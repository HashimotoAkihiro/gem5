\hypertarget{classDRAMCtrl}{
\section{クラス DRAMCtrl}
\label{classDRAMCtrl}\index{DRAMCtrl@{DRAMCtrl}}
}


{\ttfamily \#include $<$dram\_\-ctrl.hh$>$}DRAMCtrlに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=6cm]{classDRAMCtrl}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classDRAMCtrl_1_1AddrMap}{AddrMap}
\item 
class \hyperlink{classDRAMCtrl_1_1Bank}{Bank}
\item 
class \hyperlink{classDRAMCtrl_1_1BurstHelper}{BurstHelper}
\item 
class \hyperlink{classDRAMCtrl_1_1DDR3__1333__x64__DRAMSim2}{DDR3\_\-1333\_\-x64\_\-DRAMSim2}
\item 
class \hyperlink{classDRAMCtrl_1_1DDR3__1600__x64}{DDR3\_\-1600\_\-x64}
\item 
class \hyperlink{classDRAMCtrl_1_1DDR3__2133__x64}{DDR3\_\-2133\_\-x64}
\item 
class \hyperlink{classDRAMCtrl_1_1DDR4__2400__x64}{DDR4\_\-2400\_\-x64}
\item 
class \hyperlink{classDRAMCtrl_1_1DRAMCtrl}{DRAMCtrl}
\item 
class \hyperlink{classDRAMCtrl_1_1DRAMPacket}{DRAMPacket}
\item 
class \hyperlink{classDRAMCtrl_1_1LPDDR2__S4__1066__x32}{LPDDR2\_\-S4\_\-1066\_\-x32}
\item 
class \hyperlink{classDRAMCtrl_1_1LPDDR3__1600__x32}{LPDDR3\_\-1600\_\-x32}
\item 
class \hyperlink{classDRAMCtrl_1_1MemoryPort}{MemoryPort}
\item 
class \hyperlink{classDRAMCtrl_1_1MemSched}{MemSched}
\item 
class \hyperlink{classDRAMCtrl_1_1PageManage}{PageManage}
\item 
class \hyperlink{classDRAMCtrl_1_1WideIO__200__x128}{WideIO\_\-200\_\-x128}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classDRAMCtrl_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
\hyperlink{classDRAMCtrl_af86a9f0ba5b3737e1a7ba1f97dbf0e91}{DRAMCtrl} (const DRAMCtrlParams $\ast$p)
\item 
unsigned int \hyperlink{classDRAMCtrl_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)
\item 
virtual \hyperlink{classBaseSlavePort}{BaseSlavePort} \& \hyperlink{classDRAMCtrl_a4edba7d5e567b66fcd93297802a97077}{getSlavePort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
virtual void \hyperlink{classDRAMCtrl_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
virtual void \hyperlink{classDRAMCtrl_aecc7d8debf54990ffeaaed5bac7d7d81}{startup} ()
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{recvAtomic} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classDRAMCtrl_aeefa907fb6d6a787e6dab90e8138ea90}{recvFunctional} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classDRAMCtrl_a3344d9dd0f83257feab5424e761f31c6}{recvTimingReq} (\hyperlink{classPacket}{PacketPtr} pkt)
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classDRAMCtrl_a167375ed712267f43fee8fa5d1aa4f11}{BusState} \{ \hyperlink{classDRAMCtrl_a167375ed712267f43fee8fa5d1aa4f11acb9be765f361bb7efb9073730aac92c6}{READ} =  0, 
\hyperlink{classDRAMCtrl_a167375ed712267f43fee8fa5d1aa4f11a12f0259011cf4a6cf10274abcf71daaa}{READ\_\-TO\_\-WRITE}, 
\hyperlink{classDRAMCtrl_a167375ed712267f43fee8fa5d1aa4f11a61aa7ff70b76bff0fda378cf61d6afbc}{WRITE}, 
\hyperlink{classDRAMCtrl_a167375ed712267f43fee8fa5d1aa4f11ad12c9fdf4a8009963c2eb263513e4aab}{WRITE\_\-TO\_\-READ}
 \}
\item 
enum \hyperlink{classDRAMCtrl_a5f4b1f67c62d22fa4cb3ec1f98b8edf5}{RefreshState} \{ \hyperlink{classDRAMCtrl_a5f4b1f67c62d22fa4cb3ec1f98b8edf5a0408d01a98c94c06e9b5f01e52b7e4b6}{REF\_\-IDLE} =  0, 
\hyperlink{classDRAMCtrl_a5f4b1f67c62d22fa4cb3ec1f98b8edf5ad23d9d9efbe62841456648a9292a4e77}{REF\_\-DRAIN}, 
\hyperlink{classDRAMCtrl_a5f4b1f67c62d22fa4cb3ec1f98b8edf5a24272ed749c86212cfa9092585b05592}{REF\_\-PRE}, 
\hyperlink{classDRAMCtrl_a5f4b1f67c62d22fa4cb3ec1f98b8edf5a590de673c457621a7d12606a2b2360f5}{REF\_\-RUN}
 \}
\item 
enum \hyperlink{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80}{PowerState} \{ \par
\hyperlink{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80ada4f1ff35db67e1783712214c08010f2}{PWR\_\-IDLE} =  0, 
\hyperlink{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80a96cbccc90bf08cf55fb9ce1fde8fb984}{PWR\_\-REF}, 
\hyperlink{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80ad70441288ec3dbe4fb80e814a1342f18}{PWR\_\-PRE\_\-PDN}, 
\hyperlink{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80a7cdf09b08fcb323cdbd78014f98ab870}{PWR\_\-ACT}, 
\par
\hyperlink{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80acb35a2366cd70ef3f0d263d22a3f3200}{PWR\_\-ACT\_\-PDN}
 \}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classDRAMCtrl_a0798c7e6d736756005d72ec03a38badd}{processNextReqEvent} ()
\item 
void \hyperlink{classDRAMCtrl_ab4cdaf6d543d6785652264ff7ebbecac}{processRespondEvent} ()
\item 
void \hyperlink{classDRAMCtrl_ac54213c91d7d83dfe481534b1f165391}{processActivateEvent} ()
\item 
void \hyperlink{classDRAMCtrl_aac7163c120622a5f0bcc2291bc3054cd}{processPrechargeEvent} ()
\item 
void \hyperlink{classDRAMCtrl_a56cadd2563b7704b3af145a6a9f5e6ea}{processRefreshEvent} ()
\item 
void \hyperlink{classDRAMCtrl_a969289183ebadcc99a8dd9f63120b4eb}{processPowerEvent} ()
\item 
bool \hyperlink{classDRAMCtrl_a865d7144c26ea7f206d937e12935f840}{readQueueFull} (unsigned int pktCount) const 
\item 
bool \hyperlink{classDRAMCtrl_a34f56ea41ba7accf7b75a46aa79b560c}{writeQueueFull} (unsigned int pktCount) const 
\item 
void \hyperlink{classDRAMCtrl_ac224a72395d7f9bea08435f4aee435df}{addToReadQueue} (\hyperlink{classPacket}{PacketPtr} pkt, unsigned int pktCount)
\item 
void \hyperlink{classDRAMCtrl_a9538c5891b7139a62cffe6cbd7853b9a}{addToWriteQueue} (\hyperlink{classPacket}{PacketPtr} pkt, unsigned int pktCount)
\item 
void \hyperlink{classDRAMCtrl_a981a4462a622304ff598af5a232d7dd5}{doDRAMAccess} (\hyperlink{classDRAMCtrl_1_1DRAMPacket}{DRAMPacket} $\ast$dram\_\-pkt)
\item 
void \hyperlink{classDRAMCtrl_aa10846589da1206d0047f6b82c2814e4}{accessAndRespond} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} static\_\-latency)
\item 
\hyperlink{classDRAMCtrl_1_1DRAMPacket}{DRAMPacket} $\ast$ \hyperlink{classDRAMCtrl_a6d379162bc91622a9b1f1bdf82e062cc}{decodeAddr} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} dramPktAddr, unsigned int size, bool isRead)
\item 
void \hyperlink{classDRAMCtrl_a45c15f5a90be2e23d6bde9f706db7f24}{chooseNext} (\hyperlink{classstd_1_1deque}{std::deque}$<$ \hyperlink{classDRAMCtrl_1_1DRAMPacket}{DRAMPacket} $\ast$ $>$ \&queue)
\item 
void \hyperlink{classDRAMCtrl_aabfe6aa48e67d5b5c21e77dfa8a7e965}{reorderQueue} (\hyperlink{classstd_1_1deque}{std::deque}$<$ \hyperlink{classDRAMCtrl_1_1DRAMPacket}{DRAMPacket} $\ast$ $>$ \&queue)
\item 
uint64\_\-t \hyperlink{classDRAMCtrl_a29301d0e29279a6e233f15c13959b0de}{minBankActAt} (const \hyperlink{classstd_1_1deque}{std::deque}$<$ \hyperlink{classDRAMCtrl_1_1DRAMPacket}{DRAMPacket} $\ast$ $>$ \&queue) const 
\item 
void \hyperlink{classDRAMCtrl_a98181e99df633f767f5116fe80e92042}{activateBank} (\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} act\_\-tick, uint8\_\-t rank, uint8\_\-t bank, uint16\_\-t row, \hyperlink{classDRAMCtrl_1_1Bank}{Bank} \&bank\_\-ref)
\item 
void \hyperlink{classDRAMCtrl_ae75715461eec20eff07a532c11c3d54c}{prechargeBank} (\hyperlink{classDRAMCtrl_1_1Bank}{Bank} \&bank, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} pre\_\-at)
\item 
void \hyperlink{classDRAMCtrl_a3c5f01de2fe3a6826581f3641cac2ba7}{printQs} () const 
\item 
void \hyperlink{classDRAMCtrl_a233880f1f4b8f6455a2ff083dda871d3}{schedulePowerEvent} (\hyperlink{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80}{PowerState} pwr\_\-state, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classClockedObject_a4daae57fbf09ee5423d123f5ce330e92}{tick})
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDRAMCtrl_1_1MemoryPort}{MemoryPort} \hyperlink{classDRAMCtrl_a55c076720c982014096b57cadebf9a14}{port}
\item 
bool \hyperlink{classDRAMCtrl_aa4e05579e39e0e1ae7859ddba8538932}{retryRdReq}
\item 
bool \hyperlink{classDRAMCtrl_acf0d3616b5317008b8248aa2245df220}{retryWrReq}
\item 
\hyperlink{classDRAMCtrl_a167375ed712267f43fee8fa5d1aa4f11}{BusState} \hyperlink{classDRAMCtrl_a898cc5ed4c5a9ec9c13dbe52d1ea0eb2}{busState}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classstd_1_1deque}{std::deque}$<$ \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} $>$ $>$ \hyperlink{classDRAMCtrl_a4a4e224ac2ca35b6d47a3ff850e1ff3e}{actTicks}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classDRAMCtrl_1_1DRAMCtrl}{DRAMCtrl},\&DRAMCtrl::processNextReqEvent $>$ \hyperlink{classDRAMCtrl_a6f6c894e157329404d6b23503c4fa62e}{nextReqEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classDRAMCtrl_1_1DRAMCtrl}{DRAMCtrl},\&DRAMCtrl::processRespondEvent $>$ \hyperlink{classDRAMCtrl_a31bec941f92f261930a6df5cf9fb166e}{respondEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classDRAMCtrl_1_1DRAMCtrl}{DRAMCtrl},\&DRAMCtrl::processActivateEvent $>$ \hyperlink{classDRAMCtrl_ad15dbdabb028b909655b32ab9e322e50}{activateEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classDRAMCtrl_1_1DRAMCtrl}{DRAMCtrl},\&DRAMCtrl::processPrechargeEvent $>$ \hyperlink{classDRAMCtrl_a80cac8f63f85f5c7781367b8b728750f}{prechargeEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classDRAMCtrl_1_1DRAMCtrl}{DRAMCtrl},\&DRAMCtrl::processRefreshEvent $>$ \hyperlink{classDRAMCtrl_a0bc8ce4f4a849871eb32bd983b5d2843}{refreshEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classDRAMCtrl_1_1DRAMCtrl}{DRAMCtrl},\&DRAMCtrl::processPowerEvent $>$ \hyperlink{classDRAMCtrl_afb2cbddd4a31e9a3b11886230f18f44b}{powerEvent}
\item 
\hyperlink{classstd_1_1deque}{std::deque}$<$ \hyperlink{classDRAMCtrl_1_1DRAMPacket}{DRAMPacket} $\ast$ $>$ \hyperlink{classDRAMCtrl_af799cb4e1a6e82bcb68ff9354bdf6876}{readQueue}
\item 
\hyperlink{classstd_1_1deque}{std::deque}$<$ \hyperlink{classDRAMCtrl_1_1DRAMPacket}{DRAMPacket} $\ast$ $>$ \hyperlink{classDRAMCtrl_a3286652a16bd92e1fd02c6a5f42b83a1}{writeQueue}
\item 
\hyperlink{classstd_1_1deque}{std::deque}$<$ \hyperlink{classDRAMCtrl_1_1DRAMPacket}{DRAMPacket} $\ast$ $>$ \hyperlink{classDRAMCtrl_a04637ab08ad048aa826537a67dba4654}{respQueue}
\item 
\hyperlink{classDrainManager}{DrainManager} $\ast$ \hyperlink{classDRAMCtrl_a329b71fb934a93312ca0aacbf5a3f982}{drainManager}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classDRAMCtrl_1_1Bank}{Bank} $>$ $>$ \hyperlink{classDRAMCtrl_ac4dd7a78e52bcaca6fb18d24b45bb7f3}{banks}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_a9b8ba3e3a3cc11b904cd1b70e7a40ea5}{deviceBusWidth}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_a7ac4e4b031082616f09700ea29168920}{burstLength}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_afdaeeb74e1622ca1cc0f00dcf937a3b0}{deviceRowBufferSize}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_a962c654402093dcbdd4b40fd32c0de69}{devicesPerRank}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_aed1f7024fc9eeb4654afe54d86683d76}{burstSize}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_abe6f704496dadf8c0b246eb57b4e25d5}{rowBufferSize}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_a1f84aad3340018bfb3c46ace200df8cb}{columnsPerRowBuffer}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_afb57a2b8af54b8949b2c14434c74bd98}{ranksPerChannel}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_abd3ef09f9d5c70e15763a9761c8a14ca}{banksPerRank}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_a2fa7bea53e9bf8fb52623b494d814d30}{channels}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_ad878fffffe428b1673a17f489f5a4e94}{rowsPerBank}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_a7a26078fba8217391c336c615ce8ab69}{readBufferSize}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_ae1cedccfe0fe11c2bd10c28f4be1ea63}{writeBufferSize}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_a61f48157d680c1ddf7dd818c9008dd53}{writeHighThreshold}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_a803b97da34c3b40357123d5713e6ab4a}{writeLowThreshold}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_a2753a60747e9836fe5f5fec7b613385c}{minWritesPerSwitch}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_a332d2848d0e28912ff8b0c8c9e09842a}{writesThisTime}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_a72f27fd33d5f9c72099763cf6c518b87}{readsThisTime}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_a9cd12bc6d433964d98ff2386c03e5246}{tCK}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_a33aeea1fd32ea7035fc8ca3a32f75473}{tWTR}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_a578e383b38a4b65988799b3c16c4c17d}{tRTW}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_a15520c5298cfcc33032b7f0e363f7a3d}{tBURST}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_a482d43285a450eeb021dcb7065741b33}{tRCD}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_a96c42cd586bf995db505fbb5c0252ac1}{tCL}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_aa3828096d625ef4b6b497ce02b3fac85}{tRP}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_a91e2a0dae0024646d5cf40c844996bcc}{tRAS}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_a3c3ee9ca057928cc876fc54a20356535}{tWR}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_a850e39d6fd527d4992315e86a8978292}{tRTP}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_ada7c680f071957137175c60c125b929a}{tRFC}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_a2082aad1296022a7ff2d7b1a95bae882}{tREFI}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_ac09c7763d97a33e93c89f266ed29df29}{tRRD}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_a32fe8eab168b3a01214255fde6091e0b}{tXAW}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_aba56ec7c49633bf73f29b24ff6a18b38}{activationLimit}
\item 
Enums::MemSched \hyperlink{classDRAMCtrl_a77153a963ea47f1f424595cbc94461e7}{memSchedPolicy}
\item 
Enums::AddrMap \hyperlink{classDRAMCtrl_a39c22fc32946a97479fd50b6d4db1ed0}{addrMapping}
\item 
Enums::PageManage \hyperlink{classDRAMCtrl_a0ad0ee34c37f7b1694ad9aa4495c2c0f}{pageMgmt}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classDRAMCtrl_ab0ff1e80c0fcb937ef53eee0175cbd13}{maxAccessesPerRow}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_ad88c33e41f0bdc247328c7420c515f30}{frontendLatency}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_af7b0d4000762b26f57e6bdbbdf45cf6d}{backendLatency}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_a0a423ce73b4c78a0da7ce4ad9e60add6}{busBusyUntil}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_adee1f5c3afbe3ccf89880cde10ff9478}{refreshDueAt}
\item 
\hyperlink{classDRAMCtrl_a5f4b1f67c62d22fa4cb3ec1f98b8edf5}{RefreshState} \hyperlink{classDRAMCtrl_aa74cbca6192755f3cec9950a97c90342}{refreshState}
\item 
\hyperlink{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80}{PowerState} \hyperlink{classDRAMCtrl_ab31f48c472ee16c28fc62b8be41b740e}{pwrStateTrans}
\item 
\hyperlink{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80}{PowerState} \hyperlink{classDRAMCtrl_a9c9c5adc18a56a35103536d6afddfd5f}{pwrState}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_ae3e56b38f5969512cd915824ec1d5740}{prevArrival}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_a61a2436b0d2ca4872e69f76fecaeca7f}{nextReqTime}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_a8baa6fa0f23d432bebbbf1f3845c9cd5}{readReqs}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_afb65580143c89e0011c2878c20e8ed0a}{writeReqs}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_a342b92d18cc1b861071c5b596f127de8}{readBursts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_a14baa61a63ebc1c4ce4aa1930aa9ba50}{writeBursts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_a4409b60f101f8ea21148966043864074}{bytesReadDRAM}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_ae2ea884ed0a7e793cabc56748b833ed2}{bytesReadWrQ}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_a98c4533d0a7053d00f6882f984ebdaef}{bytesWritten}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_afd688f67c6a876a7b272e2ec9221fc8f}{bytesReadSys}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_acaf3b49004885b5bc8d40fef342c14c1}{bytesWrittenSys}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_a234c092fa122ea27676236c3b6f11bcb}{servicedByWrQ}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_accaed2ab83bb63d6ddff7bfa861ea537}{mergedWrBursts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_a10a3647b9ff175594214578eece1e1f7}{neitherReadNorWrite}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDRAMCtrl_a1a6c6b88a19805ae5453e5811633f884}{perBankRdBursts}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDRAMCtrl_ae757d149b2ff05a908b6ceb28f53decc}{perBankWrBursts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_acc056895269ee73447f6e9d814a22319}{numRdRetry}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_a961b9dc82d0ef2814dbdbc498a20e9b3}{numWrRetry}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_ad5c827068947b103cac8503aa45cf6e5}{totGap}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDRAMCtrl_aee4577f07fe67bcc60ba3c504b35c9f3}{readPktSize}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDRAMCtrl_aecc027383223e3500a37a9646607df81}{writePktSize}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDRAMCtrl_a34cdc0482a9faf13f94abb3a37fa90b8}{rdQLenPdf}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDRAMCtrl_ace3009d78850dc82f90724de8df96227}{wrQLenPdf}
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \hyperlink{classDRAMCtrl_a097e6ef9437eaed0d05c3d0881455b1a}{bytesPerActivate}
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \hyperlink{classDRAMCtrl_aff56c8c0df213e51ad714cb2b0df2de3}{rdPerTurnAround}
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \hyperlink{classDRAMCtrl_a6f8f6528076f5f3f9d56b7658368a781}{wrPerTurnAround}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_a3eea84ec922ff55ae38676da7222cd01}{totQLat}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_a9aa73ba3e536064d1686b6489e57a4bf}{totMemAccLat}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_abbb23dd61d5f4a897a59ea51328ad3fd}{totBusLat}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDRAMCtrl_ad594e3077a6ad256f07ab26b96b34c5f}{avgQLat}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDRAMCtrl_ad2f8163270cbb3392f2e10fb6c4f78c4}{avgBusLat}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDRAMCtrl_ac7abb815f3daf254a44904528d4e816b}{avgMemAccLat}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDRAMCtrl_a28dfaaa96a94257709a4f53f65ff6de8}{avgRdBW}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDRAMCtrl_a286267c923c741d2fb82bdf8e76ed309}{avgWrBW}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDRAMCtrl_a22abe27ebad6f2dff8823abcbfd821b8}{avgRdBWSys}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDRAMCtrl_ab3ccc99d9b3a33a2783095e6299af1d8}{avgWrBWSys}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDRAMCtrl_af80252f1fcfad371b526eac5f9bf7e4f}{peakBW}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDRAMCtrl_a32757323249e0ec2fd96e77d543fc60d}{busUtil}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDRAMCtrl_a578cf14141a41ca0c302331cf1641d4a}{busUtilRead}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDRAMCtrl_a414d3be953606d246b346cc75032e7d5}{busUtilWrite}
\item 
\hyperlink{classStats_1_1Average}{Stats::Average} \hyperlink{classDRAMCtrl_ab0f0022a38b8ccefd6d4d17ed434fcea}{avgRdQLen}
\item 
\hyperlink{classStats_1_1Average}{Stats::Average} \hyperlink{classDRAMCtrl_a4cdec63bcb455cfe5f1d8e6db40b66f5}{avgWrQLen}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_a7f3862d0c1944536c2ec30b0d012e288}{readRowHits}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDRAMCtrl_a5b75e7220ef0da8a50fe5777a9a1ae52}{writeRowHits}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDRAMCtrl_a085bc7747d9a41218a9de406bf814c64}{readRowHitRate}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDRAMCtrl_ae193ec834aceec0ed536dc53ec409f22}{writeRowHitRate}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDRAMCtrl_ab29b83e3d43dd519d59172a842b673a3}{avgGap}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDRAMCtrl_a8ec7f3dd4d238e4283760a15dc16c965}{pageHitRate}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDRAMCtrl_ad084b0fe354d053d0f369a72b8559291}{pwrStateTime}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_a06e80ba25d388ee981f9c88e27e189df}{pwrStateTick}
\item 
unsigned int \hyperlink{classDRAMCtrl_a2742d81312b2f4e257aaa3690989bc88}{numBanksActive}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classPacket}{PacketPtr} $>$ \hyperlink{classDRAMCtrl_a21da4bea3554874b557428e4cce5d4a4}{pendingDelete}
\end{DoxyCompactItemize}


\subsection{説明}
The DRAM controller is a basic single-\/channel memory controller aiming to mimic a high-\/level DRAM controller and the most important timing constraints associated with the DRAM. The focus is really on modelling the impact on the system rather than the DRAM itself, hence the focus is on the controller model and not on the memory. By adhering to the correct timing constraints, ultimately there is no need for a memory model in addition to the controller model.

As a basic design principle, this controller is not cycle callable, but instead uses events to decide when new decisions can be made, when resources become available, when things are to be considered done, and when to send things back. Through these simple principles, we achieve a performant model that is not cycle-\/accurate, but enables us to evaluate the system impact of a wide range of memory technologies, and also collect statistics about the use of the memory. 

\subsection{列挙型}
\hypertarget{classDRAMCtrl_a167375ed712267f43fee8fa5d1aa4f11}{
\index{DRAMCtrl@{DRAMCtrl}!BusState@{BusState}}
\index{BusState@{BusState}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{BusState}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf BusState}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a167375ed712267f43fee8fa5d1aa4f11}
\hyperlink{namespaceBus}{Bus} state used to control the read/write switching and drive the scheduling of the next request. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{READ@{READ}!DRAMCtrl@{DRAMCtrl}}\index{DRAMCtrl@{DRAMCtrl}!READ@{READ}}\item[{\em 
\hypertarget{classDRAMCtrl_a167375ed712267f43fee8fa5d1aa4f11acb9be765f361bb7efb9073730aac92c6}{
READ}
\label{classDRAMCtrl_a167375ed712267f43fee8fa5d1aa4f11acb9be765f361bb7efb9073730aac92c6}
}]\index{READ\_\-TO\_\-WRITE@{READ\_\-TO\_\-WRITE}!DRAMCtrl@{DRAMCtrl}}\index{DRAMCtrl@{DRAMCtrl}!READ\_\-TO\_\-WRITE@{READ\_\-TO\_\-WRITE}}\item[{\em 
\hypertarget{classDRAMCtrl_a167375ed712267f43fee8fa5d1aa4f11a12f0259011cf4a6cf10274abcf71daaa}{
READ\_\-TO\_\-WRITE}
\label{classDRAMCtrl_a167375ed712267f43fee8fa5d1aa4f11a12f0259011cf4a6cf10274abcf71daaa}
}]\index{WRITE@{WRITE}!DRAMCtrl@{DRAMCtrl}}\index{DRAMCtrl@{DRAMCtrl}!WRITE@{WRITE}}\item[{\em 
\hypertarget{classDRAMCtrl_a167375ed712267f43fee8fa5d1aa4f11a61aa7ff70b76bff0fda378cf61d6afbc}{
WRITE}
\label{classDRAMCtrl_a167375ed712267f43fee8fa5d1aa4f11a61aa7ff70b76bff0fda378cf61d6afbc}
}]\index{WRITE\_\-TO\_\-READ@{WRITE\_\-TO\_\-READ}!DRAMCtrl@{DRAMCtrl}}\index{DRAMCtrl@{DRAMCtrl}!WRITE\_\-TO\_\-READ@{WRITE\_\-TO\_\-READ}}\item[{\em 
\hypertarget{classDRAMCtrl_a167375ed712267f43fee8fa5d1aa4f11ad12c9fdf4a8009963c2eb263513e4aab}{
WRITE\_\-TO\_\-READ}
\label{classDRAMCtrl_a167375ed712267f43fee8fa5d1aa4f11ad12c9fdf4a8009963c2eb263513e4aab}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
128                   {
129         READ = 0,
130         READ_TO_WRITE,
131         WRITE,
132         WRITE_TO_READ
133     };
\end{DoxyCode}
\hypertarget{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80}{
\index{DRAMCtrl@{DRAMCtrl}!PowerState@{PowerState}}
\index{PowerState@{PowerState}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{PowerState}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf PowerState}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80}
The power state captures the different operational states of the DRAM and interacts with the bus read/write state machine, and the refresh state machine. In the idle state all banks are precharged. From there we either go to an auto refresh (as determined by the refresh state machine), or to a precharge power down mode. From idle the memory can also go to the active state (with one or more banks active), and in turn from there to active power down. At the moment we do not capture the deep power down and self-\/refresh state. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{PWR\_\-IDLE@{PWR\_\-IDLE}!DRAMCtrl@{DRAMCtrl}}\index{DRAMCtrl@{DRAMCtrl}!PWR\_\-IDLE@{PWR\_\-IDLE}}\item[{\em 
\hypertarget{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80ada4f1ff35db67e1783712214c08010f2}{
PWR\_\-IDLE}
\label{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80ada4f1ff35db67e1783712214c08010f2}
}]\index{PWR\_\-REF@{PWR\_\-REF}!DRAMCtrl@{DRAMCtrl}}\index{DRAMCtrl@{DRAMCtrl}!PWR\_\-REF@{PWR\_\-REF}}\item[{\em 
\hypertarget{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80a96cbccc90bf08cf55fb9ce1fde8fb984}{
PWR\_\-REF}
\label{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80a96cbccc90bf08cf55fb9ce1fde8fb984}
}]\index{PWR\_\-PRE\_\-PDN@{PWR\_\-PRE\_\-PDN}!DRAMCtrl@{DRAMCtrl}}\index{DRAMCtrl@{DRAMCtrl}!PWR\_\-PRE\_\-PDN@{PWR\_\-PRE\_\-PDN}}\item[{\em 
\hypertarget{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80ad70441288ec3dbe4fb80e814a1342f18}{
PWR\_\-PRE\_\-PDN}
\label{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80ad70441288ec3dbe4fb80e814a1342f18}
}]\index{PWR\_\-ACT@{PWR\_\-ACT}!DRAMCtrl@{DRAMCtrl}}\index{DRAMCtrl@{DRAMCtrl}!PWR\_\-ACT@{PWR\_\-ACT}}\item[{\em 
\hypertarget{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80a7cdf09b08fcb323cdbd78014f98ab870}{
PWR\_\-ACT}
\label{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80a7cdf09b08fcb323cdbd78014f98ab870}
}]\index{PWR\_\-ACT\_\-PDN@{PWR\_\-ACT\_\-PDN}!DRAMCtrl@{DRAMCtrl}}\index{DRAMCtrl@{DRAMCtrl}!PWR\_\-ACT\_\-PDN@{PWR\_\-ACT\_\-PDN}}\item[{\em 
\hypertarget{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80acb35a2366cd70ef3f0d263d22a3f3200}{
PWR\_\-ACT\_\-PDN}
\label{classDRAMCtrl_aa59b8ef6374ae587f3c228eba57bdf80acb35a2366cd70ef3f0d263d22a3f3200}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
554                     {
555         PWR_IDLE = 0,
556         PWR_REF,
557         PWR_PRE_PDN,
558         PWR_ACT,
559         PWR_ACT_PDN
560     };
\end{DoxyCode}
\hypertarget{classDRAMCtrl_a5f4b1f67c62d22fa4cb3ec1f98b8edf5}{
\index{DRAMCtrl@{DRAMCtrl}!RefreshState@{RefreshState}}
\index{RefreshState@{RefreshState}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{RefreshState}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf RefreshState}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a5f4b1f67c62d22fa4cb3ec1f98b8edf5}
The refresh state is used to control the progress of the refresh scheduling. When normal operation is in progress the refresh state is idle. From there, it progresses to the refresh drain state once tREFI has passed. The refresh drain state captures the DRAM row active state, as it will stay there until all ongoing accesses complete. Thereafter all banks are precharged, and lastly, the DRAM is refreshed. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{REF\_\-IDLE@{REF\_\-IDLE}!DRAMCtrl@{DRAMCtrl}}\index{DRAMCtrl@{DRAMCtrl}!REF\_\-IDLE@{REF\_\-IDLE}}\item[{\em 
\hypertarget{classDRAMCtrl_a5f4b1f67c62d22fa4cb3ec1f98b8edf5a0408d01a98c94c06e9b5f01e52b7e4b6}{
REF\_\-IDLE}
\label{classDRAMCtrl_a5f4b1f67c62d22fa4cb3ec1f98b8edf5a0408d01a98c94c06e9b5f01e52b7e4b6}
}]\index{REF\_\-DRAIN@{REF\_\-DRAIN}!DRAMCtrl@{DRAMCtrl}}\index{DRAMCtrl@{DRAMCtrl}!REF\_\-DRAIN@{REF\_\-DRAIN}}\item[{\em 
\hypertarget{classDRAMCtrl_a5f4b1f67c62d22fa4cb3ec1f98b8edf5ad23d9d9efbe62841456648a9292a4e77}{
REF\_\-DRAIN}
\label{classDRAMCtrl_a5f4b1f67c62d22fa4cb3ec1f98b8edf5ad23d9d9efbe62841456648a9292a4e77}
}]\index{REF\_\-PRE@{REF\_\-PRE}!DRAMCtrl@{DRAMCtrl}}\index{DRAMCtrl@{DRAMCtrl}!REF\_\-PRE@{REF\_\-PRE}}\item[{\em 
\hypertarget{classDRAMCtrl_a5f4b1f67c62d22fa4cb3ec1f98b8edf5a24272ed749c86212cfa9092585b05592}{
REF\_\-PRE}
\label{classDRAMCtrl_a5f4b1f67c62d22fa4cb3ec1f98b8edf5a24272ed749c86212cfa9092585b05592}
}]\index{REF\_\-RUN@{REF\_\-RUN}!DRAMCtrl@{DRAMCtrl}}\index{DRAMCtrl@{DRAMCtrl}!REF\_\-RUN@{REF\_\-RUN}}\item[{\em 
\hypertarget{classDRAMCtrl_a5f4b1f67c62d22fa4cb3ec1f98b8edf5a590de673c457621a7d12606a2b2360f5}{
REF\_\-RUN}
\label{classDRAMCtrl_a5f4b1f67c62d22fa4cb3ec1f98b8edf5a590de673c457621a7d12606a2b2360f5}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
534                       {
535         REF_IDLE = 0,
536         REF_DRAIN,
537         REF_PRE,
538         REF_RUN
539     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classDRAMCtrl_af86a9f0ba5b3737e1a7ba1f97dbf0e91}{
\index{DRAMCtrl@{DRAMCtrl}!DRAMCtrl@{DRAMCtrl}}
\index{DRAMCtrl@{DRAMCtrl}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{DRAMCtrl}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DRAMCtrl} (const DRAMCtrlParams $\ast$ {\em p})}}
\label{classDRAMCtrl_af86a9f0ba5b3737e1a7ba1f97dbf0e91}



\begin{DoxyCode}
55                                           :
56     AbstractMemory(p),
57     port(name() + ".port", *this),
58     retryRdReq(false), retryWrReq(false),
59     busState(READ),
60     nextReqEvent(this), respondEvent(this), activateEvent(this),
61     prechargeEvent(this), refreshEvent(this), powerEvent(this),
62     drainManager(NULL),
63     deviceBusWidth(p->device_bus_width), burstLength(p->burst_length),
64     deviceRowBufferSize(p->device_rowbuffer_size),
65     devicesPerRank(p->devices_per_rank),
66     burstSize((devicesPerRank * burstLength * deviceBusWidth) / 8),
67     rowBufferSize(devicesPerRank * deviceRowBufferSize),
68     columnsPerRowBuffer(rowBufferSize / burstSize),
69     ranksPerChannel(p->ranks_per_channel),
70     banksPerRank(p->banks_per_rank), channels(p->channels), rowsPerBank(0),
71     readBufferSize(p->read_buffer_size),
72     writeBufferSize(p->write_buffer_size),
73     writeHighThreshold(writeBufferSize * p->write_high_thresh_perc / 100.0),
74     writeLowThreshold(writeBufferSize * p->write_low_thresh_perc / 100.0),
75     minWritesPerSwitch(p->min_writes_per_switch),
76     writesThisTime(0), readsThisTime(0),
77     tCK(p->tCK), tWTR(p->tWTR), tRTW(p->tRTW), tBURST(p->tBURST),
78     tRCD(p->tRCD), tCL(p->tCL), tRP(p->tRP), tRAS(p->tRAS), tWR(p->tWR),
79     tRTP(p->tRTP), tRFC(p->tRFC), tREFI(p->tREFI), tRRD(p->tRRD),
80     tXAW(p->tXAW), activationLimit(p->activation_limit),
81     memSchedPolicy(p->mem_sched_policy), addrMapping(p->addr_mapping),
82     pageMgmt(p->page_policy),
83     maxAccessesPerRow(p->max_accesses_per_row),
84     frontendLatency(p->static_frontend_latency),
85     backendLatency(p->static_backend_latency),
86     busBusyUntil(0), refreshDueAt(0), refreshState(REF_IDLE),
87     pwrStateTrans(PWR_IDLE), pwrState(PWR_IDLE), prevArrival(0),
88     nextReqTime(0), pwrStateTick(0), numBanksActive(0)
89 {
90     // create the bank states based on the dimensions of the ranks and
91     // banks
92     banks.resize(ranksPerChannel);
93     actTicks.resize(ranksPerChannel);
94     for (size_t c = 0; c < ranksPerChannel; ++c) {
95         banks[c].resize(banksPerRank);
96         actTicks[c].resize(activationLimit, 0);
97     }
98 
99     // perform a basic check of the write thresholds
100     if (p->write_low_thresh_perc >= p->write_high_thresh_perc)
101         fatal("Write buffer low threshold %d must be smaller than the "
102               "high threshold %d\n", p->write_low_thresh_perc,
103               p->write_high_thresh_perc);
104 
105     // determine the rows per bank by looking at the total capacity
106     uint64_t capacity = ULL(1) << ceilLog2(AbstractMemory::size());
107 
108     DPRINTF(DRAM, "Memory capacity %lld (%lld) bytes\n", capacity,
109             AbstractMemory::size());
110 
111     DPRINTF(DRAM, "Row buffer size %d bytes with %d columns per row buffer\n",
112             rowBufferSize, columnsPerRowBuffer);
113 
114     rowsPerBank = capacity / (rowBufferSize * banksPerRank * ranksPerChannel);
115 
116     if (range.interleaved()) {
117         if (channels != range.stripes())
118             fatal("%s has %d interleaved address stripes but %d channel(s)\n",
119                   name(), range.stripes(), channels);
120 
121         if (addrMapping == Enums::RoRaBaChCo) {
122             if (rowBufferSize != range.granularity()) {
123                 fatal("Interleaving of %s doesn't match RoRaBaChCo "
124                       "address map\n", name());
125             }
126         } else if (addrMapping == Enums::RoRaBaCoCh) {
127             if (system()->cacheLineSize() != range.granularity()) {
128                 fatal("Interleaving of %s doesn't match RoRaBaCoCh "
129                       "address map\n", name());
130             }
131         } else if (addrMapping == Enums::RoCoRaBaCh) {
132             if (system()->cacheLineSize() != range.granularity())
133                 fatal("Interleaving of %s doesn't match RoCoRaBaCh "
134                       "address map\n", name());
135         }
136     }
137 
138     // some basic sanity checks
139     if (tREFI <= tRP || tREFI <= tRFC) {
140         fatal("tREFI (%d) must be larger than tRP (%d) and tRFC (%d)\n",
141               tREFI, tRP, tRFC);
142     }
143 }

\end{DoxyCode}


\subsection{関数}
\hypertarget{classDRAMCtrl_aa10846589da1206d0047f6b82c2814e4}{
\index{DRAMCtrl@{DRAMCtrl}!accessAndRespond@{accessAndRespond}}
\index{accessAndRespond@{accessAndRespond}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{accessAndRespond}]{\setlength{\rightskip}{0pt plus 5cm}void accessAndRespond ({\bf PacketPtr} {\em pkt}, \/  {\bf Tick} {\em static\_\-latency})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_aa10846589da1206d0047f6b82c2814e4}
When a packet reaches its \char`\"{}readyTime\char`\"{} in the response Q, use the \char`\"{}access()\char`\"{} method in \hyperlink{classAbstractMemory}{AbstractMemory} to actually create the response packet, and send it back to the outside world requestor.


\begin{DoxyParams}{引数}
\item[{\em pkt}]The packet from the outside world \item[{\em static\_\-latency}]Static latency to add before sending the packet \end{DoxyParams}



\begin{DoxyCode}
721 {
722     DPRINTF(DRAM, "Responding to Address %lld.. ",pkt->getAddr());
723 
724     bool needsResponse = pkt->needsResponse();
725     // do the actual memory access which also turns the packet into a
726     // response
727     access(pkt);
728 
729     // turn packet around to go back to requester if response expected
730     if (needsResponse) {
731         // access already turned the packet into a response
732         assert(pkt->isResponse());
733 
734         // @todo someone should pay for this
735         pkt->busFirstWordDelay = pkt->busLastWordDelay = 0;
736 
737         // queue the packet in the response queue to be sent out after
738         // the static latency has passed
739         port.schedTimingResp(pkt, curTick() + static_latency);
740     } else {
741         // @todo the packet is going to be deleted, and the DRAMPacket
742         // is still having a pointer to it
743         pendingDelete.push_back(pkt);
744     }
745 
746     DPRINTF(DRAM, "Done\n");
747 
748     return;
749 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_a98181e99df633f767f5116fe80e92042}{
\index{DRAMCtrl@{DRAMCtrl}!activateBank@{activateBank}}
\index{activateBank@{activateBank}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{activateBank}]{\setlength{\rightskip}{0pt plus 5cm}void activateBank ({\bf Tick} {\em act\_\-tick}, \/  uint8\_\-t {\em rank}, \/  uint8\_\-t {\em bank}, \/  uint16\_\-t {\em row}, \/  {\bf Bank} \& {\em bank\_\-ref})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a98181e99df633f767f5116fe80e92042}
Keep track of when row activations happen, in order to enforce the maximum number of activations in the activation window. The method updates the time that the banks become available based on the current limits.


\begin{DoxyParams}{引数}
\item[{\em act\_\-tick}]\hyperlink{classTime}{Time} when the activation takes place \item[{\em rank}]Index of the rank \item[{\em bank}]Index of the bank \item[{\em row}]Index of the row \item[{\em bank\_\-ref}]Reference to the bank \end{DoxyParams}



\begin{DoxyCode}
754 {
755     assert(0 <= rank && rank < ranksPerChannel);
756     assert(actTicks[rank].size() == activationLimit);
757 
758     DPRINTF(DRAM, "Activate at tick %d\n", act_tick);
759 
760     // update the open row
761     assert(bank_ref.openRow == Bank::NO_ROW);
762     bank_ref.openRow = row;
763 
764     // start counting anew, this covers both the case when we
765     // auto-precharged, and when this access is forced to
766     // precharge
767     bank_ref.bytesAccessed = 0;
768     bank_ref.rowAccesses = 0;
769 
770     ++numBanksActive;
771     assert(numBanksActive <= banksPerRank * ranksPerChannel);
772 
773     DPRINTF(DRAM, "Activate bank at tick %lld, now got %d active\n",
774             act_tick, numBanksActive);
775 
776     // The next access has to respect tRAS for this bank
777     bank_ref.preAllowedAt = act_tick + tRAS;
778 
779     // Respect the row-to-column command delay
780     bank_ref.colAllowedAt = act_tick + tRCD;
781 
782     // start by enforcing tRRD
783     for(int i = 0; i < banksPerRank; i++) {
784         // next activate to any bank in this rank must not happen
785         // before tRRD
786         banks[rank][i].actAllowedAt = std::max(act_tick + tRRD,
787                                                banks[rank][i].actAllowedAt);
788     }
789 
790     // next, we deal with tXAW, if the activation limit is disabled
791     // then we are done
792     if (actTicks[rank].empty())
793         return;
794 
795     // sanity check
796     if (actTicks[rank].back() && (act_tick - actTicks[rank].back()) < tXAW) {
797         panic("Got %d activates in window %d (%llu - %llu) which is smaller "
798               "than %llu\n", activationLimit, act_tick - actTicks[rank].back(),
799               act_tick, actTicks[rank].back(), tXAW);
800     }
801 
802     // shift the times used for the book keeping, the last element
803     // (highest index) is the oldest one and hence the lowest value
804     actTicks[rank].pop_back();
805 
806     // record an new activation (in the future)
807     actTicks[rank].push_front(act_tick);
808 
809     // cannot activate more than X times in time window tXAW, push the
810     // next one (the X + 1'st activate) to be tXAW away from the
811     // oldest in our window of X
812     if (actTicks[rank].back() && (act_tick - actTicks[rank].back()) < tXAW) {
813         DPRINTF(DRAM, "Enforcing tXAW with X = %d, next activate no earlier "
814                 "than %llu\n", activationLimit, actTicks[rank].back() + tXAW);
815             for(int j = 0; j < banksPerRank; j++)
816                 // next activate must not happen before end of window
817                 banks[rank][j].actAllowedAt =
818                     std::max(actTicks[rank].back() + tXAW,
819                              banks[rank][j].actAllowedAt);
820     }
821 
822     // at the point when this activate takes place, make sure we
823     // transition to the active power state
824     if (!activateEvent.scheduled())
825         schedule(activateEvent, act_tick);
826     else if (activateEvent.when() > act_tick)
827         // move it sooner in time
828         reschedule(activateEvent, act_tick);
829 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_ac224a72395d7f9bea08435f4aee435df}{
\index{DRAMCtrl@{DRAMCtrl}!addToReadQueue@{addToReadQueue}}
\index{addToReadQueue@{addToReadQueue}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{addToReadQueue}]{\setlength{\rightskip}{0pt plus 5cm}void addToReadQueue ({\bf PacketPtr} {\em pkt}, \/  unsigned int {\em pktCount})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ac224a72395d7f9bea08435f4aee435df}
When a new read comes in, first check if the write q has a pending request to the same address. If not, decode the address to populate rank/bank/row, create one or mutliple \char`\"{}dram\_\-pkt\char`\"{}, and push them to the back of the read queue.$\backslash$ If this is the only read request in the system, schedule an event to start servicing it.


\begin{DoxyParams}{引数}
\item[{\em pkt}]The request packet from the outside world \item[{\em pktCount}]The number of DRAM bursts the pkt translate to. If pkt size is larger then one full burst, then pktCount is greater than one. \end{DoxyParams}



\begin{DoxyCode}
311 {
312     // only add to the read queue here. whenever the request is
313     // eventually done, set the readyTime, and call schedule()
314     assert(!pkt->isWrite());
315 
316     assert(pktCount != 0);
317 
318     // if the request size is larger than burst size, the pkt is split into
319     // multiple DRAM packets
320     // Note if the pkt starting address is not aligened to burst size, the
321     // address of first DRAM packet is kept unaliged. Subsequent DRAM packets
322     // are aligned to burst size boundaries. This is to ensure we accurately
323     // check read packets against packets in write queue.
324     Addr addr = pkt->getAddr();
325     unsigned pktsServicedByWrQ = 0;
326     BurstHelper* burst_helper = NULL;
327     for (int cnt = 0; cnt < pktCount; ++cnt) {
328         unsigned size = std::min((addr | (burstSize - 1)) + 1,
329                         pkt->getAddr() + pkt->getSize()) - addr;
330         readPktSize[ceilLog2(size)]++;
331         readBursts++;
332 
333         // First check write buffer to see if the data is already at
334         // the controller
335         bool foundInWrQ = false;
336         for (auto i = writeQueue.begin(); i != writeQueue.end(); ++i) {
337             // check if the read is subsumed in the write entry we are
338             // looking at
339             if ((*i)->addr <= addr &&
340                 (addr + size) <= ((*i)->addr + (*i)->size)) {
341                 foundInWrQ = true;
342                 servicedByWrQ++;
343                 pktsServicedByWrQ++;
344                 DPRINTF(DRAM, "Read to addr %lld with size %d serviced by "
345                         "write queue\n", addr, size);
346                 bytesReadWrQ += burstSize;
347                 break;
348             }
349         }
350 
351         // If not found in the write q, make a DRAM packet and
352         // push it onto the read queue
353         if (!foundInWrQ) {
354 
355             // Make the burst helper for split packets
356             if (pktCount > 1 && burst_helper == NULL) {
357                 DPRINTF(DRAM, "Read to addr %lld translates to %d "
358                         "dram requests\n", pkt->getAddr(), pktCount);
359                 burst_helper = new BurstHelper(pktCount);
360             }
361 
362             DRAMPacket* dram_pkt = decodeAddr(pkt, addr, size, true);
363             dram_pkt->burstHelper = burst_helper;
364 
365             assert(!readQueueFull(1));
366             rdQLenPdf[readQueue.size() + respQueue.size()]++;
367 
368             DPRINTF(DRAM, "Adding to read queue\n");
369 
370             readQueue.push_back(dram_pkt);
371 
372             // Update stats
373             avgRdQLen = readQueue.size() + respQueue.size();
374         }
375 
376         // Starting address of next dram pkt (aligend to burstSize boundary)
377         addr = (addr | (burstSize - 1)) + 1;
378     }
379 
380     // If all packets are serviced by write queue, we send the repsonse back
381     if (pktsServicedByWrQ == pktCount) {
382         accessAndRespond(pkt, frontendLatency);
383         return;
384     }
385 
386     // Update how many split packets are serviced by write queue
387     if (burst_helper != NULL)
388         burst_helper->burstsServiced = pktsServicedByWrQ;
389 
390     // If we are not already scheduled to get a request out of the
391     // queue, do so now
392     if (!nextReqEvent.scheduled()) {
393         DPRINTF(DRAM, "Request scheduled immediately\n");
394         schedule(nextReqEvent, curTick());
395     }
396 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_a9538c5891b7139a62cffe6cbd7853b9a}{
\index{DRAMCtrl@{DRAMCtrl}!addToWriteQueue@{addToWriteQueue}}
\index{addToWriteQueue@{addToWriteQueue}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{addToWriteQueue}]{\setlength{\rightskip}{0pt plus 5cm}void addToWriteQueue ({\bf PacketPtr} {\em pkt}, \/  unsigned int {\em pktCount})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a9538c5891b7139a62cffe6cbd7853b9a}
Decode the incoming pkt, create a dram\_\-pkt and push to the back of the write queue.  the write q length is more than the threshold specified by the user, ie the queue is beginning to get full, stop reads, and start draining writes.


\begin{DoxyParams}{引数}
\item[{\em pkt}]The request packet from the outside world \item[{\em pktCount}]The number of DRAM bursts the pkt translate to. If pkt size is larger then one full burst, then pktCount is greater than one. \end{DoxyParams}



\begin{DoxyCode}
400 {
401     // only add to the write queue here. whenever the request is
402     // eventually done, set the readyTime, and call schedule()
403     assert(pkt->isWrite());
404 
405     // if the request size is larger than burst size, the pkt is split into
406     // multiple DRAM packets
407     Addr addr = pkt->getAddr();
408     for (int cnt = 0; cnt < pktCount; ++cnt) {
409         unsigned size = std::min((addr | (burstSize - 1)) + 1,
410                         pkt->getAddr() + pkt->getSize()) - addr;
411         writePktSize[ceilLog2(size)]++;
412         writeBursts++;
413 
414         // see if we can merge with an existing item in the write
415         // queue and keep track of whether we have merged or not so we
416         // can stop at that point and also avoid enqueueing a new
417         // request
418         bool merged = false;
419         auto w = writeQueue.begin();
420 
421         while(!merged && w != writeQueue.end()) {
422             // either of the two could be first, if they are the same
423             // it does not matter which way we go
424             if ((*w)->addr >= addr) {
425                 // the existing one starts after the new one, figure
426                 // out where the new one ends with respect to the
427                 // existing one
428                 if ((addr + size) >= ((*w)->addr + (*w)->size)) {
429                     // check if the existing one is completely
430                     // subsumed in the new one
431                     DPRINTF(DRAM, "Merging write covering existing burst\n");
432                     merged = true;
433                     // update both the address and the size
434                     (*w)->addr = addr;
435                     (*w)->size = size;
436                 } else if ((addr + size) >= (*w)->addr &&
437                            ((*w)->addr + (*w)->size - addr) <= burstSize) {
438                     // the new one is just before or partially
439                     // overlapping with the existing one, and together
440                     // they fit within a burst
441                     DPRINTF(DRAM, "Merging write before existing burst\n");
442                     merged = true;
443                     // the existing queue item needs to be adjusted with
444                     // respect to both address and size
445                     (*w)->size = (*w)->addr + (*w)->size - addr;
446                     (*w)->addr = addr;
447                 }
448             } else {
449                 // the new one starts after the current one, figure
450                 // out where the existing one ends with respect to the
451                 // new one
452                 if (((*w)->addr + (*w)->size) >= (addr + size)) {
453                     // check if the new one is completely subsumed in the
454                     // existing one
455                     DPRINTF(DRAM, "Merging write into existing burst\n");
456                     merged = true;
457                     // no adjustments necessary
458                 } else if (((*w)->addr + (*w)->size) >= addr &&
459                            (addr + size - (*w)->addr) <= burstSize) {
460                     // the existing one is just before or partially
461                     // overlapping with the new one, and together
462                     // they fit within a burst
463                     DPRINTF(DRAM, "Merging write after existing burst\n");
464                     merged = true;
465                     // the address is right, and only the size has
466                     // to be adjusted
467                     (*w)->size = addr + size - (*w)->addr;
468                 }
469             }
470             ++w;
471         }
472 
473         // if the item was not merged we need to create a new write
474         // and enqueue it
475         if (!merged) {
476             DRAMPacket* dram_pkt = decodeAddr(pkt, addr, size, false);
477 
478             assert(writeQueue.size() < writeBufferSize);
479             wrQLenPdf[writeQueue.size()]++;
480 
481             DPRINTF(DRAM, "Adding to write queue\n");
482 
483             writeQueue.push_back(dram_pkt);
484 
485             // Update stats
486             avgWrQLen = writeQueue.size();
487         } else {
488             // keep track of the fact that this burst effectively
489             // disappeared as it was merged with an existing one
490             mergedWrBursts++;
491         }
492 
493         // Starting address of next dram pkt (aligend to burstSize boundary)
494         addr = (addr | (burstSize - 1)) + 1;
495     }
496 
497     // we do not wait for the writes to be send to the actual memory,
498     // but instead take responsibility for the consistency here and
499     // snoop the write queue for any upcoming reads
500     // @todo, if a pkt size is larger than burst size, we might need a
501     // different front end latency
502     accessAndRespond(pkt, frontendLatency);
503 
504     // If we are not already scheduled to get a request out of the
505     // queue, do so now
506     if (!nextReqEvent.scheduled()) {
507         DPRINTF(DRAM, "Request scheduled immediately\n");
508         schedule(nextReqEvent, curTick());
509     }
510 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_a45c15f5a90be2e23d6bde9f706db7f24}{
\index{DRAMCtrl@{DRAMCtrl}!chooseNext@{chooseNext}}
\index{chooseNext@{chooseNext}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{chooseNext}]{\setlength{\rightskip}{0pt plus 5cm}void chooseNext ({\bf std::deque}$<$ {\bf DRAMPacket} $\ast$ $>$ \& {\em queue})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a45c15f5a90be2e23d6bde9f706db7f24}
The memory schduler/arbiter -\/ picks which request needs to go next, based on the specified policy such as FCFS or FR-\/FCFS and moves it to the head of the queue. 


\begin{DoxyCode}
651 {
652     // This method does the arbitration between requests. The chosen
653     // packet is simply moved to the head of the queue. The other
654     // methods know that this is the place to look. For example, with
655     // FCFS, this method does nothing
656     assert(!queue.empty());
657 
658     if (queue.size() == 1) {
659         DPRINTF(DRAM, "Single request, nothing to do\n");
660         return;
661     }
662 
663     if (memSchedPolicy == Enums::fcfs) {
664         // Do nothing, since the correct request is already head
665     } else if (memSchedPolicy == Enums::frfcfs) {
666         reorderQueue(queue);
667     } else
668         panic("No scheduling policy chosen\n");
669 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_a6d379162bc91622a9b1f1bdf82e062cc}{
\index{DRAMCtrl@{DRAMCtrl}!decodeAddr@{decodeAddr}}
\index{decodeAddr@{decodeAddr}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{decodeAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DRAMPacket}$\ast$ decodeAddr ({\bf PacketPtr} {\em pkt}, \/  {\bf Addr} {\em dramPktAddr}, \/  unsigned int {\em size}, \/  bool {\em isRead})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a6d379162bc91622a9b1f1bdf82e062cc}
\hyperlink{classAddress}{Address} decoder to figure out physical mapping onto ranks, banks, and rows. This function is called multiple times on the same system packet if the pakcet is larger than burst of the memory. The dramPktAddr is used for the offset within the packet.


\begin{DoxyParams}{引数}
\item[{\em pkt}]The packet from the outside world \item[{\em dramPktAddr}]The starting address of the DRAM packet \item[{\em size}]The size of the DRAM packet in bytes \item[{\em isRead}]Is the request for a read or a write to DRAM \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A \hyperlink{classDRAMCtrl_1_1DRAMPacket}{DRAMPacket} pointer with the decoded information 
\end{DoxyReturn}
\hypertarget{classDRAMCtrl_a981a4462a622304ff598af5a232d7dd5}{
\index{DRAMCtrl@{DRAMCtrl}!doDRAMAccess@{doDRAMAccess}}
\index{doDRAMAccess@{doDRAMAccess}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{doDRAMAccess}]{\setlength{\rightskip}{0pt plus 5cm}void doDRAMAccess ({\bf DRAMPacket} $\ast$ {\em dram\_\-pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a981a4462a622304ff598af5a232d7dd5}
Actually do the DRAM access -\/ figure out the latency it will take to service the req based on bank state, channel state etc and then update those states to account for this request. Based on this, update the packet's \char`\"{}readyTime\char`\"{} and move it to the response q from where it will eventually go back to the outside world.


\begin{DoxyParams}{引数}
\item[{\em pkt}]The DRAM packet created from the outside world pkt \end{DoxyParams}



\begin{DoxyCode}
892 {
893     DPRINTF(DRAM, "Timing access to addr %lld, rank/bank/row %d %d %d\n",
894             dram_pkt->addr, dram_pkt->rank, dram_pkt->bank, dram_pkt->row);
895 
896     // get the bank
897     Bank& bank = dram_pkt->bankRef;
898 
899     // for the state we need to track if it is a row hit or not
900     bool row_hit = true;
901 
902     // respect any constraints on the command (e.g. tRCD or tCCD)
903     Tick cmd_at = std::max(bank.colAllowedAt, curTick());
904 
905     // Determine the access latency and update the bank state
906     if (bank.openRow == dram_pkt->row) {
907         // nothing to do
908     } else {
909         row_hit = false;
910 
911         // If there is a page open, precharge it.
912         if (bank.openRow != Bank::NO_ROW) {
913             prechargeBank(bank, std::max(bank.preAllowedAt, curTick()));
914         }
915 
916         // next we need to account for the delay in activating the
917         // page
918         Tick act_tick = std::max(bank.actAllowedAt, curTick());
919 
920         // Record the activation and deal with all the global timing
921         // constraints caused be a new activation (tRRD and tXAW)
922         activateBank(act_tick, dram_pkt->rank, dram_pkt->bank,
923                      dram_pkt->row, bank);
924 
925         // issue the command as early as possible
926         cmd_at = bank.colAllowedAt;
927     }
928 
929     // we need to wait until the bus is available before we can issue
930     // the command
931     cmd_at = std::max(cmd_at, busBusyUntil - tCL);
932 
933     // update the packet ready time
934     dram_pkt->readyTime = cmd_at + tCL + tBURST;
935 
936     // only one burst can use the bus at any one point in time
937     assert(dram_pkt->readyTime - busBusyUntil >= tBURST);
938 
939     // not strictly necessary, but update the time for the next
940     // read/write (add a max with tCCD here)
941     bank.colAllowedAt = cmd_at + tBURST;
942 
943     // If this is a write, we also need to respect the write recovery
944     // time before a precharge, in the case of a read, respect the
945     // read to precharge constraint
946     bank.preAllowedAt = std::max(bank.preAllowedAt,
947                                  dram_pkt->isRead ? cmd_at + tRTP :
948                                  dram_pkt->readyTime + tWR);
949 
950     // increment the bytes accessed and the accesses per row
951     bank.bytesAccessed += burstSize;
952     ++bank.rowAccesses;
953 
954     // if we reached the max, then issue with an auto-precharge
955     bool auto_precharge = pageMgmt == Enums::close ||
956         bank.rowAccesses == maxAccessesPerRow;
957 
958     // if we did not hit the limit, we might still want to
959     // auto-precharge
960     if (!auto_precharge &&
961         (pageMgmt == Enums::open_adaptive ||
962          pageMgmt == Enums::close_adaptive)) {
963         // a twist on the open and close page policies:
964         // 1) open_adaptive page policy does not blindly keep the
965         // page open, but close it if there are no row hits, and there
966         // are bank conflicts in the queue
967         // 2) close_adaptive page policy does not blindly close the
968         // page, but closes it only if there are no row hits in the queue.
969         // In this case, only force an auto precharge when there
970         // are no same page hits in the queue
971         bool got_more_hits = false;
972         bool got_bank_conflict = false;
973 
974         // either look at the read queue or write queue
975         const deque<DRAMPacket*>& queue = dram_pkt->isRead ? readQueue :
976             writeQueue;
977         auto p = queue.begin();
978         // make sure we are not considering the packet that we are
979         // currently dealing with (which is the head of the queue)
980         ++p;
981 
982         // keep on looking until we have found required condition or
983         // reached the end
984         while (!(got_more_hits &&
985                  (got_bank_conflict || pageMgmt == Enums::close_adaptive)) &&
986                p != queue.end()) {
987             bool same_rank_bank = (dram_pkt->rank == (*p)->rank) &&
988                 (dram_pkt->bank == (*p)->bank);
989             bool same_row = dram_pkt->row == (*p)->row;
990             got_more_hits |= same_rank_bank && same_row;
991             got_bank_conflict |= same_rank_bank && !same_row;
992             ++p;
993         }
994 
995         // auto pre-charge when either
996         // 1) open_adaptive policy, we have not got any more hits, and
997         //    have a bank conflict
998         // 2) close_adaptive policy and we have not got any more hits
999         auto_precharge = !got_more_hits &&
1000             (got_bank_conflict || pageMgmt == Enums::close_adaptive);
1001     }
1002 
1003     // if this access should use auto-precharge, then we are
1004     // closing the row
1005     if (auto_precharge) {
1006         prechargeBank(bank, std::max(curTick(), bank.preAllowedAt));
1007 
1008         DPRINTF(DRAM, "Auto-precharged bank: %d\n", dram_pkt->bankId);
1009     }
1010 
1011     // Update bus state
1012     busBusyUntil = dram_pkt->readyTime;
1013 
1014     DPRINTF(DRAM, "Access to %lld, ready at %lld bus busy until %lld.\n",
1015             dram_pkt->addr, dram_pkt->readyTime, busBusyUntil);
1016 
1017     // Update the minimum timing between the requests, this is a
1018     // conservative estimate of when we have to schedule the next
1019     // request to not introduce any unecessary bubbles. In most cases
1020     // we will wake up sooner than we have to.
1021     nextReqTime = busBusyUntil - (tRP + tRCD + tCL);
1022 
1023     // Update the stats and schedule the next request
1024     if (dram_pkt->isRead) {
1025         ++readsThisTime;
1026         if (row_hit)
1027             readRowHits++;
1028         bytesReadDRAM += burstSize;
1029         perBankRdBursts[dram_pkt->bankId]++;
1030 
1031         // Update latency stats
1032         totMemAccLat += dram_pkt->readyTime - dram_pkt->entryTime;
1033         totBusLat += tBURST;
1034         totQLat += cmd_at - dram_pkt->entryTime;
1035     } else {
1036         ++writesThisTime;
1037         if (row_hit)
1038             writeRowHits++;
1039         bytesWritten += burstSize;
1040         perBankWrBursts[dram_pkt->bankId]++;
1041     }
1042 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_aa8a18d230dba7a674ac8a0b4f35bc36a}{
\index{DRAMCtrl@{DRAMCtrl}!drain@{drain}}
\index{drain@{drain}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em drainManger})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classDRAMCtrl_aa8a18d230dba7a674ac8a0b4f35bc36a}
Provide a default implementation of the drain interface that simply returns 0 (draining completed) and sets the drain state to Drained. 

\hyperlink{classSimObject_a6bf479c521c7c3eb473822d953275b26}{SimObject}を再定義しています。


\begin{DoxyCode}
1730 {
1731     unsigned int count = port.drain(dm);
1732 
1733     // if there is anything in any of our internal queues, keep track
1734     // of that as well
1735     if (!(writeQueue.empty() && readQueue.empty() &&
1736           respQueue.empty())) {
1737         DPRINTF(Drain, "DRAM controller not drained, write: %d, read: %d,"
1738                 " resp: %d\n", writeQueue.size(), readQueue.size(),
1739                 respQueue.size());
1740         ++count;
1741         drainManager = dm;
1742 
1743         // the only part that is not drained automatically over time
1744         // is the write queue, thus kick things into action if needed
1745         if (!writeQueue.empty() && !nextReqEvent.scheduled()) {
1746             schedule(nextReqEvent, curTick());
1747         }
1748     }
1749 
1750     if (count)
1751         setDrainState(Drainable::Draining);
1752     else
1753         setDrainState(Drainable::Drained);
1754     return count;
1755 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_a4edba7d5e567b66fcd93297802a97077}{
\index{DRAMCtrl@{DRAMCtrl}!getSlavePort@{getSlavePort}}
\index{getSlavePort@{getSlavePort}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{getSlavePort}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf BaseSlavePort}\& getSlavePort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classDRAMCtrl_a4edba7d5e567b66fcd93297802a97077}
Get a slave port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classMemObject_ac918a145092d7514ebc6dbd952dceafb}{MemObject}を再定義しています。\hypertarget{classDRAMCtrl_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{DRAMCtrl@{DRAMCtrl}!init@{init}}
\index{init@{init}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classDRAMCtrl_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classDRAMCtrl_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{SimObject}を再定義しています。


\begin{DoxyCode}
147 {
148     if (!port.isConnected()) {
149         fatal("DRAMCtrl %s is unconnected!\n", name());
150     } else {
151         port.sendRangeChange();
152     }
153 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_a29301d0e29279a6e233f15c13959b0de}{
\index{DRAMCtrl@{DRAMCtrl}!minBankActAt@{minBankActAt}}
\index{minBankActAt@{minBankActAt}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{minBankActAt}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t minBankActAt (const {\bf std::deque}$<$ {\bf DRAMPacket} $\ast$ $>$ \& {\em queue}) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a29301d0e29279a6e233f15c13959b0de}
Find which are the earliest banks ready to issue an activate for the enqueued requests. Assumes maximum of 64 banks per DIMM


\begin{DoxyParams}{引数}
\item[{\em Queued}]requests to consider \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
One-\/hot encoded mask of bank indices 
\end{DoxyReturn}



\begin{DoxyCode}
1212 {
1213     uint64_t bank_mask = 0;
1214     Tick min_act_at = MaxTick;
1215 
1216     // deterimne if we have queued transactions targetting a
1217     // bank in question
1218     vector<bool> got_waiting(ranksPerChannel * banksPerRank, false);
1219     for (auto p = queue.begin(); p != queue.end(); ++p) {
1220         got_waiting[(*p)->bankId] = true;
1221     }
1222 
1223     for (int i = 0; i < ranksPerChannel; i++) {
1224         for (int j = 0; j < banksPerRank; j++) {
1225             uint8_t bank_id = i * banksPerRank + j;
1226 
1227             // if we have waiting requests for the bank, and it is
1228             // amongst the first available, update the mask
1229             if (got_waiting[bank_id]) {
1230                 // simplistic approximation of when the bank can issue
1231                 // an activate, ignoring any rank-to-rank switching
1232                 // cost
1233                 Tick act_at = banks[i][j].openRow == Bank::NO_ROW ?
1234                     banks[i][j].actAllowedAt :
1235                     std::max(banks[i][j].preAllowedAt, curTick()) + tRP;
1236 
1237                 if (act_at <= min_act_at) {
1238                     // reset bank mask if new minimum is found
1239                     if (act_at < min_act_at)
1240                         bank_mask = 0;
1241                     // set the bit corresponding to the available bank
1242                     replaceBits(bank_mask, bank_id, bank_id, 1);
1243                     min_act_at = act_at;
1244                 }
1245             }
1246         }
1247     }
1248 
1249     return bank_mask;
1250 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_ae75715461eec20eff07a532c11c3d54c}{
\index{DRAMCtrl@{DRAMCtrl}!prechargeBank@{prechargeBank}}
\index{prechargeBank@{prechargeBank}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{prechargeBank}]{\setlength{\rightskip}{0pt plus 5cm}void prechargeBank ({\bf Bank} \& {\em bank}, \/  {\bf Tick} {\em pre\_\-at})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ae75715461eec20eff07a532c11c3d54c}
Precharge a given bank and also update when the precharge is done. This will also deal with any stats related to the accesses to the open page.


\begin{DoxyParams}{引数}
\item[{\em bank}]The bank to precharge \item[{\em pre\_\-at}]\hyperlink{classTime}{Time} when the precharge takes place \end{DoxyParams}



\begin{DoxyCode}
843 {
844     // make sure the bank has an open row
845     assert(bank.openRow != Bank::NO_ROW);
846 
847     // sample the bytes per activate here since we are closing
848     // the page
849     bytesPerActivate.sample(bank.bytesAccessed);
850 
851     bank.openRow = Bank::NO_ROW;
852 
853     // no precharge allowed before this one
854     bank.preAllowedAt = pre_at;
855 
856     Tick pre_done_at = pre_at + tRP;
857 
858     bank.actAllowedAt = std::max(bank.actAllowedAt, pre_done_at);
859 
860     assert(numBanksActive != 0);
861     --numBanksActive;
862 
863     DPRINTF(DRAM, "Precharging bank at tick %lld, now got %d active\n",
864             pre_at, numBanksActive);
865 
866     // if we look at the current number of active banks we might be
867     // tempted to think the DRAM is now idle, however this can be
868     // undone by an activate that is scheduled to happen before we
869     // would have reached the idle state, so schedule an event and
870     // rather check once we actually make it to the point in time when
871     // the (last) precharge takes place
872     if (!prechargeEvent.scheduled())
873         schedule(prechargeEvent, pre_done_at);
874     else if (prechargeEvent.when() < pre_done_at)
875         reschedule(prechargeEvent, pre_done_at);
876 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_a3c5f01de2fe3a6826581f3641cac2ba7}{
\index{DRAMCtrl@{DRAMCtrl}!printQs@{printQs}}
\index{printQs@{printQs}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{printQs}]{\setlength{\rightskip}{0pt plus 5cm}void printQs () const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a3c5f01de2fe3a6826581f3641cac2ba7}
Used for debugging to observe the contents of the queues. 


\begin{DoxyCode}
513                         {
514     DPRINTF(DRAM, "===READ QUEUE===\n\n");
515     for (auto i = readQueue.begin() ;  i != readQueue.end() ; ++i) {
516         DPRINTF(DRAM, "Read %lu\n", (*i)->addr);
517     }
518     DPRINTF(DRAM, "\n===RESP QUEUE===\n\n");
519     for (auto i = respQueue.begin() ;  i != respQueue.end() ; ++i) {
520         DPRINTF(DRAM, "Response %lu\n", (*i)->addr);
521     }
522     DPRINTF(DRAM, "\n===WRITE QUEUE===\n\n");
523     for (auto i = writeQueue.begin() ;  i != writeQueue.end() ; ++i) {
524         DPRINTF(DRAM, "Write %lu\n", (*i)->addr);
525     }
526 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_ac54213c91d7d83dfe481534b1f165391}{
\index{DRAMCtrl@{DRAMCtrl}!processActivateEvent@{processActivateEvent}}
\index{processActivateEvent@{processActivateEvent}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{processActivateEvent}]{\setlength{\rightskip}{0pt plus 5cm}void processActivateEvent ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ac54213c91d7d83dfe481534b1f165391}



\begin{DoxyCode}
833 {
834     // we should transition to the active state as soon as any bank is active
835     if (pwrState != PWR_ACT)
836         // note that at this point numBanksActive could be back at
837         // zero again due to a precharge scheduled in the future
838         schedulePowerEvent(PWR_ACT, curTick());
839 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_a0798c7e6d736756005d72ec03a38badd}{
\index{DRAMCtrl@{DRAMCtrl}!processNextReqEvent@{processNextReqEvent}}
\index{processNextReqEvent@{processNextReqEvent}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{processNextReqEvent}]{\setlength{\rightskip}{0pt plus 5cm}void processNextReqEvent ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a0798c7e6d736756005d72ec03a38badd}
Bunch of things requires to setup \char`\"{}events\char`\"{} in gem5 When event \char`\"{}respondEvent\char`\"{} occurs for example, the method processRespondEvent is called; no parameters are allowed in these methods 


\begin{DoxyCode}
1046 {
1047     if (busState == READ_TO_WRITE) {
1048         DPRINTF(DRAM, "Switching to writes after %d reads with %d reads "
1049                 "waiting\n", readsThisTime, readQueue.size());
1050 
1051         // sample and reset the read-related stats as we are now
1052         // transitioning to writes, and all reads are done
1053         rdPerTurnAround.sample(readsThisTime);
1054         readsThisTime = 0;
1055 
1056         // now proceed to do the actual writes
1057         busState = WRITE;
1058     } else if (busState == WRITE_TO_READ) {
1059         DPRINTF(DRAM, "Switching to reads after %d writes with %d writes "
1060                 "waiting\n", writesThisTime, writeQueue.size());
1061 
1062         wrPerTurnAround.sample(writesThisTime);
1063         writesThisTime = 0;
1064 
1065         busState = READ;
1066     }
1067 
1068     if (refreshState != REF_IDLE) {
1069         // if a refresh waiting for this event loop to finish, then hand
1070         // over now, and do not schedule a new nextReqEvent
1071         if (refreshState == REF_DRAIN) {
1072             DPRINTF(DRAM, "Refresh drain done, now precharging\n");
1073 
1074             refreshState = REF_PRE;
1075 
1076             // hand control back to the refresh event loop
1077             schedule(refreshEvent, curTick());
1078         }
1079 
1080         // let the refresh finish before issuing any further requests
1081         return;
1082     }
1083 
1084     // when we get here it is either a read or a write
1085     if (busState == READ) {
1086 
1087         // track if we should switch or not
1088         bool switch_to_writes = false;
1089 
1090         if (readQueue.empty()) {
1091             // In the case there is no read request to go next,
1092             // trigger writes if we have passed the low threshold (or
1093             // if we are draining)
1094             if (!writeQueue.empty() &&
1095                 (drainManager || writeQueue.size() > writeLowThreshold)) {
1096 
1097                 switch_to_writes = true;
1098             } else {
1099                 // check if we are drained
1100                 if (respQueue.empty () && drainManager) {
1101                     drainManager->signalDrainDone();
1102                     drainManager = NULL;
1103                 }
1104 
1105                 // nothing to do, not even any point in scheduling an
1106                 // event for the next request
1107                 return;
1108             }
1109         } else {
1110             // Figure out which read request goes next, and move it to the
1111             // front of the read queue
1112             chooseNext(readQueue);
1113 
1114             DRAMPacket* dram_pkt = readQueue.front();
1115 
1116             doDRAMAccess(dram_pkt);
1117 
1118             // At this point we're done dealing with the request
1119             readQueue.pop_front();
1120 
1121             // sanity check
1122             assert(dram_pkt->size <= burstSize);
1123             assert(dram_pkt->readyTime >= curTick());
1124 
1125             // Insert into response queue. It will be sent back to the
1126             // requestor at its readyTime
1127             if (respQueue.empty()) {
1128                 assert(!respondEvent.scheduled());
1129                 schedule(respondEvent, dram_pkt->readyTime);
1130             } else {
1131                 assert(respQueue.back()->readyTime <= dram_pkt->readyTime);
1132                 assert(respondEvent.scheduled());
1133             }
1134 
1135             respQueue.push_back(dram_pkt);
1136 
1137             // we have so many writes that we have to transition
1138             if (writeQueue.size() > writeHighThreshold) {
1139                 switch_to_writes = true;
1140             }
1141         }
1142 
1143         // switching to writes, either because the read queue is empty
1144         // and the writes have passed the low threshold (or we are
1145         // draining), or because the writes hit the hight threshold
1146         if (switch_to_writes) {
1147             // transition to writing
1148             busState = READ_TO_WRITE;
1149 
1150             // add a bubble to the data bus, as defined by the
1151             // tRTW parameter
1152             busBusyUntil += tRTW;
1153 
1154             // update the minimum timing between the requests,
1155             // this shifts us back in time far enough to do any
1156             // bank preparation
1157             nextReqTime = busBusyUntil - (tRP + tRCD + tCL);
1158         }
1159     } else {
1160         chooseNext(writeQueue);
1161         DRAMPacket* dram_pkt = writeQueue.front();
1162         // sanity check
1163         assert(dram_pkt->size <= burstSize);
1164         doDRAMAccess(dram_pkt);
1165 
1166         writeQueue.pop_front();
1167         delete dram_pkt;
1168 
1169         // If we emptied the write queue, or got sufficiently below the
1170         // threshold (using the minWritesPerSwitch as the hysteresis) and
1171         // are not draining, or we have reads waiting and have done enough
1172         // writes, then switch to reads.
1173         if (writeQueue.empty() ||
1174             (writeQueue.size() + minWritesPerSwitch < writeLowThreshold &&
1175              !drainManager) ||
1176             (!readQueue.empty() && writesThisTime >= minWritesPerSwitch)) {
1177             // turn the bus back around for reads again
1178             busState = WRITE_TO_READ;
1179 
1180             // note that the we switch back to reads also in the idle
1181             // case, which eventually will check for any draining and
1182             // also pause any further scheduling if there is really
1183             // nothing to do
1184 
1185             // here we get a bit creative and shift the bus busy time not
1186             // just the tWTR, but also a CAS latency to capture the fact
1187             // that we are allowed to prepare a new bank, but not issue a
1188             // read command until after tWTR, in essence we capture a
1189             // bubble on the data bus that is tWTR + tCL
1190             busBusyUntil += tWTR + tCL;
1191 
1192             // update the minimum timing between the requests, this shifts
1193             // us back in time far enough to do any bank preparation
1194             nextReqTime = busBusyUntil - (tRP + tRCD + tCL);
1195         }
1196     }
1197 
1198     schedule(nextReqEvent, std::max(nextReqTime, curTick()));
1199 
1200     // If there is space available and we have writes waiting then let
1201     // them retry. This is done here to ensure that the retry does not
1202     // cause a nextReqEvent to be scheduled before we do so as part of
1203     // the next request processing
1204     if (retryWrReq && writeQueue.size() < writeBufferSize) {
1205         retryWrReq = false;
1206         port.sendRetry();
1207     }
1208 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_a969289183ebadcc99a8dd9f63120b4eb}{
\index{DRAMCtrl@{DRAMCtrl}!processPowerEvent@{processPowerEvent}}
\index{processPowerEvent@{processPowerEvent}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{processPowerEvent}]{\setlength{\rightskip}{0pt plus 5cm}void processPowerEvent ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a969289183ebadcc99a8dd9f63120b4eb}



\begin{DoxyCode}
1393 {
1394     // remember where we were, and for how long
1395     Tick duration = curTick() - pwrStateTick;
1396     PowerState prev_state = pwrState;
1397 
1398     // update the accounting
1399     pwrStateTime[prev_state] += duration;
1400 
1401     pwrState = pwrStateTrans;
1402     pwrStateTick = curTick();
1403 
1404     if (pwrState == PWR_IDLE) {
1405         DPRINTF(DRAMState, "All banks precharged\n");
1406 
1407         // if we were refreshing, make sure we start scheduling requests again
1408         if (prev_state == PWR_REF) {
1409             DPRINTF(DRAMState, "Was refreshing for %llu ticks\n", duration);
1410             assert(pwrState == PWR_IDLE);
1411 
1412             // kick things into action again
1413             refreshState = REF_IDLE;
1414             assert(!nextReqEvent.scheduled());
1415             schedule(nextReqEvent, curTick());
1416         } else {
1417             assert(prev_state == PWR_ACT);
1418 
1419             // if we have a pending refresh, and are now moving to
1420             // the idle state, direclty transition to a refresh
1421             if (refreshState == REF_RUN) {
1422                 // there should be nothing waiting at this point
1423                 assert(!powerEvent.scheduled());
1424 
1425                 // update the state in zero time and proceed below
1426                 pwrState = PWR_REF;
1427             }
1428         }
1429     }
1430 
1431     // we transition to the refresh state, let the refresh state
1432     // machine know of this state update and let it deal with the
1433     // scheduling of the next power state transition as well as the
1434     // following refresh
1435     if (pwrState == PWR_REF) {
1436         DPRINTF(DRAMState, "Refreshing\n");
1437         // kick the refresh event loop into action again, and that
1438         // in turn will schedule a transition to the idle power
1439         // state once the refresh is done
1440         assert(refreshState == REF_RUN);
1441         processRefreshEvent();
1442     }
1443 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_aac7163c120622a5f0bcc2291bc3054cd}{
\index{DRAMCtrl@{DRAMCtrl}!processPrechargeEvent@{processPrechargeEvent}}
\index{processPrechargeEvent@{processPrechargeEvent}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{processPrechargeEvent}]{\setlength{\rightskip}{0pt plus 5cm}void processPrechargeEvent ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_aac7163c120622a5f0bcc2291bc3054cd}



\begin{DoxyCode}
880 {
881     // if we reached zero, then special conditions apply as we track
882     // if all banks are precharged for the power models
883     if (numBanksActive == 0) {
884         // we should transition to the idle state when the last bank
885         // is precharged
886         schedulePowerEvent(PWR_IDLE, curTick());
887     }
888 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_a56cadd2563b7704b3af145a6a9f5e6ea}{
\index{DRAMCtrl@{DRAMCtrl}!processRefreshEvent@{processRefreshEvent}}
\index{processRefreshEvent@{processRefreshEvent}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{processRefreshEvent}]{\setlength{\rightskip}{0pt plus 5cm}void processRefreshEvent ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a56cadd2563b7704b3af145a6a9f5e6ea}



\begin{DoxyCode}
1254 {
1255     // when first preparing the refresh, remember when it was due
1256     if (refreshState == REF_IDLE) {
1257         // remember when the refresh is due
1258         refreshDueAt = curTick();
1259 
1260         // proceed to drain
1261         refreshState = REF_DRAIN;
1262 
1263         DPRINTF(DRAM, "Refresh due\n");
1264     }
1265 
1266     // let any scheduled read or write go ahead, after which it will
1267     // hand control back to this event loop
1268     if (refreshState == REF_DRAIN) {
1269         if (nextReqEvent.scheduled()) {
1270             // hand control over to the request loop until it is
1271             // evaluated next
1272             DPRINTF(DRAM, "Refresh awaiting draining\n");
1273 
1274             return;
1275         } else {
1276             refreshState = REF_PRE;
1277         }
1278     }
1279 
1280     // at this point, ensure that all banks are precharged
1281     if (refreshState == REF_PRE) {
1282         // precharge any active bank if we are not already in the idle
1283         // state
1284         if (pwrState != PWR_IDLE) {
1285             // at the moment, we use a precharge all even if there is
1286             // only a single bank open
1287             DPRINTF(DRAM, "Precharging all\n");
1288 
1289             // first determine when we can precharge
1290             Tick pre_at = curTick();
1291             for (int i = 0; i < ranksPerChannel; i++) {
1292                 for (int j = 0; j < banksPerRank; j++) {
1293                     // respect both causality and any existing bank
1294                     // constraints, some banks could already have a
1295                     // (auto) precharge scheduled
1296                     pre_at = std::max(banks[i][j].preAllowedAt, pre_at);
1297                 }
1298             }
1299 
1300             // make sure all banks are precharged, and for those that
1301             // already are, update their availability
1302             Tick act_allowed_at = pre_at + tRP;
1303 
1304             for (int i = 0; i < ranksPerChannel; i++) {
1305                 for (int j = 0; j < banksPerRank; j++) {
1306                     if (banks[i][j].openRow != Bank::NO_ROW) {
1307                         prechargeBank(banks[i][j], pre_at);
1308                     } else {
1309                         banks[i][j].actAllowedAt =
1310                             std::max(banks[i][j].actAllowedAt, act_allowed_at);
1311                         banks[i][j].preAllowedAt =
1312                             std::max(banks[i][j].preAllowedAt, pre_at);
1313                     }
1314                 }
1315             }
1316         } else {
1317             DPRINTF(DRAM, "All banks already precharged, starting refresh\n");
1318 
1319             // go ahead and kick the power state machine into gear if
1320             // we are already idle
1321             schedulePowerEvent(PWR_REF, curTick());
1322         }
1323 
1324         refreshState = REF_RUN;
1325         assert(numBanksActive == 0);
1326 
1327         // wait for all banks to be precharged, at which point the
1328         // power state machine will transition to the idle state, and
1329         // automatically move to a refresh, at that point it will also
1330         // call this method to get the refresh event loop going again
1331         return;
1332     }
1333 
1334     // last but not least we perform the actual refresh
1335     if (refreshState == REF_RUN) {
1336         // should never get here with any banks active
1337         assert(numBanksActive == 0);
1338         assert(pwrState == PWR_REF);
1339 
1340         Tick ref_done_at = curTick() + tRFC;
1341 
1342         for (int i = 0; i < ranksPerChannel; i++) {
1343             for (int j = 0; j < banksPerRank; j++) {
1344                 banks[i][j].actAllowedAt = ref_done_at;
1345             }
1346         }
1347 
1348         // make sure we did not wait so long that we cannot make up
1349         // for it
1350         if (refreshDueAt + tREFI < ref_done_at) {
1351             fatal("Refresh was delayed so long we cannot catch up\n");
1352         }
1353 
1354         // compensate for the delay in actually performing the refresh
1355         // when scheduling the next one
1356         schedule(refreshEvent, refreshDueAt + tREFI - tRP);
1357 
1358         assert(!powerEvent.scheduled());
1359 
1360         // move to the idle power state once the refresh is done, this
1361         // will also move the refresh state machine to the refresh
1362         // idle state
1363         schedulePowerEvent(PWR_IDLE, ref_done_at);
1364 
1365         DPRINTF(DRAMState, "Refresh done at %llu and next refresh at %llu\n",
1366                 ref_done_at, refreshDueAt + tREFI);
1367     }
1368 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_ab4cdaf6d543d6785652264ff7ebbecac}{
\index{DRAMCtrl@{DRAMCtrl}!processRespondEvent@{processRespondEvent}}
\index{processRespondEvent@{processRespondEvent}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{processRespondEvent}]{\setlength{\rightskip}{0pt plus 5cm}void processRespondEvent ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ab4cdaf6d543d6785652264ff7ebbecac}



\begin{DoxyCode}
601 {
602     DPRINTF(DRAM,
603             "processRespondEvent(): Some req has reached its readyTime\n");
604 
605     DRAMPacket* dram_pkt = respQueue.front();
606 
607     if (dram_pkt->burstHelper) {
608         // it is a split packet
609         dram_pkt->burstHelper->burstsServiced++;
610         if (dram_pkt->burstHelper->burstsServiced ==
611             dram_pkt->burstHelper->burstCount) {
612             // we have now serviced all children packets of a system packet
613             // so we can now respond to the requester
614             // @todo we probably want to have a different front end and back
615             // end latency for split packets
616             accessAndRespond(dram_pkt->pkt, frontendLatency + backendLatency);
617             delete dram_pkt->burstHelper;
618             dram_pkt->burstHelper = NULL;
619         }
620     } else {
621         // it is not a split packet
622         accessAndRespond(dram_pkt->pkt, frontendLatency + backendLatency);
623     }
624 
625     delete respQueue.front();
626     respQueue.pop_front();
627 
628     if (!respQueue.empty()) {
629         assert(respQueue.front()->readyTime >= curTick());
630         assert(!respondEvent.scheduled());
631         schedule(respondEvent, respQueue.front()->readyTime);
632     } else {
633         // if there is nothing left in any queue, signal a drain
634         if (writeQueue.empty() && readQueue.empty() &&
635             drainManager) {
636             drainManager->signalDrainDone();
637             drainManager = NULL;
638         }
639     }
640 
641     // We have made a location in the queue available at this point,
642     // so if there is a read that was forced to wait, retry now
643     if (retryRdReq) {
644         retryRdReq = false;
645         port.sendRetry();
646     }
647 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_a865d7144c26ea7f206d937e12935f840}{
\index{DRAMCtrl@{DRAMCtrl}!readQueueFull@{readQueueFull}}
\index{readQueueFull@{readQueueFull}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{readQueueFull}]{\setlength{\rightskip}{0pt plus 5cm}bool readQueueFull (unsigned int {\em pktCount}) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a865d7144c26ea7f206d937e12935f840}
\hyperlink{classCheck}{Check} if the read queue has room for more entries


\begin{DoxyParams}{引数}
\item[{\em pktCount}]The number of entries needed in the read queue \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
true if read queue is full, false otherwise 
\end{DoxyReturn}



\begin{DoxyCode}
192 {
193     DPRINTF(DRAM, "Read queue limit %d, current size %d, entries needed %d\n",
194             readBufferSize, readQueue.size() + respQueue.size(),
195             neededEntries);
196 
197     return
198         (readQueue.size() + respQueue.size() + neededEntries) > readBufferSize;
199 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{
\index{DRAMCtrl@{DRAMCtrl}!recvAtomic@{recvAtomic}}
\index{recvAtomic@{recvAtomic}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{recvAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvAtomic ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classDRAMCtrl_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}



\begin{DoxyCode}
175 {
176     DPRINTF(DRAM, "recvAtomic: %s 0x%x\n", pkt->cmdString(), pkt->getAddr());
177 
178     // do the actual memory access and turn the packet into a response
179     access(pkt);
180 
181     Tick latency = 0;
182     if (!pkt->memInhibitAsserted() && pkt->hasData()) {
183         // this value is not supposed to be accurate, just enough to
184         // keep things going, mimic a closed page
185         latency = tRP + tRCD + tCL;
186     }
187     return latency;
188 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_aeefa907fb6d6a787e6dab90e8138ea90}{
\index{DRAMCtrl@{DRAMCtrl}!recvFunctional@{recvFunctional}}
\index{recvFunctional@{recvFunctional}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{recvFunctional}]{\setlength{\rightskip}{0pt plus 5cm}void recvFunctional ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classDRAMCtrl_aeefa907fb6d6a787e6dab90e8138ea90}



\begin{DoxyCode}
1713 {
1714     // rely on the abstract memory
1715     functionalAccess(pkt);
1716 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_a3344d9dd0f83257feab5424e761f31c6}{
\index{DRAMCtrl@{DRAMCtrl}!recvTimingReq@{recvTimingReq}}
\index{recvTimingReq@{recvTimingReq}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{recvTimingReq}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingReq ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classDRAMCtrl_a3344d9dd0f83257feab5424e761f31c6}


\begin{Desc}
\item[\hyperlink{todo__todo000082}{TODO}]temporary hack to deal with memory corruption issues until 4-\/phase transactions are complete \end{Desc}



\begin{DoxyCode}
530 {
533     for (int x = 0; x < pendingDelete.size(); x++)
534         delete pendingDelete[x];
535     pendingDelete.clear();
536 
537     // This is where we enter from the outside world
538     DPRINTF(DRAM, "recvTimingReq: request %s addr %lld size %d\n",
539             pkt->cmdString(), pkt->getAddr(), pkt->getSize());
540 
541     // simply drop inhibited packets for now
542     if (pkt->memInhibitAsserted()) {
543         DPRINTF(DRAM, "Inhibited packet -- Dropping it now\n");
544         pendingDelete.push_back(pkt);
545         return true;
546     }
547 
548     // Calc avg gap between requests
549     if (prevArrival != 0) {
550         totGap += curTick() - prevArrival;
551     }
552     prevArrival = curTick();
553 
554 
555     // Find out how many dram packets a pkt translates to
556     // If the burst size is equal or larger than the pkt size, then a pkt
557     // translates to only one dram packet. Otherwise, a pkt translates to
558     // multiple dram packets
559     unsigned size = pkt->getSize();
560     unsigned offset = pkt->getAddr() & (burstSize - 1);
561     unsigned int dram_pkt_count = divCeil(offset + size, burstSize);
562 
563     // check local buffers and do not accept if full
564     if (pkt->isRead()) {
565         assert(size != 0);
566         if (readQueueFull(dram_pkt_count)) {
567             DPRINTF(DRAM, "Read queue full, not accepting\n");
568             // remember that we have to retry this port
569             retryRdReq = true;
570             numRdRetry++;
571             return false;
572         } else {
573             addToReadQueue(pkt, dram_pkt_count);
574             readReqs++;
575             bytesReadSys += size;
576         }
577     } else if (pkt->isWrite()) {
578         assert(size != 0);
579         if (writeQueueFull(dram_pkt_count)) {
580             DPRINTF(DRAM, "Write queue full, not accepting\n");
581             // remember that we have to retry this port
582             retryWrReq = true;
583             numWrRetry++;
584             return false;
585         } else {
586             addToWriteQueue(pkt, dram_pkt_count);
587             writeReqs++;
588             bytesWrittenSys += size;
589         }
590     } else {
591         DPRINTF(DRAM,"Neither read nor write, ignore timing\n");
592         neitherReadNorWrite++;
593         accessAndRespond(pkt, 1);
594     }
595 
596     return true;
597 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{DRAMCtrl@{DRAMCtrl}!regStats@{regStats}}
\index{regStats@{regStats}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classDRAMCtrl_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} Statistics 

\hyperlink{classAbstractMemory_a4dc637449366fcdfc4e764cdf12d9b11}{AbstractMemory}を再定義しています。


\begin{DoxyCode}
1447 {
1448     using namespace Stats;
1449 
1450     AbstractMemory::regStats();
1451 
1452     readReqs
1453         .name(name() + ".readReqs")
1454         .desc("Number of read requests accepted");
1455 
1456     writeReqs
1457         .name(name() + ".writeReqs")
1458         .desc("Number of write requests accepted");
1459 
1460     readBursts
1461         .name(name() + ".readBursts")
1462         .desc("Number of DRAM read bursts, "
1463               "including those serviced by the write queue");
1464 
1465     writeBursts
1466         .name(name() + ".writeBursts")
1467         .desc("Number of DRAM write bursts, "
1468               "including those merged in the write queue");
1469 
1470     servicedByWrQ
1471         .name(name() + ".servicedByWrQ")
1472         .desc("Number of DRAM read bursts serviced by the write queue");
1473 
1474     mergedWrBursts
1475         .name(name() + ".mergedWrBursts")
1476         .desc("Number of DRAM write bursts merged with an existing one");
1477 
1478     neitherReadNorWrite
1479         .name(name() + ".neitherReadNorWriteReqs")
1480         .desc("Number of requests that are neither read nor write");
1481 
1482     perBankRdBursts
1483         .init(banksPerRank * ranksPerChannel)
1484         .name(name() + ".perBankRdBursts")
1485         .desc("Per bank write bursts");
1486 
1487     perBankWrBursts
1488         .init(banksPerRank * ranksPerChannel)
1489         .name(name() + ".perBankWrBursts")
1490         .desc("Per bank write bursts");
1491 
1492     avgRdQLen
1493         .name(name() + ".avgRdQLen")
1494         .desc("Average read queue length when enqueuing")
1495         .precision(2);
1496 
1497     avgWrQLen
1498         .name(name() + ".avgWrQLen")
1499         .desc("Average write queue length when enqueuing")
1500         .precision(2);
1501 
1502     totQLat
1503         .name(name() + ".totQLat")
1504         .desc("Total ticks spent queuing");
1505 
1506     totBusLat
1507         .name(name() + ".totBusLat")
1508         .desc("Total ticks spent in databus transfers");
1509 
1510     totMemAccLat
1511         .name(name() + ".totMemAccLat")
1512         .desc("Total ticks spent from burst creation until serviced "
1513               "by the DRAM");
1514 
1515     avgQLat
1516         .name(name() + ".avgQLat")
1517         .desc("Average queueing delay per DRAM burst")
1518         .precision(2);
1519 
1520     avgQLat = totQLat / (readBursts - servicedByWrQ);
1521 
1522     avgBusLat
1523         .name(name() + ".avgBusLat")
1524         .desc("Average bus latency per DRAM burst")
1525         .precision(2);
1526 
1527     avgBusLat = totBusLat / (readBursts - servicedByWrQ);
1528 
1529     avgMemAccLat
1530         .name(name() + ".avgMemAccLat")
1531         .desc("Average memory access latency per DRAM burst")
1532         .precision(2);
1533 
1534     avgMemAccLat = totMemAccLat / (readBursts - servicedByWrQ);
1535 
1536     numRdRetry
1537         .name(name() + ".numRdRetry")
1538         .desc("Number of times read queue was full causing retry");
1539 
1540     numWrRetry
1541         .name(name() + ".numWrRetry")
1542         .desc("Number of times write queue was full causing retry");
1543 
1544     readRowHits
1545         .name(name() + ".readRowHits")
1546         .desc("Number of row buffer hits during reads");
1547 
1548     writeRowHits
1549         .name(name() + ".writeRowHits")
1550         .desc("Number of row buffer hits during writes");
1551 
1552     readRowHitRate
1553         .name(name() + ".readRowHitRate")
1554         .desc("Row buffer hit rate for reads")
1555         .precision(2);
1556 
1557     readRowHitRate = (readRowHits / (readBursts - servicedByWrQ)) * 100;
1558 
1559     writeRowHitRate
1560         .name(name() + ".writeRowHitRate")
1561         .desc("Row buffer hit rate for writes")
1562         .precision(2);
1563 
1564     writeRowHitRate = (writeRowHits / (writeBursts - mergedWrBursts)) * 100;
1565 
1566     readPktSize
1567         .init(ceilLog2(burstSize) + 1)
1568         .name(name() + ".readPktSize")
1569         .desc("Read request sizes (log2)");
1570 
1571      writePktSize
1572         .init(ceilLog2(burstSize) + 1)
1573         .name(name() + ".writePktSize")
1574         .desc("Write request sizes (log2)");
1575 
1576      rdQLenPdf
1577         .init(readBufferSize)
1578         .name(name() + ".rdQLenPdf")
1579         .desc("What read queue length does an incoming req see");
1580 
1581      wrQLenPdf
1582         .init(writeBufferSize)
1583         .name(name() + ".wrQLenPdf")
1584         .desc("What write queue length does an incoming req see");
1585 
1586      bytesPerActivate
1587          .init(maxAccessesPerRow)
1588          .name(name() + ".bytesPerActivate")
1589          .desc("Bytes accessed per row activation")
1590          .flags(nozero);
1591 
1592      rdPerTurnAround
1593          .init(readBufferSize)
1594          .name(name() + ".rdPerTurnAround")
1595          .desc("Reads before turning the bus around for writes")
1596          .flags(nozero);
1597 
1598      wrPerTurnAround
1599          .init(writeBufferSize)
1600          .name(name() + ".wrPerTurnAround")
1601          .desc("Writes before turning the bus around for reads")
1602          .flags(nozero);
1603 
1604     bytesReadDRAM
1605         .name(name() + ".bytesReadDRAM")
1606         .desc("Total number of bytes read from DRAM");
1607 
1608     bytesReadWrQ
1609         .name(name() + ".bytesReadWrQ")
1610         .desc("Total number of bytes read from write queue");
1611 
1612     bytesWritten
1613         .name(name() + ".bytesWritten")
1614         .desc("Total number of bytes written to DRAM");
1615 
1616     bytesReadSys
1617         .name(name() + ".bytesReadSys")
1618         .desc("Total read bytes from the system interface side");
1619 
1620     bytesWrittenSys
1621         .name(name() + ".bytesWrittenSys")
1622         .desc("Total written bytes from the system interface side");
1623 
1624     avgRdBW
1625         .name(name() + ".avgRdBW")
1626         .desc("Average DRAM read bandwidth in MiByte/s")
1627         .precision(2);
1628 
1629     avgRdBW = (bytesReadDRAM / 1000000) / simSeconds;
1630 
1631     avgWrBW
1632         .name(name() + ".avgWrBW")
1633         .desc("Average achieved write bandwidth in MiByte/s")
1634         .precision(2);
1635 
1636     avgWrBW = (bytesWritten / 1000000) / simSeconds;
1637 
1638     avgRdBWSys
1639         .name(name() + ".avgRdBWSys")
1640         .desc("Average system read bandwidth in MiByte/s")
1641         .precision(2);
1642 
1643     avgRdBWSys = (bytesReadSys / 1000000) / simSeconds;
1644 
1645     avgWrBWSys
1646         .name(name() + ".avgWrBWSys")
1647         .desc("Average system write bandwidth in MiByte/s")
1648         .precision(2);
1649 
1650     avgWrBWSys = (bytesWrittenSys / 1000000) / simSeconds;
1651 
1652     peakBW
1653         .name(name() + ".peakBW")
1654         .desc("Theoretical peak bandwidth in MiByte/s")
1655         .precision(2);
1656 
1657     peakBW = (SimClock::Frequency / tBURST) * burstSize / 1000000;
1658 
1659     busUtil
1660         .name(name() + ".busUtil")
1661         .desc("Data bus utilization in percentage")
1662         .precision(2);
1663 
1664     busUtil = (avgRdBW + avgWrBW) / peakBW * 100;
1665 
1666     totGap
1667         .name(name() + ".totGap")
1668         .desc("Total gap between requests");
1669 
1670     avgGap
1671         .name(name() + ".avgGap")
1672         .desc("Average gap between requests")
1673         .precision(2);
1674 
1675     avgGap = totGap / (readReqs + writeReqs);
1676 
1677     // Stats for DRAM Power calculation based on Micron datasheet
1678     busUtilRead
1679         .name(name() + ".busUtilRead")
1680         .desc("Data bus utilization in percentage for reads")
1681         .precision(2);
1682 
1683     busUtilRead = avgRdBW / peakBW * 100;
1684 
1685     busUtilWrite
1686         .name(name() + ".busUtilWrite")
1687         .desc("Data bus utilization in percentage for writes")
1688         .precision(2);
1689 
1690     busUtilWrite = avgWrBW / peakBW * 100;
1691 
1692     pageHitRate
1693         .name(name() + ".pageHitRate")
1694         .desc("Row buffer hit rate, read and write combined")
1695         .precision(2);
1696 
1697     pageHitRate = (writeRowHits + readRowHits) /
1698         (writeBursts - mergedWrBursts + readBursts - servicedByWrQ) * 100;
1699 
1700     pwrStateTime
1701         .init(5)
1702         .name(name() + ".memoryStateTime")
1703         .desc("Time in different power states");
1704     pwrStateTime.subname(0, "IDLE");
1705     pwrStateTime.subname(1, "REF");
1706     pwrStateTime.subname(2, "PRE_PDN");
1707     pwrStateTime.subname(3, "ACT");
1708     pwrStateTime.subname(4, "ACT_PDN");
1709 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_aabfe6aa48e67d5b5c21e77dfa8a7e965}{
\index{DRAMCtrl@{DRAMCtrl}!reorderQueue@{reorderQueue}}
\index{reorderQueue@{reorderQueue}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{reorderQueue}]{\setlength{\rightskip}{0pt plus 5cm}void reorderQueue ({\bf std::deque}$<$ {\bf DRAMPacket} $\ast$ $>$ \& {\em queue})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_aabfe6aa48e67d5b5c21e77dfa8a7e965}
For FR-\/FCFS policy reorder the read/write queue depending on row buffer hits and earliest banks available in DRAM 


\begin{DoxyCode}
673 {
674     // Only determine this when needed
675     uint64_t earliest_banks = 0;
676 
677     // Search for row hits first, if no row hit is found then schedule the
678     // packet to one of the earliest banks available
679     bool found_earliest_pkt = false;
680     auto selected_pkt_it = queue.begin();
681 
682     for (auto i = queue.begin(); i != queue.end() ; ++i) {
683         DRAMPacket* dram_pkt = *i;
684         const Bank& bank = dram_pkt->bankRef;
685         // Check if it is a row hit
686         if (bank.openRow == dram_pkt->row) {
687             // FCFS within the hits
688             DPRINTF(DRAM, "Row buffer hit\n");
689             selected_pkt_it = i;
690             break;
691         } else if (!found_earliest_pkt) {
692             // No row hit, go for first ready
693             if (earliest_banks == 0)
694                 earliest_banks = minBankActAt(queue);
695 
696             // simplistic approximation of when the bank can issue an
697             // activate, this is calculated in minBankActAt and could
698             // be cached
699             Tick act_at = bank.openRow == Bank::NO_ROW ?
700                 bank.actAllowedAt :
701                 std::max(bank.preAllowedAt, curTick()) + tRP;
702 
703             // Bank is ready or is the first available bank
704             if (act_at <= curTick() ||
705                 bits(earliest_banks, dram_pkt->bankId, dram_pkt->bankId)) {
706                 // Remember the packet to be scheduled to one of the earliest
707                 // banks available, FCFS amongst the earliest banks
708                 selected_pkt_it = i;
709                 found_earliest_pkt = true;
710             }
711         }
712     }
713 
714     DRAMPacket* selected_pkt = *selected_pkt_it;
715     queue.erase(selected_pkt_it);
716     queue.push_front(selected_pkt);
717 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_a233880f1f4b8f6455a2ff083dda871d3}{
\index{DRAMCtrl@{DRAMCtrl}!schedulePowerEvent@{schedulePowerEvent}}
\index{schedulePowerEvent@{schedulePowerEvent}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{schedulePowerEvent}]{\setlength{\rightskip}{0pt plus 5cm}void schedulePowerEvent ({\bf PowerState} {\em pwr\_\-state}, \/  {\bf Tick} {\em tick})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a233880f1f4b8f6455a2ff083dda871d3}
Schedule a power state transition in the future, and potentially override an already scheduled transition.


\begin{DoxyParams}{引数}
\item[{\em pwr\_\-state}]Power state to transition to \item[{\em tick}]Tick when transition should take place \end{DoxyParams}



\begin{DoxyCode}
1372 {
1373     // respect causality
1374     assert(tick >= curTick());
1375 
1376     if (!powerEvent.scheduled()) {
1377         DPRINTF(DRAMState, "Scheduling power event at %llu to state %d\n",
1378                 tick, pwr_state);
1379 
1380         // insert the new transition
1381         pwrStateTrans = pwr_state;
1382 
1383         schedule(powerEvent, tick);
1384     } else {
1385         panic("Scheduled power event at %llu to state %d, "
1386               "with scheduled event at %llu to %d\n", tick, pwr_state,
1387               powerEvent.when(), pwrStateTrans);
1388     }
1389 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_aecc7d8debf54990ffeaaed5bac7d7d81}{
\index{DRAMCtrl@{DRAMCtrl}!startup@{startup}}
\index{startup@{startup}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{startup}]{\setlength{\rightskip}{0pt plus 5cm}void startup ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classDRAMCtrl_aecc7d8debf54990ffeaaed5bac7d7d81}
\hyperlink{classDRAMCtrl_aecc7d8debf54990ffeaaed5bac7d7d81}{startup()} is the final initialization call before simulation. All state is initialized (including unserialized state, if any, such as the \hyperlink{statistics_8hh_a7acdccbf0d35ce0c159c0cdd36371b22}{curTick()} value), so this is the appropriate place to schedule initial event(s) for objects that need them. 

\hyperlink{classSimObject_aecc7d8debf54990ffeaaed5bac7d7d81}{SimObject}を再定義しています。


\begin{DoxyCode}
157 {
158     // update the start tick for the precharge accounting to the
159     // current tick
160     pwrStateTick = curTick();
161 
162     // shift the bus busy time sufficiently far ahead that we never
163     // have to worry about negative values when computing the time for
164     // the next request, this will add an insignificant bubble at the
165     // start of simulation
166     busBusyUntil = curTick() + tRP + tRCD + tCL;
167 
168     // kick off the refresh, and give ourselves enough time to
169     // precharge
170     schedule(refreshEvent, curTick() + tREFI - tRP);
171 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_a34f56ea41ba7accf7b75a46aa79b560c}{
\index{DRAMCtrl@{DRAMCtrl}!writeQueueFull@{writeQueueFull}}
\index{writeQueueFull@{writeQueueFull}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{writeQueueFull}]{\setlength{\rightskip}{0pt plus 5cm}bool writeQueueFull (unsigned int {\em pktCount}) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a34f56ea41ba7accf7b75a46aa79b560c}
\hyperlink{classCheck}{Check} if the write queue has room for more entries


\begin{DoxyParams}{引数}
\item[{\em pktCount}]The number of entries needed in the write queue \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
true if write queue is full, false otherwise 
\end{DoxyReturn}



\begin{DoxyCode}
203 {
204     DPRINTF(DRAM, "Write queue limit %d, current size %d, entries needed %d\n",
205             writeBufferSize, writeQueue.size(), neededEntries);
206     return (writeQueue.size() + neededEntries) > writeBufferSize;
207 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classDRAMCtrl_ad15dbdabb028b909655b32ab9e322e50}{
\index{DRAMCtrl@{DRAMCtrl}!activateEvent@{activateEvent}}
\index{activateEvent@{activateEvent}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{activateEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf DRAMCtrl}, \&DRAMCtrl::processActivateEvent$>$ {\bf activateEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ad15dbdabb028b909655b32ab9e322e50}
\hypertarget{classDRAMCtrl_aba56ec7c49633bf73f29b24ff6a18b38}{
\index{DRAMCtrl@{DRAMCtrl}!activationLimit@{activationLimit}}
\index{activationLimit@{activationLimit}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{activationLimit}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf activationLimit}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_aba56ec7c49633bf73f29b24ff6a18b38}
\hypertarget{classDRAMCtrl_a4a4e224ac2ca35b6d47a3ff850e1ff3e}{
\index{DRAMCtrl@{DRAMCtrl}!actTicks@{actTicks}}
\index{actTicks@{actTicks}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{actTicks}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf std::deque}$<${\bf Tick}$>$ $>$ {\bf actTicks}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a4a4e224ac2ca35b6d47a3ff850e1ff3e}
List to keep track of activate ticks \hypertarget{classDRAMCtrl_a39c22fc32946a97479fd50b6d4db1ed0}{
\index{DRAMCtrl@{DRAMCtrl}!addrMapping@{addrMapping}}
\index{addrMapping@{addrMapping}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{addrMapping}]{\setlength{\rightskip}{0pt plus 5cm}Enums::AddrMap {\bf addrMapping}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a39c22fc32946a97479fd50b6d4db1ed0}
\hypertarget{classDRAMCtrl_ad2f8163270cbb3392f2e10fb6c4f78c4}{
\index{DRAMCtrl@{DRAMCtrl}!avgBusLat@{avgBusLat}}
\index{avgBusLat@{avgBusLat}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{avgBusLat}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf avgBusLat}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ad2f8163270cbb3392f2e10fb6c4f78c4}
\hypertarget{classDRAMCtrl_ab29b83e3d43dd519d59172a842b673a3}{
\index{DRAMCtrl@{DRAMCtrl}!avgGap@{avgGap}}
\index{avgGap@{avgGap}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{avgGap}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf avgGap}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ab29b83e3d43dd519d59172a842b673a3}
\hypertarget{classDRAMCtrl_ac7abb815f3daf254a44904528d4e816b}{
\index{DRAMCtrl@{DRAMCtrl}!avgMemAccLat@{avgMemAccLat}}
\index{avgMemAccLat@{avgMemAccLat}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{avgMemAccLat}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf avgMemAccLat}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ac7abb815f3daf254a44904528d4e816b}
\hypertarget{classDRAMCtrl_ad594e3077a6ad256f07ab26b96b34c5f}{
\index{DRAMCtrl@{DRAMCtrl}!avgQLat@{avgQLat}}
\index{avgQLat@{avgQLat}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{avgQLat}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf avgQLat}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ad594e3077a6ad256f07ab26b96b34c5f}
\hypertarget{classDRAMCtrl_a28dfaaa96a94257709a4f53f65ff6de8}{
\index{DRAMCtrl@{DRAMCtrl}!avgRdBW@{avgRdBW}}
\index{avgRdBW@{avgRdBW}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{avgRdBW}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf avgRdBW}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a28dfaaa96a94257709a4f53f65ff6de8}
\hypertarget{classDRAMCtrl_a22abe27ebad6f2dff8823abcbfd821b8}{
\index{DRAMCtrl@{DRAMCtrl}!avgRdBWSys@{avgRdBWSys}}
\index{avgRdBWSys@{avgRdBWSys}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{avgRdBWSys}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf avgRdBWSys}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a22abe27ebad6f2dff8823abcbfd821b8}
\hypertarget{classDRAMCtrl_ab0f0022a38b8ccefd6d4d17ed434fcea}{
\index{DRAMCtrl@{DRAMCtrl}!avgRdQLen@{avgRdQLen}}
\index{avgRdQLen@{avgRdQLen}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{avgRdQLen}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Average} {\bf avgRdQLen}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ab0f0022a38b8ccefd6d4d17ed434fcea}
\hypertarget{classDRAMCtrl_a286267c923c741d2fb82bdf8e76ed309}{
\index{DRAMCtrl@{DRAMCtrl}!avgWrBW@{avgWrBW}}
\index{avgWrBW@{avgWrBW}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{avgWrBW}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf avgWrBW}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a286267c923c741d2fb82bdf8e76ed309}
\hypertarget{classDRAMCtrl_ab3ccc99d9b3a33a2783095e6299af1d8}{
\index{DRAMCtrl@{DRAMCtrl}!avgWrBWSys@{avgWrBWSys}}
\index{avgWrBWSys@{avgWrBWSys}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{avgWrBWSys}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf avgWrBWSys}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ab3ccc99d9b3a33a2783095e6299af1d8}
\hypertarget{classDRAMCtrl_a4cdec63bcb455cfe5f1d8e6db40b66f5}{
\index{DRAMCtrl@{DRAMCtrl}!avgWrQLen@{avgWrQLen}}
\index{avgWrQLen@{avgWrQLen}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{avgWrQLen}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Average} {\bf avgWrQLen}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a4cdec63bcb455cfe5f1d8e6db40b66f5}
\hypertarget{classDRAMCtrl_af7b0d4000762b26f57e6bdbbdf45cf6d}{
\index{DRAMCtrl@{DRAMCtrl}!backendLatency@{backendLatency}}
\index{backendLatency@{backendLatency}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{backendLatency}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf backendLatency}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_af7b0d4000762b26f57e6bdbbdf45cf6d}
Pipeline latency of the backend and PHY. Along with the frontend contribution, this latency is added to reads serviced by the DRAM. \hypertarget{classDRAMCtrl_ac4dd7a78e52bcaca6fb18d24b45bb7f3}{
\index{DRAMCtrl@{DRAMCtrl}!banks@{banks}}
\index{banks@{banks}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{banks}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf std::vector}$<${\bf Bank}$>$ $>$ {\bf banks}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ac4dd7a78e52bcaca6fb18d24b45bb7f3}
Multi-\/dimensional vector of banks, first dimension is ranks, second is bank \hypertarget{classDRAMCtrl_abd3ef09f9d5c70e15763a9761c8a14ca}{
\index{DRAMCtrl@{DRAMCtrl}!banksPerRank@{banksPerRank}}
\index{banksPerRank@{banksPerRank}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{banksPerRank}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf banksPerRank}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_abd3ef09f9d5c70e15763a9761c8a14ca}
\hypertarget{classDRAMCtrl_a7ac4e4b031082616f09700ea29168920}{
\index{DRAMCtrl@{DRAMCtrl}!burstLength@{burstLength}}
\index{burstLength@{burstLength}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{burstLength}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf burstLength}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a7ac4e4b031082616f09700ea29168920}
\hypertarget{classDRAMCtrl_aed1f7024fc9eeb4654afe54d86683d76}{
\index{DRAMCtrl@{DRAMCtrl}!burstSize@{burstSize}}
\index{burstSize@{burstSize}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{burstSize}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf burstSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_aed1f7024fc9eeb4654afe54d86683d76}
\hypertarget{classDRAMCtrl_a0a423ce73b4c78a0da7ce4ad9e60add6}{
\index{DRAMCtrl@{DRAMCtrl}!busBusyUntil@{busBusyUntil}}
\index{busBusyUntil@{busBusyUntil}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{busBusyUntil}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf busBusyUntil}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a0a423ce73b4c78a0da7ce4ad9e60add6}
Till when has the main data bus been spoken for already? \hypertarget{classDRAMCtrl_a898cc5ed4c5a9ec9c13dbe52d1ea0eb2}{
\index{DRAMCtrl@{DRAMCtrl}!busState@{busState}}
\index{busState@{busState}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{busState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BusState} {\bf busState}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a898cc5ed4c5a9ec9c13dbe52d1ea0eb2}
\hypertarget{classDRAMCtrl_a32757323249e0ec2fd96e77d543fc60d}{
\index{DRAMCtrl@{DRAMCtrl}!busUtil@{busUtil}}
\index{busUtil@{busUtil}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{busUtil}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf busUtil}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a32757323249e0ec2fd96e77d543fc60d}
\hypertarget{classDRAMCtrl_a578cf14141a41ca0c302331cf1641d4a}{
\index{DRAMCtrl@{DRAMCtrl}!busUtilRead@{busUtilRead}}
\index{busUtilRead@{busUtilRead}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{busUtilRead}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf busUtilRead}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a578cf14141a41ca0c302331cf1641d4a}
\hypertarget{classDRAMCtrl_a414d3be953606d246b346cc75032e7d5}{
\index{DRAMCtrl@{DRAMCtrl}!busUtilWrite@{busUtilWrite}}
\index{busUtilWrite@{busUtilWrite}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{busUtilWrite}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf busUtilWrite}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a414d3be953606d246b346cc75032e7d5}
\hypertarget{classDRAMCtrl_a097e6ef9437eaed0d05c3d0881455b1a}{
\index{DRAMCtrl@{DRAMCtrl}!bytesPerActivate@{bytesPerActivate}}
\index{bytesPerActivate@{bytesPerActivate}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{bytesPerActivate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram} {\bf bytesPerActivate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a097e6ef9437eaed0d05c3d0881455b1a}
\hypertarget{classDRAMCtrl_a4409b60f101f8ea21148966043864074}{
\index{DRAMCtrl@{DRAMCtrl}!bytesReadDRAM@{bytesReadDRAM}}
\index{bytesReadDRAM@{bytesReadDRAM}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{bytesReadDRAM}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf bytesReadDRAM}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a4409b60f101f8ea21148966043864074}
\hypertarget{classDRAMCtrl_afd688f67c6a876a7b272e2ec9221fc8f}{
\index{DRAMCtrl@{DRAMCtrl}!bytesReadSys@{bytesReadSys}}
\index{bytesReadSys@{bytesReadSys}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{bytesReadSys}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf bytesReadSys}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_afd688f67c6a876a7b272e2ec9221fc8f}
\hypertarget{classDRAMCtrl_ae2ea884ed0a7e793cabc56748b833ed2}{
\index{DRAMCtrl@{DRAMCtrl}!bytesReadWrQ@{bytesReadWrQ}}
\index{bytesReadWrQ@{bytesReadWrQ}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{bytesReadWrQ}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf bytesReadWrQ}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ae2ea884ed0a7e793cabc56748b833ed2}
\hypertarget{classDRAMCtrl_a98c4533d0a7053d00f6882f984ebdaef}{
\index{DRAMCtrl@{DRAMCtrl}!bytesWritten@{bytesWritten}}
\index{bytesWritten@{bytesWritten}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{bytesWritten}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf bytesWritten}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a98c4533d0a7053d00f6882f984ebdaef}
Number of bytes written to this memory 

\hyperlink{classAbstractMemory_ab89ec4a4876671ad5186d0e9c0e674ed}{AbstractMemory}を再定義しています。\hypertarget{classDRAMCtrl_acaf3b49004885b5bc8d40fef342c14c1}{
\index{DRAMCtrl@{DRAMCtrl}!bytesWrittenSys@{bytesWrittenSys}}
\index{bytesWrittenSys@{bytesWrittenSys}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{bytesWrittenSys}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf bytesWrittenSys}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_acaf3b49004885b5bc8d40fef342c14c1}
\hypertarget{classDRAMCtrl_a2fa7bea53e9bf8fb52623b494d814d30}{
\index{DRAMCtrl@{DRAMCtrl}!channels@{channels}}
\index{channels@{channels}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{channels}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf channels}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a2fa7bea53e9bf8fb52623b494d814d30}
\hypertarget{classDRAMCtrl_a1f84aad3340018bfb3c46ace200df8cb}{
\index{DRAMCtrl@{DRAMCtrl}!columnsPerRowBuffer@{columnsPerRowBuffer}}
\index{columnsPerRowBuffer@{columnsPerRowBuffer}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{columnsPerRowBuffer}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf columnsPerRowBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a1f84aad3340018bfb3c46ace200df8cb}
\hypertarget{classDRAMCtrl_a9b8ba3e3a3cc11b904cd1b70e7a40ea5}{
\index{DRAMCtrl@{DRAMCtrl}!deviceBusWidth@{deviceBusWidth}}
\index{deviceBusWidth@{deviceBusWidth}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{deviceBusWidth}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf deviceBusWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a9b8ba3e3a3cc11b904cd1b70e7a40ea5}
The following are basic design parameters of the memory controller, and are initialized based on parameter values. The rowsPerBank is determined based on the capacity, number of ranks and banks, the burst size, and the row buffer size. \hypertarget{classDRAMCtrl_afdaeeb74e1622ca1cc0f00dcf937a3b0}{
\index{DRAMCtrl@{DRAMCtrl}!deviceRowBufferSize@{deviceRowBufferSize}}
\index{deviceRowBufferSize@{deviceRowBufferSize}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{deviceRowBufferSize}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf deviceRowBufferSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_afdaeeb74e1622ca1cc0f00dcf937a3b0}
\hypertarget{classDRAMCtrl_a962c654402093dcbdd4b40fd32c0de69}{
\index{DRAMCtrl@{DRAMCtrl}!devicesPerRank@{devicesPerRank}}
\index{devicesPerRank@{devicesPerRank}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{devicesPerRank}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf devicesPerRank}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a962c654402093dcbdd4b40fd32c0de69}
\hypertarget{classDRAMCtrl_a329b71fb934a93312ca0aacbf5a3f982}{
\index{DRAMCtrl@{DRAMCtrl}!drainManager@{drainManager}}
\index{drainManager@{drainManager}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{drainManager}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DrainManager}$\ast$ {\bf drainManager}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a329b71fb934a93312ca0aacbf5a3f982}
If we need to drain, keep the drain manager around until we're done here. \hypertarget{classDRAMCtrl_ad88c33e41f0bdc247328c7420c515f30}{
\index{DRAMCtrl@{DRAMCtrl}!frontendLatency@{frontendLatency}}
\index{frontendLatency@{frontendLatency}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{frontendLatency}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf frontendLatency}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ad88c33e41f0bdc247328c7420c515f30}
Pipeline latency of the controller frontend. The frontend contribution is added to writes (that complete when they are in the write buffer) and reads that are serviced the write buffer. \hypertarget{classDRAMCtrl_ab0ff1e80c0fcb937ef53eee0175cbd13}{
\index{DRAMCtrl@{DRAMCtrl}!maxAccessesPerRow@{maxAccessesPerRow}}
\index{maxAccessesPerRow@{maxAccessesPerRow}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{maxAccessesPerRow}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf maxAccessesPerRow}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ab0ff1e80c0fcb937ef53eee0175cbd13}
Max column accesses (read and write) per row, before forefully closing it. \hypertarget{classDRAMCtrl_a77153a963ea47f1f424595cbc94461e7}{
\index{DRAMCtrl@{DRAMCtrl}!memSchedPolicy@{memSchedPolicy}}
\index{memSchedPolicy@{memSchedPolicy}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{memSchedPolicy}]{\setlength{\rightskip}{0pt plus 5cm}Enums::MemSched {\bf memSchedPolicy}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a77153a963ea47f1f424595cbc94461e7}
Memory controller configuration initialized based on parameter values. \hypertarget{classDRAMCtrl_accaed2ab83bb63d6ddff7bfa861ea537}{
\index{DRAMCtrl@{DRAMCtrl}!mergedWrBursts@{mergedWrBursts}}
\index{mergedWrBursts@{mergedWrBursts}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{mergedWrBursts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf mergedWrBursts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_accaed2ab83bb63d6ddff7bfa861ea537}
\hypertarget{classDRAMCtrl_a2753a60747e9836fe5f5fec7b613385c}{
\index{DRAMCtrl@{DRAMCtrl}!minWritesPerSwitch@{minWritesPerSwitch}}
\index{minWritesPerSwitch@{minWritesPerSwitch}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{minWritesPerSwitch}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf minWritesPerSwitch}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a2753a60747e9836fe5f5fec7b613385c}
\hypertarget{classDRAMCtrl_a10a3647b9ff175594214578eece1e1f7}{
\index{DRAMCtrl@{DRAMCtrl}!neitherReadNorWrite@{neitherReadNorWrite}}
\index{neitherReadNorWrite@{neitherReadNorWrite}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{neitherReadNorWrite}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf neitherReadNorWrite}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a10a3647b9ff175594214578eece1e1f7}
\hypertarget{classDRAMCtrl_a6f6c894e157329404d6b23503c4fa62e}{
\index{DRAMCtrl@{DRAMCtrl}!nextReqEvent@{nextReqEvent}}
\index{nextReqEvent@{nextReqEvent}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{nextReqEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf DRAMCtrl},\&DRAMCtrl::processNextReqEvent$>$ {\bf nextReqEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a6f6c894e157329404d6b23503c4fa62e}
\hypertarget{classDRAMCtrl_a61a2436b0d2ca4872e69f76fecaeca7f}{
\index{DRAMCtrl@{DRAMCtrl}!nextReqTime@{nextReqTime}}
\index{nextReqTime@{nextReqTime}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{nextReqTime}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf nextReqTime}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a61a2436b0d2ca4872e69f76fecaeca7f}
The soonest you have to start thinking about the next request is the longest access time that can occur before busBusyUntil. Assuming you need to precharge, open a new row, and access, it is tRP + tRCD + tCL. \hypertarget{classDRAMCtrl_a2742d81312b2f4e257aaa3690989bc88}{
\index{DRAMCtrl@{DRAMCtrl}!numBanksActive@{numBanksActive}}
\index{numBanksActive@{numBanksActive}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{numBanksActive}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf numBanksActive}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a2742d81312b2f4e257aaa3690989bc88}
\hypertarget{classDRAMCtrl_acc056895269ee73447f6e9d814a22319}{
\index{DRAMCtrl@{DRAMCtrl}!numRdRetry@{numRdRetry}}
\index{numRdRetry@{numRdRetry}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{numRdRetry}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numRdRetry}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_acc056895269ee73447f6e9d814a22319}
\hypertarget{classDRAMCtrl_a961b9dc82d0ef2814dbdbc498a20e9b3}{
\index{DRAMCtrl@{DRAMCtrl}!numWrRetry@{numWrRetry}}
\index{numWrRetry@{numWrRetry}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{numWrRetry}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numWrRetry}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a961b9dc82d0ef2814dbdbc498a20e9b3}
\hypertarget{classDRAMCtrl_a8ec7f3dd4d238e4283760a15dc16c965}{
\index{DRAMCtrl@{DRAMCtrl}!pageHitRate@{pageHitRate}}
\index{pageHitRate@{pageHitRate}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{pageHitRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf pageHitRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a8ec7f3dd4d238e4283760a15dc16c965}
\hypertarget{classDRAMCtrl_a0ad0ee34c37f7b1694ad9aa4495c2c0f}{
\index{DRAMCtrl@{DRAMCtrl}!pageMgmt@{pageMgmt}}
\index{pageMgmt@{pageMgmt}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{pageMgmt}]{\setlength{\rightskip}{0pt plus 5cm}Enums::PageManage {\bf pageMgmt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a0ad0ee34c37f7b1694ad9aa4495c2c0f}
\hypertarget{classDRAMCtrl_af80252f1fcfad371b526eac5f9bf7e4f}{
\index{DRAMCtrl@{DRAMCtrl}!peakBW@{peakBW}}
\index{peakBW@{peakBW}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{peakBW}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf peakBW}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_af80252f1fcfad371b526eac5f9bf7e4f}
\hypertarget{classDRAMCtrl_a21da4bea3554874b557428e4cce5d4a4}{
\index{DRAMCtrl@{DRAMCtrl}!pendingDelete@{pendingDelete}}
\index{pendingDelete@{pendingDelete}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{pendingDelete}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf PacketPtr}$>$ {\bf pendingDelete}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a21da4bea3554874b557428e4cce5d4a4}
\begin{Desc}
\item[\hyperlink{todo__todo000083}{TODO}]this is a temporary workaround until the 4-\/phase code is committed. upstream caches needs this packet until true is returned, so hold onto it for deletion until a subsequent call \end{Desc}
\hypertarget{classDRAMCtrl_a1a6c6b88a19805ae5453e5811633f884}{
\index{DRAMCtrl@{DRAMCtrl}!perBankRdBursts@{perBankRdBursts}}
\index{perBankRdBursts@{perBankRdBursts}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{perBankRdBursts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf perBankRdBursts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a1a6c6b88a19805ae5453e5811633f884}
\hypertarget{classDRAMCtrl_ae757d149b2ff05a908b6ceb28f53decc}{
\index{DRAMCtrl@{DRAMCtrl}!perBankWrBursts@{perBankWrBursts}}
\index{perBankWrBursts@{perBankWrBursts}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{perBankWrBursts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf perBankWrBursts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ae757d149b2ff05a908b6ceb28f53decc}
\hypertarget{classDRAMCtrl_a55c076720c982014096b57cadebf9a14}{
\index{DRAMCtrl@{DRAMCtrl}!port@{port}}
\index{port@{port}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{port}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemoryPort} {\bf port}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a55c076720c982014096b57cadebf9a14}
Our incoming port, for a multi-\/ported controller add a crossbar in front of it \hypertarget{classDRAMCtrl_afb2cbddd4a31e9a3b11886230f18f44b}{
\index{DRAMCtrl@{DRAMCtrl}!powerEvent@{powerEvent}}
\index{powerEvent@{powerEvent}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{powerEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf DRAMCtrl},\&DRAMCtrl::processPowerEvent$>$ {\bf powerEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_afb2cbddd4a31e9a3b11886230f18f44b}
\hypertarget{classDRAMCtrl_a80cac8f63f85f5c7781367b8b728750f}{
\index{DRAMCtrl@{DRAMCtrl}!prechargeEvent@{prechargeEvent}}
\index{prechargeEvent@{prechargeEvent}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{prechargeEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf DRAMCtrl}, \&DRAMCtrl::processPrechargeEvent$>$ {\bf prechargeEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a80cac8f63f85f5c7781367b8b728750f}
\hypertarget{classDRAMCtrl_ae3e56b38f5969512cd915824ec1d5740}{
\index{DRAMCtrl@{DRAMCtrl}!prevArrival@{prevArrival}}
\index{prevArrival@{prevArrival}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{prevArrival}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf prevArrival}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ae3e56b38f5969512cd915824ec1d5740}
\hypertarget{classDRAMCtrl_a9c9c5adc18a56a35103536d6afddfd5f}{
\index{DRAMCtrl@{DRAMCtrl}!pwrState@{pwrState}}
\index{pwrState@{pwrState}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{pwrState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PowerState} {\bf pwrState}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a9c9c5adc18a56a35103536d6afddfd5f}
Current power state. \hypertarget{classDRAMCtrl_a06e80ba25d388ee981f9c88e27e189df}{
\index{DRAMCtrl@{DRAMCtrl}!pwrStateTick@{pwrStateTick}}
\index{pwrStateTick@{pwrStateTick}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{pwrStateTick}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf pwrStateTick}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a06e80ba25d388ee981f9c88e27e189df}
\hypertarget{classDRAMCtrl_ad084b0fe354d053d0f369a72b8559291}{
\index{DRAMCtrl@{DRAMCtrl}!pwrStateTime@{pwrStateTime}}
\index{pwrStateTime@{pwrStateTime}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{pwrStateTime}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf pwrStateTime}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ad084b0fe354d053d0f369a72b8559291}
\hypertarget{classDRAMCtrl_ab31f48c472ee16c28fc62b8be41b740e}{
\index{DRAMCtrl@{DRAMCtrl}!pwrStateTrans@{pwrStateTrans}}
\index{pwrStateTrans@{pwrStateTrans}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{pwrStateTrans}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PowerState} {\bf pwrStateTrans}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ab31f48c472ee16c28fc62b8be41b740e}
Since we are taking decisions out of order, we need to keep track of what power transition is happening at what time, such that we can go back in time and change history. For example, if we precharge all banks and schedule going to the idle state, we might at a later point decide to activate a bank before the transition to idle would have taken place. \hypertarget{classDRAMCtrl_afb57a2b8af54b8949b2c14434c74bd98}{
\index{DRAMCtrl@{DRAMCtrl}!ranksPerChannel@{ranksPerChannel}}
\index{ranksPerChannel@{ranksPerChannel}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{ranksPerChannel}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf ranksPerChannel}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_afb57a2b8af54b8949b2c14434c74bd98}
\hypertarget{classDRAMCtrl_aff56c8c0df213e51ad714cb2b0df2de3}{
\index{DRAMCtrl@{DRAMCtrl}!rdPerTurnAround@{rdPerTurnAround}}
\index{rdPerTurnAround@{rdPerTurnAround}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{rdPerTurnAround}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram} {\bf rdPerTurnAround}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_aff56c8c0df213e51ad714cb2b0df2de3}
\hypertarget{classDRAMCtrl_a34cdc0482a9faf13f94abb3a37fa90b8}{
\index{DRAMCtrl@{DRAMCtrl}!rdQLenPdf@{rdQLenPdf}}
\index{rdQLenPdf@{rdQLenPdf}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{rdQLenPdf}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf rdQLenPdf}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a34cdc0482a9faf13f94abb3a37fa90b8}
\hypertarget{classDRAMCtrl_a7a26078fba8217391c336c615ce8ab69}{
\index{DRAMCtrl@{DRAMCtrl}!readBufferSize@{readBufferSize}}
\index{readBufferSize@{readBufferSize}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{readBufferSize}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf readBufferSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a7a26078fba8217391c336c615ce8ab69}
\hypertarget{classDRAMCtrl_a342b92d18cc1b861071c5b596f127de8}{
\index{DRAMCtrl@{DRAMCtrl}!readBursts@{readBursts}}
\index{readBursts@{readBursts}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{readBursts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf readBursts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a342b92d18cc1b861071c5b596f127de8}
\hypertarget{classDRAMCtrl_aee4577f07fe67bcc60ba3c504b35c9f3}{
\index{DRAMCtrl@{DRAMCtrl}!readPktSize@{readPktSize}}
\index{readPktSize@{readPktSize}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{readPktSize}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf readPktSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_aee4577f07fe67bcc60ba3c504b35c9f3}
\hypertarget{classDRAMCtrl_af799cb4e1a6e82bcb68ff9354bdf6876}{
\index{DRAMCtrl@{DRAMCtrl}!readQueue@{readQueue}}
\index{readQueue@{readQueue}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{readQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::deque}$<${\bf DRAMPacket}$\ast$$>$ {\bf readQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_af799cb4e1a6e82bcb68ff9354bdf6876}
The controller's main read and write queues \hypertarget{classDRAMCtrl_a8baa6fa0f23d432bebbbf1f3845c9cd5}{
\index{DRAMCtrl@{DRAMCtrl}!readReqs@{readReqs}}
\index{readReqs@{readReqs}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{readReqs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf readReqs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a8baa6fa0f23d432bebbbf1f3845c9cd5}
\hypertarget{classDRAMCtrl_a085bc7747d9a41218a9de406bf814c64}{
\index{DRAMCtrl@{DRAMCtrl}!readRowHitRate@{readRowHitRate}}
\index{readRowHitRate@{readRowHitRate}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{readRowHitRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf readRowHitRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a085bc7747d9a41218a9de406bf814c64}
\hypertarget{classDRAMCtrl_a7f3862d0c1944536c2ec30b0d012e288}{
\index{DRAMCtrl@{DRAMCtrl}!readRowHits@{readRowHits}}
\index{readRowHits@{readRowHits}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{readRowHits}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf readRowHits}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a7f3862d0c1944536c2ec30b0d012e288}
\hypertarget{classDRAMCtrl_a72f27fd33d5f9c72099763cf6c518b87}{
\index{DRAMCtrl@{DRAMCtrl}!readsThisTime@{readsThisTime}}
\index{readsThisTime@{readsThisTime}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{readsThisTime}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf readsThisTime}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a72f27fd33d5f9c72099763cf6c518b87}
\hypertarget{classDRAMCtrl_adee1f5c3afbe3ccf89880cde10ff9478}{
\index{DRAMCtrl@{DRAMCtrl}!refreshDueAt@{refreshDueAt}}
\index{refreshDueAt@{refreshDueAt}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{refreshDueAt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf refreshDueAt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_adee1f5c3afbe3ccf89880cde10ff9478}
Keep track of when a refresh is due. \hypertarget{classDRAMCtrl_a0bc8ce4f4a849871eb32bd983b5d2843}{
\index{DRAMCtrl@{DRAMCtrl}!refreshEvent@{refreshEvent}}
\index{refreshEvent@{refreshEvent}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{refreshEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf DRAMCtrl}, \&DRAMCtrl::processRefreshEvent$>$ {\bf refreshEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a0bc8ce4f4a849871eb32bd983b5d2843}
\hypertarget{classDRAMCtrl_aa74cbca6192755f3cec9950a97c90342}{
\index{DRAMCtrl@{DRAMCtrl}!refreshState@{refreshState}}
\index{refreshState@{refreshState}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{refreshState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RefreshState} {\bf refreshState}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_aa74cbca6192755f3cec9950a97c90342}
\hypertarget{classDRAMCtrl_a31bec941f92f261930a6df5cf9fb166e}{
\index{DRAMCtrl@{DRAMCtrl}!respondEvent@{respondEvent}}
\index{respondEvent@{respondEvent}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{respondEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf DRAMCtrl}, \&DRAMCtrl::processRespondEvent$>$ {\bf respondEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a31bec941f92f261930a6df5cf9fb166e}
\hypertarget{classDRAMCtrl_a04637ab08ad048aa826537a67dba4654}{
\index{DRAMCtrl@{DRAMCtrl}!respQueue@{respQueue}}
\index{respQueue@{respQueue}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{respQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::deque}$<${\bf DRAMPacket}$\ast$$>$ {\bf respQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a04637ab08ad048aa826537a67dba4654}
Response queue where read packets wait after we're done working with them, but it's not time to send the response yet. The responses are stored seperately mostly to keep the code clean and help with events scheduling. For all logical purposes such as sizing the read queue, this and the main read queue need to be added together. \hypertarget{classDRAMCtrl_aa4e05579e39e0e1ae7859ddba8538932}{
\index{DRAMCtrl@{DRAMCtrl}!retryRdReq@{retryRdReq}}
\index{retryRdReq@{retryRdReq}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{retryRdReq}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf retryRdReq}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_aa4e05579e39e0e1ae7859ddba8538932}
Remember if we have to retry a request when available. \hypertarget{classDRAMCtrl_acf0d3616b5317008b8248aa2245df220}{
\index{DRAMCtrl@{DRAMCtrl}!retryWrReq@{retryWrReq}}
\index{retryWrReq@{retryWrReq}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{retryWrReq}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf retryWrReq}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_acf0d3616b5317008b8248aa2245df220}
\hypertarget{classDRAMCtrl_abe6f704496dadf8c0b246eb57b4e25d5}{
\index{DRAMCtrl@{DRAMCtrl}!rowBufferSize@{rowBufferSize}}
\index{rowBufferSize@{rowBufferSize}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{rowBufferSize}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf rowBufferSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_abe6f704496dadf8c0b246eb57b4e25d5}
\hypertarget{classDRAMCtrl_ad878fffffe428b1673a17f489f5a4e94}{
\index{DRAMCtrl@{DRAMCtrl}!rowsPerBank@{rowsPerBank}}
\index{rowsPerBank@{rowsPerBank}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{rowsPerBank}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf rowsPerBank}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ad878fffffe428b1673a17f489f5a4e94}
\hypertarget{classDRAMCtrl_a234c092fa122ea27676236c3b6f11bcb}{
\index{DRAMCtrl@{DRAMCtrl}!servicedByWrQ@{servicedByWrQ}}
\index{servicedByWrQ@{servicedByWrQ}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{servicedByWrQ}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf servicedByWrQ}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a234c092fa122ea27676236c3b6f11bcb}
\hypertarget{classDRAMCtrl_a15520c5298cfcc33032b7f0e363f7a3d}{
\index{DRAMCtrl@{DRAMCtrl}!tBURST@{tBURST}}
\index{tBURST@{tBURST}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{tBURST}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf tBURST}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a15520c5298cfcc33032b7f0e363f7a3d}
\hypertarget{classDRAMCtrl_a9cd12bc6d433964d98ff2386c03e5246}{
\index{DRAMCtrl@{DRAMCtrl}!tCK@{tCK}}
\index{tCK@{tCK}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{tCK}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf tCK}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a9cd12bc6d433964d98ff2386c03e5246}
Basic memory timing parameters initialized based on parameter values. \hypertarget{classDRAMCtrl_a96c42cd586bf995db505fbb5c0252ac1}{
\index{DRAMCtrl@{DRAMCtrl}!tCL@{tCL}}
\index{tCL@{tCL}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{tCL}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf tCL}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a96c42cd586bf995db505fbb5c0252ac1}
\hypertarget{classDRAMCtrl_abbb23dd61d5f4a897a59ea51328ad3fd}{
\index{DRAMCtrl@{DRAMCtrl}!totBusLat@{totBusLat}}
\index{totBusLat@{totBusLat}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{totBusLat}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf totBusLat}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_abbb23dd61d5f4a897a59ea51328ad3fd}
\hypertarget{classDRAMCtrl_ad5c827068947b103cac8503aa45cf6e5}{
\index{DRAMCtrl@{DRAMCtrl}!totGap@{totGap}}
\index{totGap@{totGap}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{totGap}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf totGap}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ad5c827068947b103cac8503aa45cf6e5}
\hypertarget{classDRAMCtrl_a9aa73ba3e536064d1686b6489e57a4bf}{
\index{DRAMCtrl@{DRAMCtrl}!totMemAccLat@{totMemAccLat}}
\index{totMemAccLat@{totMemAccLat}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{totMemAccLat}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf totMemAccLat}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a9aa73ba3e536064d1686b6489e57a4bf}
\hypertarget{classDRAMCtrl_a3eea84ec922ff55ae38676da7222cd01}{
\index{DRAMCtrl@{DRAMCtrl}!totQLat@{totQLat}}
\index{totQLat@{totQLat}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{totQLat}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf totQLat}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a3eea84ec922ff55ae38676da7222cd01}
\hypertarget{classDRAMCtrl_a91e2a0dae0024646d5cf40c844996bcc}{
\index{DRAMCtrl@{DRAMCtrl}!tRAS@{tRAS}}
\index{tRAS@{tRAS}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{tRAS}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf tRAS}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a91e2a0dae0024646d5cf40c844996bcc}
\hypertarget{classDRAMCtrl_a482d43285a450eeb021dcb7065741b33}{
\index{DRAMCtrl@{DRAMCtrl}!tRCD@{tRCD}}
\index{tRCD@{tRCD}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{tRCD}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf tRCD}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a482d43285a450eeb021dcb7065741b33}
\hypertarget{classDRAMCtrl_a2082aad1296022a7ff2d7b1a95bae882}{
\index{DRAMCtrl@{DRAMCtrl}!tREFI@{tREFI}}
\index{tREFI@{tREFI}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{tREFI}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf tREFI}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a2082aad1296022a7ff2d7b1a95bae882}
\hypertarget{classDRAMCtrl_ada7c680f071957137175c60c125b929a}{
\index{DRAMCtrl@{DRAMCtrl}!tRFC@{tRFC}}
\index{tRFC@{tRFC}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{tRFC}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf tRFC}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ada7c680f071957137175c60c125b929a}
\hypertarget{classDRAMCtrl_aa3828096d625ef4b6b497ce02b3fac85}{
\index{DRAMCtrl@{DRAMCtrl}!tRP@{tRP}}
\index{tRP@{tRP}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{tRP}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf tRP}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_aa3828096d625ef4b6b497ce02b3fac85}
\hypertarget{classDRAMCtrl_ac09c7763d97a33e93c89f266ed29df29}{
\index{DRAMCtrl@{DRAMCtrl}!tRRD@{tRRD}}
\index{tRRD@{tRRD}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{tRRD}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf tRRD}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ac09c7763d97a33e93c89f266ed29df29}
\hypertarget{classDRAMCtrl_a850e39d6fd527d4992315e86a8978292}{
\index{DRAMCtrl@{DRAMCtrl}!tRTP@{tRTP}}
\index{tRTP@{tRTP}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{tRTP}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf tRTP}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a850e39d6fd527d4992315e86a8978292}
\hypertarget{classDRAMCtrl_a578e383b38a4b65988799b3c16c4c17d}{
\index{DRAMCtrl@{DRAMCtrl}!tRTW@{tRTW}}
\index{tRTW@{tRTW}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{tRTW}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf tRTW}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a578e383b38a4b65988799b3c16c4c17d}
\hypertarget{classDRAMCtrl_a3c3ee9ca057928cc876fc54a20356535}{
\index{DRAMCtrl@{DRAMCtrl}!tWR@{tWR}}
\index{tWR@{tWR}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{tWR}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf tWR}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a3c3ee9ca057928cc876fc54a20356535}
\hypertarget{classDRAMCtrl_a33aeea1fd32ea7035fc8ca3a32f75473}{
\index{DRAMCtrl@{DRAMCtrl}!tWTR@{tWTR}}
\index{tWTR@{tWTR}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{tWTR}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf tWTR}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a33aeea1fd32ea7035fc8ca3a32f75473}
\hypertarget{classDRAMCtrl_a32fe8eab168b3a01214255fde6091e0b}{
\index{DRAMCtrl@{DRAMCtrl}!tXAW@{tXAW}}
\index{tXAW@{tXAW}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{tXAW}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf tXAW}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a32fe8eab168b3a01214255fde6091e0b}
\hypertarget{classDRAMCtrl_ae1cedccfe0fe11c2bd10c28f4be1ea63}{
\index{DRAMCtrl@{DRAMCtrl}!writeBufferSize@{writeBufferSize}}
\index{writeBufferSize@{writeBufferSize}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{writeBufferSize}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf writeBufferSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ae1cedccfe0fe11c2bd10c28f4be1ea63}
\hypertarget{classDRAMCtrl_a14baa61a63ebc1c4ce4aa1930aa9ba50}{
\index{DRAMCtrl@{DRAMCtrl}!writeBursts@{writeBursts}}
\index{writeBursts@{writeBursts}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{writeBursts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf writeBursts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a14baa61a63ebc1c4ce4aa1930aa9ba50}
\hypertarget{classDRAMCtrl_a61f48157d680c1ddf7dd818c9008dd53}{
\index{DRAMCtrl@{DRAMCtrl}!writeHighThreshold@{writeHighThreshold}}
\index{writeHighThreshold@{writeHighThreshold}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{writeHighThreshold}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf writeHighThreshold}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a61f48157d680c1ddf7dd818c9008dd53}
\hypertarget{classDRAMCtrl_a803b97da34c3b40357123d5713e6ab4a}{
\index{DRAMCtrl@{DRAMCtrl}!writeLowThreshold@{writeLowThreshold}}
\index{writeLowThreshold@{writeLowThreshold}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{writeLowThreshold}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf writeLowThreshold}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a803b97da34c3b40357123d5713e6ab4a}
\hypertarget{classDRAMCtrl_aecc027383223e3500a37a9646607df81}{
\index{DRAMCtrl@{DRAMCtrl}!writePktSize@{writePktSize}}
\index{writePktSize@{writePktSize}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{writePktSize}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf writePktSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_aecc027383223e3500a37a9646607df81}
\hypertarget{classDRAMCtrl_a3286652a16bd92e1fd02c6a5f42b83a1}{
\index{DRAMCtrl@{DRAMCtrl}!writeQueue@{writeQueue}}
\index{writeQueue@{writeQueue}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{writeQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::deque}$<${\bf DRAMPacket}$\ast$$>$ {\bf writeQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a3286652a16bd92e1fd02c6a5f42b83a1}
\hypertarget{classDRAMCtrl_afb65580143c89e0011c2878c20e8ed0a}{
\index{DRAMCtrl@{DRAMCtrl}!writeReqs@{writeReqs}}
\index{writeReqs@{writeReqs}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{writeReqs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf writeReqs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_afb65580143c89e0011c2878c20e8ed0a}
\hypertarget{classDRAMCtrl_ae193ec834aceec0ed536dc53ec409f22}{
\index{DRAMCtrl@{DRAMCtrl}!writeRowHitRate@{writeRowHitRate}}
\index{writeRowHitRate@{writeRowHitRate}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{writeRowHitRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf writeRowHitRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ae193ec834aceec0ed536dc53ec409f22}
\hypertarget{classDRAMCtrl_a5b75e7220ef0da8a50fe5777a9a1ae52}{
\index{DRAMCtrl@{DRAMCtrl}!writeRowHits@{writeRowHits}}
\index{writeRowHits@{writeRowHits}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{writeRowHits}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf writeRowHits}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a5b75e7220ef0da8a50fe5777a9a1ae52}
\hypertarget{classDRAMCtrl_a332d2848d0e28912ff8b0c8c9e09842a}{
\index{DRAMCtrl@{DRAMCtrl}!writesThisTime@{writesThisTime}}
\index{writesThisTime@{writesThisTime}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{writesThisTime}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf writesThisTime}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a332d2848d0e28912ff8b0c8c9e09842a}
\hypertarget{classDRAMCtrl_a6f8f6528076f5f3f9d56b7658368a781}{
\index{DRAMCtrl@{DRAMCtrl}!wrPerTurnAround@{wrPerTurnAround}}
\index{wrPerTurnAround@{wrPerTurnAround}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{wrPerTurnAround}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram} {\bf wrPerTurnAround}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_a6f8f6528076f5f3f9d56b7658368a781}
\hypertarget{classDRAMCtrl_ace3009d78850dc82f90724de8df96227}{
\index{DRAMCtrl@{DRAMCtrl}!wrQLenPdf@{wrQLenPdf}}
\index{wrQLenPdf@{wrQLenPdf}!DRAMCtrl@{DRAMCtrl}}
\subsubsection[{wrQLenPdf}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf wrQLenPdf}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_ace3009d78850dc82f90724de8df96227}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{dram__ctrl_8hh}{dram\_\-ctrl.hh}\item 
mem/\hyperlink{dram__ctrl_8cc}{dram\_\-ctrl.cc}\end{DoxyCompactItemize}
