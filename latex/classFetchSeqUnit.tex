\hypertarget{classFetchSeqUnit}{
\section{クラス FetchSeqUnit}
\label{classFetchSeqUnit}\index{FetchSeqUnit@{FetchSeqUnit}}
}


{\ttfamily \#include $<$fetch\_\-seq\_\-unit.hh$>$}FetchSeqUnitに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classFetchSeqUnit}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classFetchSeqUnit_1_1FetchSeqEvent}{FetchSeqEvent}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classFetchSeqUnit_a2afce0a47a93eee73a314d53e4890153}{Command} \{ \hyperlink{classFetchSeqUnit_a2afce0a47a93eee73a314d53e4890153a01d26f167ac9e921c263bbcd80dd3bc4}{AssignNextPC}, 
\hyperlink{classFetchSeqUnit_a2afce0a47a93eee73a314d53e4890153abf7b003b9980c66157a424a6142f1c38}{UpdateTargetPC}
 \}
\item 
typedef \hyperlink{classRefCountingPtr}{ThePipeline::DynInstPtr} \hyperlink{classFetchSeqUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{DynInstPtr}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classRefCountingPtr}{DynInstPtr} $>$::iterator \hyperlink{classFetchSeqUnit_a184cb829e22cc656acb41864f68f51ea}{ListIt}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classFetchSeqUnit_ae6f057ce72f6f86ce462fbca75d64a67}{FetchSeqUnit} (std::string res\_\-name, int res\_\-id, int res\_\-width, \hyperlink{classCycles}{Cycles} res\_\-latency, \hyperlink{classInOrderCPU}{InOrderCPU} $\ast$\_\-cpu, \hyperlink{namespaceThePipeline_ab62ca16eeca26566ad2422b5df4943ce}{ThePipeline::Params} $\ast$params)
\item 
\hyperlink{classFetchSeqUnit_ab25f7626363f6e2ac1e2e1b838d9f74a}{$\sim$FetchSeqUnit} ()
\item 
void \hyperlink{classFetchSeqUnit_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
void \hyperlink{classFetchSeqUnit_a687aa4600423bb30ecf3bb1da6cd6000}{activateThread} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classFetchSeqUnit_ad11d9216ad92d9036ebf37844cf6e706}{deactivateThread} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classFetchSeqUnit_aee7a498a20266fbfbc6aa3f165577b68}{suspendThread} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classFetchSeqUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{execute} (int slot\_\-num)
\item 
void \hyperlink{classFetchSeqUnit_a339073618ad3c21c492d64a55ce2e216}{updateAfterContextSwitch} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classFetchSeqUnit_a48e371fe43e53aebbe5b2b2afc5aa8e3}{squash} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, int squash\_\-stage, \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} squash\_\-seq\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classFetchSeqUnit_abf76d6d245f7d3b17d26ea8dcc0cf36f}{trap} (\hyperlink{classRefCountingPtr}{Fault} fault, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid, \hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
unsigned \hyperlink{classFetchSeqUnit_ae3208e633eb913a59f8a49ba2c65840c}{instSize}
\item 
bool \hyperlink{classFetchSeqUnit_ae0f86f031bb34b0540e5ebcfaa2de630}{pcValid} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
int \hyperlink{classFetchSeqUnit_acd6cfe08097e99df8b2ef586c47d87fa}{pcBlockStage} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
TheISA::PCState \hyperlink{classFetchSeqUnit_a61bb24b7355c86288cba2cd9d51ad1ed}{pc} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classFetchSeqUnit_a8c48389ee147811c1be413cdd4be4b68}{squashSeqNum} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classFetchSeqUnit_a07ac7fa00a59be2904eaa76d4735681e}{lastSquashCycle} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classFetchSeqUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{
\index{FetchSeqUnit@{FetchSeqUnit}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf ThePipeline::DynInstPtr} {\bf DynInstPtr}}}
\label{classFetchSeqUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}


\hyperlink{classResource_af9d0c8a46736ba6aa2d8bb94da1a5e73}{Resource}を再定義しています。\hypertarget{classFetchSeqUnit_a184cb829e22cc656acb41864f68f51ea}{
\index{FetchSeqUnit@{FetchSeqUnit}!ListIt@{ListIt}}
\index{ListIt@{ListIt}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{ListIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf DynInstPtr}$>$::iterator {\bf ListIt}}}
\label{classFetchSeqUnit_a184cb829e22cc656acb41864f68f51ea}


\subsection{列挙型}
\hypertarget{classFetchSeqUnit_a2afce0a47a93eee73a314d53e4890153}{
\index{FetchSeqUnit@{FetchSeqUnit}!Command@{Command}}
\index{Command@{Command}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{Command}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Command}}}
\label{classFetchSeqUnit_a2afce0a47a93eee73a314d53e4890153}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{AssignNextPC@{AssignNextPC}!FetchSeqUnit@{FetchSeqUnit}}\index{FetchSeqUnit@{FetchSeqUnit}!AssignNextPC@{AssignNextPC}}\item[{\em 
\hypertarget{classFetchSeqUnit_a2afce0a47a93eee73a314d53e4890153a01d26f167ac9e921c263bbcd80dd3bc4}{
AssignNextPC}
\label{classFetchSeqUnit_a2afce0a47a93eee73a314d53e4890153a01d26f167ac9e921c263bbcd80dd3bc4}
}]\index{UpdateTargetPC@{UpdateTargetPC}!FetchSeqUnit@{FetchSeqUnit}}\index{FetchSeqUnit@{FetchSeqUnit}!UpdateTargetPC@{UpdateTargetPC}}\item[{\em 
\hypertarget{classFetchSeqUnit_a2afce0a47a93eee73a314d53e4890153abf7b003b9980c66157a424a6142f1c38}{
UpdateTargetPC}
\label{classFetchSeqUnit_a2afce0a47a93eee73a314d53e4890153abf7b003b9980c66157a424a6142f1c38}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
50                  {
51         AssignNextPC,
52         UpdateTargetPC
53     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classFetchSeqUnit_ae6f057ce72f6f86ce462fbca75d64a67}{
\index{FetchSeqUnit@{FetchSeqUnit}!FetchSeqUnit@{FetchSeqUnit}}
\index{FetchSeqUnit@{FetchSeqUnit}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{FetchSeqUnit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FetchSeqUnit} (std::string {\em res\_\-name}, \/  int {\em res\_\-id}, \/  int {\em res\_\-width}, \/  {\bf Cycles} {\em res\_\-latency}, \/  {\bf InOrderCPU} $\ast$ {\em \_\-cpu}, \/  {\bf ThePipeline::Params} $\ast$ {\em params})}}
\label{classFetchSeqUnit_ae6f057ce72f6f86ce462fbca75d64a67}



\begin{DoxyCode}
45     : Resource(res_name, res_id, res_width, res_latency, _cpu),
46       instSize(sizeof(MachInst))
47 {
48     for (ThreadID tid = 0; tid < ThePipeline::MaxThreads; tid++) {
49         pcValid[tid] = false;
50         pcBlockStage[tid] = 0;
51 
52         //@todo: Use CPU's squashSeqNum here instead of maintaining our own
53         // state
54         squashSeqNum[tid] = (InstSeqNum)-1;
55         lastSquashCycle[tid] = 0;
56     }
57 }
\end{DoxyCode}
\hypertarget{classFetchSeqUnit_ab25f7626363f6e2ac1e2e1b838d9f74a}{
\index{FetchSeqUnit@{FetchSeqUnit}!$\sim$FetchSeqUnit@{$\sim$FetchSeqUnit}}
\index{$\sim$FetchSeqUnit@{$\sim$FetchSeqUnit}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{$\sim$FetchSeqUnit}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf FetchSeqUnit} ()}}
\label{classFetchSeqUnit_ab25f7626363f6e2ac1e2e1b838d9f74a}



\begin{DoxyCode}
60 {
61     delete [] resourceEvent;
62 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classFetchSeqUnit_a687aa4600423bb30ecf3bb1da6cd6000}{
\index{FetchSeqUnit@{FetchSeqUnit}!activateThread@{activateThread}}
\index{activateThread@{activateThread}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{activateThread}]{\setlength{\rightskip}{0pt plus 5cm}void activateThread ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFetchSeqUnit_a687aa4600423bb30ecf3bb1da6cd6000}
Resources that care about thread activation override this. 

\hyperlink{classResource_ab75d2f4e158982d66b44263d96cdd058}{Resource}を再定義しています。


\begin{DoxyCode}
272 {
273     pcValid[tid] = true;
274 
275     pc[tid] = cpu->pcState(tid);
276 
277     cpu->fetchPriorityList.push_back(tid);
278 
279     DPRINTF(InOrderFetchSeq, "[tid:%i]: Reading PC: %s.\n",
280             tid, pc[tid]);
281 }
\end{DoxyCode}
\hypertarget{classFetchSeqUnit_ad11d9216ad92d9036ebf37844cf6e706}{
\index{FetchSeqUnit@{FetchSeqUnit}!deactivateThread@{deactivateThread}}
\index{deactivateThread@{deactivateThread}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{deactivateThread}]{\setlength{\rightskip}{0pt plus 5cm}void deactivateThread ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFetchSeqUnit_ad11d9216ad92d9036ebf37844cf6e706}
Deactivate Thread. Default action is to squash all instructions from deactivated thread. 

\hyperlink{classResource_ad11d9216ad92d9036ebf37844cf6e706}{Resource}を再定義しています。


\begin{DoxyCode}
285 {
286     pcValid[tid] = false;
287     pcBlockStage[tid] = 0;
288 
289     squashSeqNum[tid] = (InstSeqNum)-1;
290     lastSquashCycle[tid] = 0;
291 
292     list<ThreadID>::iterator thread_it = find(cpu->fetchPriorityList.begin(),
293                                               cpu->fetchPriorityList.end(),
294                                               tid);
295 
296     if (thread_it != cpu->fetchPriorityList.end())
297         cpu->fetchPriorityList.erase(thread_it);
298 }
\end{DoxyCode}
\hypertarget{classFetchSeqUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{
\index{FetchSeqUnit@{FetchSeqUnit}!execute@{execute}}
\index{execute@{execute}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{execute}]{\setlength{\rightskip}{0pt plus 5cm}void execute (int {\em slot\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFetchSeqUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}
Execute the function of this resource. The Default is action is to do nothing. More specific models will derive from this class and define their own execute function. 

\hyperlink{classResource_a39af49c5568d1db3f53c12d7d6914c32}{Resource}を再定義しています。


\begin{DoxyCode}
78 {
79     ResourceRequest* fs_req = reqs[slot_num];
80     DynInstPtr inst = fs_req->inst;
81     ThreadID tid = inst->readTid();
82     int stage_num = fs_req->getStageNum();
83 
84     if (inst->fault != NoFault) {
85         DPRINTF(InOrderFetchSeq,
86                 "[tid:%i]: [sn:%i]: Detected %s fault @ %x. Forwarding to "
87                 "next stage.\n", tid, inst->seqNum, inst->fault->name(),
88                 inst->pcState());
89         fs_req->done();
90         return;
91     }
92 
93     switch (fs_req->cmd)
94     {
95       case AssignNextPC:
96         {
97             DPRINTF(InOrderFetchSeq, "[tid:%i]: Current PC is %s\n", tid,
98                     pc[tid]);
99 
100             if (pcValid[tid]) {
101                 inst->pcState(pc[tid]);
102                 inst->setMemAddr(pc[tid].instAddr());
103 
104                 // Advance to next PC (typically PC + 4)
105                 pc[tid].advance();
106 
107                 inst->setSeqNum(cpu->getAndIncrementInstSeq(tid));
108 
109                 DPRINTF(InOrderFetchSeq, "[tid:%i]: Assigning [sn:%i] to "
110                         "PC %s\n", tid, inst->seqNum, inst->pcState());
111 
112                 fs_req->done();
113             } else {
114                 DPRINTF(InOrderStall, "STALL: [tid:%i]: NPC not valid\n", tid);
115                 fs_req->done(false);
116             }
117         }
118         break;
119 
120       case UpdateTargetPC:
121         {
122             assert(!inst->isCondDelaySlot()  &&
123                    "Not Handling Conditional Delay Slot");
124 
125             if (inst->isControl()) {
126                 if (inst->isReturn() && !inst->predTaken()) {
127                     // If it's a return, then we must wait for resolved address.
128                     // The Predictor will mark a return a false as "not taken"
129                     // if there is no RAS entry
130                     DPRINTF(InOrderFetchSeq, "[tid:%d]: Setting block signal "
131                             "for stage %i.\n",
132                             tid, stage_num);
133                     cpu->pipelineStage[stage_num]->
134                         toPrevStages->stageBlock[stage_num][tid] = true;
135                     pcValid[tid] = false;
136                     pcBlockStage[tid] = stage_num;
137                 } else if (inst->predTaken()) {
138                     // Taken Control
139                     inst->setSquashInfo(stage_num);
140                     setupSquash(inst, stage_num, tid);
141 
142                     DPRINTF(InOrderFetchSeq, "[tid:%i] Setting up squash to "
143                             "start from stage %i, after [sn:%i].\n",
144                             tid, stage_num, inst->squashSeqNum);
145                 }
146             } else {
147                 DPRINTF(InOrderFetchSeq, "[tid:%i]: [sn:%i]: Ignoring branch "
148                         "target update since then is not a control "
149                         "instruction.\n", tid, inst->seqNum);
150             }
151 
152             fs_req->done();
153         }
154         break;
155 
156       default:
157         fatal("Unrecognized command to %s", resName);
158     }
159 }
\end{DoxyCode}
\hypertarget{classFetchSeqUnit_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{FetchSeqUnit@{FetchSeqUnit}!init@{init}}
\index{init@{init}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFetchSeqUnit_a02fd73d861ef2e4aabb38c0c9ff82947}
Any extra initiliazation stuff can be set up using this function that should get called before the simulation starts (tick 0) 

\hyperlink{classResource_a02fd73d861ef2e4aabb38c0c9ff82947}{Resource}を再定義しています。


\begin{DoxyCode}
66 {
67     resourceEvent = new FetchSeqEvent[width];
68 
69     for (int i = 0; i < width; i++) {
70         reqs[i] = new ResourceRequest(this);
71     }
72 
73     initSlots();
74 }
\end{DoxyCode}
\hypertarget{classFetchSeqUnit_a48e371fe43e53aebbe5b2b2afc5aa8e3}{
\index{FetchSeqUnit@{FetchSeqUnit}!squash@{squash}}
\index{squash@{squash}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash ({\bf DynInstPtr} {\em inst}, \/  int {\em squash\_\-stage}, \/  {\bf InstSeqNum} {\em squash\_\-seq\_\-num}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFetchSeqUnit_a48e371fe43e53aebbe5b2b2afc5aa8e3}
Update to correct PC from a squash 

\hyperlink{classResource_a52235c5e3d912452f254dc45f1496fd2}{Resource}を再定義しています。


\begin{DoxyCode}
164 {
165     DPRINTF(InOrderFetchSeq, "[tid:%i]: Updating due to squash from %s (%s) "
166             "stage %i.\n", tid, inst->instName(), inst->pcState(),
167             squash_stage);
168 
169     if (lastSquashCycle[tid] == curTick() &&
170         squashSeqNum[tid] <= squash_seq_num) {
171         DPRINTF(InOrderFetchSeq, "[tid:%i]: Ignoring squash from stage %i, "
172                 "since there is an outstanding squash that is older.\n",
173                 tid, squash_stage);
174     } else {
175         squashSeqNum[tid] = squash_seq_num;
176         lastSquashCycle[tid] = curTick();
177 
178         if (inst->staticInst) {
179             if (inst->fault != NoFault) {
180                 // A Trap Caused This Fault and will update the pc state
181                 // when done trapping
182                 DPRINTF(InOrderFetchSeq, "[tid:%i] Blocking due to fault @ "
183                         "[sn:%i].%s %s \n", tid, inst->seqNum,
184                         inst->instName(), inst->pcState());
185                 pcValid[tid] = false;
186             } else {
187                 TheISA::PCState nextPC;
188                 assert(inst->staticInst);
189                 if (inst->isControl()) {
190                     nextPC = inst->readPredTarg();
191 
192                     // If we are already fetching this PC then advance to next PC
      
193                     // =======
194                     // This should handle ISAs w/delay slots and annulled delay
195                     // slots to figure out which is the next PC to fetch after
196                     // a mispredict
197                     DynInstPtr bdelay_inst = NULL;
198                     ListIt bdelay_it;
199                     if (inst->onInstList) {
200                         bdelay_it = inst->getInstListIt();
201                         bdelay_it++;
202                     } else {
203                         InstSeqNum branch_delay_num = inst->seqNum + 1;
204                         bdelay_it = cpu->findInst(branch_delay_num, tid);
205                     }
206 
207                     if (bdelay_it != cpu->instList[tid].end()) {
208                         bdelay_inst = (*bdelay_it);
209                     }
210 
211                     if (bdelay_inst) {
212                         if (bdelay_inst->pc.instAddr() == nextPC.instAddr()) {
213                             bdelay_inst->pc = nextPC;
214                             advancePC(nextPC, inst->staticInst);
215                             DPRINTF(InOrderFetchSeq, "Advanced PC to %s\n", nextP
      C);
216                         }
217                     }
218                 } else {
219                     nextPC = inst->pcState();
220                     advancePC(nextPC, inst->staticInst);
221                 }
222 
223 
224                 DPRINTF(InOrderFetchSeq, "[tid:%i]: Setting PC to %s.\n",
225                         tid, nextPC);
226                 pc[tid] = nextPC;
227 
228                 // Unblock Any Stages Waiting for this information to be updated 
      ...
229                 if (!pcValid[tid]) {
230                     DPRINTF(InOrderFetchSeq, "[tid:%d]: Setting unblock signal "
231                             "for stage %i.\n",
232                             tid, pcBlockStage[tid]);
233 
234                     // Need to use "fromNextStages" instead of "toPrevStages"
235                     // because the timebuffer will have already have advanced
236                     // in the tick function and this squash function will happen 
      after
237                     // the tick
238                     cpu->pipelineStage[pcBlockStage[tid]]->
239                         fromNextStages->stageUnblock[pcBlockStage[tid]][tid] = tr
      ue;
240                 }
241 
242                 pcValid[tid] = true;
243             }
244         }
245     }
246 
247     Resource::squash(inst, squash_stage, squash_seq_num, tid);
248 }
\end{DoxyCode}
\hypertarget{classFetchSeqUnit_aee7a498a20266fbfbc6aa3f165577b68}{
\index{FetchSeqUnit@{FetchSeqUnit}!suspendThread@{suspendThread}}
\index{suspendThread@{suspendThread}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{suspendThread}]{\setlength{\rightskip}{0pt plus 5cm}void suspendThread ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFetchSeqUnit_aee7a498a20266fbfbc6aa3f165577b68}
Resources that care about thread activation override this. 

\hyperlink{classResource_ad2f3fddbc6dd67ef5e3a84cd7a9814e6}{Resource}を再定義しています。


\begin{DoxyCode}
302 {
303     deactivateThread(tid);    
304 }
\end{DoxyCode}
\hypertarget{classFetchSeqUnit_abf76d6d245f7d3b17d26ea8dcc0cf36f}{
\index{FetchSeqUnit@{FetchSeqUnit}!trap@{trap}}
\index{trap@{trap}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{trap}]{\setlength{\rightskip}{0pt plus 5cm}void trap ({\bf Fault} {\em fault}, \/  {\bf ThreadID} {\em tid}, \/  {\bf DynInstPtr} {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFetchSeqUnit_abf76d6d245f7d3b17d26ea8dcc0cf36f}
Update to correct PC from a trap 

\hyperlink{classResource_a1eb2a0229740a87bde0282416035b864}{Resource}を再定義しています。


\begin{DoxyCode}
308 {
309     pcValid[tid] = true;
310     pc[tid] = cpu->pcState(tid);
311     DPRINTF(InOrderFetchSeq, "[tid:%i]: Trap updating to PC: "
312             "%s.\n", tid, pc[tid]);
313 }
\end{DoxyCode}
\hypertarget{classFetchSeqUnit_a339073618ad3c21c492d64a55ce2e216}{
\index{FetchSeqUnit@{FetchSeqUnit}!updateAfterContextSwitch@{updateAfterContextSwitch}}
\index{updateAfterContextSwitch@{updateAfterContextSwitch}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{updateAfterContextSwitch}]{\setlength{\rightskip}{0pt plus 5cm}void updateAfterContextSwitch ({\bf DynInstPtr} {\em inst}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFetchSeqUnit_a339073618ad3c21c492d64a55ce2e216}
Will be called the cycle before a context switch. Any bookkeeping that needs to be kept for that, can be done here 

This function assumes that the instruction causing the context switch was right after the branch. Thus, if it's not, then we are updating incorrectly here

\hyperlink{classResource_a2cf5450ce736e0c76aca0d4ef24b922a}{Resource}を再定義しています。


\begin{DoxyCode}
317 {
318     pcValid[tid] = true;
319 
320     if (cpu->thread[tid]->lastGradIsBranch) {
325         assert(cpu->nextInstAddr(tid) == inst->instAddr());
326         pc[tid] = cpu->thread[tid]->lastBranchPC;
327     } else {
328         pc[tid] = inst->pcState();
329     }
330     assert(inst->staticInst);
331     advancePC(pc[tid], inst->staticInst);
332     
333     DPRINTF(InOrderFetchSeq, "[tid:%i]: Updating PCs due to Context Switch."
334             "Assigning  PC: %s.\n", tid, pc[tid]);
335 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classFetchSeqUnit_ae3208e633eb913a59f8a49ba2c65840c}{
\index{FetchSeqUnit@{FetchSeqUnit}!instSize@{instSize}}
\index{instSize@{instSize}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{instSize}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf instSize}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFetchSeqUnit_ae3208e633eb913a59f8a49ba2c65840c}
\hypertarget{classFetchSeqUnit_a07ac7fa00a59be2904eaa76d4735681e}{
\index{FetchSeqUnit@{FetchSeqUnit}!lastSquashCycle@{lastSquashCycle}}
\index{lastSquashCycle@{lastSquashCycle}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{lastSquashCycle}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf lastSquashCycle}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFetchSeqUnit_a07ac7fa00a59be2904eaa76d4735681e}
Squash Seq. Nums \hypertarget{classFetchSeqUnit_a61bb24b7355c86288cba2cd9d51ad1ed}{
\index{FetchSeqUnit@{FetchSeqUnit}!pc@{pc}}
\index{pc@{pc}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{pc}]{\setlength{\rightskip}{0pt plus 5cm}TheISA::PCState {\bf pc}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFetchSeqUnit_a61bb24b7355c86288cba2cd9d51ad1ed}
\hypertarget{classFetchSeqUnit_acd6cfe08097e99df8b2ef586c47d87fa}{
\index{FetchSeqUnit@{FetchSeqUnit}!pcBlockStage@{pcBlockStage}}
\index{pcBlockStage@{pcBlockStage}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{pcBlockStage}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf pcBlockStage}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFetchSeqUnit_acd6cfe08097e99df8b2ef586c47d87fa}
\hypertarget{classFetchSeqUnit_ae0f86f031bb34b0540e5ebcfaa2de630}{
\index{FetchSeqUnit@{FetchSeqUnit}!pcValid@{pcValid}}
\index{pcValid@{pcValid}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{pcValid}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf pcValid}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFetchSeqUnit_ae0f86f031bb34b0540e5ebcfaa2de630}
\hypertarget{classFetchSeqUnit_a8c48389ee147811c1be413cdd4be4b68}{
\index{FetchSeqUnit@{FetchSeqUnit}!squashSeqNum@{squashSeqNum}}
\index{squashSeqNum@{squashSeqNum}!FetchSeqUnit@{FetchSeqUnit}}
\subsubsection[{squashSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf squashSeqNum}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFetchSeqUnit_a8c48389ee147811c1be413cdd4be4b68}
Squash Seq. Nums 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/inorder/resources/\hyperlink{fetch__seq__unit_8hh}{fetch\_\-seq\_\-unit.hh}\item 
cpu/inorder/resources/\hyperlink{fetch__seq__unit_8cc}{fetch\_\-seq\_\-unit.cc}\end{DoxyCompactItemize}
