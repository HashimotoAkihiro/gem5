\hypertarget{classAlphaISA_1_1ISA}{
\section{クラス ISA}
\label{classAlphaISA_1_1ISA}\index{AlphaISA::ISA@{AlphaISA::ISA}}
}


{\ttfamily \#include $<$isa.hh$>$}ISAに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classAlphaISA_1_1ISA}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef uint64\_\-t \hyperlink{classAlphaISA_1_1ISA_a3be59bc6c39d87f5d4bd0e05abe0b416}{InternalProcReg}
\item 
typedef AlphaISAParams \hyperlink{classAlphaISA_1_1ISA_a492961bc1e489616b642e85a4e2ddf03}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{namespaceAlphaISA_aa16539aa6584fd12f7d6fa868f75b4de}{MiscReg} \hyperlink{classAlphaISA_1_1ISA_af2ec8925148a53b9bddefb7fb65a7223}{readMiscRegNoEffect} (int misc\_\-reg, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid=0)
\item 
\hyperlink{namespaceAlphaISA_aa16539aa6584fd12f7d6fa868f75b4de}{MiscReg} \hyperlink{classAlphaISA_1_1ISA_a81ac5a0c0d9b625997d7737f911743b1}{readMiscReg} (int misc\_\-reg, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid=0)
\item 
void \hyperlink{classAlphaISA_1_1ISA_ab8dd4afdd4e652ca191b235505691f68}{setMiscRegNoEffect} (int misc\_\-reg, const \hyperlink{namespaceAlphaISA_aa16539aa6584fd12f7d6fa868f75b4de}{MiscReg} \&val, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid=0)
\item 
void \hyperlink{classAlphaISA_1_1ISA_ab85b054f14d72781b7f540270867e2df}{setMiscReg} (int misc\_\-reg, const \hyperlink{namespaceAlphaISA_aa16539aa6584fd12f7d6fa868f75b4de}{MiscReg} \&val, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid=0)
\item 
void \hyperlink{classAlphaISA_1_1ISA_ac8bb3912a3ce86b15842e79d0b421204}{clear} ()
\item 
void \hyperlink{classAlphaISA_1_1ISA_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
void \hyperlink{classAlphaISA_1_1ISA_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\item 
int \hyperlink{classAlphaISA_1_1ISA_aece4b88ffcab608652e8e9f0fbe643d4}{flattenIntIndex} (int reg) const 
\item 
int \hyperlink{classAlphaISA_1_1ISA_a85addcd4f57c5a0ffa81805dcad1eeb7}{flattenFloatIndex} (int reg) const 
\item 
int \hyperlink{classAlphaISA_1_1ISA_a7a5d7476bd10e5af09e6e753d1fca087}{flattenCCIndex} (int reg) const 
\item 
int \hyperlink{classAlphaISA_1_1ISA_a8997760aa4425793911f57440a4dd8ae}{flattenMiscIndex} (int reg) const 
\item 
const \hyperlink{classAlphaISA_1_1ISA_a492961bc1e489616b642e85a4e2ddf03}{Params} $\ast$ \hyperlink{classAlphaISA_1_1ISA_a0968f22111d8484ab76cc2d65d1ad57d}{params} () const 
\item 
\hyperlink{classAlphaISA_1_1ISA_ae9132e021b3f3b20c917fc328a056bbd}{ISA} (\hyperlink{classAlphaISA_1_1ISA_a492961bc1e489616b642e85a4e2ddf03}{Params} $\ast$p)
\item 
void \hyperlink{classAlphaISA_1_1ISA_a769e733729615c529fdb54f538f11dba}{startup} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classAlphaISA_1_1ISA_a3be59bc6c39d87f5d4bd0e05abe0b416}{InternalProcReg} \hyperlink{classAlphaISA_1_1ISA_adc7402a9cc2aaeb6bbb7bf5c3f7c4d18}{readIpr} (int idx, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\item 
void \hyperlink{classAlphaISA_1_1ISA_a5ad670d8483b30ac29ecc133e3e501d5}{setIpr} (int idx, \hyperlink{classAlphaISA_1_1ISA_a3be59bc6c39d87f5d4bd0e05abe0b416}{InternalProcReg} val, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSystem}{System} $\ast$ \hyperlink{classAlphaISA_1_1ISA_af27ccd765f13a4b7bd119dc7579e2746}{system}
\item 
uint64\_\-t \hyperlink{classAlphaISA_1_1ISA_afe6e18a3c766bdbd3a13c449eff10c85}{fpcr}
\item 
uint64\_\-t \hyperlink{classAlphaISA_1_1ISA_a4bf79f35bed3cb9ecd35cc65ec6400c7}{uniq}
\item 
bool \hyperlink{classAlphaISA_1_1ISA_a5379df879a195cd227c4b3e04fc324d4}{lock\_\-flag}
\item 
\hyperlink{classm5_1_1params_1_1Addr}{Addr} \hyperlink{classAlphaISA_1_1ISA_a06174a765f779599487143e17e764d72}{lock\_\-addr}
\item 
int \hyperlink{classAlphaISA_1_1ISA_a132031b6f829162c4bd2effdb8105dcb}{intr\_\-flag}
\item 
\hyperlink{classAlphaISA_1_1ISA_a3be59bc6c39d87f5d4bd0e05abe0b416}{InternalProcReg} \hyperlink{classAlphaISA_1_1ISA_a73c7625b3b5159b8981319eeb1337c75}{ipr} \mbox{[}NumInternalProcRegs\mbox{]}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classAlphaISA_1_1ISA_a3be59bc6c39d87f5d4bd0e05abe0b416}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!InternalProcReg@{InternalProcReg}}
\index{InternalProcReg@{InternalProcReg}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{InternalProcReg}]{\setlength{\rightskip}{0pt plus 5cm}typedef uint64\_\-t {\bf InternalProcReg}}}
\label{classAlphaISA_1_1ISA_a3be59bc6c39d87f5d4bd0e05abe0b416}
\hypertarget{classAlphaISA_1_1ISA_a492961bc1e489616b642e85a4e2ddf03}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!Params@{Params}}
\index{Params@{Params}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef AlphaISAParams {\bf Params}}}
\label{classAlphaISA_1_1ISA_a492961bc1e489616b642e85a4e2ddf03}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classAlphaISA_1_1ISA_ae9132e021b3f3b20c917fc328a056bbd}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!ISA@{ISA}}
\index{ISA@{ISA}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{ISA}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ISA} ({\bf Params} $\ast$ {\em p})}}
\label{classAlphaISA_1_1ISA_ae9132e021b3f3b20c917fc328a056bbd}



\begin{DoxyCode}
43     : SimObject(p), system(p->system)
44 {
45     clear();
46     initializeIprTable();
47 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classAlphaISA_1_1ISA_ac8bb3912a3ce86b15842e79d0b421204}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!clear@{clear}}
\index{clear@{clear}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{clear}]{\setlength{\rightskip}{0pt plus 5cm}void clear ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAlphaISA_1_1ISA_ac8bb3912a3ce86b15842e79d0b421204}



\begin{DoxyCode}
86         {
87             fpcr = 0;
88             uniq = 0;
89             lock_flag = 0;
90             lock_addr = 0;
91             intr_flag = 0;
92             memset(ipr, 0, sizeof(ipr));
93         }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1ISA_a7a5d7476bd10e5af09e6e753d1fca087}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!flattenCCIndex@{flattenCCIndex}}
\index{flattenCCIndex@{flattenCCIndex}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{flattenCCIndex}]{\setlength{\rightskip}{0pt plus 5cm}int flattenCCIndex (int {\em reg}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAlphaISA_1_1ISA_a7a5d7476bd10e5af09e6e753d1fca087}



\begin{DoxyCode}
113         {
114             return reg;
115         }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1ISA_a85addcd4f57c5a0ffa81805dcad1eeb7}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!flattenFloatIndex@{flattenFloatIndex}}
\index{flattenFloatIndex@{flattenFloatIndex}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{flattenFloatIndex}]{\setlength{\rightskip}{0pt plus 5cm}int flattenFloatIndex (int {\em reg}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAlphaISA_1_1ISA_a85addcd4f57c5a0ffa81805dcad1eeb7}



\begin{DoxyCode}
106         {
107             return reg;
108         }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1ISA_aece4b88ffcab608652e8e9f0fbe643d4}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!flattenIntIndex@{flattenIntIndex}}
\index{flattenIntIndex@{flattenIntIndex}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{flattenIntIndex}]{\setlength{\rightskip}{0pt plus 5cm}int flattenIntIndex (int {\em reg}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAlphaISA_1_1ISA_aece4b88ffcab608652e8e9f0fbe643d4}



\begin{DoxyCode}
100         {
101             return reg;
102         }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1ISA_a8997760aa4425793911f57440a4dd8ae}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!flattenMiscIndex@{flattenMiscIndex}}
\index{flattenMiscIndex@{flattenMiscIndex}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{flattenMiscIndex}]{\setlength{\rightskip}{0pt plus 5cm}int flattenMiscIndex (int {\em reg}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAlphaISA_1_1ISA_a8997760aa4425793911f57440a4dd8ae}



\begin{DoxyCode}
119         {
120             return reg;
121         }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1ISA_a0968f22111d8484ab76cc2d65d1ad57d}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!params@{params}}
\index{params@{params}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const AlphaISAParams $\ast$ params () const}}
\label{classAlphaISA_1_1ISA_a0968f22111d8484ab76cc2d65d1ad57d}



\begin{DoxyCode}
51 {
52     return dynamic_cast<const Params *>(_params);
53 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1ISA_adc7402a9cc2aaeb6bbb7bf5c3f7c4d18}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!readIpr@{readIpr}}
\index{readIpr@{readIpr}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{readIpr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MiscReg} readIpr (int {\em idx}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1ISA_adc7402a9cc2aaeb6bbb7bf5c3f7c4d18}



\begin{DoxyCode}
94 {
95     uint64_t retval = 0;        // return value, default 0
96 
97     switch (idx) {
98       case IPR_PALtemp0:
99       case IPR_PALtemp1:
100       case IPR_PALtemp2:
101       case IPR_PALtemp3:
102       case IPR_PALtemp4:
103       case IPR_PALtemp5:
104       case IPR_PALtemp6:
105       case IPR_PALtemp7:
106       case IPR_PALtemp8:
107       case IPR_PALtemp9:
108       case IPR_PALtemp10:
109       case IPR_PALtemp11:
110       case IPR_PALtemp12:
111       case IPR_PALtemp13:
112       case IPR_PALtemp14:
113       case IPR_PALtemp15:
114       case IPR_PALtemp16:
115       case IPR_PALtemp17:
116       case IPR_PALtemp18:
117       case IPR_PALtemp19:
118       case IPR_PALtemp20:
119       case IPR_PALtemp21:
120       case IPR_PALtemp22:
121       case IPR_PALtemp23:
122       case IPR_PAL_BASE:
123 
124       case IPR_IVPTBR:
125       case IPR_DC_MODE:
126       case IPR_MAF_MODE:
127       case IPR_ISR:
128       case IPR_EXC_ADDR:
129       case IPR_IC_PERR_STAT:
130       case IPR_DC_PERR_STAT:
131       case IPR_MCSR:
132       case IPR_ASTRR:
133       case IPR_ASTER:
134       case IPR_SIRR:
135       case IPR_ICSR:
136       case IPR_ICM:
137       case IPR_DTB_CM:
138       case IPR_IPLR:
139       case IPR_INTID:
140       case IPR_PMCTR:
141         // no side-effect
142         retval = ipr[idx];
143         break;
144 
145       case IPR_CC:
146         retval |= ipr[idx] & ULL(0xffffffff00000000);
147         retval |= tc->getCpuPtr()->curCycle()  & ULL(0x00000000ffffffff);
148         break;
149 
150       case IPR_VA:
151         retval = ipr[idx];
152         break;
153 
154       case IPR_VA_FORM:
155       case IPR_MM_STAT:
156       case IPR_IFAULT_VA_FORM:
157       case IPR_EXC_MASK:
158       case IPR_EXC_SUM:
159         retval = ipr[idx];
160         break;
161 
162       case IPR_DTB_PTE:
163         {
164             TlbEntry &entry
165                 = tc->getDTBPtr()->index(!tc->misspeculating());
166 
167             retval |= ((uint64_t)entry.ppn & ULL(0x7ffffff)) << 32;
168             retval |= ((uint64_t)entry.xre & ULL(0xf)) << 8;
169             retval |= ((uint64_t)entry.xwe & ULL(0xf)) << 12;
170             retval |= ((uint64_t)entry.fonr & ULL(0x1)) << 1;
171             retval |= ((uint64_t)entry.fonw & ULL(0x1))<< 2;
172             retval |= ((uint64_t)entry.asma & ULL(0x1)) << 4;
173             retval |= ((uint64_t)entry.asn & ULL(0x7f)) << 57;
174         }
175         break;
176 
177         // write only registers
178       case IPR_HWINT_CLR:
179       case IPR_SL_XMIT:
180       case IPR_DC_FLUSH:
181       case IPR_IC_FLUSH:
182       case IPR_ALT_MODE:
183       case IPR_DTB_IA:
184       case IPR_DTB_IAP:
185       case IPR_ITB_IA:
186       case IPR_ITB_IAP:
187         panic("Tried to read write only register %d\n", idx);
188         break;
189 
190       default:
191         // invalid IPR
192         panic("Tried to read from invalid ipr %d\n", idx);
193         break;
194     }
195 
196     return retval;
197 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1ISA_a81ac5a0c0d9b625997d7737f911743b1}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!readMiscReg@{readMiscReg}}
\index{readMiscReg@{readMiscReg}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{readMiscReg}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MiscReg} readMiscReg (int {\em misc\_\-reg}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf ThreadID} {\em tid} = {\ttfamily 0})}}
\label{classAlphaISA_1_1ISA_a81ac5a0c0d9b625997d7737f911743b1}



\begin{DoxyCode}
98 {
99     switch (misc_reg) {
100       case MISCREG_FPCR:
101         return fpcr;
102       case MISCREG_UNIQ:
103         return uniq;
104       case MISCREG_LOCKFLAG:
105         return lock_flag;
106       case MISCREG_LOCKADDR:
107         return lock_addr;
108       case MISCREG_INTR:
109         return intr_flag;
110       default:
111         return readIpr(misc_reg, tc);
112     }
113 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1ISA_af2ec8925148a53b9bddefb7fb65a7223}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!readMiscRegNoEffect@{readMiscRegNoEffect}}
\index{readMiscRegNoEffect@{readMiscRegNoEffect}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{readMiscRegNoEffect}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MiscReg} readMiscRegNoEffect (int {\em misc\_\-reg}, \/  {\bf ThreadID} {\em tid} = {\ttfamily 0})}}
\label{classAlphaISA_1_1ISA_af2ec8925148a53b9bddefb7fb65a7223}



\begin{DoxyCode}
78 {
79     switch (misc_reg) {
80       case MISCREG_FPCR:
81         return fpcr;
82       case MISCREG_UNIQ:
83         return uniq;
84       case MISCREG_LOCKFLAG:
85         return lock_flag;
86       case MISCREG_LOCKADDR:
87         return lock_addr;
88       case MISCREG_INTR:
89         return intr_flag;
90       default:
91         assert(misc_reg < NumInternalProcRegs);
92         return ipr[misc_reg];
93     }
94 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1ISA_a53e036786d17361be4c7320d39c99b84}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!serialize@{serialize}}
\index{serialize@{serialize}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})}}
\label{classAlphaISA_1_1ISA_a53e036786d17361be4c7320d39c99b84}



\begin{DoxyCode}
57 {
58     SERIALIZE_SCALAR(fpcr);
59     SERIALIZE_SCALAR(uniq);
60     SERIALIZE_SCALAR(lock_flag);
61     SERIALIZE_SCALAR(lock_addr);
62     SERIALIZE_ARRAY(ipr, NumInternalProcRegs);
63 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1ISA_a5ad670d8483b30ac29ecc133e3e501d5}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!setIpr@{setIpr}}
\index{setIpr@{setIpr}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{setIpr}]{\setlength{\rightskip}{0pt plus 5cm}void setIpr (int {\em idx}, \/  {\bf InternalProcReg} {\em val}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1ISA_a5ad670d8483b30ac29ecc133e3e501d5}



\begin{DoxyCode}
204 {
205     if (tc->misspeculating())
206         return;
207 
208     switch (idx) {
209       case IPR_PALtemp0:
210       case IPR_PALtemp1:
211       case IPR_PALtemp2:
212       case IPR_PALtemp3:
213       case IPR_PALtemp4:
214       case IPR_PALtemp5:
215       case IPR_PALtemp6:
216       case IPR_PALtemp7:
217       case IPR_PALtemp8:
218       case IPR_PALtemp9:
219       case IPR_PALtemp10:
220       case IPR_PALtemp11:
221       case IPR_PALtemp12:
222       case IPR_PALtemp13:
223       case IPR_PALtemp14:
224       case IPR_PALtemp15:
225       case IPR_PALtemp16:
226       case IPR_PALtemp17:
227       case IPR_PALtemp18:
228       case IPR_PALtemp19:
229       case IPR_PALtemp20:
230       case IPR_PALtemp21:
231       case IPR_PALtemp22:
232       case IPR_PAL_BASE:
233       case IPR_IC_PERR_STAT:
234       case IPR_DC_PERR_STAT:
235       case IPR_PMCTR:
236         // write entire quad w/ no side-effect
237         ipr[idx] = val;
238         break;
239 
240       case IPR_CC_CTL:
241         // This IPR resets the cycle counter.  We assume this only
242         // happens once... let's verify that.
243         assert(ipr[idx] == 0);
244         ipr[idx] = 1;
245         break;
246 
247       case IPR_CC:
248         // This IPR only writes the upper 64 bits.  It's ok to write
249         // all 64 here since we mask out the lower 32 in rpcc (see
250         // isa_desc).
251         ipr[idx] = val;
252         break;
253 
254       case IPR_PALtemp23:
255         // write entire quad w/ no side-effect
256         if (tc->getKernelStats())
257             tc->getKernelStats()->context(ipr[idx], val, tc);
258         ipr[idx] = val;
259         break;
260 
261       case IPR_DTB_PTE:
262         // write entire quad w/ no side-effect, tag is forthcoming
263         ipr[idx] = val;
264         break;
265 
266       case IPR_EXC_ADDR:
267         // second least significant bit in PC is always zero
268         ipr[idx] = val & ~2;
269         break;
270 
271       case IPR_ASTRR:
272       case IPR_ASTER:
273         // only write least significant four bits - privilege mask
274         ipr[idx] = val & 0xf;
275         break;
276 
277       case IPR_IPLR:
278 #ifdef DEBUG
279         if (break_ipl != -1 && break_ipl == (int)(val & 0x1f))
280             Debug::breakpoint();
281 #endif
282 
283         // only write least significant five bits - interrupt level
284         ipr[idx] = val & 0x1f;
285         if (tc->getKernelStats())
286             tc->getKernelStats()->swpipl(ipr[idx]);
287         break;
288 
289       case IPR_DTB_CM:
290         if (val & 0x18) {
291             if (tc->getKernelStats())
292                 tc->getKernelStats()->mode(Kernel::user, tc);
293         } else {
294             if (tc->getKernelStats())
295                 tc->getKernelStats()->mode(Kernel::kernel, tc);
296         }
297 
298       case IPR_ICM:
299         // only write two mode bits - processor mode
300         ipr[idx] = val & 0x18;
301         break;
302 
303       case IPR_ALT_MODE:
304         // only write two mode bits - processor mode
305         ipr[idx] = val & 0x18;
306         break;
307 
308       case IPR_MCSR:
309         // more here after optimization...
310         ipr[idx] = val;
311         break;
312 
313       case IPR_SIRR:
314         // only write software interrupt mask
315         ipr[idx] = val & 0x7fff0;
316         break;
317 
318       case IPR_ICSR:
319         ipr[idx] = val & ULL(0xffffff0300);
320         break;
321 
322       case IPR_IVPTBR:
323       case IPR_MVPTBR:
324         ipr[idx] = val & ULL(0xffffffffc0000000);
325         break;
326 
327       case IPR_DC_TEST_CTL:
328         ipr[idx] = val & 0x1ffb;
329         break;
330 
331       case IPR_DC_MODE:
332       case IPR_MAF_MODE:
333         ipr[idx] = val & 0x3f;
334         break;
335 
336       case IPR_ITB_ASN:
337         ipr[idx] = val & 0x7f0;
338         break;
339 
340       case IPR_DTB_ASN:
341         ipr[idx] = val & ULL(0xfe00000000000000);
342         break;
343 
344       case IPR_EXC_SUM:
345       case IPR_EXC_MASK:
346         // any write to this register clears it
347         ipr[idx] = 0;
348         break;
349 
350       case IPR_INTID:
351       case IPR_SL_RCV:
352       case IPR_MM_STAT:
353       case IPR_ITB_PTE_TEMP:
354       case IPR_DTB_PTE_TEMP:
355         // read-only registers
356         panic("Tried to write read only ipr %d\n", idx);
357 
358       case IPR_HWINT_CLR:
359       case IPR_SL_XMIT:
360       case IPR_DC_FLUSH:
361       case IPR_IC_FLUSH:
362         // the following are write only
363         ipr[idx] = val;
364         break;
365 
366       case IPR_DTB_IA:
367         // really a control write
368         ipr[idx] = 0;
369 
370         tc->getDTBPtr()->flushAll();
371         break;
372 
373       case IPR_DTB_IAP:
374         // really a control write
375         ipr[idx] = 0;
376 
377         tc->getDTBPtr()->flushProcesses();
378         break;
379 
380       case IPR_DTB_IS:
381         // really a control write
382         ipr[idx] = val;
383 
384         tc->getDTBPtr()->flushAddr(val, DTB_ASN_ASN(ipr[IPR_DTB_ASN]));
385         break;
386 
387       case IPR_DTB_TAG: {
388           struct TlbEntry entry;
389 
390           // FIXME: granularity hints NYI...
391           if (DTB_PTE_GH(ipr[IPR_DTB_PTE]) != 0)
392               panic("PTE GH field != 0");
393 
394           // write entire quad
395           ipr[idx] = val;
396 
397           // construct PTE for new entry
398           entry.ppn = DTB_PTE_PPN(ipr[IPR_DTB_PTE]);
399           entry.xre = DTB_PTE_XRE(ipr[IPR_DTB_PTE]);
400           entry.xwe = DTB_PTE_XWE(ipr[IPR_DTB_PTE]);
401           entry.fonr = DTB_PTE_FONR(ipr[IPR_DTB_PTE]);
402           entry.fonw = DTB_PTE_FONW(ipr[IPR_DTB_PTE]);
403           entry.asma = DTB_PTE_ASMA(ipr[IPR_DTB_PTE]);
404           entry.asn = DTB_ASN_ASN(ipr[IPR_DTB_ASN]);
405 
406           // insert new TAG/PTE value into data TLB
407           tc->getDTBPtr()->insert(val, entry);
408       }
409         break;
410 
411       case IPR_ITB_PTE: {
412           struct TlbEntry entry;
413 
414           // FIXME: granularity hints NYI...
415           if (ITB_PTE_GH(val) != 0)
416               panic("PTE GH field != 0");
417 
418           // write entire quad
419           ipr[idx] = val;
420 
421           // construct PTE for new entry
422           entry.ppn = ITB_PTE_PPN(val);
423           entry.xre = ITB_PTE_XRE(val);
424           entry.xwe = 0;
425           entry.fonr = ITB_PTE_FONR(val);
426           entry.fonw = ITB_PTE_FONW(val);
427           entry.asma = ITB_PTE_ASMA(val);
428           entry.asn = ITB_ASN_ASN(ipr[IPR_ITB_ASN]);
429 
430           // insert new TAG/PTE value into data TLB
431           tc->getITBPtr()->insert(ipr[IPR_ITB_TAG], entry);
432       }
433         break;
434 
435       case IPR_ITB_IA:
436         // really a control write
437         ipr[idx] = 0;
438 
439         tc->getITBPtr()->flushAll();
440         break;
441 
442       case IPR_ITB_IAP:
443         // really a control write
444         ipr[idx] = 0;
445 
446         tc->getITBPtr()->flushProcesses();
447         break;
448 
449       case IPR_ITB_IS:
450         // really a control write
451         ipr[idx] = val;
452 
453         tc->getITBPtr()->flushAddr(val, ITB_ASN_ASN(ipr[IPR_ITB_ASN]));
454         break;
455 
456       default:
457         // invalid IPR
458         panic("Tried to write to invalid ipr %d\n", idx);
459     }
460 
461     // no error...
462 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1ISA_ab85b054f14d72781b7f540270867e2df}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!setMiscReg@{setMiscReg}}
\index{setMiscReg@{setMiscReg}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{setMiscReg}]{\setlength{\rightskip}{0pt plus 5cm}void setMiscReg (int {\em misc\_\-reg}, \/  const {\bf MiscReg} \& {\em val}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf ThreadID} {\em tid} = {\ttfamily 0})}}
\label{classAlphaISA_1_1ISA_ab85b054f14d72781b7f540270867e2df}



\begin{DoxyCode}
144 {
145     switch (misc_reg) {
146       case MISCREG_FPCR:
147         fpcr = val;
148         return;
149       case MISCREG_UNIQ:
150         uniq = val;
151         return;
152       case MISCREG_LOCKFLAG:
153         lock_flag = val;
154         return;
155       case MISCREG_LOCKADDR:
156         lock_addr = val;
157         return;
158       case MISCREG_INTR:
159         intr_flag = val;
160         return;
161       default:
162         setIpr(misc_reg, val, tc);
163         return;
164     }
165 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1ISA_ab8dd4afdd4e652ca191b235505691f68}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!setMiscRegNoEffect@{setMiscRegNoEffect}}
\index{setMiscRegNoEffect@{setMiscRegNoEffect}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{setMiscRegNoEffect}]{\setlength{\rightskip}{0pt plus 5cm}void setMiscRegNoEffect (int {\em misc\_\-reg}, \/  const {\bf MiscReg} \& {\em val}, \/  {\bf ThreadID} {\em tid} = {\ttfamily 0})}}
\label{classAlphaISA_1_1ISA_ab8dd4afdd4e652ca191b235505691f68}



\begin{DoxyCode}
117 {
118     switch (misc_reg) {
119       case MISCREG_FPCR:
120         fpcr = val;
121         return;
122       case MISCREG_UNIQ:
123         uniq = val;
124         return;
125       case MISCREG_LOCKFLAG:
126         lock_flag = val;
127         return;
128       case MISCREG_LOCKADDR:
129         lock_addr = val;
130         return;
131       case MISCREG_INTR:
132         intr_flag = val;
133         return;
134       default:
135         assert(misc_reg < NumInternalProcRegs);
136         ipr[misc_reg] = val;
137         return;
138     }
139 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1ISA_a769e733729615c529fdb54f538f11dba}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!startup@{startup}}
\index{startup@{startup}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{startup}]{\setlength{\rightskip}{0pt plus 5cm}void startup ({\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAlphaISA_1_1ISA_a769e733729615c529fdb54f538f11dba}



\begin{DoxyCode}
127 {}
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1ISA_af22e5d6d660b97db37003ac61ac4ee49}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})}}
\label{classAlphaISA_1_1ISA_af22e5d6d660b97db37003ac61ac4ee49}



\begin{DoxyCode}
67 {
68     UNSERIALIZE_SCALAR(fpcr);
69     UNSERIALIZE_SCALAR(uniq);
70     UNSERIALIZE_SCALAR(lock_flag);
71     UNSERIALIZE_SCALAR(lock_addr);
72     UNSERIALIZE_ARRAY(ipr, NumInternalProcRegs);
73 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classAlphaISA_1_1ISA_afe6e18a3c766bdbd3a13c449eff10c85}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!fpcr@{fpcr}}
\index{fpcr@{fpcr}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{fpcr}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf fpcr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1ISA_afe6e18a3c766bdbd3a13c449eff10c85}
\hypertarget{classAlphaISA_1_1ISA_a132031b6f829162c4bd2effdb8105dcb}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!intr\_\-flag@{intr\_\-flag}}
\index{intr\_\-flag@{intr\_\-flag}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{intr\_\-flag}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf intr\_\-flag}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1ISA_a132031b6f829162c4bd2effdb8105dcb}
\hypertarget{classAlphaISA_1_1ISA_a73c7625b3b5159b8981319eeb1337c75}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!ipr@{ipr}}
\index{ipr@{ipr}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{ipr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InternalProcReg} {\bf ipr}\mbox{[}NumInternalProcRegs\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1ISA_a73c7625b3b5159b8981319eeb1337c75}
\hypertarget{classAlphaISA_1_1ISA_a06174a765f779599487143e17e764d72}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!lock\_\-addr@{lock\_\-addr}}
\index{lock\_\-addr@{lock\_\-addr}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{lock\_\-addr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf lock\_\-addr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1ISA_a06174a765f779599487143e17e764d72}
\hypertarget{classAlphaISA_1_1ISA_a5379df879a195cd227c4b3e04fc324d4}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!lock\_\-flag@{lock\_\-flag}}
\index{lock\_\-flag@{lock\_\-flag}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{lock\_\-flag}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf lock\_\-flag}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1ISA_a5379df879a195cd227c4b3e04fc324d4}
\hypertarget{classAlphaISA_1_1ISA_af27ccd765f13a4b7bd119dc7579e2746}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!system@{system}}
\index{system@{system}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{system}]{\setlength{\rightskip}{0pt plus 5cm}{\bf System}$\ast$ {\bf system}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1ISA_af27ccd765f13a4b7bd119dc7579e2746}
\hypertarget{classAlphaISA_1_1ISA_a4bf79f35bed3cb9ecd35cc65ec6400c7}{
\index{AlphaISA::ISA@{AlphaISA::ISA}!uniq@{uniq}}
\index{uniq@{uniq}!AlphaISA::ISA@{AlphaISA::ISA}}
\subsubsection[{uniq}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf uniq}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1ISA_a4bf79f35bed3cb9ecd35cc65ec6400c7}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/alpha/\hyperlink{alpha_2isa_8hh}{isa.hh}\item 
arch/alpha/\hyperlink{ev5_8cc}{ev5.cc}\item 
arch/alpha/\hyperlink{alpha_2isa_8cc}{isa.cc}\end{DoxyCompactItemize}
