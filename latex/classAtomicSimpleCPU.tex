\hypertarget{classAtomicSimpleCPU}{
\section{クラス AtomicSimpleCPU}
\label{classAtomicSimpleCPU}\index{AtomicSimpleCPU@{AtomicSimpleCPU}}
}


{\ttfamily \#include $<$atomic.hh$>$}AtomicSimpleCPUに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classAtomicSimpleCPU}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classAtomicSimpleCPU_1_1AtomicCPUDPort}{AtomicCPUDPort}
\item 
class \hyperlink{classAtomicSimpleCPU_1_1AtomicCPUPort}{AtomicCPUPort}
\item 
class \hyperlink{classAtomicSimpleCPU_1_1AtomicSimpleCPU}{AtomicSimpleCPU}
\item 
struct \hyperlink{structAtomicSimpleCPU_1_1BBInfo}{BBInfo}
\item 
struct \hyperlink{structAtomicSimpleCPU_1_1TickEvent}{TickEvent}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classAtomicSimpleCPU_ad25e81d46bd9fe8b4f176b129a012bc6}{AtomicSimpleCPU} (AtomicSimpleCPUParams $\ast$params)
\item 
virtual \hyperlink{classAtomicSimpleCPU_a0c1821e85cf304f5a090c51f3460d577}{$\sim$AtomicSimpleCPU} ()
\item 
virtual void \hyperlink{classAtomicSimpleCPU_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
unsigned int \hyperlink{classAtomicSimpleCPU_a4e932bfc8aa6dfb998b8496a0f04ace3}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$\hyperlink{classAtomicSimpleCPU_af9ba920f669cbe0f18c71846715d690a}{drain\_\-manager})
\item 
void \hyperlink{classAtomicSimpleCPU_a8f020d3237536fe007fc488c4125c5d8}{drainResume} ()
\item 
void \hyperlink{classAtomicSimpleCPU_a05f299b443f8cc73a93d61572edc0218}{switchOut} ()
\item 
void \hyperlink{classAtomicSimpleCPU_ac82d2b8d331b2e8e6854a95d2917dfa2}{takeOverFrom} (\hyperlink{classBaseCPU_1_1BaseCPU}{BaseCPU} $\ast$oldCPU)
\item 
void \hyperlink{classAtomicSimpleCPU_ae2e1ccebe596a180f8105d57f9a93645}{verifyMemoryMode} () const 
\item 
virtual void \hyperlink{classAtomicSimpleCPU_ad7a501b28bdbe8b3e708cd1ef69ac191}{activateContext} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} thread\_\-num, \hyperlink{classCycles}{Cycles} delay)
\item 
virtual void \hyperlink{classAtomicSimpleCPU_a1dad4c4d2c3df4ef367e14fcc973ce74}{suspendContext} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} thread\_\-num)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classAtomicSimpleCPU_a66191b2d8a45050b7df3c3efa7bb07c6}{readMem} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, uint8\_\-t $\ast$data, unsigned size, unsigned flags)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classAtomicSimpleCPU_ad46c5edeb1ee9b60445f3e26364e2c5e}{writeMem} (uint8\_\-t $\ast$data, unsigned size, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, unsigned flags, uint64\_\-t $\ast$res)
\item 
void \hyperlink{classAtomicSimpleCPU_a88aa41e2693dd0091afae2604eba9bed}{printAddr} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} a)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{classMasterPort}{MasterPort} \& \hyperlink{classAtomicSimpleCPU_aeea6b55ae1c4be53c21dbee434b221d4}{getDataPort} ()
\item 
virtual \hyperlink{classMasterPort}{MasterPort} \& \hyperlink{classAtomicSimpleCPU_a40da530cb5dd380fd7fc0d786e94d5eb}{getInstPort} ()
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classAtomicSimpleCPU_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\item 
bool \hyperlink{classAtomicSimpleCPU_ac166e5bc3ddf730beb1282cf821096ae}{isDrained} ()
\item 
bool \hyperlink{classAtomicSimpleCPU_abfea8f75a7a7480716801affeebbe87b}{tryCompleteDrain} ()
\item 
void \hyperlink{classAtomicSimpleCPU_aa51e4d7f169cd8e8b2e144fdcfd36f33}{profileSimPoint} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structAtomicSimpleCPU_1_1TickEvent}{TickEvent} \hyperlink{classAtomicSimpleCPU_aa36b8e894416f0ec98f701ab08f2ac22}{tickEvent}
\item 
const int \hyperlink{classAtomicSimpleCPU_a837aabdd54757cb86d0f66387511753f}{width}
\item 
bool \hyperlink{classAtomicSimpleCPU_a18a0f1e6c3d21c252b14ea6ae162e2ff}{locked}
\item 
const bool \hyperlink{classAtomicSimpleCPU_aab46afe7eb154b233d2ba1886a4b399f}{simulate\_\-data\_\-stalls}
\item 
const bool \hyperlink{classAtomicSimpleCPU_ac5ff523d495df7133594dec7894aacc7}{simulate\_\-inst\_\-stalls}
\item 
\hyperlink{classDrainManager}{DrainManager} $\ast$ \hyperlink{classAtomicSimpleCPU_af9ba920f669cbe0f18c71846715d690a}{drain\_\-manager}
\item 
\hyperlink{classAtomicSimpleCPU_1_1AtomicCPUPort}{AtomicCPUPort} \hyperlink{classAtomicSimpleCPU_a35e511691227100effd63e8a7fc12989}{icachePort}
\item 
\hyperlink{classAtomicSimpleCPU_1_1AtomicCPUDPort}{AtomicCPUDPort} \hyperlink{classAtomicSimpleCPU_ab6b7665b418b12dc80b485e66d23ed19}{dcachePort}
\item 
bool \hyperlink{classAtomicSimpleCPU_a66f9c88f6fa05c882787a7e98a7101f5}{fastmem}
\item 
\hyperlink{classRequest}{Request} \hyperlink{classAtomicSimpleCPU_a64ba0dde58d6c2c1c5e24a0b3e3b506f}{ifetch\_\-req}
\item 
\hyperlink{classRequest}{Request} \hyperlink{classAtomicSimpleCPU_a836513db061d14f39d79751c40fa9951}{data\_\-read\_\-req}
\item 
\hyperlink{classRequest}{Request} \hyperlink{classAtomicSimpleCPU_af2cc98a9d486d932d85c4513a4670ca8}{data\_\-write\_\-req}
\item 
bool \hyperlink{classAtomicSimpleCPU_a40a30a05f8e2b8b4c62c0ee0a019686a}{dcache\_\-access}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classAtomicSimpleCPU_a08f04a43a6d731e966308aaeece77208}{dcache\_\-latency}
\end{DoxyCompactItemize}
\begin{Indent}{\bf }\par
{\em \label{_amgrpd41d8cd98f00b204e9800998ecf8427e}
 }\begin{DoxyCompactItemize}
\item 
const bool \hyperlink{classAtomicSimpleCPU_a556c6eb1f8f869ee7d0802381701c49f}{simpoint}
\item 
const uint64\_\-t \hyperlink{classAtomicSimpleCPU_afa2df438a2925349299948892f519ea2}{intervalSize}
\item 
uint64\_\-t \hyperlink{classAtomicSimpleCPU_a4ba2ebd08d9a7f8efe072ed006f2ba56}{intervalCount}
\item 
uint64\_\-t \hyperlink{classAtomicSimpleCPU_a0c93f234d5028e73f388f7e730db728f}{intervalDrift}
\item 
std::ostream $\ast$ \hyperlink{classAtomicSimpleCPU_a77497fabc62f774e824e9b57974e0301}{simpointStream}
\item 
m5::hash\_\-map$<$ \hyperlink{classstd_1_1pair}{BasicBlockRange}, \hyperlink{structAtomicSimpleCPU_1_1BBInfo}{BBInfo} $>$ \hyperlink{classAtomicSimpleCPU_a06bfab070d35f298897393f7ee6e066c}{bbMap}
\item 
\hyperlink{classstd_1_1pair}{BasicBlockRange} \hyperlink{classAtomicSimpleCPU_aa13454a445c3711abe528bdd288a953c}{currentBBV}
\item 
uint64\_\-t \hyperlink{classAtomicSimpleCPU_a375bb98c835fcacb306ec154ac3c7f85}{currentBBVInstCount}
\end{DoxyCompactItemize}
\end{Indent}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classAtomicSimpleCPU_ad25e81d46bd9fe8b4f176b129a012bc6}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{AtomicSimpleCPU}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AtomicSimpleCPU} (AtomicSimpleCPUParams $\ast$ {\em params})}}
\label{classAtomicSimpleCPU_ad25e81d46bd9fe8b4f176b129a012bc6}



\begin{DoxyCode}
107     : BaseSimpleCPU(p), tickEvent(this), width(p->width), locked(false),
108       simulate_data_stalls(p->simulate_data_stalls),
109       simulate_inst_stalls(p->simulate_inst_stalls),
110       drain_manager(NULL),
111       icachePort(name() + ".icache_port", this),
112       dcachePort(name() + ".dcache_port", this),
113       fastmem(p->fastmem),
114       simpoint(p->simpoint_profile),
115       intervalSize(p->simpoint_interval),
116       intervalCount(0),
117       intervalDrift(0),
118       simpointStream(NULL),
119       currentBBV(0, 0),
120       currentBBVInstCount(0)
121 {
122     _status = Idle;
123 
124     if (simpoint) {
125         simpointStream = simout.create(p->simpoint_profile_file, false);
126     }
127 }
\end{DoxyCode}
\hypertarget{classAtomicSimpleCPU_a0c1821e85cf304f5a090c51f3460d577}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!$\sim$AtomicSimpleCPU@{$\sim$AtomicSimpleCPU}}
\index{$\sim$AtomicSimpleCPU@{$\sim$AtomicSimpleCPU}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{$\sim$AtomicSimpleCPU}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf AtomicSimpleCPU} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classAtomicSimpleCPU_a0c1821e85cf304f5a090c51f3460d577}



\begin{DoxyCode}
131 {
132     if (tickEvent.scheduled()) {
133         deschedule(tickEvent);
134     }
135     if (simpointStream) {
136         simout.close(simpointStream);
137     }
138 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classAtomicSimpleCPU_ad7a501b28bdbe8b3e708cd1ef69ac191}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!activateContext@{activateContext}}
\index{activateContext@{activateContext}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{activateContext}]{\setlength{\rightskip}{0pt plus 5cm}void activateContext ({\bf ThreadID} {\em thread\_\-num}, \/  {\bf Cycles} {\em delay})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classAtomicSimpleCPU_ad7a501b28bdbe8b3e708cd1ef69ac191}



\begin{DoxyCode}
240 {
241     DPRINTF(SimpleCPU, "ActivateContext %d (%d cycles)\n", thread_num, delay);
242 
243     assert(thread_num == 0);
244     assert(thread);
245 
246     assert(_status == Idle);
247     assert(!tickEvent.scheduled());
248 
249     notIdleFraction = 1;
250     numCycles += ticksToCycles(thread->lastActivate - thread->lastSuspend);
251 
252     //Make sure ticks are still on multiples of cycles
253     schedule(tickEvent, clockEdge(delay));
254     _status = BaseSimpleCPU::Running;
255 }
\end{DoxyCode}
\hypertarget{classAtomicSimpleCPU_a4e932bfc8aa6dfb998b8496a0f04ace3}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!drain@{drain}}
\index{drain@{drain}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em drain\_\-manager})}}
\label{classAtomicSimpleCPU_a4e932bfc8aa6dfb998b8496a0f04ace3}



\begin{DoxyCode}
142 {
143     assert(!drain_manager);
144     if (switchedOut())
145         return 0;
146 
147     if (!isDrained()) {
148         DPRINTF(Drain, "Requesting drain: %s\n", pcState());
149         drain_manager = dm;
150         return 1;
151     } else {
152         if (tickEvent.scheduled())
153             deschedule(tickEvent);
154 
155         DPRINTF(Drain, "Not executing microcode, no need to drain.\n");
156         return 0;
157     }
158 }
\end{DoxyCode}
\hypertarget{classAtomicSimpleCPU_a8f020d3237536fe007fc488c4125c5d8}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!drainResume@{drainResume}}
\index{drainResume@{drainResume}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{drainResume}]{\setlength{\rightskip}{0pt plus 5cm}void drainResume ()}}
\label{classAtomicSimpleCPU_a8f020d3237536fe007fc488c4125c5d8}



\begin{DoxyCode}
162 {
163     assert(!tickEvent.scheduled());
164     assert(!drain_manager);
165     if (switchedOut())
166         return;
167 
168     DPRINTF(SimpleCPU, "Resume\n");
169     verifyMemoryMode();
170 
171     assert(!threadContexts.empty());
172     if (threadContexts.size() > 1)
173         fatal("The atomic CPU only supports one thread.\n");
174 
175     if (thread->status() == ThreadContext::Active) {
176         schedule(tickEvent, nextCycle());
177         _status = BaseSimpleCPU::Running;
178         notIdleFraction = 1;
179     } else {
180         _status = BaseSimpleCPU::Idle;
181         notIdleFraction = 0;
182     }
183 
184     system->totalNumInsts = 0;
185 }
\end{DoxyCode}
\hypertarget{classAtomicSimpleCPU_aeea6b55ae1c4be53c21dbee434b221d4}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!getDataPort@{getDataPort}}
\index{getDataPort@{getDataPort}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{getDataPort}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf MasterPort}\& getDataPort ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classAtomicSimpleCPU_aeea6b55ae1c4be53c21dbee434b221d4}
End of data structures for SimPoints BBV generation Return a reference to the data port. 


\begin{DoxyCode}
250 { return dcachePort; }
\end{DoxyCode}
\hypertarget{classAtomicSimpleCPU_a40da530cb5dd380fd7fc0d786e94d5eb}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!getInstPort@{getInstPort}}
\index{getInstPort@{getInstPort}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{getInstPort}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf MasterPort}\& getInstPort ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classAtomicSimpleCPU_a40da530cb5dd380fd7fc0d786e94d5eb}
Return a reference to the instruction port. 


\begin{DoxyCode}
253 { return icachePort; }
\end{DoxyCode}
\hypertarget{classAtomicSimpleCPU_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!init@{init}}
\index{init@{init}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classAtomicSimpleCPU_a02fd73d861ef2e4aabb38c0c9ff82947}



\begin{DoxyCode}
85 {
86     BaseCPU::init();
87 
88     // Initialise the ThreadContext's memory proxies
89     tcBase()->initMemProxies(tcBase());
90 
91     if (FullSystem && !params()->switched_out) {
92         ThreadID size = threadContexts.size();
93         for (ThreadID i = 0; i < size; ++i) {
94             ThreadContext *tc = threadContexts[i];
95             // initialize CPU, including PC
96             TheISA::initCPU(tc, tc->contextId());
97         }
98     }
99 
100     // Atomic doesn't do MT right now, so contextId == threadId
101     ifetch_req.setThreadContext(_cpuId, 0); // Add thread ID if we add MT
102     data_read_req.setThreadContext(_cpuId, 0); // Add thread ID here too
103     data_write_req.setThreadContext(_cpuId, 0); // Add thread ID here too
104 }
\end{DoxyCode}
\hypertarget{classAtomicSimpleCPU_ac166e5bc3ddf730beb1282cf821096ae}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!isDrained@{isDrained}}
\index{isDrained@{isDrained}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{isDrained}]{\setlength{\rightskip}{0pt plus 5cm}bool isDrained ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classAtomicSimpleCPU_ac166e5bc3ddf730beb1282cf821096ae}
\hyperlink{classCheck}{Check} if a system is in a drained state.

We need to drain if: 
\begin{DoxyItemize}
\item We are in the middle of a microcode sequence as some CPUs (e.g., HW accelerated CPUs) can't be started in the middle of a gem5 microcode sequence.


\item The CPU is in a LLSC region. This shouldn't normally happen as these are executed atomically within a single \hyperlink{classAtomicSimpleCPU_a873dd91783f9efb4a590aded1f70d6b0}{tick()} call. The only way this can happen at the moment is if there is an event in the PC event queue that affects the CPU state while it is in an LLSC region.


\item Stay at PC is true. 
\end{DoxyItemize}


\begin{DoxyCode}
126                      {
127         return microPC() == 0 &&
128             !locked &&
129             !stayAtPC;
130     }
\end{DoxyCode}
\hypertarget{classAtomicSimpleCPU_a88aa41e2693dd0091afae2604eba9bed}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!printAddr@{printAddr}}
\index{printAddr@{printAddr}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{printAddr}]{\setlength{\rightskip}{0pt plus 5cm}void printAddr ({\bf Addr} {\em a})}}
\label{classAtomicSimpleCPU_a88aa41e2693dd0091afae2604eba9bed}
Print state of address in memory system via PrintReq (for debugging). 


\begin{DoxyCode}
636 {
637     dcachePort.printAddr(a);
638 }
\end{DoxyCode}
\hypertarget{classAtomicSimpleCPU_aa51e4d7f169cd8e8b2e144fdcfd36f33}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!profileSimPoint@{profileSimPoint}}
\index{profileSimPoint@{profileSimPoint}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{profileSimPoint}]{\setlength{\rightskip}{0pt plus 5cm}void profileSimPoint ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_aa51e4d7f169cd8e8b2e144fdcfd36f33}
Profile basic blocks for SimPoints. Called at every macro inst to increment basic block inst counts and to profile block if end of block. 


\begin{DoxyCode}
642 {
643     if (!currentBBVInstCount)
644         currentBBV.first = thread->pcState().instAddr();
645 
646     ++intervalCount;
647     ++currentBBVInstCount;
648 
649     // If inst is control inst, assume end of basic block.
650     if (curStaticInst->isControl()) {
651         currentBBV.second = thread->pcState().instAddr();
652 
653         auto map_itr = bbMap.find(currentBBV);
654         if (map_itr == bbMap.end()){
655             // If a new (previously unseen) basic block is found,
656             // add a new unique id, record num of insts and insert into bbMap.
657             BBInfo info;
658             info.id = bbMap.size() + 1;
659             info.insts = currentBBVInstCount;
660             info.count = currentBBVInstCount;
661             bbMap.insert(std::make_pair(currentBBV, info));
662         } else {
663             // If basic block is seen before, just increment the count by the
664             // number of insts in basic block.
665             BBInfo& info = map_itr->second;
666             info.count += currentBBVInstCount;
667         }
668         currentBBVInstCount = 0;
669 
670         // Reached end of interval if the sum of the current inst count
671         // (intervalCount) and the excessive inst count from the previous
672         // interval (intervalDrift) is greater than/equal to the interval size.
673         if (intervalCount + intervalDrift >= intervalSize) {
674             // summarize interval and display BBV info
675             std::vector<pair<uint64_t, uint64_t> > counts;
676             for (auto map_itr = bbMap.begin(); map_itr != bbMap.end();
677                     ++map_itr) {
678                 BBInfo& info = map_itr->second;
679                 if (info.count != 0) {
680                     counts.push_back(std::make_pair(info.id, info.count));
681                     info.count = 0;
682                 }
683             }
684             std::sort(counts.begin(), counts.end());
685 
686             // Print output BBV info
687             *simpointStream << "T";
688             for (auto cnt_itr = counts.begin(); cnt_itr != counts.end();
689                     ++cnt_itr) {
690                 *simpointStream << ":" << cnt_itr->first
691                                 << ":" << cnt_itr->second << " ";
692             }
693             *simpointStream << "\n";
694 
695             intervalDrift = (intervalCount + intervalDrift) - intervalSize;
696             intervalCount = 0;
697         }
698     }
699 }
\end{DoxyCode}
\hypertarget{classAtomicSimpleCPU_a66191b2d8a45050b7df3c3efa7bb07c6}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!readMem@{readMem}}
\index{readMem@{readMem}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{readMem}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} readMem ({\bf Addr} {\em addr}, \/  uint8\_\-t $\ast$ {\em data}, \/  unsigned {\em size}, \/  unsigned {\em flags})}}
\label{classAtomicSimpleCPU_a66191b2d8a45050b7df3c3efa7bb07c6}



\begin{DoxyCode}
314 {
315     // use the CPU's statically allocated read request and packet objects
316     Request *req = &data_read_req;
317 
318     if (traceData) {
319         traceData->setAddr(addr);
320     }
321 
322     //The size of the data we're trying to read.
323     int fullSize = size;
324 
325     //The address of the second part of this access if it needs to be split
326     //across a cache line boundary.
327     Addr secondAddr = roundDown(addr + size - 1, cacheLineSize());
328 
329     if (secondAddr > addr)
330         size = secondAddr - addr;
331 
332     dcache_latency = 0;
333 
334     req->taskId(taskId());
335     while (1) {
336         req->setVirt(0, addr, size, flags, dataMasterId(), thread->pcState().inst
      Addr());
337 
338         // translate to physical address
339         Fault fault = thread->dtb->translateAtomic(req, tc, BaseTLB::Read);
340 
341         // Now do the access.
342         if (fault == NoFault && !req->getFlags().isSet(Request::NO_ACCESS)) {
343             Packet pkt = Packet(req,
344                                 req->isLLSC() ? MemCmd::LoadLockedReq :
345                                 MemCmd::ReadReq);
346 
347             //@@@copy ?
348             pkt.dataStatic(data);
349 
350             if (req->isMmappedIpr())
351                 dcache_latency += TheISA::handleIprRead(thread->getTC(), &pkt);
352             else {
353                 if (fastmem && system->isMemAddr(pkt.getAddr()))
354                     system->getPhysMem().access(&pkt);
355                 else
356                     dcache_latency += dcachePort.sendAtomic(&pkt);
357             }
358             dcache_access = true;
359 
360             assert(!pkt.isError());
361 
362             if (req->isLLSC()) {
363                 TheISA::handleLockedRead(thread, req);
364             }
365         }
366 
367         //If there's a fault, return it
368         if (fault != NoFault) {
369             if (req->isPrefetch()) {
370                 return NoFault;
371             } else {
372                 return fault;
373             }
374         }
375 
376         //If we don't need to access a second cache line, stop now.
377         if (secondAddr <= addr)
378         {
379             if (req->isLocked() && fault == NoFault) {
380                 assert(!locked);
381                 locked = true;
382             }
383             return fault;
384         }
385 
386         /*
387          * Set up for accessing the second cache line.
388          */
389 
390         //Move the pointer we're reading into to the correct location.
391         data += size;
392         //Adjust the size to get the remaining bytes.
393         size = addr + fullSize - secondAddr;
394         //And access the right address.
395         addr = secondAddr;
396     }
397 }
\end{DoxyCode}
\hypertarget{classAtomicSimpleCPU_a1dad4c4d2c3df4ef367e14fcc973ce74}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!suspendContext@{suspendContext}}
\index{suspendContext@{suspendContext}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{suspendContext}]{\setlength{\rightskip}{0pt plus 5cm}void suspendContext ({\bf ThreadID} {\em thread\_\-num})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classAtomicSimpleCPU_a1dad4c4d2c3df4ef367e14fcc973ce74}



\begin{DoxyCode}
260 {
261     DPRINTF(SimpleCPU, "SuspendContext %d\n", thread_num);
262 
263     assert(thread_num == 0);
264     assert(thread);
265 
266     if (_status == Idle)
267         return;
268 
269     assert(_status == BaseSimpleCPU::Running);
270 
271     // tick event may not be scheduled if this gets called from inside
272     // an instruction's execution, e.g. "quiesce"
273     if (tickEvent.scheduled())
274         deschedule(tickEvent);
275 
276     notIdleFraction = 0;
277     _status = Idle;
278 }
\end{DoxyCode}
\hypertarget{classAtomicSimpleCPU_a05f299b443f8cc73a93d61572edc0218}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!switchOut@{switchOut}}
\index{switchOut@{switchOut}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{switchOut}]{\setlength{\rightskip}{0pt plus 5cm}void switchOut ()}}
\label{classAtomicSimpleCPU_a05f299b443f8cc73a93d61572edc0218}



\begin{DoxyCode}
207 {
208     BaseSimpleCPU::switchOut();
209 
210     assert(!tickEvent.scheduled());
211     assert(_status == BaseSimpleCPU::Running || _status == Idle);
212     assert(isDrained());
213 }
\end{DoxyCode}
\hypertarget{classAtomicSimpleCPU_ac82d2b8d331b2e8e6854a95d2917dfa2}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ({\bf BaseCPU} $\ast$ {\em oldCPU})}}
\label{classAtomicSimpleCPU_ac82d2b8d331b2e8e6854a95d2917dfa2}



\begin{DoxyCode}
218 {
219     BaseSimpleCPU::takeOverFrom(oldCPU);
220 
221     // The tick event should have been descheduled by drain()
222     assert(!tickEvent.scheduled());
223 
224     ifetch_req.setThreadContext(_cpuId, 0); // Add thread ID if we add MT
225     data_read_req.setThreadContext(_cpuId, 0); // Add thread ID here too
226     data_write_req.setThreadContext(_cpuId, 0); // Add thread ID here too
227 }
\end{DoxyCode}
\hypertarget{classAtomicSimpleCPU_a873dd91783f9efb4a590aded1f70d6b0}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!tick@{tick}}
\index{tick@{tick}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_a873dd91783f9efb4a590aded1f70d6b0}



\begin{DoxyCode}
514 {
515     DPRINTF(SimpleCPU, "Tick\n");
516 
517     Tick latency = 0;
518 
519     for (int i = 0; i < width || locked; ++i) {
520         numCycles++;
521 
522         if (!curStaticInst || !curStaticInst->isDelayedCommit())
523             checkForInterrupts();
524 
525         checkPcEventQueue();
526         // We must have just got suspended by a PC event
527         if (_status == Idle) {
528             tryCompleteDrain();
529             return;
530         }
531 
532         Fault fault = NoFault;
533 
534         TheISA::PCState pcState = thread->pcState();
535 
536         bool needToFetch = !isRomMicroPC(pcState.microPC()) &&
537                            !curMacroStaticInst;
538         if (needToFetch) {
539             ifetch_req.taskId(taskId());
540             setupFetchRequest(&ifetch_req);
541             fault = thread->itb->translateAtomic(&ifetch_req, tc,
542                                                  BaseTLB::Execute);
543         }
544 
545         if (fault == NoFault) {
546             Tick icache_latency = 0;
547             bool icache_access = false;
548             dcache_access = false; // assume no dcache access
549 
550             if (needToFetch) {
551                 // This is commented out because the decoder would act like
552                 // a tiny cache otherwise. It wouldn't be flushed when needed
553                 // like the I cache. It should be flushed, and when that works
554                 // this code should be uncommented.
555                 //Fetch more instruction memory if necessary
556                 //if(decoder.needMoreBytes())
557                 //{
558                     icache_access = true;
559                     Packet ifetch_pkt = Packet(&ifetch_req, MemCmd::ReadReq);
560                     ifetch_pkt.dataStatic(&inst);
561 
562                     if (fastmem && system->isMemAddr(ifetch_pkt.getAddr()))
563                         system->getPhysMem().access(&ifetch_pkt);
564                     else
565                         icache_latency = icachePort.sendAtomic(&ifetch_pkt);
566 
567                     assert(!ifetch_pkt.isError());
568 
569                     // ifetch_req is initialized to read the instruction directly
      
570                     // into the CPU object's inst field.
571                 //}
572             }
573 
574             preExecute();
575 
576             if (curStaticInst) {
577                 fault = curStaticInst->execute(this, traceData);
578 
579                 // keep an instruction count
580                 if (fault == NoFault)
581                     countInst();
582                 else if (traceData && !DTRACE(ExecFaulting)) {
583                     delete traceData;
584                     traceData = NULL;
585                 }
586 
587                 postExecute();
588             }
589 
590             // @todo remove me after debugging with legion done
591             if (curStaticInst && (!curStaticInst->isMicroop() ||
592                         curStaticInst->isFirstMicroop()))
593                 instCnt++;
594 
595             // profile for SimPoints if enabled and macro inst is finished
596             if (simpoint && curStaticInst && (fault == NoFault) &&
597                     (!curStaticInst->isMicroop() ||
598                      curStaticInst->isLastMicroop())) {
599                 profileSimPoint();
600             }
601 
602             Tick stall_ticks = 0;
603             if (simulate_inst_stalls && icache_access)
604                 stall_ticks += icache_latency;
605 
606             if (simulate_data_stalls && dcache_access)
607                 stall_ticks += dcache_latency;
608 
609             if (stall_ticks) {
610                 // the atomic cpu does its accounting in ticks, so
611                 // keep counting in ticks but round to the clock
612                 // period
613                 latency += divCeil(stall_ticks, clockPeriod()) *
614                     clockPeriod();
615             }
616 
617         }
618         if(fault != NoFault || !stayAtPC)
619             advancePC(fault);
620     }
621 
622     if (tryCompleteDrain())
623         return;
624 
625     // instruction takes at least one cycle
626     if (latency < clockPeriod())
627         latency = clockPeriod();
628 
629     if (_status != Idle)
630         schedule(tickEvent, curTick() + latency);
631 }
\end{DoxyCode}
\hypertarget{classAtomicSimpleCPU_abfea8f75a7a7480716801affeebbe87b}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!tryCompleteDrain@{tryCompleteDrain}}
\index{tryCompleteDrain@{tryCompleteDrain}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{tryCompleteDrain}]{\setlength{\rightskip}{0pt plus 5cm}bool tryCompleteDrain ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_abfea8f75a7a7480716801affeebbe87b}
Try to complete a drain request.

\begin{DoxyReturn}{戻り値}
true if the CPU is drained, false otherwise. 
\end{DoxyReturn}



\begin{DoxyCode}
189 {
190     if (!drain_manager)
191         return false;
192 
193     DPRINTF(Drain, "tryCompleteDrain: %s\n", pcState());
194     if (!isDrained())
195         return false;
196 
197     DPRINTF(Drain, "CPU done draining, processing drain event\n");
198     drain_manager->signalDrainDone();
199     drain_manager = NULL;
200 
201     return true;
202 }
\end{DoxyCode}
\hypertarget{classAtomicSimpleCPU_ae2e1ccebe596a180f8105d57f9a93645}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!verifyMemoryMode@{verifyMemoryMode}}
\index{verifyMemoryMode@{verifyMemoryMode}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{verifyMemoryMode}]{\setlength{\rightskip}{0pt plus 5cm}void verifyMemoryMode () const}}
\label{classAtomicSimpleCPU_ae2e1ccebe596a180f8105d57f9a93645}



\begin{DoxyCode}
231 {
232     if (!system->isAtomicMode()) {
233         fatal("The atomic CPU requires the memory system to be in "
234               "'atomic' mode.\n");
235     }
236 }
\end{DoxyCode}
\hypertarget{classAtomicSimpleCPU_ad46c5edeb1ee9b60445f3e26364e2c5e}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!writeMem@{writeMem}}
\index{writeMem@{writeMem}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{writeMem}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} writeMem (uint8\_\-t $\ast$ {\em data}, \/  unsigned {\em size}, \/  {\bf Addr} {\em addr}, \/  unsigned {\em flags}, \/  uint64\_\-t $\ast$ {\em res})}}
\label{classAtomicSimpleCPU_ad46c5edeb1ee9b60445f3e26364e2c5e}



\begin{DoxyCode}
403 {
404 
405     static uint8_t zero_array[64] = {};
406 
407     if (data == NULL) {
408         assert(size <= 64);
409         assert(flags & Request::CACHE_BLOCK_ZERO);
410         // This must be a cache block cleaning request
411         data = zero_array;
412     }
413 
414     // use the CPU's statically allocated write request and packet objects
415     Request *req = &data_write_req;
416 
417     if (traceData) {
418         traceData->setAddr(addr);
419     }
420 
421     //The size of the data we're trying to read.
422     int fullSize = size;
423 
424     //The address of the second part of this access if it needs to be split
425     //across a cache line boundary.
426     Addr secondAddr = roundDown(addr + size - 1, cacheLineSize());
427 
428     if(secondAddr > addr)
429         size = secondAddr - addr;
430 
431     dcache_latency = 0;
432 
433     req->taskId(taskId());
434     while(1) {
435         req->setVirt(0, addr, size, flags, dataMasterId(), thread->pcState().inst
      Addr());
436 
437         // translate to physical address
438         Fault fault = thread->dtb->translateAtomic(req, tc, BaseTLB::Write);
439 
440         // Now do the access.
441         if (fault == NoFault) {
442             MemCmd cmd = MemCmd::WriteReq; // default
443             bool do_access = true;  // flag to suppress cache access
444 
445             if (req->isLLSC()) {
446                 cmd = MemCmd::StoreCondReq;
447                 do_access = TheISA::handleLockedWrite(thread, req, dcachePort.
      cacheBlockMask);
448             } else if (req->isSwap()) {
449                 cmd = MemCmd::SwapReq;
450                 if (req->isCondSwap()) {
451                     assert(res);
452                     req->setExtraData(*res);
453                 }
454             }
455 
456             if (do_access && !req->getFlags().isSet(Request::NO_ACCESS)) {
457                 Packet pkt = Packet(req, cmd);
458                 pkt.dataStatic(data);
459 
460                 if (req->isMmappedIpr()) {
461                     dcache_latency +=
462                         TheISA::handleIprWrite(thread->getTC(), &pkt);
463                 } else {
464                     if (fastmem && system->isMemAddr(pkt.getAddr()))
465                         system->getPhysMem().access(&pkt);
466                     else
467                         dcache_latency += dcachePort.sendAtomic(&pkt);
468                 }
469                 dcache_access = true;
470                 assert(!pkt.isError());
471 
472                 if (req->isSwap()) {
473                     assert(res);
474                     memcpy(res, pkt.getPtr<uint8_t>(), fullSize);
475                 }
476             }
477 
478             if (res && !req->isSwap()) {
479                 *res = req->getExtraData();
480             }
481         }
482 
483         //If there's a fault or we don't need to access a second cache line,
484         //stop now.
485         if (fault != NoFault || secondAddr <= addr)
486         {
487             if (req->isLocked() && fault == NoFault) {
488                 assert(locked);
489                 locked = false;
490             }
491             if (fault != NoFault && req->isPrefetch()) {
492                 return NoFault;
493             } else {
494                 return fault;
495             }
496         }
497 
498         /*
499          * Set up for accessing the second cache line.
500          */
501 
502         //Move the pointer we're reading into to the correct location.
503         data += size;
504         //Adjust the size to get the remaining bytes.
505         size = addr + fullSize - secondAddr;
506         //And access the right address.
507         addr = secondAddr;
508     }
509 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classAtomicSimpleCPU_a06bfab070d35f298897393f7ee6e066c}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!bbMap@{bbMap}}
\index{bbMap@{bbMap}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{bbMap}]{\setlength{\rightskip}{0pt plus 5cm}m5::hash\_\-map$<${\bf BasicBlockRange}, {\bf BBInfo}$>$ {\bf bbMap}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_a06bfab070d35f298897393f7ee6e066c}
Hash table containing all previously seen basic blocks \hypertarget{classAtomicSimpleCPU_aa13454a445c3711abe528bdd288a953c}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!currentBBV@{currentBBV}}
\index{currentBBV@{currentBBV}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{currentBBV}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BasicBlockRange} {\bf currentBBV}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_aa13454a445c3711abe528bdd288a953c}
Currently executing basic block \hypertarget{classAtomicSimpleCPU_a375bb98c835fcacb306ec154ac3c7f85}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!currentBBVInstCount@{currentBBVInstCount}}
\index{currentBBVInstCount@{currentBBVInstCount}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{currentBBVInstCount}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf currentBBVInstCount}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_a375bb98c835fcacb306ec154ac3c7f85}
inst count in current basic block \hypertarget{classAtomicSimpleCPU_a836513db061d14f39d79751c40fa9951}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!data\_\-read\_\-req@{data\_\-read\_\-req}}
\index{data\_\-read\_\-req@{data\_\-read\_\-req}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{data\_\-read\_\-req}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Request} {\bf data\_\-read\_\-req}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_a836513db061d14f39d79751c40fa9951}
\hypertarget{classAtomicSimpleCPU_af2cc98a9d486d932d85c4513a4670ca8}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!data\_\-write\_\-req@{data\_\-write\_\-req}}
\index{data\_\-write\_\-req@{data\_\-write\_\-req}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{data\_\-write\_\-req}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Request} {\bf data\_\-write\_\-req}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_af2cc98a9d486d932d85c4513a4670ca8}
\hypertarget{classAtomicSimpleCPU_a40a30a05f8e2b8b4c62c0ee0a019686a}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!dcache\_\-access@{dcache\_\-access}}
\index{dcache\_\-access@{dcache\_\-access}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{dcache\_\-access}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf dcache\_\-access}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_a40a30a05f8e2b8b4c62c0ee0a019686a}
\hypertarget{classAtomicSimpleCPU_a08f04a43a6d731e966308aaeece77208}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!dcache\_\-latency@{dcache\_\-latency}}
\index{dcache\_\-latency@{dcache\_\-latency}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{dcache\_\-latency}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf dcache\_\-latency}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_a08f04a43a6d731e966308aaeece77208}
\hypertarget{classAtomicSimpleCPU_ab6b7665b418b12dc80b485e66d23ed19}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!dcachePort@{dcachePort}}
\index{dcachePort@{dcachePort}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{dcachePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AtomicCPUDPort} {\bf dcachePort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_ab6b7665b418b12dc80b485e66d23ed19}
\hypertarget{classAtomicSimpleCPU_af9ba920f669cbe0f18c71846715d690a}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!drain\_\-manager@{drain\_\-manager}}
\index{drain\_\-manager@{drain\_\-manager}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{drain\_\-manager}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DrainManager}$\ast$ {\bf drain\_\-manager}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_af9ba920f669cbe0f18c71846715d690a}
Drain manager to use when signaling drain completion

This pointer is non-\/NULL when draining and NULL otherwise. \hypertarget{classAtomicSimpleCPU_a66f9c88f6fa05c882787a7e98a7101f5}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!fastmem@{fastmem}}
\index{fastmem@{fastmem}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{fastmem}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf fastmem}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_a66f9c88f6fa05c882787a7e98a7101f5}
\hypertarget{classAtomicSimpleCPU_a35e511691227100effd63e8a7fc12989}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!icachePort@{icachePort}}
\index{icachePort@{icachePort}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{icachePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AtomicCPUPort} {\bf icachePort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_a35e511691227100effd63e8a7fc12989}
\hypertarget{classAtomicSimpleCPU_a64ba0dde58d6c2c1c5e24a0b3e3b506f}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!ifetch\_\-req@{ifetch\_\-req}}
\index{ifetch\_\-req@{ifetch\_\-req}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{ifetch\_\-req}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Request} {\bf ifetch\_\-req}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_a64ba0dde58d6c2c1c5e24a0b3e3b506f}
\hypertarget{classAtomicSimpleCPU_a4ba2ebd08d9a7f8efe072ed006f2ba56}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!intervalCount@{intervalCount}}
\index{intervalCount@{intervalCount}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{intervalCount}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf intervalCount}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_a4ba2ebd08d9a7f8efe072ed006f2ba56}
Inst count in current basic block \hypertarget{classAtomicSimpleCPU_a0c93f234d5028e73f388f7e730db728f}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!intervalDrift@{intervalDrift}}
\index{intervalDrift@{intervalDrift}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{intervalDrift}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf intervalDrift}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_a0c93f234d5028e73f388f7e730db728f}
Excess inst count from previous interval \hypertarget{classAtomicSimpleCPU_afa2df438a2925349299948892f519ea2}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!intervalSize@{intervalSize}}
\index{intervalSize@{intervalSize}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{intervalSize}]{\setlength{\rightskip}{0pt plus 5cm}const uint64\_\-t {\bf intervalSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_afa2df438a2925349299948892f519ea2}
SimPoint profiling interval size in instructions \hypertarget{classAtomicSimpleCPU_a18a0f1e6c3d21c252b14ea6ae162e2ff}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!locked@{locked}}
\index{locked@{locked}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{locked}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf locked}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_a18a0f1e6c3d21c252b14ea6ae162e2ff}
\hypertarget{classAtomicSimpleCPU_a556c6eb1f8f869ee7d0802381701c49f}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!simpoint@{simpoint}}
\index{simpoint@{simpoint}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{simpoint}]{\setlength{\rightskip}{0pt plus 5cm}const bool {\bf simpoint}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_a556c6eb1f8f869ee7d0802381701c49f}
Data structures for SimPoints BBV generation Whether SimPoint BBV profiling is enabled \hypertarget{classAtomicSimpleCPU_a77497fabc62f774e824e9b57974e0301}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!simpointStream@{simpointStream}}
\index{simpointStream@{simpointStream}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{simpointStream}]{\setlength{\rightskip}{0pt plus 5cm}std::ostream$\ast$ {\bf simpointStream}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_a77497fabc62f774e824e9b57974e0301}
Pointer to SimPoint BBV output stream \hypertarget{classAtomicSimpleCPU_aab46afe7eb154b233d2ba1886a4b399f}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!simulate\_\-data\_\-stalls@{simulate\_\-data\_\-stalls}}
\index{simulate\_\-data\_\-stalls@{simulate\_\-data\_\-stalls}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{simulate\_\-data\_\-stalls}]{\setlength{\rightskip}{0pt plus 5cm}const bool {\bf simulate\_\-data\_\-stalls}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_aab46afe7eb154b233d2ba1886a4b399f}
\hypertarget{classAtomicSimpleCPU_ac5ff523d495df7133594dec7894aacc7}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!simulate\_\-inst\_\-stalls@{simulate\_\-inst\_\-stalls}}
\index{simulate\_\-inst\_\-stalls@{simulate\_\-inst\_\-stalls}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{simulate\_\-inst\_\-stalls}]{\setlength{\rightskip}{0pt plus 5cm}const bool {\bf simulate\_\-inst\_\-stalls}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_ac5ff523d495df7133594dec7894aacc7}
\hypertarget{classAtomicSimpleCPU_aa36b8e894416f0ec98f701ab08f2ac22}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!tickEvent@{tickEvent}}
\index{tickEvent@{tickEvent}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{tickEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TickEvent} {\bf tickEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_aa36b8e894416f0ec98f701ab08f2ac22}
\hypertarget{classAtomicSimpleCPU_a837aabdd54757cb86d0f66387511753f}{
\index{AtomicSimpleCPU@{AtomicSimpleCPU}!width@{width}}
\index{width@{width}!AtomicSimpleCPU@{AtomicSimpleCPU}}
\subsubsection[{width}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf width}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAtomicSimpleCPU_a837aabdd54757cb86d0f66387511753f}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/simple/\hyperlink{atomic_8hh}{atomic.hh}\item 
cpu/simple/\hyperlink{atomic_8cc}{atomic.cc}\end{DoxyCompactItemize}
