\hypertarget{classSimpleTimingPort}{
\section{クラス SimpleTimingPort}
\label{classSimpleTimingPort}\index{SimpleTimingPort@{SimpleTimingPort}}
}


{\ttfamily \#include $<$tport.hh$>$}SimpleTimingPortに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=7cm]{classSimpleTimingPort}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSimpleTimingPort_a2273fa04bdf4a7c437c885569c7df97b}{SimpleTimingPort} (const std::string \&name, \hyperlink{classMemObject}{MemObject} $\ast$\hyperlink{classPort_aba966efb6c1df4b015be3a396df6c318}{owner})
\item 
virtual \hyperlink{classSimpleTimingPort_a4a2041c97513fa07a0941771519c951d}{$\sim$SimpleTimingPort} ()
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classSimpleTimingPort_aeefa907fb6d6a787e6dab90e8138ea90}{recvFunctional} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classSimpleTimingPort_a3344d9dd0f83257feab5424e761f31c6}{recvTimingReq} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classSimpleTimingPort_a428ab07671bc9372dc44a2487b12a726}{recvAtomic} (\hyperlink{classPacket}{PacketPtr} pkt)=0
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classPacket}{PacketPtr} $>$ \hyperlink{classSimpleTimingPort_a21da4bea3554874b557428e4cce5d4a4}{pendingDelete}
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSlavePacketQueue}{SlavePacketQueue} \hyperlink{classSimpleTimingPort_ab41143071108edb2c003308b57c50d8e}{queueImpl}
\end{DoxyCompactItemize}


\subsection{説明}
The simple timing port uses a queued port to implement recvFunctional and recvTimingReq through recvAtomic. It is always a slave port. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classSimpleTimingPort_a2273fa04bdf4a7c437c885569c7df97b}{
\index{SimpleTimingPort@{SimpleTimingPort}!SimpleTimingPort@{SimpleTimingPort}}
\index{SimpleTimingPort@{SimpleTimingPort}!SimpleTimingPort@{SimpleTimingPort}}
\subsubsection[{SimpleTimingPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SimpleTimingPort} (const std::string \& {\em name}, \/  {\bf MemObject} $\ast$ {\em owner})}}
\label{classSimpleTimingPort_a2273fa04bdf4a7c437c885569c7df97b}
Create a new \hyperlink{classSimpleTimingPort}{SimpleTimingPort} that relies on a packet queue to hold responses, and implements recvTimingReq and recvFunctional through calls to recvAtomic. Once a request arrives, it is passed to recvAtomic, and in the case of a timing access any response is scheduled to be sent after the delay of the atomic operation.


\begin{DoxyParams}{引数}
\item[{\em name}]port name \item[{\em owner}]structural owner \end{DoxyParams}



\begin{DoxyCode}
48                                                       :
49     QueuedSlavePort(_name, _owner, queueImpl), queueImpl(*_owner, *this)
50 {
51 }

\end{DoxyCode}
\hypertarget{classSimpleTimingPort_a4a2041c97513fa07a0941771519c951d}{
\index{SimpleTimingPort@{SimpleTimingPort}!$\sim$SimpleTimingPort@{$\sim$SimpleTimingPort}}
\index{$\sim$SimpleTimingPort@{$\sim$SimpleTimingPort}!SimpleTimingPort@{SimpleTimingPort}}
\subsubsection[{$\sim$SimpleTimingPort}]{\setlength{\rightskip}{0pt plus 5cm}virtual $\sim${\bf SimpleTimingPort} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classSimpleTimingPort_a4a2041c97513fa07a0941771519c951d}



\begin{DoxyCode}
106 { }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classSimpleTimingPort_a428ab07671bc9372dc44a2487b12a726}{
\index{SimpleTimingPort@{SimpleTimingPort}!recvAtomic@{recvAtomic}}
\index{recvAtomic@{recvAtomic}!SimpleTimingPort@{SimpleTimingPort}}
\subsubsection[{recvAtomic}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Tick} recvAtomic ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classSimpleTimingPort_a428ab07671bc9372dc44a2487b12a726}
Receive an atomic request packet from the master port. 

\hyperlink{classSlavePort_a428ab07671bc9372dc44a2487b12a726}{SlavePort}を実装しています。

\hyperlink{classPioPort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{PioPort}, \hyperlink{classPciDevice_1_1PciConfigPort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{PciConfigPort}, と \hyperlink{classMessageSlavePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{MessageSlavePort}で実装されています。\hypertarget{classSimpleTimingPort_aeefa907fb6d6a787e6dab90e8138ea90}{
\index{SimpleTimingPort@{SimpleTimingPort}!recvFunctional@{recvFunctional}}
\index{recvFunctional@{recvFunctional}!SimpleTimingPort@{SimpleTimingPort}}
\subsubsection[{recvFunctional}]{\setlength{\rightskip}{0pt plus 5cm}void recvFunctional ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classSimpleTimingPort_aeefa907fb6d6a787e6dab90e8138ea90}
Implemented using \hyperlink{classSimpleTimingPort_a428ab07671bc9372dc44a2487b12a726}{recvAtomic()}. 

\hyperlink{classSlavePort_a6a3d6f2e5dab6bed16d53d9e7c17378d}{SlavePort}を実装しています。


\begin{DoxyCode}
55 {
56     if (!queue.checkFunctional(pkt)) {
57         // do an atomic access and throw away the returned latency
58         recvAtomic(pkt);
59     }
60 }
\end{DoxyCode}
\hypertarget{classSimpleTimingPort_a3344d9dd0f83257feab5424e761f31c6}{
\index{SimpleTimingPort@{SimpleTimingPort}!recvTimingReq@{recvTimingReq}}
\index{recvTimingReq@{recvTimingReq}!SimpleTimingPort@{SimpleTimingPort}}
\subsubsection[{recvTimingReq}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingReq ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classSimpleTimingPort_a3344d9dd0f83257feab5424e761f31c6}
Implemented using \hyperlink{classSimpleTimingPort_a428ab07671bc9372dc44a2487b12a726}{recvAtomic()}. 

\begin{Desc}
\item[\hyperlink{todo__todo000088}{TODO}]temporary hack to deal with memory corruption issue until 4-\/phase transactions are complete. Remove me later \end{Desc}


\begin{Desc}
\item[\hyperlink{todo__todo000089}{TODO}]nominally we should just delete the packet here. Until 4-\/phase stuff we can't because the sending cache is still relying on it \end{Desc}


\hyperlink{classSlavePort_abcece77e42f88ee41af8d3d01bb48253}{SlavePort}を実装しています。


\begin{DoxyCode}
64 {
67     for (int x = 0; x < pendingDelete.size(); x++)
68         delete pendingDelete[x];
69     pendingDelete.clear();
70 
71     // the SimpleTimingPort should not be used anywhere where there is
72     // a need to deal with inhibited packets
73     if (pkt->memInhibitAsserted())
74         panic("SimpleTimingPort should never see an inhibited request\n");
75 
76     bool needsResponse = pkt->needsResponse();
77     Tick latency = recvAtomic(pkt);
78     // turn packet around to go back to requester if response expected
79     if (needsResponse) {
80         // recvAtomic() should already have turned packet into
81         // atomic response
82         assert(pkt->isResponse());
83         schedTimingResp(pkt, curTick() + latency);
84     } else {
88         pendingDelete.push_back(pkt);
89     }
90 
91     return true;
92 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classSimpleTimingPort_a21da4bea3554874b557428e4cce5d4a4}{
\index{SimpleTimingPort@{SimpleTimingPort}!pendingDelete@{pendingDelete}}
\index{pendingDelete@{pendingDelete}!SimpleTimingPort@{SimpleTimingPort}}
\subsubsection[{pendingDelete}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf PacketPtr}$>$ {\bf pendingDelete}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSimpleTimingPort_a21da4bea3554874b557428e4cce5d4a4}
\begin{Desc}
\item[\hyperlink{todo__todo000090}{TODO}]this is a temporary workaround until the 4-\/phase code is committed. upstream caches need this packet until true is returned, so hold it for deletion until a subsequent call \end{Desc}
\hypertarget{classSimpleTimingPort_ab41143071108edb2c003308b57c50d8e}{
\index{SimpleTimingPort@{SimpleTimingPort}!queueImpl@{queueImpl}}
\index{queueImpl@{queueImpl}!SimpleTimingPort@{SimpleTimingPort}}
\subsubsection[{queueImpl}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SlavePacketQueue} {\bf queueImpl}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSimpleTimingPort_ab41143071108edb2c003308b57c50d8e}
The packet queue used to store outgoing responses. Note that the queue is made private and that we avoid overloading the name used in the \hyperlink{classQueuedSlavePort}{QueuedSlavePort}. Access is provided through the queue reference in the base class. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{tport_8hh}{tport.hh}\item 
mem/\hyperlink{tport_8cc}{tport.cc}\end{DoxyCompactItemize}
