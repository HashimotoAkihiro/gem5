<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>File&nbsp;GEM5&nbsp;Wrapper: クラス テンプレート MemSidePacketQueue&lt; TagStore &gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- 作成： Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>メインページ</span></a></li>
      <li><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>構成</span></a></li>
      <li><a href="classes.html"><span>構成索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>構成メンバ</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="classCache.html">Cache</a>::<a class="el" href="classCache_1_1MemSidePacketQueue.html">MemSidePacketQueue</a>
  </div>
</div>
<div class="contents">
<h1>クラス テンプレート MemSidePacketQueue&lt; TagStore &gt;</h1><!-- doxytag: class="Cache::MemSidePacketQueue" --><!-- doxytag: inherits="MasterPacketQueue" -->
<p><code>#include &lt;<a class="el" href="cache_8hh_source.html">cache.hh</a>&gt;</code></p>
<div class="dynheader">
MemSidePacketQueue&lt; TagStore &gt;に対する継承グラフ</div>
<div class="dynsection">
 <div class="center">
  <img src="classCache_1_1MemSidePacketQueue.gif" usemap="#MemSidePacketQueue&lt; TagStore &gt;_map" alt=""/>
  <map id="MemSidePacketQueue&lt; TagStore &gt;_map" name="MemSidePacketQueue&lt; TagStore &gt;_map">
<area href="classMasterPacketQueue.html" alt="MasterPacketQueue" shape="rect" coords="0,112,215,136"/>
<area href="classPacketQueue.html" alt="PacketQueue" shape="rect" coords="0,56,215,80"/>
<area href="classDrainable.html" alt="Drainable" shape="rect" coords="0,0,215,24"/>
</map>
 </div>
</div>

<p><a href="classCache_1_1MemSidePacketQueue-members.html">すべてのメンバ一覧</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache_1_1MemSidePacketQueue.html#af98f7e700e64b2c5f5bd8f96b7368b0a">MemSidePacketQueue</a> (<a class="el" href="classCache.html">Cache</a>&lt; TagStore &gt; &amp;<a class="el" href="classCache_1_1MemSidePacketQueue.html#adf2b34ffa42914b9356a0788fc109bcc">cache</a>, <a class="el" href="classMasterPort.html">MasterPort</a> &amp;port, const std::string &amp;<a class="el" href="classPacketQueue.html#ae471a4c4073716b769170188214fe93d">label</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache_1_1MemSidePacketQueue.html#a3ce3f4b79c2caf000124b3de8ba9157c">sendDeferredPacket</a> ()</td></tr>
<tr><td colspan="2"><h2>Protected 変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCache.html">Cache</a>&lt; TagStore &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache_1_1MemSidePacketQueue.html#adf2b34ffa42914b9356a0788fc109bcc">cache</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>説明</h2>
<h3>template&lt;class TagStore&gt;<br/>
template&lt;class TagStore&gt;<br/>
 class Cache&lt; TagStore &gt;::MemSidePacketQueue&lt; TagStore &gt;</h3>

<p>Override the default behaviour of sendDeferredPacket to enable the memory-side cache port to also send requests based on the current <a class="el" href="classMSHR.html">MSHR</a> status. This queue has a pointer to our specific cache implementation and is used by the <a class="el" href="classCache_1_1MemSidePort.html">MemSidePort</a>. </p>
<hr/><h2>コンストラクタとデストラクタ</h2>
<a class="anchor" id="af98f7e700e64b2c5f5bd8f96b7368b0a"></a><!-- doxytag: member="Cache::MemSidePacketQueue::MemSidePacketQueue" ref="af98f7e700e64b2c5f5bd8f96b7368b0a" args="(Cache&lt; TagStore &gt; &amp;cache, MasterPort &amp;port, const std::string &amp;label)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCache_1_1MemSidePacketQueue.html">MemSidePacketQueue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCache.html">Cache</a>&lt; TagStore &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMasterPort.html">MasterPort</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>label</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00127"></a>00127                                                    :
<a name="l00128"></a>00128             <a class="code" href="classMasterPacketQueue.html#a95398bd9589a013635d2d0900aeb04a7">MasterPacketQueue</a>(cache, port, <a class="code" href="classPacketQueue.html#ae471a4c4073716b769170188214fe93d">label</a>), <a class="code" href="classCache_1_1MemSidePacketQueue.html#adf2b34ffa42914b9356a0788fc109bcc">cache</a>(cache) { }

</pre></div></p>

</div>
</div>
<hr/><h2>関数</h2>
<a class="anchor" id="a3ce3f4b79c2caf000124b3de8ba9157c"></a><!-- doxytag: member="Cache::MemSidePacketQueue::sendDeferredPacket" ref="a3ce3f4b79c2caf000124b3de8ba9157c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sendDeferredPacket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Override the normal sendDeferredPacket and do not only consider the transmit list (used for responses), but also requests. </p>

<p><a class="el" href="classPacketQueue.html#a3ce3f4b79c2caf000124b3de8ba9157c">PacketQueue</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l01947"></a>01947 {
<a name="l01948"></a>01948     <span class="comment">// if we have a response packet waiting we have to start with that</span>
<a name="l01949"></a>01949     <span class="keywordflow">if</span> (<a class="code" href="classPacketQueue.html#a052ea90ae061f6d3b53d6dee3b3076f3">deferredPacketReady</a>()) {
<a name="l01950"></a>01950         <span class="comment">// use the normal approach from the timing port</span>
<a name="l01951"></a>01951         <a class="code" href="classPacketQueue.html#a391c414b53eb45782e37bc539608e477">trySendTiming</a>();
<a name="l01952"></a>01952     } <span class="keywordflow">else</span> {
<a name="l01953"></a>01953         <span class="comment">// check for request packets (requests &amp; writebacks)</span>
<a name="l01954"></a>01954         <a class="code" href="classPacket.html">PacketPtr</a> pkt = <a class="code" href="classCache_1_1MemSidePacketQueue.html#adf2b34ffa42914b9356a0788fc109bcc">cache</a>.getTimingPacket();
<a name="l01955"></a>01955         <span class="keywordflow">if</span> (pkt == <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>) {
<a name="l01956"></a>01956             <span class="comment">// can happen if e.g. we attempt a writeback and fail, but</span>
<a name="l01957"></a>01957             <span class="comment">// before the retry, the writeback is eliminated because</span>
<a name="l01958"></a>01958             <span class="comment">// we snoop another cache&apos;s ReadEx.</span>
<a name="l01959"></a>01959             <a class="code" href="classPacketQueue.html#ad4363dd8230c71676c4cad8dd5a0b8a7">waitingOnRetry</a> = <span class="keyword">false</span>;
<a name="l01960"></a>01960         } <span class="keywordflow">else</span> {
<a name="l01961"></a>01961             <a class="code" href="classMSHR.html">MSHR</a> *mshr = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classMSHR.html">MSHR</a>*<span class="keyword">&gt;</span>(pkt-&gt;<a class="code" href="classPacket.html#a983ade0479f946c813284dcc65073367">senderState</a>);
<a name="l01962"></a>01962 
<a name="l01963"></a>01963             <a class="code" href="classPacketQueue.html#ad4363dd8230c71676c4cad8dd5a0b8a7">waitingOnRetry</a> = !<a class="code" href="classMasterPacketQueue.html#a43650d24b03c3739d70cd1b9500d1d9b">masterPort</a>.<a class="code" href="classMasterPort.html#aafaf979005392447714384794f1a8610">sendTimingReq</a>(pkt);
<a name="l01964"></a>01964 
<a name="l01965"></a>01965             <span class="keywordflow">if</span> (<a class="code" href="classPacketQueue.html#ad4363dd8230c71676c4cad8dd5a0b8a7">waitingOnRetry</a>) {
<a name="l01966"></a>01966                 <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(CachePort, <span class="stringliteral">&quot;now waiting on a retry\n&quot;</span>);
<a name="l01967"></a>01967                 <span class="keywordflow">if</span> (!mshr-&gt;<a class="code" href="classMSHR.html#aee2f7196808cfdd31122d93d11b633de">isForwardNoResponse</a>()) {
<a name="l01968"></a>01968                     <span class="comment">// we are awaiting a retry, but we</span>
<a name="l01969"></a>01969                     <span class="comment">// delete the packet and will be creating a new packet</span>
<a name="l01970"></a>01970                     <span class="comment">// when we get the opportunity</span>
<a name="l01971"></a>01971                     <span class="keyword">delete</span> pkt;
<a name="l01972"></a>01972                 }
<a name="l01973"></a>01973                 <span class="comment">// note that we have now masked any requestBus and</span>
<a name="l01974"></a>01974                 <span class="comment">// schedSendEvent (we will wait for a retry before</span>
<a name="l01975"></a>01975                 <span class="comment">// doing anything), and this is so even if we do not</span>
<a name="l01976"></a>01976                 <span class="comment">// care about this packet and might override it before</span>
<a name="l01977"></a>01977                 <span class="comment">// it gets retried</span>
<a name="l01978"></a>01978             } <span class="keywordflow">else</span> {
<a name="l01979"></a>01979                 <a class="code" href="classCache_1_1MemSidePacketQueue.html#adf2b34ffa42914b9356a0788fc109bcc">cache</a>.markInService(mshr, pkt);
<a name="l01980"></a>01980             }
<a name="l01981"></a>01981         }
<a name="l01982"></a>01982     }
<a name="l01983"></a>01983 
<a name="l01984"></a>01984     <span class="comment">// if we succeeded and are not waiting for a retry, schedule the</span>
<a name="l01985"></a>01985     <span class="comment">// next send, not only looking at the response transmit list, but</span>
<a name="l01986"></a>01986     <span class="comment">// also considering when the next MSHR is ready</span>
<a name="l01987"></a>01987     <span class="keywordflow">if</span> (!<a class="code" href="classPacketQueue.html#ad4363dd8230c71676c4cad8dd5a0b8a7">waitingOnRetry</a>) {
<a name="l01988"></a>01988         <a class="code" href="classPacketQueue.html#a34d5599fd6c275e889527628932a224e">scheduleSend</a>(<a class="code" href="classCache_1_1MemSidePacketQueue.html#adf2b34ffa42914b9356a0788fc109bcc">cache</a>.nextMSHRReadyTime());
<a name="l01989"></a>01989     }
<a name="l01990"></a>01990 }
</pre></div></p>

</div>
</div>
<hr/><h2>変数</h2>
<a class="anchor" id="adf2b34ffa42914b9356a0788fc109bcc"></a><!-- doxytag: member="Cache::MemSidePacketQueue::cache" ref="adf2b34ffa42914b9356a0788fc109bcc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCache.html">Cache</a>&lt;TagStore&gt;&amp; <a class="el" href="classCache_1_1MemSidePacketQueue.html#adf2b34ffa42914b9356a0788fc109bcc">cache</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>このクラスの説明は次のファイルから生成されました:<ul>
<li>mem/cache/<a class="el" href="cache_8hh_source.html">cache.hh</a></li>
<li>mem/cache/<a class="el" href="cache__impl_8hh_source.html">cache_impl.hh</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>File&nbsp;GEM5&nbsp;Wrapperに対して25 May 2015に生成されました。&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
