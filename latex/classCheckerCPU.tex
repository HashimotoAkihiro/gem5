\hypertarget{classCheckerCPU}{
\section{クラス CheckerCPU}
\label{classCheckerCPU}\index{CheckerCPU@{CheckerCPU}}
}


{\ttfamily \#include $<$cpu.hh$>$}CheckerCPUに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=1.23416cm]{classCheckerCPU}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classCheckerCPU_1_1CheckerCPU}{CheckerCPU}
\item 
union \hyperlink{unionCheckerCPU_1_1Result}{Result}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef CheckerCPUParams \hyperlink{classCheckerCPU_a56bf98a1e02b979e88cbf64420995961}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classCheckerCPU_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
\hyperlink{classCheckerCPU_a35dbdd3a266a1df157875f0f7c5b5f66}{CheckerCPU} (\hyperlink{classCheckerCPU_a56bf98a1e02b979e88cbf64420995961}{Params} $\ast$p)
\item 
virtual \hyperlink{classCheckerCPU_ac259e064f2f0d74835ec2b38dd175ef4}{$\sim$CheckerCPU} ()
\item 
void \hyperlink{classCheckerCPU_a87165dd3c0f61d17b5decfdd925b3fcd}{setSystem} (\hyperlink{classSystem}{System} $\ast$\hyperlink{classBaseCPU_ab737471139f5a296e5b26e8a0e1b0744}{system})
\item 
void \hyperlink{classCheckerCPU_a925d02a64d6c947d4ba3bb96bef728ff}{setIcachePort} (\hyperlink{classMasterPort}{MasterPort} $\ast$\hyperlink{classBaseCPU_ada744b98d4371502b5cb7c4f036f1344}{icache\_\-port})
\item 
void \hyperlink{classCheckerCPU_a8d77cc755c7a424f4eb80130fb627012}{setDcachePort} (\hyperlink{classMasterPort}{MasterPort} $\ast$\hyperlink{classBaseCPU_a9c199cadc0aca1c84868beea5d4402e7}{dcache\_\-port})
\item 
\hyperlink{classMasterPort}{MasterPort} \& \hyperlink{classCheckerCPU_a041a57fcad534c1bed3702a0f8f3a6b1}{getDataPort} ()
\item 
\hyperlink{classMasterPort}{MasterPort} \& \hyperlink{classCheckerCPU_ab8ce6baf7cb0aaaf4ca346896a86fa03}{getInstPort} ()
\item 
TheISA::TLB $\ast$ \hyperlink{classCheckerCPU_a95b7e95d0558cd03d69613142fff9137}{getITBPtr} ()
\item 
TheISA::TLB $\ast$ \hyperlink{classCheckerCPU_a2fe6a07c44bc2a4d83b86bea605ba971}{getDTBPtr} ()
\item 
virtual \hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classCheckerCPU_abdcc0de01ff3d8d22a40e0b966acb463}{totalInsts} () const 
\item 
virtual \hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classCheckerCPU_adfb528b512cf037ade8dc8e22bf8a7bd}{totalOps} () const 
\item 
virtual void \hyperlink{classCheckerCPU_ad6272f80ae37e8331e3969b3f072a801}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classCheckerCPU_af100c4e9feabf3cd918619c88c718387}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\item 
void \hyperlink{classCheckerCPU_a2f9742f8d2bcf6a31ebfc121fd9d5fbc}{setEA} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} EA)
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classCheckerCPU_a840be0f7fe0a7a50b37b0552fe6ca506}{getEA} ()
\item 
uint64\_\-t \hyperlink{classCheckerCPU_a9e7b0a4d5373c48902425c9456b19e7e}{readIntRegOperand} (const \hyperlink{classStaticInst}{StaticInst} $\ast$si, int idx)
\item 
\hyperlink{classCheckerCPU_a75484259f1855aabc8d74c6eb1cfe186}{FloatReg} \hyperlink{classCheckerCPU_a717c88c8c56d79c9ed554ba5992bd8c3}{readFloatRegOperand} (const \hyperlink{classStaticInst}{StaticInst} $\ast$si, int idx)
\item 
\hyperlink{classCheckerCPU_aab5eeae86499f9bfe15ef79360eccc64}{FloatRegBits} \hyperlink{classCheckerCPU_a39d93624e4481f4a210f2c46ea6b15b0}{readFloatRegOperandBits} (const \hyperlink{classStaticInst}{StaticInst} $\ast$si, int idx)
\item 
uint64\_\-t \hyperlink{classCheckerCPU_a25532f176443f0ec538a3b833c55f4a0}{readCCRegOperand} (const \hyperlink{classStaticInst}{StaticInst} $\ast$si, int idx)
\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{classCheckerCPU_accfdfc918ee73975e86b08cf8a528479}{setResult} (T t)
\item 
void \hyperlink{classCheckerCPU_a654e99f2be7cd298378462ce9651bb44}{setIntRegOperand} (const \hyperlink{classStaticInst}{StaticInst} $\ast$si, int idx, uint64\_\-t val)
\item 
void \hyperlink{classCheckerCPU_addc8b4b6511725bf8ff48bd09ef22892}{setFloatRegOperand} (const \hyperlink{classStaticInst}{StaticInst} $\ast$si, int idx, \hyperlink{classCheckerCPU_a75484259f1855aabc8d74c6eb1cfe186}{FloatReg} val)
\item 
void \hyperlink{classCheckerCPU_a80a516966713c873cf964af7538dbd37}{setFloatRegOperandBits} (const \hyperlink{classStaticInst}{StaticInst} $\ast$si, int idx, \hyperlink{classCheckerCPU_aab5eeae86499f9bfe15ef79360eccc64}{FloatRegBits} val)
\item 
void \hyperlink{classCheckerCPU_afeb2b876cf6b29215cf9d6d56ba8863b}{setCCRegOperand} (const \hyperlink{classStaticInst}{StaticInst} $\ast$si, int idx, uint64\_\-t val)
\item 
bool \hyperlink{classCheckerCPU_a254cecc48d457ea298b08a8bb009f9cf}{readPredicate} ()
\item 
void \hyperlink{classCheckerCPU_a137a8c6cced89c2ff8387900439436b4}{setPredicate} (bool val)
\item 
TheISA::PCState \hyperlink{classCheckerCPU_a827fb3454585cf4c620f4fd341966317}{pcState} ()
\item 
void \hyperlink{classCheckerCPU_a5e9cfc754c9ef9b7db875ce89871944e}{pcState} (const TheISA::PCState \&val)
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classCheckerCPU_a53c92716db281ae16ffb693c6d7803c7}{instAddr} ()
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classCheckerCPU_aceec6e28772f91b3cc921c0e3927b0c2}{nextInstAddr} ()
\item 
\hyperlink{base_2types_8hh_adfb4d8b20c5abc8be73dd367b16f2d57}{MicroPC} \hyperlink{classCheckerCPU_a1a21696f33a7d38f251687ae0b5e9718}{microPC} ()
\item 
\hyperlink{classCheckerCPU_aaf5f073a387db0556d1db4bcc45428bc}{MiscReg} \hyperlink{classCheckerCPU_a7b5ac6af9c2c19d7c1b442b8a3aebbc6}{readMiscRegNoEffect} (int misc\_\-reg)
\item 
\hyperlink{classCheckerCPU_aaf5f073a387db0556d1db4bcc45428bc}{MiscReg} \hyperlink{classCheckerCPU_a5a8c6c487e8da143d26188258b04f1cc}{readMiscReg} (int misc\_\-reg)
\item 
void \hyperlink{classCheckerCPU_a763517aaea2f3decbc1ef9d064216b6f}{setMiscRegNoEffect} (int misc\_\-reg, const \hyperlink{classCheckerCPU_aaf5f073a387db0556d1db4bcc45428bc}{MiscReg} \&val)
\item 
void \hyperlink{classCheckerCPU_a1877dde4f3eb17a8b7d33ea40176c148}{setMiscReg} (int misc\_\-reg, const \hyperlink{classCheckerCPU_aaf5f073a387db0556d1db4bcc45428bc}{MiscReg} \&val)
\item 
\hyperlink{classCheckerCPU_aaf5f073a387db0556d1db4bcc45428bc}{MiscReg} \hyperlink{classCheckerCPU_ac6d0dc1a63cede82f4242d43236a98db}{readMiscRegOperand} (const \hyperlink{classStaticInst}{StaticInst} $\ast$si, int idx)
\item 
void \hyperlink{classCheckerCPU_a6cfad8f780bab7feb893941cb0d46160}{setMiscRegOperand} (const \hyperlink{classStaticInst}{StaticInst} $\ast$si, int idx, const \hyperlink{classCheckerCPU_aaf5f073a387db0556d1db4bcc45428bc}{MiscReg} \&val)
\item 
uint64\_\-t \hyperlink{classCheckerCPU_a77cf978e7a92e33083fcc62cb7ead74d}{readRegOtherThread} (int misc\_\-reg)
\item 
void \hyperlink{classCheckerCPU_af05ac53fdafd8a612ca89f90b0c12910}{setRegOtherThread} (int misc\_\-reg, const TheISA::MiscReg \&val)
\item 
void \hyperlink{classCheckerCPU_a24cf06d21848d1a0b10efd6f1571d729}{recordPCChange} (const TheISA::PCState \&val)
\item 
void \hyperlink{classCheckerCPU_a2d698ff909513b48a1263f8a5440e067}{demapPage} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vaddr, uint64\_\-t asn)
\item 
void \hyperlink{classCheckerCPU_ac8a36d45a839b07f50b73f1eee119615}{demapInstPage} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vaddr, uint64\_\-t asn)
\item 
void \hyperlink{classCheckerCPU_a26789603cc94992d18f8ddedfff96acf}{demapDataPage} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vaddr, uint64\_\-t asn)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classCheckerCPU_a66191b2d8a45050b7df3c3efa7bb07c6}{readMem} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, uint8\_\-t $\ast$data, unsigned size, unsigned flags)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classCheckerCPU_ad46c5edeb1ee9b60445f3e26364e2c5e}{writeMem} (uint8\_\-t $\ast$data, unsigned size, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, unsigned flags, uint64\_\-t $\ast$res)
\item 
void \hyperlink{classCheckerCPU_abbe779fa43c72cd485ddb736ab17ff61}{setStCondFailures} (unsigned sc\_\-failures)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classCheckerCPU_a5f42e07ae335dff417664e91518c7f1e}{hwrei} ()
\item 
bool \hyperlink{classCheckerCPU_a461205960be9d52e9beda48a77e9c600}{simPalCheck} (int palFunc)
\item 
void \hyperlink{classCheckerCPU_ae674290a26ecbd622c5160e38e8a4fe9}{wakeup} ()
\item 
void \hyperlink{classCheckerCPU_a3ef5bd684f938b4a925d4a9e7e1d4f94}{syscall} (uint64\_\-t callnum)
\item 
void \hyperlink{classCheckerCPU_a70b275e63748ddd6da7d2171c540ccff}{handleError} ()
\item 
bool \hyperlink{classCheckerCPU_ab6e89553924f128af246935e240b11a4}{checkFlags} (\hyperlink{classRequest}{Request} $\ast$unverified\_\-req, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vAddr, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} pAddr, int flags)
\item 
void \hyperlink{classCheckerCPU_a516e77319e399949d9137957cd9970d0}{dumpAndExit} ()
\item 
\hyperlink{classThreadContext}{ThreadContext} $\ast$ \hyperlink{classCheckerCPU_ad33756f3e96ee445dca8d69b1dd8709c}{tcBase} ()
\item 
\hyperlink{classSimpleThread}{SimpleThread} $\ast$ \hyperlink{classCheckerCPU_aed48fbbf4ee8e6fbb3ea13b1bbc23e2d}{threadBase} ()
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSimpleThread}{SimpleThread} $\ast$ \hyperlink{classCheckerCPU_af9572fa907cd21b54cb14bd626010d39}{thread}
\item 
\hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classCheckerCPU_a9c78b70028e5df92b15a6fd9c56e5acf}{numLoad}
\item 
\hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classCheckerCPU_abc2dac603f413be8cd5f63b5c0b2d48d}{startNumLoad}
\item 
\hyperlink{unionCheckerCPU_1_1Result}{Result} \hyperlink{classCheckerCPU_ae44d4afdef854be5de937985e00e162c}{unverifiedResult}
\item 
\hyperlink{classRequest}{Request} $\ast$ \hyperlink{classCheckerCPU_a398733bcf03e60981cf4b3cc79f339cb}{unverifiedReq}
\item 
uint8\_\-t $\ast$ \hyperlink{classCheckerCPU_a6840f1942d66e27328010652fcc83cc4}{unverifiedMemData}
\item 
bool \hyperlink{classCheckerCPU_ab07cf1e394193718234cec904fc62402}{changedPC}
\item 
bool \hyperlink{classCheckerCPU_a4f3f7f9c8e8331d34afcddc9d9cf1db7}{willChangePC}
\item 
TheISA::PCState \hyperlink{classCheckerCPU_a0881ee85f2e8edfb21d616268ddbc181}{newPCState}
\item 
bool \hyperlink{classCheckerCPU_a69729b3e0649fedb790e5fa822712b63}{exitOnError}
\item 
bool \hyperlink{classCheckerCPU_a5c4b1a378d5b47717f50008b307ed1fb}{updateOnError}
\item 
bool \hyperlink{classCheckerCPU_af590e28bcadd292986518887f8ba3498}{warnOnlyOnLoadError}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classCheckerCPU_a258f3535e74a3e37e7c1afe9611266d2}{youngestSN}
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
typedef TheISA::MachInst \hyperlink{classCheckerCPU_a4617f528417b8f55f809ae0988284c9b}{MachInst}
\item 
typedef TheISA::FloatReg \hyperlink{classCheckerCPU_a75484259f1855aabc8d74c6eb1cfe186}{FloatReg}
\item 
typedef TheISA::FloatRegBits \hyperlink{classCheckerCPU_aab5eeae86499f9bfe15ef79360eccc64}{FloatRegBits}
\item 
typedef TheISA::MiscReg \hyperlink{classCheckerCPU_aaf5f073a387db0556d1db4bcc45428bc}{MiscReg}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classCheckerCPU_a7e2d118d430dcbebd896ba39811ef03b}{dbg\_\-vtophys} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{request_8hh_ac366b729262fd8e7cbd3283da6f775cf}{MasterID} \hyperlink{classCheckerCPU_a96ec6a422ac492d05f8b3edc5b58532b}{masterId}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classProcess}{Process} $\ast$ $>$ \hyperlink{classCheckerCPU_a9b2cb3a230c37a5bb09eca1375e1a5bf}{workload}
\item 
\hyperlink{classSystem}{System} $\ast$ \hyperlink{classCheckerCPU_a200e57ff6183b27a87839eda56674e28}{systemPtr}
\item 
\hyperlink{classMasterPort}{MasterPort} $\ast$ \hyperlink{classCheckerCPU_ad3e6f54baa0db8d477f7d4fe986dbc3c}{icachePort}
\item 
\hyperlink{classMasterPort}{MasterPort} $\ast$ \hyperlink{classCheckerCPU_a2bbddd281625b8b4d716708925673445}{dcachePort}
\item 
\hyperlink{classThreadContext}{ThreadContext} $\ast$ \hyperlink{classCheckerCPU_a4455a4759e69e5ebe68ae7298cbcc37d}{tc}
\item 
TheISA::TLB $\ast$ \hyperlink{classCheckerCPU_abcb37ddc11515555d8484702697bc4bb}{itb}
\item 
TheISA::TLB $\ast$ \hyperlink{classCheckerCPU_ad2fd039621f87592c4b344d4f8948e78}{dtb}
\begin{DoxyCompactList}\small\item\em choose inline that I chose dtb,itb is Data and Instructino TLB. \item\end{DoxyCompactList}\item 
std::queue$<$ \hyperlink{unionCheckerCPU_1_1Result}{Result} $>$ \hyperlink{classCheckerCPU_a54109cef8003daf3b366cc9890001d80}{result}
\item 
\hyperlink{classRequest}{RequestPtr} \hyperlink{classCheckerCPU_a5520eb2f7c2cf4b0e109d6ffd6d2d053}{memReq}
\item 
\hyperlink{classRefCountingPtr}{StaticInstPtr} \hyperlink{classCheckerCPU_abd80e0d70258dae9a743c9930a385163}{curStaticInst}
\item 
\hyperlink{classRefCountingPtr}{StaticInstPtr} \hyperlink{classCheckerCPU_a52d6d2514fb5ccecad4788d57738f544}{curMacroStaticInst}
\item 
\hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classCheckerCPU_a1431f3f73435dd9b1c68e7e3a303ada0}{numInst}
\item 
\hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classCheckerCPU_add074e8bdc5b62781b8ef02d666dc6b1}{startNumInst}
\item 
std::queue$<$ int $>$ \hyperlink{classCheckerCPU_a7abed4832bdda0e4a4770ac6946d9e24}{miscRegIdxs}
\end{DoxyCompactItemize}


\subsection{説明}
\hyperlink{classCheckerCPU}{CheckerCPU} class. Dynamically verifies instructions as they are completed by making sure that the instruction and its results match the independent execution of the benchmark inside the checker. The checker verifies instructions in order, regardless of the order in which instructions complete. There are certain results that can not be verified, specifically the result of a store conditional or the values of uncached accesses. In these cases, and with instructions marked as \char`\"{}IsUnverifiable\char`\"{}, the checker assumes that the value from the main CPU's execution is correct and simply copies that value. It provides a \hyperlink{classCheckerThreadContext}{CheckerThreadContext} (see \hyperlink{checker_2thread__context_8hh}{checker/thread\_\-context.hh}) that provides hooks for updating the Checker's state through any \hyperlink{classThreadContext}{ThreadContext} accesses. This allows the checker to be able to correctly verify instructions, even with external accesses to the \hyperlink{classThreadContext}{ThreadContext} that change state. 

\subsection{型定義}
\hypertarget{classCheckerCPU_a75484259f1855aabc8d74c6eb1cfe186}{
\index{CheckerCPU@{CheckerCPU}!FloatReg@{FloatReg}}
\index{FloatReg@{FloatReg}!CheckerCPU@{CheckerCPU}}
\subsubsection[{FloatReg}]{\setlength{\rightskip}{0pt plus 5cm}typedef TheISA::FloatReg {\bf FloatReg}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_a75484259f1855aabc8d74c6eb1cfe186}
\hypertarget{classCheckerCPU_aab5eeae86499f9bfe15ef79360eccc64}{
\index{CheckerCPU@{CheckerCPU}!FloatRegBits@{FloatRegBits}}
\index{FloatRegBits@{FloatRegBits}!CheckerCPU@{CheckerCPU}}
\subsubsection[{FloatRegBits}]{\setlength{\rightskip}{0pt plus 5cm}typedef TheISA::FloatRegBits {\bf FloatRegBits}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_aab5eeae86499f9bfe15ef79360eccc64}
\hypertarget{classCheckerCPU_a4617f528417b8f55f809ae0988284c9b}{
\index{CheckerCPU@{CheckerCPU}!MachInst@{MachInst}}
\index{MachInst@{MachInst}!CheckerCPU@{CheckerCPU}}
\subsubsection[{MachInst}]{\setlength{\rightskip}{0pt plus 5cm}typedef TheISA::MachInst {\bf MachInst}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_a4617f528417b8f55f809ae0988284c9b}
\hypertarget{classCheckerCPU_aaf5f073a387db0556d1db4bcc45428bc}{
\index{CheckerCPU@{CheckerCPU}!MiscReg@{MiscReg}}
\index{MiscReg@{MiscReg}!CheckerCPU@{CheckerCPU}}
\subsubsection[{MiscReg}]{\setlength{\rightskip}{0pt plus 5cm}typedef TheISA::MiscReg {\bf MiscReg}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_aaf5f073a387db0556d1db4bcc45428bc}
\hypertarget{classCheckerCPU_a56bf98a1e02b979e88cbf64420995961}{
\index{CheckerCPU@{CheckerCPU}!Params@{Params}}
\index{Params@{Params}!CheckerCPU@{CheckerCPU}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef CheckerCPUParams {\bf Params}}}
\label{classCheckerCPU_a56bf98a1e02b979e88cbf64420995961}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classCheckerCPU_a35dbdd3a266a1df157875f0f7c5b5f66}{
\index{CheckerCPU@{CheckerCPU}!CheckerCPU@{CheckerCPU}}
\index{CheckerCPU@{CheckerCPU}!CheckerCPU@{CheckerCPU}}
\subsubsection[{CheckerCPU}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CheckerCPU} ({\bf Params} $\ast$ {\em p})}}
\label{classCheckerCPU_a35dbdd3a266a1df157875f0f7c5b5f66}



\begin{DoxyCode}
68     : BaseCPU(p, true), systemPtr(NULL), icachePort(NULL), dcachePort(NULL),
69       tc(NULL), thread(NULL)
70 {
71     memReq = NULL;
72     curStaticInst = NULL;
73     curMacroStaticInst = NULL;
74 
75     numInst = 0;
76     startNumInst = 0;
77     numLoad = 0;
78     startNumLoad = 0;
79     youngestSN = 0;
80 
81     changedPC = willChangePC = false;
82 
83     exitOnError = p->exitOnError;
84     warnOnlyOnLoadError = p->warnOnlyOnLoadError;
85     itb = p->itb;
86     dtb = p->dtb;
87     workload = p->workload;
88 
89     updateOnError = true;
90 }
\end{DoxyCode}
\hypertarget{classCheckerCPU_ac259e064f2f0d74835ec2b38dd175ef4}{
\index{CheckerCPU@{CheckerCPU}!$\sim$CheckerCPU@{$\sim$CheckerCPU}}
\index{$\sim$CheckerCPU@{$\sim$CheckerCPU}!CheckerCPU@{CheckerCPU}}
\subsubsection[{$\sim$CheckerCPU}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf CheckerCPU} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCheckerCPU_ac259e064f2f0d74835ec2b38dd175ef4}



\begin{DoxyCode}
93 {
94 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classCheckerCPU_ab6e89553924f128af246935e240b11a4}{
\index{CheckerCPU@{CheckerCPU}!checkFlags@{checkFlags}}
\index{checkFlags@{checkFlags}!CheckerCPU@{CheckerCPU}}
\subsubsection[{checkFlags}]{\setlength{\rightskip}{0pt plus 5cm}bool checkFlags ({\bf Request} $\ast$ {\em unverified\_\-req}, \/  {\bf Addr} {\em vAddr}, \/  {\bf Addr} {\em pAddr}, \/  int {\em flags})}}
\label{classCheckerCPU_ab6e89553924f128af246935e240b11a4}
Checks if the flags set by the \hyperlink{classChecker}{Checker} and Checkee match. 


\begin{DoxyCode}
333 {
334     Addr unverifiedVAddr = unverified_req->getVaddr();
335     Addr unverifiedPAddr = unverified_req->getPaddr();
336     int unverifiedFlags = unverified_req->getFlags();
337 
338     if (unverifiedVAddr != vAddr ||
339         unverifiedPAddr != pAddr ||
340         unverifiedFlags != flags) {
341         return false;
342     }
343 
344     return true;
345 }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a7e2d118d430dcbebd896ba39811ef03b}{
\index{CheckerCPU@{CheckerCPU}!dbg\_\-vtophys@{dbg\_\-vtophys}}
\index{dbg\_\-vtophys@{dbg\_\-vtophys}!CheckerCPU@{CheckerCPU}}
\subsubsection[{dbg\_\-vtophys}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} dbg\_\-vtophys ({\bf Addr} {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_a7e2d118d430dcbebd896ba39811ef03b}



\begin{DoxyCode}
323 {
324     return vtophys(tc, addr);
325 }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a26789603cc94992d18f8ddedfff96acf}{
\index{CheckerCPU@{CheckerCPU}!demapDataPage@{demapDataPage}}
\index{demapDataPage@{demapDataPage}!CheckerCPU@{CheckerCPU}}
\subsubsection[{demapDataPage}]{\setlength{\rightskip}{0pt plus 5cm}void demapDataPage ({\bf Addr} {\em vaddr}, \/  uint64\_\-t {\em asn})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a26789603cc94992d18f8ddedfff96acf}



\begin{DoxyCode}
357     {
358         this->dtb->demapPage(vaddr, asn);
359     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_ac8a36d45a839b07f50b73f1eee119615}{
\index{CheckerCPU@{CheckerCPU}!demapInstPage@{demapInstPage}}
\index{demapInstPage@{demapInstPage}!CheckerCPU@{CheckerCPU}}
\subsubsection[{demapInstPage}]{\setlength{\rightskip}{0pt plus 5cm}void demapInstPage ({\bf Addr} {\em vaddr}, \/  uint64\_\-t {\em asn})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_ac8a36d45a839b07f50b73f1eee119615}



\begin{DoxyCode}
352     {
353         this->itb->demapPage(vaddr, asn);
354     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a2d698ff909513b48a1263f8a5440e067}{
\index{CheckerCPU@{CheckerCPU}!demapPage@{demapPage}}
\index{demapPage@{demapPage}!CheckerCPU@{CheckerCPU}}
\subsubsection[{demapPage}]{\setlength{\rightskip}{0pt plus 5cm}void demapPage ({\bf Addr} {\em vaddr}, \/  uint64\_\-t {\em asn})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a2d698ff909513b48a1263f8a5440e067}



\begin{DoxyCode}
346     {
347         this->itb->demapPage(vaddr, asn);
348         this->dtb->demapPage(vaddr, asn);
349     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a516e77319e399949d9137957cd9970d0}{
\index{CheckerCPU@{CheckerCPU}!dumpAndExit@{dumpAndExit}}
\index{dumpAndExit@{dumpAndExit}!CheckerCPU@{CheckerCPU}}
\subsubsection[{dumpAndExit}]{\setlength{\rightskip}{0pt plus 5cm}void dumpAndExit ()}}
\label{classCheckerCPU_a516e77319e399949d9137957cd9970d0}



\begin{DoxyCode}
349 {
350     warn("%lli: Checker PC:%s",
351          curTick(), thread->pcState());
352     panic("Checker found an error!");
353 }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a041a57fcad534c1bed3702a0f8f3a6b1}{
\index{CheckerCPU@{CheckerCPU}!getDataPort@{getDataPort}}
\index{getDataPort@{getDataPort}!CheckerCPU@{CheckerCPU}}
\subsubsection[{getDataPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterPort}\& getDataPort ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a041a57fcad534c1bed3702a0f8f3a6b1}



\begin{DoxyCode}
113     {
114         // the checker does not have ports on its own so return the
115         // data port of the actual CPU core
116         assert(dcachePort);
117         return *dcachePort;
118     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a2fe6a07c44bc2a4d83b86bea605ba971}{
\index{CheckerCPU@{CheckerCPU}!getDTBPtr@{getDTBPtr}}
\index{getDTBPtr@{getDTBPtr}!CheckerCPU@{CheckerCPU}}
\subsubsection[{getDTBPtr}]{\setlength{\rightskip}{0pt plus 5cm}TheISA::TLB$\ast$ getDTBPtr ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a2fe6a07c44bc2a4d83b86bea605ba971}



\begin{DoxyCode}
175 { return dtb; }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a840be0f7fe0a7a50b37b0552fe6ca506}{
\index{CheckerCPU@{CheckerCPU}!getEA@{getEA}}
\index{getEA@{getEA}!CheckerCPU@{CheckerCPU}}
\subsubsection[{getEA}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} getEA ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a840be0f7fe0a7a50b37b0552fe6ca506}



\begin{DoxyCode}
197 { panic("SimpleCPU::getEA() not implemented\n"); }
\end{DoxyCode}
\hypertarget{classCheckerCPU_ab8ce6baf7cb0aaaf4ca346896a86fa03}{
\index{CheckerCPU@{CheckerCPU}!getInstPort@{getInstPort}}
\index{getInstPort@{getInstPort}!CheckerCPU@{CheckerCPU}}
\subsubsection[{getInstPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterPort}\& getInstPort ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_ab8ce6baf7cb0aaaf4ca346896a86fa03}



\begin{DoxyCode}
121     {
122         // the checker does not have ports on its own so return the
123         // data port of the actual CPU core
124         assert(icachePort);
125         return *icachePort;
126     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a95b7e95d0558cd03d69613142fff9137}{
\index{CheckerCPU@{CheckerCPU}!getITBPtr@{getITBPtr}}
\index{getITBPtr@{getITBPtr}!CheckerCPU@{CheckerCPU}}
\subsubsection[{getITBPtr}]{\setlength{\rightskip}{0pt plus 5cm}TheISA::TLB$\ast$ getITBPtr ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a95b7e95d0558cd03d69613142fff9137}



\begin{DoxyCode}
174 { return itb; }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a70b275e63748ddd6da7d2171c540ccff}{
\index{CheckerCPU@{CheckerCPU}!handleError@{handleError}}
\index{handleError@{handleError}!CheckerCPU@{CheckerCPU}}
\subsubsection[{handleError}]{\setlength{\rightskip}{0pt plus 5cm}void handleError ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a70b275e63748ddd6da7d2171c540ccff}



\begin{DoxyCode}
377     {
378         if (exitOnError)
379             dumpAndExit();
380     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a5f42e07ae335dff417664e91518c7f1e}{
\index{CheckerCPU@{CheckerCPU}!hwrei@{hwrei}}
\index{hwrei@{hwrei}!CheckerCPU@{CheckerCPU}}
\subsubsection[{hwrei}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} hwrei ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a5f42e07ae335dff417664e91518c7f1e}



\begin{DoxyCode}
369 { return thread->hwrei(); }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{CheckerCPU@{CheckerCPU}!init@{init}}
\index{init@{init}!CheckerCPU@{CheckerCPU}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCheckerCPU_a02fd73d861ef2e4aabb38c0c9ff82947}



\begin{DoxyCode}
63 {
64     masterId = systemPtr->getMasterId(name());
65 }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a53c92716db281ae16ffb693c6d7803c7}{
\index{CheckerCPU@{CheckerCPU}!instAddr@{instAddr}}
\index{instAddr@{instAddr}!CheckerCPU@{CheckerCPU}}
\subsubsection[{instAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} instAddr ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a53c92716db281ae16ffb693c6d7803c7}



\begin{DoxyCode}
282 { return thread->instAddr(); }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a1a21696f33a7d38f251687ae0b5e9718}{
\index{CheckerCPU@{CheckerCPU}!microPC@{microPC}}
\index{microPC@{microPC}!CheckerCPU@{CheckerCPU}}
\subsubsection[{microPC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MicroPC} microPC ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a1a21696f33a7d38f251687ae0b5e9718}



\begin{DoxyCode}
284 { return thread->microPC(); }
\end{DoxyCode}
\hypertarget{classCheckerCPU_aceec6e28772f91b3cc921c0e3927b0c2}{
\index{CheckerCPU@{CheckerCPU}!nextInstAddr@{nextInstAddr}}
\index{nextInstAddr@{nextInstAddr}!CheckerCPU@{CheckerCPU}}
\subsubsection[{nextInstAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} nextInstAddr ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_aceec6e28772f91b3cc921c0e3927b0c2}



\begin{DoxyCode}
283 { return thread->nextInstAddr(); }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a5e9cfc754c9ef9b7db875ce89871944e}{
\index{CheckerCPU@{CheckerCPU}!pcState@{pcState}}
\index{pcState@{pcState}!CheckerCPU@{CheckerCPU}}
\subsubsection[{pcState}]{\setlength{\rightskip}{0pt plus 5cm}void pcState (const TheISA::PCState \& {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a5e9cfc754c9ef9b7db875ce89871944e}



\begin{DoxyCode}
277     {
278         DPRINTF(Checker, "Changing PC to %s, old PC %s.\n",
279                          val, thread->pcState());
280         thread->pcState(val);
281     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a827fb3454585cf4c620f4fd341966317}{
\index{CheckerCPU@{CheckerCPU}!pcState@{pcState}}
\index{pcState@{pcState}!CheckerCPU@{CheckerCPU}}
\subsubsection[{pcState}]{\setlength{\rightskip}{0pt plus 5cm}TheISA::PCState pcState ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a827fb3454585cf4c620f4fd341966317}



\begin{DoxyCode}
275 { return thread->pcState(); }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a25532f176443f0ec538a3b833c55f4a0}{
\index{CheckerCPU@{CheckerCPU}!readCCRegOperand@{readCCRegOperand}}
\index{readCCRegOperand@{readCCRegOperand}!CheckerCPU@{CheckerCPU}}
\subsubsection[{readCCRegOperand}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t readCCRegOperand (const {\bf StaticInst} $\ast$ {\em si}, \/  int {\em idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a25532f176443f0ec538a3b833c55f4a0}



\begin{DoxyCode}
228     {
229         int reg_idx = si->srcRegIdx(idx) - TheISA::CC_Reg_Base;
230         return thread->readCCReg(reg_idx);
231     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a717c88c8c56d79c9ed554ba5992bd8c3}{
\index{CheckerCPU@{CheckerCPU}!readFloatRegOperand@{readFloatRegOperand}}
\index{readFloatRegOperand@{readFloatRegOperand}!CheckerCPU@{CheckerCPU}}
\subsubsection[{readFloatRegOperand}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FloatReg} readFloatRegOperand (const {\bf StaticInst} $\ast$ {\em si}, \/  int {\em idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a717c88c8c56d79c9ed554ba5992bd8c3}



\begin{DoxyCode}
216     {
217         int reg_idx = si->srcRegIdx(idx) - TheISA::FP_Reg_Base;
218         return thread->readFloatReg(reg_idx);
219     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a39d93624e4481f4a210f2c46ea6b15b0}{
\index{CheckerCPU@{CheckerCPU}!readFloatRegOperandBits@{readFloatRegOperandBits}}
\index{readFloatRegOperandBits@{readFloatRegOperandBits}!CheckerCPU@{CheckerCPU}}
\subsubsection[{readFloatRegOperandBits}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FloatRegBits} readFloatRegOperandBits (const {\bf StaticInst} $\ast$ {\em si}, \/  int {\em idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a39d93624e4481f4a210f2c46ea6b15b0}



\begin{DoxyCode}
222     {
223         int reg_idx = si->srcRegIdx(idx) - TheISA::FP_Reg_Base;
224         return thread->readFloatRegBits(reg_idx);
225     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a9e7b0a4d5373c48902425c9456b19e7e}{
\index{CheckerCPU@{CheckerCPU}!readIntRegOperand@{readIntRegOperand}}
\index{readIntRegOperand@{readIntRegOperand}!CheckerCPU@{CheckerCPU}}
\subsubsection[{readIntRegOperand}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t readIntRegOperand (const {\bf StaticInst} $\ast$ {\em si}, \/  int {\em idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a9e7b0a4d5373c48902425c9456b19e7e}



\begin{DoxyCode}
211     {
212         return thread->readIntReg(si->srcRegIdx(idx));
213     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a66191b2d8a45050b7df3c3efa7bb07c6}{
\index{CheckerCPU@{CheckerCPU}!readMem@{readMem}}
\index{readMem@{readMem}!CheckerCPU@{CheckerCPU}}
\subsubsection[{readMem}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} readMem ({\bf Addr} {\em addr}, \/  uint8\_\-t $\ast$ {\em data}, \/  unsigned {\em size}, \/  unsigned {\em flags})}}
\label{classCheckerCPU_a66191b2d8a45050b7df3c3efa7bb07c6}



\begin{DoxyCode}
143 {
144     Fault fault = NoFault;
145     int fullSize = size;
146     Addr secondAddr = roundDown(addr + size - 1, cacheLineSize());
147     bool checked_flags = false;
148     bool flags_match = true;
149     Addr pAddr = 0x0;
150 
151 
152     if (secondAddr > addr)
153        size = secondAddr - addr;
154 
155     // Need to account for multiple accesses like the Atomic and TimingSimple
156     while (1) {
157         memReq = new Request();
158         memReq->setVirt(0, addr, size, flags, masterId, thread->pcState().instAdd
      r());
159 
160         // translate to physical address
161         fault = dtb->translateFunctional(memReq, tc, BaseTLB::Read);
162 
163         if (!checked_flags && fault == NoFault && unverifiedReq) {
164             flags_match = checkFlags(unverifiedReq, memReq->getVaddr(),
165                                      memReq->getPaddr(), memReq->getFlags());
166             pAddr = memReq->getPaddr();
167             checked_flags = true;
168         }
169 
170         // Now do the access
171         if (fault == NoFault &&
172             !memReq->getFlags().isSet(Request::NO_ACCESS)) {
173             PacketPtr pkt = new Packet(memReq,
174                                        memReq->isLLSC() ?
175                                        MemCmd::LoadLockedReq :
176                                        MemCmd::ReadReq);
177 
178             pkt->dataStatic(data);
179 
180             if (!(memReq->isUncacheable() || memReq->isMmappedIpr())) {
181                 // Access memory to see if we have the same data
182                 dcachePort->sendFunctional(pkt);
183             } else {
184                 // Assume the data is correct if it's an uncached access
185                 memcpy(data, unverifiedMemData, size);
186             }
187 
188             delete memReq;
189             memReq = NULL;
190             delete pkt;
191         }
192 
193         if (fault != NoFault) {
194             if (memReq->isPrefetch()) {
195                 fault = NoFault;
196             }
197             delete memReq;
198             memReq = NULL;
199             break;
200         }
201 
202         if (memReq != NULL) {
203             delete memReq;
204         }
205 
206         //If we don't need to access a second cache line, stop now.
207         if (secondAddr <= addr)
208         {
209             break;
210         }
211 
212         // Setup for accessing next cache line
213         data += size;
214         unverifiedMemData += size;
215         size = addr + fullSize - secondAddr;
216         addr = secondAddr;
217     }
218 
219     if (!flags_match) {
220         warn("%lli: Flags do not match CPU:%#x %#x %#x Checker:%#x %#x %#x\n",
221              curTick(), unverifiedReq->getVaddr(), unverifiedReq->getPaddr(),
222              unverifiedReq->getFlags(), addr, pAddr, flags);
223         handleError();
224     }
225 
226     return fault;
227 }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a5a8c6c487e8da143d26188258b04f1cc}{
\index{CheckerCPU@{CheckerCPU}!readMiscReg@{readMiscReg}}
\index{readMiscReg@{readMiscReg}!CheckerCPU@{CheckerCPU}}
\subsubsection[{readMiscReg}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MiscReg} readMiscReg (int {\em misc\_\-reg})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a5a8c6c487e8da143d26188258b04f1cc}



\begin{DoxyCode}
293     {
294         return thread->readMiscReg(misc_reg);
295     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a7b5ac6af9c2c19d7c1b442b8a3aebbc6}{
\index{CheckerCPU@{CheckerCPU}!readMiscRegNoEffect@{readMiscRegNoEffect}}
\index{readMiscRegNoEffect@{readMiscRegNoEffect}!CheckerCPU@{CheckerCPU}}
\subsubsection[{readMiscRegNoEffect}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MiscReg} readMiscRegNoEffect (int {\em misc\_\-reg})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a7b5ac6af9c2c19d7c1b442b8a3aebbc6}



\begin{DoxyCode}
288     {
289         return thread->readMiscRegNoEffect(misc_reg);
290     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_ac6d0dc1a63cede82f4242d43236a98db}{
\index{CheckerCPU@{CheckerCPU}!readMiscRegOperand@{readMiscRegOperand}}
\index{readMiscRegOperand@{readMiscRegOperand}!CheckerCPU@{CheckerCPU}}
\subsubsection[{readMiscRegOperand}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MiscReg} readMiscRegOperand (const {\bf StaticInst} $\ast$ {\em si}, \/  int {\em idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_ac6d0dc1a63cede82f4242d43236a98db}



\begin{DoxyCode}
312     {
313         int reg_idx = si->srcRegIdx(idx) - TheISA::Misc_Reg_Base;
314         return thread->readMiscReg(reg_idx);
315     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a254cecc48d457ea298b08a8bb009f9cf}{
\index{CheckerCPU@{CheckerCPU}!readPredicate@{readPredicate}}
\index{readPredicate@{readPredicate}!CheckerCPU@{CheckerCPU}}
\subsubsection[{readPredicate}]{\setlength{\rightskip}{0pt plus 5cm}bool readPredicate ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a254cecc48d457ea298b08a8bb009f9cf}



\begin{DoxyCode}
269 { return thread->readPredicate(); }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a77cf978e7a92e33083fcc62cb7ead74d}{
\index{CheckerCPU@{CheckerCPU}!readRegOtherThread@{readRegOtherThread}}
\index{readRegOtherThread@{readRegOtherThread}!CheckerCPU@{CheckerCPU}}
\subsubsection[{readRegOtherThread}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t readRegOtherThread (int {\em misc\_\-reg})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a77cf978e7a92e33083fcc62cb7ead74d}



\begin{DoxyCode}
326     {
327         panic("MIPS MT not defined for CheckerCPU.\n");
328         return 0;
329     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a24cf06d21848d1a0b10efd6f1571d729}{
\index{CheckerCPU@{CheckerCPU}!recordPCChange@{recordPCChange}}
\index{recordPCChange@{recordPCChange}!CheckerCPU@{CheckerCPU}}
\subsubsection[{recordPCChange}]{\setlength{\rightskip}{0pt plus 5cm}void recordPCChange (const TheISA::PCState \& {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a24cf06d21848d1a0b10efd6f1571d729}



\begin{DoxyCode}
340     {
341        changedPC = true;
342        newPCState = val;
343     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_ad6272f80ae37e8331e3969b3f072a801}{
\index{CheckerCPU@{CheckerCPU}!serialize@{serialize}}
\index{serialize@{serialize}!CheckerCPU@{CheckerCPU}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}virtual void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCheckerCPU_ad6272f80ae37e8331e3969b3f072a801}
\hypertarget{classCheckerCPU_afeb2b876cf6b29215cf9d6d56ba8863b}{
\index{CheckerCPU@{CheckerCPU}!setCCRegOperand@{setCCRegOperand}}
\index{setCCRegOperand@{setCCRegOperand}!CheckerCPU@{CheckerCPU}}
\subsubsection[{setCCRegOperand}]{\setlength{\rightskip}{0pt plus 5cm}void setCCRegOperand (const {\bf StaticInst} $\ast$ {\em si}, \/  int {\em idx}, \/  uint64\_\-t {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_afeb2b876cf6b29215cf9d6d56ba8863b}



\begin{DoxyCode}
263     {
264         int reg_idx = si->destRegIdx(idx) - TheISA::CC_Reg_Base;
265         thread->setCCReg(reg_idx, val);
266         setResult<uint64_t>(val);
267     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a8d77cc755c7a424f4eb80130fb627012}{
\index{CheckerCPU@{CheckerCPU}!setDcachePort@{setDcachePort}}
\index{setDcachePort@{setDcachePort}!CheckerCPU@{CheckerCPU}}
\subsubsection[{setDcachePort}]{\setlength{\rightskip}{0pt plus 5cm}void setDcachePort ({\bf MasterPort} $\ast$ {\em dcache\_\-port})}}
\label{classCheckerCPU_a8d77cc755c7a424f4eb80130fb627012}



\begin{DoxyCode}
127 {
128     dcachePort = dcache_port;
129 }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a2f9742f8d2bcf6a31ebfc121fd9d5fbc}{
\index{CheckerCPU@{CheckerCPU}!setEA@{setEA}}
\index{setEA@{setEA}!CheckerCPU@{CheckerCPU}}
\subsubsection[{setEA}]{\setlength{\rightskip}{0pt plus 5cm}void setEA ({\bf Addr} {\em EA})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a2f9742f8d2bcf6a31ebfc121fd9d5fbc}



\begin{DoxyCode}
196 { panic("SimpleCPU::setEA() not implemented\n"); }
\end{DoxyCode}
\hypertarget{classCheckerCPU_addc8b4b6511725bf8ff48bd09ef22892}{
\index{CheckerCPU@{CheckerCPU}!setFloatRegOperand@{setFloatRegOperand}}
\index{setFloatRegOperand@{setFloatRegOperand}!CheckerCPU@{CheckerCPU}}
\subsubsection[{setFloatRegOperand}]{\setlength{\rightskip}{0pt plus 5cm}void setFloatRegOperand (const {\bf StaticInst} $\ast$ {\em si}, \/  int {\em idx}, \/  {\bf FloatReg} {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_addc8b4b6511725bf8ff48bd09ef22892}



\begin{DoxyCode}
248     {
249         int reg_idx = si->destRegIdx(idx) - TheISA::FP_Reg_Base;
250         thread->setFloatReg(reg_idx, val);
251         setResult<double>(val);
252     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a80a516966713c873cf964af7538dbd37}{
\index{CheckerCPU@{CheckerCPU}!setFloatRegOperandBits@{setFloatRegOperandBits}}
\index{setFloatRegOperandBits@{setFloatRegOperandBits}!CheckerCPU@{CheckerCPU}}
\subsubsection[{setFloatRegOperandBits}]{\setlength{\rightskip}{0pt plus 5cm}void setFloatRegOperandBits (const {\bf StaticInst} $\ast$ {\em si}, \/  int {\em idx}, \/  {\bf FloatRegBits} {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a80a516966713c873cf964af7538dbd37}



\begin{DoxyCode}
256     {
257         int reg_idx = si->destRegIdx(idx) - TheISA::FP_Reg_Base;
258         thread->setFloatRegBits(reg_idx, val);
259         setResult<uint64_t>(val);
260     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a925d02a64d6c947d4ba3bb96bef728ff}{
\index{CheckerCPU@{CheckerCPU}!setIcachePort@{setIcachePort}}
\index{setIcachePort@{setIcachePort}!CheckerCPU@{CheckerCPU}}
\subsubsection[{setIcachePort}]{\setlength{\rightskip}{0pt plus 5cm}void setIcachePort ({\bf MasterPort} $\ast$ {\em icache\_\-port})}}
\label{classCheckerCPU_a925d02a64d6c947d4ba3bb96bef728ff}



\begin{DoxyCode}
121 {
122     icachePort = icache_port;
123 }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a654e99f2be7cd298378462ce9651bb44}{
\index{CheckerCPU@{CheckerCPU}!setIntRegOperand@{setIntRegOperand}}
\index{setIntRegOperand@{setIntRegOperand}!CheckerCPU@{CheckerCPU}}
\subsubsection[{setIntRegOperand}]{\setlength{\rightskip}{0pt plus 5cm}void setIntRegOperand (const {\bf StaticInst} $\ast$ {\em si}, \/  int {\em idx}, \/  uint64\_\-t {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a654e99f2be7cd298378462ce9651bb44}



\begin{DoxyCode}
242     {
243         thread->setIntReg(si->destRegIdx(idx), val);
244         setResult<uint64_t>(val);
245     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a1877dde4f3eb17a8b7d33ea40176c148}{
\index{CheckerCPU@{CheckerCPU}!setMiscReg@{setMiscReg}}
\index{setMiscReg@{setMiscReg}!CheckerCPU@{CheckerCPU}}
\subsubsection[{setMiscReg}]{\setlength{\rightskip}{0pt plus 5cm}void setMiscReg (int {\em misc\_\-reg}, \/  const {\bf MiscReg} \& {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a1877dde4f3eb17a8b7d33ea40176c148}



\begin{DoxyCode}
305     {
306         DPRINTF(Checker, "Setting misc reg %d with effect to check later\n", misc
      _reg);
307         miscRegIdxs.push(misc_reg);
308         return thread->setMiscReg(misc_reg, val);
309     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a763517aaea2f3decbc1ef9d064216b6f}{
\index{CheckerCPU@{CheckerCPU}!setMiscRegNoEffect@{setMiscRegNoEffect}}
\index{setMiscRegNoEffect@{setMiscRegNoEffect}!CheckerCPU@{CheckerCPU}}
\subsubsection[{setMiscRegNoEffect}]{\setlength{\rightskip}{0pt plus 5cm}void setMiscRegNoEffect (int {\em misc\_\-reg}, \/  const {\bf MiscReg} \& {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a763517aaea2f3decbc1ef9d064216b6f}



\begin{DoxyCode}
298     {
299         DPRINTF(Checker, "Setting misc reg %d with no effect to check later\n", m
      isc_reg);
300         miscRegIdxs.push(misc_reg);
301         return thread->setMiscRegNoEffect(misc_reg, val);
302     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a6cfad8f780bab7feb893941cb0d46160}{
\index{CheckerCPU@{CheckerCPU}!setMiscRegOperand@{setMiscRegOperand}}
\index{setMiscRegOperand@{setMiscRegOperand}!CheckerCPU@{CheckerCPU}}
\subsubsection[{setMiscRegOperand}]{\setlength{\rightskip}{0pt plus 5cm}void setMiscRegOperand (const {\bf StaticInst} $\ast$ {\em si}, \/  int {\em idx}, \/  const {\bf MiscReg} \& {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a6cfad8f780bab7feb893941cb0d46160}



\begin{DoxyCode}
319     {
320         int reg_idx = si->destRegIdx(idx) - TheISA::Misc_Reg_Base;
321         return this->setMiscReg(reg_idx, val);
322     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a137a8c6cced89c2ff8387900439436b4}{
\index{CheckerCPU@{CheckerCPU}!setPredicate@{setPredicate}}
\index{setPredicate@{setPredicate}!CheckerCPU@{CheckerCPU}}
\subsubsection[{setPredicate}]{\setlength{\rightskip}{0pt plus 5cm}void setPredicate (bool {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a137a8c6cced89c2ff8387900439436b4}



\begin{DoxyCode}
271     {
272         thread->setPredicate(val);
273     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_af05ac53fdafd8a612ca89f90b0c12910}{
\index{CheckerCPU@{CheckerCPU}!setRegOtherThread@{setRegOtherThread}}
\index{setRegOtherThread@{setRegOtherThread}!CheckerCPU@{CheckerCPU}}
\subsubsection[{setRegOtherThread}]{\setlength{\rightskip}{0pt plus 5cm}void setRegOtherThread (int {\em misc\_\-reg}, \/  const TheISA::MiscReg \& {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_af05ac53fdafd8a612ca89f90b0c12910}



\begin{DoxyCode}
332     {
333         panic("MIPS MT not defined for CheckerCPU.\n");
334     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_accfdfc918ee73975e86b08cf8a528479}{
\index{CheckerCPU@{CheckerCPU}!setResult@{setResult}}
\index{setResult@{setResult}!CheckerCPU@{CheckerCPU}}
\subsubsection[{setResult}]{\setlength{\rightskip}{0pt plus 5cm}void setResult (T {\em t})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_accfdfc918ee73975e86b08cf8a528479}



\begin{DoxyCode}
235     {
236         Result instRes;
237         instRes.set(t);
238         result.push(instRes);
239     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_abbe779fa43c72cd485ddb736ab17ff61}{
\index{CheckerCPU@{CheckerCPU}!setStCondFailures@{setStCondFailures}}
\index{setStCondFailures@{setStCondFailures}!CheckerCPU@{CheckerCPU}}
\subsubsection[{setStCondFailures}]{\setlength{\rightskip}{0pt plus 5cm}void setStCondFailures (unsigned {\em sc\_\-failures})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_abbe779fa43c72cd485ddb736ab17ff61}



\begin{DoxyCode}
366     {}
\end{DoxyCode}
\hypertarget{classCheckerCPU_a87165dd3c0f61d17b5decfdd925b3fcd}{
\index{CheckerCPU@{CheckerCPU}!setSystem@{setSystem}}
\index{setSystem@{setSystem}!CheckerCPU@{CheckerCPU}}
\subsubsection[{setSystem}]{\setlength{\rightskip}{0pt plus 5cm}void setSystem ({\bf System} $\ast$ {\em system})}}
\label{classCheckerCPU_a87165dd3c0f61d17b5decfdd925b3fcd}



\begin{DoxyCode}
98 {
99     const Params *p(dynamic_cast<const Params *>(_params));
100 
101     systemPtr = system;
102 
103     if (FullSystem) {
104         thread = new SimpleThread(this, 0, systemPtr, itb, dtb,
105                                   p->isa[0], false);
106     } else {
107         thread = new SimpleThread(this, 0, systemPtr,
108                                   workload.size() ? workload[0] : NULL,
109                                   itb, dtb, p->isa[0]);
110     }
111 
112     tc = thread->getTC();
113     threadContexts.push_back(tc);
114     thread->kernelStats = NULL;
115     // Thread should never be null after this
116     assert(thread != NULL);
117 }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a461205960be9d52e9beda48a77e9c600}{
\index{CheckerCPU@{CheckerCPU}!simPalCheck@{simPalCheck}}
\index{simPalCheck@{simPalCheck}!CheckerCPU@{CheckerCPU}}
\subsubsection[{simPalCheck}]{\setlength{\rightskip}{0pt plus 5cm}bool simPalCheck (int {\em palFunc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a461205960be9d52e9beda48a77e9c600}



\begin{DoxyCode}
370 { return thread->simPalCheck(palFunc); }
\end{DoxyCode}
\hypertarget{classCheckerCPU_a3ef5bd684f938b4a925d4a9e7e1d4f94}{
\index{CheckerCPU@{CheckerCPU}!syscall@{syscall}}
\index{syscall@{syscall}!CheckerCPU@{CheckerCPU}}
\subsubsection[{syscall}]{\setlength{\rightskip}{0pt plus 5cm}void syscall (uint64\_\-t {\em callnum})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_a3ef5bd684f938b4a925d4a9e7e1d4f94}



\begin{DoxyCode}
374 { }
\end{DoxyCode}
\hypertarget{classCheckerCPU_ad33756f3e96ee445dca8d69b1dd8709c}{
\index{CheckerCPU@{CheckerCPU}!tcBase@{tcBase}}
\index{tcBase@{tcBase}!CheckerCPU@{CheckerCPU}}
\subsubsection[{tcBase}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadContext}$\ast$ tcBase ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_ad33756f3e96ee445dca8d69b1dd8709c}



\begin{DoxyCode}
387 { return tc; }
\end{DoxyCode}
\hypertarget{classCheckerCPU_aed48fbbf4ee8e6fbb3ea13b1bbc23e2d}{
\index{CheckerCPU@{CheckerCPU}!threadBase@{threadBase}}
\index{threadBase@{threadBase}!CheckerCPU@{CheckerCPU}}
\subsubsection[{threadBase}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SimpleThread}$\ast$ threadBase ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_aed48fbbf4ee8e6fbb3ea13b1bbc23e2d}



\begin{DoxyCode}
388 { return thread; }
\end{DoxyCode}
\hypertarget{classCheckerCPU_abdcc0de01ff3d8d22a40e0b966acb463}{
\index{CheckerCPU@{CheckerCPU}!totalInsts@{totalInsts}}
\index{totalInsts@{totalInsts}!CheckerCPU@{CheckerCPU}}
\subsubsection[{totalInsts}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Counter} totalInsts () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classCheckerCPU_abdcc0de01ff3d8d22a40e0b966acb463}



\begin{DoxyCode}
178     {
179         return 0;
180     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_adfb528b512cf037ade8dc8e22bf8a7bd}{
\index{CheckerCPU@{CheckerCPU}!totalOps@{totalOps}}
\index{totalOps@{totalOps}!CheckerCPU@{CheckerCPU}}
\subsubsection[{totalOps}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Counter} totalOps () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classCheckerCPU_adfb528b512cf037ade8dc8e22bf8a7bd}



\begin{DoxyCode}
183     {
184         return 0;
185     }
\end{DoxyCode}
\hypertarget{classCheckerCPU_af100c4e9feabf3cd918619c88c718387}{
\index{CheckerCPU@{CheckerCPU}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!CheckerCPU@{CheckerCPU}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}virtual void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCheckerCPU_af100c4e9feabf3cd918619c88c718387}
\hypertarget{classCheckerCPU_ae674290a26ecbd622c5160e38e8a4fe9}{
\index{CheckerCPU@{CheckerCPU}!wakeup@{wakeup}}
\index{wakeup@{wakeup}!CheckerCPU@{CheckerCPU}}
\subsubsection[{wakeup}]{\setlength{\rightskip}{0pt plus 5cm}void wakeup ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCheckerCPU_ae674290a26ecbd622c5160e38e8a4fe9}


\hyperlink{classBaseCPU_a75101f8aee74078c8c3c1d1f3617f7cc}{BaseCPU}を再定義しています。


\begin{DoxyCode}
371 { }
\end{DoxyCode}
\hypertarget{classCheckerCPU_ad46c5edeb1ee9b60445f3e26364e2c5e}{
\index{CheckerCPU@{CheckerCPU}!writeMem@{writeMem}}
\index{writeMem@{writeMem}!CheckerCPU@{CheckerCPU}}
\subsubsection[{writeMem}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} writeMem (uint8\_\-t $\ast$ {\em data}, \/  unsigned {\em size}, \/  {\bf Addr} {\em addr}, \/  unsigned {\em flags}, \/  uint64\_\-t $\ast$ {\em res})}}
\label{classCheckerCPU_ad46c5edeb1ee9b60445f3e26364e2c5e}



\begin{DoxyCode}
232 {
233     Fault fault = NoFault;
234     bool checked_flags = false;
235     bool flags_match = true;
236     Addr pAddr = 0x0;
237 
238     int fullSize = size;
239 
240     Addr secondAddr = roundDown(addr + size - 1, cacheLineSize());
241 
242     if (secondAddr > addr)
243         size = secondAddr - addr;
244 
245     // Need to account for a multiple access like Atomic and Timing CPUs
246     while (1) {
247         memReq = new Request();
248         memReq->setVirt(0, addr, size, flags, masterId, thread->pcState().instAdd
      r());
249 
250         // translate to physical address
251         fault = dtb->translateFunctional(memReq, tc, BaseTLB::Write);
252 
253         if (!checked_flags && fault == NoFault && unverifiedReq) {
254            flags_match = checkFlags(unverifiedReq, memReq->getVaddr(),
255                                     memReq->getPaddr(), memReq->getFlags());
256            pAddr = memReq->getPaddr();
257            checked_flags = true;
258         }
259 
260         /*
261          * We don't actually check memory for the store because there
262          * is no guarantee it has left the lsq yet, and therefore we
263          * can't verify the memory on stores without lsq snooping
264          * enabled.  This is left as future work for the Checker: LSQ snooping
265          * and memory validation after stores have committed.
266          */
267         bool was_prefetch = memReq->isPrefetch();
268 
269         delete memReq;
270 
271         //If we don't need to access a second cache line, stop now.
272         if (fault != NoFault || secondAddr <= addr)
273         {
274             if (fault != NoFault && was_prefetch) {
275               fault = NoFault;
276             }
277             break;
278         }
279 
280         //Update size and access address
281         size = addr + fullSize - secondAddr;
282         //And access the right address.
283         addr = secondAddr;
284    }
285 
286    if (!flags_match) {
287        warn("%lli: Flags do not match CPU:%#x %#x Checker:%#x %#x %#x\n",
288             curTick(), unverifiedReq->getVaddr(), unverifiedReq->getPaddr(),
289             unverifiedReq->getFlags(), addr, pAddr, flags);
290        handleError();
291    }
292 
293    // Assume the result was the same as the one passed in.  This checker
294    // doesn't check if the SC should succeed or fail, it just checks the
295    // value.
296    if (unverifiedReq && res && unverifiedReq->extraDataValid())
297        *res = unverifiedReq->getExtraData();
298 
299    // Entire purpose here is to make sure we are getting the
300    // same data to send to the mem system as the CPU did.
301    // Cannot check this is actually what went to memory because
302    // there stores can be in ld/st queue or coherent operations
303    // overwriting values.
304    bool extraData;
305    if (unverifiedReq) {
306        extraData = unverifiedReq->extraDataValid() ?
307                         unverifiedReq->getExtraData() : 1;
308    }
309 
310    if (unverifiedReq && unverifiedMemData &&
311        memcmp(data, unverifiedMemData, fullSize) && extraData) {
312            warn("%lli: Store value does not match value sent to memory!\
313                   data: %#x inst_data: %#x", curTick(), data,
314                   unverifiedMemData);
315        handleError();
316    }
317 
318    return fault;
319 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classCheckerCPU_ab07cf1e394193718234cec904fc62402}{
\index{CheckerCPU@{CheckerCPU}!changedPC@{changedPC}}
\index{changedPC@{changedPC}!CheckerCPU@{CheckerCPU}}
\subsubsection[{changedPC}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf changedPC}}}
\label{classCheckerCPU_ab07cf1e394193718234cec904fc62402}
\hypertarget{classCheckerCPU_a52d6d2514fb5ccecad4788d57738f544}{
\index{CheckerCPU@{CheckerCPU}!curMacroStaticInst@{curMacroStaticInst}}
\index{curMacroStaticInst@{curMacroStaticInst}!CheckerCPU@{CheckerCPU}}
\subsubsection[{curMacroStaticInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StaticInstPtr} {\bf curMacroStaticInst}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_a52d6d2514fb5ccecad4788d57738f544}
\hypertarget{classCheckerCPU_abd80e0d70258dae9a743c9930a385163}{
\index{CheckerCPU@{CheckerCPU}!curStaticInst@{curStaticInst}}
\index{curStaticInst@{curStaticInst}!CheckerCPU@{CheckerCPU}}
\subsubsection[{curStaticInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StaticInstPtr} {\bf curStaticInst}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_abd80e0d70258dae9a743c9930a385163}
\hypertarget{classCheckerCPU_a2bbddd281625b8b4d716708925673445}{
\index{CheckerCPU@{CheckerCPU}!dcachePort@{dcachePort}}
\index{dcachePort@{dcachePort}!CheckerCPU@{CheckerCPU}}
\subsubsection[{dcachePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterPort}$\ast$ {\bf dcachePort}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_a2bbddd281625b8b4d716708925673445}
\hypertarget{classCheckerCPU_ad2fd039621f87592c4b344d4f8948e78}{
\index{CheckerCPU@{CheckerCPU}!dtb@{dtb}}
\index{dtb@{dtb}!CheckerCPU@{CheckerCPU}}
\subsubsection[{dtb}]{\setlength{\rightskip}{0pt plus 5cm}TheISA::TLB$\ast$ {\bf dtb}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_ad2fd039621f87592c4b344d4f8948e78}


choose inline that I chose dtb,itb is Data and Instructino TLB. 

\hyperlink{classBaseCPU_a6be3ef152e982fb57e224c4a32a431b7}{BaseCPU}を再定義しています。\hypertarget{classCheckerCPU_a69729b3e0649fedb790e5fa822712b63}{
\index{CheckerCPU@{CheckerCPU}!exitOnError@{exitOnError}}
\index{exitOnError@{exitOnError}!CheckerCPU@{CheckerCPU}}
\subsubsection[{exitOnError}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf exitOnError}}}
\label{classCheckerCPU_a69729b3e0649fedb790e5fa822712b63}
\hypertarget{classCheckerCPU_ad3e6f54baa0db8d477f7d4fe986dbc3c}{
\index{CheckerCPU@{CheckerCPU}!icachePort@{icachePort}}
\index{icachePort@{icachePort}!CheckerCPU@{CheckerCPU}}
\subsubsection[{icachePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterPort}$\ast$ {\bf icachePort}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_ad3e6f54baa0db8d477f7d4fe986dbc3c}
\hypertarget{classCheckerCPU_abcb37ddc11515555d8484702697bc4bb}{
\index{CheckerCPU@{CheckerCPU}!itb@{itb}}
\index{itb@{itb}!CheckerCPU@{CheckerCPU}}
\subsubsection[{itb}]{\setlength{\rightskip}{0pt plus 5cm}TheISA::TLB$\ast$ {\bf itb}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_abcb37ddc11515555d8484702697bc4bb}


\hyperlink{classBaseCPU_a05093b507c1f741f2150103b12ac7056}{BaseCPU}を再定義しています。\hypertarget{classCheckerCPU_a96ec6a422ac492d05f8b3edc5b58532b}{
\index{CheckerCPU@{CheckerCPU}!masterId@{masterId}}
\index{masterId@{masterId}!CheckerCPU@{CheckerCPU}}
\subsubsection[{masterId}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterID} {\bf masterId}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_a96ec6a422ac492d05f8b3edc5b58532b}
id attached to all issued requests \hypertarget{classCheckerCPU_a5520eb2f7c2cf4b0e109d6ffd6d2d053}{
\index{CheckerCPU@{CheckerCPU}!memReq@{memReq}}
\index{memReq@{memReq}!CheckerCPU@{CheckerCPU}}
\subsubsection[{memReq}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RequestPtr} {\bf memReq}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_a5520eb2f7c2cf4b0e109d6ffd6d2d053}
\hypertarget{classCheckerCPU_a7abed4832bdda0e4a4770ac6946d9e24}{
\index{CheckerCPU@{CheckerCPU}!miscRegIdxs@{miscRegIdxs}}
\index{miscRegIdxs@{miscRegIdxs}!CheckerCPU@{CheckerCPU}}
\subsubsection[{miscRegIdxs}]{\setlength{\rightskip}{0pt plus 5cm}std::queue$<$int$>$ {\bf miscRegIdxs}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_a7abed4832bdda0e4a4770ac6946d9e24}
\hypertarget{classCheckerCPU_a0881ee85f2e8edfb21d616268ddbc181}{
\index{CheckerCPU@{CheckerCPU}!newPCState@{newPCState}}
\index{newPCState@{newPCState}!CheckerCPU@{CheckerCPU}}
\subsubsection[{newPCState}]{\setlength{\rightskip}{0pt plus 5cm}TheISA::PCState {\bf newPCState}}}
\label{classCheckerCPU_a0881ee85f2e8edfb21d616268ddbc181}
\hypertarget{classCheckerCPU_a1431f3f73435dd9b1c68e7e3a303ada0}{
\index{CheckerCPU@{CheckerCPU}!numInst@{numInst}}
\index{numInst@{numInst}!CheckerCPU@{CheckerCPU}}
\subsubsection[{numInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Counter} {\bf numInst}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_a1431f3f73435dd9b1c68e7e3a303ada0}
\hypertarget{classCheckerCPU_a9c78b70028e5df92b15a6fd9c56e5acf}{
\index{CheckerCPU@{CheckerCPU}!numLoad@{numLoad}}
\index{numLoad@{numLoad}!CheckerCPU@{CheckerCPU}}
\subsubsection[{numLoad}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Counter} {\bf numLoad}}}
\label{classCheckerCPU_a9c78b70028e5df92b15a6fd9c56e5acf}
\hypertarget{classCheckerCPU_a54109cef8003daf3b366cc9890001d80}{
\index{CheckerCPU@{CheckerCPU}!result@{result}}
\index{result@{result}!CheckerCPU@{CheckerCPU}}
\subsubsection[{result}]{\setlength{\rightskip}{0pt plus 5cm}std::queue$<${\bf Result}$>$ {\bf result}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_a54109cef8003daf3b366cc9890001d80}
\hypertarget{classCheckerCPU_add074e8bdc5b62781b8ef02d666dc6b1}{
\index{CheckerCPU@{CheckerCPU}!startNumInst@{startNumInst}}
\index{startNumInst@{startNumInst}!CheckerCPU@{CheckerCPU}}
\subsubsection[{startNumInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Counter} {\bf startNumInst}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_add074e8bdc5b62781b8ef02d666dc6b1}
\hypertarget{classCheckerCPU_abc2dac603f413be8cd5f63b5c0b2d48d}{
\index{CheckerCPU@{CheckerCPU}!startNumLoad@{startNumLoad}}
\index{startNumLoad@{startNumLoad}!CheckerCPU@{CheckerCPU}}
\subsubsection[{startNumLoad}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Counter} {\bf startNumLoad}}}
\label{classCheckerCPU_abc2dac603f413be8cd5f63b5c0b2d48d}
\hypertarget{classCheckerCPU_a200e57ff6183b27a87839eda56674e28}{
\index{CheckerCPU@{CheckerCPU}!systemPtr@{systemPtr}}
\index{systemPtr@{systemPtr}!CheckerCPU@{CheckerCPU}}
\subsubsection[{systemPtr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf System}$\ast$ {\bf systemPtr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_a200e57ff6183b27a87839eda56674e28}
\hypertarget{classCheckerCPU_a4455a4759e69e5ebe68ae7298cbcc37d}{
\index{CheckerCPU@{CheckerCPU}!tc@{tc}}
\index{tc@{tc}!CheckerCPU@{CheckerCPU}}
\subsubsection[{tc}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadContext}$\ast$ {\bf tc}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_a4455a4759e69e5ebe68ae7298cbcc37d}
\hypertarget{classCheckerCPU_af9572fa907cd21b54cb14bd626010d39}{
\index{CheckerCPU@{CheckerCPU}!thread@{thread}}
\index{thread@{thread}!CheckerCPU@{CheckerCPU}}
\subsubsection[{thread}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SimpleThread}$\ast$ {\bf thread}}}
\label{classCheckerCPU_af9572fa907cd21b54cb14bd626010d39}
\hypertarget{classCheckerCPU_a6840f1942d66e27328010652fcc83cc4}{
\index{CheckerCPU@{CheckerCPU}!unverifiedMemData@{unverifiedMemData}}
\index{unverifiedMemData@{unverifiedMemData}!CheckerCPU@{CheckerCPU}}
\subsubsection[{unverifiedMemData}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t$\ast$ {\bf unverifiedMemData}}}
\label{classCheckerCPU_a6840f1942d66e27328010652fcc83cc4}
\hypertarget{classCheckerCPU_a398733bcf03e60981cf4b3cc79f339cb}{
\index{CheckerCPU@{CheckerCPU}!unverifiedReq@{unverifiedReq}}
\index{unverifiedReq@{unverifiedReq}!CheckerCPU@{CheckerCPU}}
\subsubsection[{unverifiedReq}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Request}$\ast$ {\bf unverifiedReq}}}
\label{classCheckerCPU_a398733bcf03e60981cf4b3cc79f339cb}
\hypertarget{classCheckerCPU_ae44d4afdef854be5de937985e00e162c}{
\index{CheckerCPU@{CheckerCPU}!unverifiedResult@{unverifiedResult}}
\index{unverifiedResult@{unverifiedResult}!CheckerCPU@{CheckerCPU}}
\subsubsection[{unverifiedResult}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Result} {\bf unverifiedResult}}}
\label{classCheckerCPU_ae44d4afdef854be5de937985e00e162c}
\hypertarget{classCheckerCPU_a5c4b1a378d5b47717f50008b307ed1fb}{
\index{CheckerCPU@{CheckerCPU}!updateOnError@{updateOnError}}
\index{updateOnError@{updateOnError}!CheckerCPU@{CheckerCPU}}
\subsubsection[{updateOnError}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf updateOnError}}}
\label{classCheckerCPU_a5c4b1a378d5b47717f50008b307ed1fb}
\hypertarget{classCheckerCPU_af590e28bcadd292986518887f8ba3498}{
\index{CheckerCPU@{CheckerCPU}!warnOnlyOnLoadError@{warnOnlyOnLoadError}}
\index{warnOnlyOnLoadError@{warnOnlyOnLoadError}!CheckerCPU@{CheckerCPU}}
\subsubsection[{warnOnlyOnLoadError}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf warnOnlyOnLoadError}}}
\label{classCheckerCPU_af590e28bcadd292986518887f8ba3498}
\hypertarget{classCheckerCPU_a4f3f7f9c8e8331d34afcddc9d9cf1db7}{
\index{CheckerCPU@{CheckerCPU}!willChangePC@{willChangePC}}
\index{willChangePC@{willChangePC}!CheckerCPU@{CheckerCPU}}
\subsubsection[{willChangePC}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf willChangePC}}}
\label{classCheckerCPU_a4f3f7f9c8e8331d34afcddc9d9cf1db7}
\hypertarget{classCheckerCPU_a9b2cb3a230c37a5bb09eca1375e1a5bf}{
\index{CheckerCPU@{CheckerCPU}!workload@{workload}}
\index{workload@{workload}!CheckerCPU@{CheckerCPU}}
\subsubsection[{workload}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf Process}$\ast$$>$ {\bf workload}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCheckerCPU_a9b2cb3a230c37a5bb09eca1375e1a5bf}


\hyperlink{classBaseCPU_a73d872f4e6fdf59531004dac33e2cd93}{BaseCPU}を再定義しています。\hypertarget{classCheckerCPU_a258f3535e74a3e37e7c1afe9611266d2}{
\index{CheckerCPU@{CheckerCPU}!youngestSN@{youngestSN}}
\index{youngestSN@{youngestSN}!CheckerCPU@{CheckerCPU}}
\subsubsection[{youngestSN}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf youngestSN}}}
\label{classCheckerCPU_a258f3535e74a3e37e7c1afe9611266d2}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/checker/\hyperlink{checker_2cpu_8hh}{cpu.hh}\item 
cpu/checker/\hyperlink{checker_2cpu_8cc}{cpu.cc}\end{DoxyCompactItemize}
