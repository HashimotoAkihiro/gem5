\hypertarget{classPageTable}{
\section{クラス PageTable}
\label{classPageTable}\index{PageTable@{PageTable}}
}


{\ttfamily \#include $<$page\_\-table.hh$>$}\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structPageTable_1_1cacheElement}{cacheElement}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classPageTable_a0ba607685599040207fa0f5834252a97}{PageTable} (const std::string \&\_\-\_\-name, uint64\_\-t \_\-pid, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \_\-pageSize=TheISA::VMPageSize)
\item 
\hyperlink{classPageTable_ac8d0a10aebf4985568764273ad64d267}{$\sim$PageTable} ()
\item 
const std::string \hyperlink{classPageTable_a6490f765a824ced1cc94979609fe7e07}{name} () const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classPageTable_a38247c4bd6655c6c275b578bd72e63e4}{pageAlign} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} a)
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classPageTable_aea9a0188c4082f2d04b870ee4d03103c}{pageOffset} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} a)
\item 
void \hyperlink{classPageTable_aff59f07ef2928facc67674a304b1e7e9}{map} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vaddr, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} paddr, int64\_\-t size, bool clobber=false)
\item 
void \hyperlink{classPageTable_a42230248f7e6b36d1d039334dfc8c73b}{remap} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vaddr, int64\_\-t size, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} new\_\-vaddr)
\item 
void \hyperlink{classPageTable_a8655228481877dd15f31d7657b7636f0}{unmap} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vaddr, int64\_\-t size)
\item 
bool \hyperlink{classPageTable_ab21bd7c6a258cbbe96db22e978a0ee70}{isUnmapped} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vaddr, int64\_\-t size)
\item 
bool \hyperlink{classPageTable_a5a9bd017a274b26bec6d93084a06a786}{lookup} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vaddr, TheISA::TlbEntry \&entry)
\item 
bool \hyperlink{classPageTable_a1fa58423b982a3454aadc9b5e932e9ed}{translate} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vaddr, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \&paddr)
\item 
bool \hyperlink{classPageTable_a72077eb2c400826c0a18b845a7be0e6a}{translate} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vaddr)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classPageTable_aacd7f462f681cfd6e11ef22d6fe32557}{translate} (\hyperlink{classRequest}{RequestPtr} req)
\item 
void \hyperlink{classPageTable_ad12e4d4887c4e62c2c8236936053dcd5}{updateCache} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vaddr, TheISA::TlbEntry entry)
\item 
void \hyperlink{classPageTable_a7a34214b4d368d09f3dee2ee3670b520}{eraseCacheEntry} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vaddr)
\item 
void \hyperlink{classPageTable_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
void \hyperlink{classPageTable_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
typedef m5::hash\_\-map$<$ \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr}, TheISA::TlbEntry $>$ \hyperlink{classPageTable_af3d8a3d9e644cad85356d24d9c324628}{PTable}
\item 
typedef PTable::iterator \hyperlink{classPageTable_ae7a302b2a02308ebbb6a164d74a9b2fa}{PTableItr}
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classPageTable_af3d8a3d9e644cad85356d24d9c324628}{PTable} \hyperlink{classPageTable_af6a1d4146effcb66a42a1a50cdedd71c}{pTable}
\item 
struct \hyperlink{structPageTable_1_1cacheElement}{cacheElement} \hyperlink{classPageTable_a6eb3f78e407d321f98bdaacc9d2768a6}{pTableCache} \mbox{[}3\mbox{]}
\item 
const \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classPageTable_a9e5e4d8007dd2c921971af2a58f86adc}{pageSize}
\item 
const \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classPageTable_a646af22c789b99dbdef2d5d867b6257a}{offsetMask}
\item 
const uint64\_\-t \hyperlink{classPageTable_ae7231756748632307a03aff2b0d3fd8d}{pid}
\item 
const std::string \hyperlink{classPageTable_a1b003dc5cfce1a4d8f9a0c4b9b589045}{\_\-name}
\end{DoxyCompactItemize}


\subsection{説明}
Page Table Declaration. 

\subsection{型定義}
\hypertarget{classPageTable_af3d8a3d9e644cad85356d24d9c324628}{
\index{PageTable@{PageTable}!PTable@{PTable}}
\index{PTable@{PTable}!PageTable@{PageTable}}
\subsubsection[{PTable}]{\setlength{\rightskip}{0pt plus 5cm}typedef m5::hash\_\-map$<${\bf Addr}, TheISA::TlbEntry$>$ {\bf PTable}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPageTable_af3d8a3d9e644cad85356d24d9c324628}
\hypertarget{classPageTable_ae7a302b2a02308ebbb6a164d74a9b2fa}{
\index{PageTable@{PageTable}!PTableItr@{PTableItr}}
\index{PTableItr@{PTableItr}!PageTable@{PageTable}}
\subsubsection[{PTableItr}]{\setlength{\rightskip}{0pt plus 5cm}typedef PTable::iterator {\bf PTableItr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPageTable_ae7a302b2a02308ebbb6a164d74a9b2fa}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classPageTable_a0ba607685599040207fa0f5834252a97}{
\index{PageTable@{PageTable}!PageTable@{PageTable}}
\index{PageTable@{PageTable}!PageTable@{PageTable}}
\subsubsection[{PageTable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PageTable} (const std::string \& {\em \_\-\_\-name}, \/  uint64\_\-t {\em \_\-pid}, \/  {\bf Addr} {\em \_\-pageSize} = {\ttfamily TheISA::VMPageSize})}}
\label{classPageTable_a0ba607685599040207fa0f5834252a97}



\begin{DoxyCode}
54     : pageSize(_pageSize), offsetMask(mask(floorLog2(_pageSize))),
55       pid(_pid), _name(__name)
56 {
57     assert(isPowerOf2(pageSize));
58     pTableCache[0].valid = false;
59     pTableCache[1].valid = false;
60     pTableCache[2].valid = false;
61 }
\end{DoxyCode}
\hypertarget{classPageTable_ac8d0a10aebf4985568764273ad64d267}{
\index{PageTable@{PageTable}!$\sim$PageTable@{$\sim$PageTable}}
\index{$\sim$PageTable@{$\sim$PageTable}!PageTable@{PageTable}}
\subsubsection[{$\sim$PageTable}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf PageTable} ()}}
\label{classPageTable_ac8d0a10aebf4985568764273ad64d267}



\begin{DoxyCode}
64 {
65 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classPageTable_a7a34214b4d368d09f3dee2ee3670b520}{
\index{PageTable@{PageTable}!eraseCacheEntry@{eraseCacheEntry}}
\index{eraseCacheEntry@{eraseCacheEntry}!PageTable@{PageTable}}
\subsubsection[{eraseCacheEntry}]{\setlength{\rightskip}{0pt plus 5cm}void eraseCacheEntry ({\bf Addr} {\em vaddr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPageTable_a7a34214b4d368d09f3dee2ee3670b520}
Erase an entry from the page table cache. 
\begin{DoxyParams}{引数}
\item[{\em vaddr}]virtual address (page aligned) to check \end{DoxyParams}



\begin{DoxyCode}
152     {
153         // Invalidate cached entries if necessary
154         if (pTableCache[0].valid && pTableCache[0].vaddr == vaddr) {
155             pTableCache[0].valid = false;
156         } else if (pTableCache[1].valid && pTableCache[1].vaddr == vaddr) {
157             pTableCache[1].valid = false;
158         } else if (pTableCache[2].valid && pTableCache[2].vaddr == vaddr) {
159             pTableCache[2].valid = false;
160         }
161     }
\end{DoxyCode}
\hypertarget{classPageTable_ab21bd7c6a258cbbe96db22e978a0ee70}{
\index{PageTable@{PageTable}!isUnmapped@{isUnmapped}}
\index{isUnmapped@{isUnmapped}!PageTable@{PageTable}}
\subsubsection[{isUnmapped}]{\setlength{\rightskip}{0pt plus 5cm}bool isUnmapped ({\bf Addr} {\em vaddr}, \/  int64\_\-t {\em size})}}
\label{classPageTable_ab21bd7c6a258cbbe96db22e978a0ee70}
\hyperlink{classCheck}{Check} if any pages in a region are already allocated 
\begin{DoxyParams}{引数}
\item[{\em vaddr}]The starting virtual address of the region. \item[{\em size}]The length of the region. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
True if no pages in the region are mapped. 
\end{DoxyReturn}



\begin{DoxyCode}
124 {
125     // starting address must be page aligned
126     assert(pageOffset(vaddr) == 0);
127 
128     for (; size > 0; size -= pageSize, vaddr += pageSize) {
129         if (pTable.find(vaddr) != pTable.end()) {
130             return false;
131         }
132     }
133 
134     return true;
135 }
\end{DoxyCode}
\hypertarget{classPageTable_a5a9bd017a274b26bec6d93084a06a786}{
\index{PageTable@{PageTable}!lookup@{lookup}}
\index{lookup@{lookup}!PageTable@{PageTable}}
\subsubsection[{lookup}]{\setlength{\rightskip}{0pt plus 5cm}bool lookup ({\bf Addr} {\em vaddr}, \/  TheISA::TlbEntry \& {\em entry})}}
\label{classPageTable_a5a9bd017a274b26bec6d93084a06a786}
Lookup function 
\begin{DoxyParams}{引数}
\item[{\em vaddr}]The virtual address. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
entry The page table entry corresponding to vaddr. 
\end{DoxyReturn}



\begin{DoxyCode}
139 {
140     Addr page_addr = pageAlign(vaddr);
141 
142     if (pTableCache[0].valid && pTableCache[0].vaddr == page_addr) {
143         entry = pTableCache[0].entry;
144         return true;
145     }
146     if (pTableCache[1].valid && pTableCache[1].vaddr == page_addr) {
147         entry = pTableCache[1].entry;
148         return true;
149     }
150     if (pTableCache[2].valid && pTableCache[2].vaddr == page_addr) {
151         entry = pTableCache[2].entry;
152         return true;
153     }
154 
155     PTableItr iter = pTable.find(page_addr);
156 
157     if (iter == pTable.end()) {
158         return false;
159     }
160 
161     updateCache(page_addr, iter->second);
162     entry = iter->second;
163     return true;
164 }
\end{DoxyCode}
\hypertarget{classPageTable_aff59f07ef2928facc67674a304b1e7e9}{
\index{PageTable@{PageTable}!map@{map}}
\index{map@{map}!PageTable@{PageTable}}
\subsubsection[{map}]{\setlength{\rightskip}{0pt plus 5cm}void map ({\bf Addr} {\em vaddr}, \/  {\bf Addr} {\em paddr}, \/  int64\_\-t {\em size}, \/  bool {\em clobber} = {\ttfamily false})}}
\label{classPageTable_aff59f07ef2928facc67674a304b1e7e9}



\begin{DoxyCode}
69 {
70     // starting address must be page aligned
71     assert(pageOffset(vaddr) == 0);
72 
73     DPRINTF(MMU, "Allocating Page: %#x-%#x\n", vaddr, vaddr+ size);
74 
75     for (; size > 0; size -= pageSize, vaddr += pageSize, paddr += pageSize) {
76         if (!clobber && (pTable.find(vaddr) != pTable.end())) {
77             // already mapped
78             fatal("PageTable::allocate: address 0x%x already mapped", vaddr);
79         }
80 
81         pTable[vaddr] = TheISA::TlbEntry(pid, vaddr, paddr);
82         eraseCacheEntry(vaddr);
83         updateCache(vaddr, pTable[vaddr]);
84     }
85 }
\end{DoxyCode}
\hypertarget{classPageTable_a6490f765a824ced1cc94979609fe7e07}{
\index{PageTable@{PageTable}!name@{name}}
\index{name@{name}!PageTable@{PageTable}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}const std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPageTable_a6490f765a824ced1cc94979609fe7e07}



\begin{DoxyCode}
81 { return _name; }
\end{DoxyCode}
\hypertarget{classPageTable_a38247c4bd6655c6c275b578bd72e63e4}{
\index{PageTable@{PageTable}!pageAlign@{pageAlign}}
\index{pageAlign@{pageAlign}!PageTable@{PageTable}}
\subsubsection[{pageAlign}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} pageAlign ({\bf Addr} {\em a})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPageTable_a38247c4bd6655c6c275b578bd72e63e4}



\begin{DoxyCode}
83 { return (a & ~offsetMask); }
\end{DoxyCode}
\hypertarget{classPageTable_aea9a0188c4082f2d04b870ee4d03103c}{
\index{PageTable@{PageTable}!pageOffset@{pageOffset}}
\index{pageOffset@{pageOffset}!PageTable@{PageTable}}
\subsubsection[{pageOffset}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} pageOffset ({\bf Addr} {\em a})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPageTable_aea9a0188c4082f2d04b870ee4d03103c}



\begin{DoxyCode}
84 { return (a &  offsetMask); }
\end{DoxyCode}
\hypertarget{classPageTable_a42230248f7e6b36d1d039334dfc8c73b}{
\index{PageTable@{PageTable}!remap@{remap}}
\index{remap@{remap}!PageTable@{PageTable}}
\subsubsection[{remap}]{\setlength{\rightskip}{0pt plus 5cm}void remap ({\bf Addr} {\em vaddr}, \/  int64\_\-t {\em size}, \/  {\bf Addr} {\em new\_\-vaddr})}}
\label{classPageTable_a42230248f7e6b36d1d039334dfc8c73b}



\begin{DoxyCode}
89 {
90     assert(pageOffset(vaddr) == 0);
91     assert(pageOffset(new_vaddr) == 0);
92 
93     DPRINTF(MMU, "moving pages from vaddr %08p to %08p, size = %d\n", vaddr,
94             new_vaddr, size);
95 
96     for (; size > 0; size -= pageSize, vaddr += pageSize, new_vaddr += pageSize) 
      {
97         assert(pTable.find(vaddr) != pTable.end());
98 
99         pTable[new_vaddr] = pTable[vaddr];
100         pTable.erase(vaddr);
101         eraseCacheEntry(vaddr);
102         pTable[new_vaddr].updateVaddr(new_vaddr);
103         updateCache(new_vaddr, pTable[new_vaddr]);
104     }
105 }
\end{DoxyCode}
\hypertarget{classPageTable_a53e036786d17361be4c7320d39c99b84}{
\index{PageTable@{PageTable}!serialize@{serialize}}
\index{serialize@{serialize}!PageTable@{PageTable}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})}}
\label{classPageTable_a53e036786d17361be4c7320d39c99b84}



\begin{DoxyCode}
198 {
199     paramOut(os, "ptable.size", pTable.size());
200 
201     PTable::size_type count = 0;
202 
203     PTableItr iter = pTable.begin();
204     PTableItr end = pTable.end();
205     while (iter != end) {
206         os << "\n[" << csprintf("%s.Entry%d", name(), count) << "]\n";
207 
208         paramOut(os, "vaddr", iter->first);
209         iter->second.serialize(os);
210 
211         ++iter;
212         ++count;
213     }
214     assert(count == pTable.size());
215 }
\end{DoxyCode}
\hypertarget{classPageTable_aacd7f462f681cfd6e11ef22d6fe32557}{
\index{PageTable@{PageTable}!translate@{translate}}
\index{translate@{translate}!PageTable@{PageTable}}
\subsubsection[{translate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translate ({\bf RequestPtr} {\em req})}}
\label{classPageTable_aacd7f462f681cfd6e11ef22d6fe32557}
Perform a translation on the memory request, fills in paddr field of req. 
\begin{DoxyParams}{引数}
\item[{\em req}]The memory request. \end{DoxyParams}



\begin{DoxyCode}
181 {
182     Addr paddr;
183     assert(pageAlign(req->getVaddr() + req->getSize() - 1)
184            == pageAlign(req->getVaddr()));
185     if (!translate(req->getVaddr(), paddr)) {
186         return Fault(new GenericPageTableFault(req->getVaddr()));
187     }
188     req->setPaddr(paddr);
189     if ((paddr & (pageSize - 1)) + req->getSize() > pageSize) {
190         panic("Request spans page boundaries!\n");
191         return NoFault;
192     }
193     return NoFault;
194 }
\end{DoxyCode}
\hypertarget{classPageTable_a72077eb2c400826c0a18b845a7be0e6a}{
\index{PageTable@{PageTable}!translate@{translate}}
\index{translate@{translate}!PageTable@{PageTable}}
\subsubsection[{translate}]{\setlength{\rightskip}{0pt plus 5cm}bool translate ({\bf Addr} {\em vaddr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPageTable_a72077eb2c400826c0a18b845a7be0e6a}
Simplified translate function (just check for translation) 
\begin{DoxyParams}{引数}
\item[{\em vaddr}]The virtual address. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
True if translation exists 
\end{DoxyReturn}



\begin{DoxyCode}
118 { Addr dummy; return translate(vaddr, dummy); }
\end{DoxyCode}
\hypertarget{classPageTable_a1fa58423b982a3454aadc9b5e932e9ed}{
\index{PageTable@{PageTable}!translate@{translate}}
\index{translate@{translate}!PageTable@{PageTable}}
\subsubsection[{translate}]{\setlength{\rightskip}{0pt plus 5cm}bool translate ({\bf Addr} {\em vaddr}, \/  {\bf Addr} \& {\em paddr})}}
\label{classPageTable_a1fa58423b982a3454aadc9b5e932e9ed}
Translate function 
\begin{DoxyParams}{引数}
\item[{\em vaddr}]The virtual address. \item[{\em paddr}]Physical address from translation. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
True if translation exists 
\end{DoxyReturn}



\begin{DoxyCode}
168 {
169     TheISA::TlbEntry entry;
170     if (!lookup(vaddr, entry)) {
171         DPRINTF(MMU, "Couldn't Translate: %#x\n", vaddr);
172         return false;
173     }
174     paddr = pageOffset(vaddr) + entry.pageStart();
175     DPRINTF(MMU, "Translating: %#x->%#x\n", vaddr, paddr);
176     return true;
177 }
\end{DoxyCode}
\hypertarget{classPageTable_a8655228481877dd15f31d7657b7636f0}{
\index{PageTable@{PageTable}!unmap@{unmap}}
\index{unmap@{unmap}!PageTable@{PageTable}}
\subsubsection[{unmap}]{\setlength{\rightskip}{0pt plus 5cm}void unmap ({\bf Addr} {\em vaddr}, \/  int64\_\-t {\em size})}}
\label{classPageTable_a8655228481877dd15f31d7657b7636f0}



\begin{DoxyCode}
109 {
110     assert(pageOffset(vaddr) == 0);
111 
112     DPRINTF(MMU, "Unmapping page: %#x-%#x\n", vaddr, vaddr+ size);
113 
114     for (; size > 0; size -= pageSize, vaddr += pageSize) {
115         assert(pTable.find(vaddr) != pTable.end());
116         pTable.erase(vaddr);
117         eraseCacheEntry(vaddr);
118     }
119 
120 }
\end{DoxyCode}
\hypertarget{classPageTable_af22e5d6d660b97db37003ac61ac4ee49}{
\index{PageTable@{PageTable}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!PageTable@{PageTable}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})}}
\label{classPageTable_af22e5d6d660b97db37003ac61ac4ee49}



\begin{DoxyCode}
219 {
220     int i = 0, count;
221     paramIn(cp, section, "ptable.size", count);
222 
223     pTable.clear();
224 
225     while (i < count) {
226         TheISA::TlbEntry *entry;
227         Addr vaddr;
228 
229         paramIn(cp, csprintf("%s.Entry%d", name(), i), "vaddr", vaddr);
230         entry = new TheISA::TlbEntry();
231         entry->unserialize(cp, csprintf("%s.Entry%d", name(), i));
232         pTable[vaddr] = *entry;
233         delete entry;
234         ++i;
235     }
236 }
\end{DoxyCode}
\hypertarget{classPageTable_ad12e4d4887c4e62c2c8236936053dcd5}{
\index{PageTable@{PageTable}!updateCache@{updateCache}}
\index{updateCache@{updateCache}!PageTable@{PageTable}}
\subsubsection[{updateCache}]{\setlength{\rightskip}{0pt plus 5cm}void updateCache ({\bf Addr} {\em vaddr}, \/  TheISA::TlbEntry {\em entry})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPageTable_ad12e4d4887c4e62c2c8236936053dcd5}
Update the page table cache. 
\begin{DoxyParams}{引数}
\item[{\em vaddr}]virtual address (page aligned) to check \item[{\em pte}]page table entry to return \end{DoxyParams}



\begin{DoxyCode}
133     {
134         pTableCache[2].entry = pTableCache[1].entry;
135         pTableCache[2].vaddr = pTableCache[1].vaddr;
136         pTableCache[2].valid = pTableCache[1].valid;
137 
138         pTableCache[1].entry = pTableCache[0].entry;
139         pTableCache[1].vaddr = pTableCache[0].vaddr;
140         pTableCache[1].valid = pTableCache[0].valid;
141 
142         pTableCache[0].entry = entry;
143         pTableCache[0].vaddr = vaddr;
144         pTableCache[0].valid = true;
145     }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classPageTable_a1b003dc5cfce1a4d8f9a0c4b9b589045}{
\index{PageTable@{PageTable}!\_\-name@{\_\-name}}
\index{\_\-name@{\_\-name}!PageTable@{PageTable}}
\subsubsection[{\_\-name}]{\setlength{\rightskip}{0pt plus 5cm}const std::string {\bf \_\-name}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPageTable_a1b003dc5cfce1a4d8f9a0c4b9b589045}
\hypertarget{classPageTable_a646af22c789b99dbdef2d5d867b6257a}{
\index{PageTable@{PageTable}!offsetMask@{offsetMask}}
\index{offsetMask@{offsetMask}!PageTable@{PageTable}}
\subsubsection[{offsetMask}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Addr} {\bf offsetMask}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPageTable_a646af22c789b99dbdef2d5d867b6257a}
\hypertarget{classPageTable_a9e5e4d8007dd2c921971af2a58f86adc}{
\index{PageTable@{PageTable}!pageSize@{pageSize}}
\index{pageSize@{pageSize}!PageTable@{PageTable}}
\subsubsection[{pageSize}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Addr} {\bf pageSize}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPageTable_a9e5e4d8007dd2c921971af2a58f86adc}
\hypertarget{classPageTable_ae7231756748632307a03aff2b0d3fd8d}{
\index{PageTable@{PageTable}!pid@{pid}}
\index{pid@{pid}!PageTable@{PageTable}}
\subsubsection[{pid}]{\setlength{\rightskip}{0pt plus 5cm}const uint64\_\-t {\bf pid}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPageTable_ae7231756748632307a03aff2b0d3fd8d}
\hypertarget{classPageTable_af6a1d4146effcb66a42a1a50cdedd71c}{
\index{PageTable@{PageTable}!pTable@{pTable}}
\index{pTable@{pTable}!PageTable@{PageTable}}
\subsubsection[{pTable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PTable} {\bf pTable}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPageTable_af6a1d4146effcb66a42a1a50cdedd71c}
\hypertarget{classPageTable_a6eb3f78e407d321f98bdaacc9d2768a6}{
\index{PageTable@{PageTable}!pTableCache@{pTableCache}}
\index{pTableCache@{pTableCache}!PageTable@{PageTable}}
\subsubsection[{pTableCache}]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf cacheElement} {\bf pTableCache}\mbox{[}3\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}read, protected\mbox{]}}}}
\label{classPageTable_a6eb3f78e407d321f98bdaacc9d2768a6}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{page__table_8hh}{page\_\-table.hh}\item 
mem/\hyperlink{page__table_8cc}{page\_\-table.cc}\end{DoxyCompactItemize}
