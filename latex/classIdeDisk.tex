\hypertarget{classIdeDisk}{
\section{クラス IdeDisk}
\label{classIdeDisk}\index{IdeDisk@{IdeDisk}}
}


{\ttfamily \#include $<$ide\_\-disk.hh$>$}IdeDiskに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classIdeDisk}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef IdeDiskParams \hyperlink{classIdeDisk_a21c0f7d16893ae472d7dbbc6df963053}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classIdeDisk_a2e3da8ce499e288eefcec4c9bd396958}{IdeDisk} (const \hyperlink{classIdeDisk_a21c0f7d16893ae472d7dbbc6df963053}{Params} $\ast$p)
\item 
\hyperlink{classIdeDisk_ad8843ac1fd1bc4b6d82e57318c9aeb38}{$\sim$IdeDisk} ()
\item 
void \hyperlink{classIdeDisk_a28f0332a5e13753c3f831ce1772b50c7}{reset} (int id)
\item 
void \hyperlink{classIdeDisk_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classIdeDisk_a2ffee462d2d9876fd5b3c6afc9a491bb}{setController} (\hyperlink{classIdeController}{IdeController} $\ast$c)
\item 
void \hyperlink{classIdeDisk_acf65df6ca6cb788da5cc36454d47cc34}{readCommand} (const \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} offset, int size, uint8\_\-t $\ast$data)
\item 
void \hyperlink{classIdeDisk_a9eb9bf3059a1fb59a282c5b86ad10ce6}{readControl} (const \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} offset, int size, uint8\_\-t $\ast$data)
\item 
void \hyperlink{classIdeDisk_af940c7b6408a2bb34bdd3580e8415da6}{writeCommand} (const \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} offset, int size, const uint8\_\-t $\ast$data)
\item 
void \hyperlink{classIdeDisk_af8e7a0d1414a2f9b03e2e001e036e87b}{writeControl} (const \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} offset, int size, const uint8\_\-t $\ast$data)
\item 
void \hyperlink{classIdeDisk_a5f7be8f129b212ec5a0f25ce5c65dbd7}{startDma} (const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \&prdTableBase)
\item 
void \hyperlink{classIdeDisk_a477c235c4d75b02347129c86b67161ea}{abortDma} ()
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classIdeController}{IdeController} $\ast$ \hyperlink{classIdeDisk_a15da11d9f856cf2edfc6ed93e24ad0ea}{ctrl}
\item 
\hyperlink{classDiskImage}{DiskImage} $\ast$ \hyperlink{classIdeDisk_a86d47120637a95e3a6876c774d768030}{image}
\item 
int \hyperlink{classIdeDisk_af49c4a1e28104d83429a5ae73e388143}{diskDelay}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classIdeDisk_a64f80702e39e45d2a65869911928c8ca}{startCommand} ()
\item 
void \hyperlink{classIdeDisk_aba6fa755ca152cedafeb4150da6a2493}{intrPost} ()
\item 
void \hyperlink{classIdeDisk_ac02b8a3b8685eca8bb4b237b29dfc762}{intrClear} ()
\item 
void \hyperlink{classIdeDisk_aa620b27b5598b2b7590329b64291460d}{doDmaTransfer} ()
\item 
void \hyperlink{classIdeDisk_aac34c7bd9c30398a876820e7bf616b72}{doDmaDataRead} ()
\item 
void \hyperlink{classIdeDisk_a4349f9ce6cbcc189128ed2968e74e497}{doDmaRead} ()
\item 
void \hyperlink{classIdeDisk_ae0d5ccabc77ef46a2850230fcf2e44de}{doDmaDataWrite} ()
\item 
void \hyperlink{classIdeDisk_ae547bc5391513f6cea7d857dc015f5da}{doDmaWrite} ()
\item 
void \hyperlink{classIdeDisk_a251a4f7092f0f261661c759eb4cdbd9b}{dmaPrdReadDone} ()
\item 
void \hyperlink{classIdeDisk_a2854a0676c5ef05d69512cabd994959c}{dmaReadDone} ()
\item 
void \hyperlink{classIdeDisk_a830e4a686d005a80a9fbf09c5d6d493e}{dmaWriteDone} ()
\item 
void \hyperlink{classIdeDisk_a8df41040225176356e649c3d35e11c62}{readDisk} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} sector, uint8\_\-t $\ast$data)
\item 
void \hyperlink{classIdeDisk_aaf5688ef23ac188d55decc9021229d43}{writeDisk} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} sector, uint8\_\-t $\ast$data)
\item 
void \hyperlink{classIdeDisk_a24fb6794cfae6f84b380080e7501959e}{updateState} (\hyperlink{ide__disk_8hh_ab9a7252f05d40d629a2b3e780862846c}{DevAction\_\-t} action)
\item 
bool \hyperlink{classIdeDisk_a61117d164479a7bbd3ed3d9afc8e261b}{isBSYSet} ()
\item 
bool \hyperlink{classIdeDisk_a3e0ad2d309fc4a7aaa7a8af8b09d2cc0}{isIENSet} ()
\item 
bool \hyperlink{classIdeDisk_a910d3c770ea864b505ae99ee7e674640}{isDEVSelect} ()
\item 
void \hyperlink{classIdeDisk_a57e01c0e3593bc187fa343f761ec895a}{setComplete} ()
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classIdeDisk_af02a88c6960b020d71b0d6b95e41bab1}{getLBABase} ()
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classIdeDisk_a8f2f46748053f3f3686a295cb3552ecd}{pciToDma} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} pciAddr)
\item 
void \hyperlink{classIdeDisk_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
void \hyperlink{classIdeDisk_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structataparams}{ataparams} \hyperlink{classIdeDisk_ae8a5371b95892db84d2b7ecef320d8a9}{driveID}
\item 
uint8\_\-t $\ast$ \hyperlink{classIdeDisk_a54aefba7f330b07a06f4c9447e582f09}{dataBuffer}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classIdeDisk_a732862da3f80cd2b8eaba9425c8415f5}{cmdBytes}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classIdeDisk_a70940fc29adad666da15b3d4c11ac2ff}{cmdBytesLeft}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classIdeDisk_a93e2e2892d126eac3ce8dbb514d44c31}{drqBytesLeft}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classIdeDisk_af7d6af3e55b20feac31aac92469e56f3}{curSector}
\item 
\hyperlink{structCommandReg}{CommandReg\_\-t} \hyperlink{classIdeDisk_a2d468138409fc099c81da8d9b62f1f0f}{cmdReg}
\item 
uint8\_\-t \hyperlink{classIdeDisk_ade818037fd6c985038ff29656089758d}{status}
\item 
bool \hyperlink{classIdeDisk_ad58649fd94c5f762267f1d7bf682f6ca}{nIENBit}
\item 
\hyperlink{ide__disk_8hh_abe49db4804c1744e30c8df026681eaf0}{DevState\_\-t} \hyperlink{classIdeDisk_a5fb52a264b2cccb6ccad92493dff5deb}{devState}
\item 
\hyperlink{ide__disk_8hh_a398a1d251e78562f1eccfb43ad5fdf49}{DmaState\_\-t} \hyperlink{classIdeDisk_acdefad9ebc91ac85f00ff92347b944d7}{dmaState}
\item 
bool \hyperlink{classIdeDisk_a3f1cf4317e46c3c845d144c5e0334096}{dmaRead}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classIdeDisk_a13b6a0a9519069583d8648b3eafa0448}{curPrdAddr}
\item 
\hyperlink{classPrdTableEntry}{PrdTableEntry} \hyperlink{classIdeDisk_a550dda68894801d065c57391335a8590}{curPrd}
\item 
int \hyperlink{classIdeDisk_a5f20adde61bc73f1275a1a35481a011d}{devID}
\item 
bool \hyperlink{classIdeDisk_aabb849037e6d1c429d270d7fd20e958f}{intrPending}
\item 
bool \hyperlink{classIdeDisk_aedff89f76b12103a29d22ef4de302236}{dmaAborted}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classIdeDisk_abab6bdef4c30741f3ec4b69e44e9d7c6}{dmaReadFullPages}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classIdeDisk_a01f4e9b11f3b49ac1cb6cbb6d51674c2}{dmaReadBytes}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classIdeDisk_a4310d460e8c2b5db635c0b2d1f1887a1}{dmaReadTxs}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classIdeDisk_adca0399abe696c769a268759b7823090}{dmaWriteFullPages}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classIdeDisk_a59676f0552c89ab5f75ed2e6d8fca378}{dmaWriteBytes}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classIdeDisk_a2bb232dff5f135210d3350a21d1c9ccf}{dmaWriteTxs}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classIdeDisk}{IdeDisk},\&IdeDisk::doDmaTransfer $>$ \hyperlink{classIdeDisk_aa90327d610dcc75173d1cd63671c6d31}{dmaTransferEvent}
\item 
\hyperlink{classChunkGenerator}{ChunkGenerator} $\ast$ \hyperlink{classIdeDisk_aafb836a34095616e67256a58e31ca604}{dmaReadCG}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classIdeDisk}{IdeDisk},\&IdeDisk::doDmaRead $>$ \hyperlink{classIdeDisk_a163b3ebdf005a99628b313b535697fb4}{dmaReadWaitEvent}
\item 
\hyperlink{classChunkGenerator}{ChunkGenerator} $\ast$ \hyperlink{classIdeDisk_a9efaedbad52401a1b8ac2b8f1dffd28e}{dmaWriteCG}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classIdeDisk}{IdeDisk},\&IdeDisk::doDmaWrite $>$ \hyperlink{classIdeDisk_ad35ded50a6e608571cb80f1ad9741514}{dmaWriteWaitEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classIdeDisk}{IdeDisk},\&IdeDisk::dmaPrdReadDone $>$ \hyperlink{classIdeDisk_aee6a35e547d828db5c3f993da6179be0}{dmaPrdReadEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classIdeDisk}{IdeDisk},\&IdeDisk::dmaReadDone $>$ \hyperlink{classIdeDisk_a7c5e1828543bec774a42b971376bb618}{dmaReadEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classIdeDisk}{IdeDisk},\&IdeDisk::dmaWriteDone $>$ \hyperlink{classIdeDisk_a6c721e441022d80574b109229351326a}{dmaWriteEvent}
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classIdeDisk_a07dd701b52fa01c73a9a70a11490190f}{EventWrapper$<$ IdeDisk,\&IdeDisk::doDmaTransfer $>$}
\item 
class \hyperlink{classIdeDisk_accdc7f0b6fabdd3d77c1b559d5145f1e}{EventWrapper$<$ IdeDisk,\&IdeDisk::doDmaRead $>$}
\item 
class \hyperlink{classIdeDisk_ab5b4eef2a93f5c96df001eac024301e2}{EventWrapper$<$ IdeDisk,\&IdeDisk::doDmaWrite $>$}
\item 
class \hyperlink{classIdeDisk_a576a5609a96330636252b99a5d689e36}{EventWrapper$<$ IdeDisk,\&IdeDisk::dmaPrdReadDone $>$}
\item 
class \hyperlink{classIdeDisk_a6de24ef3cf489b4e2419c1ce290ea10f}{EventWrapper$<$ IdeDisk,\&IdeDisk::dmaReadDone $>$}
\item 
class \hyperlink{classIdeDisk_ad39ee160ecba74f2b017af931eec8c6c}{EventWrapper$<$ IdeDisk,\&IdeDisk::dmaWriteDone $>$}
\end{DoxyCompactItemize}


\subsection{説明}
IDE Disk device model 

\subsection{型定義}
\hypertarget{classIdeDisk_a21c0f7d16893ae472d7dbbc6df963053}{
\index{IdeDisk@{IdeDisk}!Params@{Params}}
\index{Params@{Params}!IdeDisk@{IdeDisk}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef IdeDiskParams {\bf Params}}}
\label{classIdeDisk_a21c0f7d16893ae472d7dbbc6df963053}


\hyperlink{classSimObject_a0f0761d2db586a23bb2a2880b8f387bb}{SimObject}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classIdeDisk_a2e3da8ce499e288eefcec4c9bd396958}{
\index{IdeDisk@{IdeDisk}!IdeDisk@{IdeDisk}}
\index{IdeDisk@{IdeDisk}!IdeDisk@{IdeDisk}}
\subsubsection[{IdeDisk}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IdeDisk} (const {\bf Params} $\ast$ {\em p})}}
\label{classIdeDisk_a2e3da8ce499e288eefcec4c9bd396958}



\begin{DoxyCode}
69     : SimObject(p), ctrl(NULL), image(p->image), diskDelay(p->delay),
70       dmaTransferEvent(this), dmaReadCG(NULL), dmaReadWaitEvent(this),
71       dmaWriteCG(NULL), dmaWriteWaitEvent(this), dmaPrdReadEvent(this),
72       dmaReadEvent(this), dmaWriteEvent(this)
73 {
74     // Reset the device state
75     reset(p->driveID);
76 
77     // fill out the drive ID structure
78     memset(&driveID, 0, sizeof(struct ataparams));
79 
80     // Calculate LBA and C/H/S values
81     uint16_t cylinders;
82     uint8_t heads;
83     uint8_t sectors;
84 
85     uint32_t lba_size = image->size();
86     if (lba_size >= 16383*16*63) {
87         cylinders = 16383;
88         heads = 16;
89         sectors = 63;
90     } else {
91         if (lba_size >= 63)
92             sectors = 63;
93         else
94             sectors = lba_size;
95 
96         if ((lba_size / sectors) >= 16)
97             heads = 16;
98         else
99             heads = (lba_size / sectors);
100 
101         cylinders = lba_size / (heads * sectors);
102     }
103 
104     // Setup the model name
105     strncpy((char *)driveID.atap_model, "5MI EDD si k",
106             sizeof(driveID.atap_model));
107     // Set the maximum multisector transfer size
108     driveID.atap_multi = MAX_MULTSECT;
109     // IORDY supported, IORDY disabled, LBA enabled, DMA enabled
110     driveID.atap_capabilities1 = 0x7;
111     // UDMA support, EIDE support
112     driveID.atap_extensions = 0x6;
113     // Setup default C/H/S settings
114     driveID.atap_cylinders = cylinders;
115     driveID.atap_sectors = sectors;
116     driveID.atap_heads = heads;
117     // Setup the current multisector transfer size
118     driveID.atap_curmulti = MAX_MULTSECT;
119     driveID.atap_curmulti_valid = 0x1;
120     // Number of sectors on disk
121     driveID.atap_capacity = lba_size;
122     // Multiword DMA mode 2 and below supported
123     driveID.atap_dmamode_supp = 0x4;
124     // Set PIO mode 4 and 3 supported
125     driveID.atap_piomode_supp = 0x3;
126     // Set DMA mode 4 and below supported
127     driveID.atap_udmamode_supp = 0x1f;
128     // Statically set hardware config word
129     driveID.atap_hwreset_res = 0x4001;
130 
131     //arbitrary for now...
132     driveID.atap_ata_major = WDC_VER_ATA7;
133 }
\end{DoxyCode}
\hypertarget{classIdeDisk_ad8843ac1fd1bc4b6d82e57318c9aeb38}{
\index{IdeDisk@{IdeDisk}!$\sim$IdeDisk@{$\sim$IdeDisk}}
\index{$\sim$IdeDisk@{$\sim$IdeDisk}!IdeDisk@{IdeDisk}}
\subsubsection[{$\sim$IdeDisk}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf IdeDisk} ()}}
\label{classIdeDisk_ad8843ac1fd1bc4b6d82e57318c9aeb38}
Delete the data buffer. 


\begin{DoxyCode}
136 {
137     // destroy the data buffer
138     delete [] dataBuffer;
139 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classIdeDisk_a477c235c4d75b02347129c86b67161ea}{
\index{IdeDisk@{IdeDisk}!abortDma@{abortDma}}
\index{abortDma@{abortDma}!IdeDisk@{IdeDisk}}
\subsubsection[{abortDma}]{\setlength{\rightskip}{0pt plus 5cm}void abortDma ()}}
\label{classIdeDisk_a477c235c4d75b02347129c86b67161ea}



\begin{DoxyCode}
609 {
610     if (dmaState == Dma_Idle)
611         panic("Inconsistent DMA state, should be Start or Transfer!");
612 
613     if (devState != Transfer_Data_Dma && devState != Prepare_Data_Dma)
614         panic("Inconsistent device state, should be Transfer or Prepare!\n");
615 
616     updateState(ACT_CMD_ERROR);
617 }
\end{DoxyCode}
\hypertarget{classIdeDisk_a251a4f7092f0f261661c759eb4cdbd9b}{
\index{IdeDisk@{IdeDisk}!dmaPrdReadDone@{dmaPrdReadDone}}
\index{dmaPrdReadDone@{dmaPrdReadDone}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaPrdReadDone}]{\setlength{\rightskip}{0pt plus 5cm}void dmaPrdReadDone ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a251a4f7092f0f261661c759eb4cdbd9b}



\begin{DoxyCode}
355 {
356     if (dmaAborted) {
357         DPRINTF(IdeDisk, "DMA Aborted while reading PRD entry\n");
358         updateState(ACT_CMD_ERROR);
359         return;
360     }
361 
362     DPRINTF(IdeDisk,
363             "PRD: baseAddr:%#x (%#x) byteCount:%d (%d) eot:%#x sector:%d\n",
364             curPrd.getBaseAddr(), pciToDma(curPrd.getBaseAddr()),
365             curPrd.getByteCount(), (cmdBytesLeft/SectorSize),
366             curPrd.getEOT(), curSector);
367 
368     // the prd pointer has already been translated, so just do an increment
369     curPrdAddr = curPrdAddr + sizeof(PrdEntry_t);
370 
371     if (dmaRead)
372         doDmaDataRead();
373     else
374         doDmaDataWrite();
375 }
\end{DoxyCode}
\hypertarget{classIdeDisk_a2854a0676c5ef05d69512cabd994959c}{
\index{IdeDisk@{IdeDisk}!dmaReadDone@{dmaReadDone}}
\index{dmaReadDone@{dmaReadDone}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaReadDone}]{\setlength{\rightskip}{0pt plus 5cm}void dmaReadDone ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a2854a0676c5ef05d69512cabd994959c}



\begin{DoxyCode}
461 {
462     uint32_t bytesWritten = 0;
463 
464     // write the data to the disk image
465     for (bytesWritten = 0; bytesWritten < curPrd.getByteCount();
466          bytesWritten += SectorSize) {
467 
468         cmdBytesLeft -= SectorSize;
469         writeDisk(curSector++, (uint8_t *)(dataBuffer + bytesWritten));
470     }
471 
472     // check for the EOT
473     if (curPrd.getEOT()) {
474         assert(cmdBytesLeft == 0);
475         dmaState = Dma_Idle;
476         updateState(ACT_DMA_DONE);
477     } else {
478         doDmaTransfer();
479     }
480 }
\end{DoxyCode}
\hypertarget{classIdeDisk_a830e4a686d005a80a9fbf09c5d6d493e}{
\index{IdeDisk@{IdeDisk}!dmaWriteDone@{dmaWriteDone}}
\index{dmaWriteDone@{dmaWriteDone}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaWriteDone}]{\setlength{\rightskip}{0pt plus 5cm}void dmaWriteDone ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a830e4a686d005a80a9fbf09c5d6d493e}



\begin{DoxyCode}
548 {
549     DPRINTF(IdeDisk, "doWriteDone: curPrd byte count %d, eot %#x cmd bytes left:%
      d\n",
550                 curPrd.getByteCount(), curPrd.getEOT(), cmdBytesLeft);
551     // check for the EOT
552     if (curPrd.getEOT()) {
553         assert(cmdBytesLeft == 0);
554         dmaState = Dma_Idle;
555         updateState(ACT_DMA_DONE);
556     } else {
557         doDmaTransfer();
558     }
559 }
\end{DoxyCode}
\hypertarget{classIdeDisk_aac34c7bd9c30398a876820e7bf616b72}{
\index{IdeDisk@{IdeDisk}!doDmaDataRead@{doDmaDataRead}}
\index{doDmaDataRead@{doDmaDataRead}!IdeDisk@{IdeDisk}}
\subsubsection[{doDmaDataRead}]{\setlength{\rightskip}{0pt plus 5cm}void doDmaDataRead ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_aac34c7bd9c30398a876820e7bf616b72}


\begin{Desc}
\item[\hyperlink{todo__todo000057}{TODO}]we need to figure out what the delay actually will be \end{Desc}



\begin{DoxyCode}
379 {
381     Tick totalDiskDelay = diskDelay + (curPrd.getByteCount() / SectorSize);
382 
383     DPRINTF(IdeDisk, "doDmaRead, diskDelay: %d totalDiskDelay: %d\n",
384             diskDelay, totalDiskDelay);
385 
386     schedule(dmaReadWaitEvent, curTick() + totalDiskDelay);
387 }
\end{DoxyCode}
\hypertarget{classIdeDisk_ae0d5ccabc77ef46a2850230fcf2e44de}{
\index{IdeDisk@{IdeDisk}!doDmaDataWrite@{doDmaDataWrite}}
\index{doDmaDataWrite@{doDmaDataWrite}!IdeDisk@{IdeDisk}}
\subsubsection[{doDmaDataWrite}]{\setlength{\rightskip}{0pt plus 5cm}void doDmaDataWrite ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_ae0d5ccabc77ef46a2850230fcf2e44de}


\begin{Desc}
\item[\hyperlink{todo__todo000058}{TODO}]we need to figure out what the delay actually will be \end{Desc}



\begin{DoxyCode}
484 {
486     Tick totalDiskDelay = diskDelay + (curPrd.getByteCount() / SectorSize);
487     uint32_t bytesRead = 0;
488 
489     DPRINTF(IdeDisk, "doDmaWrite, diskDelay: %d totalDiskDelay: %d\n",
490             diskDelay, totalDiskDelay);
491 
492     memset(dataBuffer, 0, MAX_DMA_SIZE);
493     assert(cmdBytesLeft <= MAX_DMA_SIZE);
494     while (bytesRead < curPrd.getByteCount()) {
495         readDisk(curSector++, (uint8_t *)(dataBuffer + bytesRead));
496         bytesRead += SectorSize;
497         cmdBytesLeft -= SectorSize;
498     }
499     DPRINTF(IdeDisk, "doDmaWrite, bytesRead: %d cmdBytesLeft: %d\n",
500             bytesRead, cmdBytesLeft);
501 
502     schedule(dmaWriteWaitEvent, curTick() + totalDiskDelay);
503 }
\end{DoxyCode}
\hypertarget{classIdeDisk_a4349f9ce6cbcc189128ed2968e74e497}{
\index{IdeDisk@{IdeDisk}!doDmaRead@{doDmaRead}}
\index{doDmaRead@{doDmaRead}!IdeDisk@{IdeDisk}}
\subsubsection[{doDmaRead}]{\setlength{\rightskip}{0pt plus 5cm}void doDmaRead ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a4349f9ce6cbcc189128ed2968e74e497}



\begin{DoxyCode}
422 {
423     if (dmaAborted) {
424         DPRINTF(IdeDisk, "DMA Aborted in middle of Dma Read\n");
425         if (dmaReadCG)
426             delete dmaReadCG;
427         dmaReadCG = NULL;
428         updateState(ACT_CMD_ERROR);
429         return;
430     }
431 
432     if (!dmaReadCG) {
433         // clear out the data buffer
434         memset(dataBuffer, 0, MAX_DMA_SIZE);
435         dmaReadCG = new ChunkGenerator(curPrd.getBaseAddr(),
436                 curPrd.getByteCount(), TheISA::PageBytes);
437 
438     }
439     if (ctrl->dmaPending() || ctrl->getDrainState() != Drainable::Running) {
440         schedule(dmaReadWaitEvent, curTick() + DMA_BACKOFF_PERIOD);
441         return;
442     } else if (!dmaReadCG->done()) {
443         assert(dmaReadCG->complete() < MAX_DMA_SIZE);
444         ctrl->dmaRead(pciToDma(dmaReadCG->addr()), dmaReadCG->size(),
445                 &dmaReadWaitEvent, dataBuffer + dmaReadCG->complete());
446         dmaReadBytes += dmaReadCG->size();
447         dmaReadTxs++;
448         if (dmaReadCG->size() == TheISA::PageBytes)
449             dmaReadFullPages++;
450         dmaReadCG->next();
451     } else {
452         assert(dmaReadCG->done());
453         delete dmaReadCG;
454         dmaReadCG = NULL;
455         dmaReadDone();
456     }
457 }
\end{DoxyCode}
\hypertarget{classIdeDisk_aa620b27b5598b2b7590329b64291460d}{
\index{IdeDisk@{IdeDisk}!doDmaTransfer@{doDmaTransfer}}
\index{doDmaTransfer@{doDmaTransfer}!IdeDisk@{IdeDisk}}
\subsubsection[{doDmaTransfer}]{\setlength{\rightskip}{0pt plus 5cm}void doDmaTransfer ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_aa620b27b5598b2b7590329b64291460d}



\begin{DoxyCode}
334 {
335     if (dmaAborted) {
336         DPRINTF(IdeDisk, "DMA Aborted before reading PRD entry\n");
337         updateState(ACT_CMD_ERROR);
338         return;
339     }
340 
341     if (dmaState != Dma_Transfer || devState != Transfer_Data_Dma)
342         panic("Inconsistent DMA transfer state: dmaState = %d devState = %d\n",
343               dmaState, devState);
344 
345     if (ctrl->dmaPending() || ctrl->getDrainState() != Drainable::Running) {
346         schedule(dmaTransferEvent, curTick() + DMA_BACKOFF_PERIOD);
347         return;
348     } else
349         ctrl->dmaRead(curPrdAddr, sizeof(PrdEntry_t), &dmaPrdReadEvent,
350                 (uint8_t*)&curPrd.entry);
351 }
\end{DoxyCode}
\hypertarget{classIdeDisk_ae547bc5391513f6cea7d857dc015f5da}{
\index{IdeDisk@{IdeDisk}!doDmaWrite@{doDmaWrite}}
\index{doDmaWrite@{doDmaWrite}!IdeDisk@{IdeDisk}}
\subsubsection[{doDmaWrite}]{\setlength{\rightskip}{0pt plus 5cm}void doDmaWrite ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_ae547bc5391513f6cea7d857dc015f5da}



\begin{DoxyCode}
507 {
508     if (dmaAborted) {
509         DPRINTF(IdeDisk, "DMA Aborted while doing DMA Write\n");
510         if (dmaWriteCG)
511             delete dmaWriteCG;
512         dmaWriteCG = NULL;
513         updateState(ACT_CMD_ERROR);
514         return;
515     }
516     if (!dmaWriteCG) {
517         // clear out the data buffer
518         dmaWriteCG = new ChunkGenerator(curPrd.getBaseAddr(),
519                 curPrd.getByteCount(), TheISA::PageBytes);
520     }
521     if (ctrl->dmaPending() || ctrl->getDrainState() != Drainable::Running) {
522         schedule(dmaWriteWaitEvent, curTick() + DMA_BACKOFF_PERIOD);
523         DPRINTF(IdeDisk, "doDmaWrite: rescheduling\n");
524         return;
525     } else if (!dmaWriteCG->done()) {
526         assert(dmaWriteCG->complete() < MAX_DMA_SIZE);
527         ctrl->dmaWrite(pciToDma(dmaWriteCG->addr()), dmaWriteCG->size(),
528                 &dmaWriteWaitEvent, dataBuffer + dmaWriteCG->complete());
529         DPRINTF(IdeDisk, "doDmaWrite: not done curPrd byte count %d, eot %#x\n",
530                 curPrd.getByteCount(), curPrd.getEOT());
531         dmaWriteBytes += dmaWriteCG->size();
532         dmaWriteTxs++;
533         if (dmaWriteCG->size() == TheISA::PageBytes)
534             dmaWriteFullPages++;
535         dmaWriteCG->next();
536     } else {
537         DPRINTF(IdeDisk, "doDmaWrite: done curPrd byte count %d, eot %#x\n",
538                 curPrd.getByteCount(), curPrd.getEOT());
539         assert(dmaWriteCG->done());
540         delete dmaWriteCG;
541         dmaWriteCG = NULL;
542         dmaWriteDone();
543     }
544 }
\end{DoxyCode}
\hypertarget{classIdeDisk_af02a88c6960b020d71b0d6b95e41bab1}{
\index{IdeDisk@{IdeDisk}!getLBABase@{getLBABase}}
\index{getLBABase@{getLBABase}!IdeDisk@{IdeDisk}}
\subsubsection[{getLBABase}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} getLBABase ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classIdeDisk_af02a88c6960b020d71b0d6b95e41bab1}



\begin{DoxyCode}
361     {
362         return  (Addr)(((cmdReg.head & 0xf) << 24) | (cmdReg.cyl_high << 16) |
363                        (cmdReg.cyl_low << 8) | (cmdReg.sec_num));
364     }
\end{DoxyCode}
\hypertarget{classIdeDisk_ac02b8a3b8685eca8bb4b237b29dfc762}{
\index{IdeDisk@{IdeDisk}!intrClear@{intrClear}}
\index{intrClear@{intrClear}!IdeDisk@{IdeDisk}}
\subsubsection[{intrClear}]{\setlength{\rightskip}{0pt plus 5cm}void intrClear ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_ac02b8a3b8685eca8bb4b237b29dfc762}



\begin{DoxyCode}
749 {
750     DPRINTF(IdeDisk, "Clearing Interrupt\n");
751     if (!intrPending)
752         panic("Attempt to clear a non-pending interrupt\n");
753 
754     intrPending = false;
755 
756     // talk to controller to clear interrupt
757     if (ctrl)
758         ctrl->intrClear();
759 }
\end{DoxyCode}
\hypertarget{classIdeDisk_aba6fa755ca152cedafeb4150da6a2493}{
\index{IdeDisk@{IdeDisk}!intrPost@{intrPost}}
\index{intrPost@{intrPost}!IdeDisk@{IdeDisk}}
\subsubsection[{intrPost}]{\setlength{\rightskip}{0pt plus 5cm}void intrPost ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_aba6fa755ca152cedafeb4150da6a2493}



\begin{DoxyCode}
734 {
735     DPRINTF(IdeDisk, "Posting Interrupt\n");
736     if (intrPending)
737         panic("Attempt to post an interrupt with one pending\n");
738 
739     intrPending = true;
740 
741     // talk to controller to set interrupt
742     if (ctrl) {
743         ctrl->intrPost();
744     }
745 }
\end{DoxyCode}
\hypertarget{classIdeDisk_a61117d164479a7bbd3ed3d9afc8e261b}{
\index{IdeDisk@{IdeDisk}!isBSYSet@{isBSYSet}}
\index{isBSYSet@{isBSYSet}!IdeDisk@{IdeDisk}}
\subsubsection[{isBSYSet}]{\setlength{\rightskip}{0pt plus 5cm}bool isBSYSet ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classIdeDisk_a61117d164479a7bbd3ed3d9afc8e261b}



\begin{DoxyCode}
346 { return (status & STATUS_BSY_BIT); }
\end{DoxyCode}
\hypertarget{classIdeDisk_a910d3c770ea864b505ae99ee7e674640}{
\index{IdeDisk@{IdeDisk}!isDEVSelect@{isDEVSelect}}
\index{isDEVSelect@{isDEVSelect}!IdeDisk@{IdeDisk}}
\subsubsection[{isDEVSelect}]{\setlength{\rightskip}{0pt plus 5cm}bool isDEVSelect ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a910d3c770ea864b505ae99ee7e674640}



\begin{DoxyCode}
187 {
188     return ctrl->isDiskSelected(this);
189 }
\end{DoxyCode}
\hypertarget{classIdeDisk_a3e0ad2d309fc4a7aaa7a8af8b09d2cc0}{
\index{IdeDisk@{IdeDisk}!isIENSet@{isIENSet}}
\index{isIENSet@{isIENSet}!IdeDisk@{IdeDisk}}
\subsubsection[{isIENSet}]{\setlength{\rightskip}{0pt plus 5cm}bool isIENSet ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classIdeDisk_a3e0ad2d309fc4a7aaa7a8af8b09d2cc0}



\begin{DoxyCode}
347 { return nIENBit; }
\end{DoxyCode}
\hypertarget{classIdeDisk_a8f2f46748053f3f3686a295cb3552ecd}{
\index{IdeDisk@{IdeDisk}!pciToDma@{pciToDma}}
\index{pciToDma@{pciToDma}!IdeDisk@{IdeDisk}}
\subsubsection[{pciToDma}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} pciToDma ({\bf Addr} {\em pciAddr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classIdeDisk_a8f2f46748053f3f3686a295cb3552ecd}



\begin{DoxyCode}
193 {
194     if (ctrl)
195         return ctrl->pciToDma(pciAddr);
196     else
197         panic("Access to unset controller!\n");
198 }
\end{DoxyCode}
\hypertarget{classIdeDisk_acf65df6ca6cb788da5cc36454d47cc34}{
\index{IdeDisk@{IdeDisk}!readCommand@{readCommand}}
\index{readCommand@{readCommand}!IdeDisk@{IdeDisk}}
\subsubsection[{readCommand}]{\setlength{\rightskip}{0pt plus 5cm}void readCommand (const {\bf Addr} {\em offset}, \/  int {\em size}, \/  uint8\_\-t $\ast$ {\em data})}}
\label{classIdeDisk_acf65df6ca6cb788da5cc36454d47cc34}



\begin{DoxyCode}
206 {
207     if (offset == DATA_OFFSET) {
208         if (size == sizeof(uint16_t)) {
209             *(uint16_t *)data = cmdReg.data;
210         } else if (size == sizeof(uint32_t)) {
211             *(uint16_t *)data = cmdReg.data;
212             updateState(ACT_DATA_READ_SHORT);
213             *((uint16_t *)data + 1) = cmdReg.data;
214         } else {
215             panic("Data read of unsupported size %d.\n", size);
216         }
217         updateState(ACT_DATA_READ_SHORT);
218         return;
219     }
220     assert(size == sizeof(uint8_t));
221     switch (offset) {
222       case ERROR_OFFSET:
223         *data = cmdReg.error;
224         break;
225       case NSECTOR_OFFSET:
226         *data = cmdReg.sec_count;
227         break;
228       case SECTOR_OFFSET:
229         *data = cmdReg.sec_num;
230         break;
231       case LCYL_OFFSET:
232         *data = cmdReg.cyl_low;
233         break;
234       case HCYL_OFFSET:
235         *data = cmdReg.cyl_high;
236         break;
237       case DRIVE_OFFSET:
238         *data = cmdReg.drive;
239         break;
240       case STATUS_OFFSET:
241         *data = status;
242         updateState(ACT_STAT_READ);
243         break;
244       default:
245         panic("Invalid IDE command register offset: %#x\n", offset);
246     }
247     DPRINTF(IdeDisk, "Read to disk at offset: %#x data %#x\n", offset, *data);
248 }
\end{DoxyCode}
\hypertarget{classIdeDisk_a9eb9bf3059a1fb59a282c5b86ad10ce6}{
\index{IdeDisk@{IdeDisk}!readControl@{readControl}}
\index{readControl@{readControl}!IdeDisk@{IdeDisk}}
\subsubsection[{readControl}]{\setlength{\rightskip}{0pt plus 5cm}void readControl (const {\bf Addr} {\em offset}, \/  int {\em size}, \/  uint8\_\-t $\ast$ {\em data})}}
\label{classIdeDisk_a9eb9bf3059a1fb59a282c5b86ad10ce6}



\begin{DoxyCode}
252 {
253     assert(size == sizeof(uint8_t));
254     *data = status;
255     if (offset != ALTSTAT_OFFSET)
256         panic("Invalid IDE control register offset: %#x\n", offset);
257     DPRINTF(IdeDisk, "Read to disk at offset: %#x data %#x\n", offset, *data);
258 }
\end{DoxyCode}
\hypertarget{classIdeDisk_a8df41040225176356e649c3d35e11c62}{
\index{IdeDisk@{IdeDisk}!readDisk@{readDisk}}
\index{readDisk@{readDisk}!IdeDisk@{IdeDisk}}
\subsubsection[{readDisk}]{\setlength{\rightskip}{0pt plus 5cm}void readDisk ({\bf uint32\_\-t} {\em sector}, \/  uint8\_\-t $\ast$ {\em data})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a8df41040225176356e649c3d35e11c62}



\begin{DoxyCode}
567 {
568     uint32_t bytesRead = image->read(data, sector);
569 
570     if (bytesRead != SectorSize)
571         panic("Can't read from %s. Only %d of %d read. errno=%d\n",
572               name(), bytesRead, SectorSize, errno);
573 }
\end{DoxyCode}
\hypertarget{classIdeDisk_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{IdeDisk@{IdeDisk}!regStats@{regStats}}
\index{regStats@{regStats}!IdeDisk@{IdeDisk}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIdeDisk_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} Statistics 

\hyperlink{classSimObject_a4dc637449366fcdfc4e764cdf12d9b11}{SimObject}を再定義しています。


\begin{DoxyCode}
391 {
392     using namespace Stats;
393     dmaReadFullPages
394         .name(name() + ".dma_read_full_pages")
395         .desc("Number of full page size DMA reads (not PRD).")
396         ;
397     dmaReadBytes
398         .name(name() + ".dma_read_bytes")
399         .desc("Number of bytes transfered via DMA reads (not PRD).")
400         ;
401     dmaReadTxs
402         .name(name() + ".dma_read_txs")
403         .desc("Number of DMA read transactions (not PRD).")
404         ;
405 
406     dmaWriteFullPages
407         .name(name() + ".dma_write_full_pages")
408         .desc("Number of full page size DMA writes.")
409         ;
410     dmaWriteBytes
411         .name(name() + ".dma_write_bytes")
412         .desc("Number of bytes transfered via DMA writes.")
413         ;
414     dmaWriteTxs
415         .name(name() + ".dma_write_txs")
416         .desc("Number of DMA write transactions.")
417         ;
418 }
\end{DoxyCode}
\hypertarget{classIdeDisk_a28f0332a5e13753c3f831ce1772b50c7}{
\index{IdeDisk@{IdeDisk}!reset@{reset}}
\index{reset@{reset}!IdeDisk@{IdeDisk}}
\subsubsection[{reset}]{\setlength{\rightskip}{0pt plus 5cm}void reset (int {\em id})}}
\label{classIdeDisk_a28f0332a5e13753c3f831ce1772b50c7}
Reset the device state 


\begin{DoxyCode}
143 {
144     // initialize the data buffer and shadow registers
145     dataBuffer = new uint8_t[MAX_DMA_SIZE];
146 
147     memset(dataBuffer, 0, MAX_DMA_SIZE);
148     memset(&cmdReg, 0, sizeof(CommandReg_t));
149     memset(&curPrd.entry, 0, sizeof(PrdEntry_t));
150 
151     curPrdAddr = 0;
152     curSector = 0;
153     cmdBytes = 0;
154     cmdBytesLeft = 0;
155     drqBytesLeft = 0;
156     dmaRead = false;
157     intrPending = false;
158     dmaAborted = false;
159 
160     // set the device state to idle
161     dmaState = Dma_Idle;
162 
163     if (id == DEV0) {
164         devState = Device_Idle_S;
165         devID = DEV0;
166     } else if (id == DEV1) {
167         devState = Device_Idle_NS;
168         devID = DEV1;
169     } else {
170         panic("Invalid device ID: %#x\n", id);
171     }
172 
173     // set the device ready bit
174     status = STATUS_DRDY_BIT;
175 
176     /* The error register must be set to 0x1 on start-up to
177        indicate that no diagnostic error was detected */
178     cmdReg.error = 0x1;
179 }
\end{DoxyCode}
\hypertarget{classIdeDisk_a53e036786d17361be4c7320d39c99b84}{
\index{IdeDisk@{IdeDisk}!serialize@{serialize}}
\index{serialize@{serialize}!IdeDisk@{IdeDisk}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}private, virtual\mbox{]}}}}
\label{classIdeDisk_a53e036786d17361be4c7320d39c99b84}
Serialize this object to the given output stream. 
\begin{DoxyParams}{引数}
\item[{\em os}]The stream to serialize to. \end{DoxyParams}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。\hypertarget{classIdeDisk_a57e01c0e3593bc187fa343f761ec895a}{
\index{IdeDisk@{IdeDisk}!setComplete@{setComplete}}
\index{setComplete@{setComplete}!IdeDisk@{IdeDisk}}
\subsubsection[{setComplete}]{\setlength{\rightskip}{0pt plus 5cm}void setComplete ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classIdeDisk_a57e01c0e3593bc187fa343f761ec895a}



\begin{DoxyCode}
351     {
352         // clear out the status byte
353         status = 0;
354         // set the DRDY bit
355         status |= STATUS_DRDY_BIT;
356         // set the SEEK bit
357         status |= STATUS_SEEK_BIT;
358     }
\end{DoxyCode}
\hypertarget{classIdeDisk_a2ffee462d2d9876fd5b3c6afc9a491bb}{
\index{IdeDisk@{IdeDisk}!setController@{setController}}
\index{setController@{setController}!IdeDisk@{IdeDisk}}
\subsubsection[{setController}]{\setlength{\rightskip}{0pt plus 5cm}void setController ({\bf IdeController} $\ast$ {\em c})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classIdeDisk_a2ffee462d2d9876fd5b3c6afc9a491bb}
\hyperlink{classSet}{Set} the controller for this device 
\begin{DoxyParams}{引数}
\item[{\em c}]The IDE controller \end{DoxyParams}



\begin{DoxyCode}
285                                          {
286         if (ctrl) panic("Cannot change the controller once set!\n");
287         ctrl = c;
288     }
\end{DoxyCode}
\hypertarget{classIdeDisk_a64f80702e39e45d2a65869911928c8ca}{
\index{IdeDisk@{IdeDisk}!startCommand@{startCommand}}
\index{startCommand@{startCommand}!IdeDisk@{IdeDisk}}
\subsubsection[{startCommand}]{\setlength{\rightskip}{0pt plus 5cm}void startCommand ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a64f80702e39e45d2a65869911928c8ca}


\begin{Desc}
\item[\hyperlink{todo__todo000059}{TODO}]make this a scheduled event to simulate disk delay \end{Desc}



\begin{DoxyCode}
621 {
622     DevAction_t action = ACT_NONE;
623     uint32_t size = 0;
624     dmaRead = false;
625 
626     // Decode commands
627     switch (cmdReg.command) {
628         // Supported non-data commands
629       case WDSF_READ_NATIVE_MAX:
630         size = (uint32_t)image->size() - 1;
631         cmdReg.sec_num = (size & 0xff);
632         cmdReg.cyl_low = ((size & 0xff00) >> 8);
633         cmdReg.cyl_high = ((size & 0xff0000) >> 16);
634         cmdReg.head = ((size & 0xf000000) >> 24);
635 
636         devState = Command_Execution;
637         action = ACT_CMD_COMPLETE;
638         break;
639 
640       case WDCC_RECAL:
641       case WDCC_IDP:
642       case WDCC_STANDBY_IMMED:
643       case WDCC_FLUSHCACHE:
644       case WDSF_VERIFY:
645       case WDSF_SEEK:
646       case SET_FEATURES:
647       case WDCC_SETMULTI:
648         devState = Command_Execution;
649         action = ACT_CMD_COMPLETE;
650         break;
651 
652         // Supported PIO data-in commands
653       case WDCC_IDENTIFY:
654         cmdBytes = cmdBytesLeft = sizeof(struct ataparams);
655         devState = Prepare_Data_In;
656         action = ACT_DATA_READY;
657         break;
658 
659       case WDCC_READMULTI:
660       case WDCC_READ:
661         if (!(cmdReg.drive & DRIVE_LBA_BIT))
662             panic("Attempt to perform CHS access, only supports LBA\n");
663 
664         if (cmdReg.sec_count == 0)
665             cmdBytes = cmdBytesLeft = (256 * SectorSize);
666         else
667             cmdBytes = cmdBytesLeft = (cmdReg.sec_count * SectorSize);
668 
669         curSector = getLBABase();
670 
672         devState = Prepare_Data_In;
673         action = ACT_DATA_READY;
674         break;
675 
676         // Supported PIO data-out commands
677       case WDCC_WRITEMULTI:
678       case WDCC_WRITE:
679         if (!(cmdReg.drive & DRIVE_LBA_BIT))
680             panic("Attempt to perform CHS access, only supports LBA\n");
681 
682         if (cmdReg.sec_count == 0)
683             cmdBytes = cmdBytesLeft = (256 * SectorSize);
684         else
685             cmdBytes = cmdBytesLeft = (cmdReg.sec_count * SectorSize);
686         DPRINTF(IdeDisk, "Setting cmdBytesLeft to %d\n", cmdBytesLeft);
687         curSector = getLBABase();
688 
689         devState = Prepare_Data_Out;
690         action = ACT_DATA_READY;
691         break;
692 
693         // Supported DMA commands
694       case WDCC_WRITEDMA:
695         dmaRead = true;  // a write to the disk is a DMA read from memory
696       case WDCC_READDMA:
697         if (!(cmdReg.drive & DRIVE_LBA_BIT))
698             panic("Attempt to perform CHS access, only supports LBA\n");
699 
700         if (cmdReg.sec_count == 0)
701             cmdBytes = cmdBytesLeft = (256 * SectorSize);
702         else
703             cmdBytes = cmdBytesLeft = (cmdReg.sec_count * SectorSize);
704         DPRINTF(IdeDisk, "Setting cmdBytesLeft to %d in readdma\n", cmdBytesLeft)
      ;
705 
706         curSector = getLBABase();
707 
708         devState = Prepare_Data_Dma;
709         action = ACT_DMA_READY;
710         break;
711 
712       default:
713         panic("Unsupported ATA command: %#x\n", cmdReg.command);
714     }
715 
716     if (action != ACT_NONE) {
717         // set the BSY bit
718         status |= STATUS_BSY_BIT;
719         // clear the DRQ bit
720         status &= ~STATUS_DRQ_BIT;
721         // clear the DF bit
722         status &= ~STATUS_DF_BIT;
723 
724         updateState(action);
725     }
726 }
\end{DoxyCode}
\hypertarget{classIdeDisk_a5f7be8f129b212ec5a0f25ce5c65dbd7}{
\index{IdeDisk@{IdeDisk}!startDma@{startDma}}
\index{startDma@{startDma}!IdeDisk@{IdeDisk}}
\subsubsection[{startDma}]{\setlength{\rightskip}{0pt plus 5cm}void startDma (const {\bf uint32\_\-t} \& {\em prdTableBase})}}
\label{classIdeDisk_a5f7be8f129b212ec5a0f25ce5c65dbd7}



\begin{DoxyCode}
591 {
592     if (dmaState != Dma_Start)
593         panic("Inconsistent DMA state, should be in Dma_Start!\n");
594 
595     if (devState != Transfer_Data_Dma)
596         panic("Inconsistent device state for DMA start!\n");
597 
598     // PRD base address is given by bits 31:2
599     curPrdAddr = pciToDma((Addr)(prdTableBase & ~ULL(0x3)));
600 
601     dmaState = Dma_Transfer;
602 
603     // schedule dma transfer (doDmaTransfer)
604     schedule(dmaTransferEvent, curTick() + 1);
605 }
\end{DoxyCode}
\hypertarget{classIdeDisk_af22e5d6d660b97db37003ac61ac4ee49}{
\index{IdeDisk@{IdeDisk}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!IdeDisk@{IdeDisk}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}private, virtual\mbox{]}}}}
\label{classIdeDisk_af22e5d6d660b97db37003ac61ac4ee49}
Reconstruct the state of this object from a checkpoint. 
\begin{DoxyParams}{引数}
\item[{\em \hyperlink{namespacecp}{cp}}]The checkpoint to use. \item[{\em section}]The section name describing this object. \end{DoxyParams}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。\hypertarget{classIdeDisk_a24fb6794cfae6f84b380080e7501959e}{
\index{IdeDisk@{IdeDisk}!updateState@{updateState}}
\index{updateState@{updateState}!IdeDisk@{IdeDisk}}
\subsubsection[{updateState}]{\setlength{\rightskip}{0pt plus 5cm}void updateState ({\bf DevAction\_\-t} {\em action})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a24fb6794cfae6f84b380080e7501959e}


\begin{Desc}
\item[\hyperlink{todo__todo000060}{TODO}]change this to a scheduled event to simulate disk delay \end{Desc}


\begin{Desc}
\item[\hyperlink{todo__todo000061}{TODO}]change this to a scheduled event to simulate disk delay \end{Desc}



\begin{DoxyCode}
767 {
768     switch (devState) {
769       case Device_Srst:
770         if (action == ACT_SRST_SET) {
771             // set the BSY bit
772             status |= STATUS_BSY_BIT;
773         } else if (action == ACT_SRST_CLEAR) {
774             // clear the BSY bit
775             status &= ~STATUS_BSY_BIT;
776 
777             // reset the device state
778             reset(devID);
779         }
780         break;
781 
782       case Device_Idle_S:
783         if (action == ACT_SELECT_WRITE && !isDEVSelect()) {
784             devState = Device_Idle_NS;
785         } else if (action == ACT_CMD_WRITE) {
786             startCommand();
787         }
788 
789         break;
790 
791       case Device_Idle_SI:
792         if (action == ACT_SELECT_WRITE && !isDEVSelect()) {
793             devState = Device_Idle_NS;
794             intrClear();
795         } else if (action == ACT_STAT_READ || isIENSet()) {
796             devState = Device_Idle_S;
797             intrClear();
798         } else if (action == ACT_CMD_WRITE) {
799             intrClear();
800             startCommand();
801         }
802 
803         break;
804 
805       case Device_Idle_NS:
806         if (action == ACT_SELECT_WRITE && isDEVSelect()) {
807             if (!isIENSet() && intrPending) {
808                 devState = Device_Idle_SI;
809                 intrPost();
810             }
811             if (isIENSet() || !intrPending) {
812                 devState = Device_Idle_S;
813             }
814         }
815         break;
816 
817       case Command_Execution:
818         if (action == ACT_CMD_COMPLETE) {
819             // clear the BSY bit
820             setComplete();
821 
822             if (!isIENSet()) {
823                 devState = Device_Idle_SI;
824                 intrPost();
825             } else {
826                 devState = Device_Idle_S;
827             }
828         }
829         break;
830 
831       case Prepare_Data_In:
832         if (action == ACT_CMD_ERROR) {
833             // clear the BSY bit
834             setComplete();
835 
836             if (!isIENSet()) {
837                 devState = Device_Idle_SI;
838                 intrPost();
839             } else {
840                 devState = Device_Idle_S;
841             }
842         } else if (action == ACT_DATA_READY) {
843             // clear the BSY bit
844             status &= ~STATUS_BSY_BIT;
845             // set the DRQ bit
846             status |= STATUS_DRQ_BIT;
847 
848             // copy the data into the data buffer
849             if (cmdReg.command == WDCC_IDENTIFY) {
850                 // Reset the drqBytes for this block
851                 drqBytesLeft = sizeof(struct ataparams);
852 
853                 memcpy((void *)dataBuffer, (void *)&driveID,
854                        sizeof(struct ataparams));
855             } else {
856                 // Reset the drqBytes for this block
857                 drqBytesLeft = SectorSize;
858 
859                 readDisk(curSector++, dataBuffer);
860             }
861 
862             // put the first two bytes into the data register
863             memcpy((void *)&cmdReg.data, (void *)dataBuffer,
864                    sizeof(uint16_t));
865 
866             if (!isIENSet()) {
867                 devState = Data_Ready_INTRQ_In;
868                 intrPost();
869             } else {
870                 devState = Transfer_Data_In;
871             }
872         }
873         break;
874 
875       case Data_Ready_INTRQ_In:
876         if (action == ACT_STAT_READ) {
877             devState = Transfer_Data_In;
878             intrClear();
879         }
880         break;
881 
882       case Transfer_Data_In:
883         if (action == ACT_DATA_READ_BYTE || action == ACT_DATA_READ_SHORT) {
884             if (action == ACT_DATA_READ_BYTE) {
885                 panic("DEBUG: READING DATA ONE BYTE AT A TIME!\n");
886             } else {
887                 drqBytesLeft -= 2;
888                 cmdBytesLeft -= 2;
889 
890                 // copy next short into data registers
891                 if (drqBytesLeft)
892                     memcpy((void *)&cmdReg.data,
893                            (void *)&dataBuffer[SectorSize - drqBytesLeft],
894                            sizeof(uint16_t));
895             }
896 
897             if (drqBytesLeft == 0) {
898                 if (cmdBytesLeft == 0) {
899                     // Clear the BSY bit
900                     setComplete();
901                     devState = Device_Idle_S;
902                 } else {
903                     devState = Prepare_Data_In;
904                     // set the BSY_BIT
905                     status |= STATUS_BSY_BIT;
906                     // clear the DRQ_BIT
907                     status &= ~STATUS_DRQ_BIT;
908 
911                     updateState(ACT_DATA_READY);
912                 }
913             }
914         }
915         break;
916 
917       case Prepare_Data_Out:
918         if (action == ACT_CMD_ERROR || cmdBytesLeft == 0) {
919             // clear the BSY bit
920             setComplete();
921 
922             if (!isIENSet()) {
923                 devState = Device_Idle_SI;
924                 intrPost();
925             } else {
926                 devState = Device_Idle_S;
927             }
928         } else if (action == ACT_DATA_READY && cmdBytesLeft != 0) {
929             // clear the BSY bit
930             status &= ~STATUS_BSY_BIT;
931             // set the DRQ bit
932             status |= STATUS_DRQ_BIT;
933 
934             // clear the data buffer to get it ready for writes
935             memset(dataBuffer, 0, MAX_DMA_SIZE);
936 
937             // reset the drqBytes for this block
938             drqBytesLeft = SectorSize;
939 
940             if (cmdBytesLeft == cmdBytes || isIENSet()) {
941                 devState = Transfer_Data_Out;
942             } else {
943                 devState = Data_Ready_INTRQ_Out;
944                 intrPost();
945             }
946         }
947         break;
948 
949       case Data_Ready_INTRQ_Out:
950         if (action == ACT_STAT_READ) {
951             devState = Transfer_Data_Out;
952             intrClear();
953         }
954         break;
955 
956       case Transfer_Data_Out:
957         if (action == ACT_DATA_WRITE_BYTE ||
958             action == ACT_DATA_WRITE_SHORT) {
959 
960             if (action == ACT_DATA_READ_BYTE) {
961                 panic("DEBUG: WRITING DATA ONE BYTE AT A TIME!\n");
962             } else {
963                 // copy the latest short into the data buffer
964                 memcpy((void *)&dataBuffer[SectorSize - drqBytesLeft],
965                        (void *)&cmdReg.data,
966                        sizeof(uint16_t));
967 
968                 drqBytesLeft -= 2;
969                 cmdBytesLeft -= 2;
970             }
971 
972             if (drqBytesLeft == 0) {
973                 // copy the block to the disk
974                 writeDisk(curSector++, dataBuffer);
975 
976                 // set the BSY bit
977                 status |= STATUS_BSY_BIT;
978                 // set the seek bit
979                 status |= STATUS_SEEK_BIT;
980                 // clear the DRQ bit
981                 status &= ~STATUS_DRQ_BIT;
982 
983                 devState = Prepare_Data_Out;
984 
987                 updateState(ACT_DATA_READY);
988             }
989         }
990         break;
991 
992       case Prepare_Data_Dma:
993         if (action == ACT_CMD_ERROR) {
994             // clear the BSY bit
995             setComplete();
996 
997             if (!isIENSet()) {
998                 devState = Device_Idle_SI;
999                 intrPost();
1000             } else {
1001                 devState = Device_Idle_S;
1002             }
1003         } else if (action == ACT_DMA_READY) {
1004             // clear the BSY bit
1005             status &= ~STATUS_BSY_BIT;
1006             // set the DRQ bit
1007             status |= STATUS_DRQ_BIT;
1008 
1009             devState = Transfer_Data_Dma;
1010 
1011             if (dmaState != Dma_Idle)
1012                 panic("Inconsistent DMA state, should be Dma_Idle\n");
1013 
1014             dmaState = Dma_Start;
1015             // wait for the write to the DMA start bit
1016         }
1017         break;
1018 
1019       case Transfer_Data_Dma:
1020         if (action == ACT_CMD_ERROR) {
1021             dmaAborted = true;
1022             devState = Device_Dma_Abort;
1023         } else if (action == ACT_DMA_DONE) {
1024             // clear the BSY bit
1025             setComplete();
1026             // set the seek bit
1027             status |= STATUS_SEEK_BIT;
1028             // clear the controller state for DMA transfer
1029             ctrl->setDmaComplete(this);
1030 
1031             if (!isIENSet()) {
1032                 devState = Device_Idle_SI;
1033                 intrPost();
1034             } else {
1035                 devState = Device_Idle_S;
1036             }
1037         }
1038         break;
1039 
1040       case Device_Dma_Abort:
1041         if (action == ACT_CMD_ERROR) {
1042             setComplete();
1043             status |= STATUS_SEEK_BIT;
1044             ctrl->setDmaComplete(this);
1045             dmaAborted = false;
1046             dmaState = Dma_Idle;
1047 
1048             if (!isIENSet()) {
1049                 devState = Device_Idle_SI;
1050                 intrPost();
1051             } else {
1052                 devState = Device_Idle_S;
1053             }
1054         } else {
1055             DPRINTF(IdeDisk, "Disk still busy aborting previous DMA command\n");
1056         }
1057         break;
1058 
1059       default:
1060         panic("Unknown IDE device state: %#x\n", devState);
1061     }
1062 }
\end{DoxyCode}
\hypertarget{classIdeDisk_af940c7b6408a2bb34bdd3580e8415da6}{
\index{IdeDisk@{IdeDisk}!writeCommand@{writeCommand}}
\index{writeCommand@{writeCommand}!IdeDisk@{IdeDisk}}
\subsubsection[{writeCommand}]{\setlength{\rightskip}{0pt plus 5cm}void writeCommand (const {\bf Addr} {\em offset}, \/  int {\em size}, \/  const uint8\_\-t $\ast$ {\em data})}}
\label{classIdeDisk_af940c7b6408a2bb34bdd3580e8415da6}



\begin{DoxyCode}
262 {
263     if (offset == DATA_OFFSET) {
264         if (size == sizeof(uint16_t)) {
265             cmdReg.data = *(const uint16_t *)data;
266         } else if (size == sizeof(uint32_t)) {
267             cmdReg.data = *(const uint16_t *)data;
268             updateState(ACT_DATA_WRITE_SHORT);
269             cmdReg.data = *((const uint16_t *)data + 1);
270         } else {
271             panic("Data write of unsupported size %d.\n", size);
272         }
273         updateState(ACT_DATA_WRITE_SHORT);
274         return;
275     }
276 
277     assert(size == sizeof(uint8_t));
278     switch (offset) {
279       case FEATURES_OFFSET:
280         break;
281       case NSECTOR_OFFSET:
282         cmdReg.sec_count = *data;
283         break;
284       case SECTOR_OFFSET:
285         cmdReg.sec_num = *data;
286         break;
287       case LCYL_OFFSET:
288         cmdReg.cyl_low = *data;
289         break;
290       case HCYL_OFFSET:
291         cmdReg.cyl_high = *data;
292         break;
293       case DRIVE_OFFSET:
294         cmdReg.drive = *data;
295         updateState(ACT_SELECT_WRITE);
296         break;
297       case COMMAND_OFFSET:
298         cmdReg.command = *data;
299         updateState(ACT_CMD_WRITE);
300         break;
301       default:
302         panic("Invalid IDE command register offset: %#x\n", offset);
303     }
304     DPRINTF(IdeDisk, "Write to disk at offset: %#x data %#x\n", offset,
305             (uint32_t)*data);
306 }
\end{DoxyCode}
\hypertarget{classIdeDisk_af8e7a0d1414a2f9b03e2e001e036e87b}{
\index{IdeDisk@{IdeDisk}!writeControl@{writeControl}}
\index{writeControl@{writeControl}!IdeDisk@{IdeDisk}}
\subsubsection[{writeControl}]{\setlength{\rightskip}{0pt plus 5cm}void writeControl (const {\bf Addr} {\em offset}, \/  int {\em size}, \/  const uint8\_\-t $\ast$ {\em data})}}
\label{classIdeDisk_af8e7a0d1414a2f9b03e2e001e036e87b}



\begin{DoxyCode}
310 {
311     if (offset != CONTROL_OFFSET)
312         panic("Invalid IDE control register offset: %#x\n", offset);
313 
314     if (*data & CONTROL_RST_BIT) {
315         // force the device into the reset state
316         devState = Device_Srst;
317         updateState(ACT_SRST_SET);
318     } else if (devState == Device_Srst && !(*data & CONTROL_RST_BIT)) {
319         updateState(ACT_SRST_CLEAR);
320     }
321 
322     nIENBit = *data & CONTROL_IEN_BIT;
323 
324     DPRINTF(IdeDisk, "Write to disk at offset: %#x data %#x\n", offset,
325             (uint32_t)*data);
326 }
\end{DoxyCode}
\hypertarget{classIdeDisk_aaf5688ef23ac188d55decc9021229d43}{
\index{IdeDisk@{IdeDisk}!writeDisk@{writeDisk}}
\index{writeDisk@{writeDisk}!IdeDisk@{IdeDisk}}
\subsubsection[{writeDisk}]{\setlength{\rightskip}{0pt plus 5cm}void writeDisk ({\bf uint32\_\-t} {\em sector}, \/  uint8\_\-t $\ast$ {\em data})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_aaf5688ef23ac188d55decc9021229d43}



\begin{DoxyCode}
577 {
578     uint32_t bytesWritten = image->write(data, sector);
579 
580     if (bytesWritten != SectorSize)
581         panic("Can't write to %s. Only %d of %d written. errno=%d\n",
582               name(), bytesWritten, SectorSize, errno);
583 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classIdeDisk_a576a5609a96330636252b99a5d689e36}{
\index{IdeDisk@{IdeDisk}!EventWrapper$<$ IdeDisk,\&IdeDisk::dmaPrdReadDone $>$@{EventWrapper$<$ IdeDisk,\&IdeDisk::dmaPrdReadDone $>$}}
\index{EventWrapper$<$ IdeDisk,\&IdeDisk::dmaPrdReadDone $>$@{EventWrapper$<$ IdeDisk,\&IdeDisk::dmaPrdReadDone $>$}!IdeDisk@{IdeDisk}}
\subsubsection[{EventWrapper$<$ IdeDisk,\&IdeDisk::dmaPrdReadDone $>$}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf EventWrapper}$<$ {\bf IdeDisk},\&IdeDisk::dmaPrdReadDone $>$\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classIdeDisk_a576a5609a96330636252b99a5d689e36}
\hypertarget{classIdeDisk_a6de24ef3cf489b4e2419c1ce290ea10f}{
\index{IdeDisk@{IdeDisk}!EventWrapper$<$ IdeDisk,\&IdeDisk::dmaReadDone $>$@{EventWrapper$<$ IdeDisk,\&IdeDisk::dmaReadDone $>$}}
\index{EventWrapper$<$ IdeDisk,\&IdeDisk::dmaReadDone $>$@{EventWrapper$<$ IdeDisk,\&IdeDisk::dmaReadDone $>$}!IdeDisk@{IdeDisk}}
\subsubsection[{EventWrapper$<$ IdeDisk,\&IdeDisk::dmaReadDone $>$}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf EventWrapper}$<$ {\bf IdeDisk},\&IdeDisk::dmaReadDone $>$\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classIdeDisk_a6de24ef3cf489b4e2419c1ce290ea10f}
\hypertarget{classIdeDisk_ad39ee160ecba74f2b017af931eec8c6c}{
\index{IdeDisk@{IdeDisk}!EventWrapper$<$ IdeDisk,\&IdeDisk::dmaWriteDone $>$@{EventWrapper$<$ IdeDisk,\&IdeDisk::dmaWriteDone $>$}}
\index{EventWrapper$<$ IdeDisk,\&IdeDisk::dmaWriteDone $>$@{EventWrapper$<$ IdeDisk,\&IdeDisk::dmaWriteDone $>$}!IdeDisk@{IdeDisk}}
\subsubsection[{EventWrapper$<$ IdeDisk,\&IdeDisk::dmaWriteDone $>$}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf EventWrapper}$<$ {\bf IdeDisk},\&IdeDisk::dmaWriteDone $>$\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classIdeDisk_ad39ee160ecba74f2b017af931eec8c6c}
\hypertarget{classIdeDisk_accdc7f0b6fabdd3d77c1b559d5145f1e}{
\index{IdeDisk@{IdeDisk}!EventWrapper$<$ IdeDisk,\&IdeDisk::doDmaRead $>$@{EventWrapper$<$ IdeDisk,\&IdeDisk::doDmaRead $>$}}
\index{EventWrapper$<$ IdeDisk,\&IdeDisk::doDmaRead $>$@{EventWrapper$<$ IdeDisk,\&IdeDisk::doDmaRead $>$}!IdeDisk@{IdeDisk}}
\subsubsection[{EventWrapper$<$ IdeDisk,\&IdeDisk::doDmaRead $>$}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf EventWrapper}$<$ {\bf IdeDisk},\&IdeDisk::doDmaRead $>$\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classIdeDisk_accdc7f0b6fabdd3d77c1b559d5145f1e}
\hypertarget{classIdeDisk_a07dd701b52fa01c73a9a70a11490190f}{
\index{IdeDisk@{IdeDisk}!EventWrapper$<$ IdeDisk,\&IdeDisk::doDmaTransfer $>$@{EventWrapper$<$ IdeDisk,\&IdeDisk::doDmaTransfer $>$}}
\index{EventWrapper$<$ IdeDisk,\&IdeDisk::doDmaTransfer $>$@{EventWrapper$<$ IdeDisk,\&IdeDisk::doDmaTransfer $>$}!IdeDisk@{IdeDisk}}
\subsubsection[{EventWrapper$<$ IdeDisk,\&IdeDisk::doDmaTransfer $>$}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf EventWrapper}$<$ {\bf IdeDisk},\&IdeDisk::doDmaTransfer $>$\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classIdeDisk_a07dd701b52fa01c73a9a70a11490190f}
\hypertarget{classIdeDisk_ab5b4eef2a93f5c96df001eac024301e2}{
\index{IdeDisk@{IdeDisk}!EventWrapper$<$ IdeDisk,\&IdeDisk::doDmaWrite $>$@{EventWrapper$<$ IdeDisk,\&IdeDisk::doDmaWrite $>$}}
\index{EventWrapper$<$ IdeDisk,\&IdeDisk::doDmaWrite $>$@{EventWrapper$<$ IdeDisk,\&IdeDisk::doDmaWrite $>$}!IdeDisk@{IdeDisk}}
\subsubsection[{EventWrapper$<$ IdeDisk,\&IdeDisk::doDmaWrite $>$}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf EventWrapper}$<$ {\bf IdeDisk},\&IdeDisk::doDmaWrite $>$\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classIdeDisk_ab5b4eef2a93f5c96df001eac024301e2}


\subsection{変数}
\hypertarget{classIdeDisk_a732862da3f80cd2b8eaba9425c8415f5}{
\index{IdeDisk@{IdeDisk}!cmdBytes@{cmdBytes}}
\index{cmdBytes@{cmdBytes}!IdeDisk@{IdeDisk}}
\subsubsection[{cmdBytes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf cmdBytes}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a732862da3f80cd2b8eaba9425c8415f5}
Number of bytes in command data transfer \hypertarget{classIdeDisk_a70940fc29adad666da15b3d4c11ac2ff}{
\index{IdeDisk@{IdeDisk}!cmdBytesLeft@{cmdBytesLeft}}
\index{cmdBytesLeft@{cmdBytesLeft}!IdeDisk@{IdeDisk}}
\subsubsection[{cmdBytesLeft}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf cmdBytesLeft}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a70940fc29adad666da15b3d4c11ac2ff}
Number of bytes left in command data transfer \hypertarget{classIdeDisk_a2d468138409fc099c81da8d9b62f1f0f}{
\index{IdeDisk@{IdeDisk}!cmdReg@{cmdReg}}
\index{cmdReg@{cmdReg}!IdeDisk@{IdeDisk}}
\subsubsection[{cmdReg}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CommandReg\_\-t} {\bf cmdReg}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a2d468138409fc099c81da8d9b62f1f0f}
Command block registers \hypertarget{classIdeDisk_a15da11d9f856cf2edfc6ed93e24ad0ea}{
\index{IdeDisk@{IdeDisk}!ctrl@{ctrl}}
\index{ctrl@{ctrl}!IdeDisk@{IdeDisk}}
\subsubsection[{ctrl}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IdeController}$\ast$ {\bf ctrl}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIdeDisk_a15da11d9f856cf2edfc6ed93e24ad0ea}
The IDE controller for this disk. \hypertarget{classIdeDisk_a550dda68894801d065c57391335a8590}{
\index{IdeDisk@{IdeDisk}!curPrd@{curPrd}}
\index{curPrd@{curPrd}!IdeDisk@{IdeDisk}}
\subsubsection[{curPrd}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PrdTableEntry} {\bf curPrd}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a550dda68894801d065c57391335a8590}
PRD entry \hypertarget{classIdeDisk_a13b6a0a9519069583d8648b3eafa0448}{
\index{IdeDisk@{IdeDisk}!curPrdAddr@{curPrdAddr}}
\index{curPrdAddr@{curPrdAddr}!IdeDisk@{IdeDisk}}
\subsubsection[{curPrdAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf curPrdAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a13b6a0a9519069583d8648b3eafa0448}
PRD table base address \hypertarget{classIdeDisk_af7d6af3e55b20feac31aac92469e56f3}{
\index{IdeDisk@{IdeDisk}!curSector@{curSector}}
\index{curSector@{curSector}!IdeDisk@{IdeDisk}}
\subsubsection[{curSector}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf curSector}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_af7d6af3e55b20feac31aac92469e56f3}
Current sector in access \hypertarget{classIdeDisk_a54aefba7f330b07a06f4c9447e582f09}{
\index{IdeDisk@{IdeDisk}!dataBuffer@{dataBuffer}}
\index{dataBuffer@{dataBuffer}!IdeDisk@{IdeDisk}}
\subsubsection[{dataBuffer}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t$\ast$ {\bf dataBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a54aefba7f330b07a06f4c9447e582f09}
Data buffer for transfers \hypertarget{classIdeDisk_a5f20adde61bc73f1275a1a35481a011d}{
\index{IdeDisk@{IdeDisk}!devID@{devID}}
\index{devID@{devID}!IdeDisk@{IdeDisk}}
\subsubsection[{devID}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf devID}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a5f20adde61bc73f1275a1a35481a011d}
\hyperlink{namespaceDevice}{Device} ID (master=0/slave=1) \hypertarget{classIdeDisk_a5fb52a264b2cccb6ccad92493dff5deb}{
\index{IdeDisk@{IdeDisk}!devState@{devState}}
\index{devState@{devState}!IdeDisk@{IdeDisk}}
\subsubsection[{devState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DevState\_\-t} {\bf devState}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a5fb52a264b2cccb6ccad92493dff5deb}
\hyperlink{namespaceDevice}{Device} state \hypertarget{classIdeDisk_af49c4a1e28104d83429a5ae73e388143}{
\index{IdeDisk@{IdeDisk}!diskDelay@{diskDelay}}
\index{diskDelay@{diskDelay}!IdeDisk@{IdeDisk}}
\subsubsection[{diskDelay}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf diskDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIdeDisk_af49c4a1e28104d83429a5ae73e388143}
The disk delay in microseconds. \hypertarget{classIdeDisk_aedff89f76b12103a29d22ef4de302236}{
\index{IdeDisk@{IdeDisk}!dmaAborted@{dmaAborted}}
\index{dmaAborted@{dmaAborted}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaAborted}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf dmaAborted}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_aedff89f76b12103a29d22ef4de302236}
DMA Aborted \hypertarget{classIdeDisk_aee6a35e547d828db5c3f993da6179be0}{
\index{IdeDisk@{IdeDisk}!dmaPrdReadEvent@{dmaPrdReadEvent}}
\index{dmaPrdReadEvent@{dmaPrdReadEvent}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaPrdReadEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf IdeDisk}, \&IdeDisk::dmaPrdReadDone$>$ {\bf dmaPrdReadEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_aee6a35e547d828db5c3f993da6179be0}
\hypertarget{classIdeDisk_a3f1cf4317e46c3c845d144c5e0334096}{
\index{IdeDisk@{IdeDisk}!dmaRead@{dmaRead}}
\index{dmaRead@{dmaRead}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaRead}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf dmaRead}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a3f1cf4317e46c3c845d144c5e0334096}
Dma transaction is a read \hypertarget{classIdeDisk_a01f4e9b11f3b49ac1cb6cbb6d51674c2}{
\index{IdeDisk@{IdeDisk}!dmaReadBytes@{dmaReadBytes}}
\index{dmaReadBytes@{dmaReadBytes}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaReadBytes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf dmaReadBytes}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a01f4e9b11f3b49ac1cb6cbb6d51674c2}
\hypertarget{classIdeDisk_aafb836a34095616e67256a58e31ca604}{
\index{IdeDisk@{IdeDisk}!dmaReadCG@{dmaReadCG}}
\index{dmaReadCG@{dmaReadCG}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaReadCG}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ChunkGenerator}$\ast$ {\bf dmaReadCG}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_aafb836a34095616e67256a58e31ca604}
\hypertarget{classIdeDisk_a7c5e1828543bec774a42b971376bb618}{
\index{IdeDisk@{IdeDisk}!dmaReadEvent@{dmaReadEvent}}
\index{dmaReadEvent@{dmaReadEvent}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaReadEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf IdeDisk}, \&IdeDisk::dmaReadDone$>$ {\bf dmaReadEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a7c5e1828543bec774a42b971376bb618}
\hypertarget{classIdeDisk_abab6bdef4c30741f3ec4b69e44e9d7c6}{
\index{IdeDisk@{IdeDisk}!dmaReadFullPages@{dmaReadFullPages}}
\index{dmaReadFullPages@{dmaReadFullPages}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaReadFullPages}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf dmaReadFullPages}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_abab6bdef4c30741f3ec4b69e44e9d7c6}
\hypertarget{classIdeDisk_a4310d460e8c2b5db635c0b2d1f1887a1}{
\index{IdeDisk@{IdeDisk}!dmaReadTxs@{dmaReadTxs}}
\index{dmaReadTxs@{dmaReadTxs}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaReadTxs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf dmaReadTxs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a4310d460e8c2b5db635c0b2d1f1887a1}
\hypertarget{classIdeDisk_a163b3ebdf005a99628b313b535697fb4}{
\index{IdeDisk@{IdeDisk}!dmaReadWaitEvent@{dmaReadWaitEvent}}
\index{dmaReadWaitEvent@{dmaReadWaitEvent}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaReadWaitEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf IdeDisk}, \&IdeDisk::doDmaRead$>$ {\bf dmaReadWaitEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a163b3ebdf005a99628b313b535697fb4}
\hypertarget{classIdeDisk_acdefad9ebc91ac85f00ff92347b944d7}{
\index{IdeDisk@{IdeDisk}!dmaState@{dmaState}}
\index{dmaState@{dmaState}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DmaState\_\-t} {\bf dmaState}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_acdefad9ebc91ac85f00ff92347b944d7}
Dma state \hypertarget{classIdeDisk_aa90327d610dcc75173d1cd63671c6d31}{
\index{IdeDisk@{IdeDisk}!dmaTransferEvent@{dmaTransferEvent}}
\index{dmaTransferEvent@{dmaTransferEvent}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaTransferEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf IdeDisk}, \&IdeDisk::doDmaTransfer$>$ {\bf dmaTransferEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_aa90327d610dcc75173d1cd63671c6d31}
\hypertarget{classIdeDisk_a59676f0552c89ab5f75ed2e6d8fca378}{
\index{IdeDisk@{IdeDisk}!dmaWriteBytes@{dmaWriteBytes}}
\index{dmaWriteBytes@{dmaWriteBytes}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaWriteBytes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf dmaWriteBytes}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a59676f0552c89ab5f75ed2e6d8fca378}
\hypertarget{classIdeDisk_a9efaedbad52401a1b8ac2b8f1dffd28e}{
\index{IdeDisk@{IdeDisk}!dmaWriteCG@{dmaWriteCG}}
\index{dmaWriteCG@{dmaWriteCG}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaWriteCG}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ChunkGenerator}$\ast$ {\bf dmaWriteCG}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a9efaedbad52401a1b8ac2b8f1dffd28e}
\hypertarget{classIdeDisk_a6c721e441022d80574b109229351326a}{
\index{IdeDisk@{IdeDisk}!dmaWriteEvent@{dmaWriteEvent}}
\index{dmaWriteEvent@{dmaWriteEvent}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaWriteEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf IdeDisk}, \&IdeDisk::dmaWriteDone$>$ {\bf dmaWriteEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a6c721e441022d80574b109229351326a}
\hypertarget{classIdeDisk_adca0399abe696c769a268759b7823090}{
\index{IdeDisk@{IdeDisk}!dmaWriteFullPages@{dmaWriteFullPages}}
\index{dmaWriteFullPages@{dmaWriteFullPages}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaWriteFullPages}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf dmaWriteFullPages}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_adca0399abe696c769a268759b7823090}
\hypertarget{classIdeDisk_a2bb232dff5f135210d3350a21d1c9ccf}{
\index{IdeDisk@{IdeDisk}!dmaWriteTxs@{dmaWriteTxs}}
\index{dmaWriteTxs@{dmaWriteTxs}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaWriteTxs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf dmaWriteTxs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a2bb232dff5f135210d3350a21d1c9ccf}
\hypertarget{classIdeDisk_ad35ded50a6e608571cb80f1ad9741514}{
\index{IdeDisk@{IdeDisk}!dmaWriteWaitEvent@{dmaWriteWaitEvent}}
\index{dmaWriteWaitEvent@{dmaWriteWaitEvent}!IdeDisk@{IdeDisk}}
\subsubsection[{dmaWriteWaitEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf IdeDisk}, \&IdeDisk::doDmaWrite$>$ {\bf dmaWriteWaitEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_ad35ded50a6e608571cb80f1ad9741514}
\hypertarget{classIdeDisk_ae8a5371b95892db84d2b7ecef320d8a9}{
\index{IdeDisk@{IdeDisk}!driveID@{driveID}}
\index{driveID@{driveID}!IdeDisk@{IdeDisk}}
\subsubsection[{driveID}]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf ataparams} {\bf driveID}\hspace{0.3cm}{\ttfamily  \mbox{[}read, private\mbox{]}}}}
\label{classIdeDisk_ae8a5371b95892db84d2b7ecef320d8a9}
Drive identification structure for this disk \hypertarget{classIdeDisk_a93e2e2892d126eac3ce8dbb514d44c31}{
\index{IdeDisk@{IdeDisk}!drqBytesLeft@{drqBytesLeft}}
\index{drqBytesLeft@{drqBytesLeft}!IdeDisk@{IdeDisk}}
\subsubsection[{drqBytesLeft}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf drqBytesLeft}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_a93e2e2892d126eac3ce8dbb514d44c31}
Number of bytes left in DRQ block \hypertarget{classIdeDisk_a86d47120637a95e3a6876c774d768030}{
\index{IdeDisk@{IdeDisk}!image@{image}}
\index{image@{image}!IdeDisk@{IdeDisk}}
\subsubsection[{image}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DiskImage}$\ast$ {\bf image}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIdeDisk_a86d47120637a95e3a6876c774d768030}
The image that contains the data of this disk. \hypertarget{classIdeDisk_aabb849037e6d1c429d270d7fd20e958f}{
\index{IdeDisk@{IdeDisk}!intrPending@{intrPending}}
\index{intrPending@{intrPending}!IdeDisk@{IdeDisk}}
\subsubsection[{intrPending}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf intrPending}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_aabb849037e6d1c429d270d7fd20e958f}
Interrupt pending \hypertarget{classIdeDisk_ad58649fd94c5f762267f1d7bf682f6ca}{
\index{IdeDisk@{IdeDisk}!nIENBit@{nIENBit}}
\index{nIENBit@{nIENBit}!IdeDisk@{IdeDisk}}
\subsubsection[{nIENBit}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf nIENBit}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_ad58649fd94c5f762267f1d7bf682f6ca}
Interrupt enable bit \hypertarget{classIdeDisk_ade818037fd6c985038ff29656089758d}{
\index{IdeDisk@{IdeDisk}!status@{status}}
\index{status@{status}!IdeDisk@{IdeDisk}}
\subsubsection[{status}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf status}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeDisk_ade818037fd6c985038ff29656089758d}
Status register 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/\hyperlink{ide__disk_8hh}{ide\_\-disk.hh}\item 
dev/\hyperlink{ide__disk_8cc}{ide\_\-disk.cc}\end{DoxyCompactItemize}
