\hypertarget{classBaseKvmCPU}{
\section{クラス BaseKvmCPU}
\label{classBaseKvmCPU}\index{BaseKvmCPU@{BaseKvmCPU}}
}


{\ttfamily \#include $<$base.hh$>$}BaseKvmCPUに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classBaseKvmCPU}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classBaseKvmCPU_1_1BaseKvmCPU}{BaseKvmCPU}
\item 
class \hyperlink{classBaseKvmCPU_1_1KVMCpuPort}{KVMCpuPort}
\item 
struct \hyperlink{structBaseKvmCPU_1_1TickEvent}{TickEvent}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classBaseKvmCPU_a9eb0b030bd0367a335c97b465d98f01c}{BaseKvmCPU} (BaseKvmCPUParams $\ast$params)
\item 
virtual \hyperlink{classBaseKvmCPU_abd186de5de7d9b8e90d2c1f08daf1ecd}{$\sim$BaseKvmCPU} ()
\item 
void \hyperlink{classBaseKvmCPU_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
void \hyperlink{classBaseKvmCPU_aecc7d8debf54990ffeaaed5bac7d7d81}{startup} ()
\item 
void \hyperlink{classBaseKvmCPU_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classBaseKvmCPU_a688ca491f5419c29fb81f8235ba1dc13}{serializeThread} (std::ostream \&os, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classBaseKvmCPU_a5122e6d6fdbdb3cb9ba72ae970f00a9e}{unserializeThread} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
unsigned int \hyperlink{classBaseKvmCPU_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)
\item 
void \hyperlink{classBaseKvmCPU_a8f020d3237536fe007fc488c4125c5d8}{drainResume} ()
\item 
void \hyperlink{classBaseKvmCPU_a05f299b443f8cc73a93d61572edc0218}{switchOut} ()
\item 
void \hyperlink{classBaseKvmCPU_a6ab19fbe58a682743f9e652e9777fdac}{takeOverFrom} (\hyperlink{classBaseCPU_1_1BaseCPU}{BaseCPU} $\ast$cpu)
\item 
void \hyperlink{classBaseKvmCPU_ae2e1ccebe596a180f8105d57f9a93645}{verifyMemoryMode} () const 
\item 
\hyperlink{classMasterPort}{MasterPort} \& \hyperlink{classBaseKvmCPU_a041a57fcad534c1bed3702a0f8f3a6b1}{getDataPort} ()
\item 
\hyperlink{classMasterPort}{MasterPort} \& \hyperlink{classBaseKvmCPU_ab8ce6baf7cb0aaaf4ca346896a86fa03}{getInstPort} ()
\item 
void \hyperlink{classBaseKvmCPU_ae674290a26ecbd622c5160e38e8a4fe9}{wakeup} ()
\item 
void \hyperlink{classBaseKvmCPU_ad7a501b28bdbe8b3e708cd1ef69ac191}{activateContext} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} thread\_\-num, \hyperlink{classCycles}{Cycles} delay)
\item 
void \hyperlink{classBaseKvmCPU_a1dad4c4d2c3df4ef367e14fcc973ce74}{suspendContext} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} thread\_\-num)
\item 
void \hyperlink{classBaseKvmCPU_a49259982c98a7959f39b77db5069fea0}{deallocateContext} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} thread\_\-num)
\item 
void \hyperlink{classBaseKvmCPU_ab39525f324a8a93139e17327f6ccde10}{haltContext} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} thread\_\-num)
\item 
\hyperlink{classThreadContext}{ThreadContext} $\ast$ \hyperlink{classBaseKvmCPU_a2199ea70043ddde97c86e49a656b7ba9}{getContext} (int tn)
\item 
\hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classBaseKvmCPU_a7e01d94bb5a6e15fa8c94bcdf276115d}{totalInsts} () const 
\item 
\hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classBaseKvmCPU_a76fa5df6827aaa8fc26deebad97d9e78}{totalOps} () const 
\item 
virtual void \hyperlink{classBaseKvmCPU_accd2600060dbaee3a3b41aed4034c63c}{dump} ()
\item 
void \hyperlink{classBaseKvmCPU_ae984a01dc23c52800f5fe28344f59b81}{kick} () const 
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSimpleThread}{SimpleThread} $\ast$ \hyperlink{classBaseKvmCPU_af9572fa907cd21b54cb14bd626010d39}{thread}
\item 
\hyperlink{classThreadContext}{ThreadContext} $\ast$ \hyperlink{classBaseKvmCPU_a4455a4759e69e5ebe68ae7298cbcc37d}{tc}
\item 
\hyperlink{classKvmVM}{KvmVM} \& \hyperlink{classBaseKvmCPU_a6b8ecd9ec419f0cbe3c1047be643fe08}{vm}
\item 
\hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classBaseKvmCPU_a4a8e80967bf91692eb1703752a8203b3}{ctrInsts}
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classBaseKvmCPU_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \{ \hyperlink{classBaseKvmCPU_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}{Idle}, 
\hyperlink{classBaseKvmCPU_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}{Running}, 
\hyperlink{classBaseKvmCPU_a67a0db04d321a74b7e7fcfd3f1a3f70ba30f0df86d1d54bb5ea7ee293977f73df}{RunningService}, 
\hyperlink{classBaseKvmCPU_a67a0db04d321a74b7e7fcfd3f1a3f70ba8d38f5f3c8c186646364b893e12e6ae0}{RunningServiceCompletion}
 \}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classBaseKvmCPU_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\item 
virtual uint64\_\-t \hyperlink{classBaseKvmCPU_abcad2a22057ba48360b17b978f694b48}{getHostCycles} () const 
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classBaseKvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}{kvmRun} (\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} ticks)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classBaseKvmCPU_a405afc17ad0dee3b816012ce909b2b6f}{kvmRunDrain} ()
\item 
struct kvm\_\-run $\ast$ \hyperlink{classBaseKvmCPU_ae544593d8bd3763ec6cf4cc7d0fd614b}{getKvmRunState} ()
\item 
uint8\_\-t $\ast$ \hyperlink{classBaseKvmCPU_a0e5c1a55b7cce45487f5778ee272acdf}{getGuestData} (uint64\_\-t offset) const 
\item 
void \hyperlink{group__KvmInterrupts_gabc700469cba2d4bba666902e552e7c2e}{kvmNonMaskableInterrupt} ()
\item 
void \hyperlink{group__KvmInterrupts_ga16b8f95e3f70098952604e6b8a121679}{kvmInterrupt} (const struct kvm\_\-interrupt \&interrupt)
\item 
std::string \hyperlink{classBaseKvmCPU_af080be5963a74cfafcfc1db16f294f1a}{getAndFormatOneReg} (uint64\_\-t id) const 
\item 
virtual bool \hyperlink{classBaseKvmCPU_a4ee4cbdc5d3315fd8016b44d3e77abd5}{archIsDrained} () const 
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classBaseKvmCPU_a1a68601eed760a2ebbe974e685901b60}{doMMIOAccess} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} paddr, void $\ast$data, int size, bool write)
\item 
int \hyperlink{group__KvmIoctl_ga106fe09b5e87d6c14884f8ffff7b338a}{ioctl} (int request, long p1) const 
\item 
int \hyperlink{group__KvmIoctl_ga89db87cb31fe2ba732de8fa68c8bd1f1}{ioctl} (int request, void $\ast$p1) const 
\item 
int \hyperlink{group__KvmIoctl_ga32cd3b0742689c29c9ab9e3e03feb5f2}{ioctl} (int request) const 
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classBaseKvmCPU_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \hyperlink{classBaseKvmCPU_a6cdf6e6db875a442f3ab6db542bd2bb5}{\_\-status}
\item 
\hyperlink{classBaseKvmCPU_1_1KVMCpuPort}{KVMCpuPort} \hyperlink{classBaseKvmCPU_a3f709bd88ed61bca6788f8cc3cda97cb}{dataPort}
\item 
\hyperlink{classBaseKvmCPU_1_1KVMCpuPort}{KVMCpuPort} \hyperlink{classBaseKvmCPU_a3d1157769fdf1f3b9566f70b9e7c30ea}{instPort}
\item 
\hyperlink{classRequest}{Request} \hyperlink{classBaseKvmCPU_a22caf021a7ece8d92e5ab612191b1b57}{mmio\_\-req}
\item 
bool \hyperlink{classBaseKvmCPU_a8d712456c8dd8a9842aa40a69dbc27dd}{threadContextDirty}
\item 
bool \hyperlink{classBaseKvmCPU_a32fdccc14987171c2381947096c363f1}{kvmStateDirty}
\item 
const long \hyperlink{classBaseKvmCPU_ac52bdf6886dcfd53068633de9ed83184}{vcpuID}
\item 
pthread\_\-t \hyperlink{classBaseKvmCPU_a8a181f878f7db2579a3a67dd2d8c5902}{vcpuThread}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classBaseKvmCPU_a2858df681aa95b652e3d371d56def5a3}{flushCoalescedMMIO} ()
\item 
void \hyperlink{classBaseKvmCPU_acae9fda1e38c2cd8a3d7c8659a4a66fa}{setupSignalHandler} ()
\item 
bool \hyperlink{classBaseKvmCPU_a8e9cbc5cd93017313960f88c346493ee}{discardPendingSignal} (int signum) const 
\item 
void \hyperlink{classBaseKvmCPU_abc1464ae4d17eb8f6ea86c6bb5f68532}{startupThread} ()
\item 
bool \hyperlink{classBaseKvmCPU_a250ca18dfc0316e340eaa2ec45d73c3e}{tryDrain} ()
\item 
void \hyperlink{classBaseKvmCPU_a745968f1246564028e5b3fd8dde0548d}{ioctlRun} ()
\item 
void \hyperlink{classBaseKvmCPU_a10bd071dda7c87970b3595b2d3c5408e}{setupInstStop} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classBaseKvmCPU_a6b91f8b5649b80e8424cebfa3047e1d0}{vcpuFD}
\item 
int \hyperlink{classBaseKvmCPU_a0915679bdc25b2c015f15996f6d4ff6d}{vcpuMMapSize}
\item 
struct kvm\_\-run $\ast$ \hyperlink{classBaseKvmCPU_ab174cc060c981cfd21406dc3797c8c6b}{\_\-kvmRun}
\item 
struct kvm\_\-coalesced\_\-mmio\_\-ring $\ast$ \hyperlink{classBaseKvmCPU_ad4e1bcd3f032d2921aa97aec1fc7a45c}{mmioRing}
\item 
const long \hyperlink{classBaseKvmCPU_a8386a4766759aabc32038300820a64aa}{pageSize}
\item 
\hyperlink{structBaseKvmCPU_1_1TickEvent}{TickEvent} \hyperlink{classBaseKvmCPU_aa36b8e894416f0ec98f701ab08f2ac22}{tickEvent}
\item 
std::unique\_\-ptr$<$ \hyperlink{classBaseKvmTimer}{BaseKvmTimer} $>$ \hyperlink{classBaseKvmCPU_a28c546a9aa908313559ed074632a0c37}{runTimer}
\item 
float \hyperlink{classBaseKvmCPU_a0ef366aa4bbbcdc2f7eeb7fcd3962dde}{hostFactor}
\item 
\hyperlink{classDrainManager}{DrainManager} $\ast$ \hyperlink{classBaseKvmCPU_a329b71fb934a93312ca0aacbf5a3f982}{drainManager}
\end{DoxyCompactItemize}
\label{_amgrpd41d8cd98f00b204e9800998ecf8427e}
 \begin{DoxyCompactItemize}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBaseKvmCPU_a302bf9a6fd3b54c46eb3e2bfb18a320e}{numInsts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBaseKvmCPU_a6184fcde9e075404315cd7c343054d30}{numVMExits}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBaseKvmCPU_a8ef83ba51e6ab5f5db813c16e3cebb1d}{numVMHalfEntries}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBaseKvmCPU_a6cdcd551476b4e8234d5bfd987218d88}{numExitSignal}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBaseKvmCPU_a4030a87068a8b133f5efabfc19f7542d}{numMMIO}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBaseKvmCPU_a99a92abe3f29c3d0f59af4e384a8fe7f}{numCoalescedMMIO}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBaseKvmCPU_ae3a09de1034e0294f5df0ce66d876727}{numIO}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBaseKvmCPU_a65e906b9e123036deb6bc8922ce53e96}{numHalt}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBaseKvmCPU_a5ff214621d200e4672d581b12832886a}{numInterrupts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBaseKvmCPU_a230908c23db440bfcee954fb8d72f269}{numHypercalls}
\item 
uint64\_\-t \hyperlink{classBaseKvmCPU_a9b8c93980540464141f0989b8258295b}{activeInstPeriod}
\item 
\hyperlink{classPerfKvmCounter}{PerfKvmCounter} \hyperlink{classBaseKvmCPU_a496c1c0ab30aeafdeeeede34db1edf45}{hwCycles}
\item 
\hyperlink{classPerfKvmCounter}{PerfKvmCounter} \hyperlink{classBaseKvmCPU_ab3360069d449c748e7b9efe5f6d427e9}{hwInstructions}
\item 
bool \hyperlink{classBaseKvmCPU_a569365e1361250361be1c3f703a52914}{perfControlledByTimer}
\item 
void \hyperlink{classBaseKvmCPU_a422ac5896dab3bae0379fa65831e3778}{getRegisters} (struct kvm\_\-regs \&regs) const 
\item 
void \hyperlink{classBaseKvmCPU_a104d34588afdf9e14607bad09f01bd53}{setRegisters} (const struct kvm\_\-regs \&regs)
\item 
void \hyperlink{classBaseKvmCPU_a5b5f3c0a541efb9b8567a5e835421c15}{getSpecialRegisters} (struct kvm\_\-sregs \&regs) const 
\item 
void \hyperlink{classBaseKvmCPU_aefaac43fa62903f42a68a637083d5f09}{setSpecialRegisters} (const struct kvm\_\-sregs \&regs)
\item 
void \hyperlink{classBaseKvmCPU_a9fdafd736b7b9ef041b6c3e4768a61d6}{getFPUState} (struct kvm\_\-fpu \&state) const 
\item 
void \hyperlink{classBaseKvmCPU_a31b5d1e73edb46a17fa0a8ddd29e7604}{setFPUState} (const struct kvm\_\-fpu \&state)
\item 
void \hyperlink{classBaseKvmCPU_ad96695f9596f808056054f3c2026b818}{setOneReg} (uint64\_\-t id, const void $\ast$addr)
\item 
void \hyperlink{classBaseKvmCPU_a0f8ff23affd5f22fc47c4d00e6d24979}{setOneReg} (uint64\_\-t id, uint64\_\-t value)
\item 
void \hyperlink{classBaseKvmCPU_ab70d563942fa831d4de5da7d94ba8064}{setOneReg} (uint64\_\-t id, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} value)
\item 
void \hyperlink{classBaseKvmCPU_ab5a47c64ebf5a4de2539c6f71f7acc51}{getOneReg} (uint64\_\-t id, void $\ast$addr) const 
\item 
uint64\_\-t \hyperlink{classBaseKvmCPU_a803c633f6b9fc380a376a5a6d2ca17ee}{getOneRegU64} (uint64\_\-t id) const 
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classBaseKvmCPU_abb51d3ccd07e153be4d5982c324a95bc}{getOneRegU32} (uint64\_\-t id) const 
\item 
virtual void \hyperlink{classBaseKvmCPU_a48817be7bf03ef44cc5114ecf4df9b27}{updateKvmState} ()=0
\item 
virtual void \hyperlink{classBaseKvmCPU_ac47bfb587580ca76050e0c9bc753c10d}{updateThreadContext} ()=0
\item 
void \hyperlink{classBaseKvmCPU_a5d4ee3823af24f9210efb370a4c8ce93}{syncThreadContext} ()
\item 
void \hyperlink{classBaseKvmCPU_a8633407bfc3732fef1f78ef60345873d}{syncKvmState} ()
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classBaseKvmCPU_ab7dc26d4e02dbccc343942dd7a3ed7d8}{handleKvmExit} ()
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classBaseKvmCPU_a404fbd80d6676724d026a932b2258dc7}{handleKvmExitIO} ()
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classBaseKvmCPU_a32523a85b6259326f71aea298ae96ff6}{handleKvmExitHypercall} ()
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classBaseKvmCPU_a405e34c9d079e8823ac2a1ca0e816a47}{handleKvmExitIRQWindowOpen} ()
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classBaseKvmCPU_a00e63a4b01cf730bba2c42ef852b0876}{handleKvmExitUnknown} ()
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classBaseKvmCPU_a9e36bfbe1df222d0ceeaa2f83ad8fa2b}{handleKvmExitException} ()
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classBaseKvmCPU_a0dfcd253bad58e13a071f638d6638b1e}{handleKvmExitFailEntry} ()
\item 
void \hyperlink{classBaseKvmCPU_a76bff52136628a5be57e6d1ea8ff5370}{setSignalMask} (const sigset\_\-t $\ast$mask)
\item 
void \hyperlink{classBaseKvmCPU_a9a2709df130ee7a63e53f9d65a0ebb36}{setupCounters} ()
\item 
void \hyperlink{classBaseKvmCPU_a807cad1db3257b823ffdb698c1e62a9a}{setupInstCounter} (uint64\_\-t period=0)
\end{DoxyCompactItemize}


\subsection{説明}
Base class for KVM based CPU models

All architecture specific KVM implementation should inherit from this class. The most basic CPU models only need to override the \hyperlink{classBaseKvmCPU_a48817be7bf03ef44cc5114ecf4df9b27}{updateKvmState()} and \hyperlink{classBaseKvmCPU_ac47bfb587580ca76050e0c9bc753c10d}{updateThreadContext()} methods to implement state synchronization between gem5 and KVM.

The architecture specific implementation is also responsible for delivering interrupts into the VM. This is typically done by overriding \hyperlink{classBaseKvmCPU_a873dd91783f9efb4a590aded1f70d6b0}{tick()} and checking the thread context before entering into the VM. In order to deliver an interrupt, the implementation then calls \hyperlink{group__KvmInterrupts_ga5037b917c47fff611ecdd5b547655284}{KvmVM::setIRQLine()} or \hyperlink{group__KvmInterrupts_ga16b8f95e3f70098952604e6b8a121679}{BaseKvmCPU::kvmInterrupt()} depending on the specifics of the underlying hardware/drivers. 

\subsection{列挙型}
\hypertarget{classBaseKvmCPU_a67a0db04d321a74b7e7fcfd3f1a3f70b}{
\index{BaseKvmCPU@{BaseKvmCPU}!Status@{Status}}
\index{Status@{Status}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{Status}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Status}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_a67a0db04d321a74b7e7fcfd3f1a3f70b}
\begin{center}

\begin{DoxyImageNoCaption}
  \mbox{\includegraphics{inline_dotgraph_1}}
\end{DoxyImageNoCaption}
\end{center}
 \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Idle@{Idle}!BaseKvmCPU@{BaseKvmCPU}}\index{BaseKvmCPU@{BaseKvmCPU}!Idle@{Idle}}\item[{\em 
\hypertarget{classBaseKvmCPU_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}{
Idle}
\label{classBaseKvmCPU_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}
}]Context not scheduled in KVM.

The CPU generally enters this state when the guest execute an instruction that halts the CPU (e.g., WFI on ARM or HLT on X86) if KVM traps this instruction. Ticks are not scheduled in this state.

\begin{DoxySeeAlso}{参照}
\hyperlink{classBaseKvmCPU_a1dad4c4d2c3df4ef367e14fcc973ce74}{suspendContext()} 
\end{DoxySeeAlso}
\index{Running@{Running}!BaseKvmCPU@{BaseKvmCPU}}\index{BaseKvmCPU@{BaseKvmCPU}!Running@{Running}}\item[{\em 
\hypertarget{classBaseKvmCPU_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}{
Running}
\label{classBaseKvmCPU_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}
}]Running normally.

This is the normal run state of the CPU. KVM will be entered next time \hyperlink{classBaseKvmCPU_a873dd91783f9efb4a590aded1f70d6b0}{tick()} is called. \index{RunningService@{RunningService}!BaseKvmCPU@{BaseKvmCPU}}\index{BaseKvmCPU@{BaseKvmCPU}!RunningService@{RunningService}}\item[{\em 
\hypertarget{classBaseKvmCPU_a67a0db04d321a74b7e7fcfd3f1a3f70ba30f0df86d1d54bb5ea7ee293977f73df}{
RunningService}
\label{classBaseKvmCPU_a67a0db04d321a74b7e7fcfd3f1a3f70ba30f0df86d1d54bb5ea7ee293977f73df}
}]Requiring service at the beginning of the next cycle.

The virtual machine has exited and requires service, \hyperlink{classBaseKvmCPU_a873dd91783f9efb4a590aded1f70d6b0}{tick()} will call \hyperlink{classBaseKvmCPU_ab7dc26d4e02dbccc343942dd7a3ed7d8}{handleKvmExit()} on the next cycle. The next state after running service is determined in \hyperlink{classBaseKvmCPU_ab7dc26d4e02dbccc343942dd7a3ed7d8}{handleKvmExit()} and depends on what kind of service the guest requested: 
\begin{DoxyItemize}
\item IO/MMIO: RunningServiceCompletion 
\item Halt: Idle 
\item Others: Running 
\end{DoxyItemize}\index{RunningServiceCompletion@{RunningServiceCompletion}!BaseKvmCPU@{BaseKvmCPU}}\index{BaseKvmCPU@{BaseKvmCPU}!RunningServiceCompletion@{RunningServiceCompletion}}\item[{\em 
\hypertarget{classBaseKvmCPU_a67a0db04d321a74b7e7fcfd3f1a3f70ba8d38f5f3c8c186646364b893e12e6ae0}{
RunningServiceCompletion}
\label{classBaseKvmCPU_a67a0db04d321a74b7e7fcfd3f1a3f70ba8d38f5f3c8c186646364b893e12e6ae0}
}]Service completion in progress.

The VM has requested service that requires KVM to be entered once in order to get to a consistent state. This happens in \hyperlink{classBaseKvmCPU_ab7dc26d4e02dbccc343942dd7a3ed7d8}{handleKvmExit()} or one of its friends after IO exits. After executing \hyperlink{classBaseKvmCPU_a873dd91783f9efb4a590aded1f70d6b0}{tick()}, the CPU will transition into the Running or RunningService state. \end{description}
\end{Desc}




\begin{DoxyCode}
169                 {
179         Idle,
185         Running,
198         RunningService,
207         RunningServiceCompletion,
208     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classBaseKvmCPU_a9eb0b030bd0367a335c97b465d98f01c}{
\index{BaseKvmCPU@{BaseKvmCPU}!BaseKvmCPU@{BaseKvmCPU}}
\index{BaseKvmCPU@{BaseKvmCPU}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{BaseKvmCPU}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseKvmCPU} (BaseKvmCPUParams $\ast$ {\em params})}}
\label{classBaseKvmCPU_a9eb0b030bd0367a335c97b465d98f01c}



\begin{DoxyCode}
67     : BaseCPU(params),
68       vm(*params->kvmVM),
69       _status(Idle),
70       dataPort(name() + ".dcache_port", this),
71       instPort(name() + ".icache_port", this),
72       threadContextDirty(true),
73       kvmStateDirty(false),
74       vcpuID(vm.allocVCPUID()), vcpuFD(-1), vcpuMMapSize(0),
75       _kvmRun(NULL), mmioRing(NULL),
76       pageSize(sysconf(_SC_PAGE_SIZE)),
77       tickEvent(*this),
78       activeInstPeriod(0),
79       perfControlledByTimer(params->usePerfOverflow),
80       hostFactor(params->hostFactor),
81       drainManager(NULL),
82       ctrInsts(0)
83 {
84     if (pageSize == -1)
85         panic("KVM: Failed to determine host page size (%i)\n",
86               errno);
87 
88     thread = new SimpleThread(this, 0, params->system,
89                               params->itb, params->dtb, params->isa[0]);
90     thread->setStatus(ThreadContext::Halted);
91     tc = thread->getTC();
92     threadContexts.push_back(tc);
93 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_abd186de5de7d9b8e90d2c1f08daf1ecd}{
\index{BaseKvmCPU@{BaseKvmCPU}!$\sim$BaseKvmCPU@{$\sim$BaseKvmCPU}}
\index{$\sim$BaseKvmCPU@{$\sim$BaseKvmCPU}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{$\sim$BaseKvmCPU}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf BaseKvmCPU} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classBaseKvmCPU_abd186de5de7d9b8e90d2c1f08daf1ecd}



\begin{DoxyCode}
96 {
97     if (_kvmRun)
98         munmap(_kvmRun, vcpuMMapSize);
99     close(vcpuFD);
100 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classBaseKvmCPU_ad7a501b28bdbe8b3e708cd1ef69ac191}{
\index{BaseKvmCPU@{BaseKvmCPU}!activateContext@{activateContext}}
\index{activateContext@{activateContext}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{activateContext}]{\setlength{\rightskip}{0pt plus 5cm}void activateContext ({\bf ThreadID} {\em thread\_\-num}, \/  {\bf Cycles} {\em delay})}}
\label{classBaseKvmCPU_ad7a501b28bdbe8b3e708cd1ef69ac191}



\begin{DoxyCode}
434 {
435     DPRINTF(Kvm, "ActivateContext %d (%d cycles)\n", thread_num, delay);
436 
437     assert(thread_num == 0);
438     assert(thread);
439 
440     assert(_status == Idle);
441     assert(!tickEvent.scheduled());
442 
443     numCycles += ticksToCycles(thread->lastActivate - thread->lastSuspend);
444 
445     schedule(tickEvent, clockEdge(delay));
446     _status = Running;
447 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a4ee4cbdc5d3315fd8016b44d3e77abd5}{
\index{BaseKvmCPU@{BaseKvmCPU}!archIsDrained@{archIsDrained}}
\index{archIsDrained@{archIsDrained}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{archIsDrained}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool archIsDrained () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classBaseKvmCPU_a4ee4cbdc5d3315fd8016b44d3e77abd5}
Is the architecture specific code in a state that prevents draining?

This method should return false if there are any pending events in the guest vCPU that won't be carried over to the gem5 state and thus will prevent correct checkpointing or CPU handover. It might, for example, check for pending interrupts that have been passed to the vCPU but not acknowledged by the OS. Architecures implementing this method {\itshape must\/} override \hyperlink{classBaseKvmCPU_a405afc17ad0dee3b816012ce909b2b6f}{kvmRunDrain()}.

\begin{DoxySeeAlso}{参照}
\hyperlink{classBaseKvmCPU_a405afc17ad0dee3b816012ce909b2b6f}{BaseKvmCPU::kvmRunDrain()}
\end{DoxySeeAlso}
\begin{DoxyReturn}{戻り値}
true if the vCPU is drained, false otherwise. 
\end{DoxyReturn}


\hyperlink{classX86KvmCPU_a1d97c7e0665d576bb463335078bb02ec}{X86KvmCPU}で再定義されています。


\begin{DoxyCode}
493 { return true; }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a49259982c98a7959f39b77db5069fea0}{
\index{BaseKvmCPU@{BaseKvmCPU}!deallocateContext@{deallocateContext}}
\index{deallocateContext@{deallocateContext}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{deallocateContext}]{\setlength{\rightskip}{0pt plus 5cm}void deallocateContext ({\bf ThreadID} {\em thread\_\-num})}}
\label{classBaseKvmCPU_a49259982c98a7959f39b77db5069fea0}



\begin{DoxyCode}
475 {
476     // for now, these are equivalent
477     suspendContext(thread_num);
478 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a8e9cbc5cd93017313960f88c346493ee}{
\index{BaseKvmCPU@{BaseKvmCPU}!discardPendingSignal@{discardPendingSignal}}
\index{discardPendingSignal@{discardPendingSignal}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{discardPendingSignal}]{\setlength{\rightskip}{0pt plus 5cm}bool discardPendingSignal (int {\em signum}) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_a8e9cbc5cd93017313960f88c346493ee}
Discard a (potentially) pending signal.


\begin{DoxyParams}{引数}
\item[{\em signum}]Signal to discard \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
true if the signal was pending, false otherwise. 
\end{DoxyReturn}



\begin{DoxyCode}
1128 {
1129     int discardedSignal;
1130 
1131     // Setting the timeout to zero causes sigtimedwait to return
1132     // immediately.
1133     struct timespec timeout;
1134     timeout.tv_sec = 0;
1135     timeout.tv_nsec = 0;
1136 
1137     sigset_t sigset;
1138     sigemptyset(&sigset);
1139     sigaddset(&sigset, signum);
1140 
1141     do {
1142         discardedSignal = sigtimedwait(&sigset, NULL, &timeout);
1143     } while (discardedSignal == -1 && errno == EINTR);
1144 
1145     if (discardedSignal == signum)
1146         return true;
1147     else if (discardedSignal == -1 && errno == EAGAIN)
1148         return false;
1149     else
1150         panic("Unexpected return value from sigtimedwait: %i (errno: %i)\n",
1151               discardedSignal, errno);
1152 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a1a68601eed760a2ebbe974e685901b60}{
\index{BaseKvmCPU@{BaseKvmCPU}!doMMIOAccess@{doMMIOAccess}}
\index{doMMIOAccess@{doMMIOAccess}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{doMMIOAccess}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} doMMIOAccess ({\bf Addr} {\em paddr}, \/  void $\ast$ {\em data}, \/  int {\em size}, \/  bool {\em write})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_a1a68601eed760a2ebbe974e685901b60}
Inject a memory mapped IO request into gem5


\begin{DoxyParams}{引数}
\item[{\em paddr}]Physical address \item[{\em data}]Pointer to the source/destination buffer \item[{\em size}]Memory access size \item[{\em write}]True if write, False if read \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Number of ticks spent servicing the memory access 
\end{DoxyReturn}



\begin{DoxyCode}
988 {
989     ThreadContext *tc(thread->getTC());
990     syncThreadContext();
991 
992     mmio_req.setPhys(paddr, size, Request::UNCACHEABLE, dataMasterId());
993     // Some architectures do need to massage physical addresses a bit
994     // before they are inserted into the memory system. This enables
995     // APIC accesses on x86 and m5ops where supported through a MMIO
996     // interface.
997     BaseTLB::Mode tlb_mode(write ? BaseTLB::Write : BaseTLB::Read);
998     Fault fault(tc->getDTBPtr()->finalizePhysical(&mmio_req, tc, tlb_mode));
999     if (fault != NoFault)
1000         warn("Finalization of MMIO address failed: %s\n", fault->name());
1001 
1002 
1003     const MemCmd cmd(write ? MemCmd::WriteReq : MemCmd::ReadReq);
1004     Packet pkt(&mmio_req, cmd);
1005     pkt.dataStatic(data);
1006 
1007     if (mmio_req.isMmappedIpr()) {
1008         // We currently assume that there is no need to migrate to a
1009         // different event queue when doing IPRs. Currently, IPRs are
1010         // only used for m5ops, so it should be a valid assumption.
1011         const Cycles ipr_delay(write ?
1012                              TheISA::handleIprWrite(tc, &pkt) :
1013                              TheISA::handleIprRead(tc, &pkt));
1014         return clockPeriod() * ipr_delay;
1015     } else {
1016         // Temporarily lock and migrate to the event queue of the
1017         // VM. This queue is assumed to "own" all devices we need to
1018         // access if running in multi-core mode.
1019         EventQueue::ScopedMigration migrate(vm.eventQueue());
1020 
1021         return dataPort.sendAtomic(&pkt);
1022     }
1023 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_aa8a18d230dba7a674ac8a0b4f35bc36a}{
\index{BaseKvmCPU@{BaseKvmCPU}!drain@{drain}}
\index{drain@{drain}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em dm})}}
\label{classBaseKvmCPU_aa8a18d230dba7a674ac8a0b4f35bc36a}


FALLTHROUGH 


\begin{DoxyCode}
284 {
285     if (switchedOut())
286         return 0;
287 
288     DPRINTF(Drain, "BaseKvmCPU::drain\n");
289     switch (_status) {
290       case Running:
291         // The base KVM code is normally ready when it is in the
292         // Running state, but the architecture specific code might be
293         // of a different opinion. This may happen when the CPU been
294         // notified of an event that hasn't been accepted by the vCPU
295         // yet.
296         if (!archIsDrained()) {
297             drainManager = dm;
298             return 1;
299         }
300 
301         // The state of the CPU is consistent, so we don't need to do
302         // anything special to drain it. We simply de-schedule the
303         // tick event and enter the Idle state to prevent nasty things
304         // like MMIOs from happening.
305         if (tickEvent.scheduled())
306             deschedule(tickEvent);
307         _status = Idle;
308 
310       case Idle:
311         // Idle, no need to drain
312         assert(!tickEvent.scheduled());
313 
314         // Sync the thread context here since we'll need it when we
315         // switch CPUs or checkpoint the CPU.
316         syncThreadContext();
317 
318         return 0;
319 
320       case RunningServiceCompletion:
321         // The CPU has just requested a service that was handled in
322         // the RunningService state, but the results have still not
323         // been reported to the CPU. Now, we /could/ probably just
324         // update the register state ourselves instead of letting KVM
325         // handle it, but that would be tricky. Instead, we enter KVM
326         // and let it do its stuff.
327         drainManager = dm;
328 
329         DPRINTF(Drain, "KVM CPU is waiting for service completion, "
330                 "requesting drain.\n");
331         return 1;
332 
333       case RunningService:
334         // We need to drain since the CPU is waiting for service (e.g., MMIOs)
335         drainManager = dm;
336 
337         DPRINTF(Drain, "KVM CPU is waiting for service, requesting drain.\n");
338         return 1;
339 
340       default:
341         panic("KVM: Unhandled CPU state in drain()\n");
342         return 0;
343     }
344 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a8f020d3237536fe007fc488c4125c5d8}{
\index{BaseKvmCPU@{BaseKvmCPU}!drainResume@{drainResume}}
\index{drainResume@{drainResume}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{drainResume}]{\setlength{\rightskip}{0pt plus 5cm}void drainResume ()}}
\label{classBaseKvmCPU_a8f020d3237536fe007fc488c4125c5d8}



\begin{DoxyCode}
348 {
349     assert(!tickEvent.scheduled());
350 
351     // We might have been switched out. In that case, we don't need to
352     // do anything.
353     if (switchedOut())
354         return;
355 
356     DPRINTF(Kvm, "drainResume\n");
357     verifyMemoryMode();
358 
359     // The tick event is de-scheduled as a part of the draining
360     // process. Re-schedule it if the thread context is active.
361     if (tc->status() == ThreadContext::Active) {
362         schedule(tickEvent, nextCycle());
363         _status = Running;
364     } else {
365         _status = Idle;
366     }
367 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_accd2600060dbaee3a3b41aed4034c63c}{
\index{BaseKvmCPU@{BaseKvmCPU}!dump@{dump}}
\index{dump@{dump}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{dump}]{\setlength{\rightskip}{0pt plus 5cm}void dump ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classBaseKvmCPU_accd2600060dbaee3a3b41aed4034c63c}
Dump the internal state to the terminal. 

\hyperlink{classArmKvmCPU_accd2600060dbaee3a3b41aed4034c63c}{ArmKvmCPU}, と \hyperlink{classX86KvmCPU_accd2600060dbaee3a3b41aed4034c63c}{X86KvmCPU}で再定義されています。


\begin{DoxyCode}
511 {
512     inform("State dumping not implemented.");
513 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a2858df681aa95b652e3d371d56def5a3}{
\index{BaseKvmCPU@{BaseKvmCPU}!flushCoalescedMMIO@{flushCoalescedMMIO}}
\index{flushCoalescedMMIO@{flushCoalescedMMIO}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{flushCoalescedMMIO}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} flushCoalescedMMIO ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_a2858df681aa95b652e3d371d56def5a3}
Service MMIO requests in the mmioRing.

\begin{DoxyReturn}{戻り値}
Number of ticks spent servicing the MMIO requests in the MMIO ring buffer 
\end{DoxyReturn}



\begin{DoxyCode}
1057 {
1058     if (!mmioRing)
1059         return 0;
1060 
1061     DPRINTF(KvmIO, "KVM: Flushing the coalesced MMIO ring buffer\n");
1062 
1063     // TODO: We might need to do synchronization when we start to
1064     // support multiple CPUs
1065     Tick ticks(0);
1066     while (mmioRing->first != mmioRing->last) {
1067         struct kvm_coalesced_mmio &ent(
1068             mmioRing->coalesced_mmio[mmioRing->first]);
1069 
1070         DPRINTF(KvmIO, "KVM: Handling coalesced MMIO (addr: 0x%x, len: %u)\n",
1071                 ent.phys_addr, ent.len);
1072 
1073         ++numCoalescedMMIO;
1074         ticks += doMMIOAccess(ent.phys_addr, ent.data, ent.len, true);
1075 
1076         mmioRing->first = (mmioRing->first + 1) % KVM_COALESCED_MMIO_MAX;
1077     }
1078 
1079     return ticks;
1080 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_af080be5963a74cfafcfc1db16f294f1a}{
\index{BaseKvmCPU@{BaseKvmCPU}!getAndFormatOneReg@{getAndFormatOneReg}}
\index{getAndFormatOneReg@{getAndFormatOneReg}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{getAndFormatOneReg}]{\setlength{\rightskip}{0pt plus 5cm}std::string getAndFormatOneReg (uint64\_\-t {\em id}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_af080be5963a74cfafcfc1db16f294f1a}
Get and format one register for printout.

This function call \hyperlink{classBaseKvmCPU_ab5a47c64ebf5a4de2539c6f71f7acc51}{getOneReg()} to retrieve the contents of one register and automatically formats it for printing.

\begin{DoxyNote}{覚え書き}
The presence of this call depends on \hyperlink{classKvm_af1ad3b73711f45008bcb240d012987f7}{Kvm::capOneReg()}. 
\end{DoxyNote}



\begin{DoxyCode}
802 {
803 #ifdef KVM_GET_ONE_REG
804     std::ostringstream ss;
805 
806     ss.setf(std::ios::hex, std::ios::basefield);
807     ss.setf(std::ios::showbase);
808 #define HANDLE_INTTYPE(len)                      \
809     case KVM_REG_SIZE_U ## len: {                \
810         uint ## len ## _t value;                 \
811         getOneReg(id, &value);                   \
812         ss << value;                             \
813     }  break
814 
815 #define HANDLE_ARRAY(len)                       \
816     case KVM_REG_SIZE_U ## len: {               \
817         uint8_t value[len / 8];                 \
818         getOneReg(id, value);                   \
819         ss << "[" << value[0];                  \
820         for (int i = 1; i < len  / 8; ++i)      \
821             ss << ", " << value[i];             \
822         ss << "]";                              \
823       } break
824 
825     switch (id & KVM_REG_SIZE_MASK) {
826         HANDLE_INTTYPE(8);
827         HANDLE_INTTYPE(16);
828         HANDLE_INTTYPE(32);
829         HANDLE_INTTYPE(64);
830         HANDLE_ARRAY(128);
831         HANDLE_ARRAY(256);
832         HANDLE_ARRAY(512);
833         HANDLE_ARRAY(1024);
834       default:
835         ss << "??";
836     }
837 
838 #undef HANDLE_INTTYPE
839 #undef HANDLE_ARRAY
840 
841     return ss.str();
842 #else
843     panic("KVM_GET_ONE_REG is unsupported on this platform.\n");
844 #endif
845 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a2199ea70043ddde97c86e49a656b7ba9}{
\index{BaseKvmCPU@{BaseKvmCPU}!getContext@{getContext}}
\index{getContext@{getContext}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{getContext}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadContext} $\ast$ getContext (int {\em tn})}}
\label{classBaseKvmCPU_a2199ea70043ddde97c86e49a656b7ba9}



\begin{DoxyCode}
489 {
490     assert(tn == 0);
491     syncThreadContext();
492     return tc;
493 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a041a57fcad534c1bed3702a0f8f3a6b1}{
\index{BaseKvmCPU@{BaseKvmCPU}!getDataPort@{getDataPort}}
\index{getDataPort@{getDataPort}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{getDataPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterPort}\& getDataPort ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseKvmCPU_a041a57fcad534c1bed3702a0f8f3a6b1}



\begin{DoxyCode}
99 { return dataPort; }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a9fdafd736b7b9ef041b6c3e4768a61d6}{
\index{BaseKvmCPU@{BaseKvmCPU}!getFPUState@{getFPUState}}
\index{getFPUState@{getFPUState}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{getFPUState}]{\setlength{\rightskip}{0pt plus 5cm}void getFPUState (struct kvm\_\-fpu \& {\em state}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_a9fdafd736b7b9ef041b6c3e4768a61d6}
Get/Set the guest FPU/vector state 


\begin{DoxyCode}
753 {
754     if (ioctl(KVM_GET_FPU, &state) == -1)
755         panic("KVM: Failed to get guest FPU state\n");
756 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a0e5c1a55b7cce45487f5778ee272acdf}{
\index{BaseKvmCPU@{BaseKvmCPU}!getGuestData@{getGuestData}}
\index{getGuestData@{getGuestData}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{getGuestData}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t$\ast$ getGuestData (uint64\_\-t {\em offset}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classBaseKvmCPU_a0e5c1a55b7cce45487f5778ee272acdf}
Retrieve a pointer to guest data stored at the end of the kvm\_\-run structure. This is mainly used for PIO operations (KVM\_\-EXIT\_\-IO).


\begin{DoxyParams}{引数}
\item[{\em offset}]Offset as specified by the kvm\_\-run structure \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Pointer to guest data 
\end{DoxyReturn}



\begin{DoxyCode}
289                                                  {
290         return (uint8_t *)_kvmRun + offset;
291     };
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_abcad2a22057ba48360b17b978f694b48}{
\index{BaseKvmCPU@{BaseKvmCPU}!getHostCycles@{getHostCycles}}
\index{getHostCycles@{getHostCycles}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{getHostCycles}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t getHostCycles () const\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBaseKvmCPU_abcad2a22057ba48360b17b978f694b48}
Get the value of the hardware cycle counter in the guest.

This method is supposed to return the total number of cycles executed in hardware mode relative to some arbitrary point in the past. It's mainly used when estimating the number of cycles actually executed by the CPU in \hyperlink{classBaseKvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}{kvmRun()}. The default behavior of this method is to use the cycles performance counter, but some architectures may want to use internal registers instead.

\begin{DoxyReturn}{戻り値}
Number of host cycles executed relative to an undefined point in the past. 
\end{DoxyReturn}


\hyperlink{classX86KvmCPU_abcad2a22057ba48360b17b978f694b48}{X86KvmCPU}で再定義されています。


\begin{DoxyCode}
608 {
609     return hwCycles.read();
610 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_ab8ce6baf7cb0aaaf4ca346896a86fa03}{
\index{BaseKvmCPU@{BaseKvmCPU}!getInstPort@{getInstPort}}
\index{getInstPort@{getInstPort}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{getInstPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterPort}\& getInstPort ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseKvmCPU_ab8ce6baf7cb0aaaf4ca346896a86fa03}



\begin{DoxyCode}
100 { return instPort; }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_ae544593d8bd3763ec6cf4cc7d0fd614b}{
\index{BaseKvmCPU@{BaseKvmCPU}!getKvmRunState@{getKvmRunState}}
\index{getKvmRunState@{getKvmRunState}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{getKvmRunState}]{\setlength{\rightskip}{0pt plus 5cm}struct kvm\_\-run$\ast$ getKvmRunState ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, read, protected\mbox{]}}}}
\label{classBaseKvmCPU_ae544593d8bd3763ec6cf4cc7d0fd614b}
Get a pointer to the kvm\_\-run structure containing all the input and output parameters from \hyperlink{classBaseKvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}{kvmRun()}. 


\begin{DoxyCode}
279 { return _kvmRun; };
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_ab5a47c64ebf5a4de2539c6f71f7acc51}{
\index{BaseKvmCPU@{BaseKvmCPU}!getOneReg@{getOneReg}}
\index{getOneReg@{getOneReg}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{getOneReg}]{\setlength{\rightskip}{0pt plus 5cm}void getOneReg (uint64\_\-t {\em id}, \/  void $\ast$ {\em addr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_ab5a47c64ebf5a4de2539c6f71f7acc51}



\begin{DoxyCode}
785 {
786 #ifdef KVM_GET_ONE_REG
787     struct kvm_one_reg reg;
788     reg.id = id;
789     reg.addr = (uint64_t)addr;
790 
791     if (ioctl(KVM_GET_ONE_REG, &reg) == -1) {
792         panic("KVM: Failed to get register (0x%x) value (errno: %i)\n",
793               id, errno);
794     }
795 #else
796     panic("KVM_GET_ONE_REG is unsupported on this platform.\n");
797 #endif
798 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_abb51d3ccd07e153be4d5982c324a95bc}{
\index{BaseKvmCPU@{BaseKvmCPU}!getOneRegU32@{getOneRegU32}}
\index{getOneRegU32@{getOneRegU32}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{getOneRegU32}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} getOneRegU32 (uint64\_\-t {\em id}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classBaseKvmCPU_abb51d3ccd07e153be4d5982c324a95bc}



\begin{DoxyCode}
357                                              {
358         uint32_t value;
359         getOneReg(id, &value);
360         return value;
361     }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a803c633f6b9fc380a376a5a6d2ca17ee}{
\index{BaseKvmCPU@{BaseKvmCPU}!getOneRegU64@{getOneRegU64}}
\index{getOneRegU64@{getOneRegU64}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{getOneRegU64}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t getOneRegU64 (uint64\_\-t {\em id}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classBaseKvmCPU_a803c633f6b9fc380a376a5a6d2ca17ee}



\begin{DoxyCode}
352                                              {
353         uint64_t value;
354         getOneReg(id, &value);
355         return value;
356     }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a422ac5896dab3bae0379fa65831e3778}{
\index{BaseKvmCPU@{BaseKvmCPU}!getRegisters@{getRegisters}}
\index{getRegisters@{getRegisters}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{getRegisters}]{\setlength{\rightskip}{0pt plus 5cm}void getRegisters (struct kvm\_\-regs \& {\em regs}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_a422ac5896dab3bae0379fa65831e3778}
Get/Set the register state of the guest vCPU

KVM has two different interfaces for accessing the state of the guest CPU. One interface updates 'normal' registers and one updates 'special' registers. The distinction between special and normal registers isn't very clear and is architecture dependent. 


\begin{DoxyCode}
725 {
726     if (ioctl(KVM_GET_REGS, &regs) == -1)
727         panic("KVM: Failed to get guest registers\n");
728 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a5b5f3c0a541efb9b8567a5e835421c15}{
\index{BaseKvmCPU@{BaseKvmCPU}!getSpecialRegisters@{getSpecialRegisters}}
\index{getSpecialRegisters@{getSpecialRegisters}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{getSpecialRegisters}]{\setlength{\rightskip}{0pt plus 5cm}void getSpecialRegisters (struct kvm\_\-sregs \& {\em regs}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_a5b5f3c0a541efb9b8567a5e835421c15}



\begin{DoxyCode}
739 {
740     if (ioctl(KVM_GET_SREGS, &regs) == -1)
741         panic("KVM: Failed to get guest special registers\n");
742 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_ab39525f324a8a93139e17327f6ccde10}{
\index{BaseKvmCPU@{BaseKvmCPU}!haltContext@{haltContext}}
\index{haltContext@{haltContext}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{haltContext}]{\setlength{\rightskip}{0pt plus 5cm}void haltContext ({\bf ThreadID} {\em thread\_\-num})}}
\label{classBaseKvmCPU_ab39525f324a8a93139e17327f6ccde10}



\begin{DoxyCode}
482 {
483     // for now, these are equivalent
484     suspendContext(thread_num);
485 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_ab7dc26d4e02dbccc343942dd7a3ed7d8}{
\index{BaseKvmCPU@{BaseKvmCPU}!handleKvmExit@{handleKvmExit}}
\index{handleKvmExit@{handleKvmExit}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{handleKvmExit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} handleKvmExit ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBaseKvmCPU_ab7dc26d4e02dbccc343942dd7a3ed7d8}
Main kvmRun exit handler, calls the relevant handleKvmExit$\ast$ depending on exit type.

\begin{DoxyReturn}{戻り値}
Number of ticks spent servicing the exit request 
\end{DoxyReturn}



\begin{DoxyCode}
873 {
874     DPRINTF(KvmRun, "handleKvmExit (exit_reason: %i)\n", _kvmRun->exit_reason);
875     assert(_status == RunningService);
876 
877     // Switch into the running state by default. Individual handlers
878     // can override this.
879     _status = Running;
880     switch (_kvmRun->exit_reason) {
881       case KVM_EXIT_UNKNOWN:
882         return handleKvmExitUnknown();
883 
884       case KVM_EXIT_EXCEPTION:
885         return handleKvmExitException();
886 
887       case KVM_EXIT_IO:
888         _status = RunningServiceCompletion;
889         ++numIO;
890         return handleKvmExitIO();
891 
892       case KVM_EXIT_HYPERCALL:
893         ++numHypercalls;
894         return handleKvmExitHypercall();
895 
896       case KVM_EXIT_HLT:
897         /* The guest has halted and is waiting for interrupts */
898         DPRINTF(Kvm, "handleKvmExitHalt\n");
899         ++numHalt;
900 
901         // Suspend the thread until the next interrupt arrives
902         thread->suspend();
903 
904         // This is actually ignored since the thread is suspended.
905         return 0;
906 
907       case KVM_EXIT_MMIO:
908         _status = RunningServiceCompletion;
909         /* Service memory mapped IO requests */
910         DPRINTF(KvmIO, "KVM: Handling MMIO (w: %u, addr: 0x%x, len: %u)\n",
911                 _kvmRun->mmio.is_write,
912                 _kvmRun->mmio.phys_addr, _kvmRun->mmio.len);
913 
914         ++numMMIO;
915         return doMMIOAccess(_kvmRun->mmio.phys_addr, _kvmRun->mmio.data,
916                             _kvmRun->mmio.len, _kvmRun->mmio.is_write);
917 
918       case KVM_EXIT_IRQ_WINDOW_OPEN:
919         return handleKvmExitIRQWindowOpen();
920 
921       case KVM_EXIT_FAIL_ENTRY:
922         return handleKvmExitFailEntry();
923 
924       case KVM_EXIT_INTR:
925         /* KVM was interrupted by a signal, restart it in the next
926          * tick. */
927         return 0;
928 
929       case KVM_EXIT_INTERNAL_ERROR:
930         panic("KVM: Internal error (suberror: %u)\n",
931               _kvmRun->internal.suberror);
932 
933       default:
934         dump();
935         panic("KVM: Unexpected exit (exit_reason: %u)\n", _kvmRun->exit_reason);
936     }
937 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a9e36bfbe1df222d0ceeaa2f83ad8fa2b}{
\index{BaseKvmCPU@{BaseKvmCPU}!handleKvmExitException@{handleKvmExitException}}
\index{handleKvmExitException@{handleKvmExitException}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{handleKvmExitException}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} handleKvmExitException ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBaseKvmCPU_a9e36bfbe1df222d0ceeaa2f83ad8fa2b}
An unhandled virtualization exception occured

Some KVM virtualization drivers return unhandled exceptions to the user-\/space monitor. This interface is currently only used by the Intel VMX KVM driver.

\begin{DoxyReturn}{戻り値}
Number of ticks delay the next CPU tick 
\end{DoxyReturn}



\begin{DoxyCode}
971 {
972     dump();
973     panic("KVM: Got exception when starting vCPU "
974           "(exception: %u, error_code: %u)\n",
975           _kvmRun->ex.exception, _kvmRun->ex.error_code);
976 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a0dfcd253bad58e13a071f638d6638b1e}{
\index{BaseKvmCPU@{BaseKvmCPU}!handleKvmExitFailEntry@{handleKvmExitFailEntry}}
\index{handleKvmExitFailEntry@{handleKvmExitFailEntry}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{handleKvmExitFailEntry}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} handleKvmExitFailEntry ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBaseKvmCPU_a0dfcd253bad58e13a071f638d6638b1e}
KVM failed to start the virtualized CPU

The kvm\_\-run data structure contains the hardware-\/specific error code.

\begin{DoxyReturn}{戻り値}
Number of ticks delay the next CPU tick 
\end{DoxyReturn}



\begin{DoxyCode}
980 {
981     dump();
982     panic("KVM: Failed to enter virtualized mode (hw reason: 0x%llx)\n",
983           _kvmRun->fail_entry.hardware_entry_failure_reason);
984 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a32523a85b6259326f71aea298ae96ff6}{
\index{BaseKvmCPU@{BaseKvmCPU}!handleKvmExitHypercall@{handleKvmExitHypercall}}
\index{handleKvmExitHypercall@{handleKvmExitHypercall}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{handleKvmExitHypercall}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} handleKvmExitHypercall ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBaseKvmCPU_a32523a85b6259326f71aea298ae96ff6}
The guest requested a monitor service using a hypercall

\begin{DoxyReturn}{戻り値}
Number of ticks spent servicing the hypercall 
\end{DoxyReturn}



\begin{DoxyCode}
949 {
950     panic("KVM: Unhandled hypercall\n");
951 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a404fbd80d6676724d026a932b2258dc7}{
\index{BaseKvmCPU@{BaseKvmCPU}!handleKvmExitIO@{handleKvmExitIO}}
\index{handleKvmExitIO@{handleKvmExitIO}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{handleKvmExitIO}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} handleKvmExitIO ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBaseKvmCPU_a404fbd80d6676724d026a932b2258dc7}
The guest performed a legacy IO request (out/inp on x86)

\begin{DoxyReturn}{戻り値}
Number of ticks spent servicing the IO request 
\end{DoxyReturn}


\hyperlink{classX86KvmCPU_a404fbd80d6676724d026a932b2258dc7}{X86KvmCPU}で再定義されています。


\begin{DoxyCode}
941 {
942     panic("KVM: Unhandled guest IO (dir: %i, size: %i, port: 0x%x, count: %i)\n",
      
943           _kvmRun->io.direction, _kvmRun->io.size,
944           _kvmRun->io.port, _kvmRun->io.count);
945 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a405e34c9d079e8823ac2a1ca0e816a47}{
\index{BaseKvmCPU@{BaseKvmCPU}!handleKvmExitIRQWindowOpen@{handleKvmExitIRQWindowOpen}}
\index{handleKvmExitIRQWindowOpen@{handleKvmExitIRQWindowOpen}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{handleKvmExitIRQWindowOpen}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} handleKvmExitIRQWindowOpen ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBaseKvmCPU_a405e34c9d079e8823ac2a1ca0e816a47}
The guest exited because an interrupt window was requested

The guest exited because an interrupt window was requested (request\_\-interrupt\_\-window in the kvm\_\-run structure was set to 1 before calling kvmRun) and it is now ready to receive

\begin{DoxyReturn}{戻り値}
Number of ticks spent servicing the IRQ 
\end{DoxyReturn}


\hyperlink{classX86KvmCPU_a405e34c9d079e8823ac2a1ca0e816a47}{X86KvmCPU}で再定義されています。


\begin{DoxyCode}
955 {
956     warn("KVM: Unhandled IRQ window.\n");
957     return 0;
958 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a00e63a4b01cf730bba2c42ef852b0876}{
\index{BaseKvmCPU@{BaseKvmCPU}!handleKvmExitUnknown@{handleKvmExitUnknown}}
\index{handleKvmExitUnknown@{handleKvmExitUnknown}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{handleKvmExitUnknown}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} handleKvmExitUnknown ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBaseKvmCPU_a00e63a4b01cf730bba2c42ef852b0876}
An unknown architecture dependent error occurred when starting the vCPU

The kvm\_\-run data structure contains the hardware error code. The defaults behavior of this method just prints the HW error code and panics. Architecture dependent implementations may want to override this method to provide better, hardware-\/aware, error messages.

\begin{DoxyReturn}{戻り値}
Number of ticks delay the next CPU tick 
\end{DoxyReturn}



\begin{DoxyCode}
963 {
964     dump();
965     panic("KVM: Unknown error when starting vCPU (hw reason: 0x%llx)\n",
966           _kvmRun->hw.hardware_exit_reason);
967 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{BaseKvmCPU@{BaseKvmCPU}!init@{init}}
\index{init@{init}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()}}
\label{classBaseKvmCPU_a02fd73d861ef2e4aabb38c0c9ff82947}



\begin{DoxyCode}
104 {
105     BaseCPU::init();
106 
107     if (numThreads != 1)
108         fatal("KVM: Multithreading not supported");
109 
110     tc->initMemProxies(tc);
111 
112     // initialize CPU, including PC
113     if (FullSystem && !switchedOut())
114         TheISA::initCPU(tc, tc->contextId());
115 
116     mmio_req.setThreadContext(tc->contextId(), 0);
117 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a745968f1246564028e5b3fd8dde0548d}{
\index{BaseKvmCPU@{BaseKvmCPU}!ioctlRun@{ioctlRun}}
\index{ioctlRun@{ioctlRun}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{ioctlRun}]{\setlength{\rightskip}{0pt plus 5cm}void ioctlRun ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_a745968f1246564028e5b3fd8dde0548d}
Execute the KVM\_\-RUN ioctl 


\begin{DoxyCode}
1210 {
1211     if (ioctl(KVM_RUN) == -1) {
1212         if (errno != EINTR)
1213             panic("KVM: Failed to start virtual CPU (errno: %i)\n",
1214                   errno);
1215     }
1216 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_ae984a01dc23c52800f5fe28344f59b81}{
\index{BaseKvmCPU@{BaseKvmCPU}!kick@{kick}}
\index{kick@{kick}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{kick}]{\setlength{\rightskip}{0pt plus 5cm}void kick () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseKvmCPU_ae984a01dc23c52800f5fe28344f59b81}
Force an exit from KVM.

Send a signal to the thread owning this vCPU to get it to exit from KVM. Ignored if the vCPU is not executing. 


\begin{DoxyCode}
122 { pthread_kill(vcpuThread, KVM_KICK_SIGNAL); }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}{
\index{BaseKvmCPU@{BaseKvmCPU}!kvmRun@{kvmRun}}
\index{kvmRun@{kvmRun}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{kvmRun}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} kvmRun ({\bf Tick} {\em ticks})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBaseKvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}
\hyperlink{classRequest}{Request} KVM to run the guest for a given number of ticks. The method returns the approximate number of ticks executed.

\begin{DoxyNote}{覚え書き}
The returned number of ticks can be both larger or smaller than the requested number of ticks. A smaller number can, for example, occur when the guest executes MMIO. A larger number is typically due to performance counter inaccuracies.

This method is virtual in order to allow implementations to check for architecture specific events (e.g., interrupts) before entering the VM.

It is the response of the caller (normally \hyperlink{classBaseKvmCPU_a873dd91783f9efb4a590aded1f70d6b0}{tick()}) to make sure that the KVM state is synchronized and that the TC is invalidated after entering KVM.

This method does not normally cause any state transitions. However, if it may suspend the CPU by suspending the thread, which leads to a transition to the Idle state. In such a case, kvm {\itshape must not\/} be entered.
\end{DoxyNote}

\begin{DoxyParams}{引数}
\item[{\em ticks}]Number of ticks to execute, set to 0 to exit immediately after finishing pending operations. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Number of ticks executed (see note) 
\end{DoxyReturn}


\hyperlink{classArmKvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}{ArmKvmCPU}, と \hyperlink{classX86KvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}{X86KvmCPU}で再定義されています。


\begin{DoxyCode}
614 {
615     Tick ticksExecuted;
616     DPRINTF(KvmRun, "KVM: Executing for %i ticks\n", ticks);
617 
618     if (ticks == 0) {
619         // Settings ticks == 0 is a special case which causes an entry
620         // into KVM that finishes pending operations (e.g., IO) and
621         // then immediately exits.
622         DPRINTF(KvmRun, "KVM: Delivering IO without full guest entry\n");
623 
624         ++numVMHalfEntries;
625 
626         // Send a KVM_KICK_SIGNAL to the vCPU thread (i.e., this
627         // thread). The KVM control signal is masked while executing
628         // in gem5 and gets unmasked temporarily as when entering
629         // KVM. See setSignalMask() and setupSignalHandler().
630         kick();
631 
632         // Start the vCPU. KVM will check for signals after completing
633         // pending operations (IO). Since the KVM_KICK_SIGNAL is
634         // pending, this forces an immediate exit to gem5 again. We
635         // don't bother to setup timers since this shouldn't actually
636         // execute any code (other than completing half-executed IO
637         // instructions) in the guest.
638         ioctlRun();
639 
640         // We always execute at least one cycle to prevent the
641         // BaseKvmCPU::tick() to be rescheduled on the same tick
642         // twice.
643         ticksExecuted = clockPeriod();
644     } else {
645         // This method is executed as a result of a tick event. That
646         // means that the event queue will be locked when entering the
647         // method. We temporarily unlock the event queue to allow
648         // other threads to steal control of this thread to inject
649         // interrupts. They will typically lock the queue and then
650         // force an exit from KVM by kicking the vCPU.
651         EventQueue::ScopedRelease release(curEventQueue());
652 
653         if (ticks < runTimer->resolution()) {
654             DPRINTF(KvmRun, "KVM: Adjusting tick count (%i -> %i)\n",
655                     ticks, runTimer->resolution());
656             ticks = runTimer->resolution();
657         }
658 
659         // Get hardware statistics after synchronizing contexts. The KVM
660         // state update might affect guest cycle counters.
661         uint64_t baseCycles(getHostCycles());
662         uint64_t baseInstrs(hwInstructions.read());
663 
664         // Arm the run timer and start the cycle timer if it isn't
665         // controlled by the overflow timer. Starting/stopping the cycle
666         // timer automatically starts the other perf timers as they are in
667         // the same counter group.
668         runTimer->arm(ticks);
669         if (!perfControlledByTimer)
670             hwCycles.start();
671 
672         ioctlRun();
673 
674         runTimer->disarm();
675         if (!perfControlledByTimer)
676             hwCycles.stop();
677 
678         // The control signal may have been delivered after we exited
679         // from KVM. It will be pending in that case since it is
680         // masked when we aren't executing in KVM. Discard it to make
681         // sure we don't deliver it immediately next time we try to
682         // enter into KVM.
683         discardPendingSignal(KVM_KICK_SIGNAL);
684 
685         const uint64_t hostCyclesExecuted(getHostCycles() - baseCycles);
686         const uint64_t simCyclesExecuted(hostCyclesExecuted * hostFactor);
687         const uint64_t instsExecuted(hwInstructions.read() - baseInstrs);
688         ticksExecuted = runTimer->ticksFromHostCycles(hostCyclesExecuted);
689 
690         /* Update statistics */
691         numCycles += simCyclesExecuted;;
692         numInsts += instsExecuted;
693         ctrInsts += instsExecuted;
694         system->totalNumInsts += instsExecuted;
695 
696         DPRINTF(KvmRun,
697                 "KVM: Executed %i instructions in %i cycles "
698                 "(%i ticks, sim cycles: %i).\n",
699                 instsExecuted, hostCyclesExecuted, ticksExecuted, simCyclesExecut
      ed);
700     }
701 
702     ++numVMExits;
703 
704     return ticksExecuted + flushCoalescedMMIO();
705 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a405afc17ad0dee3b816012ce909b2b6f}{
\index{BaseKvmCPU@{BaseKvmCPU}!kvmRunDrain@{kvmRunDrain}}
\index{kvmRunDrain@{kvmRunDrain}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{kvmRunDrain}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} kvmRunDrain ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBaseKvmCPU_a405afc17ad0dee3b816012ce909b2b6f}
\hyperlink{classRequest}{Request} the CPU to run until draining completes.

This function normally calls kvmRun(0) to make KVM finish pending MMIO operations. Architecures implementing \hyperlink{classBaseKvmCPU_a4ee4cbdc5d3315fd8016b44d3e77abd5}{archIsDrained()} must override this method.

\begin{DoxySeeAlso}{参照}
\hyperlink{classBaseKvmCPU_a4ee4cbdc5d3315fd8016b44d3e77abd5}{BaseKvmCPU::archIsDrained()}
\end{DoxySeeAlso}
\begin{DoxyReturn}{戻り値}
Number of ticks executed 
\end{DoxyReturn}


\hyperlink{classX86KvmCPU_a405afc17ad0dee3b816012ce909b2b6f}{X86KvmCPU}で再定義されています。


\begin{DoxyCode}
595 {
596     // By default, the only thing we need to drain is a pending IO
597     // operation which assumes that we are in the
598     // RunningServiceCompletion state.
599     assert(_status == RunningServiceCompletion);
600 
601     // Deliver the data from the pending IO operation and immediately
602     // exit.
603     return kvmRun(0);
604 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{BaseKvmCPU@{BaseKvmCPU}!regStats@{regStats}}
\index{regStats@{regStats}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()}}
\label{classBaseKvmCPU_a4dc637449366fcdfc4e764cdf12d9b11}



\begin{DoxyCode}
201 {
202     using namespace Stats;
203 
204     BaseCPU::regStats();
205 
206     numInsts
207         .name(name() + ".committedInsts")
208         .desc("Number of instructions committed")
209         ;
210 
211     numVMExits
212         .name(name() + ".numVMExits")
213         .desc("total number of KVM exits")
214         ;
215 
216     numVMHalfEntries
217         .name(name() + ".numVMHalfEntries")
218         .desc("number of KVM entries to finalize pending operations")
219         ;
220 
221     numExitSignal
222         .name(name() + ".numExitSignal")
223         .desc("exits due to signal delivery")
224         ;
225 
226     numMMIO
227         .name(name() + ".numMMIO")
228         .desc("number of VM exits due to memory mapped IO")
229         ;
230 
231     numCoalescedMMIO
232         .name(name() + ".numCoalescedMMIO")
233         .desc("number of coalesced memory mapped IO requests")
234         ;
235 
236     numIO
237         .name(name() + ".numIO")
238         .desc("number of VM exits due to legacy IO")
239         ;
240 
241     numHalt
242         .name(name() + ".numHalt")
243         .desc("number of VM exits due to wait for interrupt instructions")
244         ;
245 
246     numInterrupts
247         .name(name() + ".numInterrupts")
248         .desc("number of interrupts delivered")
249         ;
250 
251     numHypercalls
252         .name(name() + ".numHypercalls")
253         .desc("number of hypercalls")
254         ;
255 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a688ca491f5419c29fb81f8235ba1dc13}{
\index{BaseKvmCPU@{BaseKvmCPU}!serializeThread@{serializeThread}}
\index{serializeThread@{serializeThread}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{serializeThread}]{\setlength{\rightskip}{0pt plus 5cm}void serializeThread (std::ostream \& {\em os}, \/  {\bf ThreadID} {\em tid})}}
\label{classBaseKvmCPU_a688ca491f5419c29fb81f8235ba1dc13}



\begin{DoxyCode}
259 {
260     if (DTRACE(Checkpoint)) {
261         DPRINTF(Checkpoint, "KVM: Serializing thread %i:\n", tid);
262         dump();
263     }
264 
265     assert(tid == 0);
266     assert(_status == Idle);
267     thread->serialize(os);
268 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a31b5d1e73edb46a17fa0a8ddd29e7604}{
\index{BaseKvmCPU@{BaseKvmCPU}!setFPUState@{setFPUState}}
\index{setFPUState@{setFPUState}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{setFPUState}]{\setlength{\rightskip}{0pt plus 5cm}void setFPUState (const struct kvm\_\-fpu \& {\em state})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_a31b5d1e73edb46a17fa0a8ddd29e7604}



\begin{DoxyCode}
760 {
761     if (ioctl(KVM_SET_FPU, (void *)&state) == -1)
762         panic("KVM: Failed to set guest FPU state\n");
763 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_ab70d563942fa831d4de5da7d94ba8064}{
\index{BaseKvmCPU@{BaseKvmCPU}!setOneReg@{setOneReg}}
\index{setOneReg@{setOneReg}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{setOneReg}]{\setlength{\rightskip}{0pt plus 5cm}void setOneReg (uint64\_\-t {\em id}, \/  {\bf uint32\_\-t} {\em value})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classBaseKvmCPU_ab70d563942fa831d4de5da7d94ba8064}



\begin{DoxyCode}
350 { setOneReg(id, &value); }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a0f8ff23affd5f22fc47c4d00e6d24979}{
\index{BaseKvmCPU@{BaseKvmCPU}!setOneReg@{setOneReg}}
\index{setOneReg@{setOneReg}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{setOneReg}]{\setlength{\rightskip}{0pt plus 5cm}void setOneReg (uint64\_\-t {\em id}, \/  uint64\_\-t {\em value})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classBaseKvmCPU_a0f8ff23affd5f22fc47c4d00e6d24979}



\begin{DoxyCode}
349 { setOneReg(id, &value); }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_ad96695f9596f808056054f3c2026b818}{
\index{BaseKvmCPU@{BaseKvmCPU}!setOneReg@{setOneReg}}
\index{setOneReg@{setOneReg}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{setOneReg}]{\setlength{\rightskip}{0pt plus 5cm}void setOneReg (uint64\_\-t {\em id}, \/  const void $\ast$ {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_ad96695f9596f808056054f3c2026b818}
Get/Set single register using the KVM\_\-(SET$|$GET)\_\-ONE\_\-REG API.

\begin{DoxyNote}{覚え書き}
The presence of this call depends on \hyperlink{classKvm_af1ad3b73711f45008bcb240d012987f7}{Kvm::capOneReg()}. 
\end{DoxyNote}



\begin{DoxyCode}
768 {
769 #ifdef KVM_SET_ONE_REG
770     struct kvm_one_reg reg;
771     reg.id = id;
772     reg.addr = (uint64_t)addr;
773 
774     if (ioctl(KVM_SET_ONE_REG, &reg) == -1) {
775         panic("KVM: Failed to set register (0x%x) value (errno: %i)\n",
776               id, errno);
777     }
778 #else
779     panic("KVM_SET_ONE_REG is unsupported on this platform.\n");
780 #endif
781 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a104d34588afdf9e14607bad09f01bd53}{
\index{BaseKvmCPU@{BaseKvmCPU}!setRegisters@{setRegisters}}
\index{setRegisters@{setRegisters}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{setRegisters}]{\setlength{\rightskip}{0pt plus 5cm}void setRegisters (const struct kvm\_\-regs \& {\em regs})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_a104d34588afdf9e14607bad09f01bd53}



\begin{DoxyCode}
732 {
733     if (ioctl(KVM_SET_REGS, (void *)&regs) == -1)
734         panic("KVM: Failed to set guest registers\n");
735 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a76bff52136628a5be57e6d1ea8ff5370}{
\index{BaseKvmCPU@{BaseKvmCPU}!setSignalMask@{setSignalMask}}
\index{setSignalMask@{setSignalMask}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{setSignalMask}]{\setlength{\rightskip}{0pt plus 5cm}void setSignalMask (const sigset\_\-t $\ast$ {\em mask})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_a76bff52136628a5be57e6d1ea8ff5370}
\hyperlink{classSet}{Set} the signal mask used in \hyperlink{classBaseKvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}{kvmRun()}

This method allows the signal mask of the thread executing \hyperlink{classBaseKvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}{kvmRun()} to be overridden inside the actual system call. This allows us to mask timer signals used to force KVM exits while in gem5.

The signal mask can be disabled by setting it to NULL.


\begin{DoxyParams}{引数}
\item[{\em mask}]Signals to mask \end{DoxyParams}



\begin{DoxyCode}
1027 {
1028     std::unique_ptr<struct kvm_signal_mask> kvm_mask;
1029 
1030     if (mask) {
1031         kvm_mask.reset((struct kvm_signal_mask *)operator new(
1032                            sizeof(struct kvm_signal_mask) + sizeof(*mask)));
1033         // The kernel and the user-space headers have different ideas
1034         // about the size of sigset_t. This seems like a massive hack,
1035         // but is actually what qemu does.
1036         assert(sizeof(*mask) >= 8);
1037         kvm_mask->len = 8;
1038         memcpy(kvm_mask->sigset, mask, kvm_mask->len);
1039     }
1040 
1041     if (ioctl(KVM_SET_SIGNAL_MASK, (void *)kvm_mask.get()) == -1)
1042         panic("KVM: Failed to set vCPU signal mask (errno: %i)\n",
1043               errno);
1044 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_aefaac43fa62903f42a68a637083d5f09}{
\index{BaseKvmCPU@{BaseKvmCPU}!setSpecialRegisters@{setSpecialRegisters}}
\index{setSpecialRegisters@{setSpecialRegisters}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{setSpecialRegisters}]{\setlength{\rightskip}{0pt plus 5cm}void setSpecialRegisters (const struct kvm\_\-sregs \& {\em regs})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_aefaac43fa62903f42a68a637083d5f09}



\begin{DoxyCode}
746 {
747     if (ioctl(KVM_SET_SREGS, (void *)&regs) == -1)
748         panic("KVM: Failed to set guest special registers\n");
749 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a9a2709df130ee7a63e53f9d65a0ebb36}{
\index{BaseKvmCPU@{BaseKvmCPU}!setupCounters@{setupCounters}}
\index{setupCounters@{setupCounters}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{setupCounters}]{\setlength{\rightskip}{0pt plus 5cm}void setupCounters ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_a9a2709df130ee7a63e53f9d65a0ebb36}
Setup hardware performance counters 


\begin{DoxyCode}
1156 {
1157     DPRINTF(Kvm, "Attaching cycle counter...\n");
1158     PerfKvmCounterConfig cfgCycles(PERF_TYPE_HARDWARE,
1159                                 PERF_COUNT_HW_CPU_CYCLES);
1160     cfgCycles.disabled(true)
1161         .pinned(true);
1162 
1163     // Try to exclude the host. We set both exclude_hv and
1164     // exclude_host since different architectures use slightly
1165     // different APIs in the kernel.
1166     cfgCycles.exclude_hv(true)
1167         .exclude_host(true);
1168 
1169     if (perfControlledByTimer) {
1170         // We need to configure the cycles counter to send overflows
1171         // since we are going to use it to trigger timer signals that
1172         // trap back into m5 from KVM. In practice, this means that we
1173         // need to set some non-zero sample period that gets
1174         // overridden when the timer is armed.
1175         cfgCycles.wakeupEvents(1)
1176             .samplePeriod(42);
1177     }
1178 
1179     hwCycles.attach(cfgCycles,
1180                     0); // TID (0 => currentThread)
1181 
1182     setupInstCounter();
1183 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a807cad1db3257b823ffdb698c1e62a9a}{
\index{BaseKvmCPU@{BaseKvmCPU}!setupInstCounter@{setupInstCounter}}
\index{setupInstCounter@{setupInstCounter}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{setupInstCounter}]{\setlength{\rightskip}{0pt plus 5cm}void setupInstCounter (uint64\_\-t {\em period} = {\ttfamily 0})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_a807cad1db3257b823ffdb698c1e62a9a}
Setup the guest instruction counter.

Setup the guest instruction counter and optionally request a signal every N instructions executed by the guest. This method will re-\/attach the counter if the counter has already been attached and its sampling settings have changed.


\begin{DoxyParams}{引数}
\item[{\em period}]Signal period, set to 0 to disable signaling. \end{DoxyParams}



\begin{DoxyCode}
1233 {
1234     // No need to do anything if we aren't attaching for the first
1235     // time or the period isn't changing.
1236     if (period == activeInstPeriod && hwInstructions.attached())
1237         return;
1238 
1239     PerfKvmCounterConfig cfgInstructions(PERF_TYPE_HARDWARE,
1240                                          PERF_COUNT_HW_INSTRUCTIONS);
1241 
1242     // Try to exclude the host. We set both exclude_hv and
1243     // exclude_host since different architectures use slightly
1244     // different APIs in the kernel.
1245     cfgInstructions.exclude_hv(true)
1246         .exclude_host(true);
1247 
1248     if (period) {
1249         // Setup a sampling counter if that has been requested.
1250         cfgInstructions.wakeupEvents(1)
1251             .samplePeriod(period);
1252     }
1253 
1254     // We need to detach and re-attach the counter to reliably change
1255     // sampling settings. See PerfKvmCounter::period() for details.
1256     if (hwInstructions.attached())
1257         hwInstructions.detach();
1258     assert(hwCycles.attached());
1259     hwInstructions.attach(cfgInstructions,
1260                           0, // TID (0 => currentThread)
1261                           hwCycles);
1262 
1263     if (period)
1264         hwInstructions.enableSignals(KVM_KICK_SIGNAL);
1265 
1266     activeInstPeriod = period;
1267 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a10bd071dda7c87970b3595b2d3c5408e}{
\index{BaseKvmCPU@{BaseKvmCPU}!setupInstStop@{setupInstStop}}
\index{setupInstStop@{setupInstStop}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{setupInstStop}]{\setlength{\rightskip}{0pt plus 5cm}void setupInstStop ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_a10bd071dda7c87970b3595b2d3c5408e}
Setup an instruction break if there is one pending.

\hyperlink{classCheck}{Check} if there are pending instruction breaks in the CPU's instruction event queue and schedule an instruction break using PerfEvent.

\begin{DoxyNote}{覚え書き}
This method doesn't currently handle the main system instruction event queue. 
\end{DoxyNote}



\begin{DoxyCode}
1220 {
1221     if (comInstEventQueue[0]->empty()) {
1222         setupInstCounter(0);
1223     } else {
1224         const uint64_t next(comInstEventQueue[0]->nextTick());
1225 
1226         assert(next > ctrInsts);
1227         setupInstCounter(next - ctrInsts);
1228     }
1229 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_acae9fda1e38c2cd8a3d7c8659a4a66fa}{
\index{BaseKvmCPU@{BaseKvmCPU}!setupSignalHandler@{setupSignalHandler}}
\index{setupSignalHandler@{setupSignalHandler}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{setupSignalHandler}]{\setlength{\rightskip}{0pt plus 5cm}void setupSignalHandler ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_acae9fda1e38c2cd8a3d7c8659a4a66fa}
Setup a signal handler to catch the timer signal used to switch back to the monitor. 


\begin{DoxyCode}
1099 {
1100     struct sigaction sa;
1101 
1102     memset(&sa, 0, sizeof(sa));
1103     sa.sa_sigaction = onKickSignal;
1104     sa.sa_flags = SA_SIGINFO | SA_RESTART;
1105     if (sigaction(KVM_KICK_SIGNAL, &sa, NULL) == -1)
1106         panic("KVM: Failed to setup vCPU timer signal handler\n");
1107 
1108     sigset_t sigset;
1109     if (pthread_sigmask(SIG_BLOCK, NULL, &sigset) == -1)
1110         panic("KVM: Failed get signal mask\n");
1111 
1112     // Request KVM to setup the same signal mask as we're currently
1113     // running with except for the KVM control signal. We'll sometimes
1114     // need to raise the KVM_KICK_SIGNAL to cause immediate exits from
1115     // KVM after servicing IO requests. See kvmRun().
1116     sigdelset(&sigset, KVM_KICK_SIGNAL);
1117     setSignalMask(&sigset);
1118 
1119     // Mask our control signals so they aren't delivered unless we're
1120     // actually executing inside KVM.
1121     sigaddset(&sigset, KVM_KICK_SIGNAL);
1122     if (pthread_sigmask(SIG_SETMASK, &sigset, NULL) == -1)
1123         panic("KVM: Failed mask the KVM control signals\n");
1124 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_aecc7d8debf54990ffeaaed5bac7d7d81}{
\index{BaseKvmCPU@{BaseKvmCPU}!startup@{startup}}
\index{startup@{startup}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{startup}]{\setlength{\rightskip}{0pt plus 5cm}void startup ()}}
\label{classBaseKvmCPU_aecc7d8debf54990ffeaaed5bac7d7d81}


\hyperlink{classArmKvmCPU_aecc7d8debf54990ffeaaed5bac7d7d81}{ArmKvmCPU}, と \hyperlink{classX86KvmCPU_aecc7d8debf54990ffeaaed5bac7d7d81}{X86KvmCPU}で再定義されています。


\begin{DoxyCode}
121 {
122     const BaseKvmCPUParams * const p(
123         dynamic_cast<const BaseKvmCPUParams *>(params()));
124 
125     Kvm &kvm(vm.kvm);
126 
127     BaseCPU::startup();
128 
129     assert(vcpuFD == -1);
130 
131     // Tell the VM that a CPU is about to start.
132     vm.cpuStartup();
133 
134     // We can't initialize KVM CPUs in BaseKvmCPU::init() since we are
135     // not guaranteed that the parent KVM VM has initialized at that
136     // point. Initialize virtual CPUs here instead.
137     vcpuFD = vm.createVCPU(vcpuID);
138 
139     // Map the KVM run structure */
140     vcpuMMapSize = kvm.getVCPUMMapSize();
141     _kvmRun = (struct kvm_run *)mmap(0, vcpuMMapSize,
142                                      PROT_READ | PROT_WRITE, MAP_SHARED,
143                                      vcpuFD, 0);
144     if (_kvmRun == MAP_FAILED)
145         panic("KVM: Failed to map run data structure\n");
146 
147     // Setup a pointer to the MMIO ring buffer if coalesced MMIO is
148     // available. The offset into the KVM's communication page is
149     // provided by the coalesced MMIO capability.
150     int mmioOffset(kvm.capCoalescedMMIO());
151     if (!p->useCoalescedMMIO) {
152         inform("KVM: Coalesced MMIO disabled by config.\n");
153     } else if (mmioOffset) {
154         inform("KVM: Coalesced IO available\n");
155         mmioRing = (struct kvm_coalesced_mmio_ring *)(
156             (char *)_kvmRun + (mmioOffset * pageSize));
157     } else {
158         inform("KVM: Coalesced not supported by host OS\n");
159     }
160 
161     thread->startup();
162 
163     Event *startupEvent(
164         new EventWrapper<BaseKvmCPU,
165                          &BaseKvmCPU::startupThread>(this, true));
166     schedule(startupEvent, curTick());
167 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_abc1464ae4d17eb8f6ea86c6bb5f68532}{
\index{BaseKvmCPU@{BaseKvmCPU}!startupThread@{startupThread}}
\index{startupThread@{startupThread}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{startupThread}]{\setlength{\rightskip}{0pt plus 5cm}void startupThread ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_abc1464ae4d17eb8f6ea86c6bb5f68532}
Thread-\/specific initialization.

Some KVM-\/related initialization requires us to know the TID of the thread that is going to execute our event queue. For example, when setting up timers, we need to know the TID of the thread executing in KVM in order to deliver the timer signal to that thread. This method is called as the first event in this SimObject's event queue.

\begin{DoxySeeAlso}{参照}
\hyperlink{classBaseKvmCPU_aecc7d8debf54990ffeaaed5bac7d7d81}{startup} 
\end{DoxySeeAlso}



\begin{DoxyCode}
171 {
172     // Do thread-specific initialization. We need to setup signal
173     // delivery for counters and timers from within the thread that
174     // will execute the event queue to ensure that signals are
175     // delivered to the right threads.
176     const BaseKvmCPUParams * const p(
177         dynamic_cast<const BaseKvmCPUParams *>(params()));
178 
179     vcpuThread = pthread_self();
180 
181     // Setup signal handlers. This has to be done after the vCPU is
182     // created since it manipulates the vCPU signal mask.
183     setupSignalHandler();
184 
185     setupCounters();
186 
187     if (p->usePerfOverflow)
188         runTimer.reset(new PerfKvmTimer(hwCycles,
189                                         KVM_KICK_SIGNAL,
190                                         p->hostFactor,
191                                         p->hostFreq));
192     else
193         runTimer.reset(new PosixKvmTimer(KVM_KICK_SIGNAL, CLOCK_MONOTONIC,
194                                          p->hostFactor,
195                                          p->hostFreq));
196 
197 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a1dad4c4d2c3df4ef367e14fcc973ce74}{
\index{BaseKvmCPU@{BaseKvmCPU}!suspendContext@{suspendContext}}
\index{suspendContext@{suspendContext}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{suspendContext}]{\setlength{\rightskip}{0pt plus 5cm}void suspendContext ({\bf ThreadID} {\em thread\_\-num})}}
\label{classBaseKvmCPU_a1dad4c4d2c3df4ef367e14fcc973ce74}



\begin{DoxyCode}
452 {
453     DPRINTF(Kvm, "SuspendContext %d\n", thread_num);
454 
455     assert(thread_num == 0);
456     assert(thread);
457 
458     if (_status == Idle)
459         return;
460 
461     assert(_status == Running);
462 
463     // The tick event may no be scheduled if the quest has requested
464     // the monitor to wait for interrupts. The normal CPU models can
465     // get their tick events descheduled by quiesce instructions, but
466     // that can't happen here.
467     if (tickEvent.scheduled())
468         deschedule(tickEvent);
469 
470     _status = Idle;
471 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a05f299b443f8cc73a93d61572edc0218}{
\index{BaseKvmCPU@{BaseKvmCPU}!switchOut@{switchOut}}
\index{switchOut@{switchOut}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{switchOut}]{\setlength{\rightskip}{0pt plus 5cm}void switchOut ()}}
\label{classBaseKvmCPU_a05f299b443f8cc73a93d61572edc0218}



\begin{DoxyCode}
371 {
372     DPRINTF(Kvm, "switchOut\n");
373 
374     BaseCPU::switchOut();
375 
376     // We should have drained prior to executing a switchOut, which
377     // means that the tick event shouldn't be scheduled and the CPU is
378     // idle.
379     assert(!tickEvent.scheduled());
380     assert(_status == Idle);
381 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a8633407bfc3732fef1f78ef60345873d}{
\index{BaseKvmCPU@{BaseKvmCPU}!syncKvmState@{syncKvmState}}
\index{syncKvmState@{syncKvmState}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{syncKvmState}]{\setlength{\rightskip}{0pt plus 5cm}void syncKvmState ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_a8633407bfc3732fef1f78ef60345873d}
Update the KVM if the thread context is dirty. 


\begin{DoxyCode}
861 {
862     if (!threadContextDirty)
863         return;
864 
865     assert(!kvmStateDirty);
866 
867     updateKvmState();
868     threadContextDirty = false;
869 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a5d4ee3823af24f9210efb370a4c8ce93}{
\index{BaseKvmCPU@{BaseKvmCPU}!syncThreadContext@{syncThreadContext}}
\index{syncThreadContext@{syncThreadContext}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{syncThreadContext}]{\setlength{\rightskip}{0pt plus 5cm}void syncThreadContext ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_a5d4ee3823af24f9210efb370a4c8ce93}
Update a thread context if the KVM state is dirty with respect to the cached thread context. 


\begin{DoxyCode}
849 {
850     if (!kvmStateDirty)
851         return;
852 
853     assert(!threadContextDirty);
854 
855     updateThreadContext();
856     kvmStateDirty = false;
857 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a6ab19fbe58a682743f9e652e9777fdac}{
\index{BaseKvmCPU@{BaseKvmCPU}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ({\bf BaseCPU} $\ast$ {\em cpu})}}
\label{classBaseKvmCPU_a6ab19fbe58a682743f9e652e9777fdac}
\hypertarget{classBaseKvmCPU_a873dd91783f9efb4a590aded1f70d6b0}{
\index{BaseKvmCPU@{BaseKvmCPU}!tick@{tick}}
\index{tick@{tick}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_a873dd91783f9efb4a590aded1f70d6b0}
Execute the CPU until the next event in the main event queue or until the guest needs service from gem5. 


\begin{DoxyCode}
517 {
518     Tick delay(0);
519     assert(_status != Idle);
520 
521     switch (_status) {
522       case RunningService:
523         // handleKvmExit() will determine the next state of the CPU
524         delay = handleKvmExit();
525 
526         if (tryDrain())
527             _status = Idle;
528         break;
529 
530       case RunningServiceCompletion:
531       case Running: {
532           EventQueue *q = curEventQueue();
533           Tick ticksToExecute(q->nextTick() - curTick());
534 
535           // We might need to update the KVM state.
536           syncKvmState();
537 
538           // Setup any pending instruction count breakpoints using
539           // PerfEvent.
540           setupInstStop();
541 
542           DPRINTF(KvmRun, "Entering KVM...\n");
543           if (drainManager) {
544               // Force an immediate exit from KVM after completing
545               // pending operations. The architecture-specific code
546               // takes care to run until it is in a state where it can
547               // safely be drained.
548               delay = kvmRunDrain();
549           } else {
550               delay = kvmRun(ticksToExecute);
551           }
552 
553           // The CPU might have been suspended before entering into
554           // KVM. Assume that the CPU was suspended /before/ entering
555           // into KVM and skip the exit handling.
556           if (_status == Idle)
557               break;
558 
559           // Entering into KVM implies that we'll have to reload the thread
560           // context from KVM if we want to access it. Flag the KVM state as
561           // dirty with respect to the cached thread context.
562           kvmStateDirty = true;
563 
564           // Enter into the RunningService state unless the
565           // simulation was stopped by a timer.
566           if (_kvmRun->exit_reason !=  KVM_EXIT_INTR) {
567               _status = RunningService;
568           } else {
569               ++numExitSignal;
570               _status = Running;
571           }
572 
573           // Service any pending instruction events. The vCPU should
574           // have exited in time for the event using the instruction
575           // counter configured by setupInstStop().
576           comInstEventQueue[0]->serviceEvents(ctrInsts);
577           system->instEventQueue.serviceEvents(system->totalNumInsts);
578 
579           if (tryDrain())
580               _status = Idle;
581       } break;
582 
583       default:
584         panic("BaseKvmCPU entered tick() in an illegal state (%i)\n",
585               _status);
586     }
587 
588     // Schedule a new tick if we are still running
589     if (_status != Idle)
590         schedule(tickEvent, clockEdge(ticksToCycles(delay)));
591 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a7e01d94bb5a6e15fa8c94bcdf276115d}{
\index{BaseKvmCPU@{BaseKvmCPU}!totalInsts@{totalInsts}}
\index{totalInsts@{totalInsts}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{totalInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Counter} totalInsts () const}}
\label{classBaseKvmCPU_a7e01d94bb5a6e15fa8c94bcdf276115d}



\begin{DoxyCode}
498 {
499     return ctrInsts;
500 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a76fa5df6827aaa8fc26deebad97d9e78}{
\index{BaseKvmCPU@{BaseKvmCPU}!totalOps@{totalOps}}
\index{totalOps@{totalOps}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{totalOps}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Counter} totalOps () const}}
\label{classBaseKvmCPU_a76fa5df6827aaa8fc26deebad97d9e78}



\begin{DoxyCode}
504 {
505     hack_once("Pretending totalOps is equivalent to totalInsts()\n");
506     return ctrInsts;
507 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a250ca18dfc0316e340eaa2ec45d73c3e}{
\index{BaseKvmCPU@{BaseKvmCPU}!tryDrain@{tryDrain}}
\index{tryDrain@{tryDrain}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{tryDrain}]{\setlength{\rightskip}{0pt plus 5cm}bool tryDrain ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_a250ca18dfc0316e340eaa2ec45d73c3e}
Try to drain the CPU if a drain is pending 


\begin{DoxyCode}
1187 {
1188     if (!drainManager)
1189         return false;
1190 
1191     if (!archIsDrained()) {
1192         DPRINTF(Drain, "tryDrain: Architecture code is not ready.\n");
1193         return false;
1194     }
1195 
1196     if (_status == Idle || _status == Running) {
1197         DPRINTF(Drain,
1198                 "tryDrain: CPU transitioned into the Idle state, drain done\n");
1199         drainManager->signalDrainDone();
1200         drainManager = NULL;
1201         return true;
1202     } else {
1203         DPRINTF(Drain, "tryDrain: CPU not ready.\n");
1204         return false;
1205     }
1206 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a5122e6d6fdbdb3cb9ba72ae970f00a9e}{
\index{BaseKvmCPU@{BaseKvmCPU}!unserializeThread@{unserializeThread}}
\index{unserializeThread@{unserializeThread}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{unserializeThread}]{\setlength{\rightskip}{0pt plus 5cm}void unserializeThread ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section}, \/  {\bf ThreadID} {\em tid})}}
\label{classBaseKvmCPU_a5122e6d6fdbdb3cb9ba72ae970f00a9e}



\begin{DoxyCode}
273 {
274     DPRINTF(Checkpoint, "KVM: Unserialize thread %i:\n", tid);
275 
276     assert(tid == 0);
277     assert(_status == Idle);
278     thread->unserialize(cp, section);
279     threadContextDirty = true;
280 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_a48817be7bf03ef44cc5114ecf4df9b27}{
\index{BaseKvmCPU@{BaseKvmCPU}!updateKvmState@{updateKvmState}}
\index{updateKvmState@{updateKvmState}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{updateKvmState}]{\setlength{\rightskip}{0pt plus 5cm}virtual void updateKvmState ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classBaseKvmCPU_a48817be7bf03ef44cc5114ecf4df9b27}
Update the KVM state from the current thread context

The base CPU calls this method before starting the guest CPU when the contextDirty flag is set. The architecture dependent CPU implementation is expected to update all guest state (registers, special registers, and FPU state). 

\hyperlink{classArmKvmCPU_a93c6e8c82dfb63c7039f0cbf064fae5d}{ArmKvmCPU}, と \hyperlink{classX86KvmCPU_a93c6e8c82dfb63c7039f0cbf064fae5d}{X86KvmCPU}で実装されています。\hypertarget{classBaseKvmCPU_ac47bfb587580ca76050e0c9bc753c10d}{
\index{BaseKvmCPU@{BaseKvmCPU}!updateThreadContext@{updateThreadContext}}
\index{updateThreadContext@{updateThreadContext}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{updateThreadContext}]{\setlength{\rightskip}{0pt plus 5cm}virtual void updateThreadContext ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classBaseKvmCPU_ac47bfb587580ca76050e0c9bc753c10d}
Update the current thread context with the KVM state

The base CPU after the guest updates any of the KVM state. In practice, this happens after kvmRun is called. The architecture dependent code is expected to read the state of the guest CPU and update gem5's thread state. 

\hyperlink{classArmKvmCPU_adbd5e38eae7c8c3021f2c4f430b399fd}{ArmKvmCPU}, と \hyperlink{classX86KvmCPU_adbd5e38eae7c8c3021f2c4f430b399fd}{X86KvmCPU}で実装されています。\hypertarget{classBaseKvmCPU_ae2e1ccebe596a180f8105d57f9a93645}{
\index{BaseKvmCPU@{BaseKvmCPU}!verifyMemoryMode@{verifyMemoryMode}}
\index{verifyMemoryMode@{verifyMemoryMode}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{verifyMemoryMode}]{\setlength{\rightskip}{0pt plus 5cm}void verifyMemoryMode () const}}
\label{classBaseKvmCPU_ae2e1ccebe596a180f8105d57f9a93645}



\begin{DoxyCode}
407 {
408     if (!(system->isAtomicMode() && system->bypassCaches())) {
409         fatal("The KVM-based CPUs requires the memory system to be in the "
410               "'atomic_noncaching' mode.\n");
411     }
412 }
\end{DoxyCode}
\hypertarget{classBaseKvmCPU_ae674290a26ecbd622c5160e38e8a4fe9}{
\index{BaseKvmCPU@{BaseKvmCPU}!wakeup@{wakeup}}
\index{wakeup@{wakeup}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{wakeup}]{\setlength{\rightskip}{0pt plus 5cm}void wakeup ()}}
\label{classBaseKvmCPU_ae674290a26ecbd622c5160e38e8a4fe9}


\hyperlink{classBaseCPU_a75101f8aee74078c8c3c1d1f3617f7cc}{BaseCPU}を再定義しています。


\begin{DoxyCode}
416 {
417     DPRINTF(Kvm, "wakeup()\n");
418     // This method might have been called from another
419     // context. Migrate to this SimObject's event queue when
420     // delivering the wakeup signal.
421     EventQueue::ScopedMigration migrate(eventQueue());
422 
423     // Kick the vCPU to get it to come out of KVM.
424     kick();
425 
426     if (thread->status() != ThreadContext::Suspended)
427         return;
428 
429     thread->activate();
430 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classBaseKvmCPU_ab174cc060c981cfd21406dc3797c8c6b}{
\index{BaseKvmCPU@{BaseKvmCPU}!\_\-kvmRun@{\_\-kvmRun}}
\index{\_\-kvmRun@{\_\-kvmRun}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{\_\-kvmRun}]{\setlength{\rightskip}{0pt plus 5cm}struct kvm\_\-run$\ast$ {\bf \_\-kvmRun}\hspace{0.3cm}{\ttfamily  \mbox{[}read, private\mbox{]}}}}
\label{classBaseKvmCPU_ab174cc060c981cfd21406dc3797c8c6b}
Pointer to the kvm\_\-run structure used to communicate parameters with KVM.

\begin{DoxyNote}{覚え書き}
This is the base pointer of the MMAPed KVM region. The first page contains the kvm\_\-run structure. Subsequent pages may contain other data such as the MMIO ring buffer. 
\end{DoxyNote}
\hypertarget{classBaseKvmCPU_a6cdf6e6db875a442f3ab6db542bd2bb5}{
\index{BaseKvmCPU@{BaseKvmCPU}!\_\-status@{\_\-status}}
\index{\_\-status@{\_\-status}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{\_\-status}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Status} {\bf \_\-status}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_a6cdf6e6db875a442f3ab6db542bd2bb5}
CPU run state \hypertarget{classBaseKvmCPU_a9b8c93980540464141f0989b8258295b}{
\index{BaseKvmCPU@{BaseKvmCPU}!activeInstPeriod@{activeInstPeriod}}
\index{activeInstPeriod@{activeInstPeriod}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{activeInstPeriod}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf activeInstPeriod}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_a9b8c93980540464141f0989b8258295b}
Currently active instruction count breakpoint \hypertarget{classBaseKvmCPU_a4a8e80967bf91692eb1703752a8203b3}{
\index{BaseKvmCPU@{BaseKvmCPU}!ctrInsts@{ctrInsts}}
\index{ctrInsts@{ctrInsts}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{ctrInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Counter} {\bf ctrInsts}}}
\label{classBaseKvmCPU_a4a8e80967bf91692eb1703752a8203b3}
Number of instructions executed by the CPU \hypertarget{classBaseKvmCPU_a3f709bd88ed61bca6788f8cc3cda97cb}{
\index{BaseKvmCPU@{BaseKvmCPU}!dataPort@{dataPort}}
\index{dataPort@{dataPort}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{dataPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf KVMCpuPort} {\bf dataPort}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_a3f709bd88ed61bca6788f8cc3cda97cb}
\hyperlink{classPort}{Port} for data requests \hypertarget{classBaseKvmCPU_a329b71fb934a93312ca0aacbf5a3f982}{
\index{BaseKvmCPU@{BaseKvmCPU}!drainManager@{drainManager}}
\index{drainManager@{drainManager}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{drainManager}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DrainManager}$\ast$ {\bf drainManager}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_a329b71fb934a93312ca0aacbf5a3f982}
Drain manager to use when signaling drain completion

This pointer is non-\/NULL when draining and NULL otherwise. \hypertarget{classBaseKvmCPU_a0ef366aa4bbbcdc2f7eeb7fcd3962dde}{
\index{BaseKvmCPU@{BaseKvmCPU}!hostFactor@{hostFactor}}
\index{hostFactor@{hostFactor}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{hostFactor}]{\setlength{\rightskip}{0pt plus 5cm}float {\bf hostFactor}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_a0ef366aa4bbbcdc2f7eeb7fcd3962dde}
Host factor as specified in the configuration \hypertarget{classBaseKvmCPU_a496c1c0ab30aeafdeeeede34db1edf45}{
\index{BaseKvmCPU@{BaseKvmCPU}!hwCycles@{hwCycles}}
\index{hwCycles@{hwCycles}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{hwCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PerfKvmCounter} {\bf hwCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_a496c1c0ab30aeafdeeeede34db1edf45}
Guest cycle counter.

This is the group leader of all performance counters measuring the guest system. It can be used in conjunction with the \hyperlink{classPerfKvmTimer}{PerfKvmTimer} (see perfControlledByTimer) to trigger exits from KVM. \hypertarget{classBaseKvmCPU_ab3360069d449c748e7b9efe5f6d427e9}{
\index{BaseKvmCPU@{BaseKvmCPU}!hwInstructions@{hwInstructions}}
\index{hwInstructions@{hwInstructions}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{hwInstructions}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PerfKvmCounter} {\bf hwInstructions}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_ab3360069d449c748e7b9efe5f6d427e9}
Guest instruction counter.

This counter is typically only used to measure the number of instructions executed by the guest. However, it can also be used to trigger exits from KVM if the configuration script requests an exit after a certain number of instructions.

\begin{DoxySeeAlso}{参照}
setupInstBreak 

scheduleInstStop 
\end{DoxySeeAlso}
\hypertarget{classBaseKvmCPU_a3d1157769fdf1f3b9566f70b9e7c30ea}{
\index{BaseKvmCPU@{BaseKvmCPU}!instPort@{instPort}}
\index{instPort@{instPort}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{instPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf KVMCpuPort} {\bf instPort}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_a3d1157769fdf1f3b9566f70b9e7c30ea}
Unused dummy port for the instruction interface \hypertarget{classBaseKvmCPU_a32fdccc14987171c2381947096c363f1}{
\index{BaseKvmCPU@{BaseKvmCPU}!kvmStateDirty@{kvmStateDirty}}
\index{kvmStateDirty@{kvmStateDirty}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{kvmStateDirty}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf kvmStateDirty}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_a32fdccc14987171c2381947096c363f1}
Is the KVM state dirty? \hyperlink{classSet}{Set} to true to force an update of the KVM vCPU state upon the next call to \hyperlink{classBaseKvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}{kvmRun()}. \hypertarget{classBaseKvmCPU_a22caf021a7ece8d92e5ab612191b1b57}{
\index{BaseKvmCPU@{BaseKvmCPU}!mmio\_\-req@{mmio\_\-req}}
\index{mmio\_\-req@{mmio\_\-req}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{mmio\_\-req}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Request} {\bf mmio\_\-req}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_a22caf021a7ece8d92e5ab612191b1b57}
Pre-\/allocated MMIO memory request \hypertarget{classBaseKvmCPU_ad4e1bcd3f032d2921aa97aec1fc7a45c}{
\index{BaseKvmCPU@{BaseKvmCPU}!mmioRing@{mmioRing}}
\index{mmioRing@{mmioRing}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{mmioRing}]{\setlength{\rightskip}{0pt plus 5cm}struct kvm\_\-coalesced\_\-mmio\_\-ring$\ast$ {\bf mmioRing}\hspace{0.3cm}{\ttfamily  \mbox{[}read, private\mbox{]}}}}
\label{classBaseKvmCPU_ad4e1bcd3f032d2921aa97aec1fc7a45c}
Coalesced MMIO ring buffer. NULL if coalesced MMIO is not supported. \hypertarget{classBaseKvmCPU_a99a92abe3f29c3d0f59af4e384a8fe7f}{
\index{BaseKvmCPU@{BaseKvmCPU}!numCoalescedMMIO@{numCoalescedMMIO}}
\index{numCoalescedMMIO@{numCoalescedMMIO}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{numCoalescedMMIO}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numCoalescedMMIO}}}
\label{classBaseKvmCPU_a99a92abe3f29c3d0f59af4e384a8fe7f}
\hypertarget{classBaseKvmCPU_a6cdcd551476b4e8234d5bfd987218d88}{
\index{BaseKvmCPU@{BaseKvmCPU}!numExitSignal@{numExitSignal}}
\index{numExitSignal@{numExitSignal}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{numExitSignal}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numExitSignal}}}
\label{classBaseKvmCPU_a6cdcd551476b4e8234d5bfd987218d88}
\hypertarget{classBaseKvmCPU_a65e906b9e123036deb6bc8922ce53e96}{
\index{BaseKvmCPU@{BaseKvmCPU}!numHalt@{numHalt}}
\index{numHalt@{numHalt}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{numHalt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numHalt}}}
\label{classBaseKvmCPU_a65e906b9e123036deb6bc8922ce53e96}
\hypertarget{classBaseKvmCPU_a230908c23db440bfcee954fb8d72f269}{
\index{BaseKvmCPU@{BaseKvmCPU}!numHypercalls@{numHypercalls}}
\index{numHypercalls@{numHypercalls}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{numHypercalls}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numHypercalls}}}
\label{classBaseKvmCPU_a230908c23db440bfcee954fb8d72f269}
\hypertarget{classBaseKvmCPU_a302bf9a6fd3b54c46eb3e2bfb18a320e}{
\index{BaseKvmCPU@{BaseKvmCPU}!numInsts@{numInsts}}
\index{numInsts@{numInsts}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{numInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numInsts}}}
\label{classBaseKvmCPU_a302bf9a6fd3b54c46eb3e2bfb18a320e}
\hypertarget{classBaseKvmCPU_a5ff214621d200e4672d581b12832886a}{
\index{BaseKvmCPU@{BaseKvmCPU}!numInterrupts@{numInterrupts}}
\index{numInterrupts@{numInterrupts}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{numInterrupts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numInterrupts}}}
\label{classBaseKvmCPU_a5ff214621d200e4672d581b12832886a}
\hypertarget{classBaseKvmCPU_ae3a09de1034e0294f5df0ce66d876727}{
\index{BaseKvmCPU@{BaseKvmCPU}!numIO@{numIO}}
\index{numIO@{numIO}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{numIO}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numIO}}}
\label{classBaseKvmCPU_ae3a09de1034e0294f5df0ce66d876727}
\hypertarget{classBaseKvmCPU_a4030a87068a8b133f5efabfc19f7542d}{
\index{BaseKvmCPU@{BaseKvmCPU}!numMMIO@{numMMIO}}
\index{numMMIO@{numMMIO}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{numMMIO}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numMMIO}}}
\label{classBaseKvmCPU_a4030a87068a8b133f5efabfc19f7542d}
\hypertarget{classBaseKvmCPU_a6184fcde9e075404315cd7c343054d30}{
\index{BaseKvmCPU@{BaseKvmCPU}!numVMExits@{numVMExits}}
\index{numVMExits@{numVMExits}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{numVMExits}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numVMExits}}}
\label{classBaseKvmCPU_a6184fcde9e075404315cd7c343054d30}
\hypertarget{classBaseKvmCPU_a8ef83ba51e6ab5f5db813c16e3cebb1d}{
\index{BaseKvmCPU@{BaseKvmCPU}!numVMHalfEntries@{numVMHalfEntries}}
\index{numVMHalfEntries@{numVMHalfEntries}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{numVMHalfEntries}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numVMHalfEntries}}}
\label{classBaseKvmCPU_a8ef83ba51e6ab5f5db813c16e3cebb1d}
\hypertarget{classBaseKvmCPU_a8386a4766759aabc32038300820a64aa}{
\index{BaseKvmCPU@{BaseKvmCPU}!pageSize@{pageSize}}
\index{pageSize@{pageSize}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{pageSize}]{\setlength{\rightskip}{0pt plus 5cm}const long {\bf pageSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_a8386a4766759aabc32038300820a64aa}
Cached page size of the host \hypertarget{classBaseKvmCPU_a569365e1361250361be1c3f703a52914}{
\index{BaseKvmCPU@{BaseKvmCPU}!perfControlledByTimer@{perfControlledByTimer}}
\index{perfControlledByTimer@{perfControlledByTimer}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{perfControlledByTimer}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf perfControlledByTimer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_a569365e1361250361be1c3f703a52914}
Does the runTimer control the performance counters?

The run timer will automatically enable and disable performance counters if a PerfEvent-\/based timer is used to control KVM exits. \hypertarget{classBaseKvmCPU_a28c546a9aa908313559ed074632a0c37}{
\index{BaseKvmCPU@{BaseKvmCPU}!runTimer@{runTimer}}
\index{runTimer@{runTimer}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{runTimer}]{\setlength{\rightskip}{0pt plus 5cm}std::unique\_\-ptr$<${\bf BaseKvmTimer}$>$ {\bf runTimer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_a28c546a9aa908313559ed074632a0c37}
Timer used to force execution into the monitor after a specified number of simulation tick equivalents have executed in the guest. This counter generates the signal specified by KVM\_\-TIMER\_\-SIGNAL. \hypertarget{classBaseKvmCPU_a4455a4759e69e5ebe68ae7298cbcc37d}{
\index{BaseKvmCPU@{BaseKvmCPU}!tc@{tc}}
\index{tc@{tc}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{tc}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadContext}$\ast$ {\bf tc}}}
\label{classBaseKvmCPU_a4455a4759e69e5ebe68ae7298cbcc37d}
\hyperlink{classThreadContext}{ThreadContext} object, provides an interface for external objects to modify this thread's state. \hypertarget{classBaseKvmCPU_af9572fa907cd21b54cb14bd626010d39}{
\index{BaseKvmCPU@{BaseKvmCPU}!thread@{thread}}
\index{thread@{thread}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{thread}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SimpleThread}$\ast$ {\bf thread}}}
\label{classBaseKvmCPU_af9572fa907cd21b54cb14bd626010d39}
A cached copy of a thread's state in the form of a \hyperlink{classSimpleThread}{SimpleThread} object.

Normally the actual thread state is stored in the KVM vCPU. If KVM has been running this copy is will be out of date. If we recently handled some events within gem5 that required state to be updated this could be the most up-\/to-\/date copy. When \hyperlink{classBaseKvmCPU_a2199ea70043ddde97c86e49a656b7ba9}{getContext()} or \hyperlink{classBaseKvmCPU_ac47bfb587580ca76050e0c9bc753c10d}{updateThreadContext()} is called this copy gets updated. The method syncThreadContext can be used within a KVM CPU to update the thread context if the KVM state is dirty (i.e., the vCPU has been run since the last update). \hypertarget{classBaseKvmCPU_a8d712456c8dd8a9842aa40a69dbc27dd}{
\index{BaseKvmCPU@{BaseKvmCPU}!threadContextDirty@{threadContextDirty}}
\index{threadContextDirty@{threadContextDirty}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{threadContextDirty}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf threadContextDirty}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_a8d712456c8dd8a9842aa40a69dbc27dd}
Is the gem5 context dirty? \hyperlink{classSet}{Set} to true to force an update of the KVM vCPU state upon the next call to \hyperlink{classBaseKvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}{kvmRun()}. \hypertarget{classBaseKvmCPU_aa36b8e894416f0ec98f701ab08f2ac22}{
\index{BaseKvmCPU@{BaseKvmCPU}!tickEvent@{tickEvent}}
\index{tickEvent@{tickEvent}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{tickEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TickEvent} {\bf tickEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_aa36b8e894416f0ec98f701ab08f2ac22}
\hypertarget{classBaseKvmCPU_a6b91f8b5649b80e8424cebfa3047e1d0}{
\index{BaseKvmCPU@{BaseKvmCPU}!vcpuFD@{vcpuFD}}
\index{vcpuFD@{vcpuFD}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{vcpuFD}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf vcpuFD}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_a6b91f8b5649b80e8424cebfa3047e1d0}
KVM vCPU file descriptor \hypertarget{classBaseKvmCPU_ac52bdf6886dcfd53068633de9ed83184}{
\index{BaseKvmCPU@{BaseKvmCPU}!vcpuID@{vcpuID}}
\index{vcpuID@{vcpuID}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{vcpuID}]{\setlength{\rightskip}{0pt plus 5cm}const long {\bf vcpuID}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_ac52bdf6886dcfd53068633de9ed83184}
KVM internal ID of the vCPU \hypertarget{classBaseKvmCPU_a0915679bdc25b2c015f15996f6d4ff6d}{
\index{BaseKvmCPU@{BaseKvmCPU}!vcpuMMapSize@{vcpuMMapSize}}
\index{vcpuMMapSize@{vcpuMMapSize}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{vcpuMMapSize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf vcpuMMapSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseKvmCPU_a0915679bdc25b2c015f15996f6d4ff6d}
Size of MMAPed kvm\_\-run area \hypertarget{classBaseKvmCPU_a8a181f878f7db2579a3a67dd2d8c5902}{
\index{BaseKvmCPU@{BaseKvmCPU}!vcpuThread@{vcpuThread}}
\index{vcpuThread@{vcpuThread}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{vcpuThread}]{\setlength{\rightskip}{0pt plus 5cm}pthread\_\-t {\bf vcpuThread}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseKvmCPU_a8a181f878f7db2579a3a67dd2d8c5902}
ID of the vCPU thread \hypertarget{classBaseKvmCPU_a6b8ecd9ec419f0cbe3c1047be643fe08}{
\index{BaseKvmCPU@{BaseKvmCPU}!vm@{vm}}
\index{vm@{vm}!BaseKvmCPU@{BaseKvmCPU}}
\subsubsection[{vm}]{\setlength{\rightskip}{0pt plus 5cm}{\bf KvmVM}\& {\bf vm}}}
\label{classBaseKvmCPU_a6b8ecd9ec419f0cbe3c1047be643fe08}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/kvm/\hyperlink{cpu_2kvm_2base_8hh}{base.hh}\item 
cpu/kvm/\hyperlink{cpu_2kvm_2base_8cc}{base.cc}\end{DoxyCompactItemize}
