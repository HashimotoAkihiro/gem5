\hypertarget{classPl050}{
\section{クラス Pl050}
\label{classPl050}\index{Pl050@{Pl050}}
}


{\ttfamily \#include $<$kmi.hh$>$}Pl050に対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=9cm]{classPl050}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef Pl050Params \hyperlink{classPl050_a12cd0d18c639c998ce04efabfca4d619}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
const \hyperlink{classPl050_a12cd0d18c639c998ce04efabfca4d619}{Params} $\ast$ \hyperlink{classPl050_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{classPl050_aee46f95854b38b40deb83122bffdde55}{Pl050} (const \hyperlink{classPl050_a12cd0d18c639c998ce04efabfca4d619}{Params} $\ast$p)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classPl050_a613ec7d5e1ec64f8d21fec78ae8e568e}{read} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classPl050_a4cefab464e72b5dd42c003a0a4341802}{write} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual void \hyperlink{classPl050_adfccd86af30aeaf063a1700dedde4788}{mouseAt} (uint16\_\-t x, uint16\_\-t y, uint8\_\-t buttons)
\item 
virtual void \hyperlink{classPl050_a24207a2cfb1351040a29bc3a1e341e42}{keyPress} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} key, bool down)
\item 
virtual void \hyperlink{classPl050_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classPl050_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classPl050_a12eff01be6a763bdde7517ade0fb4c3b}{BitUnion8} (ControlReg) Bitfield$<$ 0 $>$ force\_\-clock\_\-low
\item 
\hyperlink{classPl050_ae5769101277017b333eb93fb1bd4241e}{EndBitUnion} (ControlReg) ControlReg control
\item 
\hyperlink{classPl050_a8d38b04829a0d44ca73abac2d923445e}{BitUnion8} (StatusReg) Bitfield$<$ 0 $>$ data\_\-in
\item 
\hyperlink{classPl050_aa9e28741f3f4858715bb5d4147fd5b02}{EndBitUnion} (StatusReg) StatusReg status
\item 
\hyperlink{classPl050_aaad187ce47ad27fa2f7b32559402bc3e}{BitUnion8} (InterruptReg) Bitfield$<$ 0 $>$ rx
\item 
\hyperlink{classPl050_a429076a6961a34396291ae1f31258c78}{EndBitUnion} (InterruptReg) InterruptReg interrupts
\item 
void \hyperlink{classPl050_a3923da0a193dd22650c252c4eae4743d}{updateIntStatus} ()
\item 
void \hyperlink{classPl050_ab251ef5c4d9e1f0239542a9d8aa0dc3e}{generateInterrupt} ()
\item 
void \hyperlink{classPl050_a71bcba1e6fb2b38cac48b70b7a227c05}{processCommand} (uint8\_\-t byte)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
Bitfield$<$ 1 $>$ \hyperlink{classPl050_ac85a33c0241e926e1e133ec81ea09e1b}{force\_\-data\_\-low}
\item 
Bitfield$<$ 2 $>$ \hyperlink{classPl050_a10e20e217e3d67e2d20eed7ba60b5abf}{enable}
\item 
Bitfield$<$ 3 $>$ \hyperlink{classPl050_a8be90b7eaebfdf66f8f76df2c35749f1}{txint\_\-enable}
\item 
Bitfield$<$ 4 $>$ \hyperlink{classPl050_ac524c29efd86a04fe395e469bf48963b}{rxint\_\-enable}
\item 
Bitfield$<$ 5 $>$ \hyperlink{classPl050_ae880673634fb4c5ac4c5854a2490401a}{type}
\item 
Bitfield$<$ 1 $>$ \hyperlink{classPl050_ac86e910c41bcd2b2b02875f862bc4204}{clk\_\-in}
\item 
Bitfield$<$ 2 $>$ \hyperlink{classPl050_a1e505c28dece6bcfc640c89e379073d5}{rxparity}
\item 
Bitfield$<$ 3 $>$ \hyperlink{classPl050_abefe6ab60abda20d7264b5b22bb4048c}{rxbusy}
\item 
Bitfield$<$ 4 $>$ \hyperlink{classPl050_a0ec902d94a3ae210a8266e9ea5e0ff75}{rxfull}
\item 
Bitfield$<$ 5 $>$ \hyperlink{classPl050_a1d29e46d92d912324287f82c29e23f24}{txbusy}
\item 
Bitfield$<$ 6 $>$ \hyperlink{classPl050_af389e6d9640f1d43721d64e35c51b99a}{txempty}
\item 
uint8\_\-t \hyperlink{classPl050_abeb566ea63abc9ab6a987f0a6b99d0de}{clkdiv}
\item 
Bitfield$<$ 1 $>$ \hyperlink{classPl050_a429f49b4fd10858ef7c2557020a03d25}{tx}
\item 
InterruptReg \hyperlink{classPl050_ad4097b6a619d6dc0448b637554b87158}{rawInterrupts}
\item 
int \hyperlink{classPl050_ad11eded38a493c41b578c9ca28f528f8}{ackNext}
\item 
bool \hyperlink{classPl050_a0a89e7496669527845e89de84902ff53}{shiftDown}
\item 
\hyperlink{classVncInput}{VncInput} $\ast$ \hyperlink{classPl050_a52d1b5d3426a30e18a452cd67d87ec13}{vnc}
\item 
bool \hyperlink{classPl050_aed3536f6eab29208a570ebb75f43a9ce}{driverInitialized}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classPl050}{Pl050},\&Pl050::generateInterrupt $>$ \hyperlink{classPl050_af9021b7232a0425b2cc0f8c778ef44dc}{intEvent}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ uint8\_\-t $>$ \hyperlink{classPl050_a8eaa5d81b6a16387d60ab6bcd893700e}{rxQueue}
\end{DoxyCompactItemize}
\subsection*{Static Protected 変数}
\begin{DoxyCompactItemize}
\item 
static const int \hyperlink{classPl050_a94aa9060c3488d5cdfb2dd78c874d207}{kmiCr} = 0x000
\item 
static const int \hyperlink{classPl050_abe6bafc131e2ec278a0a4c467bd7648a}{kmiStat} = 0x004
\item 
static const int \hyperlink{classPl050_ae09c83c7501da90dbfd234377912503a}{kmiData} = 0x008
\item 
static const int \hyperlink{classPl050_a4199383ce9d3a94925b34a565f984079}{kmiClkDiv} = 0x00C
\item 
static const int \hyperlink{classPl050_ad616dc94a2b0aa2585e72dbf0e98cdd9}{kmiISR} = 0x010
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classPl050_a12cd0d18c639c998ce04efabfca4d619}{
\index{Pl050@{Pl050}!Params@{Params}}
\index{Params@{Params}!Pl050@{Pl050}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef Pl050Params {\bf Params}}}
\label{classPl050_a12cd0d18c639c998ce04efabfca4d619}


\hyperlink{classAmbaIntDevice_aa70660260d212b343768d91a298c80de}{AmbaIntDevice}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classPl050_aee46f95854b38b40deb83122bffdde55}{
\index{Pl050@{Pl050}!Pl050@{Pl050}}
\index{Pl050@{Pl050}!Pl050@{Pl050}}
\subsubsection[{Pl050}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pl050} (const {\bf Params} $\ast$ {\em p})}}
\label{classPl050_aee46f95854b38b40deb83122bffdde55}



\begin{DoxyCode}
54     : AmbaIntDevice(p, 0xfff), control(0), status(0x43), clkdiv(0),
55       interrupts(0), rawInterrupts(0), ackNext(false), shiftDown(false),
56       vnc(p->vnc), driverInitialized(false), intEvent(this)
57 {
58     if (vnc) {
59         if (!p->is_mouse)
60             vnc->setKeyboard(this);
61         else
62             vnc->setMouse(this);
63     }
64 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classPl050_aaad187ce47ad27fa2f7b32559402bc3e}{
\index{Pl050@{Pl050}!BitUnion8@{BitUnion8}}
\index{BitUnion8@{BitUnion8}!Pl050@{Pl050}}
\subsubsection[{BitUnion8}]{\setlength{\rightskip}{0pt plus 5cm}BitUnion8 (InterruptReg)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_aaad187ce47ad27fa2f7b32559402bc3e}
\hypertarget{classPl050_a8d38b04829a0d44ca73abac2d923445e}{
\index{Pl050@{Pl050}!BitUnion8@{BitUnion8}}
\index{BitUnion8@{BitUnion8}!Pl050@{Pl050}}
\subsubsection[{BitUnion8}]{\setlength{\rightskip}{0pt plus 5cm}BitUnion8 (StatusReg)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_a8d38b04829a0d44ca73abac2d923445e}
KMI status register \hypertarget{classPl050_a12eff01be6a763bdde7517ade0fb4c3b}{
\index{Pl050@{Pl050}!BitUnion8@{BitUnion8}}
\index{BitUnion8@{BitUnion8}!Pl050@{Pl050}}
\subsubsection[{BitUnion8}]{\setlength{\rightskip}{0pt plus 5cm}BitUnion8 (ControlReg)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_a12eff01be6a763bdde7517ade0fb4c3b}
\hypertarget{classPl050_a429076a6961a34396291ae1f31258c78}{
\index{Pl050@{Pl050}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!Pl050@{Pl050}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion (InterruptReg)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_a429076a6961a34396291ae1f31258c78}
interrupt status register. \hypertarget{classPl050_aa9e28741f3f4858715bb5d4147fd5b02}{
\index{Pl050@{Pl050}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!Pl050@{Pl050}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion (StatusReg)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_aa9e28741f3f4858715bb5d4147fd5b02}
\hypertarget{classPl050_ae5769101277017b333eb93fb1bd4241e}{
\index{Pl050@{Pl050}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!Pl050@{Pl050}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion (ControlReg)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_ae5769101277017b333eb93fb1bd4241e}
control register \hypertarget{classPl050_ab251ef5c4d9e1f0239542a9d8aa0dc3e}{
\index{Pl050@{Pl050}!generateInterrupt@{generateInterrupt}}
\index{generateInterrupt@{generateInterrupt}!Pl050@{Pl050}}
\subsubsection[{generateInterrupt}]{\setlength{\rightskip}{0pt plus 5cm}void generateInterrupt ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_ab251ef5c4d9e1f0239542a9d8aa0dc3e}
Function to generate interrupt 


\begin{DoxyCode}
259 {
260 
261     if (interrupts) {
262         gic->sendInt(intNum);
263         DPRINTF(Pl050, "Generated interrupt\n");
264     }
265 }
\end{DoxyCode}
\hypertarget{classPl050_a24207a2cfb1351040a29bc3a1e341e42}{
\index{Pl050@{Pl050}!keyPress@{keyPress}}
\index{keyPress@{keyPress}!Pl050@{Pl050}}
\subsubsection[{keyPress}]{\setlength{\rightskip}{0pt plus 5cm}void keyPress ({\bf uint32\_\-t} {\em key}, \/  bool {\em down})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPl050_a24207a2cfb1351040a29bc3a1e341e42}
Called when the vnc server receives a key press event from the client. 
\begin{DoxyParams}{引数}
\item[{\em key}]the key passed is an x11 keysym \item[{\em down}]is the key now down or up? \end{DoxyParams}


\hyperlink{classVncKeyboard_a5159bd9abc87d9ed9e74c782173e8f0f}{VncKeyboard}を実装しています。


\begin{DoxyCode}
299 {
300     using namespace Ps2;
301 
302     std::list<uint8_t> keys;
303 
304     // convert the X11 keysym into ps2 codes
305     keySymToPs2(key, down, shiftDown, keys);
306 
307     // Insert into our queue of charecters
308     rxQueue.splice(rxQueue.end(), keys);
309     updateIntStatus();
310 }
\end{DoxyCode}
\hypertarget{classPl050_adfccd86af30aeaf063a1700dedde4788}{
\index{Pl050@{Pl050}!mouseAt@{mouseAt}}
\index{mouseAt@{mouseAt}!Pl050@{Pl050}}
\subsubsection[{mouseAt}]{\setlength{\rightskip}{0pt plus 5cm}void mouseAt (uint16\_\-t {\em x}, \/  uint16\_\-t {\em y}, \/  uint8\_\-t {\em buttons})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPl050_adfccd86af30aeaf063a1700dedde4788}
called whenever the mouse moves or it's button state changes buttons is a simple mask with each button (0-\/8) corresponding to a bit position in the byte with 1 being down and 0 being up 
\begin{DoxyParams}{引数}
\item[{\em x}]the x position of the mouse \item[{\em y}]the y position of the mouse \item[{\em buttos}]the button state as described above \end{DoxyParams}


\hyperlink{classVncMouse_a9046dc82e20c004a2ac9b38f47ade145}{VncMouse}を実装しています。


\begin{DoxyCode}
269 {
270     using namespace Ps2;
271 
272     // If the driver hasn't initialized the device yet, no need to try and send
273     // it anything. Similarly we can get vnc mouse events orders of maginture
274     // faster than m5 can process them. Only queue up two sets mouse movements
275     // and don't add more until those are processed.
276     if (!driverInitialized || rxQueue.size() > 10)
277         return;
278 
279     // We shouldn't be here unless a vnc server called us in which case
280     // we should have a pointer to it
281     assert(vnc);
282 
283     // Convert screen coordinates to touchpad coordinates
284     uint16_t _x = (2047.0/vnc->videoWidth()) * x;
285     uint16_t _y = (2047.0/vnc->videoHeight()) * y;
286 
287     rxQueue.push_back(buttons);
288     rxQueue.push_back(_x >> 7);
289     rxQueue.push_back(_x & 0x7f);
290     rxQueue.push_back(_y >> 7);
291     rxQueue.push_back(_y & 0x7f);
292 
293     updateIntStatus();
294 }
\end{DoxyCode}
\hypertarget{classPl050_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{Pl050@{Pl050}!params@{params}}
\index{params@{params}!Pl050@{Pl050}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPl050_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classBasicPioDevice_acd3c3feb78ae7a8f88fe0f110a718dff}{BasicPioDevice}を再定義しています。


\begin{DoxyCode}
148     {
149         return dynamic_cast<const Params *>(_params);
150     }
\end{DoxyCode}
\hypertarget{classPl050_a71bcba1e6fb2b38cac48b70b7a227c05}{
\index{Pl050@{Pl050}!processCommand@{processCommand}}
\index{processCommand@{processCommand}!Pl050@{Pl050}}
\subsubsection[{processCommand}]{\setlength{\rightskip}{0pt plus 5cm}void processCommand (uint8\_\-t {\em byte})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_a71bcba1e6fb2b38cac48b70b7a227c05}
Handle a command sent to the kmi and respond appropriately 


\begin{DoxyCode}
173 {
174     using namespace Ps2;
175 
176     if (ackNext) {
177         ackNext--;
178         rxQueue.push_back(Ack);
179         updateIntStatus();
180         return;
181     }
182 
183     switch (byte) {
184       case Ps2Reset:
185         rxQueue.push_back(Ack);
186         rxQueue.push_back(SelfTestPass);
187         break;
188       case SetResolution:
189       case SetRate:
190       case SetStatusLed:
191       case SetScaling1_1:
192       case SetScaling1_2:
193         rxQueue.push_back(Ack);
194         ackNext = 1;
195         break;
196       case ReadId:
197         rxQueue.push_back(Ack);
198         if (params()->is_mouse)
199             rxQueue.push_back(MouseId);
200         else
201             rxQueue.push_back(KeyboardId);
202         break;
203       case TpReadId:
204         if (!params()->is_mouse)
205             break;
206         // We're not a trackpoint device, this should make the probe go away
207         rxQueue.push_back(Ack);
208         rxQueue.push_back(0);
209         rxQueue.push_back(0);
210         // fall through
211       case Disable:
212       case Enable:
213       case SetDefaults:
214         rxQueue.push_back(Ack);
215         break;
216       case StatusRequest:
217         rxQueue.push_back(Ack);
218         rxQueue.push_back(0);
219         rxQueue.push_back(2); // default resolution
220         rxQueue.push_back(100); // default sample rate
221         break;
222       case TouchKitId:
223         ackNext = 2;
224         rxQueue.push_back(Ack);
225         rxQueue.push_back(TouchKitId);
226         rxQueue.push_back(1);
227         rxQueue.push_back('A');
228 
229         driverInitialized = true;
230         break;
231       default:
232         panic("Unknown byte received: %d\n", byte);
233     }
234 
235     updateIntStatus();
236 }
\end{DoxyCode}
\hypertarget{classPl050_a613ec7d5e1ec64f8d21fec78ae8e568e}{
\index{Pl050@{Pl050}!read@{read}}
\index{read@{read}!Pl050@{Pl050}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} read ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPl050_a613ec7d5e1ec64f8d21fec78ae8e568e}
Pure virtual function that the device must implement. Called when a read command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_a842312590432036092c422c87a442358}{PioDevice}を実装しています。


\begin{DoxyCode}
68 {
69     assert(pkt->getAddr() >= pioAddr && pkt->getAddr() < pioAddr + pioSize);
70 
71     Addr daddr = pkt->getAddr() - pioAddr;
72     pkt->allocate();
73 
74 
75     uint32_t data = 0;
76 
77     switch (daddr) {
78       case kmiCr:
79         DPRINTF(Pl050, "Read Commmand: %#x\n", (uint32_t)control);
80         data = control;
81         break;
82       case kmiStat:
83         if (rxQueue.empty())
84             status.rxfull = 0;
85         else
86             status.rxfull = 1;
87 
88         DPRINTF(Pl050, "Read Status: %#x\n", (uint32_t)status);
89         data = status;
90         break;
91       case kmiData:
92         if (rxQueue.empty()) {
93             data = 0;
94         } else {
95             data = rxQueue.front();
96             rxQueue.pop_front();
97         }
98         DPRINTF(Pl050, "Read Data: %#x\n", (uint32_t)data);
99         updateIntStatus();
100         break;
101       case kmiClkDiv:
102         data = clkdiv;
103         break;
104       case kmiISR:
105         data = interrupts;
106         DPRINTF(Pl050, "Read Interrupts: %#x\n", (uint32_t)interrupts);
107         break;
108       default:
109         if (readId(pkt, ambaId, pioAddr)) {
110             // Hack for variable size accesses
111             data = pkt->get<uint32_t>();
112             break;
113         }
114 
115         warn("Tried to read PL050 at offset %#x that doesn't exist\n", daddr);
116         break;
117     }
118 
119     switch(pkt->getSize()) {
120       case 1:
121         pkt->set<uint8_t>(data);
122         break;
123       case 2:
124         pkt->set<uint16_t>(data);
125         break;
126       case 4:
127         pkt->set<uint32_t>(data);
128         break;
129       default:
130         panic("KMI read size too big?\n");
131         break;
132     }
133 
134     pkt->makeAtomicResponse();
135     return pioDelay;
136 }
\end{DoxyCode}
\hypertarget{classPl050_a53e036786d17361be4c7320d39c99b84}{
\index{Pl050@{Pl050}!serialize@{serialize}}
\index{serialize@{serialize}!Pl050@{Pl050}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPl050_a53e036786d17361be4c7320d39c99b84}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。


\begin{DoxyCode}
314 {
315     uint8_t ctrlreg = control;
316     SERIALIZE_SCALAR(ctrlreg);
317 
318     uint8_t stsreg = status;
319     SERIALIZE_SCALAR(stsreg);
320     SERIALIZE_SCALAR(clkdiv);
321 
322     uint8_t ints = interrupts;
323     SERIALIZE_SCALAR(ints);
324 
325     uint8_t raw_ints = rawInterrupts;
326     SERIALIZE_SCALAR(raw_ints);
327 
328     SERIALIZE_SCALAR(ackNext);
329     SERIALIZE_SCALAR(shiftDown);
330     SERIALIZE_SCALAR(driverInitialized);
331 
332     arrayParamOut(os, "rxQueue", rxQueue);
333 }
\end{DoxyCode}
\hypertarget{classPl050_af22e5d6d660b97db37003ac61ac4ee49}{
\index{Pl050@{Pl050}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!Pl050@{Pl050}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPl050_af22e5d6d660b97db37003ac61ac4ee49}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。


\begin{DoxyCode}
337 {
338     uint8_t ctrlreg;
339     UNSERIALIZE_SCALAR(ctrlreg);
340     control = ctrlreg;
341 
342     uint8_t stsreg;
343     UNSERIALIZE_SCALAR(stsreg);
344     status = stsreg;
345 
346     UNSERIALIZE_SCALAR(clkdiv);
347 
348     uint8_t ints;
349     UNSERIALIZE_SCALAR(ints);
350     interrupts = ints;
351 
352     uint8_t raw_ints;
353     UNSERIALIZE_SCALAR(raw_ints);
354     rawInterrupts = raw_ints;
355 
356     UNSERIALIZE_SCALAR(ackNext);
357     UNSERIALIZE_SCALAR(shiftDown);
358     UNSERIALIZE_SCALAR(driverInitialized);
359 
360     arrayParamIn(cp, section, "rxQueue", rxQueue);
361 }
\end{DoxyCode}
\hypertarget{classPl050_a3923da0a193dd22650c252c4eae4743d}{
\index{Pl050@{Pl050}!updateIntStatus@{updateIntStatus}}
\index{updateIntStatus@{updateIntStatus}!Pl050@{Pl050}}
\subsubsection[{updateIntStatus}]{\setlength{\rightskip}{0pt plus 5cm}void updateIntStatus ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_a3923da0a193dd22650c252c4eae4743d}
Update the status of the interrupt registers and schedule an interrupt if required 


\begin{DoxyCode}
241 {
242     if (!rxQueue.empty())
243         rawInterrupts.rx = 1;
244     else
245         rawInterrupts.rx = 0;
246 
247     interrupts.tx = rawInterrupts.tx & control.txint_enable;
248     interrupts.rx = rawInterrupts.rx & control.rxint_enable;
249 
250     DPRINTF(Pl050, "rawInterupts=%#x control=%#x interrupts=%#x\n",
251             (uint32_t)rawInterrupts, (uint32_t)control, (uint32_t)interrupts);
252 
253     if (interrupts && !intEvent.scheduled())
254         schedule(intEvent, curTick() + intDelay);
255 }
\end{DoxyCode}
\hypertarget{classPl050_a4cefab464e72b5dd42c003a0a4341802}{
\index{Pl050@{Pl050}!write@{write}}
\index{write@{write}!Pl050@{Pl050}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} write ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPl050_a4cefab464e72b5dd42c003a0a4341802}
Pure virtual function that the device must implement. Called when a write command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_afe8371668d023bb2516b286e5e399b6f}{PioDevice}を実装しています。


\begin{DoxyCode}
140 {
141 
142     assert(pkt->getAddr() >= pioAddr && pkt->getAddr() < pioAddr + pioSize);
143 
144     Addr daddr = pkt->getAddr() - pioAddr;
145 
146     assert(pkt->getSize() == sizeof(uint8_t));
147 
148 
149     switch (daddr) {
150       case kmiCr:
151         DPRINTF(Pl050, "Write Commmand: %#x\n", (uint32_t)pkt->get<uint8_t>());
152         control = pkt->get<uint8_t>();
153         updateIntStatus();
154         break;
155       case kmiData:
156         DPRINTF(Pl050, "Write Data: %#x\n", (uint32_t)pkt->get<uint8_t>());
157         processCommand(pkt->get<uint8_t>());
158         updateIntStatus();
159         break;
160       case kmiClkDiv:
161         clkdiv = pkt->get<uint8_t>();
162         break;
163       default:
164         warn("Tried to write PL050 at offset %#x that doesn't exist\n", daddr);
165         break;
166     }
167     pkt->makeAtomicResponse();
168     return pioDelay;
169 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classPl050_ad11eded38a493c41b578c9ca28f528f8}{
\index{Pl050@{Pl050}!ackNext@{ackNext}}
\index{ackNext@{ackNext}!Pl050@{Pl050}}
\subsubsection[{ackNext}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf ackNext}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_ad11eded38a493c41b578c9ca28f528f8}
If the controller should ignore the next data byte and acknowledge it. The driver is attempting to setup some feature we don't care about \hypertarget{classPl050_ac86e910c41bcd2b2b02875f862bc4204}{
\index{Pl050@{Pl050}!clk\_\-in@{clk\_\-in}}
\index{clk\_\-in@{clk\_\-in}!Pl050@{Pl050}}
\subsubsection[{clk\_\-in}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$1$>$ {\bf clk\_\-in}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_ac86e910c41bcd2b2b02875f862bc4204}
\hypertarget{classPl050_abeb566ea63abc9ab6a987f0a6b99d0de}{
\index{Pl050@{Pl050}!clkdiv@{clkdiv}}
\index{clkdiv@{clkdiv}!Pl050@{Pl050}}
\subsubsection[{clkdiv}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf clkdiv}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_abeb566ea63abc9ab6a987f0a6b99d0de}
clock divisor register This register is just kept around to satisfy reads after driver does writes. The divsor does nothing, as we're not actually signaling ps2 serial commands to anything. \hypertarget{classPl050_aed3536f6eab29208a570ebb75f43a9ce}{
\index{Pl050@{Pl050}!driverInitialized@{driverInitialized}}
\index{driverInitialized@{driverInitialized}!Pl050@{Pl050}}
\subsubsection[{driverInitialized}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf driverInitialized}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_aed3536f6eab29208a570ebb75f43a9ce}
If the linux driver has initialized the device yet and thus can we send mouse data \hypertarget{classPl050_a10e20e217e3d67e2d20eed7ba60b5abf}{
\index{Pl050@{Pl050}!enable@{enable}}
\index{enable@{enable}!Pl050@{Pl050}}
\subsubsection[{enable}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$2$>$ {\bf enable}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_a10e20e217e3d67e2d20eed7ba60b5abf}
\hypertarget{classPl050_ac85a33c0241e926e1e133ec81ea09e1b}{
\index{Pl050@{Pl050}!force\_\-data\_\-low@{force\_\-data\_\-low}}
\index{force\_\-data\_\-low@{force\_\-data\_\-low}!Pl050@{Pl050}}
\subsubsection[{force\_\-data\_\-low}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$1$>$ {\bf force\_\-data\_\-low}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_ac85a33c0241e926e1e133ec81ea09e1b}
\hypertarget{classPl050_af9021b7232a0425b2cc0f8c778ef44dc}{
\index{Pl050@{Pl050}!intEvent@{intEvent}}
\index{intEvent@{intEvent}!Pl050@{Pl050}}
\subsubsection[{intEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf Pl050}, \&Pl050::generateInterrupt$>$ {\bf intEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_af9021b7232a0425b2cc0f8c778ef44dc}
Wrapper to create an event out of the thing \hypertarget{classPl050_a4199383ce9d3a94925b34a565f984079}{
\index{Pl050@{Pl050}!kmiClkDiv@{kmiClkDiv}}
\index{kmiClkDiv@{kmiClkDiv}!Pl050@{Pl050}}
\subsubsection[{kmiClkDiv}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf kmiClkDiv} = 0x00C\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl050_a4199383ce9d3a94925b34a565f984079}
\hypertarget{classPl050_a94aa9060c3488d5cdfb2dd78c874d207}{
\index{Pl050@{Pl050}!kmiCr@{kmiCr}}
\index{kmiCr@{kmiCr}!Pl050@{Pl050}}
\subsubsection[{kmiCr}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf kmiCr} = 0x000\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl050_a94aa9060c3488d5cdfb2dd78c874d207}
\hypertarget{classPl050_ae09c83c7501da90dbfd234377912503a}{
\index{Pl050@{Pl050}!kmiData@{kmiData}}
\index{kmiData@{kmiData}!Pl050@{Pl050}}
\subsubsection[{kmiData}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf kmiData} = 0x008\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl050_ae09c83c7501da90dbfd234377912503a}
\hypertarget{classPl050_ad616dc94a2b0aa2585e72dbf0e98cdd9}{
\index{Pl050@{Pl050}!kmiISR@{kmiISR}}
\index{kmiISR@{kmiISR}!Pl050@{Pl050}}
\subsubsection[{kmiISR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf kmiISR} = 0x010\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl050_ad616dc94a2b0aa2585e72dbf0e98cdd9}
\hypertarget{classPl050_abe6bafc131e2ec278a0a4c467bd7648a}{
\index{Pl050@{Pl050}!kmiStat@{kmiStat}}
\index{kmiStat@{kmiStat}!Pl050@{Pl050}}
\subsubsection[{kmiStat}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf kmiStat} = 0x004\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl050_abe6bafc131e2ec278a0a4c467bd7648a}
\hypertarget{classPl050_ad4097b6a619d6dc0448b637554b87158}{
\index{Pl050@{Pl050}!rawInterrupts@{rawInterrupts}}
\index{rawInterrupts@{rawInterrupts}!Pl050@{Pl050}}
\subsubsection[{rawInterrupts}]{\setlength{\rightskip}{0pt plus 5cm}InterruptReg {\bf rawInterrupts}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_ad4097b6a619d6dc0448b637554b87158}
raw interrupt register (unmasked) \hypertarget{classPl050_abefe6ab60abda20d7264b5b22bb4048c}{
\index{Pl050@{Pl050}!rxbusy@{rxbusy}}
\index{rxbusy@{rxbusy}!Pl050@{Pl050}}
\subsubsection[{rxbusy}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$3$>$ {\bf rxbusy}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_abefe6ab60abda20d7264b5b22bb4048c}
\hypertarget{classPl050_a0ec902d94a3ae210a8266e9ea5e0ff75}{
\index{Pl050@{Pl050}!rxfull@{rxfull}}
\index{rxfull@{rxfull}!Pl050@{Pl050}}
\subsubsection[{rxfull}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$4$>$ {\bf rxfull}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_a0ec902d94a3ae210a8266e9ea5e0ff75}
\hypertarget{classPl050_ac524c29efd86a04fe395e469bf48963b}{
\index{Pl050@{Pl050}!rxint\_\-enable@{rxint\_\-enable}}
\index{rxint\_\-enable@{rxint\_\-enable}!Pl050@{Pl050}}
\subsubsection[{rxint\_\-enable}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$4$>$ {\bf rxint\_\-enable}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_ac524c29efd86a04fe395e469bf48963b}
\hypertarget{classPl050_a1e505c28dece6bcfc640c89e379073d5}{
\index{Pl050@{Pl050}!rxparity@{rxparity}}
\index{rxparity@{rxparity}!Pl050@{Pl050}}
\subsubsection[{rxparity}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$2$>$ {\bf rxparity}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_a1e505c28dece6bcfc640c89e379073d5}
\hypertarget{classPl050_a8eaa5d81b6a16387d60ab6bcd893700e}{
\index{Pl050@{Pl050}!rxQueue@{rxQueue}}
\index{rxQueue@{rxQueue}!Pl050@{Pl050}}
\subsubsection[{rxQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<$uint8\_\-t$>$ {\bf rxQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_a8eaa5d81b6a16387d60ab6bcd893700e}
Receive queue. This list contains all the pending commands that need to be sent to the driver \hypertarget{classPl050_a0a89e7496669527845e89de84902ff53}{
\index{Pl050@{Pl050}!shiftDown@{shiftDown}}
\index{shiftDown@{shiftDown}!Pl050@{Pl050}}
\subsubsection[{shiftDown}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf shiftDown}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_a0a89e7496669527845e89de84902ff53}
is the shift key currently down \hypertarget{classPl050_a429f49b4fd10858ef7c2557020a03d25}{
\index{Pl050@{Pl050}!tx@{tx}}
\index{tx@{tx}!Pl050@{Pl050}}
\subsubsection[{tx}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$1$>$ {\bf tx}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_a429f49b4fd10858ef7c2557020a03d25}
\hypertarget{classPl050_a1d29e46d92d912324287f82c29e23f24}{
\index{Pl050@{Pl050}!txbusy@{txbusy}}
\index{txbusy@{txbusy}!Pl050@{Pl050}}
\subsubsection[{txbusy}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$5$>$ {\bf txbusy}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_a1d29e46d92d912324287f82c29e23f24}
\hypertarget{classPl050_af389e6d9640f1d43721d64e35c51b99a}{
\index{Pl050@{Pl050}!txempty@{txempty}}
\index{txempty@{txempty}!Pl050@{Pl050}}
\subsubsection[{txempty}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$6$>$ {\bf txempty}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_af389e6d9640f1d43721d64e35c51b99a}
\hypertarget{classPl050_a8be90b7eaebfdf66f8f76df2c35749f1}{
\index{Pl050@{Pl050}!txint\_\-enable@{txint\_\-enable}}
\index{txint\_\-enable@{txint\_\-enable}!Pl050@{Pl050}}
\subsubsection[{txint\_\-enable}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$3$>$ {\bf txint\_\-enable}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_a8be90b7eaebfdf66f8f76df2c35749f1}
\hypertarget{classPl050_ae880673634fb4c5ac4c5854a2490401a}{
\index{Pl050@{Pl050}!type@{type}}
\index{type@{type}!Pl050@{Pl050}}
\subsubsection[{type}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$5$>$ {\bf type}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_ae880673634fb4c5ac4c5854a2490401a}
\hypertarget{classPl050_a52d1b5d3426a30e18a452cd67d87ec13}{
\index{Pl050@{Pl050}!vnc@{vnc}}
\index{vnc@{vnc}!Pl050@{Pl050}}
\subsubsection[{vnc}]{\setlength{\rightskip}{0pt plus 5cm}{\bf VncInput}$\ast$ {\bf vnc}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl050_a52d1b5d3426a30e18a452cd67d87ec13}
The vnc server we're connected to (if any) 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/arm/\hyperlink{kmi_8hh}{kmi.hh}\item 
dev/arm/\hyperlink{kmi_8cc}{kmi.cc}\end{DoxyCompactItemize}
