\hypertarget{classArmISA_1_1TLB}{
\section{クラス TLB}
\label{classArmISA_1_1TLB}\index{ArmISA::TLB@{ArmISA::TLB}}
}


{\ttfamily \#include $<$tlb.hh$>$}TLBに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4cm]{classArmISA_1_1TLB}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0d}{ArmFlags} \{ \par
\hyperlink{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0da811bb3ddcc5035211e497b863db3abd0}{AlignmentMask} =  0x7, 
\hyperlink{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0da46a23507e5cc78facbca4f0aadb6106d}{AlignByte} =  0x0, 
\hyperlink{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0da78d8dffe4cfc46c93a011f6c18eb342f}{AlignHalfWord} =  0x1, 
\hyperlink{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0da7aed72b8cf399f281ad8558187fe6941}{AlignWord} =  0x2, 
\par
\hyperlink{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0dad6e82eb48377344b7d9f32c3a488dc0e}{AlignDoubleWord} =  0x3, 
\hyperlink{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0da9323e858587f025242511a85b969b287}{AlignQuadWord} =  0x4, 
\hyperlink{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0da9adcd9ee14d498ddb978852cae60d840}{AlignOctWord} =  0x5, 
\hyperlink{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0dac6aa9917fe5880558d8ee22e2fbcbe58}{AllowUnaligned} =  0x8, 
\par
\hyperlink{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0dadcfc57d389e8e2bb30dc32135b6a92d0}{UserMode} =  0x10, 
\hyperlink{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0daf6e40c9fd5825f3b3a4f2d45d4a64c68}{MustBeOne} =  0x40
 \}
\item 
enum \hyperlink{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08}{ArmTranslationType} \{ \hyperlink{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08af17d21db71fd885f6cc71fb2d0e896ec}{NormalTran} =  0, 
\hyperlink{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08a4ed07d4f5bb408945e5f4e9c7333b2d3}{S1CTran} =  0x1, 
\hyperlink{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08ae447e872ded0e6da22f91d2ccaf66afd}{HypMode} =  0x2, 
\hyperlink{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08ab8e7d202ad511f74c201e2bca94e83d6}{S1S2NsTran} =  0x4
 \}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classArmISA_1_1TLB_a072a0e1c517c70f5baf23c7bf1aae5c6}{TLB} (const ArmTLBParams $\ast$p)
\item 
\hyperlink{classArmISA_1_1TLB_a5bc074f4c969287561515e7906f422b5}{TLB} (const \hyperlink{classSimObject_a0f0761d2db586a23bb2a2880b8f387bb}{Params} $\ast$p, int \_\-size, \hyperlink{classArmISA_1_1TableWalker}{TableWalker} $\ast$\_\-walker)
\item 
\hyperlink{structArmISA_1_1TlbEntry}{TlbEntry} $\ast$ \hyperlink{classArmISA_1_1TLB_a16c4d359f56a027d2e6afe6af85c81e4}{lookup} (\hyperlink{classm5_1_1params_1_1Addr}{Addr} vpn, uint16\_\-t asn, uint8\_\-t \hyperlink{classArmISA_1_1TLB_add293169f7f2ac526b3fa14f950cf0bb}{vmid}, bool hyp, bool secure, bool functional, bool ignore\_\-asn, uint8\_\-t target\_\-el)
\item 
virtual \hyperlink{classArmISA_1_1TLB_a18a1722ab7889997b15fd7b9fc33c7ff}{$\sim$TLB} ()
\item 
void \hyperlink{classArmISA_1_1TLB_a15b6c15c1be2ca4de3e65772a02aa29f}{takeOverFrom} (\hyperlink{classBaseTLB}{BaseTLB} $\ast$otlb)
\item 
virtual void \hyperlink{classArmISA_1_1TLB_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\begin{DoxyCompactList}\small\item\em setup all the back pointers \item\end{DoxyCompactList}\item 
void \hyperlink{classArmISA_1_1TLB_ae888fc9d1a9bad8784469601dcf8d436}{setMMU} (\hyperlink{classArmISA_1_1Stage2MMU}{Stage2MMU} $\ast$\hyperlink{namespaceArmISA_afb747b54d0c5e3e4e1763be19ca9373b}{m})
\item 
int \hyperlink{classArmISA_1_1TLB_ae121404a6cfcf714e05fe2231ce4c7fc}{getsize} () const 
\item 
void \hyperlink{classArmISA_1_1TLB_a0a32b96ef1142ca48fa347d06b5d2436}{insert} (\hyperlink{classm5_1_1params_1_1Addr}{Addr} vaddr, \hyperlink{structArmISA_1_1TlbEntry}{TlbEntry} \&pte)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classArmISA_1_1TLB_acdb1ef6fa70ed231ff084dced51b91eb}{getTE} (\hyperlink{structArmISA_1_1TlbEntry}{TlbEntry} $\ast$$\ast$te, \hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{namespaceArmISA_a5aff829af55e65b802d83dfcef4e9dd0}{tc}, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} \hyperlink{namespaceArmISA_a5f3b9b97eb2dfa29d33e74878455f90d}{mode}, \hyperlink{classBaseTLB_1_1Translation}{Translation} $\ast$translation, bool timing, bool functional, bool is\_\-secure, \hyperlink{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08}{ArmTranslationType} tranType)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classArmISA_1_1TLB_a0743624c3e13c3dd3108be8847f8e488}{getResultTe} (\hyperlink{structArmISA_1_1TlbEntry}{TlbEntry} $\ast$$\ast$te, \hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{namespaceArmISA_a5aff829af55e65b802d83dfcef4e9dd0}{tc}, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} \hyperlink{namespaceArmISA_a5f3b9b97eb2dfa29d33e74878455f90d}{mode}, \hyperlink{classBaseTLB_1_1Translation}{Translation} $\ast$translation, bool timing, bool functional, \hyperlink{structArmISA_1_1TlbEntry}{TlbEntry} $\ast$mergeTe)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classArmISA_1_1TLB_a5a4e92c7787e92910f8ad62cb4f1bf5f}{checkPermissions} (\hyperlink{structArmISA_1_1TlbEntry}{TlbEntry} $\ast$te, \hyperlink{classRequest}{RequestPtr} req, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} \hyperlink{namespaceArmISA_a5f3b9b97eb2dfa29d33e74878455f90d}{mode})
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classArmISA_1_1TLB_a1ba70376d3c5636e94c5fd6312f7b63e}{checkPermissions64} (\hyperlink{structArmISA_1_1TlbEntry}{TlbEntry} $\ast$te, \hyperlink{classRequest}{RequestPtr} req, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} \hyperlink{namespaceArmISA_a5f3b9b97eb2dfa29d33e74878455f90d}{mode}, \hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{namespaceArmISA_a5aff829af55e65b802d83dfcef4e9dd0}{tc})
\item 
void \hyperlink{classArmISA_1_1TLB_a5ef6c06c7267c792fec8972aef272b4e}{flushAllSecurity} (bool secure\_\-lookup, uint8\_\-t target\_\-el, bool ignore\_\-el=false)
\item 
void \hyperlink{classArmISA_1_1TLB_a7cd235aa813c35e4cb1b4efcdd1a407f}{flushAllNs} (bool hyp, uint8\_\-t target\_\-el, bool ignore\_\-el=false)
\item 
void \hyperlink{classArmISA_1_1TLB_aca1483a67aee5a91e442f7131d66bcbd}{flushAll} ()
\item 
void \hyperlink{classArmISA_1_1TLB_afe44c2f5e54b8288d36b04cd77d18d54}{flushMvaAsid} (\hyperlink{classm5_1_1params_1_1Addr}{Addr} mva, uint64\_\-t asn, bool secure\_\-lookup, uint8\_\-t target\_\-el)
\item 
void \hyperlink{classArmISA_1_1TLB_ac8076054324beee773a8f801c3e6dfed}{flushAsid} (uint64\_\-t asn, bool secure\_\-lookup, uint8\_\-t target\_\-el)
\item 
void \hyperlink{classArmISA_1_1TLB_a9ea15078537697a5208dea8e912d7a08}{flushMva} (\hyperlink{classm5_1_1params_1_1Addr}{Addr} mva, bool secure\_\-lookup, bool hyp, uint8\_\-t target\_\-el)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classArmISA_1_1TLB_aa14d4829f5c7bce966547df0babb7487}{trickBoxCheck} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} \hyperlink{namespaceArmISA_a5f3b9b97eb2dfa29d33e74878455f90d}{mode}, \hyperlink{structArmISA_1_1TlbEntry_a0595b41cfb7d03f18438f9c355a3469d}{TlbEntry::DomainType} \hyperlink{namespaceArmISA_ad0cc3566b56b49851f0996cbbe5000cf}{domain})
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classArmISA_1_1TLB_a19bf31f32ec6125d85acc1feeee28e47}{walkTrickBoxCheck} (\hyperlink{classm5_1_1params_1_1Addr}{Addr} \hyperlink{namespaceArmISA_aec59a1cc2e7438586cdc39f4b30b0061}{pa}, bool is\_\-secure, \hyperlink{classm5_1_1params_1_1Addr}{Addr} \hyperlink{namespaceArmISA_a441099e13f407fadb6bcb0447107de87}{va}, \hyperlink{classm5_1_1params_1_1Addr}{Addr} sz, bool is\_\-exec, bool is\_\-write, \hyperlink{structArmISA_1_1TlbEntry_a0595b41cfb7d03f18438f9c355a3469d}{TlbEntry::DomainType} \hyperlink{namespaceArmISA_ad0cc3566b56b49851f0996cbbe5000cf}{domain}, \hyperlink{namespaceArmISA_aefa4213b348e38ee69f2a6109563a7bd}{LookupLevel} lookup\_\-level)
\item 
void \hyperlink{classArmISA_1_1TLB_a48b5486ebf7c83e7c81025a032312ca6}{printTlb} () const 
\item 
void \hyperlink{classArmISA_1_1TLB_a5fd1cb3fb8887f4bd6c1f982a23cc026}{allCpusCaching} ()
\item 
void \hyperlink{classArmISA_1_1TLB_a2d698ff909513b48a1263f8a5440e067}{demapPage} (\hyperlink{classm5_1_1params_1_1Addr}{Addr} vaddr, uint64\_\-t asn)
\item 
bool \hyperlink{classArmISA_1_1TLB_a4871909ce80dc11f7ddffcd28214262e}{translateFunctional} (\hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{namespaceArmISA_a5aff829af55e65b802d83dfcef4e9dd0}{tc}, \hyperlink{classm5_1_1params_1_1Addr}{Addr} vaddr, \hyperlink{classm5_1_1params_1_1Addr}{Addr} \&paddr)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classArmISA_1_1TLB_ab1be1538ff47c6977f901f22ba6150a0}{translateFunctional} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{namespaceArmISA_a5aff829af55e65b802d83dfcef4e9dd0}{tc}, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} \hyperlink{namespaceArmISA_a5f3b9b97eb2dfa29d33e74878455f90d}{mode}, \hyperlink{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08}{ArmTranslationType} tranType=NormalTran)
\item 
void \hyperlink{classArmISA_1_1TLB_af863223c2fa90b0bbb305626dc3bc604}{setAttr} (uint64\_\-t \hyperlink{namespaceArmISA_a710acfac10f0042826d2d6d9c213ae7b}{attr})
\item 
uint64\_\-t \hyperlink{classArmISA_1_1TLB_abe784aff035154580e3b0fc0f5af8bd5}{getAttr} () const 
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classArmISA_1_1TLB_a3d876e306a41e194bda2747ea51982f8}{translateFs} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{namespaceArmISA_a5aff829af55e65b802d83dfcef4e9dd0}{tc}, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} \hyperlink{namespaceArmISA_a5f3b9b97eb2dfa29d33e74878455f90d}{mode}, \hyperlink{classBaseTLB_1_1Translation}{Translation} $\ast$translation, bool \&delay, bool timing, \hyperlink{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08}{ArmTranslationType} tranType, bool functional=false)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classArmISA_1_1TLB_a6ada13dabe05b90fee0464345cf0f654}{translateSe} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{namespaceArmISA_a5aff829af55e65b802d83dfcef4e9dd0}{tc}, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} \hyperlink{namespaceArmISA_a5f3b9b97eb2dfa29d33e74878455f90d}{mode}, \hyperlink{classBaseTLB_1_1Translation}{Translation} $\ast$translation, bool \&delay, bool timing)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classArmISA_1_1TLB_ad9813aa5a0ed9ba84b634d9960006ed2}{translateAtomic} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{namespaceArmISA_a5aff829af55e65b802d83dfcef4e9dd0}{tc}, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} \hyperlink{namespaceArmISA_a5f3b9b97eb2dfa29d33e74878455f90d}{mode}, \hyperlink{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08}{ArmTranslationType} tranType=NormalTran)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classArmISA_1_1TLB_aece4eb62debdc9703b211d68ce771521}{translateTiming} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{namespaceArmISA_a5aff829af55e65b802d83dfcef4e9dd0}{tc}, \hyperlink{classBaseTLB_1_1Translation}{Translation} $\ast$translation, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} \hyperlink{namespaceArmISA_a5f3b9b97eb2dfa29d33e74878455f90d}{mode}, \hyperlink{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08}{ArmTranslationType} tranType=NormalTran)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classArmISA_1_1TLB_adc8f6be2e370d6ce03ae8044ff6f8709}{translateComplete} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{namespaceArmISA_a5aff829af55e65b802d83dfcef4e9dd0}{tc}, \hyperlink{classBaseTLB_1_1Translation}{Translation} $\ast$translation, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} \hyperlink{namespaceArmISA_a5f3b9b97eb2dfa29d33e74878455f90d}{mode}, \hyperlink{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08}{ArmTranslationType} tranType, bool callFromS2)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classArmISA_1_1TLB_ae199d95c42e036851a8a0543c6d6d2e3}{finalizePhysical} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{namespaceArmISA_a5aff829af55e65b802d83dfcef4e9dd0}{tc}, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} \hyperlink{namespaceArmISA_a5f3b9b97eb2dfa29d33e74878455f90d}{mode}) const 
\item 
void \hyperlink{classArmISA_1_1TLB_a8f020d3237536fe007fc488c4125c5d8}{drainResume} ()
\item 
void \hyperlink{classArmISA_1_1TLB_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
void \hyperlink{classArmISA_1_1TLB_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\item 
void \hyperlink{classArmISA_1_1TLB_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
virtual \hyperlink{classBaseMasterPort}{BaseMasterPort} $\ast$ \hyperlink{classArmISA_1_1TLB_a2ea87b216b1f58953a679590672be258}{getMasterPort} ()
\item 
\hyperlink{classDmaPort}{DmaPort} \& \hyperlink{classArmISA_1_1TLB_a3eca666205fdb5a79565d7520a5c97b9}{getWalkerPort} ()
\item 
const \hyperlink{classSimObject_a0f0761d2db586a23bb2a2880b8f387bb}{Params} $\ast$ \hyperlink{classArmISA_1_1TLB_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
void \hyperlink{classArmISA_1_1TLB_a97b2a677e1ca5219c876aa978a853c15}{invalidateMiscReg} ()
\end{DoxyCompactItemize}
\subsection*{Static Public メソッド}
\begin{DoxyCompactItemize}
\item 
static bool \hyperlink{classArmISA_1_1TLB_a3e576c3e0d39dfca708baea44ebf0617}{validVirtualAddress} (\hyperlink{classm5_1_1params_1_1Addr}{Addr} vaddr)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classArmISA_1_1TLB_a7eb66b75612ed7e8b075cd89dfd2b157}{updateMiscReg} (\hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{namespaceArmISA_a5aff829af55e65b802d83dfcef4e9dd0}{tc}, \hyperlink{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08}{ArmTranslationType} tranType=NormalTran)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structArmISA_1_1TlbEntry}{TlbEntry} $\ast$ \hyperlink{classArmISA_1_1TLB_a434ae74dec9e8168e4f338aeb18d5931}{table}
\item 
int \hyperlink{classArmISA_1_1TLB_a439227feff9d7f55384e8780cfc2eb82}{size}
\item 
bool \hyperlink{classArmISA_1_1TLB_a07545f2ccf0498cfe71558779680f062}{isStage2}
\item 
bool \hyperlink{classArmISA_1_1TLB_a52120124577a3b7c28a4e8876cd36a8b}{stage2Req}
\item 
uint64\_\-t \hyperlink{classArmISA_1_1TLB_a89972e483f89fb3a1694154f97ce2d9d}{\_\-attr}
\item 
bool \hyperlink{classArmISA_1_1TLB_a16c6c6799c68307c82bc6304cf0b27b4}{directToStage2}
\item 
\hyperlink{classArmISA_1_1TableWalker}{TableWalker} $\ast$ \hyperlink{classArmISA_1_1TLB_ae4dec2d4d5730361d51d9f4b24dee89c}{tableWalker}
\item 
\hyperlink{classArmISA_1_1TLB}{TLB} $\ast$ \hyperlink{classArmISA_1_1TLB_a2188cef93e9eb4ac6383c0ca4f44dc36}{stage2Tlb}
\item 
\hyperlink{classArmISA_1_1Stage2MMU}{Stage2MMU} $\ast$ \hyperlink{classArmISA_1_1TLB_a21ea64a0a6d9600fb09fff0854fd55d7}{stage2Mmu}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classArmISA_1_1TLB_a6f516f4695aa8bb85a9a52e395689e1a}{instHits}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classArmISA_1_1TLB_ae63ad13cb56fbd34a91d2093deaafad2}{instMisses}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classArmISA_1_1TLB_a36a79efeb718e4de41970178013dac63}{readHits}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classArmISA_1_1TLB_a262cd06e148f8dd362b73ee2a8c87ce0}{readMisses}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classArmISA_1_1TLB_a1d93d3754ee97de787330f7620867026}{writeHits}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classArmISA_1_1TLB_a607353d27be8640c6f48a295794322d6}{writeMisses}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classArmISA_1_1TLB_a98ccf1b183bddae403b637838f23fa49}{inserts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classArmISA_1_1TLB_a14429a278d32a87d27c0d9df47269a12}{flushTlb}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classArmISA_1_1TLB_af504265daaa5a177333d30804fba83a8}{flushTlbMva}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classArmISA_1_1TLB_a94bc002df9a21796ac29c74bc3ef8240}{flushTlbMvaAsid}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classArmISA_1_1TLB_a678e74ffba8318815627ae109f96b17e}{flushTlbAsid}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classArmISA_1_1TLB_ad4c80b0aa999ae0403e2ffbc9a217aaa}{flushedEntries}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classArmISA_1_1TLB_aaafbdf0bc49ea504814d314b5f51d47e}{alignFaults}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classArmISA_1_1TLB_a8d76399ea2182eaf505e54da078f5202}{prefetchFaults}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classArmISA_1_1TLB_a718b0dd709705b2b6cbf1c5e33c387fd}{domainFaults}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classArmISA_1_1TLB_a95307396029ef99d258ca5284cd8b284}{permsFaults}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classArmISA_1_1TLB_a1ebd2c58048a00cc55442a58e6782f35}{readAccesses}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classArmISA_1_1TLB_aaf48f6b8c76d54c75a6156c32ac6405f}{writeAccesses}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classArmISA_1_1TLB_a7268909f031909e2eab6994aa6406ae4}{instAccesses}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classArmISA_1_1TLB_a224eed77bfb7a27359c9c3c1acbdbfaa}{hits}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classArmISA_1_1TLB_a4b8b96257f1e97cd5730673f38f9571c}{misses}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classArmISA_1_1TLB_a1929e1032289676f78e07e4c6bc55369}{accesses}
\item 
int \hyperlink{classArmISA_1_1TLB_a7450c3dc2cffd22401a23ddc29b0c036}{rangeMRU}
\item 
bool \hyperlink{classArmISA_1_1TLB_a2ebef8e3741ddc1169a0a05e6a48052e}{bootUncacheability}
\item 
bool \hyperlink{classArmISA_1_1TLB_a52c06c8a54293998f3e1f71cdbd916f7}{aarch64}
\item 
\hyperlink{namespaceArmISA_a16588a7a92eb985c3341b7f706c81dd5}{ExceptionLevel} \hyperlink{classArmISA_1_1TLB_a658ce290954a428d8c5df11b8b5bd81b}{aarch64EL}
\item 
SCTLR \hyperlink{classArmISA_1_1TLB_a43c4d132ca97c6cc5358f7be3c2b5a69}{sctlr}
\item 
SCR \hyperlink{classArmISA_1_1TLB_ace0bf26677706ecff809bd4c76d33c8c}{scr}
\item 
bool \hyperlink{classArmISA_1_1TLB_ae5a4adef864b3b2b23001750a8a89499}{isPriv}
\item 
bool \hyperlink{classArmISA_1_1TLB_a62bc84f4251f16cf0cfa0f8d96e00c37}{isSecure}
\item 
bool \hyperlink{classArmISA_1_1TLB_a104c09577173edc4f8ce6814cc33f0ae}{isHyp}
\item 
TTBCR \hyperlink{classArmISA_1_1TLB_ad6762be565087b4bfb87f5bcb42673e7}{ttbcr}
\item 
uint16\_\-t \hyperlink{classArmISA_1_1TLB_a984a2dcfd9509ab586bee117bb2a7cfb}{asid}
\item 
uint8\_\-t \hyperlink{classArmISA_1_1TLB_add293169f7f2ac526b3fa14f950cf0bb}{vmid}
\item 
PRRR \hyperlink{classArmISA_1_1TLB_a06fc88abc8a8aa441c512ebb7531b3d7}{prrr}
\item 
NMRR \hyperlink{classArmISA_1_1TLB_a763ad3cda6c2782d46835a3b2c4b5515}{nmrr}
\item 
HCR \hyperlink{classArmISA_1_1TLB_ad0d8df2e2be956266458221c23763b4c}{hcr}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classArmISA_1_1TLB_a9d6f500564b7a3bf1ded6bc18b3d47db}{dacr}
\item 
bool \hyperlink{classArmISA_1_1TLB_ab11476fda4a6785ee0b6096e2e50f30c}{miscRegValid}
\item 
\hyperlink{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08}{ArmTranslationType} \hyperlink{classArmISA_1_1TLB_a23a689868acc5917efd41d7477757059}{curTranType}
\item 
bool \hyperlink{classArmISA_1_1TLB_a8e8469d916956ca8b9052ebd6f155e0b}{haveLPAE}
\item 
bool \hyperlink{classArmISA_1_1TLB_a48e6871d9ab14ff31b50307f0c617f95}{haveVirtualization}
\item 
bool \hyperlink{classArmISA_1_1TLB_a3aea18414c83c86fa366401cb767e7ab}{haveLargeAsid64}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classArmISA_1_1TLB_ab44854fd690d81090e18a5a7ba3850be}{\_\-flushMva} (\hyperlink{classm5_1_1params_1_1Addr}{Addr} mva, uint64\_\-t asn, bool secure\_\-lookup, bool hyp, bool ignore\_\-asn, uint8\_\-t target\_\-el)
\item 
bool \hyperlink{classArmISA_1_1TLB_a58d5b81b2c0a67f5780f391dfea47e3a}{checkELMatch} (uint8\_\-t target\_\-el, uint8\_\-t tentry\_\-el, bool ignore\_\-el)
\end{DoxyCompactItemize}


\subsection{列挙型}
\hypertarget{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0d}{
\index{ArmISA::TLB@{ArmISA::TLB}!ArmFlags@{ArmFlags}}
\index{ArmFlags@{ArmFlags}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{ArmFlags}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ArmFlags}}}
\label{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0d}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{AlignmentMask@{AlignmentMask}!ArmISA::TLB@{ArmISA::TLB}}\index{ArmISA::TLB@{ArmISA::TLB}!AlignmentMask@{AlignmentMask}}\item[{\em 
\hypertarget{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0da811bb3ddcc5035211e497b863db3abd0}{
AlignmentMask}
\label{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0da811bb3ddcc5035211e497b863db3abd0}
}]\index{AlignByte@{AlignByte}!ArmISA::TLB@{ArmISA::TLB}}\index{ArmISA::TLB@{ArmISA::TLB}!AlignByte@{AlignByte}}\item[{\em 
\hypertarget{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0da46a23507e5cc78facbca4f0aadb6106d}{
AlignByte}
\label{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0da46a23507e5cc78facbca4f0aadb6106d}
}]\index{AlignHalfWord@{AlignHalfWord}!ArmISA::TLB@{ArmISA::TLB}}\index{ArmISA::TLB@{ArmISA::TLB}!AlignHalfWord@{AlignHalfWord}}\item[{\em 
\hypertarget{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0da78d8dffe4cfc46c93a011f6c18eb342f}{
AlignHalfWord}
\label{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0da78d8dffe4cfc46c93a011f6c18eb342f}
}]\index{AlignWord@{AlignWord}!ArmISA::TLB@{ArmISA::TLB}}\index{ArmISA::TLB@{ArmISA::TLB}!AlignWord@{AlignWord}}\item[{\em 
\hypertarget{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0da7aed72b8cf399f281ad8558187fe6941}{
AlignWord}
\label{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0da7aed72b8cf399f281ad8558187fe6941}
}]\index{AlignDoubleWord@{AlignDoubleWord}!ArmISA::TLB@{ArmISA::TLB}}\index{ArmISA::TLB@{ArmISA::TLB}!AlignDoubleWord@{AlignDoubleWord}}\item[{\em 
\hypertarget{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0dad6e82eb48377344b7d9f32c3a488dc0e}{
AlignDoubleWord}
\label{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0dad6e82eb48377344b7d9f32c3a488dc0e}
}]\index{AlignQuadWord@{AlignQuadWord}!ArmISA::TLB@{ArmISA::TLB}}\index{ArmISA::TLB@{ArmISA::TLB}!AlignQuadWord@{AlignQuadWord}}\item[{\em 
\hypertarget{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0da9323e858587f025242511a85b969b287}{
AlignQuadWord}
\label{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0da9323e858587f025242511a85b969b287}
}]\index{AlignOctWord@{AlignOctWord}!ArmISA::TLB@{ArmISA::TLB}}\index{ArmISA::TLB@{ArmISA::TLB}!AlignOctWord@{AlignOctWord}}\item[{\em 
\hypertarget{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0da9adcd9ee14d498ddb978852cae60d840}{
AlignOctWord}
\label{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0da9adcd9ee14d498ddb978852cae60d840}
}]\index{AllowUnaligned@{AllowUnaligned}!ArmISA::TLB@{ArmISA::TLB}}\index{ArmISA::TLB@{ArmISA::TLB}!AllowUnaligned@{AllowUnaligned}}\item[{\em 
\hypertarget{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0dac6aa9917fe5880558d8ee22e2fbcbe58}{
AllowUnaligned}
\label{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0dac6aa9917fe5880558d8ee22e2fbcbe58}
}]\index{UserMode@{UserMode}!ArmISA::TLB@{ArmISA::TLB}}\index{ArmISA::TLB@{ArmISA::TLB}!UserMode@{UserMode}}\item[{\em 
\hypertarget{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0dadcfc57d389e8e2bb30dc32135b6a92d0}{
UserMode}
\label{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0dadcfc57d389e8e2bb30dc32135b6a92d0}
}]\index{MustBeOne@{MustBeOne}!ArmISA::TLB@{ArmISA::TLB}}\index{ArmISA::TLB@{ArmISA::TLB}!MustBeOne@{MustBeOne}}\item[{\em 
\hypertarget{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0daf6e40c9fd5825f3b3a4f2d45d4a64c68}{
MustBeOne}
\label{classArmISA_1_1TLB_a1e31c6b4a233c7e98a3e85eba0c84f0daf6e40c9fd5825f3b3a4f2d45d4a64c68}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
69                   {
70         AlignmentMask = 0x7,
71 
72         AlignByte = 0x0,
73         AlignHalfWord = 0x1,
74         AlignWord = 0x2,
75         AlignDoubleWord = 0x3,
76         AlignQuadWord = 0x4,
77         AlignOctWord = 0x5,
78 
79         AllowUnaligned = 0x8,
80         // Priv code operating as if it wasn't
81         UserMode = 0x10,
82         // Because zero otherwise looks like a valid setting and may be used
83         // accidentally, this bit must be non-zero to show it was used on
84         // purpose.
85         MustBeOne = 0x40
86     };
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08}{
\index{ArmISA::TLB@{ArmISA::TLB}!ArmTranslationType@{ArmTranslationType}}
\index{ArmTranslationType@{ArmTranslationType}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{ArmTranslationType}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ArmTranslationType}}}
\label{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{NormalTran@{NormalTran}!ArmISA::TLB@{ArmISA::TLB}}\index{ArmISA::TLB@{ArmISA::TLB}!NormalTran@{NormalTran}}\item[{\em 
\hypertarget{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08af17d21db71fd885f6cc71fb2d0e896ec}{
NormalTran}
\label{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08af17d21db71fd885f6cc71fb2d0e896ec}
}]\index{S1CTran@{S1CTran}!ArmISA::TLB@{ArmISA::TLB}}\index{ArmISA::TLB@{ArmISA::TLB}!S1CTran@{S1CTran}}\item[{\em 
\hypertarget{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08a4ed07d4f5bb408945e5f4e9c7333b2d3}{
S1CTran}
\label{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08a4ed07d4f5bb408945e5f4e9c7333b2d3}
}]\index{HypMode@{HypMode}!ArmISA::TLB@{ArmISA::TLB}}\index{ArmISA::TLB@{ArmISA::TLB}!HypMode@{HypMode}}\item[{\em 
\hypertarget{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08ae447e872ded0e6da22f91d2ccaf66afd}{
HypMode}
\label{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08ae447e872ded0e6da22f91d2ccaf66afd}
}]\index{S1S2NsTran@{S1S2NsTran}!ArmISA::TLB@{ArmISA::TLB}}\index{ArmISA::TLB@{ArmISA::TLB}!S1S2NsTran@{S1S2NsTran}}\item[{\em 
\hypertarget{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08ab8e7d202ad511f74c201e2bca94e83d6}{
S1S2NsTran}
\label{classArmISA_1_1TLB_ad6f5d480df151d5bddeefc6271793f08ab8e7d202ad511f74c201e2bca94e83d6}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
88                             {
89         NormalTran = 0,
90         S1CTran = 0x1,
91         HypMode = 0x2,
92         // Secure code operating as if it wasn't (required by some Address
93         // Translate operations)
94         S1S2NsTran = 0x4
95     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classArmISA_1_1TLB_a072a0e1c517c70f5baf23c7bf1aae5c6}{
\index{ArmISA::TLB@{ArmISA::TLB}!TLB@{TLB}}
\index{TLB@{TLB}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{TLB}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TLB} (const ArmTLBParams $\ast$ {\em p})}}
\label{classArmISA_1_1TLB_a072a0e1c517c70f5baf23c7bf1aae5c6}



\begin{DoxyCode}
73     : BaseTLB(p), table(new TlbEntry[p->size]), size(p->size),
74     isStage2(p->is_stage2), tableWalker(p->walker), stage2Tlb(NULL),
75     stage2Mmu(NULL), rangeMRU(1), bootUncacheability(false),
76     miscRegValid(false), curTranType(NormalTran)
77 {
78     tableWalker->setTlb(this);
79 
80     // Cache system-level properties
81     haveLPAE = tableWalker->haveLPAE();
82     haveVirtualization = tableWalker->haveVirtualization();
83     haveLargeAsid64 = tableWalker->haveLargeAsid64();
84 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a5bc074f4c969287561515e7906f422b5}{
\index{ArmISA::TLB@{ArmISA::TLB}!TLB@{TLB}}
\index{TLB@{TLB}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{TLB}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TLB} (const {\bf Params} $\ast$ {\em p}, \/  int {\em \_\-size}, \/  {\bf TableWalker} $\ast$ {\em \_\-walker})}}
\label{classArmISA_1_1TLB_a5bc074f4c969287561515e7906f422b5}
\hypertarget{classArmISA_1_1TLB_a18a1722ab7889997b15fd7b9fc33c7ff}{
\index{ArmISA::TLB@{ArmISA::TLB}!$\sim$TLB@{$\sim$TLB}}
\index{$\sim$TLB@{$\sim$TLB}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{$\sim$TLB}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf TLB} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classArmISA_1_1TLB_a18a1722ab7889997b15fd7b9fc33c7ff}



\begin{DoxyCode}
87 {
88     delete[] table;
89 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classArmISA_1_1TLB_ab44854fd690d81090e18a5a7ba3850be}{
\index{ArmISA::TLB@{ArmISA::TLB}!\_\-flushMva@{\_\-flushMva}}
\index{\_\-flushMva@{\_\-flushMva}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{\_\-flushMva}]{\setlength{\rightskip}{0pt plus 5cm}void \_\-flushMva ({\bf Addr} {\em mva}, \/  uint64\_\-t {\em asn}, \/  bool {\em secure\_\-lookup}, \/  bool {\em hyp}, \/  bool {\em ignore\_\-asn}, \/  uint8\_\-t {\em target\_\-el})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmISA_1_1TLB_ab44854fd690d81090e18a5a7ba3850be}
Remove any entries that match both a va and asn 
\begin{DoxyParams}{引数}
\item[{\em mva}]virtual address to flush \item[{\em asn}]contextid/asn to flush on match \item[{\em secure\_\-lookup}]if the operation affects the secure world \item[{\em hyp}]if the operation affects hyp mode \item[{\em ignore\_\-asn}]if the flush should ignore the asn \end{DoxyParams}



\begin{DoxyCode}
317 {
318     TlbEntry *te;
319     // D5.7.2: Sign-extend address to 64 bits
320     mva = sext<56>(mva);
321     te = lookup(mva, asn, vmid, hyp, secure_lookup, false, ignore_asn,
322                 target_el);
323     while (te != NULL) {
324         if (secure_lookup == !te->nstid) {
325             DPRINTF(TLB, " -  %s\n", te->print());
326             te->valid = false;
327             flushedEntries++;
328         }
329         te = lookup(mva, asn, vmid, hyp, secure_lookup, false, ignore_asn,
330                     target_el);
331     }
332 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a5fd1cb3fb8887f4bd6c1f982a23cc026}{
\index{ArmISA::TLB@{ArmISA::TLB}!allCpusCaching@{allCpusCaching}}
\index{allCpusCaching@{allCpusCaching}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{allCpusCaching}]{\setlength{\rightskip}{0pt plus 5cm}void allCpusCaching ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1TLB_a5fd1cb3fb8887f4bd6c1f982a23cc026}



\begin{DoxyCode}
231 { bootUncacheability = true; }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a58d5b81b2c0a67f5780f391dfea47e3a}{
\index{ArmISA::TLB@{ArmISA::TLB}!checkELMatch@{checkELMatch}}
\index{checkELMatch@{checkELMatch}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{checkELMatch}]{\setlength{\rightskip}{0pt plus 5cm}bool checkELMatch (uint8\_\-t {\em target\_\-el}, \/  uint8\_\-t {\em tentry\_\-el}, \/  bool {\em ignore\_\-el})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmISA_1_1TLB_a58d5b81b2c0a67f5780f391dfea47e3a}



\begin{DoxyCode}
336 {
337     bool elMatch = true;
338     if (!ignore_el) {
339         if (target_el == 2 || target_el == 3) {
340             elMatch = (tentry_el  == target_el);
341         } else {
342             elMatch = (tentry_el == 0) || (tentry_el  == 1);
343         }
344     }
345     return elMatch;
346 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a5a4e92c7787e92910f8ad62cb4f1bf5f}{
\index{ArmISA::TLB@{ArmISA::TLB}!checkPermissions@{checkPermissions}}
\index{checkPermissions@{checkPermissions}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{checkPermissions}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} checkPermissions ({\bf TlbEntry} $\ast$ {\em te}, \/  {\bf RequestPtr} {\em req}, \/  {\bf Mode} {\em mode})}}
\label{classArmISA_1_1TLB_a5a4e92c7787e92910f8ad62cb4f1bf5f}



\begin{DoxyCode}
587 {
588     Addr vaddr = req->getVaddr(); // 32-bit don't have to purify
589     uint32_t flags = req->getFlags();
590     bool is_fetch  = (mode == Execute);
591     bool is_write  = (mode == Write);
592     bool is_priv   = isPriv && !(flags & UserMode);
593 
594     // Get the translation type from the actuall table entry
595     ArmFault::TranMethod tranMethod = te->longDescFormat ? ArmFault::LpaeTran
596                                                          : ArmFault::VmsaTran;
597 
598     // If this is the second stage of translation and the request is for a
599     // stage 1 page table walk then we need to check the HCR.PTW bit. This
600     // allows us to generate a fault if the request targets an area marked
601     // as a device or strongly ordered.
602     if (isStage2 && req->isPTWalk() && hcr.ptw &&
603         (te->mtype != TlbEntry::MemoryType::Normal)) {
604         return new DataAbort(vaddr, te->domain, is_write,
605                              ArmFault::PermissionLL + te->lookupLevel,
606                              isStage2, tranMethod);
607     }
608 
609     // Generate an alignment fault for unaligned data accesses to device or
610     // strongly ordered memory
611     if (!is_fetch) {
612         if (te->mtype != TlbEntry::MemoryType::Normal) {
613             if (vaddr & mask(flags & AlignmentMask)) {
614                 alignFaults++;
615                 return new DataAbort(vaddr, TlbEntry::DomainType::NoAccess, is_wr
      ite,
616                                      ArmFault::AlignmentFault, isStage2,
617                                      tranMethod);
618             }
619         }
620     }
621 
622     if (te->nonCacheable) {
623         // Prevent prefetching from I/O devices.
624         if (req->isPrefetch()) {
625             // Here we can safely use the fault status for the short
626             // desc. format in all cases
627             return new PrefetchAbort(vaddr, ArmFault::PrefetchUncacheable,
628                                      isStage2, tranMethod);
629         }
630     }
631 
632     if (!te->longDescFormat) {
633         switch ((dacr >> (static_cast<uint8_t>(te->domain) * 2)) & 0x3) {
634           case 0:
635             domainFaults++;
636             DPRINTF(TLB, "TLB Fault: Data abort on domain. DACR: %#x"
637                     " domain: %#x write:%d\n", dacr,
638                     static_cast<uint8_t>(te->domain), is_write);
639             if (is_fetch)
640                 return new PrefetchAbort(vaddr,
641                                          ArmFault::DomainLL + te->lookupLevel,
642                                          isStage2, tranMethod);
643             else
644                 return new DataAbort(vaddr, te->domain, is_write,
645                                      ArmFault::DomainLL + te->lookupLevel,
646                                      isStage2, tranMethod);
647           case 1:
648             // Continue with permissions check
649             break;
650           case 2:
651             panic("UNPRED domain\n");
652           case 3:
653             return NoFault;
654         }
655     }
656 
657     // The 'ap' variable is AP[2:0] or {AP[2,1],1b'0}, i.e. always three bits
658     uint8_t ap  = te->longDescFormat ? te->ap << 1 : te->ap;
659     uint8_t hap = te->hap;
660 
661     if (sctlr.afe == 1 || te->longDescFormat)
662         ap |= 1;
663 
664     bool abt;
665     bool isWritable = true;
666     // If this is a stage 2 access (eg for reading stage 1 page table entries)
667     // then don't perform the AP permissions check, we stil do the HAP check
668     // below.
669     if (isStage2) {
670         abt = false;
671     } else {
672         switch (ap) {
673           case 0:
674             DPRINTF(TLB, "Access permissions 0, checking rs:%#x\n",
675                     (int)sctlr.rs);
676             if (!sctlr.xp) {
677                 switch ((int)sctlr.rs) {
678                   case 2:
679                     abt = is_write;
680                     break;
681                   case 1:
682                     abt = is_write || !is_priv;
683                     break;
684                   case 0:
685                   case 3:
686                   default:
687                     abt = true;
688                     break;
689                 }
690             } else {
691                 abt = true;
692             }
693             break;
694           case 1:
695             abt = !is_priv;
696             break;
697           case 2:
698             abt = !is_priv && is_write;
699             isWritable = is_priv;
700             break;
701           case 3:
702             abt = false;
703             break;
704           case 4:
705             panic("UNPRED premissions\n");
706           case 5:
707             abt = !is_priv || is_write;
708             isWritable = false;
709             break;
710           case 6:
711           case 7:
712             abt        = is_write;
713             isWritable = false;
714             break;
715           default:
716             panic("Unknown permissions %#x\n", ap);
717         }
718     }
719 
720     bool hapAbt = is_write ? !(hap & 2) : !(hap & 1);
721     bool xn     = te->xn || (isWritable && sctlr.wxn) ||
722                             (ap == 3    && sctlr.uwxn && is_priv);
723     if (is_fetch && (abt || xn ||
724                      (te->longDescFormat && te->pxn && !is_priv) ||
725                      (isSecure && te->ns && scr.sif))) {
726         permsFaults++;
727         DPRINTF(TLB, "TLB Fault: Prefetch abort on permission check. AP:%d "
728                      "priv:%d write:%d ns:%d sif:%d sctlr.afe: %d \n",
729                      ap, is_priv, is_write, te->ns, scr.sif,sctlr.afe);
730         return new PrefetchAbort(vaddr,
731                                  ArmFault::PermissionLL + te->lookupLevel,
732                                  isStage2, tranMethod);
733     } else if (abt | hapAbt) {
734         permsFaults++;
735         DPRINTF(TLB, "TLB Fault: Data abort on permission check. AP:%d priv:%d"
736                " write:%d\n", ap, is_priv, is_write);
737         return new DataAbort(vaddr, te->domain, is_write,
738                              ArmFault::PermissionLL + te->lookupLevel,
739                              isStage2 | !abt, tranMethod);
740     }
741     return NoFault;
742 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a1ba70376d3c5636e94c5fd6312f7b63e}{
\index{ArmISA::TLB@{ArmISA::TLB}!checkPermissions64@{checkPermissions64}}
\index{checkPermissions64@{checkPermissions64}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{checkPermissions64}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} checkPermissions64 ({\bf TlbEntry} $\ast$ {\em te}, \/  {\bf RequestPtr} {\em req}, \/  {\bf Mode} {\em mode}, \/  {\bf ThreadContext} $\ast$ {\em tc})}}
\label{classArmISA_1_1TLB_a1ba70376d3c5636e94c5fd6312f7b63e}



\begin{DoxyCode}
748 {
749     assert(aarch64);
750 
751     Addr vaddr_tainted = req->getVaddr();
752     Addr vaddr = purifyTaggedAddr(vaddr_tainted, tc, aarch64EL);
753 
754     uint32_t flags = req->getFlags();
755     bool is_fetch  = (mode == Execute);
756     bool is_write  = (mode == Write);
757     bool is_priv M5_VAR_USED  = isPriv && !(flags & UserMode);
758 
759     updateMiscReg(tc, curTranType);
760 
761     // If this is the second stage of translation and the request is for a
762     // stage 1 page table walk then we need to check the HCR.PTW bit. This
763     // allows us to generate a fault if the request targets an area marked
764     // as a device or strongly ordered.
765     if (isStage2 && req->isPTWalk() && hcr.ptw &&
766         (te->mtype != TlbEntry::MemoryType::Normal)) {
767         return new DataAbort(vaddr_tainted, te->domain, is_write,
768                              ArmFault::PermissionLL + te->lookupLevel,
769                              isStage2, ArmFault::LpaeTran);
770     }
771 
772     // Generate an alignment fault for unaligned accesses to device or
773     // strongly ordered memory
774     if (!is_fetch) {
775         if (te->mtype != TlbEntry::MemoryType::Normal) {
776             if (vaddr & mask(flags & AlignmentMask)) {
777                 alignFaults++;
778                 return new DataAbort(vaddr_tainted,
779                                      TlbEntry::DomainType::NoAccess, is_write,
780                                      ArmFault::AlignmentFault, isStage2,
781                                      ArmFault::LpaeTran);
782             }
783         }
784     }
785 
786     if (te->nonCacheable) {
787         // Prevent prefetching from I/O devices.
788         if (req->isPrefetch()) {
789             // Here we can safely use the fault status for the short
790             // desc. format in all cases
791             return new PrefetchAbort(vaddr_tainted,
792                                      ArmFault::PrefetchUncacheable,
793                                      isStage2, ArmFault::LpaeTran);
794         }
795     }
796 
797     uint8_t ap  = 0x3 & (te->ap);  // 2-bit access protection field
798     bool grant = false;
799 
800     uint8_t xn =  te->xn;
801     uint8_t pxn = te->pxn;
802     bool r = !is_write && !is_fetch;
803     bool w = is_write;
804     bool x = is_fetch;
805     DPRINTF(TLBVerbose, "Checking permissions: ap:%d, xn:%d, pxn:%d, r:%d, "
806                         "w:%d, x:%d\n", ap, xn, pxn, r, w, x);
807 
808     if (isStage2) {
809         panic("Virtualization in AArch64 state is not supported yet");
810     } else {
811         switch (aarch64EL) {
812           case EL0:
813             {
814                 uint8_t perm = (ap << 2)  | (xn << 1) | pxn;
815                 switch (perm) {
816                   case 0:
817                   case 1:
818                   case 8:
819                   case 9:
820                     grant = x;
821                     break;
822                   case 4:
823                   case 5:
824                     grant = r || w || (x && !sctlr.wxn);
825                     break;
826                   case 6:
827                   case 7:
828                     grant = r || w;
829                     break;
830                   case 12:
831                   case 13:
832                     grant = r || x;
833                     break;
834                   case 14:
835                   case 15:
836                     grant = r;
837                     break;
838                   default:
839                     grant = false;
840                 }
841             }
842             break;
843           case EL1:
844             {
845                 uint8_t perm = (ap << 2)  | (xn << 1) | pxn;
846                 switch (perm) {
847                   case 0:
848                   case 2:
849                     grant = r || w || (x && !sctlr.wxn);
850                     break;
851                   case 1:
852                   case 3:
853                   case 4:
854                   case 5:
855                   case 6:
856                   case 7:
857                     // regions that are writeable at EL0 should not be
858                     // executable at EL1
859                     grant = r || w;
860                     break;
861                   case 8:
862                   case 10:
863                   case 12:
864                   case 14:
865                     grant = r || x;
866                     break;
867                   case 9:
868                   case 11:
869                   case 13:
870                   case 15:
871                     grant = r;
872                     break;
873                   default:
874                     grant = false;
875                 }
876             }
877             break;
878           case EL2:
879           case EL3:
880             {
881                 uint8_t perm = (ap & 0x2) | xn;
882                 switch (perm) {
883                   case 0:
884                     grant = r || w || (x && !sctlr.wxn) ;
885                     break;
886                   case 1:
887                     grant = r || w;
888                     break;
889                   case 2:
890                     grant = r || x;
891                     break;
892                   case 3:
893                     grant = r;
894                     break;
895                   default:
896                     grant = false;
897                 }
898             }
899             break;
900         }
901     }
902 
903     if (!grant) {
904         if (is_fetch) {
905             permsFaults++;
906             DPRINTF(TLB, "TLB Fault: Prefetch abort on permission check. "
907                     "AP:%d priv:%d write:%d ns:%d sif:%d "
908                     "sctlr.afe: %d\n",
909                     ap, is_priv, is_write, te->ns, scr.sif, sctlr.afe);
910             // Use PC value instead of vaddr because vaddr might be aligned to
911             // cache line and should not be the address reported in FAR
912             return new PrefetchAbort(req->getPC(),
913                                      ArmFault::PermissionLL + te->lookupLevel,
914                                      isStage2, ArmFault::LpaeTran);
915         } else {
916             permsFaults++;
917             DPRINTF(TLB, "TLB Fault: Data abort on permission check. AP:%d "
918                     "priv:%d write:%d\n", ap, is_priv, is_write);
919             return new DataAbort(vaddr_tainted, te->domain, is_write,
920                                  ArmFault::PermissionLL + te->lookupLevel,
921                                  isStage2, ArmFault::LpaeTran);
922         }
923     }
924 
925     return NoFault;
926 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a2d698ff909513b48a1263f8a5440e067}{
\index{ArmISA::TLB@{ArmISA::TLB}!demapPage@{demapPage}}
\index{demapPage@{demapPage}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{demapPage}]{\setlength{\rightskip}{0pt plus 5cm}void demapPage ({\bf Addr} {\em vaddr}, \/  uint64\_\-t {\em asn})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1TLB_a2d698ff909513b48a1263f8a5440e067}



\begin{DoxyCode}
233     {
234         // needed for x86 only
235         panic("demapPage() is not implemented.\n");
236     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a8f020d3237536fe007fc488c4125c5d8}{
\index{ArmISA::TLB@{ArmISA::TLB}!drainResume@{drainResume}}
\index{drainResume@{drainResume}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{drainResume}]{\setlength{\rightskip}{0pt plus 5cm}void drainResume ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classArmISA_1_1TLB_a8f020d3237536fe007fc488c4125c5d8}
Resume execution after a successful drain.

\begin{DoxyNote}{覚え書き}
This method is normally only called from the simulation scripts. 
\end{DoxyNote}


\hyperlink{classDrainable_a8f020d3237536fe007fc488c4125c5d8}{Drainable}を再定義しています。


\begin{DoxyCode}
350 {
351     // We might have unserialized something or switched CPUs, so make
352     // sure to re-read the misc regs.
353     miscRegValid = false;
354 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_ae199d95c42e036851a8a0543c6d6d2e3}{
\index{ArmISA::TLB@{ArmISA::TLB}!finalizePhysical@{finalizePhysical}}
\index{finalizePhysical@{finalizePhysical}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{finalizePhysical}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} finalizePhysical ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Mode} {\em mode}) const}}
\label{classArmISA_1_1TLB_ae199d95c42e036851a8a0543c6d6d2e3}



\begin{DoxyCode}
125 {
126     return NoFault;
127 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_aca1483a67aee5a91e442f7131d66bcbd}{
\index{ArmISA::TLB@{ArmISA::TLB}!flushAll@{flushAll}}
\index{flushAll@{flushAll}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{flushAll}]{\setlength{\rightskip}{0pt plus 5cm}void flushAll ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classArmISA_1_1TLB_aca1483a67aee5a91e442f7131d66bcbd}
\hyperlink{classArmISA_1_1Reset}{Reset} the entire \hyperlink{classArmISA_1_1TLB}{TLB}. Used for CPU switching to prevent stale translations after multiple switches 

\hyperlink{classBaseTLB_a5958bc92949a47d1be1088468abdc006}{BaseTLB}を実装しています。


\begin{DoxyCode}
199     {
200         flushAllSecurity(false, 0, true);
201         flushAllSecurity(true, 0, true);
202     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a7cd235aa813c35e4cb1b4efcdd1a407f}{
\index{ArmISA::TLB@{ArmISA::TLB}!flushAllNs@{flushAllNs}}
\index{flushAllNs@{flushAllNs}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{flushAllNs}]{\setlength{\rightskip}{0pt plus 5cm}void flushAllNs (bool {\em hyp}, \/  uint8\_\-t {\em target\_\-el}, \/  bool {\em ignore\_\-el} = {\ttfamily false})}}
\label{classArmISA_1_1TLB_a7cd235aa813c35e4cb1b4efcdd1a407f}
Remove all entries in the non secure world, depending on whether they were allocated in hyp mode or not 
\begin{DoxyParams}{引数}
\item[{\em hyp}]if the opperation affects hyp mode \end{DoxyParams}



\begin{DoxyCode}
246 {
247     DPRINTF(TLB, "Flushing all NS TLB entries (%s lookup)\n",
248             (hyp ? "hyp" : "non-hyp"));
249     int x = 0;
250     TlbEntry *te;
251     while (x < size) {
252         te = &table[x];
253         if (te->valid && te->nstid && te->isHyp == hyp &&
254             checkELMatch(target_el, te->el, ignore_el)) {
255 
256             DPRINTF(TLB, " -  %s\n", te->print());
257             flushedEntries++;
258             te->valid = false;
259         }
260         ++x;
261     }
262 
263     flushTlb++;
264 
265     // If there's a second stage TLB (and we're not it) then flush it as well
266     if (!isStage2 && !hyp) {
267         stage2Tlb->flushAllNs(false, true);
268     }
269 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a5ef6c06c7267c792fec8972aef272b4e}{
\index{ArmISA::TLB@{ArmISA::TLB}!flushAllSecurity@{flushAllSecurity}}
\index{flushAllSecurity@{flushAllSecurity}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{flushAllSecurity}]{\setlength{\rightskip}{0pt plus 5cm}void flushAllSecurity (bool {\em secure\_\-lookup}, \/  uint8\_\-t {\em target\_\-el}, \/  bool {\em ignore\_\-el} = {\ttfamily false})}}
\label{classArmISA_1_1TLB_a5ef6c06c7267c792fec8972aef272b4e}
\hyperlink{classArmISA_1_1Reset}{Reset} the entire \hyperlink{classArmISA_1_1TLB}{TLB} 
\begin{DoxyParams}{引数}
\item[{\em secure\_\-lookup}]if the operation affects the secure world \end{DoxyParams}



\begin{DoxyCode}
217 {
218     DPRINTF(TLB, "Flushing all TLB entries (%s lookup)\n",
219             (secure_lookup ? "secure" : "non-secure"));
220     int x = 0;
221     TlbEntry *te;
222     while (x < size) {
223         te = &table[x];
224         if (te->valid && secure_lookup == !te->nstid &&
225             (te->vmid == vmid || secure_lookup) &&
226             checkELMatch(target_el, te->el, ignore_el)) {
227 
228             DPRINTF(TLB, " -  %s\n", te->print());
229             te->valid = false;
230             flushedEntries++;
231         }
232         ++x;
233     }
234 
235     flushTlb++;
236 
237     // If there's a second stage TLB (and we're not it) then flush it as well
238     // if we're currently in hyp mode
239     if (!isStage2 && isHyp) {
240         stage2Tlb->flushAllSecurity(secure_lookup, true);
241     }
242 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_ac8076054324beee773a8f801c3e6dfed}{
\index{ArmISA::TLB@{ArmISA::TLB}!flushAsid@{flushAsid}}
\index{flushAsid@{flushAsid}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{flushAsid}]{\setlength{\rightskip}{0pt plus 5cm}void flushAsid (uint64\_\-t {\em asn}, \/  bool {\em secure\_\-lookup}, \/  uint8\_\-t {\em target\_\-el})}}
\label{classArmISA_1_1TLB_ac8076054324beee773a8f801c3e6dfed}
Remove any entries that match the asn 
\begin{DoxyParams}{引数}
\item[{\em asn}]contextid/asn to flush on match \item[{\em secure\_\-lookup}]if the operation affects the secure world \end{DoxyParams}



\begin{DoxyCode}
283 {
284     DPRINTF(TLB, "Flushing TLB entries with asid: %#x (%s lookup)\n", asn,
285             (secure_lookup ? "secure" : "non-secure"));
286 
287     int x = 0 ;
288     TlbEntry *te;
289 
290     while (x < size) {
291         te = &table[x];
292         if (te->valid && te->asid == asn && secure_lookup == !te->nstid &&
293             (te->vmid == vmid || secure_lookup) &&
294             checkELMatch(target_el, te->el, false)) {
295 
296             te->valid = false;
297             DPRINTF(TLB, " -  %s\n", te->print());
298             flushedEntries++;
299         }
300         ++x;
301     }
302     flushTlbAsid++;
303 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a9ea15078537697a5208dea8e912d7a08}{
\index{ArmISA::TLB@{ArmISA::TLB}!flushMva@{flushMva}}
\index{flushMva@{flushMva}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{flushMva}]{\setlength{\rightskip}{0pt plus 5cm}void flushMva ({\bf Addr} {\em mva}, \/  bool {\em secure\_\-lookup}, \/  bool {\em hyp}, \/  uint8\_\-t {\em target\_\-el})}}
\label{classArmISA_1_1TLB_a9ea15078537697a5208dea8e912d7a08}
Remove all entries that match the va regardless of asn 
\begin{DoxyParams}{引数}
\item[{\em mva}]address to flush from cache \item[{\em secure\_\-lookup}]if the operation affects the secure world \item[{\em hyp}]if the operation affects hyp mode \end{DoxyParams}



\begin{DoxyCode}
307 {
308     DPRINTF(TLB, "Flushing TLB entries with mva: %#x (%s lookup)\n", mva,
309             (secure_lookup ? "secure" : "non-secure"));
310     _flushMva(mva, 0xbeef, secure_lookup, hyp, true, target_el);
311     flushTlbMva++;
312 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_afe44c2f5e54b8288d36b04cd77d18d54}{
\index{ArmISA::TLB@{ArmISA::TLB}!flushMvaAsid@{flushMvaAsid}}
\index{flushMvaAsid@{flushMvaAsid}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{flushMvaAsid}]{\setlength{\rightskip}{0pt plus 5cm}void flushMvaAsid ({\bf Addr} {\em mva}, \/  uint64\_\-t {\em asn}, \/  bool {\em secure\_\-lookup}, \/  uint8\_\-t {\em target\_\-el})}}
\label{classArmISA_1_1TLB_afe44c2f5e54b8288d36b04cd77d18d54}
Remove any entries that match both a va and asn 
\begin{DoxyParams}{引数}
\item[{\em mva}]virtual address to flush \item[{\em asn}]contextid/asn to flush on match \item[{\em secure\_\-lookup}]if the operation affects the secure world \end{DoxyParams}



\begin{DoxyCode}
273 {
274     DPRINTF(TLB, "Flushing TLB entries with mva: %#x, asid: %#x "
275             "(%s lookup)\n", mva, asn, (secure_lookup ?
276             "secure" : "non-secure"));
277     _flushMva(mva, asn, secure_lookup, false, false, target_el);
278     flushTlbMvaAsid++;
279 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_abe784aff035154580e3b0fc0f5af8bd5}{
\index{ArmISA::TLB@{ArmISA::TLB}!getAttr@{getAttr}}
\index{getAttr@{getAttr}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{getAttr}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t getAttr () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1TLB_abe784aff035154580e3b0fc0f5af8bd5}



\begin{DoxyCode}
267     {
268         return _attr;
269     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a2ea87b216b1f58953a679590672be258}{
\index{ArmISA::TLB@{ArmISA::TLB}!getMasterPort@{getMasterPort}}
\index{getMasterPort@{getMasterPort}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{getMasterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseMasterPort} $\ast$ getMasterPort ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classArmISA_1_1TLB_a2ea87b216b1f58953a679590672be258}
Get the table walker master port. This is used for migrating port connections during a CPU \hyperlink{classArmISA_1_1TLB_a15b6c15c1be2ca4de3e65772a02aa29f}{takeOverFrom()} call. For architectures that do not have a table walker, NULL is returned, hence the use of a pointer rather than a reference. For ARM this method will always return a valid port pointer.

\begin{DoxyReturn}{戻り値}
A pointer to the walker master port 
\end{DoxyReturn}


\hyperlink{classBaseTLB_a5125451589673cb85c7cab06c2ac5434}{BaseTLB}を再定義しています。


\begin{DoxyCode}
1189 {
1190     return &tableWalker->getMasterPort("port");
1191 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a0743624c3e13c3dd3108be8847f8e488}{
\index{ArmISA::TLB@{ArmISA::TLB}!getResultTe@{getResultTe}}
\index{getResultTe@{getResultTe}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{getResultTe}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} getResultTe ({\bf TlbEntry} $\ast$$\ast$ {\em te}, \/  {\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Mode} {\em mode}, \/  {\bf Translation} $\ast$ {\em translation}, \/  bool {\em timing}, \/  bool {\em functional}, \/  {\bf TlbEntry} $\ast$ {\em mergeTe})}}
\label{classArmISA_1_1TLB_a0743624c3e13c3dd3108be8847f8e488}



\begin{DoxyCode}
1369 {
1370     Fault fault;
1371     TlbEntry *s1Te = NULL;
1372 
1373     Addr vaddr_tainted = req->getVaddr();
1374 
1375     // Get the stage 1 table entry
1376     fault = getTE(&s1Te, req, tc, mode, translation, timing, functional,
1377                   isSecure, curTranType);
1378     // only proceed if we have a valid table entry
1379     if ((s1Te != NULL) && (fault == NoFault)) {
1380         // Check stage 1 permissions before checking stage 2
1381         if (aarch64)
1382             fault = checkPermissions64(s1Te, req, mode, tc);
1383         else
1384             fault = checkPermissions(s1Te, req, mode);
1385         if (stage2Req & (fault == NoFault)) {
1386             Stage2LookUp *s2Lookup = new Stage2LookUp(this, stage2Tlb, *s1Te,
1387                 req, translation, mode, timing, functional, curTranType);
1388             fault = s2Lookup->getTe(tc, mergeTe);
1389             if (s2Lookup->isComplete()) {
1390                 *te = mergeTe;
1391                 // We've finished with the lookup so delete it
1392                 delete s2Lookup;
1393             } else {
1394                 // The lookup hasn't completed, so we can't delete it now. We
1395                 // get round this by asking the object to self delete when the
1396                 // translation is complete.
1397                 s2Lookup->setSelfDelete();
1398             }
1399         } else {
1400             // This case deals with an S1 hit (or bypass), followed by
1401             // an S2 hit-but-perms issue
1402             if (isStage2) {
1403                 DPRINTF(TLBVerbose, "s2TLB: reqVa %#x, reqPa %#x, fault %p\n",
1404                         vaddr_tainted, req->hasPaddr() ? req->getPaddr() : ~0, fa
      ult);
1405                 if (fault != NoFault) {
1406                     ArmFault *armFault = reinterpret_cast<ArmFault *>(fault.get()
      );
1407                     armFault->annotate(ArmFault::S1PTW, false);
1408                     armFault->annotate(ArmFault::OVA, vaddr_tainted);
1409                 }
1410             }
1411             *te = s1Te;
1412         }
1413     }
1414     return fault;
1415 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_ae121404a6cfcf714e05fe2231ce4c7fc}{
\index{ArmISA::TLB@{ArmISA::TLB}!getsize@{getsize}}
\index{getsize@{getsize}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{getsize}]{\setlength{\rightskip}{0pt plus 5cm}int getsize () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1TLB_ae121404a6cfcf714e05fe2231ce4c7fc}



\begin{DoxyCode}
165 { return size; }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_acdb1ef6fa70ed231ff084dced51b91eb}{
\index{ArmISA::TLB@{ArmISA::TLB}!getTE@{getTE}}
\index{getTE@{getTE}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{getTE}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} getTE ({\bf TlbEntry} $\ast$$\ast$ {\em te}, \/  {\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Mode} {\em mode}, \/  {\bf Translation} $\ast$ {\em translation}, \/  bool {\em timing}, \/  bool {\em functional}, \/  bool {\em is\_\-secure}, \/  {\bf TLB::ArmTranslationType} {\em tranType})}}
\label{classArmISA_1_1TLB_acdb1ef6fa70ed231ff084dced51b91eb}



\begin{DoxyCode}
1308 {
1309     bool is_fetch = (mode == Execute);
1310     bool is_write = (mode == Write);
1311 
1312     Addr vaddr_tainted = req->getVaddr();
1313     Addr vaddr = 0;
1314     ExceptionLevel target_el = aarch64 ? aarch64EL : EL1;
1315     if (aarch64) {
1316         vaddr = purifyTaggedAddr(vaddr_tainted, tc, target_el);
1317     } else {
1318         vaddr = vaddr_tainted;
1319     }
1320     *te = lookup(vaddr, asid, vmid, isHyp, is_secure, false, false, target_el);
1321     if (*te == NULL) {
1322         if (req->isPrefetch()) {
1323             // if the request is a prefetch don't attempt to fill the TLB or go
1324             // any further with the memory access (here we can safely use the
1325             // fault status for the short desc. format in all cases)
1326            prefetchFaults++;
1327            return new PrefetchAbort(vaddr_tainted, ArmFault::PrefetchTLBMiss, 
      isStage2);
1328         }
1329 
1330         if (is_fetch)
1331             instMisses++;
1332         else if (is_write)
1333             writeMisses++;
1334         else
1335             readMisses++;
1336 
1337         // start translation table walk, pass variables rather than
1338         // re-retreaving in table walker for speed
1339         DPRINTF(TLB, "TLB Miss: Starting hardware table walker for %#x(%d:%d)\n",
      
1340                 vaddr_tainted, asid, vmid);
1341         Fault fault;
1342         fault = tableWalker->walk(req, tc, asid, vmid, isHyp, mode,
1343                                   translation, timing, functional, is_secure,
1344                                   tranType);
1345         // for timing mode, return and wait for table walk,
1346         if (timing || fault != NoFault) {
1347             return fault;
1348         }
1349 
1350         *te = lookup(vaddr, asid, vmid, isHyp, is_secure, false, false, target_el
      );
1351         if (!*te)
1352             printTlb();
1353         assert(*te);
1354     } else {
1355         if (is_fetch)
1356             instHits++;
1357         else if (is_write)
1358             writeHits++;
1359         else
1360             readHits++;
1361     }
1362     return NoFault;
1363 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a3eca666205fdb5a79565d7520a5c97b9}{
\index{ArmISA::TLB@{ArmISA::TLB}!getWalkerPort@{getWalkerPort}}
\index{getWalkerPort@{getWalkerPort}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{getWalkerPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DmaPort} \& getWalkerPort ()}}
\label{classArmISA_1_1TLB_a3eca666205fdb5a79565d7520a5c97b9}
Allow the MMU (overseeing both stage 1 and stage 2 TLBs) to access the table walker port of this \hyperlink{classArmISA_1_1TLB}{TLB} so that it can orchestrate staged translations.

\begin{DoxyReturn}{戻り値}
The table walker DMA port 
\end{DoxyReturn}



\begin{DoxyCode}
1195 {
1196     return tableWalker->getWalkerPort();
1197 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{ArmISA::TLB@{ArmISA::TLB}!init@{init}}
\index{init@{init}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classArmISA_1_1TLB_a02fd73d861ef2e4aabb38c0c9ff82947}


setup all the back pointers 

\hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{SimObject}を再定義しています。


\begin{DoxyCode}
93 {
94     if (stage2Mmu && !isStage2)
95         stage2Tlb = stage2Mmu->stage2Tlb();
96 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a0a32b96ef1142ca48fa347d06b5d2436}{
\index{ArmISA::TLB@{ArmISA::TLB}!insert@{insert}}
\index{insert@{insert}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{insert}]{\setlength{\rightskip}{0pt plus 5cm}void insert ({\bf Addr} {\em vaddr}, \/  {\bf TlbEntry} \& {\em pte})}}
\label{classArmISA_1_1TLB_a0a32b96ef1142ca48fa347d06b5d2436}



\begin{DoxyCode}
174 {
175     DPRINTF(TLB, "Inserting entry into TLB with pfn:%#x size:%#x vpn: %#x"
176             " asid:%d vmid:%d N:%d global:%d valid:%d nc:%d xn:%d"
177             " ap:%#x domain:%#x ns:%d nstid:%d isHyp:%d\n", entry.pfn,
178             entry.size, entry.vpn, entry.asid, entry.vmid, entry.N,
179             entry.global, entry.valid, entry.nonCacheable, entry.xn,
180             entry.ap, static_cast<uint8_t>(entry.domain), entry.ns, entry.nstid,
181             entry.isHyp);
182 
183     if (table[size - 1].valid)
184         DPRINTF(TLB, " - Replacing Valid entry %#x, asn %d vmn %d ppn %#x "
185                 "size: %#x ap:%d ns:%d nstid:%d g:%d isHyp:%d el: %d\n",
186                 table[size-1].vpn << table[size-1].N, table[size-1].asid,
187                 table[size-1].vmid, table[size-1].pfn << table[size-1].N,
188                 table[size-1].size, table[size-1].ap, table[size-1].ns,
189                 table[size-1].nstid, table[size-1].global, table[size-1].isHyp,
190                 table[size-1].el);
191 
192     //inserting to MRU position and evicting the LRU one
193 
194     for (int i = size - 1; i > 0; --i)
195         table[i] = table[i-1];
196     table[0] = entry;
197 
198     inserts++;
199 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a97b2a677e1ca5219c876aa978a853c15}{
\index{ArmISA::TLB@{ArmISA::TLB}!invalidateMiscReg@{invalidateMiscReg}}
\index{invalidateMiscReg@{invalidateMiscReg}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{invalidateMiscReg}]{\setlength{\rightskip}{0pt plus 5cm}void invalidateMiscReg ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1TLB_a97b2a677e1ca5219c876aa978a853c15}



\begin{DoxyCode}
351 { miscRegValid = false; }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a16c4d359f56a027d2e6afe6af85c81e4}{
\index{ArmISA::TLB@{ArmISA::TLB}!lookup@{lookup}}
\index{lookup@{lookup}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{lookup}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TlbEntry} $\ast$ lookup ({\bf Addr} {\em vpn}, \/  uint16\_\-t {\em asn}, \/  uint8\_\-t {\em vmid}, \/  bool {\em hyp}, \/  bool {\em secure}, \/  bool {\em functional}, \/  bool {\em ignore\_\-asn}, \/  uint8\_\-t {\em target\_\-el})}}
\label{classArmISA_1_1TLB_a16c4d359f56a027d2e6afe6af85c81e4}
Lookup an entry in the \hyperlink{classArmISA_1_1TLB}{TLB} 
\begin{DoxyParams}{引数}
\item[{\em vpn}]virtual address \item[{\em asn}]context id/address space id to use \item[{\em vmid}]The virtual machine ID used for stage 2 translation \item[{\em secure}]if the lookup is secure \item[{\em hyp}]if the lookup is done from hyp mode \item[{\em functional}]if the lookup should modify state \item[{\em ignore\_\-asn}]if on lookup asn should be ignored \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
pointer to \hyperlink{classArmISA_1_1TLB}{TLB} entry if it exists 
\end{DoxyReturn}



\begin{DoxyCode}
132 {
133 
134     TlbEntry *retval = NULL;
135 
136     // Maintaining LRU array
137     int x = 0;
138     while (retval == NULL && x < size) {
139         if ((!ignore_asn && table[x].match(va, asn, vmid, hyp, secure, false,
140              target_el)) ||
141             (ignore_asn && table[x].match(va, vmid, hyp, secure, target_el))) {
142             // We only move the hit entry ahead when the position is higher
143             // than rangeMRU
144             if (x > rangeMRU && !functional) {
145                 TlbEntry tmp_entry = table[x];
146                 for(int i = x; i > 0; i--)
147                     table[i] = table[i - 1];
148                 table[0] = tmp_entry;
149                 retval = &table[0];
150             } else {
151                 retval = &table[x];
152             }
153             break;
154         }
155         ++x;
156     }
157 
158     DPRINTF(TLBVerbose, "Lookup %#x, asn %#x -> %s vmn 0x%x hyp %d secure %d "
159             "ppn %#x size: %#x pa: %#x ap:%d ns:%d nstid:%d g:%d asid: %d "
160             "el: %d\n",
161             va, asn, retval ? "hit" : "miss", vmid, hyp, secure,
162             retval ? retval->pfn       : 0, retval ? retval->size  : 0,
163             retval ? retval->pAddr(va) : 0, retval ? retval->ap    : 0,
164             retval ? retval->ns        : 0, retval ? retval->nstid : 0,
165             retval ? retval->global    : 0, retval ? retval->asid  : 0,
166             retval ? retval->el        : 0, retval ? retval->el    : 0);
167 
168     return retval;
169 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{ArmISA::TLB@{ArmISA::TLB}!params@{params}}
\index{params@{params}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1TLB_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classSimObject_acd3c3feb78ae7a8f88fe0f110a718dff}{SimObject}を再定義しています。


\begin{DoxyCode}
348     {
349         return dynamic_cast<const Params *>(_params);
350     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a48b5486ebf7c83e7c81025a032312ca6}{
\index{ArmISA::TLB@{ArmISA::TLB}!printTlb@{printTlb}}
\index{printTlb@{printTlb}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{printTlb}]{\setlength{\rightskip}{0pt plus 5cm}void printTlb () const}}
\label{classArmISA_1_1TLB_a48b5486ebf7c83e7c81025a032312ca6}



\begin{DoxyCode}
203 {
204     int x = 0;
205     TlbEntry *te;
206     DPRINTF(TLB, "Current TLB contents:\n");
207     while (x < size) {
208         te = &table[x];
209         if (te->valid)
210             DPRINTF(TLB, " *  %s\n", te->print());
211         ++x;
212     }
213 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{ArmISA::TLB@{ArmISA::TLB}!regStats@{regStats}}
\index{regStats@{regStats}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classArmISA_1_1TLB_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} statistics for this object. 

\hyperlink{classSimObject_a4dc637449366fcdfc4e764cdf12d9b11}{SimObject}を再定義しています。


\begin{DoxyCode}
419 {
420     instHits
421         .name(name() + ".inst_hits")
422         .desc("ITB inst hits")
423         ;
424 
425     instMisses
426         .name(name() + ".inst_misses")
427         .desc("ITB inst misses")
428         ;
429 
430     instAccesses
431         .name(name() + ".inst_accesses")
432         .desc("ITB inst accesses")
433         ;
434 
435     readHits
436         .name(name() + ".read_hits")
437         .desc("DTB read hits")
438         ;
439 
440     readMisses
441         .name(name() + ".read_misses")
442         .desc("DTB read misses")
443         ;
444 
445     readAccesses
446         .name(name() + ".read_accesses")
447         .desc("DTB read accesses")
448         ;
449 
450     writeHits
451         .name(name() + ".write_hits")
452         .desc("DTB write hits")
453         ;
454 
455     writeMisses
456         .name(name() + ".write_misses")
457         .desc("DTB write misses")
458         ;
459 
460     writeAccesses
461         .name(name() + ".write_accesses")
462         .desc("DTB write accesses")
463         ;
464 
465     hits
466         .name(name() + ".hits")
467         .desc("DTB hits")
468         ;
469 
470     misses
471         .name(name() + ".misses")
472         .desc("DTB misses")
473         ;
474 
475     accesses
476         .name(name() + ".accesses")
477         .desc("DTB accesses")
478         ;
479 
480     flushTlb
481         .name(name() + ".flush_tlb")
482         .desc("Number of times complete TLB was flushed")
483         ;
484 
485     flushTlbMva
486         .name(name() + ".flush_tlb_mva")
487         .desc("Number of times TLB was flushed by MVA")
488         ;
489 
490     flushTlbMvaAsid
491         .name(name() + ".flush_tlb_mva_asid")
492         .desc("Number of times TLB was flushed by MVA & ASID")
493         ;
494 
495     flushTlbAsid
496         .name(name() + ".flush_tlb_asid")
497         .desc("Number of times TLB was flushed by ASID")
498         ;
499 
500     flushedEntries
501         .name(name() + ".flush_entries")
502         .desc("Number of entries that have been flushed from TLB")
503         ;
504 
505     alignFaults
506         .name(name() + ".align_faults")
507         .desc("Number of TLB faults due to alignment restrictions")
508         ;
509 
510     prefetchFaults
511         .name(name() + ".prefetch_faults")
512         .desc("Number of TLB faults due to prefetch")
513         ;
514 
515     domainFaults
516         .name(name() + ".domain_faults")
517         .desc("Number of TLB faults due to domain restrictions")
518         ;
519 
520     permsFaults
521         .name(name() + ".perms_faults")
522         .desc("Number of TLB faults due to permissions restrictions")
523         ;
524 
525     instAccesses = instHits + instMisses;
526     readAccesses = readHits + readMisses;
527     writeAccesses = writeHits + writeMisses;
528     hits = readHits + writeHits + instHits;
529     misses = readMisses + writeMisses + instMisses;
530     accesses = readAccesses + writeAccesses + instAccesses;
531 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a53e036786d17361be4c7320d39c99b84}{
\index{ArmISA::TLB@{ArmISA::TLB}!serialize@{serialize}}
\index{serialize@{serialize}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classArmISA_1_1TLB_a53e036786d17361be4c7320d39c99b84}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。\hypertarget{classArmISA_1_1TLB_af863223c2fa90b0bbb305626dc3bc604}{
\index{ArmISA::TLB@{ArmISA::TLB}!setAttr@{setAttr}}
\index{setAttr@{setAttr}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{setAttr}]{\setlength{\rightskip}{0pt plus 5cm}void setAttr (uint64\_\-t {\em attr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1TLB_af863223c2fa90b0bbb305626dc3bc604}
Accessor functions for memory attributes for last accessed \hyperlink{classArmISA_1_1TLB}{TLB} entry 


\begin{DoxyCode}
261     {
262         _attr = attr;
263     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_ae888fc9d1a9bad8784469601dcf8d436}{
\index{ArmISA::TLB@{ArmISA::TLB}!setMMU@{setMMU}}
\index{setMMU@{setMMU}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{setMMU}]{\setlength{\rightskip}{0pt plus 5cm}void setMMU ({\bf Stage2MMU} $\ast$ {\em m})}}
\label{classArmISA_1_1TLB_ae888fc9d1a9bad8784469601dcf8d436}



\begin{DoxyCode}
100 {
101     stage2Mmu = m;
102     tableWalker->setMMU(m);
103 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a15b6c15c1be2ca4de3e65772a02aa29f}{
\index{ArmISA::TLB@{ArmISA::TLB}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ({\bf BaseTLB} $\ast$ {\em otlb})}}
\label{classArmISA_1_1TLB_a15b6c15c1be2ca4de3e65772a02aa29f}



\begin{DoxyCode}
358 {
359     TLB *otlb = dynamic_cast<TLB*>(_otlb);
360     /* Make sure we actually have a valid type */
361     if (otlb) {
362         _attr = otlb->_attr;
363         haveLPAE = otlb->haveLPAE;
364         directToStage2 = otlb->directToStage2;
365         stage2Req = otlb->stage2Req;
366         bootUncacheability = otlb->bootUncacheability;
367 
368         /* Sync the stage2 MMU if they exist in both
369          * the old CPU and the new
370          */
371         if (!isStage2 &&
372             stage2Tlb && otlb->stage2Tlb) {
373             stage2Tlb->takeOverFrom(otlb->stage2Tlb);
374         }
375     } else {
376         panic("Incompatible TLB type!");
377     }
378 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_ad9813aa5a0ed9ba84b634d9960006ed2}{
\index{ArmISA::TLB@{ArmISA::TLB}!translateAtomic@{translateAtomic}}
\index{translateAtomic@{translateAtomic}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{translateAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translateAtomic ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Mode} {\em mode}, \/  {\bf TLB::ArmTranslationType} {\em tranType} = {\ttfamily NormalTran})}}
\label{classArmISA_1_1TLB_ad9813aa5a0ed9ba84b634d9960006ed2}



\begin{DoxyCode}
1104 {
1105     updateMiscReg(tc, tranType);
1106 
1107     if (directToStage2) {
1108         assert(stage2Tlb);
1109         return stage2Tlb->translateAtomic(req, tc, mode, tranType);
1110     }
1111 
1112     bool delay = false;
1113     Fault fault;
1114     if (FullSystem)
1115         fault = translateFs(req, tc, mode, NULL, delay, false, tranType);
1116     else
1117         fault = translateSe(req, tc, mode, NULL, delay, false);
1118     assert(!delay);
1119     return fault;
1120 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_adc8f6be2e370d6ce03ae8044ff6f8709}{
\index{ArmISA::TLB@{ArmISA::TLB}!translateComplete@{translateComplete}}
\index{translateComplete@{translateComplete}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{translateComplete}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translateComplete ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Translation} $\ast$ {\em translation}, \/  {\bf Mode} {\em mode}, \/  {\bf TLB::ArmTranslationType} {\em tranType}, \/  bool {\em callFromS2})}}
\label{classArmISA_1_1TLB_adc8f6be2e370d6ce03ae8044ff6f8709}



\begin{DoxyCode}
1163 {
1164     bool delay = false;
1165     Fault fault;
1166     if (FullSystem)
1167         fault = translateFs(req, tc, mode, translation, delay, true, tranType);
1168     else
1169         fault = translateSe(req, tc, mode, translation, delay, true);
1170     DPRINTF(TLBVerbose, "Translation returning delay=%d fault=%d\n", delay, fault
       !=
1171             NoFault);
1172     // If we have a translation, and we're not in the middle of doing a stage
1173     // 2 translation tell the translation that we've either finished or its
1174     // going to take a while. By not doing this when we're in the middle of a
1175     // stage 2 translation we prevent marking the translation as delayed twice,
1176     // one when the translation starts and again when the stage 1 translation
1177     // completes.
1178     if (translation && (callFromS2 || !stage2Req || req->hasPaddr() || fault != 
      NoFault)) {
1179         if (!delay)
1180             translation->finish(fault, req, tc, mode);
1181         else
1182             translation->markDelayed();
1183     }
1184     return fault;
1185 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a3d876e306a41e194bda2747ea51982f8}{
\index{ArmISA::TLB@{ArmISA::TLB}!translateFs@{translateFs}}
\index{translateFs@{translateFs}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{translateFs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translateFs ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Mode} {\em mode}, \/  {\bf Translation} $\ast$ {\em translation}, \/  bool \& {\em delay}, \/  bool {\em timing}, \/  {\bf TLB::ArmTranslationType} {\em tranType}, \/  bool {\em functional} = {\ttfamily false})}}
\label{classArmISA_1_1TLB_a3d876e306a41e194bda2747ea51982f8}



\begin{DoxyCode}
932 {
933     // No such thing as a functional timing access
934     assert(!(timing && functional));
935 
936     updateMiscReg(tc, tranType);
937 
938     Addr vaddr_tainted = req->getVaddr();
939     Addr vaddr = 0;
940     if (aarch64)
941         vaddr = purifyTaggedAddr(vaddr_tainted, tc, aarch64EL);
942     else
943         vaddr = vaddr_tainted;
944     uint32_t flags = req->getFlags();
945 
946     bool is_fetch  = (mode == Execute);
947     bool is_write  = (mode == Write);
948     bool long_desc_format = aarch64 || (haveLPAE && ttbcr.eae);
949     ArmFault::TranMethod tranMethod = long_desc_format ? ArmFault::LpaeTran
950                                                        : ArmFault::VmsaTran;
951 
952     req->setAsid(asid);
953 
954     DPRINTF(TLBVerbose, "CPSR is priv:%d UserMode:%d secure:%d S1S2NsTran:%d\n",
955             isPriv, flags & UserMode, isSecure, tranType & S1S2NsTran);
956 
957     DPRINTF(TLB, "translateFs addr %#x, mode %d, st2 %d, scr %#x sctlr %#x "
958                  "flags %#x tranType 0x%x\n", vaddr_tainted, mode, isStage2,
959                  scr, sctlr, flags, tranType);
960 
961     // Generate an alignment fault for unaligned PC
962     if (aarch64 && is_fetch && (req->getPC() & mask(2))) {
963         return new PCAlignmentFault(req->getPC());
964     }
965 
966     // If this is a clrex instruction, provide a PA of 0 with no fault
967     // This will force the monitor to set the tracked address to 0
968     // a bit of a hack but this effectively clrears this processors monitor
969     if (flags & Request::CLEAR_LL){
970         // @todo: check implications of security extensions
971        req->setPaddr(0);
972        req->setFlags(Request::UNCACHEABLE);
973        req->setFlags(Request::CLEAR_LL);
974        return NoFault;
975     }
976     if ((req->isInstFetch() && (!sctlr.i)) ||
977         ((!req->isInstFetch()) && (!sctlr.c))){
978        req->setFlags(Request::UNCACHEABLE);
979     }
980     if (!is_fetch) {
981         assert(flags & MustBeOne);
982         if (sctlr.a || !(flags & AllowUnaligned)) {
983             if (vaddr & mask(flags & AlignmentMask)) {
984                 alignFaults++;
985                 return new DataAbort(vaddr_tainted,
986                                      TlbEntry::DomainType::NoAccess, is_write,
987                                      ArmFault::AlignmentFault, isStage2,
988                                      tranMethod);
989             }
990         }
991     }
992 
993     // If guest MMU is off or hcr.vm=0 go straight to stage2
994     if ((isStage2 && !hcr.vm) || (!isStage2 && !sctlr.m)) {
995 
996         req->setPaddr(vaddr);
997         // When the MMU is off the security attribute corresponds to the
998         // security state of the processor
999         if (isSecure)
1000             req->setFlags(Request::SECURE);
1001 
1002         // @todo: double check this (ARM ARM issue C B3.2.1)
1003         if (long_desc_format || sctlr.tre == 0) {
1004             req->setFlags(Request::UNCACHEABLE);
1005         } else {
1006             if (nmrr.ir0 == 0 || nmrr.or0 == 0 || prrr.tr0 != 0x2)
1007                 req->setFlags(Request::UNCACHEABLE);
1008         }
1009 
1010         // Set memory attributes
1011         TlbEntry temp_te;
1012         temp_te.ns = !isSecure;
1013         if (isStage2 || hcr.dc == 0 || isSecure ||
1014            (isHyp && !(tranType & S1CTran))) {
1015 
1016             temp_te.mtype      = is_fetch ? TlbEntry::MemoryType::Normal
1017                                           : TlbEntry::MemoryType::StronglyOrdered
      ;
1018             temp_te.innerAttrs = 0x0;
1019             temp_te.outerAttrs = 0x0;
1020             temp_te.shareable  = true;
1021             temp_te.outerShareable = true;
1022         } else {
1023             temp_te.mtype      = TlbEntry::MemoryType::Normal;
1024             temp_te.innerAttrs = 0x3;
1025             temp_te.outerAttrs = 0x3;
1026             temp_te.shareable  = false;
1027             temp_te.outerShareable = false;
1028         }
1029         temp_te.setAttributes(long_desc_format);
1030         DPRINTF(TLBVerbose, "(No MMU) setting memory attributes: shareable:\
1031                 %d, innerAttrs: %d, outerAttrs: %d, isStage2: %d\n",
1032                 temp_te.shareable, temp_te.innerAttrs, temp_te.outerAttrs,
1033                 isStage2);
1034         setAttr(temp_te.attributes);
1035 
1036         return trickBoxCheck(req, mode, TlbEntry::DomainType::NoAccess);
1037     }
1038 
1039     DPRINTF(TLBVerbose, "Translating %s=%#x context=%d\n",
1040             isStage2 ? "IPA" : "VA", vaddr_tainted, asid);
1041     // Translation enabled
1042 
1043     TlbEntry *te = NULL;
1044     TlbEntry mergeTe;
1045     Fault fault = getResultTe(&te, req, tc, mode, translation, timing,
1046                               functional, &mergeTe);
1047     // only proceed if we have a valid table entry
1048     if ((te == NULL) && (fault == NoFault)) delay = true;
1049 
1050     // If we have the table entry transfer some of the attributes to the
1051     // request that triggered the translation
1052     if (te != NULL) {
1053         // Set memory attributes
1054         DPRINTF(TLBVerbose,
1055                 "Setting memory attributes: shareable: %d, innerAttrs: %d, \
1056                 outerAttrs: %d, mtype: %d, isStage2: %d\n",
1057                 te->shareable, te->innerAttrs, te->outerAttrs,
1058                 static_cast<uint8_t>(te->mtype), isStage2);
1059         setAttr(te->attributes);
1060         if (te->nonCacheable) {
1061             req->setFlags(Request::UNCACHEABLE);
1062         }
1063 
1064         if (!bootUncacheability &&
1065             ((ArmSystem*)tc->getSystemPtr())->adderBootUncacheable(vaddr)) {
1066             req->setFlags(Request::UNCACHEABLE);
1067         }
1068 
1069         req->setPaddr(te->pAddr(vaddr));
1070         if (isSecure && !te->ns) {
1071             req->setFlags(Request::SECURE);
1072         }
1073         if ((!is_fetch) && (vaddr & mask(flags & AlignmentMask)) &&
1074             (te->mtype != TlbEntry::MemoryType::Normal)) {
1075                 // Unaligned accesses to Device memory should always cause an
1076                 // abort regardless of sctlr.a
1077                 alignFaults++;
1078                 return new DataAbort(vaddr_tainted,
1079                                      TlbEntry::DomainType::NoAccess, is_write,
1080                                      ArmFault::AlignmentFault, isStage2,
1081                                      tranMethod);
1082         }
1083 
1084         // Check for a trickbox generated address fault
1085         if (fault == NoFault) {
1086             fault = trickBoxCheck(req, mode, te->domain);
1087         }
1088     }
1089 
1090     // Generate Illegal Inst Set State fault if IL bit is set in CPSR
1091     if (fault == NoFault) {
1092         CPSR cpsr = tc->readMiscReg(MISCREG_CPSR);
1093         if (aarch64 && is_fetch && cpsr.il == 1) {
1094             return new IllegalInstSetStateFault();
1095         }
1096     }
1097 
1098     return fault;
1099 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_ab1be1538ff47c6977f901f22ba6150a0}{
\index{ArmISA::TLB@{ArmISA::TLB}!translateFunctional@{translateFunctional}}
\index{translateFunctional@{translateFunctional}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{translateFunctional}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translateFunctional ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Mode} {\em mode}, \/  {\bf TLB::ArmTranslationType} {\em tranType} = {\ttfamily NormalTran})}}
\label{classArmISA_1_1TLB_ab1be1538ff47c6977f901f22ba6150a0}
Do a functional lookup on the \hyperlink{classArmISA_1_1TLB}{TLB} (for checker cpu) that behaves like a normal lookup without modifying any page table state. 


\begin{DoxyCode}
1125 {
1126     updateMiscReg(tc, tranType);
1127 
1128     if (directToStage2) {
1129         assert(stage2Tlb);
1130         return stage2Tlb->translateFunctional(req, tc, mode, tranType);
1131     }
1132 
1133     bool delay = false;
1134     Fault fault;
1135     if (FullSystem)
1136         fault = translateFs(req, tc, mode, NULL, delay, false, tranType, true);
1137    else
1138         fault = translateSe(req, tc, mode, NULL, delay, false);
1139     assert(!delay);
1140     return fault;
1141 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a4871909ce80dc11f7ddffcd28214262e}{
\index{ArmISA::TLB@{ArmISA::TLB}!translateFunctional@{translateFunctional}}
\index{translateFunctional@{translateFunctional}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{translateFunctional}]{\setlength{\rightskip}{0pt plus 5cm}bool translateFunctional ({\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Addr} {\em vaddr}, \/  {\bf Addr} \& {\em paddr})}}
\label{classArmISA_1_1TLB_a4871909ce80dc11f7ddffcd28214262e}
Do a functional lookup on the \hyperlink{classArmISA_1_1TLB}{TLB} (for debugging) and don't modify any internal state 
\begin{DoxyParams}{引数}
\item[{\em tc}]thread context to get the context id from \item[{\em vaddr}]virtual address to translate \item[{\em pa}]returned physical address \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
if the translation was successful 
\end{DoxyReturn}



\begin{DoxyCode}
107 {
108     updateMiscReg(tc);
109 
110     if (directToStage2) {
111         assert(stage2Tlb);
112         return stage2Tlb->translateFunctional(tc, va, pa);
113     }
114 
115     TlbEntry *e = lookup(va, asid, vmid, isHyp, isSecure, true, false,
116                          aarch64 ? aarch64EL : EL1);
117     if (!e)
118         return false;
119     pa = e->pAddr(va);
120     return true;
121 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a6ada13dabe05b90fee0464345cf0f654}{
\index{ArmISA::TLB@{ArmISA::TLB}!translateSe@{translateSe}}
\index{translateSe@{translateSe}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{translateSe}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translateSe ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Mode} {\em mode}, \/  {\bf Translation} $\ast$ {\em translation}, \/  bool \& {\em delay}, \/  bool {\em timing})}}
\label{classArmISA_1_1TLB_a6ada13dabe05b90fee0464345cf0f654}



\begin{DoxyCode}
536 {
537     updateMiscReg(tc);
538     Addr vaddr_tainted = req->getVaddr();
539     Addr vaddr = 0;
540     if (aarch64)
541         vaddr = purifyTaggedAddr(vaddr_tainted, tc, aarch64EL);
542     else
543         vaddr = vaddr_tainted;
544     uint32_t flags = req->getFlags();
545 
546     bool is_fetch = (mode == Execute);
547     bool is_write = (mode == Write);
548 
549     if (!is_fetch) {
550         assert(flags & MustBeOne);
551         if (sctlr.a || !(flags & AllowUnaligned)) {
552             if (vaddr & mask(flags & AlignmentMask)) {
553                 // LPAE is always disabled in SE mode
554                 return new DataAbort(vaddr_tainted,
555                         TlbEntry::DomainType::NoAccess, is_write,
556                                      ArmFault::AlignmentFault, isStage2,
557                                      ArmFault::VmsaTran);
558             }
559         }
560     }
561 
562     Addr paddr;
563     Process *p = tc->getProcessPtr();
564 
565     if (!p->pTable->translate(vaddr, paddr))
566         return Fault(new GenericPageTableFault(vaddr_tainted));
567     req->setPaddr(paddr);
568 
569     return NoFault;
570 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_aece4eb62debdc9703b211d68ce771521}{
\index{ArmISA::TLB@{ArmISA::TLB}!translateTiming@{translateTiming}}
\index{translateTiming@{translateTiming}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{translateTiming}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translateTiming ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Translation} $\ast$ {\em translation}, \/  {\bf Mode} {\em mode}, \/  {\bf TLB::ArmTranslationType} {\em tranType} = {\ttfamily NormalTran})}}
\label{classArmISA_1_1TLB_aece4eb62debdc9703b211d68ce771521}



\begin{DoxyCode}
1146 {
1147     updateMiscReg(tc, tranType);
1148 
1149     if (directToStage2) {
1150         assert(stage2Tlb);
1151         return stage2Tlb->translateTiming(req, tc, translation, mode, tranType);
1152     }
1153 
1154     assert(translation);
1155 
1156     return translateComplete(req, tc, translation, mode, tranType, isStage2);
1157 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_aa14d4829f5c7bce966547df0babb7487}{
\index{ArmISA::TLB@{ArmISA::TLB}!trickBoxCheck@{trickBoxCheck}}
\index{trickBoxCheck@{trickBoxCheck}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{trickBoxCheck}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} trickBoxCheck ({\bf RequestPtr} {\em req}, \/  {\bf Mode} {\em mode}, \/  {\bf TlbEntry::DomainType} {\em domain})}}
\label{classArmISA_1_1TLB_aa14d4829f5c7bce966547df0babb7487}



\begin{DoxyCode}
574 {
575     return NoFault;
576 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_af22e5d6d660b97db37003ac61ac4ee49}{
\index{ArmISA::TLB@{ArmISA::TLB}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classArmISA_1_1TLB_af22e5d6d660b97db37003ac61ac4ee49}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。\hypertarget{classArmISA_1_1TLB_a7eb66b75612ed7e8b075cd89dfd2b157}{
\index{ArmISA::TLB@{ArmISA::TLB}!updateMiscReg@{updateMiscReg}}
\index{updateMiscReg@{updateMiscReg}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{updateMiscReg}]{\setlength{\rightskip}{0pt plus 5cm}void updateMiscReg ({\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf ArmTranslationType} {\em tranType} = {\ttfamily NormalTran})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a7eb66b75612ed7e8b075cd89dfd2b157}



\begin{DoxyCode}
1201 {
1202     // check if the regs have changed, or the translation mode is different.
1203     // NOTE: the tran type doesn't affect stage 2 TLB's as they only handle
1204     // one type of translation anyway
1205     if (miscRegValid && ((tranType == curTranType) || isStage2)) {
1206         return;
1207     }
1208 
1209     DPRINTF(TLBVerbose, "TLB variables changed!\n");
1210     CPSR cpsr = tc->readMiscReg(MISCREG_CPSR);
1211     // Dependencies: SCR/SCR_EL3, CPSR
1212     isSecure  = inSecureState(tc);
1213     isSecure &= (tranType & HypMode)    == 0;
1214     isSecure &= (tranType & S1S2NsTran) == 0;
1215     aarch64 = !cpsr.width;
1216     if (aarch64) {  // AArch64
1217         aarch64EL = (ExceptionLevel) (uint8_t) cpsr.el;
1218         switch (aarch64EL) {
1219           case EL0:
1220           case EL1:
1221             {
1222                 sctlr = tc->readMiscReg(MISCREG_SCTLR_EL1);
1223                 ttbcr = tc->readMiscReg(MISCREG_TCR_EL1);
1224                 uint64_t ttbr_asid = ttbcr.a1 ?
1225                     tc->readMiscReg(MISCREG_TTBR1_EL1) :
1226                     tc->readMiscReg(MISCREG_TTBR0_EL1);
1227                 asid = bits(ttbr_asid,
1228                             (haveLargeAsid64 && ttbcr.as) ? 63 : 55, 48);
1229             }
1230             break;
1231           case EL2:
1232             sctlr = tc->readMiscReg(MISCREG_SCTLR_EL2);
1233             ttbcr = tc->readMiscReg(MISCREG_TCR_EL2);
1234             asid = -1;
1235             break;
1236           case EL3:
1237             sctlr = tc->readMiscReg(MISCREG_SCTLR_EL3);
1238             ttbcr = tc->readMiscReg(MISCREG_TCR_EL3);
1239             asid = -1;
1240             break;
1241         }
1242         scr = tc->readMiscReg(MISCREG_SCR_EL3);
1243         isPriv = aarch64EL != EL0;
1244         // @todo: modify this behaviour to support Virtualization in
1245         // AArch64
1246         vmid           = 0;
1247         isHyp          = false;
1248         directToStage2 = false;
1249         stage2Req      = false;
1250     } else {  // AArch32
1251         sctlr  = tc->readMiscReg(flattenMiscRegNsBanked(MISCREG_SCTLR, tc,
1252                                  !isSecure));
1253         ttbcr  = tc->readMiscReg(flattenMiscRegNsBanked(MISCREG_TTBCR, tc,
1254                                  !isSecure));
1255         scr    = tc->readMiscReg(MISCREG_SCR);
1256         isPriv = cpsr.mode != MODE_USER;
1257         if (haveLPAE && ttbcr.eae) {
1258             // Long-descriptor translation table format in use
1259             uint64_t ttbr_asid = tc->readMiscReg(
1260                 flattenMiscRegNsBanked(ttbcr.a1 ? MISCREG_TTBR1
1261                                                 : MISCREG_TTBR0,
1262                                        tc, !isSecure));
1263             asid = bits(ttbr_asid, 55, 48);
1264         } else {
1265             // Short-descriptor translation table format in use
1266             CONTEXTIDR context_id = tc->readMiscReg(flattenMiscRegNsBanked(
1267                 MISCREG_CONTEXTIDR, tc,!isSecure));
1268             asid = context_id.asid;
1269         }
1270         prrr = tc->readMiscReg(flattenMiscRegNsBanked(MISCREG_PRRR, tc,
1271                                !isSecure));
1272         nmrr = tc->readMiscReg(flattenMiscRegNsBanked(MISCREG_NMRR, tc,
1273                                !isSecure));
1274         dacr = tc->readMiscReg(flattenMiscRegNsBanked(MISCREG_DACR, tc,
1275                                !isSecure));
1276         hcr  = tc->readMiscReg(MISCREG_HCR);
1277 
1278         if (haveVirtualization) {
1279             vmid   = bits(tc->readMiscReg(MISCREG_VTTBR), 55, 48);
1280             isHyp  = cpsr.mode == MODE_HYP;
1281             isHyp |=  tranType & HypMode;
1282             isHyp &= (tranType & S1S2NsTran) == 0;
1283             isHyp &= (tranType & S1CTran)    == 0;
1284             if (isHyp) {
1285                 sctlr = tc->readMiscReg(MISCREG_HSCTLR);
1286             }
1287             // Work out if we should skip the first stage of translation and go
1288             // directly to stage 2. This value is cached so we don't have to
1289             // compute it for every translation.
1290             stage2Req      = hcr.vm && !isStage2 && !isHyp && !isSecure &&
1291                              !(tranType & S1CTran);
1292             directToStage2 = stage2Req && !sctlr.m;
1293         } else {
1294             vmid           = 0;
1295             stage2Req      = false;
1296             isHyp          = false;
1297             directToStage2 = false;
1298         }
1299     }
1300     miscRegValid = true;
1301     curTranType  = tranType;
1302 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1TLB_a3e576c3e0d39dfca708baea44ebf0617}{
\index{ArmISA::TLB@{ArmISA::TLB}!validVirtualAddress@{validVirtualAddress}}
\index{validVirtualAddress@{validVirtualAddress}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{validVirtualAddress}]{\setlength{\rightskip}{0pt plus 5cm}static bool validVirtualAddress ({\bf Addr} {\em vaddr})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classArmISA_1_1TLB_a3e576c3e0d39dfca708baea44ebf0617}
\hypertarget{classArmISA_1_1TLB_a19bf31f32ec6125d85acc1feeee28e47}{
\index{ArmISA::TLB@{ArmISA::TLB}!walkTrickBoxCheck@{walkTrickBoxCheck}}
\index{walkTrickBoxCheck@{walkTrickBoxCheck}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{walkTrickBoxCheck}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} walkTrickBoxCheck ({\bf Addr} {\em pa}, \/  bool {\em is\_\-secure}, \/  {\bf Addr} {\em va}, \/  {\bf Addr} {\em sz}, \/  bool {\em is\_\-exec}, \/  bool {\em is\_\-write}, \/  {\bf TlbEntry::DomainType} {\em domain}, \/  {\bf LookupLevel} {\em lookup\_\-level})}}
\label{classArmISA_1_1TLB_a19bf31f32ec6125d85acc1feeee28e47}



\begin{DoxyCode}
581 {
582     return NoFault;
583 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classArmISA_1_1TLB_a89972e483f89fb3a1694154f97ce2d9d}{
\index{ArmISA::TLB@{ArmISA::TLB}!\_\-attr@{\_\-attr}}
\index{\_\-attr@{\_\-attr}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{\_\-attr}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf \_\-attr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a89972e483f89fb3a1694154f97ce2d9d}
\hypertarget{classArmISA_1_1TLB_a52c06c8a54293998f3e1f71cdbd916f7}{
\index{ArmISA::TLB@{ArmISA::TLB}!aarch64@{aarch64}}
\index{aarch64@{aarch64}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{aarch64}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf aarch64}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a52c06c8a54293998f3e1f71cdbd916f7}
\hypertarget{classArmISA_1_1TLB_a658ce290954a428d8c5df11b8b5bd81b}{
\index{ArmISA::TLB@{ArmISA::TLB}!aarch64EL@{aarch64EL}}
\index{aarch64EL@{aarch64EL}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{aarch64EL}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ExceptionLevel} {\bf aarch64EL}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a658ce290954a428d8c5df11b8b5bd81b}
\hypertarget{classArmISA_1_1TLB_a1929e1032289676f78e07e4c6bc55369}{
\index{ArmISA::TLB@{ArmISA::TLB}!accesses@{accesses}}
\index{accesses@{accesses}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{accesses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf accesses}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a1929e1032289676f78e07e4c6bc55369}
\hypertarget{classArmISA_1_1TLB_aaafbdf0bc49ea504814d314b5f51d47e}{
\index{ArmISA::TLB@{ArmISA::TLB}!alignFaults@{alignFaults}}
\index{alignFaults@{alignFaults}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{alignFaults}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf alignFaults}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classArmISA_1_1TLB_aaafbdf0bc49ea504814d314b5f51d47e}
\hypertarget{classArmISA_1_1TLB_a984a2dcfd9509ab586bee117bb2a7cfb}{
\index{ArmISA::TLB@{ArmISA::TLB}!asid@{asid}}
\index{asid@{asid}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{asid}]{\setlength{\rightskip}{0pt plus 5cm}uint16\_\-t {\bf asid}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a984a2dcfd9509ab586bee117bb2a7cfb}
\hypertarget{classArmISA_1_1TLB_a2ebef8e3741ddc1169a0a05e6a48052e}{
\index{ArmISA::TLB@{ArmISA::TLB}!bootUncacheability@{bootUncacheability}}
\index{bootUncacheability@{bootUncacheability}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{bootUncacheability}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf bootUncacheability}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a2ebef8e3741ddc1169a0a05e6a48052e}
\hypertarget{classArmISA_1_1TLB_a23a689868acc5917efd41d7477757059}{
\index{ArmISA::TLB@{ArmISA::TLB}!curTranType@{curTranType}}
\index{curTranType@{curTranType}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{curTranType}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ArmTranslationType} {\bf curTranType}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a23a689868acc5917efd41d7477757059}
\hypertarget{classArmISA_1_1TLB_a9d6f500564b7a3bf1ded6bc18b3d47db}{
\index{ArmISA::TLB@{ArmISA::TLB}!dacr@{dacr}}
\index{dacr@{dacr}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{dacr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf dacr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a9d6f500564b7a3bf1ded6bc18b3d47db}
\hypertarget{classArmISA_1_1TLB_a16c6c6799c68307c82bc6304cf0b27b4}{
\index{ArmISA::TLB@{ArmISA::TLB}!directToStage2@{directToStage2}}
\index{directToStage2@{directToStage2}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{directToStage2}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf directToStage2}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a16c6c6799c68307c82bc6304cf0b27b4}
\hypertarget{classArmISA_1_1TLB_a718b0dd709705b2b6cbf1c5e33c387fd}{
\index{ArmISA::TLB@{ArmISA::TLB}!domainFaults@{domainFaults}}
\index{domainFaults@{domainFaults}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{domainFaults}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf domainFaults}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a718b0dd709705b2b6cbf1c5e33c387fd}
\hypertarget{classArmISA_1_1TLB_ad4c80b0aa999ae0403e2ffbc9a217aaa}{
\index{ArmISA::TLB@{ArmISA::TLB}!flushedEntries@{flushedEntries}}
\index{flushedEntries@{flushedEntries}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{flushedEntries}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf flushedEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classArmISA_1_1TLB_ad4c80b0aa999ae0403e2ffbc9a217aaa}
\hypertarget{classArmISA_1_1TLB_a14429a278d32a87d27c0d9df47269a12}{
\index{ArmISA::TLB@{ArmISA::TLB}!flushTlb@{flushTlb}}
\index{flushTlb@{flushTlb}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{flushTlb}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf flushTlb}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a14429a278d32a87d27c0d9df47269a12}
\hypertarget{classArmISA_1_1TLB_a678e74ffba8318815627ae109f96b17e}{
\index{ArmISA::TLB@{ArmISA::TLB}!flushTlbAsid@{flushTlbAsid}}
\index{flushTlbAsid@{flushTlbAsid}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{flushTlbAsid}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf flushTlbAsid}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a678e74ffba8318815627ae109f96b17e}
\hypertarget{classArmISA_1_1TLB_af504265daaa5a177333d30804fba83a8}{
\index{ArmISA::TLB@{ArmISA::TLB}!flushTlbMva@{flushTlbMva}}
\index{flushTlbMva@{flushTlbMva}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{flushTlbMva}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf flushTlbMva}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classArmISA_1_1TLB_af504265daaa5a177333d30804fba83a8}
\hypertarget{classArmISA_1_1TLB_a94bc002df9a21796ac29c74bc3ef8240}{
\index{ArmISA::TLB@{ArmISA::TLB}!flushTlbMvaAsid@{flushTlbMvaAsid}}
\index{flushTlbMvaAsid@{flushTlbMvaAsid}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{flushTlbMvaAsid}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf flushTlbMvaAsid}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a94bc002df9a21796ac29c74bc3ef8240}
\hypertarget{classArmISA_1_1TLB_a3aea18414c83c86fa366401cb767e7ab}{
\index{ArmISA::TLB@{ArmISA::TLB}!haveLargeAsid64@{haveLargeAsid64}}
\index{haveLargeAsid64@{haveLargeAsid64}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{haveLargeAsid64}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf haveLargeAsid64}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a3aea18414c83c86fa366401cb767e7ab}
\hypertarget{classArmISA_1_1TLB_a8e8469d916956ca8b9052ebd6f155e0b}{
\index{ArmISA::TLB@{ArmISA::TLB}!haveLPAE@{haveLPAE}}
\index{haveLPAE@{haveLPAE}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{haveLPAE}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf haveLPAE}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a8e8469d916956ca8b9052ebd6f155e0b}
\hypertarget{classArmISA_1_1TLB_a48e6871d9ab14ff31b50307f0c617f95}{
\index{ArmISA::TLB@{ArmISA::TLB}!haveVirtualization@{haveVirtualization}}
\index{haveVirtualization@{haveVirtualization}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{haveVirtualization}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf haveVirtualization}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a48e6871d9ab14ff31b50307f0c617f95}
\hypertarget{classArmISA_1_1TLB_ad0d8df2e2be956266458221c23763b4c}{
\index{ArmISA::TLB@{ArmISA::TLB}!hcr@{hcr}}
\index{hcr@{hcr}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{hcr}]{\setlength{\rightskip}{0pt plus 5cm}HCR {\bf hcr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_ad0d8df2e2be956266458221c23763b4c}
\hypertarget{classArmISA_1_1TLB_a224eed77bfb7a27359c9c3c1acbdbfaa}{
\index{ArmISA::TLB@{ArmISA::TLB}!hits@{hits}}
\index{hits@{hits}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{hits}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf hits}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a224eed77bfb7a27359c9c3c1acbdbfaa}
\hypertarget{classArmISA_1_1TLB_a98ccf1b183bddae403b637838f23fa49}{
\index{ArmISA::TLB@{ArmISA::TLB}!inserts@{inserts}}
\index{inserts@{inserts}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{inserts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf inserts}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a98ccf1b183bddae403b637838f23fa49}
\hypertarget{classArmISA_1_1TLB_a7268909f031909e2eab6994aa6406ae4}{
\index{ArmISA::TLB@{ArmISA::TLB}!instAccesses@{instAccesses}}
\index{instAccesses@{instAccesses}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{instAccesses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf instAccesses}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a7268909f031909e2eab6994aa6406ae4}
\hypertarget{classArmISA_1_1TLB_a6f516f4695aa8bb85a9a52e395689e1a}{
\index{ArmISA::TLB@{ArmISA::TLB}!instHits@{instHits}}
\index{instHits@{instHits}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{instHits}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf instHits}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a6f516f4695aa8bb85a9a52e395689e1a}
\hypertarget{classArmISA_1_1TLB_ae63ad13cb56fbd34a91d2093deaafad2}{
\index{ArmISA::TLB@{ArmISA::TLB}!instMisses@{instMisses}}
\index{instMisses@{instMisses}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{instMisses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf instMisses}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classArmISA_1_1TLB_ae63ad13cb56fbd34a91d2093deaafad2}
\hypertarget{classArmISA_1_1TLB_a104c09577173edc4f8ce6814cc33f0ae}{
\index{ArmISA::TLB@{ArmISA::TLB}!isHyp@{isHyp}}
\index{isHyp@{isHyp}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{isHyp}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf isHyp}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a104c09577173edc4f8ce6814cc33f0ae}
\hypertarget{classArmISA_1_1TLB_ae5a4adef864b3b2b23001750a8a89499}{
\index{ArmISA::TLB@{ArmISA::TLB}!isPriv@{isPriv}}
\index{isPriv@{isPriv}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{isPriv}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf isPriv}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_ae5a4adef864b3b2b23001750a8a89499}
\hypertarget{classArmISA_1_1TLB_a62bc84f4251f16cf0cfa0f8d96e00c37}{
\index{ArmISA::TLB@{ArmISA::TLB}!isSecure@{isSecure}}
\index{isSecure@{isSecure}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{isSecure}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf isSecure}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a62bc84f4251f16cf0cfa0f8d96e00c37}
\hypertarget{classArmISA_1_1TLB_a07545f2ccf0498cfe71558779680f062}{
\index{ArmISA::TLB@{ArmISA::TLB}!isStage2@{isStage2}}
\index{isStage2@{isStage2}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{isStage2}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf isStage2}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a07545f2ccf0498cfe71558779680f062}
\hypertarget{classArmISA_1_1TLB_ab11476fda4a6785ee0b6096e2e50f30c}{
\index{ArmISA::TLB@{ArmISA::TLB}!miscRegValid@{miscRegValid}}
\index{miscRegValid@{miscRegValid}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{miscRegValid}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf miscRegValid}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_ab11476fda4a6785ee0b6096e2e50f30c}
\hypertarget{classArmISA_1_1TLB_a4b8b96257f1e97cd5730673f38f9571c}{
\index{ArmISA::TLB@{ArmISA::TLB}!misses@{misses}}
\index{misses@{misses}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{misses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf misses}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a4b8b96257f1e97cd5730673f38f9571c}
\hypertarget{classArmISA_1_1TLB_a763ad3cda6c2782d46835a3b2c4b5515}{
\index{ArmISA::TLB@{ArmISA::TLB}!nmrr@{nmrr}}
\index{nmrr@{nmrr}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{nmrr}]{\setlength{\rightskip}{0pt plus 5cm}NMRR {\bf nmrr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a763ad3cda6c2782d46835a3b2c4b5515}
\hypertarget{classArmISA_1_1TLB_a95307396029ef99d258ca5284cd8b284}{
\index{ArmISA::TLB@{ArmISA::TLB}!permsFaults@{permsFaults}}
\index{permsFaults@{permsFaults}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{permsFaults}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf permsFaults}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a95307396029ef99d258ca5284cd8b284}
\hypertarget{classArmISA_1_1TLB_a8d76399ea2182eaf505e54da078f5202}{
\index{ArmISA::TLB@{ArmISA::TLB}!prefetchFaults@{prefetchFaults}}
\index{prefetchFaults@{prefetchFaults}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{prefetchFaults}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf prefetchFaults}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a8d76399ea2182eaf505e54da078f5202}
\hypertarget{classArmISA_1_1TLB_a06fc88abc8a8aa441c512ebb7531b3d7}{
\index{ArmISA::TLB@{ArmISA::TLB}!prrr@{prrr}}
\index{prrr@{prrr}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{prrr}]{\setlength{\rightskip}{0pt plus 5cm}PRRR {\bf prrr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a06fc88abc8a8aa441c512ebb7531b3d7}
\hypertarget{classArmISA_1_1TLB_a7450c3dc2cffd22401a23ddc29b0c036}{
\index{ArmISA::TLB@{ArmISA::TLB}!rangeMRU@{rangeMRU}}
\index{rangeMRU@{rangeMRU}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{rangeMRU}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf rangeMRU}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a7450c3dc2cffd22401a23ddc29b0c036}
\hypertarget{classArmISA_1_1TLB_a1ebd2c58048a00cc55442a58e6782f35}{
\index{ArmISA::TLB@{ArmISA::TLB}!readAccesses@{readAccesses}}
\index{readAccesses@{readAccesses}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{readAccesses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf readAccesses}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a1ebd2c58048a00cc55442a58e6782f35}
\hypertarget{classArmISA_1_1TLB_a36a79efeb718e4de41970178013dac63}{
\index{ArmISA::TLB@{ArmISA::TLB}!readHits@{readHits}}
\index{readHits@{readHits}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{readHits}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf readHits}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a36a79efeb718e4de41970178013dac63}
\hypertarget{classArmISA_1_1TLB_a262cd06e148f8dd362b73ee2a8c87ce0}{
\index{ArmISA::TLB@{ArmISA::TLB}!readMisses@{readMisses}}
\index{readMisses@{readMisses}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{readMisses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf readMisses}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a262cd06e148f8dd362b73ee2a8c87ce0}
\hypertarget{classArmISA_1_1TLB_ace0bf26677706ecff809bd4c76d33c8c}{
\index{ArmISA::TLB@{ArmISA::TLB}!scr@{scr}}
\index{scr@{scr}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{scr}]{\setlength{\rightskip}{0pt plus 5cm}SCR {\bf scr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_ace0bf26677706ecff809bd4c76d33c8c}
\hypertarget{classArmISA_1_1TLB_a43c4d132ca97c6cc5358f7be3c2b5a69}{
\index{ArmISA::TLB@{ArmISA::TLB}!sctlr@{sctlr}}
\index{sctlr@{sctlr}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{sctlr}]{\setlength{\rightskip}{0pt plus 5cm}SCTLR {\bf sctlr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a43c4d132ca97c6cc5358f7be3c2b5a69}
\hypertarget{classArmISA_1_1TLB_a439227feff9d7f55384e8780cfc2eb82}{
\index{ArmISA::TLB@{ArmISA::TLB}!size@{size}}
\index{size@{size}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{size}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf size}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a439227feff9d7f55384e8780cfc2eb82}
\hypertarget{classArmISA_1_1TLB_a21ea64a0a6d9600fb09fff0854fd55d7}{
\index{ArmISA::TLB@{ArmISA::TLB}!stage2Mmu@{stage2Mmu}}
\index{stage2Mmu@{stage2Mmu}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{stage2Mmu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stage2MMU}$\ast$ {\bf stage2Mmu}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a21ea64a0a6d9600fb09fff0854fd55d7}
\hypertarget{classArmISA_1_1TLB_a52120124577a3b7c28a4e8876cd36a8b}{
\index{ArmISA::TLB@{ArmISA::TLB}!stage2Req@{stage2Req}}
\index{stage2Req@{stage2Req}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{stage2Req}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf stage2Req}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a52120124577a3b7c28a4e8876cd36a8b}
\hypertarget{classArmISA_1_1TLB_a2188cef93e9eb4ac6383c0ca4f44dc36}{
\index{ArmISA::TLB@{ArmISA::TLB}!stage2Tlb@{stage2Tlb}}
\index{stage2Tlb@{stage2Tlb}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{stage2Tlb}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TLB}$\ast$ {\bf stage2Tlb}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a2188cef93e9eb4ac6383c0ca4f44dc36}
\hypertarget{classArmISA_1_1TLB_a434ae74dec9e8168e4f338aeb18d5931}{
\index{ArmISA::TLB@{ArmISA::TLB}!table@{table}}
\index{table@{table}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{table}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TlbEntry}$\ast$ {\bf table}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a434ae74dec9e8168e4f338aeb18d5931}
\hypertarget{classArmISA_1_1TLB_ae4dec2d4d5730361d51d9f4b24dee89c}{
\index{ArmISA::TLB@{ArmISA::TLB}!tableWalker@{tableWalker}}
\index{tableWalker@{tableWalker}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{tableWalker}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TableWalker}$\ast$ {\bf tableWalker}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_ae4dec2d4d5730361d51d9f4b24dee89c}
\hypertarget{classArmISA_1_1TLB_ad6762be565087b4bfb87f5bcb42673e7}{
\index{ArmISA::TLB@{ArmISA::TLB}!ttbcr@{ttbcr}}
\index{ttbcr@{ttbcr}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{ttbcr}]{\setlength{\rightskip}{0pt plus 5cm}TTBCR {\bf ttbcr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_ad6762be565087b4bfb87f5bcb42673e7}
\hypertarget{classArmISA_1_1TLB_add293169f7f2ac526b3fa14f950cf0bb}{
\index{ArmISA::TLB@{ArmISA::TLB}!vmid@{vmid}}
\index{vmid@{vmid}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{vmid}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf vmid}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_add293169f7f2ac526b3fa14f950cf0bb}
\hypertarget{classArmISA_1_1TLB_aaf48f6b8c76d54c75a6156c32ac6405f}{
\index{ArmISA::TLB@{ArmISA::TLB}!writeAccesses@{writeAccesses}}
\index{writeAccesses@{writeAccesses}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{writeAccesses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf writeAccesses}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1TLB_aaf48f6b8c76d54c75a6156c32ac6405f}
\hypertarget{classArmISA_1_1TLB_a1d93d3754ee97de787330f7620867026}{
\index{ArmISA::TLB@{ArmISA::TLB}!writeHits@{writeHits}}
\index{writeHits@{writeHits}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{writeHits}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf writeHits}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a1d93d3754ee97de787330f7620867026}
\hypertarget{classArmISA_1_1TLB_a607353d27be8640c6f48a295794322d6}{
\index{ArmISA::TLB@{ArmISA::TLB}!writeMisses@{writeMisses}}
\index{writeMisses@{writeMisses}!ArmISA::TLB@{ArmISA::TLB}}
\subsubsection[{writeMisses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf writeMisses}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classArmISA_1_1TLB_a607353d27be8640c6f48a295794322d6}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/arm/\hyperlink{arch_2arm_2tlb_8hh}{tlb.hh}\item 
arch/arm/\hyperlink{arch_2arm_2tlb_8cc}{tlb.cc}\end{DoxyCompactItemize}
