\hypertarget{classResource}{
\section{クラス Resource}
\label{classResource}\index{Resource@{Resource}}
}


{\ttfamily \#include $<$resource.hh$>$}Resourceに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=12cm]{classResource}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classRefCountingPtr}{ThePipeline::DynInstPtr} \hyperlink{classResource_af9d0c8a46736ba6aa2d8bb94da1a5e73}{DynInstPtr}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classResource_a0fa53d2551f0069c7ce630fca9105c63}{Resource} (std::string res\_\-name, int res\_\-id, int res\_\-width, \hyperlink{classCycles}{Cycles} res\_\-latency, \hyperlink{classInOrderCPU}{InOrderCPU} $\ast$\_\-cpu)
\item 
virtual \hyperlink{classResource_af04be79e8cd12b4e3ab7361f3237ed26}{$\sim$Resource} ()
\item 
virtual std::string \hyperlink{classResource_af1801e31af6399bccce114ab12575168}{name} ()
\item 
int \hyperlink{classResource_a67283be3f45257d1e0c474c563ebb6b6}{getId} ()
\item 
virtual void \hyperlink{classResource_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
virtual void \hyperlink{classResource_aef17f15baa657a3b0b17d6a2c855fb02}{initSlots} ()
\item 
virtual void \hyperlink{classResource_ac1739a9be0fbd5d96cf441cd3b2c1c78}{regStats} ()
\item 
virtual void \hyperlink{classResource_ab75d2f4e158982d66b44263d96cdd058}{activateThread} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
virtual void \hyperlink{classResource_ad11d9216ad92d9036ebf37844cf6e706}{deactivateThread} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
virtual void \hyperlink{classResource_ad2f3fddbc6dd67ef5e3a84cd7a9814e6}{suspendThread} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
virtual void \hyperlink{classResource_a2cf5450ce736e0c76aca0d4ef24b922a}{updateAfterContextSwitch} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
virtual void \hyperlink{classResource_ad09300971c77caba13bf59e77b99ea24}{instGraduated} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} seq\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
virtual void \hyperlink{classResource_a1eb2a0229740a87bde0282416035b864}{trap} (\hyperlink{classRefCountingPtr}{Fault} fault, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid, \hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
virtual \hyperlink{classResourceRequest}{ResourceRequest} $\ast$ \hyperlink{classResource_acd38b2c94092af431807b57f7b7cef6c}{request} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
virtual int \hyperlink{classResource_ab3ba2ee95c723c8c056db0a1f2a6dfd3}{getSlot} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
virtual int \hyperlink{classResource_a990f82d45376225d628def316f024f6b}{findSlot} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
virtual void \hyperlink{classResource_a19ec1254d9f9be5b3058fad36034f7da}{freeSlot} (int slot\_\-idx)
\item 
virtual \hyperlink{classResourceRequest}{ResourceRequest} $\ast$ \hyperlink{classResource_aae5ce84f94a1057d7f60172daf5d731d}{getRequest} (\hyperlink{classRefCountingPtr}{DynInstPtr} \_\-inst, int stage\_\-num, int res\_\-idx, int slot\_\-num, unsigned cmd)
\item 
void \hyperlink{classResource_a9f90c5efcf202dda43bb780a645bee1f}{scheduleExecution} (int slot\_\-idx)
\item 
virtual void \hyperlink{classResource_a39af49c5568d1db3f53c12d7d6914c32}{execute} (int slot\_\-idx)
\item 
virtual \hyperlink{classRefCountingPtr}{Fault} \hyperlink{classResource_a04a5d185526d3121fee572712fe353ad}{doFetchAccess} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
virtual void \hyperlink{classResource_aa874bbb279acf67627511df8f4c3dce5}{doCacheAccess} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, uint64\_\-t $\ast$write\_\-result=NULL, \hyperlink{classCacheRequest}{CacheReqPtr} split\_\-req=NULL)
\item 
void \hyperlink{classResource_ab03920cf8ee0a1dd131d4a6db0320f71}{setupSquash} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, int stage\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
virtual void \hyperlink{classResource_a52235c5e3d912452f254dc45f1496fd2}{squash} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, int stage\_\-num, \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} squash\_\-seq\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
virtual void \hyperlink{classResource_ae2d6fba25ece343caad6eb029a4a3b5b}{squashDueToMemStall} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, int stage\_\-num, \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} squash\_\-seq\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classResource_ac04c1a8a5c1212f9bbdc1ce83b1da882}{squashThenTrap} (int stage\_\-num, \hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
int \hyperlink{classResource_aa376a7fab43ff33531fff37daaf97d30}{slotsAvail} ()
\item 
int \hyperlink{classResource_a7996fa2858e57c95ac52ee2813f816f7}{slotsInUse} ()
\item 
void \hyperlink{classResource_a55e9744a3539be9ff746b13b1d6bafc3}{scheduleEvent} (int slot\_\-idx, \hyperlink{classCycles}{Cycles} delay)
\item 
bool \hyperlink{classResource_a9463594c1003adcd1e810ad6cea904eb}{scheduleEvent} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, \hyperlink{classCycles}{Cycles} delay)
\item 
void \hyperlink{classResource_a30247366c4c8cb82c2a196a286d309ad}{unscheduleEvent} (int slot\_\-idx)
\item 
bool \hyperlink{classResource_a2ca5964896e91fdb616377369e29cfc4}{unscheduleEvent} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
virtual \hyperlink{classResourceRequest}{ResReqPtr} \hyperlink{classResource_ae3afc1c63d17a49a6301bd18fca574a0}{findRequest} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
void \hyperlink{classResource_a00d6f4600ca80ac12352a9c0d3922857}{rejectRequest} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
virtual void \hyperlink{classResource_a9063fd6f97e36e3565247339ffa3882c}{requestAgain} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, bool \&try\_\-request)
\item 
virtual \hyperlink{classCycles}{Cycles} \hyperlink{classResource_a0d3550b57856a6b656d76b87a9d6b6e8}{getLatency} (int slot\_\-num)
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classResourceRequest}{ResReqPtr} $>$ \hyperlink{classResource_a83b4e5928b54d2813c3c4911043e677d}{reqs}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ int $>$ \hyperlink{classResource_a1dd2ecf45bf9024f273d09813d993f97}{availSlots}
\item 
\hyperlink{classInOrderCPU}{InOrderCPU} $\ast$ \hyperlink{classResource_a41d682c28d0f49e04393c52815808782}{cpu}
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
std::string \hyperlink{classResource_a991d4c92f58169fd45fe3f1c1881ac9e}{resName}
\item 
int \hyperlink{classResource_a7441ef0865bcb3db9b8064dd7375c1ea}{id}
\item 
int \hyperlink{classResource_a2474a5474cbff19523a51eb1de01cda4}{width}
\item 
const \hyperlink{classCycles}{Cycles} \hyperlink{classResource_a46b9d67ee437c6ecdbedca8ec8d2ed40}{latency}
\item 
\hyperlink{classResourceEvent}{ResourceEvent} $\ast$ \hyperlink{classResource_abde7a6c4ff046aa4c2ecd476c4266be3}{resourceEvent}
\item 
\hyperlink{classResourceRequest}{ResReqPtr} \hyperlink{classResource_a52489b62c55d7db3b70c3713b3000601}{deniedReq}
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classResource_a80da161b04f097f36d40b2bb699192b6}{ResourceEvent}
\item 
class \hyperlink{classResource_ae78e4599e7afd86b067119e90ac5dfed}{ResourceRequest}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classResource_af9d0c8a46736ba6aa2d8bb94da1a5e73}{
\index{Resource@{Resource}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!Resource@{Resource}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf ThePipeline::DynInstPtr} {\bf DynInstPtr}}}
\label{classResource_af9d0c8a46736ba6aa2d8bb94da1a5e73}


\hyperlink{classAGENUnit_a32d1573770d3d1d96a1741ac80433e33}{AGENUnit}, \hyperlink{classBranchPredictor_af9d0c8a46736ba6aa2d8bb94da1a5e73}{BranchPredictor}, \hyperlink{classCacheUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{CacheUnit}, \hyperlink{classDecodeUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{DecodeUnit}, \hyperlink{classExecutionUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{ExecutionUnit}, \hyperlink{classFetchSeqUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{FetchSeqUnit}, \hyperlink{classFetchUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{FetchUnit}, \hyperlink{classGraduationUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{GraduationUnit}, \hyperlink{classInstBuffer_af9d0c8a46736ba6aa2d8bb94da1a5e73}{InstBuffer}, \hyperlink{classMemDepUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{MemDepUnit$<$ MemDepPred, Impl $>$}, \hyperlink{classMultDivUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{MultDivUnit}, \hyperlink{classTLBUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{TLBUnit}, \hyperlink{classUseDefUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{UseDefUnit}, と \hyperlink{classMemDepUnit_a028ce10889c5f6450239d9e9a7347976}{MemDepUnit$<$ MemDepPred, Impl $>$}で再定義されています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classResource_a0fa53d2551f0069c7ce630fca9105c63}{
\index{Resource@{Resource}!Resource@{Resource}}
\index{Resource@{Resource}!Resource@{Resource}}
\subsubsection[{Resource}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Resource} (std::string {\em res\_\-name}, \/  int {\em res\_\-id}, \/  int {\em res\_\-width}, \/  {\bf Cycles} {\em res\_\-latency}, \/  {\bf InOrderCPU} $\ast$ {\em \_\-cpu})}}
\label{classResource_a0fa53d2551f0069c7ce630fca9105c63}
\hypertarget{classResource_af04be79e8cd12b4e3ab7361f3237ed26}{
\index{Resource@{Resource}!$\sim$Resource@{$\sim$Resource}}
\index{$\sim$Resource@{$\sim$Resource}!Resource@{Resource}}
\subsubsection[{$\sim$Resource}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf Resource} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classResource_af04be79e8cd12b4e3ab7361f3237ed26}



\begin{DoxyCode}
60 {
61     if (resourceEvent) {
62         delete [] resourceEvent;
63     }
64 
65     delete deniedReq;
66 
67     for (int i = 0; i < width; i++) {
68         delete reqs[i];
69     }
70 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classResource_ab75d2f4e158982d66b44263d96cdd058}{
\index{Resource@{Resource}!activateThread@{activateThread}}
\index{activateThread@{activateThread}!Resource@{Resource}}
\subsubsection[{activateThread}]{\setlength{\rightskip}{0pt plus 5cm}virtual void activateThread ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classResource_ab75d2f4e158982d66b44263d96cdd058}
Resources that care about thread activation override this. 

\hyperlink{classFetchSeqUnit_a687aa4600423bb30ecf3bb1da6cd6000}{FetchSeqUnit}で再定義されています。


\begin{DoxyCode}
86 { }
\end{DoxyCode}
\hypertarget{classResource_ad11d9216ad92d9036ebf37844cf6e706}{
\index{Resource@{Resource}!deactivateThread@{deactivateThread}}
\index{deactivateThread@{deactivateThread}!Resource@{Resource}}
\subsubsection[{deactivateThread}]{\setlength{\rightskip}{0pt plus 5cm}void deactivateThread ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classResource_ad11d9216ad92d9036ebf37844cf6e706}
Deactivate Thread. Default action is to squash all instructions from deactivated thread. 

\hyperlink{classFetchSeqUnit_ad11d9216ad92d9036ebf37844cf6e706}{FetchSeqUnit}で再定義されています。


\begin{DoxyCode}
284 {
285     // In the most basic case, deactivation means squashing everything
286     // from a particular thread
287     DynInstPtr dummy_inst = new InOrderDynInst(cpu, NULL, 0, tid, tid);
288     squash(dummy_inst, 0, 0, tid);
289 }
\end{DoxyCode}
\hypertarget{classResource_aa874bbb279acf67627511df8f4c3dce5}{
\index{Resource@{Resource}!doCacheAccess@{doCacheAccess}}
\index{doCacheAccess@{doCacheAccess}!Resource@{Resource}}
\subsubsection[{doCacheAccess}]{\setlength{\rightskip}{0pt plus 5cm}virtual void doCacheAccess ({\bf DynInstPtr} {\em inst}, \/  uint64\_\-t $\ast$ {\em write\_\-result} = {\ttfamily NULL}, \/  {\bf CacheReqPtr} {\em split\_\-req} = {\ttfamily NULL})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classResource_aa874bbb279acf67627511df8f4c3dce5}
Read/Write on behalf of an instruction. Will check to see if instruction is actually in resource before trying to do access.Needs to be defined for derived units. 

\hyperlink{classCacheUnit_afc4f09d8e36072c3a3c361f2edf108b4}{CacheUnit}で再定義されています。


\begin{DoxyCode}
161     { panic("doCacheAccess undefined for %s", name()); }
\end{DoxyCode}
\hypertarget{classResource_a04a5d185526d3121fee572712fe353ad}{
\index{Resource@{Resource}!doFetchAccess@{doFetchAccess}}
\index{doFetchAccess@{doFetchAccess}!Resource@{Resource}}
\subsubsection[{doFetchAccess}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Fault} doFetchAccess ({\bf DynInstPtr} {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classResource_a04a5d185526d3121fee572712fe353ad}
Fetch on behalf of an instruction. Will check to see if instruction is actually in resource before trying to fetch. Needs to be defined for derived units. 


\begin{DoxyCode}
148     { panic("doFetchAccess undefined for %s", name()); return NoFault; }
\end{DoxyCode}
\hypertarget{classResource_a39af49c5568d1db3f53c12d7d6914c32}{
\index{Resource@{Resource}!execute@{execute}}
\index{execute@{execute}!Resource@{Resource}}
\subsubsection[{execute}]{\setlength{\rightskip}{0pt plus 5cm}void execute (int {\em slot\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classResource_a39af49c5568d1db3f53c12d7d6914c32}
Execute the function of this resource. The Default is action is to do nothing. More specific models will derive from this class and define their own execute function. 

\hyperlink{classAGENUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{AGENUnit}, \hyperlink{classBranchPredictor_a7b7fff82f8c9cbdb02add1346f60bb9e}{BranchPredictor}, \hyperlink{classCacheUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{CacheUnit}, \hyperlink{classDecodeUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{DecodeUnit}, \hyperlink{classExecutionUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{ExecutionUnit}, \hyperlink{classFetchSeqUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{FetchSeqUnit}, \hyperlink{classFetchUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{FetchUnit}, \hyperlink{classGraduationUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{GraduationUnit}, \hyperlink{classInstBuffer_a7b7fff82f8c9cbdb02add1346f60bb9e}{InstBuffer}, \hyperlink{classMemDepUnit_a74d7cd749b79186057ad86f5f7b79fd2}{MemDepUnit$<$ MemDepPred, Impl $>$}, \hyperlink{classMultDivUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{MultDivUnit}, \hyperlink{classTLBUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{TLBUnit}, と \hyperlink{classUseDefUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{UseDefUnit}で再定義されています。


\begin{DoxyCode}
274 {
275     //@todo: have each resource print out command their executing
276     DPRINTF(Resource, "[tid:%i]: Executing %s resource.\n",
277             reqs[slot_idx]->getTid(), name());
278     reqs[slot_idx]->setCompleted(true);
279     reqs[slot_idx]->done();
280 }
\end{DoxyCode}
\hypertarget{classResource_ae3afc1c63d17a49a6301bd18fca574a0}{
\index{Resource@{Resource}!findRequest@{findRequest}}
\index{findRequest@{findRequest}!Resource@{Resource}}
\subsubsection[{findRequest}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ResReqPtr} findRequest ({\bf DynInstPtr} {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classResource_ae3afc1c63d17a49a6301bd18fca574a0}
Find the request that corresponds to this instruction 

\hyperlink{classCacheUnit_ae3afc1c63d17a49a6301bd18fca574a0}{CacheUnit}, と \hyperlink{classUseDefUnit_ae3afc1c63d17a49a6301bd18fca574a0}{UseDefUnit}で再定義されています。


\begin{DoxyCode}
254 {
255     for (int i = 0; i < width; i++) {
256         if (reqs[i]->valid &&
257             reqs[i]->getInst() == inst) {
258             return reqs[i];
259         }
260     }
261 
262     return NULL;
263 }
\end{DoxyCode}
\hypertarget{classResource_a990f82d45376225d628def316f024f6b}{
\index{Resource@{Resource}!findSlot@{findSlot}}
\index{findSlot@{findSlot}!Resource@{Resource}}
\subsubsection[{findSlot}]{\setlength{\rightskip}{0pt plus 5cm}int findSlot ({\bf DynInstPtr} {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classResource_a990f82d45376225d628def316f024f6b}
Find the slot that this instruction is using in a resource 


\begin{DoxyCode}
136 {
137     int slot_num = -1;
138 
139     for (int i = 0; i < width; i++) {
140         if (reqs[i]->valid &&
141             reqs[i]->getInst()->seqNum == inst->seqNum) {
142             slot_num = reqs[i]->getSlot();
143         }
144     }
145     return slot_num;
146 }
\end{DoxyCode}
\hypertarget{classResource_a19ec1254d9f9be5b3058fad36034f7da}{
\index{Resource@{Resource}!freeSlot@{freeSlot}}
\index{freeSlot@{freeSlot}!Resource@{Resource}}
\subsubsection[{freeSlot}]{\setlength{\rightskip}{0pt plus 5cm}void freeSlot (int {\em slot\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classResource_a19ec1254d9f9be5b3058fad36034f7da}
Free a resource slot 


\begin{DoxyCode}
123 {
124     DPRINTF(Resource, "Deallocating [slot:%i].\n",
125             slot_idx);
126 
127     // Put slot number on this resource's free list
128     availSlots.push_back(slot_idx);
129 
130     // Invalidate Request & Reset it's flags
131     reqs[slot_idx]->clearRequest();
132 }
\end{DoxyCode}
\hypertarget{classResource_a67283be3f45257d1e0c474c563ebb6b6}{
\index{Resource@{Resource}!getId@{getId}}
\index{getId@{getId}!Resource@{Resource}}
\subsubsection[{getId}]{\setlength{\rightskip}{0pt plus 5cm}int getId ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classResource_a67283be3f45257d1e0c474c563ebb6b6}
Return ID for this resource 


\begin{DoxyCode}
74 { return id; }
\end{DoxyCode}
\hypertarget{classResource_a0d3550b57856a6b656d76b87a9d6b6e8}{
\index{Resource@{Resource}!getLatency@{getLatency}}
\index{getLatency@{getLatency}!Resource@{Resource}}
\subsubsection[{getLatency}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Cycles} getLatency (int {\em slot\_\-num})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classResource_a0d3550b57856a6b656d76b87a9d6b6e8}
Return Latency of \hyperlink{classResource}{Resource} 


\begin{DoxyCode}
211 { return latency; }
\end{DoxyCode}
\hypertarget{classResource_aae5ce84f94a1057d7f60172daf5d731d}{
\index{Resource@{Resource}!getRequest@{getRequest}}
\index{getRequest@{getRequest}!Resource@{Resource}}
\subsubsection[{getRequest}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ResReqPtr} getRequest ({\bf DynInstPtr} {\em \_\-inst}, \/  int {\em stage\_\-num}, \/  int {\em res\_\-idx}, \/  int {\em slot\_\-num}, \/  unsigned {\em cmd})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classResource_aae5ce84f94a1057d7f60172daf5d731d}
\hyperlink{classRequest}{Request} usage of a resource for this instruction. If this instruction already has made this request to this resource, and that request is uncompleted this function will just return that request 

\hyperlink{classCacheUnit_aae5ce84f94a1057d7f60172daf5d731d}{CacheUnit}, \hyperlink{classFetchUnit_aae5ce84f94a1057d7f60172daf5d731d}{FetchUnit}, \hyperlink{classTLBUnit_a98b2e8ae07f180e62be1d03beae400f9}{TLBUnit}, と \hyperlink{classUseDefUnit_aae5ce84f94a1057d7f60172daf5d731d}{UseDefUnit}で再定義されています。


\begin{DoxyCode}
247 {
248     reqs[slot_num]->setRequest(inst, stage_num, id, slot_num, cmd);
249     return reqs[slot_num];
250 }
\end{DoxyCode}
\hypertarget{classResource_ab3ba2ee95c723c8c056db0a1f2a6dfd3}{
\index{Resource@{Resource}!getSlot@{getSlot}}
\index{getSlot@{getSlot}!Resource@{Resource}}
\subsubsection[{getSlot}]{\setlength{\rightskip}{0pt plus 5cm}int getSlot ({\bf DynInstPtr} {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classResource_ab3ba2ee95c723c8c056db0a1f2a6dfd3}
Get the next available slot in this resource. Instruction is passed so that resources can check the instruction before allocating a slot if necessary. 

\hyperlink{classCacheUnit_ab3ba2ee95c723c8c056db0a1f2a6dfd3}{CacheUnit}, \hyperlink{classMultDivUnit_ab3ba2ee95c723c8c056db0a1f2a6dfd3}{MultDivUnit}, と \hyperlink{classTLBUnit_ab3ba2ee95c723c8c056db0a1f2a6dfd3}{TLBUnit}で再定義されています。


\begin{DoxyCode}
150 {
151     int slot_num = -1;
152 
153     if (slotsAvail() != 0) {
154         slot_num = availSlots[0];
155 
156         vector<int>::iterator vect_it = availSlots.begin();
157 
158         assert(slot_num == *vect_it);
159 
160         availSlots.erase(vect_it);
161     }
162 
163     return slot_num;
164 }
\end{DoxyCode}
\hypertarget{classResource_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{Resource@{Resource}!init@{init}}
\index{init@{init}!Resource@{Resource}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classResource_a02fd73d861ef2e4aabb38c0c9ff82947}
Any extra initiliazation stuff can be set up using this function that should get called before the simulation starts (tick 0) 

\hyperlink{classCacheUnit_a02fd73d861ef2e4aabb38c0c9ff82947}{CacheUnit}, \hyperlink{classFetchSeqUnit_a02fd73d861ef2e4aabb38c0c9ff82947}{FetchSeqUnit}, \hyperlink{classMultDivUnit_a02fd73d861ef2e4aabb38c0c9ff82947}{MultDivUnit}, \hyperlink{classTLBUnit_a02fd73d861ef2e4aabb38c0c9ff82947}{TLBUnit}, と \hyperlink{classUseDefUnit_a02fd73d861ef2e4aabb38c0c9ff82947}{UseDefUnit}で再定義されています。


\begin{DoxyCode}
75 {
76     // If the resource has a zero-cycle (no latency)
77     // function, then no reason to have events
78     // that will process them for the right tick
79     if (latency > Cycles(0))
80       resourceEvent = new ResourceEvent[width];
81 
82 
83     for (int i = 0; i < width; i++)
84       reqs[i] = new ResourceRequest(this);
85 
86 
87     initSlots();
88 }
\end{DoxyCode}
\hypertarget{classResource_aef17f15baa657a3b0b17d6a2c855fb02}{
\index{Resource@{Resource}!initSlots@{initSlots}}
\index{initSlots@{initSlots}!Resource@{Resource}}
\subsubsection[{initSlots}]{\setlength{\rightskip}{0pt plus 5cm}void initSlots ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classResource_aef17f15baa657a3b0b17d6a2c855fb02}



\begin{DoxyCode}
92 {
93     // Add available slot numbers for resource
94     for (int slot_idx = 0; slot_idx < width; slot_idx++) {
95         availSlots.push_back(slot_idx);
96 
97         if (resourceEvent) {
98             resourceEvent[slot_idx].init(this, slot_idx);
99         }
100     }
101 }
\end{DoxyCode}
\hypertarget{classResource_ad09300971c77caba13bf59e77b99ea24}{
\index{Resource@{Resource}!instGraduated@{instGraduated}}
\index{instGraduated@{instGraduated}!Resource@{Resource}}
\subsubsection[{instGraduated}]{\setlength{\rightskip}{0pt plus 5cm}virtual void instGraduated ({\bf InstSeqNum} {\em seq\_\-num}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classResource_ad09300971c77caba13bf59e77b99ea24}
Resources that care when an instruction has been graduated can override this 

\hyperlink{classBranchPredictor_a3f5f4da90448a4c3a3c0533881fb3129}{BranchPredictor}で再定義されています。


\begin{DoxyCode}
104 { }
\end{DoxyCode}
\hypertarget{classResource_af1801e31af6399bccce114ab12575168}{
\index{Resource@{Resource}!name@{name}}
\index{name@{name}!Resource@{Resource}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classResource_af1801e31af6399bccce114ab12575168}
Return name of this resource 


\begin{DoxyCode}
105 {
106     return cpu->name() + "."  + resName;
107 }
\end{DoxyCode}
\hypertarget{classResource_ac1739a9be0fbd5d96cf441cd3b2c1c78}{
\index{Resource@{Resource}!regStats@{regStats}}
\index{regStats@{regStats}!Resource@{Resource}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}virtual void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classResource_ac1739a9be0fbd5d96cf441cd3b2c1c78}
\hyperlink{classRegister}{Register} \hyperlink{namespaceStats}{Stats} for this resource 

\hyperlink{classAGENUnit_a4dc637449366fcdfc4e764cdf12d9b11}{AGENUnit}, \hyperlink{classBranchPredictor_a4dc637449366fcdfc4e764cdf12d9b11}{BranchPredictor}, \hyperlink{classExecutionUnit_a4dc637449366fcdfc4e764cdf12d9b11}{ExecutionUnit}, \hyperlink{classInstBuffer_a4dc637449366fcdfc4e764cdf12d9b11}{InstBuffer}, \hyperlink{classMultDivUnit_a4dc637449366fcdfc4e764cdf12d9b11}{MultDivUnit}, \hyperlink{classUseDefUnit_a4dc637449366fcdfc4e764cdf12d9b11}{UseDefUnit}, と \hyperlink{classMemDepUnit_a4dc637449366fcdfc4e764cdf12d9b11}{MemDepUnit$<$ MemDepPred, Impl $>$}で再定義されています。


\begin{DoxyCode}
83 { }
\end{DoxyCode}
\hypertarget{classResource_a00d6f4600ca80ac12352a9c0d3922857}{
\index{Resource@{Resource}!rejectRequest@{rejectRequest}}
\index{rejectRequest@{rejectRequest}!Resource@{Resource}}
\subsubsection[{rejectRequest}]{\setlength{\rightskip}{0pt plus 5cm}void rejectRequest ({\bf DynInstPtr} {\em inst})}}
\label{classResource_a00d6f4600ca80ac12352a9c0d3922857}



\begin{DoxyCode}
267 {
268     DPRINTF(RefCount, "[tid:%i]: Unable to grant request for [sn:%i].\n",
269             inst->readTid(), inst->seqNum);
270 }
\end{DoxyCode}
\hypertarget{classResource_acd38b2c94092af431807b57f7b7cef6c}{
\index{Resource@{Resource}!request@{request}}
\index{request@{request}!Resource@{Resource}}
\subsubsection[{request}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ResReqPtr} request ({\bf DynInstPtr} {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classResource_acd38b2c94092af431807b57f7b7cef6c}
\hyperlink{classRequest}{Request} usage of this resource. Returns a \hyperlink{classResourceRequest}{ResourceRequest} object with all the necessary resource information 


\begin{DoxyCode}
168 {
169     // See if the resource is already serving this instruction.
170     // If so, use that request;
171     bool try_request = false;
172     int slot_num = -1;
173     int stage_num;
174     ResReqPtr inst_req = findRequest(inst);
175 
176     if (inst_req) {
177         // If some preprocessing has to be done on instruction
178         // that has already requested once, then handle it here.
179         // update the 'try_request' variable if we should
180         // re-execute the request.
181         requestAgain(inst, try_request);
182 
183         slot_num = inst_req->getSlot();
184         stage_num = inst_req->getStageNum();
185     } else {
186         // Get new slot # for instruction
187         slot_num = getSlot(inst);
188 
189         if (slot_num != -1) {
190             DPRINTF(Resource, "Allocating [slot:%i] for [tid:%i]: [sn:%i]\n",
191                     slot_num, inst->readTid(), inst->seqNum);
192 
193             // Get Stage # from Schedule Entry
194             stage_num = inst->curSkedEntry->stageNum;
195             unsigned cmd = inst->curSkedEntry->cmd;
196 
197             // Generate Resource Request
198             inst_req = getRequest(inst, stage_num, id, slot_num, cmd);
199 
200             if (inst->staticInst) {
201                 DPRINTF(Resource, "[tid:%i]: [sn:%i] requesting this "
202                         "resource.\n",
203                         inst->readTid(), inst->seqNum);
204             } else {
205                 DPRINTF(Resource, "[tid:%i]: instruction requesting this "
206                         "resource.\n",
207                         inst->readTid());
208             }
209 
210             try_request = true;
211         } else {
212             DPRINTF(Resource, "No slot available for [tid:%i]: [sn:%i]\n",
213                     inst->readTid(), inst->seqNum);
214         }
215 
216     }
217 
218     if (try_request) {
219         // Schedule execution of resource
220         scheduleExecution(slot_num);
221     } else {
222         inst_req = deniedReq;
223         rejectRequest(inst);
224     }
225 
226     return inst_req;
227 }
\end{DoxyCode}
\hypertarget{classResource_a9063fd6f97e36e3565247339ffa3882c}{
\index{Resource@{Resource}!requestAgain@{requestAgain}}
\index{requestAgain@{requestAgain}!Resource@{Resource}}
\subsubsection[{requestAgain}]{\setlength{\rightskip}{0pt plus 5cm}void requestAgain ({\bf DynInstPtr} {\em inst}, \/  bool \& {\em try\_\-request})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classResource_a9063fd6f97e36e3565247339ffa3882c}
\hyperlink{classRequest}{Request} a \hyperlink{classResource}{Resource} again. Some resources have to special process this in subsequent accesses. 

\hyperlink{classCacheUnit_a9063fd6f97e36e3565247339ffa3882c}{CacheUnit}, と \hyperlink{classMultDivUnit_a9063fd6f97e36e3565247339ffa3882c}{MultDivUnit}で再定義されています。


\begin{DoxyCode}
231 {
232     do_request = true;
233 
234     if (inst->staticInst) {
235         DPRINTF(Resource, "[tid:%i]: [sn:%i] requesting this resource "
236                 "again.\n",
237                 inst->readTid(), inst->seqNum);
238     } else {
239         DPRINTF(Resource, "[tid:%i]: requesting this resource again.\n",
240                 inst->readTid());
241     }
242 }
\end{DoxyCode}
\hypertarget{classResource_a9463594c1003adcd1e810ad6cea904eb}{
\index{Resource@{Resource}!scheduleEvent@{scheduleEvent}}
\index{scheduleEvent@{scheduleEvent}!Resource@{Resource}}
\subsubsection[{scheduleEvent}]{\setlength{\rightskip}{0pt plus 5cm}bool scheduleEvent ({\bf DynInstPtr} {\em inst}, \/  {\bf Cycles} {\em delay})}}
\label{classResource_a9463594c1003adcd1e810ad6cea904eb}
Find instruction in list, Schedule resource event, regardless of its current state. 


\begin{DoxyCode}
388 {
389     int slot_idx = findSlot(inst);
390 
391     if(slot_idx != -1)
392         resourceEvent[slot_idx].scheduleEvent(delay);
393 
394     return slot_idx;
395 }
\end{DoxyCode}
\hypertarget{classResource_a55e9744a3539be9ff746b13b1d6bafc3}{
\index{Resource@{Resource}!scheduleEvent@{scheduleEvent}}
\index{scheduleEvent@{scheduleEvent}!Resource@{Resource}}
\subsubsection[{scheduleEvent}]{\setlength{\rightskip}{0pt plus 5cm}void scheduleEvent (int {\em slot\_\-idx}, \/  {\bf Cycles} {\em delay})}}
\label{classResource_a55e9744a3539be9ff746b13b1d6bafc3}
Schedule resource event, regardless of its current state. 


\begin{DoxyCode}
378 {
379     DPRINTF(Resource, "[tid:%i]: Scheduling event for [sn:%i] on tick %i.\n",
380             reqs[slot_idx]->inst->readTid(),
381             reqs[slot_idx]->inst->seqNum,
382             cpu->clockEdge(delay));
383     resourceEvent[slot_idx].scheduleEvent(delay);
384 }
\end{DoxyCode}
\hypertarget{classResource_a9f90c5efcf202dda43bb780a645bee1f}{
\index{Resource@{Resource}!scheduleExecution@{scheduleExecution}}
\index{scheduleExecution@{scheduleExecution}!Resource@{Resource}}
\subsubsection[{scheduleExecution}]{\setlength{\rightskip}{0pt plus 5cm}void scheduleExecution (int {\em slot\_\-idx})}}
\label{classResource_a9f90c5efcf202dda43bb780a645bee1f}
Schedule Execution of This \hyperlink{classResource}{Resource} For A Given Slot 


\begin{DoxyCode}
368 {
369     if (latency > Cycles(0)) {
370         scheduleEvent(slot_num, latency);
371     } else {
372         execute(slot_num);
373     }
374 }
\end{DoxyCode}
\hypertarget{classResource_ab03920cf8ee0a1dd131d4a6db0320f71}{
\index{Resource@{Resource}!setupSquash@{setupSquash}}
\index{setupSquash@{setupSquash}!Resource@{Resource}}
\subsubsection[{setupSquash}]{\setlength{\rightskip}{0pt plus 5cm}void setupSquash ({\bf DynInstPtr} {\em inst}, \/  int {\em stage\_\-num}, \/  {\bf ThreadID} {\em tid})}}
\label{classResource_ab03920cf8ee0a1dd131d4a6db0320f71}
Setup Squash to be sent out to pipeline and resource pool 


\begin{DoxyCode}
293 {
294     // Squash In Pipeline Stage
295     cpu->pipelineStage[stage_num]->setupSquash(inst, tid);
296 
297     // Schedule Squash Through-out Resource Pool
298     cpu->resPool->scheduleEvent(
299         (InOrderCPU::CPUEventType)ResourcePool::SquashAll, inst,
300         Cycles(0));
301 }
\end{DoxyCode}
\hypertarget{classResource_aa376a7fab43ff33531fff37daaf97d30}{
\index{Resource@{Resource}!slotsAvail@{slotsAvail}}
\index{slotsAvail@{slotsAvail}!Resource@{Resource}}
\subsubsection[{slotsAvail}]{\setlength{\rightskip}{0pt plus 5cm}int slotsAvail ()}}
\label{classResource_aa376a7fab43ff33531fff37daaf97d30}
The number of instructions available that this resource can can still process 


\begin{DoxyCode}
111 {
112     return availSlots.size();
113 }
\end{DoxyCode}
\hypertarget{classResource_a7996fa2858e57c95ac52ee2813f816f7}{
\index{Resource@{Resource}!slotsInUse@{slotsInUse}}
\index{slotsInUse@{slotsInUse}!Resource@{Resource}}
\subsubsection[{slotsInUse}]{\setlength{\rightskip}{0pt plus 5cm}int slotsInUse ()}}
\label{classResource_a7996fa2858e57c95ac52ee2813f816f7}
The number of instructions using this resource 


\begin{DoxyCode}
117 {
118     return width - availSlots.size();
119 }
\end{DoxyCode}
\hypertarget{classResource_a52235c5e3d912452f254dc45f1496fd2}{
\index{Resource@{Resource}!squash@{squash}}
\index{squash@{squash}!Resource@{Resource}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash ({\bf DynInstPtr} {\em inst}, \/  int {\em stage\_\-num}, \/  {\bf InstSeqNum} {\em squash\_\-seq\_\-num}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classResource_a52235c5e3d912452f254dc45f1496fd2}
Squash All Requests After This Seq Num 

\hyperlink{classBranchPredictor_a52235c5e3d912452f254dc45f1496fd2}{BranchPredictor}, \hyperlink{classCacheUnit_a52235c5e3d912452f254dc45f1496fd2}{CacheUnit}, \hyperlink{classFetchSeqUnit_a48e371fe43e53aebbe5b2b2afc5aa8e3}{FetchSeqUnit}, \hyperlink{classInstBuffer_a52235c5e3d912452f254dc45f1496fd2}{InstBuffer}, \hyperlink{classMultDivUnit_a52235c5e3d912452f254dc45f1496fd2}{MultDivUnit}, と \hyperlink{classTLBUnit_a52235c5e3d912452f254dc45f1496fd2}{TLBUnit}で再定義されています。


\begin{DoxyCode}
306 {
307     //@todo: check squash seq num before squashing. can save time going
308     //       through this function.
309     for (int i = 0; i < width; i++) {
310         ResReqPtr req_ptr = reqs[i];
311         DynInstPtr inst = req_ptr->getInst();
312 
313         if (req_ptr->valid &&
314             inst->readTid() == tid &&
315             inst->seqNum > squash_seq_num) {
316 
317             DPRINTF(Resource, "[tid:%i]: Squashing [sn:%i].\n",
318                     req_ptr->getInst()->readTid(),
319                     req_ptr->getInst()->seqNum);
320 
321             req_ptr->setSquashed();
322 
323             int req_slot_num = req_ptr->getSlot();
324 
325             if (latency > Cycles(0)) {
326                 if (resourceEvent[req_slot_num].scheduled())
327                     unscheduleEvent(req_slot_num);
328             }
329 
330             freeSlot(req_slot_num);
331         }
332     }
333 }
\end{DoxyCode}
\hypertarget{classResource_ae2d6fba25ece343caad6eb029a4a3b5b}{
\index{Resource@{Resource}!squashDueToMemStall@{squashDueToMemStall}}
\index{squashDueToMemStall@{squashDueToMemStall}!Resource@{Resource}}
\subsubsection[{squashDueToMemStall}]{\setlength{\rightskip}{0pt plus 5cm}void squashDueToMemStall ({\bf DynInstPtr} {\em inst}, \/  int {\em stage\_\-num}, \/  {\bf InstSeqNum} {\em squash\_\-seq\_\-num}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classResource_ae2d6fba25ece343caad6eb029a4a3b5b}
Squash Requests Due to a Memory Stall (By Default, same as \char`\"{}squash\char`\"{} 

\hyperlink{classCacheUnit_ae2d6fba25ece343caad6eb029a4a3b5b}{CacheUnit}で再定義されています。


\begin{DoxyCode}
339 {
340     squash(inst, stage_num, squash_seq_num, tid);    
341 }
\end{DoxyCode}
\hypertarget{classResource_ac04c1a8a5c1212f9bbdc1ce83b1da882}{
\index{Resource@{Resource}!squashThenTrap@{squashThenTrap}}
\index{squashThenTrap@{squashThenTrap}!Resource@{Resource}}
\subsubsection[{squashThenTrap}]{\setlength{\rightskip}{0pt plus 5cm}void squashThenTrap (int {\em stage\_\-num}, \/  {\bf DynInstPtr} {\em inst})}}
\label{classResource_ac04c1a8a5c1212f9bbdc1ce83b1da882}
Handle Squash \& Trap that occured from an instruction in a resource 


\begin{DoxyCode}
345 {
346     ThreadID tid = inst->readTid();
347 
348     inst->setSquashInfo(stage_num);
349     setupSquash(inst, stage_num, tid);
350 
351     if (inst->traceData) {
352         if (inst->staticInst &&
353             inst->fault != NoFault && DTRACE(ExecFaulting)) {
354             inst->traceData->setStageCycle(stage_num, curTick());
355             inst->traceData->setFetchSeq(inst->seqNum);
356             inst->traceData->dump();
357         }
358 
359         delete inst->traceData;
360         inst->traceData = NULL;
361     }
362 
363     cpu->trapContext(inst->fault, tid, inst);
364 }
\end{DoxyCode}
\hypertarget{classResource_ad2f3fddbc6dd67ef5e3a84cd7a9814e6}{
\index{Resource@{Resource}!suspendThread@{suspendThread}}
\index{suspendThread@{suspendThread}!Resource@{Resource}}
\subsubsection[{suspendThread}]{\setlength{\rightskip}{0pt plus 5cm}virtual void suspendThread ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classResource_ad2f3fddbc6dd67ef5e3a84cd7a9814e6}
Resources that care about thread activation override this. 

\hyperlink{classFetchSeqUnit_aee7a498a20266fbfbc6aa3f165577b68}{FetchSeqUnit}で再定義されています。


\begin{DoxyCode}
94 { }
\end{DoxyCode}
\hypertarget{classResource_a1eb2a0229740a87bde0282416035b864}{
\index{Resource@{Resource}!trap@{trap}}
\index{trap@{trap}!Resource@{Resource}}
\subsubsection[{trap}]{\setlength{\rightskip}{0pt plus 5cm}virtual void trap ({\bf Fault} {\em fault}, \/  {\bf ThreadID} {\em tid}, \/  {\bf DynInstPtr} {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classResource_a1eb2a0229740a87bde0282416035b864}
Post-\/processsing for Trap Generated from this instruction 

\hyperlink{classCacheUnit_abf76d6d245f7d3b17d26ea8dcc0cf36f}{CacheUnit}, \hyperlink{classFetchSeqUnit_abf76d6d245f7d3b17d26ea8dcc0cf36f}{FetchSeqUnit}, と \hyperlink{classFetchUnit_abf76d6d245f7d3b17d26ea8dcc0cf36f}{FetchUnit}で再定義されています。


\begin{DoxyCode}
107 { }
\end{DoxyCode}
\hypertarget{classResource_a2ca5964896e91fdb616377369e29cfc4}{
\index{Resource@{Resource}!unscheduleEvent@{unscheduleEvent}}
\index{unscheduleEvent@{unscheduleEvent}!Resource@{Resource}}
\subsubsection[{unscheduleEvent}]{\setlength{\rightskip}{0pt plus 5cm}bool unscheduleEvent ({\bf DynInstPtr} {\em inst})}}
\label{classResource_a2ca5964896e91fdb616377369e29cfc4}
Unschedule resource event, regardless of its current state. 


\begin{DoxyCode}
405 {
406     int slot_idx = findSlot(inst);
407 
408     if(slot_idx != -1)
409         resourceEvent[slot_idx].unscheduleEvent();
410 
411     return slot_idx;
412 }
\end{DoxyCode}
\hypertarget{classResource_a30247366c4c8cb82c2a196a286d309ad}{
\index{Resource@{Resource}!unscheduleEvent@{unscheduleEvent}}
\index{unscheduleEvent@{unscheduleEvent}!Resource@{Resource}}
\subsubsection[{unscheduleEvent}]{\setlength{\rightskip}{0pt plus 5cm}void unscheduleEvent (int {\em slot\_\-idx})}}
\label{classResource_a30247366c4c8cb82c2a196a286d309ad}
Unschedule resource event, regardless of its current state. 


\begin{DoxyCode}
399 {
400     resourceEvent[slot_idx].unscheduleEvent();
401 }
\end{DoxyCode}
\hypertarget{classResource_a2cf5450ce736e0c76aca0d4ef24b922a}{
\index{Resource@{Resource}!updateAfterContextSwitch@{updateAfterContextSwitch}}
\index{updateAfterContextSwitch@{updateAfterContextSwitch}!Resource@{Resource}}
\subsubsection[{updateAfterContextSwitch}]{\setlength{\rightskip}{0pt plus 5cm}virtual void updateAfterContextSwitch ({\bf DynInstPtr} {\em inst}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classResource_a2cf5450ce736e0c76aca0d4ef24b922a}
Will be called the cycle before a context switch. Any bookkeeping that needs to be kept for that, can be done here 

\hyperlink{classFetchSeqUnit_a339073618ad3c21c492d64a55ce2e216}{FetchSeqUnit}, と \hyperlink{classUseDefUnit_a339073618ad3c21c492d64a55ce2e216}{UseDefUnit}で再定義されています。


\begin{DoxyCode}
99 { }    
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classResource_a80da161b04f097f36d40b2bb699192b6}{
\index{Resource@{Resource}!ResourceEvent@{ResourceEvent}}
\index{ResourceEvent@{ResourceEvent}!Resource@{Resource}}
\subsubsection[{ResourceEvent}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf ResourceEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classResource_a80da161b04f097f36d40b2bb699192b6}
\hypertarget{classResource_ae78e4599e7afd86b067119e90ac5dfed}{
\index{Resource@{Resource}!ResourceRequest@{ResourceRequest}}
\index{ResourceRequest@{ResourceRequest}!Resource@{Resource}}
\subsubsection[{ResourceRequest}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf ResourceRequest}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classResource_ae78e4599e7afd86b067119e90ac5dfed}


\subsection{変数}
\hypertarget{classResource_a1dd2ecf45bf9024f273d09813d993f97}{
\index{Resource@{Resource}!availSlots@{availSlots}}
\index{availSlots@{availSlots}!Resource@{Resource}}
\subsubsection[{availSlots}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<$int$>$ {\bf availSlots}}}
\label{classResource_a1dd2ecf45bf9024f273d09813d993f97}
A list of all the available execution slots for this resource. This correlates with the actual resource event idx. \hypertarget{classResource_a41d682c28d0f49e04393c52815808782}{
\index{Resource@{Resource}!cpu@{cpu}}
\index{cpu@{cpu}!Resource@{Resource}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InOrderCPU}$\ast$ {\bf cpu}}}
\label{classResource_a41d682c28d0f49e04393c52815808782}
The CPU(s) that this resource interacts with \hypertarget{classResource_a52489b62c55d7db3b70c3713b3000601}{
\index{Resource@{Resource}!deniedReq@{deniedReq}}
\index{deniedReq@{deniedReq}!Resource@{Resource}}
\subsubsection[{deniedReq}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ResReqPtr} {\bf deniedReq}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classResource_a52489b62c55d7db3b70c3713b3000601}
Default denied resource request pointer \hypertarget{classResource_a7441ef0865bcb3db9b8064dd7375c1ea}{
\index{Resource@{Resource}!id@{id}}
\index{id@{id}!Resource@{Resource}}
\subsubsection[{id}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf id}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classResource_a7441ef0865bcb3db9b8064dd7375c1ea}
ID of the resource. The \hyperlink{classResource}{Resource} Pool uses this \# to identify this resource. 

\hyperlink{classMemDepUnit_a7441ef0865bcb3db9b8064dd7375c1ea}{MemDepUnit$<$ MemDepPred, Impl $>$}で再定義されています。\hypertarget{classResource_a46b9d67ee437c6ecdbedca8ec8d2ed40}{
\index{Resource@{Resource}!latency@{latency}}
\index{latency@{latency}!Resource@{Resource}}
\subsubsection[{latency}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Cycles} {\bf latency}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classResource_a46b9d67ee437c6ecdbedca8ec8d2ed40}
Constant latency for this resource. Note: Dynamic latency resources set this to 0 and manage the latency themselves \hypertarget{classResource_a83b4e5928b54d2813c3c4911043e677d}{
\index{Resource@{Resource}!reqs@{reqs}}
\index{reqs@{reqs}!Resource@{Resource}}
\subsubsection[{reqs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf ResReqPtr}$>$ {\bf reqs}}}
\label{classResource_a83b4e5928b54d2813c3c4911043e677d}
List of all Requests the \hyperlink{classResource}{Resource} is Servicing. Each request represents part of the resource's bandwidth \hypertarget{classResource_a991d4c92f58169fd45fe3f1c1881ac9e}{
\index{Resource@{Resource}!resName@{resName}}
\index{resName@{resName}!Resource@{Resource}}
\subsubsection[{resName}]{\setlength{\rightskip}{0pt plus 5cm}std::string {\bf resName}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classResource_a991d4c92f58169fd45fe3f1c1881ac9e}
The name of this resource \hypertarget{classResource_abde7a6c4ff046aa4c2ecd476c4266be3}{
\index{Resource@{Resource}!resourceEvent@{resourceEvent}}
\index{resourceEvent@{resourceEvent}!Resource@{Resource}}
\subsubsection[{resourceEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ResourceEvent}$\ast$ {\bf resourceEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classResource_abde7a6c4ff046aa4c2ecd476c4266be3}
The resource event used for scheduling resource slots on the event queue \hypertarget{classResource_a2474a5474cbff19523a51eb1de01cda4}{
\index{Resource@{Resource}!width@{width}}
\index{width@{width}!Resource@{Resource}}
\subsubsection[{width}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf width}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classResource_a2474a5474cbff19523a51eb1de01cda4}
The number of instructions the resource can simultaneously process. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/inorder/\hyperlink{resource_8hh}{resource.hh}\item 
cpu/inorder/\hyperlink{resource_8cc}{resource.cc}\end{DoxyCompactItemize}
