\hypertarget{classTsunamiCChip}{
\section{クラス TsunamiCChip}
\label{classTsunamiCChip}\index{TsunamiCChip@{TsunamiCChip}}
}


{\ttfamily \#include $<$tsunami\_\-cchip.hh$>$}TsunamiCChipに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=7cm]{classTsunamiCChip}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef TsunamiCChipParams \hyperlink{classTsunamiCChip_ae88d115af4688355c68945ae8486b7ec}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classTsunamiCChip_ab55992bfee06f9d23385fad4a1f6f197}{TsunamiCChip} (const \hyperlink{classTsunamiCChip_ae88d115af4688355c68945ae8486b7ec}{Params} $\ast$p)
\item 
const \hyperlink{classTsunamiCChip_ae88d115af4688355c68945ae8486b7ec}{Params} $\ast$ \hyperlink{classTsunamiCChip_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classTsunamiCChip_a613ec7d5e1ec64f8d21fec78ae8e568e}{read} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classTsunamiCChip_a4cefab464e72b5dd42c003a0a4341802}{write} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classTsunamiCChip_acdd7f639bc4c5a8d164d48a96734d6c1}{postRTC} ()
\item 
void \hyperlink{classTsunamiCChip_a2a04c83ef42523f729c8c5ad75ffa3ea}{postDRIR} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} interrupt)
\item 
void \hyperlink{classTsunamiCChip_a75bd270f0ce8d71afe064fa3b4128c26}{clearDRIR} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} interrupt)
\item 
void \hyperlink{classTsunamiCChip_ad463cf06091847c5eef7aba24419eee0}{clearIPI} (uint64\_\-t ipintr)
\item 
void \hyperlink{classTsunamiCChip_a1bc328d0acc40e7f79412b5b3c9b9395}{clearITI} (uint64\_\-t itintr)
\item 
void \hyperlink{classTsunamiCChip_a1f4571959aa97b26452f6accc79abffe}{reqIPI} (uint64\_\-t ipreq)
\item 
virtual void \hyperlink{classTsunamiCChip_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classTsunamiCChip_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classTsunami}{Tsunami} $\ast$ \hyperlink{classTsunamiCChip_aa178467f241f875a068722413f62ec20}{tsunami}
\item 
uint64\_\-t \hyperlink{classTsunamiCChip_ad791aec1b6c30bc2e0d2a6e2016ea3ba}{dim} \mbox{[}\hyperlink{classTsunami_ab15ce4af0fe2c47746a30bafa34ced51}{Tsunami::Max\_\-CPUs}\mbox{]}
\item 
uint64\_\-t \hyperlink{classTsunamiCChip_a41f0c570ffaf676a652c72cca47f743a}{dir} \mbox{[}\hyperlink{classTsunami_ab15ce4af0fe2c47746a30bafa34ced51}{Tsunami::Max\_\-CPUs}\mbox{]}
\item 
uint64\_\-t \hyperlink{classTsunamiCChip_aa506ee56b76eeb7c0ffa0112c07799e7}{drir}
\item 
uint64\_\-t \hyperlink{classTsunamiCChip_aa814845b1fc114b393e125f86d7dc57e}{ipint}
\item 
uint64\_\-t \hyperlink{classTsunamiCChip_ad115b62dbebcd51ee67d3110a1b143c6}{itint}
\end{DoxyCompactItemize}


\subsection{説明}
\hyperlink{classTsunami}{Tsunami} CChip CSR Emulation. This device includes all the interrupt handling code for the chipset. 

\subsection{型定義}
\hypertarget{classTsunamiCChip_ae88d115af4688355c68945ae8486b7ec}{
\index{TsunamiCChip@{TsunamiCChip}!Params@{Params}}
\index{Params@{Params}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef TsunamiCChipParams {\bf Params}}}
\label{classTsunamiCChip_ae88d115af4688355c68945ae8486b7ec}


\hyperlink{classBasicPioDevice_a2845515ac6467f10540747053c8a0449}{BasicPioDevice}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classTsunamiCChip_ab55992bfee06f9d23385fad4a1f6f197}{
\index{TsunamiCChip@{TsunamiCChip}!TsunamiCChip@{TsunamiCChip}}
\index{TsunamiCChip@{TsunamiCChip}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{TsunamiCChip}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TsunamiCChip} (const {\bf Params} $\ast$ {\em p})}}
\label{classTsunamiCChip_ab55992bfee06f9d23385fad4a1f6f197}
Initialize the \hyperlink{classTsunami}{Tsunami} CChip by setting all of the device register to 0. 
\begin{DoxyParams}{引数}
\item[{\em p}]params struct \end{DoxyParams}



\begin{DoxyCode}
60     : BasicPioDevice(p, 0x10000000), tsunami(p->tsunami)
61 {
62     drir = 0;
63     ipint = 0;
64     itint = 0;
65 
66     for (int x = 0; x < Tsunami::Max_CPUs; x++)
67     {
68         dim[x] = 0;
69         dir[x] = 0;
70     }
71 
72     //Put back pointer in tsunami
73     tsunami->cchip = this;
74 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classTsunamiCChip_a75bd270f0ce8d71afe064fa3b4128c26}{
\index{TsunamiCChip@{TsunamiCChip}!clearDRIR@{clearDRIR}}
\index{clearDRIR@{clearDRIR}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{clearDRIR}]{\setlength{\rightskip}{0pt plus 5cm}void clearDRIR ({\bf uint32\_\-t} {\em interrupt})}}
\label{classTsunamiCChip_a75bd270f0ce8d71afe064fa3b4128c26}
clear an interrupt previously posted to the CPU. 
\begin{DoxyParams}{引数}
\item[{\em interrupt}]the interrupt number to post (0-\/64) \end{DoxyParams}



\begin{DoxyCode}
487 {
488     uint64_t bitvector = ULL(1) << interrupt;
489     uint64_t size = sys->threadContexts.size();
490     assert(size <= Tsunami::Max_CPUs);
491 
492     if (drir & bitvector)
493     {
494         drir &= ~bitvector;
495         for(int i=0; i < size; i++) {
496            if (dir[i] & bitvector) {
497                tsunami->intrctrl->clear(i, TheISA::INTLEVEL_IRQ1, interrupt);
498                DPRINTF(Tsunami, "clearing dir interrupt to cpu %d,"
499                     "interrupt %d\n",i, interrupt);
500 
501            }
502            dir[i] = dim[i] & drir;
503         }
504     }
505     else
506         DPRINTF(Tsunami, "Spurrious clear? interrupt %d\n", interrupt);
507 }
\end{DoxyCode}
\hypertarget{classTsunamiCChip_ad463cf06091847c5eef7aba24419eee0}{
\index{TsunamiCChip@{TsunamiCChip}!clearIPI@{clearIPI}}
\index{clearIPI@{clearIPI}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{clearIPI}]{\setlength{\rightskip}{0pt plus 5cm}void clearIPI (uint64\_\-t {\em ipintr})}}
\label{classTsunamiCChip_ad463cf06091847c5eef7aba24419eee0}
post an ipi interrupt to the CPU. 
\begin{DoxyParams}{引数}
\item[{\em ipintr}]the cpu number to clear(bitvector) \end{DoxyParams}



\begin{DoxyCode}
379 {
380     int numcpus = sys->threadContexts.size();
381     assert(numcpus <= Tsunami::Max_CPUs);
382 
383     if (ipintr) {
384         for (int cpunum=0; cpunum < numcpus; cpunum++) {
385             // Check each cpu bit
386             uint64_t cpumask = ULL(1) << cpunum;
387             if (ipintr & cpumask) {
388                 // Check if there is a pending ipi
389                 if (ipint & cpumask) {
390                     ipint &= ~cpumask;
391                     tsunami->intrctrl->clear(cpunum, TheISA::INTLEVEL_IRQ3, 0);
392                     DPRINTF(IPI, "clear IPI IPI cpu=%d\n", cpunum);
393                 }
394                 else
395                     warn("clear IPI for CPU=%d, but NO IPI\n", cpunum);
396             }
397         }
398     }
399     else
400         panic("Big IPI Clear, but not processors indicated\n");
401 }
\end{DoxyCode}
\hypertarget{classTsunamiCChip_a1bc328d0acc40e7f79412b5b3c9b9395}{
\index{TsunamiCChip@{TsunamiCChip}!clearITI@{clearITI}}
\index{clearITI@{clearITI}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{clearITI}]{\setlength{\rightskip}{0pt plus 5cm}void clearITI (uint64\_\-t {\em itintr})}}
\label{classTsunamiCChip_a1bc328d0acc40e7f79412b5b3c9b9395}
clear a timer interrupt previously posted to the CPU. 
\begin{DoxyParams}{引数}
\item[{\em itintr}]the cpu number to clear(bitvector) \end{DoxyParams}



\begin{DoxyCode}
405 {
406     int numcpus = sys->threadContexts.size();
407     assert(numcpus <= Tsunami::Max_CPUs);
408 
409     if (itintr) {
410         for (int i=0; i < numcpus; i++) {
411             uint64_t cpumask = ULL(1) << i;
412             if (itintr & cpumask & itint) {
413                 tsunami->intrctrl->clear(i, TheISA::INTLEVEL_IRQ2, 0);
414                 itint &= ~cpumask;
415                 DPRINTF(Tsunami, "clearing rtc interrupt to cpu=%d\n", i);
416             }
417         }
418     }
419     else
420         panic("Big ITI Clear, but not processors indicated\n");
421 }
\end{DoxyCode}
\hypertarget{classTsunamiCChip_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{TsunamiCChip@{TsunamiCChip}!params@{params}}
\index{params@{params}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classTsunamiCChip_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classBasicPioDevice_acd3c3feb78ae7a8f88fe0f110a718dff}{BasicPioDevice}を再定義しています。


\begin{DoxyCode}
91     {
92         return dynamic_cast<const Params *>(_params);
93     }
\end{DoxyCode}
\hypertarget{classTsunamiCChip_a2a04c83ef42523f729c8c5ad75ffa3ea}{
\index{TsunamiCChip@{TsunamiCChip}!postDRIR@{postDRIR}}
\index{postDRIR@{postDRIR}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{postDRIR}]{\setlength{\rightskip}{0pt plus 5cm}void postDRIR ({\bf uint32\_\-t} {\em interrupt})}}
\label{classTsunamiCChip_a2a04c83ef42523f729c8c5ad75ffa3ea}
post an interrupt to the CPU. 
\begin{DoxyParams}{引数}
\item[{\em interrupt}]the interrupt number to post (0-\/64) \end{DoxyParams}



\begin{DoxyCode}
469 {
470     uint64_t bitvector = ULL(1) << interrupt;
471     uint64_t size = sys->threadContexts.size();
472     assert(size <= Tsunami::Max_CPUs);
473     drir |= bitvector;
474 
475     for(int i=0; i < size; i++) {
476         dir[i] = dim[i] & drir;
477        if (dim[i] & bitvector) {
478               tsunami->intrctrl->post(i, TheISA::INTLEVEL_IRQ1, interrupt);
479               DPRINTF(Tsunami, "posting dir interrupt to cpu %d,"
480                         "interrupt %d\n",i, interrupt);
481        }
482     }
483 }
\end{DoxyCode}
\hypertarget{classTsunamiCChip_acdd7f639bc4c5a8d164d48a96734d6c1}{
\index{TsunamiCChip@{TsunamiCChip}!postRTC@{postRTC}}
\index{postRTC@{postRTC}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{postRTC}]{\setlength{\rightskip}{0pt plus 5cm}void postRTC ()}}
\label{classTsunamiCChip_acdd7f639bc4c5a8d164d48a96734d6c1}
post an RTC interrupt to the CPU 


\begin{DoxyCode}
452 {
453     int size = sys->threadContexts.size();
454     assert(size <= Tsunami::Max_CPUs);
455 
456     for (int i = 0; i < size; i++) {
457         uint64_t cpumask = ULL(1) << i;
458        if (!(cpumask & itint)) {
459            itint |= cpumask;
460            tsunami->intrctrl->post(i, TheISA::INTLEVEL_IRQ2, 0);
461            DPRINTF(Tsunami, "Posting RTC interrupt to cpu=%d\n", i);
462        }
463     }
464 
465 }
\end{DoxyCode}
\hypertarget{classTsunamiCChip_a613ec7d5e1ec64f8d21fec78ae8e568e}{
\index{TsunamiCChip@{TsunamiCChip}!read@{read}}
\index{read@{read}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} read ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTsunamiCChip_a613ec7d5e1ec64f8d21fec78ae8e568e}
Pure virtual function that the device must implement. Called when a read command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_a842312590432036092c422c87a442358}{PioDevice}を実装しています。


\begin{DoxyCode}
78 {
79     DPRINTF(Tsunami, "read  va=%#x size=%d\n", pkt->getAddr(), pkt->getSize());
80 
81     assert(pkt->getAddr() >= pioAddr && pkt->getAddr() < pioAddr + pioSize);
82 
83     Addr regnum = (pkt->getAddr() - pioAddr) >> 6;
84     Addr daddr = (pkt->getAddr() - pioAddr);
85 
86     pkt->allocate();
87     switch (pkt->getSize()) {
88 
89       case sizeof(uint64_t):
90           pkt->set<uint64_t>(0);
91 
92           if (daddr & TSDEV_CC_BDIMS)
93           {
94               pkt->set(dim[(daddr >> 4) & 0x3F]);
95               break;
96           }
97 
98           if (daddr & TSDEV_CC_BDIRS)
99           {
100               pkt->set(dir[(daddr >> 4) & 0x3F]);
101               break;
102           }
103 
104           switch(regnum) {
105               case TSDEV_CC_CSR:
106                   pkt->set(0x0);
107                   break;
108               case TSDEV_CC_MTR:
109                   panic("TSDEV_CC_MTR not implemeted\n");
110                    break;
111               case TSDEV_CC_MISC:
112                   pkt->set(((ipint << 8) & 0xF) | ((itint << 4) & 0xF) |
113                                      (pkt->req->contextId() & 0x3));
114                   // currently, FS cannot handle MT so contextId and
115                   // cpuId are effectively the same, don't know if it will
116                   // matter if FS becomes MT enabled.  I suspect no because
117                   // we are currently able to boot up to 64 procs anyway
118                   // which would render the CPUID of this register useless
119                   // anyway
120                   break;
121               case TSDEV_CC_AAR0:
122               case TSDEV_CC_AAR1:
123               case TSDEV_CC_AAR2:
124               case TSDEV_CC_AAR3:
125                   pkt->set(0);
126                   break;
127               case TSDEV_CC_DIM0:
128                   pkt->set(dim[0]);
129                   break;
130               case TSDEV_CC_DIM1:
131                   pkt->set(dim[1]);
132                   break;
133               case TSDEV_CC_DIM2:
134                   pkt->set(dim[2]);
135                   break;
136               case TSDEV_CC_DIM3:
137                   pkt->set(dim[3]);
138                   break;
139               case TSDEV_CC_DIR0:
140                   pkt->set(dir[0]);
141                   break;
142               case TSDEV_CC_DIR1:
143                   pkt->set(dir[1]);
144                   break;
145               case TSDEV_CC_DIR2:
146                   pkt->set(dir[2]);
147                   break;
148               case TSDEV_CC_DIR3:
149                   pkt->set(dir[3]);
150                   break;
151               case TSDEV_CC_DRIR:
152                   pkt->set(drir);
153                   break;
154               case TSDEV_CC_PRBEN:
155                   panic("TSDEV_CC_PRBEN not implemented\n");
156                   break;
157               case TSDEV_CC_IIC0:
158               case TSDEV_CC_IIC1:
159               case TSDEV_CC_IIC2:
160               case TSDEV_CC_IIC3:
161                   panic("TSDEV_CC_IICx not implemented\n");
162                   break;
163               case TSDEV_CC_MPR0:
164               case TSDEV_CC_MPR1:
165               case TSDEV_CC_MPR2:
166               case TSDEV_CC_MPR3:
167                   panic("TSDEV_CC_MPRx not implemented\n");
168                   break;
169               case TSDEV_CC_IPIR:
170                   pkt->set(ipint);
171                   break;
172               case TSDEV_CC_ITIR:
173                   pkt->set(itint);
174                   break;
175               default:
176                   panic("default in cchip read reached, accessing 0x%x\n");
177            } // uint64_t
178 
179       break;
180       case sizeof(uint32_t):
181       case sizeof(uint16_t):
182       case sizeof(uint8_t):
183       default:
184         panic("invalid access size(?) for tsunami register!\n");
185     }
186     DPRINTF(Tsunami, "Tsunami CChip: read  regnum=%#x size=%d data=%lld\n",
187             regnum, pkt->getSize(), pkt->get<uint64_t>());
188 
189     pkt->makeAtomicResponse();
190     return pioDelay;
191 }
\end{DoxyCode}
\hypertarget{classTsunamiCChip_a1f4571959aa97b26452f6accc79abffe}{
\index{TsunamiCChip@{TsunamiCChip}!reqIPI@{reqIPI}}
\index{reqIPI@{reqIPI}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{reqIPI}]{\setlength{\rightskip}{0pt plus 5cm}void reqIPI (uint64\_\-t {\em ipreq})}}
\label{classTsunamiCChip_a1f4571959aa97b26452f6accc79abffe}
request an interrupt be posted to the CPU. 
\begin{DoxyParams}{引数}
\item[{\em ipreq}]the cpu number to interrupt(bitvector) \end{DoxyParams}



\begin{DoxyCode}
425 {
426     int numcpus = sys->threadContexts.size();
427     assert(numcpus <= Tsunami::Max_CPUs);
428 
429     if (ipreq) {
430         for (int cpunum=0; cpunum < numcpus; cpunum++) {
431             // Check each cpu bit
432             uint64_t cpumask = ULL(1) << cpunum;
433             if (ipreq & cpumask) {
434                 // Check if there is already an ipi (bits 8:11)
435                 if (!(ipint & cpumask)) {
436                     ipint  |= cpumask;
437                     tsunami->intrctrl->post(cpunum, TheISA::INTLEVEL_IRQ3, 0);
438                     DPRINTF(IPI, "send IPI cpu=%d\n", cpunum);
439                 }
440                 else
441                     warn("post IPI for CPU=%d, but IPI already\n", cpunum);
442             }
443         }
444     }
445     else
446         panic("Big IPI Request, but not processors indicated\n");
447 }
\end{DoxyCode}
\hypertarget{classTsunamiCChip_a53e036786d17361be4c7320d39c99b84}{
\index{TsunamiCChip@{TsunamiCChip}!serialize@{serialize}}
\index{serialize@{serialize}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTsunamiCChip_a53e036786d17361be4c7320d39c99b84}
Serialize this object to the given output stream. 
\begin{DoxyParams}{引数}
\item[{\em os}]The stream to serialize to. \end{DoxyParams}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。


\begin{DoxyCode}
512 {
513     SERIALIZE_ARRAY(dim, Tsunami::Max_CPUs);
514     SERIALIZE_ARRAY(dir, Tsunami::Max_CPUs);
515     SERIALIZE_SCALAR(ipint);
516     SERIALIZE_SCALAR(itint);
517     SERIALIZE_SCALAR(drir);
518 }
\end{DoxyCode}
\hypertarget{classTsunamiCChip_af22e5d6d660b97db37003ac61ac4ee49}{
\index{TsunamiCChip@{TsunamiCChip}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTsunamiCChip_af22e5d6d660b97db37003ac61ac4ee49}
Reconstruct the state of this object from a checkpoint. 
\begin{DoxyParams}{引数}
\item[{\em \hyperlink{namespacecp}{cp}}]The checkpoint use. \item[{\em section}]The section name of this object \end{DoxyParams}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。


\begin{DoxyCode}
522 {
523     UNSERIALIZE_ARRAY(dim, Tsunami::Max_CPUs);
524     UNSERIALIZE_ARRAY(dir, Tsunami::Max_CPUs);
525     UNSERIALIZE_SCALAR(ipint);
526     UNSERIALIZE_SCALAR(itint);
527     UNSERIALIZE_SCALAR(drir);
528 }
\end{DoxyCode}
\hypertarget{classTsunamiCChip_a4cefab464e72b5dd42c003a0a4341802}{
\index{TsunamiCChip@{TsunamiCChip}!write@{write}}
\index{write@{write}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} write ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTsunamiCChip_a4cefab464e72b5dd42c003a0a4341802}
Pure virtual function that the device must implement. Called when a write command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_afe8371668d023bb2516b286e5e399b6f}{PioDevice}を実装しています。


\begin{DoxyCode}
195 {
196     assert(pkt->getAddr() >= pioAddr && pkt->getAddr() < pioAddr + pioSize);
197     Addr daddr = pkt->getAddr() - pioAddr;
198     Addr regnum = (pkt->getAddr() - pioAddr) >> 6 ;
199 
200 
201     assert(pkt->getSize() == sizeof(uint64_t));
202 
203     DPRINTF(Tsunami, "write - addr=%#x value=%#x\n", pkt->getAddr(), pkt->get<uin
      t64_t>());
204 
205     bool supportedWrite = false;
206 
207 
208     if (daddr & TSDEV_CC_BDIMS)
209     {
210         int number = (daddr >> 4) & 0x3F;
211 
212         uint64_t bitvector;
213         uint64_t olddim;
214         uint64_t olddir;
215 
216         olddim = dim[number];
217         olddir = dir[number];
218         dim[number] = pkt->get<uint64_t>();
219         dir[number] = dim[number] & drir;
220         for(int x = 0; x < Tsunami::Max_CPUs; x++)
221         {
222             bitvector = ULL(1) << x;
223             // Figure out which bits have changed
224             if ((dim[number] & bitvector) != (olddim & bitvector))
225             {
226                 // The bit is now set and it wasn't before (set)
227                 if((dim[number] & bitvector) && (dir[number] & bitvector))
228                 {
229                     tsunami->intrctrl->post(number, TheISA::INTLEVEL_IRQ1, x);
230                     DPRINTF(Tsunami, "dim write resulting in posting dir"
231                             " interrupt to cpu %d\n", number);
232                 }
233                 else if ((olddir & bitvector) &&
234                         !(dir[number] & bitvector))
235                 {
236                     // The bit was set and now its now clear and
237                     // we were interrupting on that bit before
238                     tsunami->intrctrl->clear(number, TheISA::INTLEVEL_IRQ1, x);
239                     DPRINTF(Tsunami, "dim write resulting in clear"
240                             " dir interrupt to cpu %d\n", number);
241 
242                 }
243 
244 
245             }
246         }
247     } else {
248         switch(regnum) {
249           case TSDEV_CC_CSR:
250               panic("TSDEV_CC_CSR write\n");
251           case TSDEV_CC_MTR:
252               panic("TSDEV_CC_MTR write not implemented\n");
253           case TSDEV_CC_MISC:
254             uint64_t ipreq;
255             ipreq = (pkt->get<uint64_t>() >> 12) & 0xF;
256             //If it is bit 12-15, this is an IPI post
257             if (ipreq) {
258                 reqIPI(ipreq);
259                 supportedWrite = true;
260             }
261 
262             //If it is bit 8-11, this is an IPI clear
263             uint64_t ipintr;
264             ipintr = (pkt->get<uint64_t>() >> 8) & 0xF;
265             if (ipintr) {
266                 clearIPI(ipintr);
267                 supportedWrite = true;
268             }
269 
270             //If it is the 4-7th bit, clear the RTC interrupt
271             uint64_t itintr;
272               itintr = (pkt->get<uint64_t>() >> 4) & 0xF;
273             if (itintr) {
274                   clearITI(itintr);
275                 supportedWrite = true;
276             }
277 
278               // ignore NXMs
279               if (pkt->get<uint64_t>() & 0x10000000)
280                   supportedWrite = true;
281 
282             if(!supportedWrite)
283                   panic("TSDEV_CC_MISC write not implemented\n");
284 
285             break;
286             case TSDEV_CC_AAR0:
287             case TSDEV_CC_AAR1:
288             case TSDEV_CC_AAR2:
289             case TSDEV_CC_AAR3:
290                 panic("TSDEV_CC_AARx write not implemeted\n");
291             case TSDEV_CC_DIM0:
292             case TSDEV_CC_DIM1:
293             case TSDEV_CC_DIM2:
294             case TSDEV_CC_DIM3:
295                 int number;
296                 if(regnum == TSDEV_CC_DIM0)
297                     number = 0;
298                 else if(regnum == TSDEV_CC_DIM1)
299                     number = 1;
300                 else if(regnum == TSDEV_CC_DIM2)
301                     number = 2;
302                 else
303                     number = 3;
304 
305                 uint64_t bitvector;
306                 uint64_t olddim;
307                 uint64_t olddir;
308 
309                 olddim = dim[number];
310                 olddir = dir[number];
311                 dim[number] = pkt->get<uint64_t>();
312                 dir[number] = dim[number] & drir;
313                 for(int x = 0; x < 64; x++)
314                 {
315                     bitvector = ULL(1) << x;
316                     // Figure out which bits have changed
317                     if ((dim[number] & bitvector) != (olddim & bitvector))
318                     {
319                         // The bit is now set and it wasn't before (set)
320                         if((dim[number] & bitvector) && (dir[number] & bitvector)
      )
321                         {
322                           tsunami->intrctrl->post(number, TheISA::INTLEVEL_IRQ1, 
      x);
323                           DPRINTF(Tsunami, "posting dir interrupt to cpu 0\n");
324                         }
325                         else if ((olddir & bitvector) &&
326                                 !(dir[number] & bitvector))
327                         {
328                             // The bit was set and now its now clear and
329                             // we were interrupting on that bit before
330                             tsunami->intrctrl->clear(number, 
      TheISA::INTLEVEL_IRQ1, x);
331                           DPRINTF(Tsunami, "dim write resulting in clear"
332                                     " dir interrupt to cpu %d\n",
333                                     x);
334 
335                         }
336 
337 
338                     }
339                 }
340                 break;
341             case TSDEV_CC_DIR0:
342             case TSDEV_CC_DIR1:
343             case TSDEV_CC_DIR2:
344             case TSDEV_CC_DIR3:
345                 panic("TSDEV_CC_DIR write not implemented\n");
346             case TSDEV_CC_DRIR:
347                 panic("TSDEV_CC_DRIR write not implemented\n");
348             case TSDEV_CC_PRBEN:
349                 panic("TSDEV_CC_PRBEN write not implemented\n");
350             case TSDEV_CC_IIC0:
351             case TSDEV_CC_IIC1:
352             case TSDEV_CC_IIC2:
353             case TSDEV_CC_IIC3:
354                 panic("TSDEV_CC_IICx write not implemented\n");
355             case TSDEV_CC_MPR0:
356             case TSDEV_CC_MPR1:
357             case TSDEV_CC_MPR2:
358             case TSDEV_CC_MPR3:
359                 panic("TSDEV_CC_MPRx write not implemented\n");
360             case TSDEV_CC_IPIR:
361                 clearIPI(pkt->get<uint64_t>());
362                 break;
363             case TSDEV_CC_ITIR:
364                 clearITI(pkt->get<uint64_t>());
365                 break;
366             case TSDEV_CC_IPIQ:
367                 reqIPI(pkt->get<uint64_t>());
368                 break;
369             default:
370               panic("default in cchip read reached, accessing 0x%x\n");
371         }  // swtich(regnum)
372     } // not BIG_TSUNAMI write
373     pkt->makeAtomicResponse();
374     return pioDelay;
375 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classTsunamiCChip_ad791aec1b6c30bc2e0d2a6e2016ea3ba}{
\index{TsunamiCChip@{TsunamiCChip}!dim@{dim}}
\index{dim@{dim}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{dim}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf dim}\mbox{[}{\bf Tsunami::Max\_\-CPUs}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiCChip_ad791aec1b6c30bc2e0d2a6e2016ea3ba}
The dims are device interrupt mask registers. One exists for each CPU, the DRIR X DIM = DIR \hypertarget{classTsunamiCChip_a41f0c570ffaf676a652c72cca47f743a}{
\index{TsunamiCChip@{TsunamiCChip}!dir@{dir}}
\index{dir@{dir}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{dir}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf dir}\mbox{[}{\bf Tsunami::Max\_\-CPUs}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiCChip_a41f0c570ffaf676a652c72cca47f743a}
The dirs are device interrupt registers. One exists for each CPU, the DRIR X DIM = DIR \hypertarget{classTsunamiCChip_aa506ee56b76eeb7c0ffa0112c07799e7}{
\index{TsunamiCChip@{TsunamiCChip}!drir@{drir}}
\index{drir@{drir}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{drir}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf drir}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiCChip_aa506ee56b76eeb7c0ffa0112c07799e7}
This register contains bits for each PCI interrupt that can occur. \hypertarget{classTsunamiCChip_aa814845b1fc114b393e125f86d7dc57e}{
\index{TsunamiCChip@{TsunamiCChip}!ipint@{ipint}}
\index{ipint@{ipint}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{ipint}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf ipint}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiCChip_aa814845b1fc114b393e125f86d7dc57e}
Indicator of which CPUs have an IPI interrupt \hypertarget{classTsunamiCChip_ad115b62dbebcd51ee67d3110a1b143c6}{
\index{TsunamiCChip@{TsunamiCChip}!itint@{itint}}
\index{itint@{itint}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{itint}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf itint}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiCChip_ad115b62dbebcd51ee67d3110a1b143c6}
Indicator of which CPUs have an RTC interrupt \hypertarget{classTsunamiCChip_aa178467f241f875a068722413f62ec20}{
\index{TsunamiCChip@{TsunamiCChip}!tsunami@{tsunami}}
\index{tsunami@{tsunami}!TsunamiCChip@{TsunamiCChip}}
\subsubsection[{tsunami}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tsunami}$\ast$ {\bf tsunami}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiCChip_aa178467f241f875a068722413f62ec20}
pointer to the tsunami object. This is our access to all the other tsunami devices. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/alpha/\hyperlink{tsunami__cchip_8hh}{tsunami\_\-cchip.hh}\item 
dev/alpha/\hyperlink{tsunami__cchip_8cc}{tsunami\_\-cchip.cc}\end{DoxyCompactItemize}
