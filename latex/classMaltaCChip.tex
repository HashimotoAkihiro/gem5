\hypertarget{classMaltaCChip}{
\section{クラス MaltaCChip}
\label{classMaltaCChip}\index{MaltaCChip@{MaltaCChip}}
}


{\ttfamily \#include $<$malta\_\-cchip.hh$>$}MaltaCChipに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=7cm]{classMaltaCChip}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef MaltaCChipParams \hyperlink{classMaltaCChip_a7a47c530613bf1fa98cc01dad4ffc4e3}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
const \hyperlink{classMaltaCChip_a7a47c530613bf1fa98cc01dad4ffc4e3}{Params} $\ast$ \hyperlink{classMaltaCChip_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{classMaltaCChip_aa4ac6a02ebf51ef5435118450b4908f3}{MaltaCChip} (\hyperlink{classMaltaCChip_a7a47c530613bf1fa98cc01dad4ffc4e3}{Params} $\ast$p)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classMaltaCChip_a613ec7d5e1ec64f8d21fec78ae8e568e}{read} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classMaltaCChip_a4cefab464e72b5dd42c003a0a4341802}{write} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classMaltaCChip_acdd7f639bc4c5a8d164d48a96734d6c1}{postRTC} ()
\item 
void \hyperlink{classMaltaCChip_a9a5bef2d9dc872c3efda198f08e08c62}{postIntr} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} interrupt)
\item 
void \hyperlink{classMaltaCChip_af0c6cfe896197ad4db6e5d1ab37fe5fb}{clearIntr} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} interrupt)
\item 
void \hyperlink{classMaltaCChip_ad463cf06091847c5eef7aba24419eee0}{clearIPI} (uint64\_\-t ipintr)
\item 
void \hyperlink{classMaltaCChip_a1bc328d0acc40e7f79412b5b3c9b9395}{clearITI} (uint64\_\-t itintr)
\item 
void \hyperlink{classMaltaCChip_a1f4571959aa97b26452f6accc79abffe}{reqIPI} (uint64\_\-t ipreq)
\item 
virtual void \hyperlink{classMaltaCChip_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classMaltaCChip_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMalta}{Malta} $\ast$ \hyperlink{classMaltaCChip_ae7ba1afe6be03355de9c5cbc41c11f96}{malta}
\end{DoxyCompactItemize}


\subsection{説明}
\hyperlink{classMalta}{Malta} CChip CSR Emulation. This device includes all the interrupt handling code for the chipset. 

\subsection{型定義}
\hypertarget{classMaltaCChip_a7a47c530613bf1fa98cc01dad4ffc4e3}{
\index{MaltaCChip@{MaltaCChip}!Params@{Params}}
\index{Params@{Params}!MaltaCChip@{MaltaCChip}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef MaltaCChipParams {\bf Params}}}
\label{classMaltaCChip_a7a47c530613bf1fa98cc01dad4ffc4e3}
The dims are device interrupt mask registers. One exists for each CPU, the DRIR X DIM = DIR The dirs are device interrupt registers. One exists for each CPU, the DRIR X DIM = DIR This register contains bits for each PCI interrupt that can occur. Indicator of which CPUs have an IPI interrupt Indicator of which CPUs have an RTC interrupt 

\hyperlink{classBasicPioDevice_a2845515ac6467f10540747053c8a0449}{BasicPioDevice}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classMaltaCChip_aa4ac6a02ebf51ef5435118450b4908f3}{
\index{MaltaCChip@{MaltaCChip}!MaltaCChip@{MaltaCChip}}
\index{MaltaCChip@{MaltaCChip}!MaltaCChip@{MaltaCChip}}
\subsubsection[{MaltaCChip}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MaltaCChip} ({\bf Params} $\ast$ {\em p})}}
\label{classMaltaCChip_aa4ac6a02ebf51ef5435118450b4908f3}
Initialize the \hyperlink{classMalta}{Malta} CChip by setting all of the device register to 0. 
\begin{DoxyParams}{引数}
\item[{\em p}]params struct \end{DoxyParams}



\begin{DoxyCode}
58     : BasicPioDevice(p, 0xfffffff), malta(p->malta)
59 {
60     warn("MaltaCCHIP::MaltaCChip() not implemented.");
61 
62     //Put back pointer in malta
63     malta->cchip = this;
64 
65 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classMaltaCChip_af0c6cfe896197ad4db6e5d1ab37fe5fb}{
\index{MaltaCChip@{MaltaCChip}!clearIntr@{clearIntr}}
\index{clearIntr@{clearIntr}!MaltaCChip@{MaltaCChip}}
\subsubsection[{clearIntr}]{\setlength{\rightskip}{0pt plus 5cm}void clearIntr ({\bf uint32\_\-t} {\em interrupt})}}
\label{classMaltaCChip_af0c6cfe896197ad4db6e5d1ab37fe5fb}
clear an interrupt previously posted to the CPU. 
\begin{DoxyParams}{引数}
\item[{\em interrupt}]the interrupt number to post (0-\/7) \end{DoxyParams}



\begin{DoxyCode}
491 {
492     uint64_t size = sys->threadContexts.size();
493     assert(size <= Malta::Max_CPUs);
494 
495     for(int i=0; i < size; i++) {
496                                         //Note: Malta does not use index, but thi
      s was added to use the pre-existing implementation
497               malta->intrctrl->clear(i, interrupt, 0);
498               DPRINTF(Malta, "clearing interrupt to cpu %d,"
499                         "interrupt %d\n",i, interrupt);
500    }
501 }
\end{DoxyCode}
\hypertarget{classMaltaCChip_ad463cf06091847c5eef7aba24419eee0}{
\index{MaltaCChip@{MaltaCChip}!clearIPI@{clearIPI}}
\index{clearIPI@{clearIPI}!MaltaCChip@{MaltaCChip}}
\subsubsection[{clearIPI}]{\setlength{\rightskip}{0pt plus 5cm}void clearIPI (uint64\_\-t {\em ipintr})}}
\label{classMaltaCChip_ad463cf06091847c5eef7aba24419eee0}
post an ipi interrupt to the CPU. 
\begin{DoxyParams}{引数}
\item[{\em ipintr}]the cpu number to clear(bitvector) \end{DoxyParams}



\begin{DoxyCode}
371 {
372                 panic("MaltaCCHIP::clear() not implemented.");
373                 /*
374     int numcpus = malta->intrctrl->cpu->system->threadContexts.size();
375     assert(numcpus <= Malta::Max_CPUs);
376 
377     if (ipintr) {
378         for (int cpunum=0; cpunum < numcpus; cpunum++) {
379             // Check each cpu bit
380             uint64_t cpumask = ULL(1) << cpunum;
381             if (ipintr & cpumask) {
382                 // Check if there is a pending ipi
383                 if (ipint & cpumask) {
384                     ipint &= ~cpumask;
385                     malta->intrctrl->clear(cpunum, TheISA::INTLEVEL_IRQ3, 0);
386                     DPRINTF(IPI, "clear IPI IPI cpu=%d\n", cpunum);
387                 }
388                 else
389                     warn("clear IPI for CPU=%d, but NO IPI\n", cpunum);
390             }
391         }
392     }
393     else
394         panic("Big IPI Clear, but not processors indicated\n");
395         */
396 }
\end{DoxyCode}
\hypertarget{classMaltaCChip_a1bc328d0acc40e7f79412b5b3c9b9395}{
\index{MaltaCChip@{MaltaCChip}!clearITI@{clearITI}}
\index{clearITI@{clearITI}!MaltaCChip@{MaltaCChip}}
\subsubsection[{clearITI}]{\setlength{\rightskip}{0pt plus 5cm}void clearITI (uint64\_\-t {\em itintr})}}
\label{classMaltaCChip_a1bc328d0acc40e7f79412b5b3c9b9395}
clear a timer interrupt previously posted to the CPU. 
\begin{DoxyParams}{引数}
\item[{\em itintr}]the cpu number to clear(bitvector) \end{DoxyParams}



\begin{DoxyCode}
400 {
401                 panic("MaltaCCHIP::clearITI() not implemented.");
402                 /*
403     int numcpus = malta->intrctrl->cpu->system->threadContexts.size();
404     assert(numcpus <= Malta::Max_CPUs);
405 
406     if (itintr) {
407         for (int i=0; i < numcpus; i++) {
408             uint64_t cpumask = ULL(1) << i;
409             if (itintr & cpumask & itint) {
410                 malta->intrctrl->clear(i, TheISA::INTLEVEL_IRQ2, 0);
411                 itint &= ~cpumask;
412                 DPRINTF(Malta, "clearing rtc interrupt to cpu=%d\n", i);
413             }
414         }
415     }
416     else
417         panic("Big ITI Clear, but not processors indicated\n");
418     */
419 }
\end{DoxyCode}
\hypertarget{classMaltaCChip_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{MaltaCChip@{MaltaCChip}!params@{params}}
\index{params@{params}!MaltaCChip@{MaltaCChip}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMaltaCChip_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classBasicPioDevice_acd3c3feb78ae7a8f88fe0f110a718dff}{BasicPioDevice}を再定義しています。


\begin{DoxyCode}
86     {
87         return dynamic_cast<const Params *>(_params);
88     }
\end{DoxyCode}
\hypertarget{classMaltaCChip_a9a5bef2d9dc872c3efda198f08e08c62}{
\index{MaltaCChip@{MaltaCChip}!postIntr@{postIntr}}
\index{postIntr@{postIntr}!MaltaCChip@{MaltaCChip}}
\subsubsection[{postIntr}]{\setlength{\rightskip}{0pt plus 5cm}void postIntr ({\bf uint32\_\-t} {\em interrupt})}}
\label{classMaltaCChip_a9a5bef2d9dc872c3efda198f08e08c62}
post an interrupt to the CPU. 
\begin{DoxyParams}{引数}
\item[{\em interrupt}]the interrupt number to post (0-\/7) \end{DoxyParams}



\begin{DoxyCode}
476 {
477     uint64_t size = sys->threadContexts.size();
478     assert(size <= Malta::Max_CPUs);
479 
480     for(int i=0; i < size; i++) {
481                                         //Note: Malta does not use index, but thi
      s was added to use the pre-existing implementation
482               malta->intrctrl->post(i, interrupt, 0);
483               DPRINTF(Malta, "posting  interrupt to cpu %d,"
484                         "interrupt %d\n",i, interrupt);
485    }
486 
487 }
\end{DoxyCode}
\hypertarget{classMaltaCChip_acdd7f639bc4c5a8d164d48a96734d6c1}{
\index{MaltaCChip@{MaltaCChip}!postRTC@{postRTC}}
\index{postRTC@{postRTC}!MaltaCChip@{MaltaCChip}}
\subsubsection[{postRTC}]{\setlength{\rightskip}{0pt plus 5cm}void postRTC ()}}
\label{classMaltaCChip_acdd7f639bc4c5a8d164d48a96734d6c1}
post an RTC interrupt to the CPU 


\begin{DoxyCode}
455 {
456                 panic("MaltaCCHIP::postRTC() not implemented.");
457 
458                 /*
459     int size = malta->intrctrl->cpu->system->threadContexts.size();
460     assert(size <= Malta::Max_CPUs);
461 
462     for (int i = 0; i < size; i++) {
463         uint64_t cpumask = ULL(1) << i;
464        if (!(cpumask & itint)) {
465            itint |= cpumask;
466            malta->intrctrl->post(i, TheISA::INTLEVEL_IRQ2, 0);
467            DPRINTF(Malta, "Posting RTC interrupt to cpu=%d", i);
468        }
469     }
470     */
471 
472 }
\end{DoxyCode}
\hypertarget{classMaltaCChip_a613ec7d5e1ec64f8d21fec78ae8e568e}{
\index{MaltaCChip@{MaltaCChip}!read@{read}}
\index{read@{read}!MaltaCChip@{MaltaCChip}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} read ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classMaltaCChip_a613ec7d5e1ec64f8d21fec78ae8e568e}
Pure virtual function that the device must implement. Called when a read command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_a842312590432036092c422c87a442358}{PioDevice}を実装しています。


\begin{DoxyCode}
69 {
70                 panic("MaltaCCHIP::read() not implemented.");
71                 return pioDelay;
72                 /*
73     DPRINTF(Malta, "read  va=%#x size=%d\n", pkt->getAddr(), pkt->getSize());
74 
75     assert(pkt->result == Packet::Unknown);
76     assert(pkt->getAddr() >= pioAddr && pkt->getAddr() < pioAddr + pioSize);
77 
78     Addr regnum = (pkt->getAddr() - pioAddr) >> 6;
79     Addr daddr = (pkt->getAddr() - pioAddr);
80 
81     pkt->allocate();
82     switch (pkt->getSize()) {
83 
84       case sizeof(uint64_t):
85           if (daddr & TSDEV_CC_BDIMS)
86           {
87               pkt->set(dim[(daddr >> 4) & 0x3F]);
88               break;
89           }
90 
91           if (daddr & TSDEV_CC_BDIRS)
92           {
93               pkt->set(dir[(daddr >> 4) & 0x3F]);
94               break;
95           }
96 
97           switch(regnum) {
98               case TSDEV_CC_CSR:
99                   pkt->set(0x0);
100                   break;
101               case TSDEV_CC_MTR:
102                   panic("TSDEV_CC_MTR not implemeted\n");
103                    break;
104               case TSDEV_CC_MISC:
105                   pkt->set((ipint << 8) & 0xF | (itint << 4) & 0xF |
106                                      (pkt->req->contextId() & 0x3));
107                   break;
108               case TSDEV_CC_AAR0:
109               case TSDEV_CC_AAR1:
110               case TSDEV_CC_AAR2:
111               case TSDEV_CC_AAR3:
112                   pkt->set(0);
113                   break;
114               case TSDEV_CC_DIM0:
115                   pkt->set(dim[0]);
116                   break;
117               case TSDEV_CC_DIM1:
118                   pkt->set(dim[1]);
119                   break;
120               case TSDEV_CC_DIM2:
121                   pkt->set(dim[2]);
122                   break;
123               case TSDEV_CC_DIM3:
124                   pkt->set(dim[3]);
125                   break;
126               case TSDEV_CC_DIR0:
127                   pkt->set(dir[0]);
128                   break;
129               case TSDEV_CC_DIR1:
130                   pkt->set(dir[1]);
131                   break;
132               case TSDEV_CC_DIR2:
133                   pkt->set(dir[2]);
134                   break;
135               case TSDEV_CC_DIR3:
136                   pkt->set(dir[3]);
137                   break;
138               case TSDEV_CC_DRIR:
139                   pkt->set(drir);
140                   break;
141               case TSDEV_CC_PRBEN:
142                   panic("TSDEV_CC_PRBEN not implemented\n");
143                   break;
144               case TSDEV_CC_IIC0:
145               case TSDEV_CC_IIC1:
146               case TSDEV_CC_IIC2:
147               case TSDEV_CC_IIC3:
148                   panic("TSDEV_CC_IICx not implemented\n");
149                   break;
150               case TSDEV_CC_MPR0:
151               case TSDEV_CC_MPR1:
152               case TSDEV_CC_MPR2:
153               case TSDEV_CC_MPR3:
154                   panic("TSDEV_CC_MPRx not implemented\n");
155                   break;
156               case TSDEV_CC_IPIR:
157                   pkt->set(ipint);
158                   break;
159               case TSDEV_CC_ITIR:
160                   pkt->set(itint);
161                   break;
162               default:
163                   panic("default in cchip read reached, accessing 0x%x\n");
164            } // uint64_t
165 
166       break;
167       case sizeof(uint32_t):
168       case sizeof(uint16_t):
169       case sizeof(uint8_t):
170       default:
171         panic("invalid access size(?) for malta register!\n");
172     }
173     DPRINTF(Malta, "Malta CChip: read  regnum=%#x size=%d data=%lld\n",
174             regnum, pkt->getSize(), pkt->get<uint64_t>());
175 
176     pkt->result = Packet::Success;
177     return pioDelay;
178     */
179 }
\end{DoxyCode}
\hypertarget{classMaltaCChip_a1f4571959aa97b26452f6accc79abffe}{
\index{MaltaCChip@{MaltaCChip}!reqIPI@{reqIPI}}
\index{reqIPI@{reqIPI}!MaltaCChip@{MaltaCChip}}
\subsubsection[{reqIPI}]{\setlength{\rightskip}{0pt plus 5cm}void reqIPI (uint64\_\-t {\em ipreq})}}
\label{classMaltaCChip_a1f4571959aa97b26452f6accc79abffe}
request an interrupt be posted to the CPU. 
\begin{DoxyParams}{引数}
\item[{\em ipreq}]the cpu number to interrupt(bitvector) \end{DoxyParams}



\begin{DoxyCode}
423 {
424                 panic("MaltaCCHIP::reqIPI() not implemented.");
425 
426                 /*
427     int numcpus = malta->intrctrl->cpu->system->threadContexts.size();
428     assert(numcpus <= Malta::Max_CPUs);
429 
430     if (ipreq) {
431         for (int cpunum=0; cpunum < numcpus; cpunum++) {
432             // Check each cpu bit
433             uint64_t cpumask = ULL(1) << cpunum;
434             if (ipreq & cpumask) {
435                 // Check if there is already an ipi (bits 8:11)
436                 if (!(ipint & cpumask)) {
437                     ipint  |= cpumask;
438                     malta->intrctrl->post(cpunum, TheISA::INTLEVEL_IRQ3, 0);
439                     DPRINTF(IPI, "send IPI cpu=%d\n", cpunum);
440                 }
441                 else
442                     warn("post IPI for CPU=%d, but IPI already\n", cpunum);
443             }
444         }
445     }
446     else
447         panic("Big IPI Request, but not processors indicated\n");
448    */
449 
450 }
\end{DoxyCode}
\hypertarget{classMaltaCChip_a53e036786d17361be4c7320d39c99b84}{
\index{MaltaCChip@{MaltaCChip}!serialize@{serialize}}
\index{serialize@{serialize}!MaltaCChip@{MaltaCChip}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classMaltaCChip_a53e036786d17361be4c7320d39c99b84}
Serialize this object to the given output stream. 
\begin{DoxyParams}{引数}
\item[{\em os}]The stream to serialize to. \end{DoxyParams}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。


\begin{DoxyCode}
506 {
507    // SERIALIZE_ARRAY(dim, Malta::Max_CPUs);
508     //SERIALIZE_ARRAY(dir, Malta::Max_CPUs);
509     //SERIALIZE_SCALAR(ipint);
510     //SERIALIZE_SCALAR(itint);
511     //SERIALIZE_SCALAR(drir);
512 }
\end{DoxyCode}
\hypertarget{classMaltaCChip_af22e5d6d660b97db37003ac61ac4ee49}{
\index{MaltaCChip@{MaltaCChip}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!MaltaCChip@{MaltaCChip}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classMaltaCChip_af22e5d6d660b97db37003ac61ac4ee49}
Reconstruct the state of this object from a checkpoint. 
\begin{DoxyParams}{引数}
\item[{\em \hyperlink{namespacecp}{cp}}]The checkpoint use. \item[{\em section}]The section name of this object \end{DoxyParams}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。


\begin{DoxyCode}
516 {
517     //UNSERIALIZE_ARRAY(dim, Malta::Max_CPUs);
518     //UNSERIALIZE_ARRAY(dir, Malta::Max_CPUs);
519     //UNSERIALIZE_SCALAR(ipint);
520     //UNSERIALIZE_SCALAR(itint);
521     //UNSERIALIZE_SCALAR(drir);
522 }
\end{DoxyCode}
\hypertarget{classMaltaCChip_a4cefab464e72b5dd42c003a0a4341802}{
\index{MaltaCChip@{MaltaCChip}!write@{write}}
\index{write@{write}!MaltaCChip@{MaltaCChip}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} write ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classMaltaCChip_a4cefab464e72b5dd42c003a0a4341802}
Pure virtual function that the device must implement. Called when a write command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_afe8371668d023bb2516b286e5e399b6f}{PioDevice}を実装しています。


\begin{DoxyCode}
183 {
184                 panic("MaltaCCHIP::write() not implemented.");
185                 return pioDelay;
186                 /*
187     assert(pkt->getAddr() >= pioAddr && pkt->getAddr() < pioAddr + pioSize);
188     Addr daddr = pkt->getAddr() - pioAddr;
189     Addr regnum = (pkt->getAddr() - pioAddr) >> 6 ;
190 
191 
192     assert(pkt->getSize() == sizeof(uint64_t));
193 
194     DPRINTF(Malta, "write - addr=%#x value=%#x\n", pkt->getAddr(), pkt->get<uint6
      4_t>());
195 
196     bool supportedWrite = false;
197 
198 
199     if (daddr & TSDEV_CC_BDIMS)
200     {
201         int number = (daddr >> 4) & 0x3F;
202 
203         uint64_t bitvector;
204         uint64_t olddim;
205         uint64_t olddir;
206 
207         olddim = dim[number];
208         olddir = dir[number];
209         dim[number] = pkt->get<uint64_t>();
210         dir[number] = dim[number] & drir;
211         for(int x = 0; x < Malta::Max_CPUs; x++)
212         {
213             bitvector = ULL(1) << x;
214             // Figure out which bits have changed
215             if ((dim[number] & bitvector) != (olddim & bitvector))
216             {
217                 // The bit is now set and it wasn't before (set)
218                 if((dim[number] & bitvector) && (dir[number] & bitvector))
219                 {
220                     malta->intrctrl->post(number, TheISA::INTLEVEL_IRQ1, x);
221                     DPRINTF(Malta, "dim write resulting in posting dir"
222                             " interrupt to cpu %d\n", number);
223                 }
224                 else if ((olddir & bitvector) &&
225                         !(dir[number] & bitvector))
226                 {
227                     // The bit was set and now its now clear and
228                     // we were interrupting on that bit before
229                     malta->intrctrl->clear(number, TheISA::INTLEVEL_IRQ1, x);
230                     DPRINTF(Malta, "dim write resulting in clear"
231                             " dir interrupt to cpu %d\n", number);
232 
233                 }
234 
235 
236             }
237         }
238     } else {
239         switch(regnum) {
240           case TSDEV_CC_CSR:
241               panic("TSDEV_CC_CSR write\n");
242           case TSDEV_CC_MTR:
243               panic("TSDEV_CC_MTR write not implemented\n");
244           case TSDEV_CC_MISC:
245             uint64_t ipreq;
246             ipreq = (pkt->get<uint64_t>() >> 12) & 0xF;
247             //If it is bit 12-15, this is an IPI post
248             if (ipreq) {
249                 reqIPI(ipreq);
250                 supportedWrite = true;
251             }
252 
253             //If it is bit 8-11, this is an IPI clear
254             uint64_t ipintr;
255             ipintr = (pkt->get<uint64_t>() >> 8) & 0xF;
256             if (ipintr) {
257                 clearIPI(ipintr);
258                 supportedWrite = true;
259             }
260 
261             //If it is the 4-7th bit, clear the RTC interrupt
262             uint64_t itintr;
263               itintr = (pkt->get<uint64_t>() >> 4) & 0xF;
264             if (itintr) {
265                   clearITI(itintr);
266                 supportedWrite = true;
267             }
268 
269               // ignore NXMs
270               if (pkt->get<uint64_t>() & 0x10000000)
271                   supportedWrite = true;
272 
273             if(!supportedWrite)
274                   panic("TSDEV_CC_MISC write not implemented\n");
275 
276             break;
277             case TSDEV_CC_AAR0:
278             case TSDEV_CC_AAR1:
279             case TSDEV_CC_AAR2:
280             case TSDEV_CC_AAR3:
281                 panic("TSDEV_CC_AARx write not implemeted\n");
282             case TSDEV_CC_DIM0:
283             case TSDEV_CC_DIM1:
284             case TSDEV_CC_DIM2:
285             case TSDEV_CC_DIM3:
286                 int number;
287                 if(regnum == TSDEV_CC_DIM0)
288                     number = 0;
289                 else if(regnum == TSDEV_CC_DIM1)
290                     number = 1;
291                 else if(regnum == TSDEV_CC_DIM2)
292                     number = 2;
293                 else
294                     number = 3;
295 
296                 uint64_t bitvector;
297                 uint64_t olddim;
298                 uint64_t olddir;
299 
300                 olddim = dim[number];
301                 olddir = dir[number];
302                 dim[number] = pkt->get<uint64_t>();
303                 dir[number] = dim[number] & drir;
304                 for(int x = 0; x < 64; x++)
305                 {
306                     bitvector = ULL(1) << x;
307                     // Figure out which bits have changed
308                     if ((dim[number] & bitvector) != (olddim & bitvector))
309                     {
310                         // The bit is now set and it wasn't before (set)
311                         if((dim[number] & bitvector) && (dir[number] & bitvector)
      )
312                         {
313                           malta->intrctrl->post(number, TheISA::INTLEVEL_IRQ1, x)
      ;
314                           DPRINTF(Malta, "posting dir interrupt to cpu 0\n");
315                         }
316                         else if ((olddir & bitvector) &&
317                                 !(dir[number] & bitvector))
318                         {
319                             // The bit was set and now its now clear and
320                             // we were interrupting on that bit before
321                             malta->intrctrl->clear(number, TheISA::INTLEVEL_IRQ1,
       x);
322                           DPRINTF(Malta, "dim write resulting in clear"
323                                     " dir interrupt to cpu %d\n",
324                                     x);
325 
326                         }
327 
328 
329                     }
330                 }
331                 break;
332             case TSDEV_CC_DIR0:
333             case TSDEV_CC_DIR1:
334             case TSDEV_CC_DIR2:
335             case TSDEV_CC_DIR3:
336                 panic("TSDEV_CC_DIR write not implemented\n");
337             case TSDEV_CC_DRIR:
338                 panic("TSDEV_CC_DRIR write not implemented\n");
339             case TSDEV_CC_PRBEN:
340                 panic("TSDEV_CC_PRBEN write not implemented\n");
341             case TSDEV_CC_IIC0:
342             case TSDEV_CC_IIC1:
343             case TSDEV_CC_IIC2:
344             case TSDEV_CC_IIC3:
345                 panic("TSDEV_CC_IICx write not implemented\n");
346             case TSDEV_CC_MPR0:
347             case TSDEV_CC_MPR1:
348             case TSDEV_CC_MPR2:
349             case TSDEV_CC_MPR3:
350                 panic("TSDEV_CC_MPRx write not implemented\n");
351             case TSDEV_CC_IPIR:
352                 clearIPI(pkt->get<uint64_t>());
353                 break;
354             case TSDEV_CC_ITIR:
355                 clearITI(pkt->get<uint64_t>());
356                 break;
357             case TSDEV_CC_IPIQ:
358                 reqIPI(pkt->get<uint64_t>());
359                 break;
360             default:
361               panic("default in cchip read reached, accessing 0x%x\n");
362         }  // swtich(regnum)
363     } // not BIG_TSUNAMI write
364     pkt->result = Packet::Success;
365     return pioDelay;
366     */
367 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classMaltaCChip_ae7ba1afe6be03355de9c5cbc41c11f96}{
\index{MaltaCChip@{MaltaCChip}!malta@{malta}}
\index{malta@{malta}!MaltaCChip@{MaltaCChip}}
\subsubsection[{malta}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Malta}$\ast$ {\bf malta}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMaltaCChip_ae7ba1afe6be03355de9c5cbc41c11f96}
pointer to the malta object. This is our access to all the other malta devices. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/mips/\hyperlink{malta__cchip_8hh}{malta\_\-cchip.hh}\item 
dev/mips/\hyperlink{malta__cchip_8cc}{malta\_\-cchip.cc}\end{DoxyCompactItemize}
