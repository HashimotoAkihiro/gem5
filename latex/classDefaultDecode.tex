\hypertarget{classDefaultDecode}{
\section{クラス テンプレート DefaultDecode$<$ Impl $>$}
\label{classDefaultDecode}\index{DefaultDecode@{DefaultDecode}}
}


{\ttfamily \#include $<$decode.hh$>$}\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structDefaultDecode_1_1Stalls}{Stalls}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classDefaultDecode_a92cfc320e0bf43339d34c50c65be3d71}{DecodeStatus} \{ \hyperlink{classDefaultDecode_a92cfc320e0bf43339d34c50c65be3d71a26bd8444261cc58df7a86753c79d2520}{Active}, 
\hyperlink{classDefaultDecode_a92cfc320e0bf43339d34c50c65be3d71a969c924a722daf6334fca64346092ae6}{Inactive}
 \}
\item 
enum \hyperlink{classDefaultDecode_ae2739961013a00cede621d4d72f2173c}{ThreadStatus} \{ \par
\hyperlink{classDefaultDecode_ae2739961013a00cede621d4d72f2173ca2f5f2c4a8c4f4f0519d503dcdfbf55cb}{Running}, 
\hyperlink{classDefaultDecode_ae2739961013a00cede621d4d72f2173cad3fa9ae9431d6cb1772f9d9df48cab19}{Idle}, 
\hyperlink{classDefaultDecode_ae2739961013a00cede621d4d72f2173ca19a48e232b72697e4bb7ea1b6075ed49}{StartSquash}, 
\hyperlink{classDefaultDecode_ae2739961013a00cede621d4d72f2173ca22a648855197e326dc88f548634c0ec7}{Squashing}, 
\par
\hyperlink{classDefaultDecode_ae2739961013a00cede621d4d72f2173ca9463ee9b8700258a1019b4b9d2d77a30}{Blocked}, 
\hyperlink{classDefaultDecode_ae2739961013a00cede621d4d72f2173caf2a3acf850890cb1651bc41dcbacb7e0}{Unblocking}
 \}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDefaultDecode_a23f15d8a826761fea1106a071b97cf79}{DefaultDecode} (\hyperlink{classDefaultDecode_a44622cf06940413482836cb62931ac3f}{O3CPU} $\ast$\_\-cpu, DerivO3CPUParams $\ast$params)
\item 
void \hyperlink{classDefaultDecode_a31d4cbdab16d4ff8d6bc7f84ece727da}{startupStage} ()
\item 
void \hyperlink{classDefaultDecode_ada2a699094bc420f977abf2a17ed14c8}{resetStage} ()
\item 
std::string \hyperlink{classDefaultDecode_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classDefaultDecode_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classDefaultDecode_a2b521ea5f191fff72265f60d4ed5187b}{setTimeBuffer} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$ $\ast$tb\_\-ptr)
\item 
void \hyperlink{classDefaultDecode_a21f95db13a2fc05d7a5fcc43fec1f1e7}{setDecodeQueue} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultDecode_a38077cd156cf219016abf92d8c5b523b}{DecodeStruct} $>$ $\ast$dq\_\-ptr)
\item 
void \hyperlink{classDefaultDecode_ad1be90519aa7737ddf8e41de079a5ea9}{setFetchQueue} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultDecode_a3aac8607069f16898ef53cfaa2d97aeb}{FetchStruct} $>$ $\ast$fq\_\-ptr)
\item 
void \hyperlink{classDefaultDecode_aab96bdacf8bd420402cbb543f994e054}{setActiveThreads} (\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$at\_\-ptr)
\item 
void \hyperlink{classDefaultDecode_a0240eb42fa57fe5d3788093f62b77347}{drainSanityCheck} () const 
\item 
bool \hyperlink{classDefaultDecode_adf5473c18a3d7c1e88c4a2072bce5526}{isDrained} () const 
\item 
void \hyperlink{classDefaultDecode_a8674059ce345e23aac5086b2c3e24a43}{takeOverFrom} ()
\item 
void \hyperlink{classDefaultDecode_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\item 
void \hyperlink{classDefaultDecode_a9632c526b9379a21d93cf2021090f194}{decode} (bool \&status\_\-change, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultDecode_a1a947755eba94aa1142e3b47068e5eee}{decodeInsts} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
unsigned \hyperlink{classDefaultDecode_a44313b71f53a0366212ed600d2d0b11d}{squash} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef Impl::O3CPU \hyperlink{classDefaultDecode_a44622cf06940413482836cb62931ac3f}{O3CPU}
\item 
typedef Impl::DynInstPtr \hyperlink{classDefaultDecode_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}
\item 
typedef Impl::CPUPol \hyperlink{classDefaultDecode_a87d662eaeb9eab249d671b63cb4ba11a}{CPUPol}
\item 
typedef CPUPol::FetchStruct \hyperlink{classDefaultDecode_a3aac8607069f16898ef53cfaa2d97aeb}{FetchStruct}
\item 
typedef CPUPol::DecodeStruct \hyperlink{classDefaultDecode_a38077cd156cf219016abf92d8c5b523b}{DecodeStruct}
\item 
typedef CPUPol::TimeStruct \hyperlink{classDefaultDecode_ab7dd3632ef639702a5c6e7c2c3a2f82a}{TimeStruct}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classDefaultDecode_ac24515147270ef9b85991bbe13bd47af}{skidInsert} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classDefaultDecode_afe3e2673d17dd5c568862ef5ae68b4d8}{skidsEmpty} ()
\item 
void \hyperlink{classDefaultDecode_a4bb9486757ce225941aaaf759b357a57}{updateStatus} ()
\item 
void \hyperlink{classDefaultDecode_a9ff2aa32ab0f40674cb3518108d62f8e}{sortInsts} ()
\item 
void \hyperlink{classDefaultDecode_ad65c9f053a6038ac8c34c34bfe9a88c3}{readStallSignals} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classDefaultDecode_af77f2bf38a75182c65e633b9fdf295d2}{checkSignalsAndUpdate} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classDefaultDecode_a6ba4f2f95d991f5be818dabf7500feed}{checkStall} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid) const 
\item 
bool \hyperlink{classDefaultDecode_a5517058b9f07975a25ecbf123bcc4844}{fetchInstsValid} ()
\item 
bool \hyperlink{classDefaultDecode_ad1993925abd15d3fb59fde2ccfa3d678}{block} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classDefaultDecode_a9cc3b95f6969935f78c0158aa5145021}{unblock} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultDecode_a80c82399ba102a2f35e863ee05d2e9dd}{squash} (\hyperlink{classDefaultDecode_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDefaultDecode_a92cfc320e0bf43339d34c50c65be3d71}{DecodeStatus} \hyperlink{classDefaultDecode_a69375c9c0bc115c0f1a90b7967abfa6a}{\_\-status}
\item 
\hyperlink{classDefaultDecode_ae2739961013a00cede621d4d72f2173c}{ThreadStatus} \hyperlink{classDefaultDecode_a1d8482258ad490dd3485ac43d127ce4d}{decodeStatus} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classDefaultDecode_a44622cf06940413482836cb62931ac3f}{O3CPU} $\ast$ \hyperlink{classDefaultDecode_a1379cf882a12ac6fc9eba5da7c84b18b}{cpu}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$ $\ast$ \hyperlink{classDefaultDecode_a83f9ee976e732665aeb08dbc19acfd45}{timeBuffer}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classDefaultDecode_ae99c54a9c8f1e218b86afcee348c54fc}{fromRename}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classDefaultDecode_a6c9093e88770a58dc8853f49a09bbac8}{fromIEW}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classDefaultDecode_a0055a92bd94eda21c2641d46ff013dac}{fromCommit}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classDefaultDecode_acc94cfae2a67b5dbb0e74e81c24a3b6e}{toFetch}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultDecode_a38077cd156cf219016abf92d8c5b523b}{DecodeStruct} $>$ $\ast$ \hyperlink{classDefaultDecode_a7860fc5736574343c9e294cb2bef9d93}{decodeQueue}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultDecode_a38077cd156cf219016abf92d8c5b523b}{DecodeStruct} $>$::wire \hyperlink{classDefaultDecode_ac096c67e7877c089a5417aa83a721edc}{toRename}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultDecode_a3aac8607069f16898ef53cfaa2d97aeb}{FetchStruct} $>$ $\ast$ \hyperlink{classDefaultDecode_a9a2f350be647ebfb6567172812db491a}{fetchQueue}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultDecode_a3aac8607069f16898ef53cfaa2d97aeb}{FetchStruct} $>$::wire \hyperlink{classDefaultDecode_a2e3dd009c447d077f19b303b53b52fab}{fromFetch}
\item 
std::queue$<$ \hyperlink{classDefaultDecode_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classDefaultDecode_a1b0ce60f9b6c662a2f3df87a3e8b50f8}{insts} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
std::queue$<$ \hyperlink{classDefaultDecode_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classDefaultDecode_a911bfd7c5c1efbd9f479d2b960078ec1}{skidBuffer} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
bool \hyperlink{classDefaultDecode_a2c7e870d4babdac0dc91fc7ffabd0f3d}{wroteToTimeBuffer}
\item 
\hyperlink{structDefaultDecode_1_1Stalls}{Stalls} \hyperlink{classDefaultDecode_ade48cf321f5741ea8e54e071680cacdc}{stalls} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classDefaultDecode_a3b9933c4d891d5618e6a103f0c231e8c}{renameToDecodeDelay}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classDefaultDecode_ac7ece3c345b9ce038d4b7726da7c9b41}{iewToDecodeDelay}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classDefaultDecode_a77f4b17f2ef6c226e894d648ee743fae}{commitToDecodeDelay}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classDefaultDecode_a689484c3554224a1c1c676e9dde3f653}{fetchToDecodeDelay}
\item 
unsigned \hyperlink{classDefaultDecode_aecf92f13590eed742e3064a4fdb5e004}{decodeWidth}
\item 
unsigned \hyperlink{classDefaultDecode_a998ac27e2d5479a5c6e97258d25cea3d}{toRenameIndex}
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classDefaultDecode_a88377f855dbf5adeeecb06b5bb821d35}{numThreads}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$ \hyperlink{classDefaultDecode_af6eaea53db532812052f71bf0380dab5}{activeThreads}
\item 
unsigned \hyperlink{classDefaultDecode_a268414a6444b620140f263013a739a17}{skidBufferMax}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classDefaultDecode_aa7e5b323025273d40b8cba03150ebaee}{bdelayDoneSeqNum} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classDefaultDecode_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classDefaultDecode_ab16bbdee47d26fedf584262248b6b6e4}{squashInst} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
bool \hyperlink{classDefaultDecode_ab0db2d75f6bf41c785017f8c3af9c16b}{squashAfterDelaySlot} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultDecode_a1037bebd5ca3880affa4633d03176747}{decodeIdleCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultDecode_aa61ef46bfb5ece8742ca0ba35c596f7f}{decodeBlockedCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultDecode_af217607d5162d70e22d1892d3b7f041d}{decodeRunCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultDecode_a99328fc971ae507d591e100b90615c8b}{decodeUnblockCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultDecode_aac9ee4c2600bd9d9915595c7008652ba}{decodeSquashCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultDecode_a85271ddee50df718b95448a65de49f4f}{decodeBranchResolved}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultDecode_ac82a9e3870dbcc3d3c3a331634bf81af}{decodeBranchMispred}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultDecode_ac6135ce194bbd50f851f71e0e6049464}{decodeControlMispred}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultDecode_a2ac1cd5e0cbce47426a97fba4bb966dc}{decodeDecodedInsts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultDecode_a7bd44f968f6e156e212a8c275066ec40}{decodeSquashedInsts}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$class Impl$>$ class DefaultDecode$<$ Impl $>$}

\hyperlink{classDefaultDecode}{DefaultDecode} class handles both single threaded and SMT decode. Its width is specified by the parameters; each cycles it tries to decode that many instructions. Because instructions are actually decoded when the \hyperlink{classStaticInst}{StaticInst} is created, this stage does not do much other than check any PC-\/relative branches. 

\subsection{型定義}
\hypertarget{classDefaultDecode_a87d662eaeb9eab249d671b63cb4ba11a}{
\index{DefaultDecode@{DefaultDecode}!CPUPol@{CPUPol}}
\index{CPUPol@{CPUPol}!DefaultDecode@{DefaultDecode}}
\subsubsection[{CPUPol}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::CPUPol {\bf CPUPol}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a87d662eaeb9eab249d671b63cb4ba11a}
\hypertarget{classDefaultDecode_a38077cd156cf219016abf92d8c5b523b}{
\index{DefaultDecode@{DefaultDecode}!DecodeStruct@{DecodeStruct}}
\index{DecodeStruct@{DecodeStruct}!DefaultDecode@{DefaultDecode}}
\subsubsection[{DecodeStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::DecodeStruct {\bf DecodeStruct}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a38077cd156cf219016abf92d8c5b523b}
\hypertarget{classDefaultDecode_a028ce10889c5f6450239d9e9a7347976}{
\index{DefaultDecode@{DefaultDecode}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!DefaultDecode@{DefaultDecode}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInstPtr {\bf DynInstPtr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a028ce10889c5f6450239d9e9a7347976}
\hypertarget{classDefaultDecode_a3aac8607069f16898ef53cfaa2d97aeb}{
\index{DefaultDecode@{DefaultDecode}!FetchStruct@{FetchStruct}}
\index{FetchStruct@{FetchStruct}!DefaultDecode@{DefaultDecode}}
\subsubsection[{FetchStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::FetchStruct {\bf FetchStruct}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a3aac8607069f16898ef53cfaa2d97aeb}
\hypertarget{classDefaultDecode_a44622cf06940413482836cb62931ac3f}{
\index{DefaultDecode@{DefaultDecode}!O3CPU@{O3CPU}}
\index{O3CPU@{O3CPU}!DefaultDecode@{DefaultDecode}}
\subsubsection[{O3CPU}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::O3CPU {\bf O3CPU}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a44622cf06940413482836cb62931ac3f}
\hypertarget{classDefaultDecode_ab7dd3632ef639702a5c6e7c2c3a2f82a}{
\index{DefaultDecode@{DefaultDecode}!TimeStruct@{TimeStruct}}
\index{TimeStruct@{TimeStruct}!DefaultDecode@{DefaultDecode}}
\subsubsection[{TimeStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::TimeStruct {\bf TimeStruct}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_ab7dd3632ef639702a5c6e7c2c3a2f82a}


\subsection{列挙型}
\hypertarget{classDefaultDecode_a92cfc320e0bf43339d34c50c65be3d71}{
\index{DefaultDecode@{DefaultDecode}!DecodeStatus@{DecodeStatus}}
\index{DecodeStatus@{DecodeStatus}!DefaultDecode@{DefaultDecode}}
\subsubsection[{DecodeStatus}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf DecodeStatus}}}
\label{classDefaultDecode_a92cfc320e0bf43339d34c50c65be3d71}
Overall decode stage status. Used to determine if the CPU can deschedule itself due to a lack of activity. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Active@{Active}!DefaultDecode@{DefaultDecode}}\index{DefaultDecode@{DefaultDecode}!Active@{Active}}\item[{\em 
\hypertarget{classDefaultDecode_a92cfc320e0bf43339d34c50c65be3d71a26bd8444261cc58df7a86753c79d2520}{
Active}
\label{classDefaultDecode_a92cfc320e0bf43339d34c50c65be3d71a26bd8444261cc58df7a86753c79d2520}
}]\index{Inactive@{Inactive}!DefaultDecode@{DefaultDecode}}\index{DefaultDecode@{DefaultDecode}!Inactive@{Inactive}}\item[{\em 
\hypertarget{classDefaultDecode_a92cfc320e0bf43339d34c50c65be3d71a969c924a722daf6334fca64346092ae6}{
Inactive}
\label{classDefaultDecode_a92cfc320e0bf43339d34c50c65be3d71a969c924a722daf6334fca64346092ae6}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
78                       {
79         Active,
80         Inactive
81     };
\end{DoxyCode}
\hypertarget{classDefaultDecode_ae2739961013a00cede621d4d72f2173c}{
\index{DefaultDecode@{DefaultDecode}!ThreadStatus@{ThreadStatus}}
\index{ThreadStatus@{ThreadStatus}!DefaultDecode@{DefaultDecode}}
\subsubsection[{ThreadStatus}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ThreadStatus}}}
\label{classDefaultDecode_ae2739961013a00cede621d4d72f2173c}
Individual thread status. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Running@{Running}!DefaultDecode@{DefaultDecode}}\index{DefaultDecode@{DefaultDecode}!Running@{Running}}\item[{\em 
\hypertarget{classDefaultDecode_ae2739961013a00cede621d4d72f2173ca2f5f2c4a8c4f4f0519d503dcdfbf55cb}{
Running}
\label{classDefaultDecode_ae2739961013a00cede621d4d72f2173ca2f5f2c4a8c4f4f0519d503dcdfbf55cb}
}]\index{Idle@{Idle}!DefaultDecode@{DefaultDecode}}\index{DefaultDecode@{DefaultDecode}!Idle@{Idle}}\item[{\em 
\hypertarget{classDefaultDecode_ae2739961013a00cede621d4d72f2173cad3fa9ae9431d6cb1772f9d9df48cab19}{
Idle}
\label{classDefaultDecode_ae2739961013a00cede621d4d72f2173cad3fa9ae9431d6cb1772f9d9df48cab19}
}]\index{StartSquash@{StartSquash}!DefaultDecode@{DefaultDecode}}\index{DefaultDecode@{DefaultDecode}!StartSquash@{StartSquash}}\item[{\em 
\hypertarget{classDefaultDecode_ae2739961013a00cede621d4d72f2173ca19a48e232b72697e4bb7ea1b6075ed49}{
StartSquash}
\label{classDefaultDecode_ae2739961013a00cede621d4d72f2173ca19a48e232b72697e4bb7ea1b6075ed49}
}]\index{Squashing@{Squashing}!DefaultDecode@{DefaultDecode}}\index{DefaultDecode@{DefaultDecode}!Squashing@{Squashing}}\item[{\em 
\hypertarget{classDefaultDecode_ae2739961013a00cede621d4d72f2173ca22a648855197e326dc88f548634c0ec7}{
Squashing}
\label{classDefaultDecode_ae2739961013a00cede621d4d72f2173ca22a648855197e326dc88f548634c0ec7}
}]\index{Blocked@{Blocked}!DefaultDecode@{DefaultDecode}}\index{DefaultDecode@{DefaultDecode}!Blocked@{Blocked}}\item[{\em 
\hypertarget{classDefaultDecode_ae2739961013a00cede621d4d72f2173ca9463ee9b8700258a1019b4b9d2d77a30}{
Blocked}
\label{classDefaultDecode_ae2739961013a00cede621d4d72f2173ca9463ee9b8700258a1019b4b9d2d77a30}
}]\index{Unblocking@{Unblocking}!DefaultDecode@{DefaultDecode}}\index{DefaultDecode@{DefaultDecode}!Unblocking@{Unblocking}}\item[{\em 
\hypertarget{classDefaultDecode_ae2739961013a00cede621d4d72f2173caf2a3acf850890cb1651bc41dcbacb7e0}{
Unblocking}
\label{classDefaultDecode_ae2739961013a00cede621d4d72f2173caf2a3acf850890cb1651bc41dcbacb7e0}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
84                       {
85         Running,
86         Idle,
87         StartSquash,
88         Squashing,
89         Blocked,
90         Unblocking
91     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classDefaultDecode_a23f15d8a826761fea1106a071b97cf79}{
\index{DefaultDecode@{DefaultDecode}!DefaultDecode@{DefaultDecode}}
\index{DefaultDecode@{DefaultDecode}!DefaultDecode@{DefaultDecode}}
\subsubsection[{DefaultDecode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DefaultDecode} ({\bf O3CPU} $\ast$ {\em \_\-cpu}, \/  DerivO3CPUParams $\ast$ {\em params})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultDecode_a23f15d8a826761fea1106a071b97cf79}
\hyperlink{classDefaultDecode}{DefaultDecode} constructor. 


\begin{DoxyCode}
63     : cpu(_cpu),
64       renameToDecodeDelay(params->renameToDecodeDelay),
65       iewToDecodeDelay(params->iewToDecodeDelay),
66       commitToDecodeDelay(params->commitToDecodeDelay),
67       fetchToDecodeDelay(params->fetchToDecodeDelay),
68       decodeWidth(params->decodeWidth),
69       numThreads(params->numThreads)
70 {
71     if (decodeWidth > Impl::MaxWidth)
72         fatal("decodeWidth (%d) is larger than compiled limit (%d),\n"
73              "\tincrease MaxWidth in src/cpu/o3/impl.hh\n",
74              decodeWidth, static_cast<int>(Impl::MaxWidth));
75 
76     // @todo: Make into a parameter
77     skidBufferMax = (fetchToDecodeDelay + 1) *  params->fetchWidth;
78 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classDefaultDecode_ad1993925abd15d3fb59fde2ccfa3d678}{
\index{DefaultDecode@{DefaultDecode}!block@{block}}
\index{block@{block}!DefaultDecode@{DefaultDecode}}
\subsubsection[{block}]{\setlength{\rightskip}{0pt plus 5cm}bool block ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultDecode_ad1993925abd15d3fb59fde2ccfa3d678}
Switches decode to blocking, and signals back that decode has become blocked. \begin{DoxyReturn}{戻り値}
Returns true if there is a status change. 
\end{DoxyReturn}



\begin{DoxyCode}
239 {
240     DPRINTF(Decode, "[tid:%u]: Blocking.\n", tid);
241 
242     // Add the current inputs to the skid buffer so they can be
243     // reprocessed when this stage unblocks.
244     skidInsert(tid);
245 
246     // If the decode status is blocked or unblocking then decode has not yet
247     // signalled fetch to unblock. In that case, there is no need to tell
248     // fetch to block.
249     if (decodeStatus[tid] != Blocked) {
250         // Set the status to Blocked.
251         decodeStatus[tid] = Blocked;
252 
253         if (toFetch->decodeUnblock[tid]) {
254             toFetch->decodeUnblock[tid] = false;
255         } else {
256             toFetch->decodeBlock[tid] = true;
257             wroteToTimeBuffer = true;
258         }
259 
260         return true;
261     }
262 
263     return false;
264 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_af77f2bf38a75182c65e633b9fdf295d2}{
\index{DefaultDecode@{DefaultDecode}!checkSignalsAndUpdate@{checkSignalsAndUpdate}}
\index{checkSignalsAndUpdate@{checkSignalsAndUpdate}!DefaultDecode@{DefaultDecode}}
\subsubsection[{checkSignalsAndUpdate}]{\setlength{\rightskip}{0pt plus 5cm}bool checkSignalsAndUpdate ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultDecode_af77f2bf38a75182c65e633b9fdf295d2}
Checks all input signals and updates decode's status appropriately. 


\begin{DoxyCode}
509 {
510     // Check if there's a squash signal, squash if there is.
511     // Check stall signals, block if necessary.
512     // If status was blocked
513     //     Check if stall conditions have passed
514     //         if so then go to unblocking
515     // If status was Squashing
516     //     check if squashing is not high.  Switch to running this cycle.
517 
518     // Update the per thread stall statuses.
519     readStallSignals(tid);
520 
521     // Check squash signals from commit.
522     if (fromCommit->commitInfo[tid].squash) {
523 
524         DPRINTF(Decode, "[tid:%u]: Squashing instructions due to squash "
525                 "from commit.\n", tid);
526 
527         squash(tid);
528 
529         return true;
530     }
531 
532     // Check ROB squash signals from commit.
533     if (fromCommit->commitInfo[tid].robSquashing) {
534         DPRINTF(Decode, "[tid:%u]: ROB is still squashing.\n", tid);
535 
536         // Continue to squash.
537         decodeStatus[tid] = Squashing;
538 
539         return true;
540     }
541 
542     if (checkStall(tid)) {
543         return block(tid);
544     }
545 
546     if (decodeStatus[tid] == Blocked) {
547         DPRINTF(Decode, "[tid:%u]: Done blocking, switching to unblocking.\n",
548                 tid);
549 
550         decodeStatus[tid] = Unblocking;
551 
552         unblock(tid);
553 
554         return true;
555     }
556 
557     if (decodeStatus[tid] == Squashing) {
558         // Switch status to running if decode isn't being told to block or
559         // squash this cycle.
560         DPRINTF(Decode, "[tid:%u]: Done squashing, switching to running.\n",
561                 tid);
562 
563         decodeStatus[tid] = Running;
564 
565         return false;
566     }
567 
568     // If we've reached this point, we have not gotten any signals that
569     // cause decode to change its status.  Decode remains the same as before.
570     return false;
571 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_a6ba4f2f95d991f5be818dabf7500feed}{
\index{DefaultDecode@{DefaultDecode}!checkStall@{checkStall}}
\index{checkStall@{checkStall}!DefaultDecode@{DefaultDecode}}
\subsubsection[{checkStall}]{\setlength{\rightskip}{0pt plus 5cm}bool checkStall ({\bf ThreadID} {\em tid}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultDecode_a6ba4f2f95d991f5be818dabf7500feed}
Checks all stall signals, and returns if any are true. 


\begin{DoxyCode}
212 {
213     bool ret_val = false;
214 
215     if (stalls[tid].rename) {
216         DPRINTF(Decode,"[tid:%i]: Stall fom Rename stage detected.\n", tid);
217         ret_val = true;
218     } else if (stalls[tid].iew) {
219         DPRINTF(Decode,"[tid:%i]: Stall fom IEW stage detected.\n", tid);
220         ret_val = true;
221     } else if (stalls[tid].commit) {
222         DPRINTF(Decode,"[tid:%i]: Stall fom Commit stage detected.\n", tid);
223         ret_val = true;
224     }
225 
226     return ret_val;
227 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_a9632c526b9379a21d93cf2021090f194}{
\index{DefaultDecode@{DefaultDecode}!decode@{decode}}
\index{decode@{decode}!DefaultDecode@{DefaultDecode}}
\subsubsection[{decode}]{\setlength{\rightskip}{0pt plus 5cm}void decode (bool \& {\em status\_\-change}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultDecode_a9632c526b9379a21d93cf2021090f194}
Determines what to do based on decode's current status. 
\begin{DoxyParams}{引数}
\item[{\em status\_\-change}]\hyperlink{classDefaultDecode_a9632c526b9379a21d93cf2021090f194}{decode()} sets this variable if there was a status change (ie switching from from blocking to unblocking). \item[{\em tid}]Thread id to decode instructions from. \end{DoxyParams}



\begin{DoxyCode}
612 {
613     // If status is Running or idle,
614     //     call decodeInsts()
615     // If status is Unblocking,
616     //     buffer any instructions coming from fetch
617     //     continue trying to empty skid buffer
618     //     check if stall conditions have passed
619 
620     if (decodeStatus[tid] == Blocked) {
621         ++decodeBlockedCycles;
622     } else if (decodeStatus[tid] == Squashing) {
623         ++decodeSquashCycles;
624     }
625 
626     // Decode should try to decode as many instructions as its bandwidth
627     // will allow, as long as it is not currently blocked.
628     if (decodeStatus[tid] == Running ||
629         decodeStatus[tid] == Idle) {
630         DPRINTF(Decode, "[tid:%u]: Not blocked, so attempting to run "
631                 "stage.\n",tid);
632 
633         decodeInsts(tid);
634     } else if (decodeStatus[tid] == Unblocking) {
635         // Make sure that the skid buffer has something in it if the
636         // status is unblocking.
637         assert(!skidsEmpty());
638 
639         // If the status was unblocking, then instructions from the skid
640         // buffer were used.  Remove those instructions and handle
641         // the rest of unblocking.
642         decodeInsts(tid);
643 
644         if (fetchInstsValid()) {
645             // Add the current inputs to the skid buffer so they can be
646             // reprocessed when this stage unblocks.
647             skidInsert(tid);
648         }
649 
650         status_change = unblock(tid) || status_change;
651     }
652 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_a1a947755eba94aa1142e3b47068e5eee}{
\index{DefaultDecode@{DefaultDecode}!decodeInsts@{decodeInsts}}
\index{decodeInsts@{decodeInsts}!DefaultDecode@{DefaultDecode}}
\subsubsection[{decodeInsts}]{\setlength{\rightskip}{0pt plus 5cm}void decodeInsts ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultDecode_a1a947755eba94aa1142e3b47068e5eee}
Processes instructions from fetch and passes them on to rename. Decoding of instructions actually happens when they are created in fetch, so this function mostly checks if PC-\/relative branches are correct. 


\begin{DoxyCode}
657 {
658     // Instructions can come either from the skid buffer or the list of
659     // instructions coming from fetch, depending on decode's status.
660     int insts_available = decodeStatus[tid] == Unblocking ?
661         skidBuffer[tid].size() : insts[tid].size();
662 
663     if (insts_available == 0) {
664         DPRINTF(Decode, "[tid:%u] Nothing to do, breaking out"
665                 " early.\n",tid);
666         // Should I change the status to idle?
667         ++decodeIdleCycles;
668         return;
669     } else if (decodeStatus[tid] == Unblocking) {
670         DPRINTF(Decode, "[tid:%u] Unblocking, removing insts from skid "
671                 "buffer.\n",tid);
672         ++decodeUnblockCycles;
673     } else if (decodeStatus[tid] == Running) {
674         ++decodeRunCycles;
675     }
676 
677     DynInstPtr inst;
678 
679     std::queue<DynInstPtr>
680         &insts_to_decode = decodeStatus[tid] == Unblocking ?
681         skidBuffer[tid] : insts[tid];
682 
683     DPRINTF(Decode, "[tid:%u]: Sending instruction to rename.\n",tid);
684 
685     while (insts_available > 0 && toRenameIndex < decodeWidth) {
686         assert(!insts_to_decode.empty());
687 
688         inst = insts_to_decode.front();
689 
690         insts_to_decode.pop();
691 
692         DPRINTF(Decode, "[tid:%u]: Processing instruction [sn:%lli] with "
693                 "PC %s\n", tid, inst->seqNum, inst->pcState());
694 
695         if (inst->isSquashed()) {
696             DPRINTF(Decode, "[tid:%u]: Instruction %i with PC %s is "
697                     "squashed, skipping.\n",
698                     tid, inst->seqNum, inst->pcState());
699 
700             ++decodeSquashedInsts;
701 
702             --insts_available;
703 
704             continue;
705         }
706 
707         // Also check if instructions have no source registers.  Mark
708         // them as ready to issue at any time.  Not sure if this check
709         // should exist here or at a later stage; however it doesn't matter
710         // too much for function correctness.
711         if (inst->numSrcRegs() == 0) {
712             inst->setCanIssue();
713         }
714 
715         // This current instruction is valid, so add it into the decode
716         // queue.  The next instruction may not be valid, so check to
717         // see if branches were predicted correctly.
718         toRename->insts[toRenameIndex] = inst;
719 
720         ++(toRename->size);
721         ++toRenameIndex;
722         ++decodeDecodedInsts;
723         --insts_available;
724 
725 #if TRACING_ON
726         if (DTRACE(O3PipeView)) {
727             inst->decodeTick = curTick() - inst->fetchTick;
728         }
729 #endif
730 
731         // Ensure that if it was predicted as a branch, it really is a
732         // branch.
733         if (inst->readPredTaken() && !inst->isControl()) {
734             panic("Instruction predicted as a branch!");
735 
736             ++decodeControlMispred;
737 
738             // Might want to set some sort of boolean and just do
739             // a check at the end
740             squash(inst, inst->threadNumber);
741 
742             break;
743         }
744 
745         // Go ahead and compute any PC-relative branches.
746         if (inst->isDirectCtrl() && inst->isUncondCtrl()) {
747             ++decodeBranchResolved;
748 
749             if (!(inst->branchTarget() == inst->readPredTarg())) {
750                 ++decodeBranchMispred;
751 
752                 // Might want to set some sort of boolean and just do
753                 // a check at the end
754                 squash(inst, inst->threadNumber);
755                 TheISA::PCState target = inst->branchTarget();
756 
757                 DPRINTF(Decode, "[sn:%i]: Updating predictions: PredPC: %s\n",
758                         inst->seqNum, target);
759                 //The micro pc after an instruction level branch should be 0
760                 inst->setPredTarg(target);
761                 break;
762             }
763         }
764     }
765 
766     // If we didn't process all instructions, then we will need to block
767     // and put all those instructions into the skid buffer.
768     if (!insts_to_decode.empty()) {
769         block(tid);
770     }
771 
772     // Record that decode has written to the time buffer for activity
773     // tracking.
774     if (toRenameIndex) {
775         wroteToTimeBuffer = true;
776     }
777 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_a0240eb42fa57fe5d3788093f62b77347}{
\index{DefaultDecode@{DefaultDecode}!drainSanityCheck@{drainSanityCheck}}
\index{drainSanityCheck@{drainSanityCheck}!DefaultDecode@{DefaultDecode}}
\subsubsection[{drainSanityCheck}]{\setlength{\rightskip}{0pt plus 5cm}void drainSanityCheck () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultDecode_a0240eb42fa57fe5d3788093f62b77347}
Perform sanity checks after a drain. 


\begin{DoxyCode}
202 {
203     for (ThreadID tid = 0; tid < numThreads; ++tid) {
204         assert(insts[tid].empty());
205         assert(skidBuffer[tid].empty());
206     }
207 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_a5517058b9f07975a25ecbf123bcc4844}{
\index{DefaultDecode@{DefaultDecode}!fetchInstsValid@{fetchInstsValid}}
\index{fetchInstsValid@{fetchInstsValid}!DefaultDecode@{DefaultDecode}}
\subsubsection[{fetchInstsValid}]{\setlength{\rightskip}{0pt plus 5cm}bool fetchInstsValid ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultDecode_a5517058b9f07975a25ecbf123bcc4844}
Returns if there any instructions from fetch on this cycle. 


\begin{DoxyCode}
232 {
233     return fromFetch->size > 0;
234 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_adf5473c18a3d7c1e88c4a2072bce5526}{
\index{DefaultDecode@{DefaultDecode}!isDrained@{isDrained}}
\index{isDrained@{isDrained}!DefaultDecode@{DefaultDecode}}
\subsubsection[{isDrained}]{\setlength{\rightskip}{0pt plus 5cm}bool isDrained () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultDecode_adf5473c18a3d7c1e88c4a2072bce5526}
Has the stage drained? 


\begin{DoxyCode}
129 { return true; }
\end{DoxyCode}
\hypertarget{classDefaultDecode_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{DefaultDecode@{DefaultDecode}!name@{name}}
\index{name@{name}!DefaultDecode@{DefaultDecode}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultDecode_a37627d5d5bba7f4a8690c71c2ab3cb07}
Returns the name of decode. 


\begin{DoxyCode}
106 {
107     return cpu->name() + ".decode";
108 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_ad65c9f053a6038ac8c34c34bfe9a88c3}{
\index{DefaultDecode@{DefaultDecode}!readStallSignals@{readStallSignals}}
\index{readStallSignals@{readStallSignals}!DefaultDecode@{DefaultDecode}}
\subsubsection[{readStallSignals}]{\setlength{\rightskip}{0pt plus 5cm}void readStallSignals ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultDecode_ad65c9f053a6038ac8c34c34bfe9a88c3}
Reads all stall signals from the backwards communication timebuffer. 


\begin{DoxyCode}
477 {
478     if (fromRename->renameBlock[tid]) {
479         stalls[tid].rename = true;
480     }
481 
482     if (fromRename->renameUnblock[tid]) {
483         assert(stalls[tid].rename);
484         stalls[tid].rename = false;
485     }
486 
487     if (fromIEW->iewBlock[tid]) {
488         stalls[tid].iew = true;
489     }
490 
491     if (fromIEW->iewUnblock[tid]) {
492         assert(stalls[tid].iew);
493         stalls[tid].iew = false;
494     }
495 
496     if (fromCommit->commitBlock[tid]) {
497         stalls[tid].commit = true;
498     }
499 
500     if (fromCommit->commitUnblock[tid]) {
501         assert(stalls[tid].commit);
502         stalls[tid].commit = false;
503     }
504 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{DefaultDecode@{DefaultDecode}!regStats@{regStats}}
\index{regStats@{regStats}!DefaultDecode@{DefaultDecode}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultDecode_a4dc637449366fcdfc4e764cdf12d9b11}
Registers statistics. 


\begin{DoxyCode}
113 {
114     decodeIdleCycles
115         .name(name() + ".IdleCycles")
116         .desc("Number of cycles decode is idle")
117         .prereq(decodeIdleCycles);
118     decodeBlockedCycles
119         .name(name() + ".BlockedCycles")
120         .desc("Number of cycles decode is blocked")
121         .prereq(decodeBlockedCycles);
122     decodeRunCycles
123         .name(name() + ".RunCycles")
124         .desc("Number of cycles decode is running")
125         .prereq(decodeRunCycles);
126     decodeUnblockCycles
127         .name(name() + ".UnblockCycles")
128         .desc("Number of cycles decode is unblocking")
129         .prereq(decodeUnblockCycles);
130     decodeSquashCycles
131         .name(name() + ".SquashCycles")
132         .desc("Number of cycles decode is squashing")
133         .prereq(decodeSquashCycles);
134     decodeBranchResolved
135         .name(name() + ".BranchResolved")
136         .desc("Number of times decode resolved a branch")
137         .prereq(decodeBranchResolved);
138     decodeBranchMispred
139         .name(name() + ".BranchMispred")
140         .desc("Number of times decode detected a branch misprediction")
141         .prereq(decodeBranchMispred);
142     decodeControlMispred
143         .name(name() + ".ControlMispred")
144         .desc("Number of times decode detected an instruction incorrectly"
145               " predicted as a control")
146         .prereq(decodeControlMispred);
147     decodeDecodedInsts
148         .name(name() + ".DecodedInsts")
149         .desc("Number of instructions handled by decode")
150         .prereq(decodeDecodedInsts);
151     decodeSquashedInsts
152         .name(name() + ".SquashedInsts")
153         .desc("Number of squashed instructions handled by decode")
154         .prereq(decodeSquashedInsts);
155 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_ada2a699094bc420f977abf2a17ed14c8}{
\index{DefaultDecode@{DefaultDecode}!resetStage@{resetStage}}
\index{resetStage@{resetStage}!DefaultDecode@{DefaultDecode}}
\subsubsection[{resetStage}]{\setlength{\rightskip}{0pt plus 5cm}void resetStage ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultDecode_ada2a699094bc420f977abf2a17ed14c8}



\begin{DoxyCode}
90 {
91     _status = Inactive;
92 
93     // Setup status, make sure stall signals are clear.
94     for (ThreadID tid = 0; tid < numThreads; ++tid) {
95         decodeStatus[tid] = Idle;
96 
97         stalls[tid].rename = false;
98         stalls[tid].iew = false;
99         stalls[tid].commit = false;
100     }
101 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_aab96bdacf8bd420402cbb543f994e054}{
\index{DefaultDecode@{DefaultDecode}!setActiveThreads@{setActiveThreads}}
\index{setActiveThreads@{setActiveThreads}!DefaultDecode@{DefaultDecode}}
\subsubsection[{setActiveThreads}]{\setlength{\rightskip}{0pt plus 5cm}void setActiveThreads ({\bf std::list}$<$ {\bf ThreadID} $>$ $\ast$ {\em at\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultDecode_aab96bdacf8bd420402cbb543f994e054}
Sets pointer to list of active threads. 


\begin{DoxyCode}
195 {
196     activeThreads = at_ptr;
197 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_a21f95db13a2fc05d7a5fcc43fec1f1e7}{
\index{DefaultDecode@{DefaultDecode}!setDecodeQueue@{setDecodeQueue}}
\index{setDecodeQueue@{setDecodeQueue}!DefaultDecode@{DefaultDecode}}
\subsubsection[{setDecodeQueue}]{\setlength{\rightskip}{0pt plus 5cm}void setDecodeQueue ({\bf TimeBuffer}$<$ {\bf DecodeStruct} $>$ $\ast$ {\em dq\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultDecode_a21f95db13a2fc05d7a5fcc43fec1f1e7}
Sets pointer to time buffer used to communicate to the next stage. 


\begin{DoxyCode}
175 {
176     decodeQueue = dq_ptr;
177 
178     // Setup wire to write information to proper place in decode queue.
179     toRename = decodeQueue->getWire(0);
180 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_ad1be90519aa7737ddf8e41de079a5ea9}{
\index{DefaultDecode@{DefaultDecode}!setFetchQueue@{setFetchQueue}}
\index{setFetchQueue@{setFetchQueue}!DefaultDecode@{DefaultDecode}}
\subsubsection[{setFetchQueue}]{\setlength{\rightskip}{0pt plus 5cm}void setFetchQueue ({\bf TimeBuffer}$<$ {\bf FetchStruct} $>$ $\ast$ {\em fq\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultDecode_ad1be90519aa7737ddf8e41de079a5ea9}
Sets pointer to time buffer coming from fetch. 


\begin{DoxyCode}
185 {
186     fetchQueue = fq_ptr;
187 
188     // Setup wire to read information from fetch queue.
189     fromFetch = fetchQueue->getWire(-fetchToDecodeDelay);
190 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_a2b521ea5f191fff72265f60d4ed5187b}{
\index{DefaultDecode@{DefaultDecode}!setTimeBuffer@{setTimeBuffer}}
\index{setTimeBuffer@{setTimeBuffer}!DefaultDecode@{DefaultDecode}}
\subsubsection[{setTimeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}void setTimeBuffer ({\bf TimeBuffer}$<$ {\bf TimeStruct} $>$ $\ast$ {\em tb\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultDecode_a2b521ea5f191fff72265f60d4ed5187b}
Sets the main backwards communication time buffer pointer. 


\begin{DoxyCode}
160 {
161     timeBuffer = tb_ptr;
162 
163     // Setup wire to write information back to fetch.
164     toFetch = timeBuffer->getWire(0);
165 
166     // Create wires to get information from proper places in time buffer.
167     fromRename = timeBuffer->getWire(-renameToDecodeDelay);
168     fromIEW = timeBuffer->getWire(-iewToDecodeDelay);
169     fromCommit = timeBuffer->getWire(-commitToDecodeDelay);
170 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_ac24515147270ef9b85991bbe13bd47af}{
\index{DefaultDecode@{DefaultDecode}!skidInsert@{skidInsert}}
\index{skidInsert@{skidInsert}!DefaultDecode@{DefaultDecode}}
\subsubsection[{skidInsert}]{\setlength{\rightskip}{0pt plus 5cm}void skidInsert ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultDecode_ac24515147270ef9b85991bbe13bd47af}
Inserts a thread's instructions into the skid buffer, to be decoded once decode unblocks. 


\begin{DoxyCode}
388 {
389     DynInstPtr inst = NULL;
390 
391     while (!insts[tid].empty()) {
392         inst = insts[tid].front();
393 
394         insts[tid].pop();
395 
396         assert(tid == inst->threadNumber);
397 
398         DPRINTF(Decode,"Inserting [sn:%lli] PC: %s into decode skidBuffer %i\n",
399                 inst->seqNum, inst->pcState(), inst->threadNumber);
400 
401         skidBuffer[tid].push(inst);
402     }
403 
404     // @todo: Eventually need to enforce this by not letting a thread
405     // fetch past its skidbuffer
406     assert(skidBuffer[tid].size() <= skidBufferMax);
407 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_afe3e2673d17dd5c568862ef5ae68b4d8}{
\index{DefaultDecode@{DefaultDecode}!skidsEmpty@{skidsEmpty}}
\index{skidsEmpty@{skidsEmpty}!DefaultDecode@{DefaultDecode}}
\subsubsection[{skidsEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool skidsEmpty ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultDecode_afe3e2673d17dd5c568862ef5ae68b4d8}
Returns if all of the skid buffers are empty. 


\begin{DoxyCode}
412 {
413     list<ThreadID>::iterator threads = activeThreads->begin();
414     list<ThreadID>::iterator end = activeThreads->end();
415 
416     while (threads != end) {
417         ThreadID tid = *threads++;
418         if (!skidBuffer[tid].empty())
419             return false;
420     }
421 
422     return true;
423 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_a9ff2aa32ab0f40674cb3518108d62f8e}{
\index{DefaultDecode@{DefaultDecode}!sortInsts@{sortInsts}}
\index{sortInsts@{sortInsts}!DefaultDecode@{DefaultDecode}}
\subsubsection[{sortInsts}]{\setlength{\rightskip}{0pt plus 5cm}void sortInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultDecode_a9ff2aa32ab0f40674cb3518108d62f8e}
Separates instructions from fetch into individual lists of instructions sorted by thread. 


\begin{DoxyCode}
467 {
468     int insts_from_fetch = fromFetch->size;
469     for (int i = 0; i < insts_from_fetch; ++i) {
470         insts[fromFetch->insts[i]->threadNumber].push(fromFetch->insts[i]);
471     }
472 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_a44313b71f53a0366212ed600d2d0b11d}{
\index{DefaultDecode@{DefaultDecode}!squash@{squash}}
\index{squash@{squash}!DefaultDecode@{DefaultDecode}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}unsigned squash ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultDecode_a44313b71f53a0366212ed600d2d0b11d}
Squashes due to commit signalling a squash. Changes status to squashing and clears block/unblock signals as needed. 


\begin{DoxyCode}
340 {
341     DPRINTF(Decode, "[tid:%i]: Squashing.\n",tid);
342 
343     if (decodeStatus[tid] == Blocked ||
344         decodeStatus[tid] == Unblocking) {
345         if (FullSystem) {
346             toFetch->decodeUnblock[tid] = 1;
347         } else {
348             // In syscall emulation, we can have both a block and a squash due
349             // to a syscall in the same cycle.  This would cause both signals
350             // to be high.  This shouldn't happen in full system.
351             // @todo: Determine if this still happens.
352             if (toFetch->decodeBlock[tid])
353                 toFetch->decodeBlock[tid] = 0;
354             else
355                 toFetch->decodeUnblock[tid] = 1;
356         }
357     }
358 
359     // Set status to squashing.
360     decodeStatus[tid] = Squashing;
361 
362     // Go through incoming instructions from fetch and squash them.
363     unsigned squash_count = 0;
364 
365     for (int i=0; i<fromFetch->size; i++) {
366         if (fromFetch->insts[i]->threadNumber == tid) {
367             fromFetch->insts[i]->setSquashed();
368             squash_count++;
369         }
370     }
371 
372     // Clear the instruction list and skid buffer in case they have any
373     // insts in them.
374     while (!insts[tid].empty()) {
375         insts[tid].pop();
376     }
377 
378     while (!skidBuffer[tid].empty()) {
379         skidBuffer[tid].pop();
380     }
381 
382     return squash_count;
383 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_a80c82399ba102a2f35e863ee05d2e9dd}{
\index{DefaultDecode@{DefaultDecode}!squash@{squash}}
\index{squash@{squash}!DefaultDecode@{DefaultDecode}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash ({\bf DynInstPtr} \& {\em inst}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultDecode_a80c82399ba102a2f35e863ee05d2e9dd}
Squashes if there is a PC-\/relative branch that was predicted incorrectly. Sends squash information back to fetch. 


\begin{DoxyCode}
288 {
289     DPRINTF(Decode, "[tid:%i]: [sn:%i] Squashing due to incorrect branch "
290             "prediction detected at decode.\n", tid, inst->seqNum);
291 
292     // Send back mispredict information.
293     toFetch->decodeInfo[tid].branchMispredict = true;
294     toFetch->decodeInfo[tid].predIncorrect = true;
295     toFetch->decodeInfo[tid].mispredictInst = inst;
296     toFetch->decodeInfo[tid].squash = true;
297     toFetch->decodeInfo[tid].doneSeqNum = inst->seqNum;
298     toFetch->decodeInfo[tid].nextPC = inst->branchTarget();
299     toFetch->decodeInfo[tid].branchTaken = inst->pcState().branching();
300     toFetch->decodeInfo[tid].squashInst = inst;
301     if (toFetch->decodeInfo[tid].mispredictInst->isUncondCtrl()) {
302             toFetch->decodeInfo[tid].branchTaken = true;
303     }
304 
305     InstSeqNum squash_seq_num = inst->seqNum;
306 
307     // Might have to tell fetch to unblock.
308     if (decodeStatus[tid] == Blocked ||
309         decodeStatus[tid] == Unblocking) {
310         toFetch->decodeUnblock[tid] = 1;
311     }
312 
313     // Set status to squashing.
314     decodeStatus[tid] = Squashing;
315 
316     for (int i=0; i<fromFetch->size; i++) {
317         if (fromFetch->insts[i]->threadNumber == tid &&
318             fromFetch->insts[i]->seqNum > squash_seq_num) {
319             fromFetch->insts[i]->setSquashed();
320         }
321     }
322 
323     // Clear the instruction list and skid buffer in case they have any
324     // insts in them.
325     while (!insts[tid].empty()) {
326         insts[tid].pop();
327     }
328 
329     while (!skidBuffer[tid].empty()) {
330         skidBuffer[tid].pop();
331     }
332 
333     // Squash instructions up until this one
334     cpu->removeInstsUntil(squash_seq_num, tid);
335 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_a31d4cbdab16d4ff8d6bc7f84ece727da}{
\index{DefaultDecode@{DefaultDecode}!startupStage@{startupStage}}
\index{startupStage@{startupStage}!DefaultDecode@{DefaultDecode}}
\subsubsection[{startupStage}]{\setlength{\rightskip}{0pt plus 5cm}void startupStage ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultDecode_a31d4cbdab16d4ff8d6bc7f84ece727da}



\begin{DoxyCode}
83 {
84     resetStage();
85 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_a8674059ce345e23aac5086b2c3e24a43}{
\index{DefaultDecode@{DefaultDecode}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!DefaultDecode@{DefaultDecode}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultDecode_a8674059ce345e23aac5086b2c3e24a43}
Takes over from another CPU's thread. 


\begin{DoxyCode}
132 { resetStage(); }
\end{DoxyCode}
\hypertarget{classDefaultDecode_a873dd91783f9efb4a590aded1f70d6b0}{
\index{DefaultDecode@{DefaultDecode}!tick@{tick}}
\index{tick@{tick}!DefaultDecode@{DefaultDecode}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultDecode_a873dd91783f9efb4a590aded1f70d6b0}
Ticks decode, processing all input signals and decoding as many instructions as possible. 


\begin{DoxyCode}
576 {
577     wroteToTimeBuffer = false;
578 
579     bool status_change = false;
580 
581     toRenameIndex = 0;
582 
583     list<ThreadID>::iterator threads = activeThreads->begin();
584     list<ThreadID>::iterator end = activeThreads->end();
585 
586     sortInsts();
587 
588     //Check stall and squash signals.
589     while (threads != end) {
590         ThreadID tid = *threads++;
591 
592         DPRINTF(Decode,"Processing [tid:%i]\n",tid);
593         status_change =  checkSignalsAndUpdate(tid) || status_change;
594 
595         decode(status_change, tid);
596     }
597 
598     if (status_change) {
599         updateStatus();
600     }
601 
602     if (wroteToTimeBuffer) {
603         DPRINTF(Activity, "Activity this cycle.\n");
604 
605         cpu->activityThisCycle();
606     }
607 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_a9cc3b95f6969935f78c0158aa5145021}{
\index{DefaultDecode@{DefaultDecode}!unblock@{unblock}}
\index{unblock@{unblock}!DefaultDecode@{DefaultDecode}}
\subsubsection[{unblock}]{\setlength{\rightskip}{0pt plus 5cm}bool unblock ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultDecode_a9cc3b95f6969935f78c0158aa5145021}
Switches decode to unblocking if the skid buffer is empty, and signals back that decode has unblocked. \begin{DoxyReturn}{戻り値}
Returns true if there is a status change. 
\end{DoxyReturn}



\begin{DoxyCode}
269 {
270     // Decode is done unblocking only if the skid buffer is empty.
271     if (skidBuffer[tid].empty()) {
272         DPRINTF(Decode, "[tid:%u]: Done unblocking.\n", tid);
273         toFetch->decodeUnblock[tid] = true;
274         wroteToTimeBuffer = true;
275 
276         decodeStatus[tid] = Running;
277         return true;
278     }
279 
280     DPRINTF(Decode, "[tid:%u]: Currently unblocking.\n", tid);
281 
282     return false;
283 }
\end{DoxyCode}
\hypertarget{classDefaultDecode_a4bb9486757ce225941aaaf759b357a57}{
\index{DefaultDecode@{DefaultDecode}!updateStatus@{updateStatus}}
\index{updateStatus@{updateStatus}!DefaultDecode@{DefaultDecode}}
\subsubsection[{updateStatus}]{\setlength{\rightskip}{0pt plus 5cm}void updateStatus ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultDecode_a4bb9486757ce225941aaaf759b357a57}
Updates overall decode status based on all of the threads' statuses. 


\begin{DoxyCode}
428 {
429     bool any_unblocking = false;
430 
431     list<ThreadID>::iterator threads = activeThreads->begin();
432     list<ThreadID>::iterator end = activeThreads->end();
433 
434     while (threads != end) {
435         ThreadID tid = *threads++;
436 
437         if (decodeStatus[tid] == Unblocking) {
438             any_unblocking = true;
439             break;
440         }
441     }
442 
443     // Decode will have activity if it's unblocking.
444     if (any_unblocking) {
445         if (_status == Inactive) {
446             _status = Active;
447 
448             DPRINTF(Activity, "Activating stage.\n");
449 
450             cpu->activateStage(O3CPU::DecodeIdx);
451         }
452     } else {
453         // If it's not unblocking, then decode will not have any internal
454         // activity.  Switch it to inactive.
455         if (_status == Active) {
456             _status = Inactive;
457             DPRINTF(Activity, "Deactivating stage.\n");
458 
459             cpu->deactivateStage(O3CPU::DecodeIdx);
460         }
461     }
462 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classDefaultDecode_a69375c9c0bc115c0f1a90b7967abfa6a}{
\index{DefaultDecode@{DefaultDecode}!\_\-status@{\_\-status}}
\index{\_\-status@{\_\-status}!DefaultDecode@{DefaultDecode}}
\subsubsection[{\_\-status}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DecodeStatus} {\bf \_\-status}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a69375c9c0bc115c0f1a90b7967abfa6a}
Decode status. \hypertarget{classDefaultDecode_af6eaea53db532812052f71bf0380dab5}{
\index{DefaultDecode@{DefaultDecode}!activeThreads@{activeThreads}}
\index{activeThreads@{activeThreads}!DefaultDecode@{DefaultDecode}}
\subsubsection[{activeThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf ThreadID}$>$$\ast$ {\bf activeThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_af6eaea53db532812052f71bf0380dab5}
List of active thread ids \hypertarget{classDefaultDecode_aa7e5b323025273d40b8cba03150ebaee}{
\index{DefaultDecode@{DefaultDecode}!bdelayDoneSeqNum@{bdelayDoneSeqNum}}
\index{bdelayDoneSeqNum@{bdelayDoneSeqNum}!DefaultDecode@{DefaultDecode}}
\subsubsection[{bdelayDoneSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf bdelayDoneSeqNum}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_aa7e5b323025273d40b8cba03150ebaee}
SeqNum of Squashing Branch Delay Instruction (used for MIPS) \hypertarget{classDefaultDecode_a77f4b17f2ef6c226e894d648ee743fae}{
\index{DefaultDecode@{DefaultDecode}!commitToDecodeDelay@{commitToDecodeDelay}}
\index{commitToDecodeDelay@{commitToDecodeDelay}!DefaultDecode@{DefaultDecode}}
\subsubsection[{commitToDecodeDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf commitToDecodeDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a77f4b17f2ef6c226e894d648ee743fae}
Commit to decode delay. \hypertarget{classDefaultDecode_a1379cf882a12ac6fc9eba5da7c84b18b}{
\index{DefaultDecode@{DefaultDecode}!cpu@{cpu}}
\index{cpu@{cpu}!DefaultDecode@{DefaultDecode}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf O3CPU}$\ast$ {\bf cpu}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a1379cf882a12ac6fc9eba5da7c84b18b}
CPU interface. \hypertarget{classDefaultDecode_aa61ef46bfb5ece8742ca0ba35c596f7f}{
\index{DefaultDecode@{DefaultDecode}!decodeBlockedCycles@{decodeBlockedCycles}}
\index{decodeBlockedCycles@{decodeBlockedCycles}!DefaultDecode@{DefaultDecode}}
\subsubsection[{decodeBlockedCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf decodeBlockedCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_aa61ef46bfb5ece8742ca0ba35c596f7f}
Stat for total number of blocked cycles. \hypertarget{classDefaultDecode_ac82a9e3870dbcc3d3c3a331634bf81af}{
\index{DefaultDecode@{DefaultDecode}!decodeBranchMispred@{decodeBranchMispred}}
\index{decodeBranchMispred@{decodeBranchMispred}!DefaultDecode@{DefaultDecode}}
\subsubsection[{decodeBranchMispred}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf decodeBranchMispred}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_ac82a9e3870dbcc3d3c3a331634bf81af}
Stat for number of times a branch mispredict is detected. \hypertarget{classDefaultDecode_a85271ddee50df718b95448a65de49f4f}{
\index{DefaultDecode@{DefaultDecode}!decodeBranchResolved@{decodeBranchResolved}}
\index{decodeBranchResolved@{decodeBranchResolved}!DefaultDecode@{DefaultDecode}}
\subsubsection[{decodeBranchResolved}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf decodeBranchResolved}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a85271ddee50df718b95448a65de49f4f}
Stat for number of times a branch is resolved at decode. \hypertarget{classDefaultDecode_ac6135ce194bbd50f851f71e0e6049464}{
\index{DefaultDecode@{DefaultDecode}!decodeControlMispred@{decodeControlMispred}}
\index{decodeControlMispred@{decodeControlMispred}!DefaultDecode@{DefaultDecode}}
\subsubsection[{decodeControlMispred}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf decodeControlMispred}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_ac6135ce194bbd50f851f71e0e6049464}
Stat for number of times decode detected a non-\/control instruction incorrectly predicted as a branch. \hypertarget{classDefaultDecode_a2ac1cd5e0cbce47426a97fba4bb966dc}{
\index{DefaultDecode@{DefaultDecode}!decodeDecodedInsts@{decodeDecodedInsts}}
\index{decodeDecodedInsts@{decodeDecodedInsts}!DefaultDecode@{DefaultDecode}}
\subsubsection[{decodeDecodedInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf decodeDecodedInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a2ac1cd5e0cbce47426a97fba4bb966dc}
Stat for total number of decoded instructions. \hypertarget{classDefaultDecode_a1037bebd5ca3880affa4633d03176747}{
\index{DefaultDecode@{DefaultDecode}!decodeIdleCycles@{decodeIdleCycles}}
\index{decodeIdleCycles@{decodeIdleCycles}!DefaultDecode@{DefaultDecode}}
\subsubsection[{decodeIdleCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf decodeIdleCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a1037bebd5ca3880affa4633d03176747}
Stat for total number of idle cycles. \hypertarget{classDefaultDecode_a7860fc5736574343c9e294cb2bef9d93}{
\index{DefaultDecode@{DefaultDecode}!decodeQueue@{decodeQueue}}
\index{decodeQueue@{decodeQueue}!DefaultDecode@{DefaultDecode}}
\subsubsection[{decodeQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf DecodeStruct}$>$$\ast$ {\bf decodeQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a7860fc5736574343c9e294cb2bef9d93}
Decode instruction queue. \hypertarget{classDefaultDecode_af217607d5162d70e22d1892d3b7f041d}{
\index{DefaultDecode@{DefaultDecode}!decodeRunCycles@{decodeRunCycles}}
\index{decodeRunCycles@{decodeRunCycles}!DefaultDecode@{DefaultDecode}}
\subsubsection[{decodeRunCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf decodeRunCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_af217607d5162d70e22d1892d3b7f041d}
Stat for total number of normal running cycles. \hypertarget{classDefaultDecode_aac9ee4c2600bd9d9915595c7008652ba}{
\index{DefaultDecode@{DefaultDecode}!decodeSquashCycles@{decodeSquashCycles}}
\index{decodeSquashCycles@{decodeSquashCycles}!DefaultDecode@{DefaultDecode}}
\subsubsection[{decodeSquashCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf decodeSquashCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_aac9ee4c2600bd9d9915595c7008652ba}
Stat for total number of squashing cycles. \hypertarget{classDefaultDecode_a7bd44f968f6e156e212a8c275066ec40}{
\index{DefaultDecode@{DefaultDecode}!decodeSquashedInsts@{decodeSquashedInsts}}
\index{decodeSquashedInsts@{decodeSquashedInsts}!DefaultDecode@{DefaultDecode}}
\subsubsection[{decodeSquashedInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf decodeSquashedInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a7bd44f968f6e156e212a8c275066ec40}
Stat for total number of squashed instructions. \hypertarget{classDefaultDecode_a1d8482258ad490dd3485ac43d127ce4d}{
\index{DefaultDecode@{DefaultDecode}!decodeStatus@{decodeStatus}}
\index{decodeStatus@{decodeStatus}!DefaultDecode@{DefaultDecode}}
\subsubsection[{decodeStatus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadStatus} {\bf decodeStatus}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a1d8482258ad490dd3485ac43d127ce4d}
Per-\/thread status. \hypertarget{classDefaultDecode_a99328fc971ae507d591e100b90615c8b}{
\index{DefaultDecode@{DefaultDecode}!decodeUnblockCycles@{decodeUnblockCycles}}
\index{decodeUnblockCycles@{decodeUnblockCycles}!DefaultDecode@{DefaultDecode}}
\subsubsection[{decodeUnblockCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf decodeUnblockCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a99328fc971ae507d591e100b90615c8b}
Stat for total number of unblocking cycles. \hypertarget{classDefaultDecode_aecf92f13590eed742e3064a4fdb5e004}{
\index{DefaultDecode@{DefaultDecode}!decodeWidth@{decodeWidth}}
\index{decodeWidth@{decodeWidth}!DefaultDecode@{DefaultDecode}}
\subsubsection[{decodeWidth}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf decodeWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_aecf92f13590eed742e3064a4fdb5e004}
The width of decode, in instructions. \hypertarget{classDefaultDecode_a9a2f350be647ebfb6567172812db491a}{
\index{DefaultDecode@{DefaultDecode}!fetchQueue@{fetchQueue}}
\index{fetchQueue@{fetchQueue}!DefaultDecode@{DefaultDecode}}
\subsubsection[{fetchQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf FetchStruct}$>$$\ast$ {\bf fetchQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a9a2f350be647ebfb6567172812db491a}
Fetch instruction queue interface. \hypertarget{classDefaultDecode_a689484c3554224a1c1c676e9dde3f653}{
\index{DefaultDecode@{DefaultDecode}!fetchToDecodeDelay@{fetchToDecodeDelay}}
\index{fetchToDecodeDelay@{fetchToDecodeDelay}!DefaultDecode@{DefaultDecode}}
\subsubsection[{fetchToDecodeDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf fetchToDecodeDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a689484c3554224a1c1c676e9dde3f653}
Fetch to decode delay. \hypertarget{classDefaultDecode_a0055a92bd94eda21c2641d46ff013dac}{
\index{DefaultDecode@{DefaultDecode}!fromCommit@{fromCommit}}
\index{fromCommit@{fromCommit}!DefaultDecode@{DefaultDecode}}
\subsubsection[{fromCommit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf fromCommit}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a0055a92bd94eda21c2641d46ff013dac}
\hyperlink{classWire}{Wire} to get commit's information from backwards time buffer. \hypertarget{classDefaultDecode_a2e3dd009c447d077f19b303b53b52fab}{
\index{DefaultDecode@{DefaultDecode}!fromFetch@{fromFetch}}
\index{fromFetch@{fromFetch}!DefaultDecode@{DefaultDecode}}
\subsubsection[{fromFetch}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf FetchStruct}$>$::wire {\bf fromFetch}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a2e3dd009c447d077f19b303b53b52fab}
\hyperlink{classWire}{Wire} to get fetch's output from fetch queue. \hypertarget{classDefaultDecode_a6c9093e88770a58dc8853f49a09bbac8}{
\index{DefaultDecode@{DefaultDecode}!fromIEW@{fromIEW}}
\index{fromIEW@{fromIEW}!DefaultDecode@{DefaultDecode}}
\subsubsection[{fromIEW}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf fromIEW}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a6c9093e88770a58dc8853f49a09bbac8}
\hyperlink{classWire}{Wire} to get iew's information from backwards time buffer. \hypertarget{classDefaultDecode_ae99c54a9c8f1e218b86afcee348c54fc}{
\index{DefaultDecode@{DefaultDecode}!fromRename@{fromRename}}
\index{fromRename@{fromRename}!DefaultDecode@{DefaultDecode}}
\subsubsection[{fromRename}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf fromRename}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_ae99c54a9c8f1e218b86afcee348c54fc}
\hyperlink{classWire}{Wire} to get rename's output from backwards time buffer. \hypertarget{classDefaultDecode_ac7ece3c345b9ce038d4b7726da7c9b41}{
\index{DefaultDecode@{DefaultDecode}!iewToDecodeDelay@{iewToDecodeDelay}}
\index{iewToDecodeDelay@{iewToDecodeDelay}!DefaultDecode@{DefaultDecode}}
\subsubsection[{iewToDecodeDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf iewToDecodeDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_ac7ece3c345b9ce038d4b7726da7c9b41}
IEW to decode delay. \hypertarget{classDefaultDecode_a1b0ce60f9b6c662a2f3df87a3e8b50f8}{
\index{DefaultDecode@{DefaultDecode}!insts@{insts}}
\index{insts@{insts}!DefaultDecode@{DefaultDecode}}
\subsubsection[{insts}]{\setlength{\rightskip}{0pt plus 5cm}std::queue$<${\bf DynInstPtr}$>$ {\bf insts}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a1b0ce60f9b6c662a2f3df87a3e8b50f8}
Queue of all instructions coming from fetch this cycle. \hypertarget{classDefaultDecode_a88377f855dbf5adeeecb06b5bb821d35}{
\index{DefaultDecode@{DefaultDecode}!numThreads@{numThreads}}
\index{numThreads@{numThreads}!DefaultDecode@{DefaultDecode}}
\subsubsection[{numThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} {\bf numThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a88377f855dbf5adeeecb06b5bb821d35}
number of Active Threads \hypertarget{classDefaultDecode_a3b9933c4d891d5618e6a103f0c231e8c}{
\index{DefaultDecode@{DefaultDecode}!renameToDecodeDelay@{renameToDecodeDelay}}
\index{renameToDecodeDelay@{renameToDecodeDelay}!DefaultDecode@{DefaultDecode}}
\subsubsection[{renameToDecodeDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf renameToDecodeDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a3b9933c4d891d5618e6a103f0c231e8c}
Rename to decode delay. \hypertarget{classDefaultDecode_a911bfd7c5c1efbd9f479d2b960078ec1}{
\index{DefaultDecode@{DefaultDecode}!skidBuffer@{skidBuffer}}
\index{skidBuffer@{skidBuffer}!DefaultDecode@{DefaultDecode}}
\subsubsection[{skidBuffer}]{\setlength{\rightskip}{0pt plus 5cm}std::queue$<${\bf DynInstPtr}$>$ {\bf skidBuffer}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a911bfd7c5c1efbd9f479d2b960078ec1}
Skid buffer between fetch and decode. \hypertarget{classDefaultDecode_a268414a6444b620140f263013a739a17}{
\index{DefaultDecode@{DefaultDecode}!skidBufferMax@{skidBufferMax}}
\index{skidBufferMax@{skidBufferMax}!DefaultDecode@{DefaultDecode}}
\subsubsection[{skidBufferMax}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf skidBufferMax}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a268414a6444b620140f263013a739a17}
Maximum size of the skid buffer. \hypertarget{classDefaultDecode_ab0db2d75f6bf41c785017f8c3af9c16b}{
\index{DefaultDecode@{DefaultDecode}!squashAfterDelaySlot@{squashAfterDelaySlot}}
\index{squashAfterDelaySlot@{squashAfterDelaySlot}!DefaultDecode@{DefaultDecode}}
\subsubsection[{squashAfterDelaySlot}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf squashAfterDelaySlot}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_ab0db2d75f6bf41c785017f8c3af9c16b}
Tells when their is a pending delay slot inst. to send to rename. If there is, then wait squash after the next instruction (used for MIPS). \hypertarget{classDefaultDecode_ab16bbdee47d26fedf584262248b6b6e4}{
\index{DefaultDecode@{DefaultDecode}!squashInst@{squashInst}}
\index{squashInst@{squashInst}!DefaultDecode@{DefaultDecode}}
\subsubsection[{squashInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf squashInst}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_ab16bbdee47d26fedf584262248b6b6e4}
Instruction used for squashing branch (used for MIPS) \hypertarget{classDefaultDecode_ade48cf321f5741ea8e54e071680cacdc}{
\index{DefaultDecode@{DefaultDecode}!stalls@{stalls}}
\index{stalls@{stalls}!DefaultDecode@{DefaultDecode}}
\subsubsection[{stalls}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stalls} {\bf stalls}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_ade48cf321f5741ea8e54e071680cacdc}
Tracks which stages are telling decode to stall. \hypertarget{classDefaultDecode_a83f9ee976e732665aeb08dbc19acfd45}{
\index{DefaultDecode@{DefaultDecode}!timeBuffer@{timeBuffer}}
\index{timeBuffer@{timeBuffer}!DefaultDecode@{DefaultDecode}}
\subsubsection[{timeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$$\ast$ {\bf timeBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a83f9ee976e732665aeb08dbc19acfd45}
\hyperlink{classTime}{Time} buffer interface. \hypertarget{classDefaultDecode_acc94cfae2a67b5dbb0e74e81c24a3b6e}{
\index{DefaultDecode@{DefaultDecode}!toFetch@{toFetch}}
\index{toFetch@{toFetch}!DefaultDecode@{DefaultDecode}}
\subsubsection[{toFetch}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf toFetch}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_acc94cfae2a67b5dbb0e74e81c24a3b6e}
\hyperlink{classWire}{Wire} to write information heading to previous stages. \hypertarget{classDefaultDecode_ac096c67e7877c089a5417aa83a721edc}{
\index{DefaultDecode@{DefaultDecode}!toRename@{toRename}}
\index{toRename@{toRename}!DefaultDecode@{DefaultDecode}}
\subsubsection[{toRename}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf DecodeStruct}$>$::wire {\bf toRename}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_ac096c67e7877c089a5417aa83a721edc}
\hyperlink{classWire}{Wire} used to write any information heading to rename. \hypertarget{classDefaultDecode_a998ac27e2d5479a5c6e97258d25cea3d}{
\index{DefaultDecode@{DefaultDecode}!toRenameIndex@{toRenameIndex}}
\index{toRenameIndex@{toRenameIndex}!DefaultDecode@{DefaultDecode}}
\subsubsection[{toRenameIndex}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf toRenameIndex}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a998ac27e2d5479a5c6e97258d25cea3d}
Index of instructions being sent to rename. \hypertarget{classDefaultDecode_a2c7e870d4babdac0dc91fc7ffabd0f3d}{
\index{DefaultDecode@{DefaultDecode}!wroteToTimeBuffer@{wroteToTimeBuffer}}
\index{wroteToTimeBuffer@{wroteToTimeBuffer}!DefaultDecode@{DefaultDecode}}
\subsubsection[{wroteToTimeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf wroteToTimeBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultDecode_a2c7e870d4babdac0dc91fc7ffabd0f3d}
Variable that tracks if decode has written to the time buffer this cycle. Used to tell CPU if there is activity this cycle. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/o3/\hyperlink{decode_8hh}{decode.hh}\item 
cpu/o3/\hyperlink{decode__impl_8hh}{decode\_\-impl.hh}\end{DoxyCompactItemize}
