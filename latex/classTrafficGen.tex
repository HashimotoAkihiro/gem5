\hypertarget{classTrafficGen}{
\section{クラス TrafficGen}
\label{classTrafficGen}\index{TrafficGen@{TrafficGen}}
}


{\ttfamily \#include $<$traffic\_\-gen.hh$>$}TrafficGenに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=5cm]{classTrafficGen}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classTrafficGen_1_1TrafficGen}{TrafficGen}
\item 
class \hyperlink{classTrafficGen_1_1TrafficGenPort}{TrafficGenPort}
\item 
struct \hyperlink{structTrafficGen_1_1Transition}{Transition}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classTrafficGen_a146890cf5f9e59c2f8c33edfb1502488}{TrafficGen} (const TrafficGenParams $\ast$p)
\item 
\hyperlink{classTrafficGen_a5667988c9607ce8d7e3eabd0ebe860f6}{$\sim$TrafficGen} ()
\item 
virtual \hyperlink{classBaseMasterPort}{BaseMasterPort} \& \hyperlink{classTrafficGen_a54ebb5edc195c159b56a39e6f15b9932}{getMasterPort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
void \hyperlink{classTrafficGen_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
void \hyperlink{classTrafficGen_a3c34ea9b29f410748d4435a667484924}{initState} ()
\item 
unsigned int \hyperlink{classTrafficGen_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)
\item 
void \hyperlink{classTrafficGen_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
void \hyperlink{classTrafficGen_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\item 
void \hyperlink{classTrafficGen_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classTrafficGen_aab0a81b788e7282586c12953fa5e0c37}{transition} ()
\item 
void \hyperlink{classTrafficGen_a1346cf8b75d4ba67a861233a8651601d}{enterState} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} newState)
\item 
void \hyperlink{classTrafficGen_a7719d247662a43429aac025090db5704}{parseConfig} ()
\item 
void \hyperlink{classTrafficGen_ac5c54df7ed3b930268c8d7752c101725}{update} ()
\item 
void \hyperlink{classTrafficGen_a29cb5a4f98063ce6e9210eacbdb35298}{recvRetry} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSystem}{System} $\ast$ \hyperlink{classTrafficGen_af27ccd765f13a4b7bd119dc7579e2746}{system}
\item 
\hyperlink{request_8hh_ac366b729262fd8e7cbd3283da6f775cf}{MasterID} \hyperlink{classTrafficGen_aa8528db52f6eb976baecb2291d1b408a}{masterID}
\item 
const std::string \hyperlink{classTrafficGen_ad5835f1d2646493dafb2c5ac6244a93f}{configFile}
\item 
const bool \hyperlink{classTrafficGen_a42af28607a09ff1b95b5e848bf73f915}{elasticReq}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classTrafficGen_aaa2a440da39850c0d2d678fd2ee844af}{nextTransitionTick}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classTrafficGen_a52d98e2f5ed0bf508db823995ad4940f}{nextPacketTick}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classstd_1_1vector}{std::vector}$<$ double $>$ $>$ \hyperlink{classTrafficGen_a14f30e68ecada24867b46bcc8093f4f5}{transitionMatrix}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classTrafficGen_a8428fe009627d1dd49ef98a54587830e}{currState}
\item 
m5::hash\_\-map$<$ \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t}, \hyperlink{classBaseGen}{BaseGen} $\ast$ $>$ \hyperlink{classTrafficGen_a033c23b252da5264e1f864277711e5e1}{states}
\item 
\hyperlink{classTrafficGen_1_1TrafficGenPort}{TrafficGenPort} \hyperlink{classTrafficGen_a51d5c08451d2b2b8b99fe3fda83f05d8}{port}
\item 
\hyperlink{classPacket}{PacketPtr} \hyperlink{classTrafficGen_a314ae93c04b3ca96e79e1b1f39a8e478}{retryPkt}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classTrafficGen_a770dcab4388a8d55911cb6f29d9bb692}{retryPktTick}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classTrafficGen_1_1TrafficGen}{TrafficGen},\&TrafficGen::update $>$ \hyperlink{classTrafficGen_ab779474477fa217dd5483711dec2bf13}{updateEvent}
\item 
\hyperlink{classDrainManager}{DrainManager} $\ast$ \hyperlink{classTrafficGen_a329b71fb934a93312ca0aacbf5a3f982}{drainManager}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classTrafficGen_a5ffd7b0e5641784cc4c40547e51c6cbc}{numPackets}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classTrafficGen_a166f92adc8967f926459ca64c92d6a66}{numRetries}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classTrafficGen_a2d1dee1e20aeb0205ae665d7ad08b822}{retryTicks}
\end{DoxyCompactItemize}


\subsection{説明}
The traffic generator is a master module that generates stimuli for the memory system, based on a collection of simple generator behaviours that are either probabilistic or based on traces. It can be used stand alone for creating test cases for interconnect and memory controllers, or function as a black box replacement for system components that are not yet modelled in detail, e.g. a video engine or baseband subsystem. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classTrafficGen_a146890cf5f9e59c2f8c33edfb1502488}{
\index{TrafficGen@{TrafficGen}!TrafficGen@{TrafficGen}}
\index{TrafficGen@{TrafficGen}!TrafficGen@{TrafficGen}}
\subsubsection[{TrafficGen}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TrafficGen} (const TrafficGenParams $\ast$ {\em p})}}
\label{classTrafficGen_a146890cf5f9e59c2f8c33edfb1502488}



\begin{DoxyCode}
55     : MemObject(p),
56       system(p->system),
57       masterID(system->getMasterId(name())),
58       configFile(p->config_file),
59       elasticReq(p->elastic_req),
60       nextTransitionTick(0),
61       nextPacketTick(0),
62       port(name() + ".port", *this),
63       retryPkt(NULL),
64       retryPktTick(0),
65       updateEvent(this),
66       drainManager(NULL)
67 {
68 }
\end{DoxyCode}
\hypertarget{classTrafficGen_a5667988c9607ce8d7e3eabd0ebe860f6}{
\index{TrafficGen@{TrafficGen}!$\sim$TrafficGen@{$\sim$TrafficGen}}
\index{$\sim$TrafficGen@{$\sim$TrafficGen}!TrafficGen@{TrafficGen}}
\subsubsection[{$\sim$TrafficGen}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf TrafficGen} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classTrafficGen_a5667988c9607ce8d7e3eabd0ebe860f6}



\begin{DoxyCode}
189 {}
\end{DoxyCode}


\subsection{関数}
\hypertarget{classTrafficGen_aa8a18d230dba7a674ac8a0b4f35bc36a}{
\index{TrafficGen@{TrafficGen}!drain@{drain}}
\index{drain@{drain}!TrafficGen@{TrafficGen}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em drainManger})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTrafficGen_aa8a18d230dba7a674ac8a0b4f35bc36a}
Provide a default implementation of the drain interface that simply returns 0 (draining completed) and sets the drain state to Drained. 

\hyperlink{classSimObject_a6bf479c521c7c3eb473822d953275b26}{SimObject}を再定義しています。


\begin{DoxyCode}
122 {
123     if (!updateEvent.scheduled()) {
124         // no event has been scheduled yet (e.g. switched from atomic mode)
125         return 0;
126     }
127 
128     if (retryPkt == NULL) {
129         // shut things down
130         nextPacketTick = MaxTick;
131         nextTransitionTick = MaxTick;
132         deschedule(updateEvent);
133         return 0;
134     } else {
135         drainManager = dm;
136         return 1;
137     }
138 }
\end{DoxyCode}
\hypertarget{classTrafficGen_a1346cf8b75d4ba67a861233a8651601d}{
\index{TrafficGen@{TrafficGen}!enterState@{enterState}}
\index{enterState@{enterState}!TrafficGen@{TrafficGen}}
\subsubsection[{enterState}]{\setlength{\rightskip}{0pt plus 5cm}void enterState ({\bf uint32\_\-t} {\em newState})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_a1346cf8b75d4ba67a861233a8651601d}
Enter a new state.


\begin{DoxyParams}{引数}
\item[{\em newState}]identifier of state to enter \end{DoxyParams}



\begin{DoxyCode}
432 {
433     DPRINTF(TrafficGen, "Transition to state %d\n", newState);
434 
435     currState = newState;
436     // we could have been delayed and not transitioned on the exact
437     // tick when we were supposed to (due to back pressure when
438     // sending a packet)
439     nextTransitionTick = curTick() + states[currState]->duration;
440     states[currState]->enter();
441 }
\end{DoxyCode}
\hypertarget{classTrafficGen_a54ebb5edc195c159b56a39e6f15b9932}{
\index{TrafficGen@{TrafficGen}!getMasterPort@{getMasterPort}}
\index{getMasterPort@{getMasterPort}!TrafficGen@{TrafficGen}}
\subsubsection[{getMasterPort}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf BaseMasterPort}\& getMasterPort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTrafficGen_a54ebb5edc195c159b56a39e6f15b9932}
Get a master port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classMemObject_adc4e675e51defbdd1e354dac729d0703}{MemObject}を再定義しています。\hypertarget{classTrafficGen_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{TrafficGen@{TrafficGen}!init@{init}}
\index{init@{init}!TrafficGen@{TrafficGen}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTrafficGen_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classTrafficGen_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{SimObject}を再定義しています。


\begin{DoxyCode}
88 {
89     if (!port.isConnected())
90         fatal("The port of %s is not connected!\n", name());
91 
92     // if the system is in timing mode active the request generator
93     if (system->isTimingMode()) {
94         DPRINTF(TrafficGen, "Timing mode, activating request generator\n");
95 
96         parseConfig();
97 
98         // enter initial state
99         enterState(currState);
100     } else {
101         DPRINTF(TrafficGen,
102                 "Traffic generator is only active in timing mode\n");
103     }
104 }
\end{DoxyCode}
\hypertarget{classTrafficGen_a3c34ea9b29f410748d4435a667484924}{
\index{TrafficGen@{TrafficGen}!initState@{initState}}
\index{initState@{initState}!TrafficGen@{TrafficGen}}
\subsubsection[{initState}]{\setlength{\rightskip}{0pt plus 5cm}void initState ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTrafficGen_a3c34ea9b29f410748d4435a667484924}
\hyperlink{classTrafficGen_a3c34ea9b29f410748d4435a667484924}{initState()} is called on each \hyperlink{classSimObject}{SimObject} when $\ast$not$\ast$ restoring from a checkpoint. This provides a hook for state initializations that are only required for a \char`\"{}cold start\char`\"{}. 

\hyperlink{classSimObject_a3c34ea9b29f410748d4435a667484924}{SimObject}を再定義しています。


\begin{DoxyCode}
108 {
109     // when not restoring from a checkpoint, make sure we kick things off
110     if (system->isTimingMode()) {
111         // call nextPacketTick on the state to advance it
112         nextPacketTick = states[currState]->nextPacketTick(elasticReq, 0);
113         schedule(updateEvent, std::min(nextPacketTick, nextTransitionTick));
114     } else {
115         DPRINTF(TrafficGen,
116                 "Traffic generator is only active in timing mode\n");
117     }
118 }
\end{DoxyCode}
\hypertarget{classTrafficGen_a7719d247662a43429aac025090db5704}{
\index{TrafficGen@{TrafficGen}!parseConfig@{parseConfig}}
\index{parseConfig@{parseConfig}!TrafficGen@{TrafficGen}}
\subsubsection[{parseConfig}]{\setlength{\rightskip}{0pt plus 5cm}void parseConfig ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_a7719d247662a43429aac025090db5704}
Parse the config file and build the state map and transition matrix. 


\begin{DoxyCode}
212 {
213     // keep track of the transitions parsed to create the matrix when
214     // done
215     vector<Transition> transitions;
216 
217     // open input file
218     ifstream infile;
219     infile.open(configFile.c_str(), ifstream::in);
220     if (!infile.is_open()) {
221         fatal("Traffic generator %s config file not found at %s\n",
222               name(), configFile);
223     }
224 
225     bool init_state_set = false;
226 
227     // read line by line and determine the action based on the first
228     // keyword
229     string keyword;
230     string line;
231 
232     while (getline(infile, line).good()) {
233         // see if this line is a comment line, and if so skip it
234         if (line.find('#') != 1) {
235             // create an input stream for the tokenization
236             istringstream is(line);
237 
238             // determine the keyword
239             is >> keyword;
240 
241             if (keyword == "STATE") {
242                 // parse the behaviour of this state
243                 uint32_t id;
244                 Tick duration;
245                 string mode;
246 
247                 is >> id >> duration >> mode;
248 
249                 if (mode == "TRACE") {
250                     string traceFile;
251                     Addr addrOffset;
252 
253                     is >> traceFile >> addrOffset;
254 
255                     states[id] = new TraceGen(name(), masterID, duration,
256                                               traceFile, addrOffset);
257                     DPRINTF(TrafficGen, "State: %d TraceGen\n", id);
258                 } else if (mode == "IDLE") {
259                     states[id] = new IdleGen(name(), masterID, duration);
260                     DPRINTF(TrafficGen, "State: %d IdleGen\n", id);
261                 } else if (mode == "LINEAR" || mode == "RANDOM" ||
262                            mode == "DRAM") {
263                     uint32_t read_percent;
264                     Addr start_addr;
265                     Addr end_addr;
266                     Addr blocksize;
267                     Tick min_period;
268                     Tick max_period;
269                     Addr data_limit;
270 
271                     is >> read_percent >> start_addr >> end_addr >>
272                         blocksize >> min_period >> max_period >> data_limit;
273 
274                     DPRINTF(TrafficGen, "%s, addr %x to %x, size %d,"
275                             " period %d to %d, %d%% reads\n",
276                             mode, start_addr, end_addr, blocksize, min_period,
277                             max_period, read_percent);
278 
279 
280                     if (blocksize > system->cacheLineSize())
281                         fatal("TrafficGen %s block size (%d) is larger than "
282                               "cache line size (%d)\n", name(),
283                               blocksize, system->cacheLineSize());
284 
285                     if (read_percent > 100)
286                         fatal("%s cannot have more than 100% reads", name());
287 
288                     if (min_period > max_period)
289                         fatal("%s cannot have min_period > max_period", name());
290 
291                     if (mode == "LINEAR") {
292                         states[id] = new LinearGen(name(), masterID,
293                                                    duration, start_addr,
294                                                    end_addr, blocksize,
295                                                    min_period, max_period,
296                                                    read_percent, data_limit);
297                         DPRINTF(TrafficGen, "State: %d LinearGen\n", id);
298                     } else if (mode == "RANDOM") {
299                         states[id] = new RandomGen(name(), masterID,
300                                                    duration, start_addr,
301                                                    end_addr, blocksize,
302                                                    min_period, max_period,
303                                                    read_percent, data_limit);
304                         DPRINTF(TrafficGen, "State: %d RandomGen\n", id);
305                     } else if (mode == "DRAM") {
306                         // stride size (bytes) of the request for achieving
307                         // required hit length
308                         unsigned int stride_size;
309                         unsigned int page_size;
310                         unsigned int nbr_of_banks_DRAM;
311                         unsigned int nbr_of_banks_util;
312                         unsigned int addr_mapping;
313 
314                         is >> stride_size >> page_size >> nbr_of_banks_DRAM >>
315                             nbr_of_banks_util >> addr_mapping;
316 
317                         if (stride_size > page_size)
318                             warn("DRAM generator stride size (%d) is greater "
319                                  "than page size (%d)  of the memory\n",
320                                  blocksize, page_size);
321 
322                         if (nbr_of_banks_util > nbr_of_banks_DRAM)
323                             fatal("Attempting to use more banks (%) than "
324                                   "what is available (%)\n",
325                                   nbr_of_banks_util, nbr_of_banks_DRAM);
326 
327                         if (nbr_of_banks_util > nbr_of_banks_DRAM)
328                             fatal("Attempting to use more banks (%) than "
329                                   "what is available (%)\n",
330                                   nbr_of_banks_util, nbr_of_banks_DRAM);
331 
332                         // count the number of sequential packets to
333                         // generate
334                         unsigned int num_seq_pkts = 1;
335 
336                         if (stride_size > blocksize) {
337                             num_seq_pkts = divCeil(stride_size, blocksize);
338                             DPRINTF(TrafficGen, "stride size: %d "
339                                     "block size: %d, num_seq_pkts: %d\n",
340                                     stride_size, blocksize, num_seq_pkts);
341                         }
342 
343                         states[id] = new DramGen(name(), masterID,
344                                                  duration, start_addr,
345                                                  end_addr, blocksize,
346                                                  min_period, max_period,
347                                                  read_percent, data_limit,
348                                                  num_seq_pkts, page_size,
349                                                  nbr_of_banks_DRAM,
350                                                  nbr_of_banks_util,
351                                                  addr_mapping);
352                         DPRINTF(TrafficGen, "State: %d DramGen\n", id);
353                     }
354                 } else {
355                     fatal("%s: Unknown traffic generator mode: %s",
356                           name(), mode);
357                 }
358             } else if (keyword == "TRANSITION") {
359                 Transition transition;
360 
361                 is >> transition.from >> transition.to >> transition.p;
362 
363                 transitions.push_back(transition);
364 
365                 DPRINTF(TrafficGen, "Transition: %d -> %d\n", transition.from,
366                         transition.to);
367             } else if (keyword == "INIT") {
368                 // set the initial state as the active state
369                 is >> currState;
370 
371                 init_state_set = true;
372 
373                 DPRINTF(TrafficGen, "Initial state: %d\n", currState);
374             }
375         }
376     }
377 
378     if (!init_state_set)
379         fatal("%s: initial state not specified (add 'INIT <id>' line "
380               "to the config file)\n", name());
381 
382     // resize and populate state transition matrix
383     transitionMatrix.resize(states.size());
384     for (size_t i = 0; i < states.size(); i++) {
385         transitionMatrix[i].resize(states.size());
386     }
387 
388     for (vector<Transition>::iterator t = transitions.begin();
389          t != transitions.end(); ++t) {
390         transitionMatrix[t->from][t->to] = t->p;
391     }
392 
393     // ensure the egress edges do not have a probability larger than
394     // one
395     for (size_t i = 0; i < states.size(); i++) {
396         double sum = 0;
397         for (size_t j = 0; j < states.size(); j++) {
398             sum += transitionMatrix[i][j];
399         }
400 
401         // avoid comparing floating point numbers
402         if (abs(sum - 1.0) > 0.001)
403             fatal("%s has transition probability != 1 for state %d\n",
404                   name(), i);
405     }
406 
407     // close input file
408     infile.close();
409 }
\end{DoxyCode}
\hypertarget{classTrafficGen_a29cb5a4f98063ce6e9210eacbdb35298}{
\index{TrafficGen@{TrafficGen}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!TrafficGen@{TrafficGen}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetry ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_a29cb5a4f98063ce6e9210eacbdb35298}
Receive a retry from the neighbouring port and attempt to resend the waiting packet. 


\begin{DoxyCode}
445 {
446     assert(retryPkt != NULL);
447 
448     DPRINTF(TrafficGen, "Received retry\n");
449     numRetries++;
450     // attempt to send the packet, and if we are successful start up
451     // the machinery again
452     if (port.sendTimingReq(retryPkt)) {
453         retryPkt = NULL;
454         // remember how much delay was incurred due to back-pressure
455         // when sending the request, we also use this to derive
456         // the tick for the next packet
457         Tick delay = curTick() - retryPktTick;
458         retryPktTick = 0;
459         retryTicks += delay;
460 
461         if (drainManager == NULL) {
462             // packet is sent, so find out when the next one is due
463             nextPacketTick = states[currState]->nextPacketTick(elasticReq,
464                                                                delay);
465             Tick nextEventTick = std::min(nextPacketTick, nextTransitionTick);
466             schedule(updateEvent, std::max(curTick(), nextEventTick));
467         } else {
468             // shut things down
469             nextPacketTick = MaxTick;
470             nextTransitionTick = MaxTick;
471             drainManager->signalDrainDone();
472             // Clear the drain event once we're done with it.
473             drainManager = NULL;
474         }
475     }
476 }
\end{DoxyCode}
\hypertarget{classTrafficGen_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{TrafficGen@{TrafficGen}!regStats@{regStats}}
\index{regStats@{regStats}!TrafficGen@{TrafficGen}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTrafficGen_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} statistics 

\hyperlink{classSimObject_a4dc637449366fcdfc4e764cdf12d9b11}{SimObject}を再定義しています。


\begin{DoxyCode}
480 {
481     // Initialise all the stats
482     using namespace Stats;
483 
484     numPackets
485         .name(name() + ".numPackets")
486         .desc("Number of packets generated");
487 
488     numRetries
489         .name(name() + ".numRetries")
490         .desc("Number of retries");
491 
492     retryTicks
493         .name(name() + ".retryTicks")
494         .desc("Time spent waiting due to back-pressure (ticks)");
495 }
\end{DoxyCode}
\hypertarget{classTrafficGen_a53e036786d17361be4c7320d39c99b84}{
\index{TrafficGen@{TrafficGen}!serialize@{serialize}}
\index{serialize@{serialize}!TrafficGen@{TrafficGen}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTrafficGen_a53e036786d17361be4c7320d39c99b84}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。\hypertarget{classTrafficGen_aab0a81b788e7282586c12953fa5e0c37}{
\index{TrafficGen@{TrafficGen}!transition@{transition}}
\index{transition@{transition}!TrafficGen@{TrafficGen}}
\subsubsection[{transition}]{\setlength{\rightskip}{0pt plus 5cm}void transition ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_aab0a81b788e7282586c12953fa5e0c37}
Determine next state and perform the transition. 


\begin{DoxyCode}
413 {
414     // exit the current state
415     states[currState]->exit();
416 
417     // determine next state
418     double p = random_mt.gen_real1();
419     assert(currState < transitionMatrix.size());
420     double cumulative = 0.0;
421     size_t i = 0;
422     do {
423         cumulative += transitionMatrix[currState][i];
424         ++i;
425     } while (cumulative < p && i < transitionMatrix[currState].size());
426 
427     enterState(i - 1);
428 }
\end{DoxyCode}
\hypertarget{classTrafficGen_af22e5d6d660b97db37003ac61ac4ee49}{
\index{TrafficGen@{TrafficGen}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!TrafficGen@{TrafficGen}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTrafficGen_af22e5d6d660b97db37003ac61ac4ee49}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。\hypertarget{classTrafficGen_ac5c54df7ed3b930268c8d7752c101725}{
\index{TrafficGen@{TrafficGen}!update@{update}}
\index{update@{update}!TrafficGen@{TrafficGen}}
\subsubsection[{update}]{\setlength{\rightskip}{0pt plus 5cm}void update ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_ac5c54df7ed3b930268c8d7752c101725}
Schedules event for next update and executes an update on the state graph, either performing a state transition or executing the current state, depending on the current time. 


\begin{DoxyCode}
181 {
182     // if we have reached the time for the next state transition, then
183     // perform the transition
184     if (curTick() >= nextTransitionTick) {
185         transition();
186     } else {
187         assert(curTick() >= nextPacketTick);
188         // get the next packet and try to send it
189         PacketPtr pkt = states[currState]->getNextPacket();
190         numPackets++;
191         if (!port.sendTimingReq(pkt)) {
192             retryPkt = pkt;
193             retryPktTick = curTick();
194         }
195     }
196 
197     // if we are waiting for a retry, do not schedule any further
198     // events, in the case of a transition or a successful send, go
199     // ahead and determine when the next update should take place
200     if (retryPkt == NULL) {
201         // schedule next update event based on either the next execute
202         // tick or the next transition, which ever comes first
203         nextPacketTick = states[currState]->nextPacketTick(elasticReq, 0);
204         Tick nextEventTick = std::min(nextPacketTick, nextTransitionTick);
205         DPRINTF(TrafficGen, "Next event scheduled at %lld\n", nextEventTick);
206         schedule(updateEvent, nextEventTick);
207     }
208 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classTrafficGen_ad5835f1d2646493dafb2c5ac6244a93f}{
\index{TrafficGen@{TrafficGen}!configFile@{configFile}}
\index{configFile@{configFile}!TrafficGen@{TrafficGen}}
\subsubsection[{configFile}]{\setlength{\rightskip}{0pt plus 5cm}const std::string {\bf configFile}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_ad5835f1d2646493dafb2c5ac6244a93f}
The config file to parse. \hypertarget{classTrafficGen_a8428fe009627d1dd49ef98a54587830e}{
\index{TrafficGen@{TrafficGen}!currState@{currState}}
\index{currState@{currState}!TrafficGen@{TrafficGen}}
\subsubsection[{currState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf currState}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_a8428fe009627d1dd49ef98a54587830e}
Index of the current state \hypertarget{classTrafficGen_a329b71fb934a93312ca0aacbf5a3f982}{
\index{TrafficGen@{TrafficGen}!drainManager@{drainManager}}
\index{drainManager@{drainManager}!TrafficGen@{TrafficGen}}
\subsubsection[{drainManager}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DrainManager}$\ast$ {\bf drainManager}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_a329b71fb934a93312ca0aacbf5a3f982}
Manager to signal when drained \hypertarget{classTrafficGen_a42af28607a09ff1b95b5e848bf73f915}{
\index{TrafficGen@{TrafficGen}!elasticReq@{elasticReq}}
\index{elasticReq@{elasticReq}!TrafficGen@{TrafficGen}}
\subsubsection[{elasticReq}]{\setlength{\rightskip}{0pt plus 5cm}const bool {\bf elasticReq}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_a42af28607a09ff1b95b5e848bf73f915}
Determine whether to add elasticity in the request injection, thus responding to backpressure by slowing things down. \hypertarget{classTrafficGen_aa8528db52f6eb976baecb2291d1b408a}{
\index{TrafficGen@{TrafficGen}!masterID@{masterID}}
\index{masterID@{masterID}!TrafficGen@{TrafficGen}}
\subsubsection[{masterID}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterID} {\bf masterID}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_aa8528db52f6eb976baecb2291d1b408a}
MasterID used in generated requests. \hypertarget{classTrafficGen_a52d98e2f5ed0bf508db823995ad4940f}{
\index{TrafficGen@{TrafficGen}!nextPacketTick@{nextPacketTick}}
\index{nextPacketTick@{nextPacketTick}!TrafficGen@{TrafficGen}}
\subsubsection[{nextPacketTick}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf nextPacketTick}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_a52d98e2f5ed0bf508db823995ad4940f}
\hyperlink{classTime}{Time} of the next packet. \hypertarget{classTrafficGen_aaa2a440da39850c0d2d678fd2ee844af}{
\index{TrafficGen@{TrafficGen}!nextTransitionTick@{nextTransitionTick}}
\index{nextTransitionTick@{nextTransitionTick}!TrafficGen@{TrafficGen}}
\subsubsection[{nextTransitionTick}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf nextTransitionTick}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_aaa2a440da39850c0d2d678fd2ee844af}
\hyperlink{classTime}{Time} of next transition \hypertarget{classTrafficGen_a5ffd7b0e5641784cc4c40547e51c6cbc}{
\index{TrafficGen@{TrafficGen}!numPackets@{numPackets}}
\index{numPackets@{numPackets}!TrafficGen@{TrafficGen}}
\subsubsection[{numPackets}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numPackets}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_a5ffd7b0e5641784cc4c40547e51c6cbc}
Count the number of generated packets. \hypertarget{classTrafficGen_a166f92adc8967f926459ca64c92d6a66}{
\index{TrafficGen@{TrafficGen}!numRetries@{numRetries}}
\index{numRetries@{numRetries}!TrafficGen@{TrafficGen}}
\subsubsection[{numRetries}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numRetries}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_a166f92adc8967f926459ca64c92d6a66}
Count the number of retries. \hypertarget{classTrafficGen_a51d5c08451d2b2b8b99fe3fda83f05d8}{
\index{TrafficGen@{TrafficGen}!port@{port}}
\index{port@{port}!TrafficGen@{TrafficGen}}
\subsubsection[{port}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TrafficGenPort} {\bf port}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_a51d5c08451d2b2b8b99fe3fda83f05d8}
The instance of master port used by the traffic generator. \hypertarget{classTrafficGen_a314ae93c04b3ca96e79e1b1f39a8e478}{
\index{TrafficGen@{TrafficGen}!retryPkt@{retryPkt}}
\index{retryPkt@{retryPkt}!TrafficGen@{TrafficGen}}
\subsubsection[{retryPkt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketPtr} {\bf retryPkt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_a314ae93c04b3ca96e79e1b1f39a8e478}
\hyperlink{classPacket}{Packet} waiting to be sent. \hypertarget{classTrafficGen_a770dcab4388a8d55911cb6f29d9bb692}{
\index{TrafficGen@{TrafficGen}!retryPktTick@{retryPktTick}}
\index{retryPktTick@{retryPktTick}!TrafficGen@{TrafficGen}}
\subsubsection[{retryPktTick}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf retryPktTick}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_a770dcab4388a8d55911cb6f29d9bb692}
Tick when the stalled packet was meant to be sent. \hypertarget{classTrafficGen_a2d1dee1e20aeb0205ae665d7ad08b822}{
\index{TrafficGen@{TrafficGen}!retryTicks@{retryTicks}}
\index{retryTicks@{retryTicks}!TrafficGen@{TrafficGen}}
\subsubsection[{retryTicks}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf retryTicks}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_a2d1dee1e20aeb0205ae665d7ad08b822}
Count the time incurred from back-\/pressure. \hypertarget{classTrafficGen_a033c23b252da5264e1f864277711e5e1}{
\index{TrafficGen@{TrafficGen}!states@{states}}
\index{states@{states}!TrafficGen@{TrafficGen}}
\subsubsection[{states}]{\setlength{\rightskip}{0pt plus 5cm}m5::hash\_\-map$<${\bf uint32\_\-t}, {\bf BaseGen}$\ast$$>$ {\bf states}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_a033c23b252da5264e1f864277711e5e1}
Map of generator states \hypertarget{classTrafficGen_af27ccd765f13a4b7bd119dc7579e2746}{
\index{TrafficGen@{TrafficGen}!system@{system}}
\index{system@{system}!TrafficGen@{TrafficGen}}
\subsubsection[{system}]{\setlength{\rightskip}{0pt plus 5cm}{\bf System}$\ast$ {\bf system}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_af27ccd765f13a4b7bd119dc7579e2746}
The system used to determine which mode we are currently operating in. \hypertarget{classTrafficGen_a14f30e68ecada24867b46bcc8093f4f5}{
\index{TrafficGen@{TrafficGen}!transitionMatrix@{transitionMatrix}}
\index{transitionMatrix@{transitionMatrix}!TrafficGen@{TrafficGen}}
\subsubsection[{transitionMatrix}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf std::vector}$<$double$>$ $>$ {\bf transitionMatrix}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_a14f30e68ecada24867b46bcc8093f4f5}
State transition matrix \hypertarget{classTrafficGen_ab779474477fa217dd5483711dec2bf13}{
\index{TrafficGen@{TrafficGen}!updateEvent@{updateEvent}}
\index{updateEvent@{updateEvent}!TrafficGen@{TrafficGen}}
\subsubsection[{updateEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf TrafficGen}, \&TrafficGen::update$>$ {\bf updateEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTrafficGen_ab779474477fa217dd5483711dec2bf13}
\hyperlink{classEvent}{Event} for scheduling updates 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/testers/traffic\_\-gen/\hyperlink{traffic__gen_8hh}{traffic\_\-gen.hh}\item 
cpu/testers/traffic\_\-gen/\hyperlink{traffic__gen_8cc}{traffic\_\-gen.cc}\end{DoxyCompactItemize}
