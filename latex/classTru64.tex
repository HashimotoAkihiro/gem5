\hypertarget{classTru64}{
\section{クラス Tru64}
\label{classTru64}\index{Tru64@{Tru64}}
}


{\ttfamily \#include $<$tru64.hh$>$}Tru64に対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classTru64}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structTru64_1_1cpu__info}{cpu\_\-info}
\begin{DoxyCompactList}\small\item\em For getsysinfo() GSI\_\-CPU\_\-INFO option. \item\end{DoxyCompactList}\item 
struct \hyperlink{structTru64_1_1dirent}{dirent}
\begin{DoxyCompactList}\small\item\em For getdirentries(). \item\end{DoxyCompactList}\item 
struct \hyperlink{structTru64_1_1F64__statfs}{F64\_\-statfs}
\begin{DoxyCompactList}\small\item\em For statfs(). \item\end{DoxyCompactList}\item 
struct \hyperlink{structTru64_1_1nxm__config__info}{nxm\_\-config\_\-info}
\begin{DoxyCompactList}\small\item\em \hyperlink{structTru64_1_1nxm__config__info}{nxm\_\-config\_\-info} \item\end{DoxyCompactList}\item 
struct \hyperlink{structTru64_1_1nxm__sched__state}{nxm\_\-sched\_\-state}
\item 
struct \hyperlink{structTru64_1_1nxm__shared}{nxm\_\-shared}
\begin{DoxyCompactList}\small\item\em \hyperlink{structTru64_1_1nxm__shared}{nxm\_\-shared}. \item\end{DoxyCompactList}\item 
struct \hyperlink{structTru64_1_1nxm__task__attr}{nxm\_\-task\_\-attr}
\begin{DoxyCompactList}\small\item\em Task attribute structure. \item\end{DoxyCompactList}\item 
struct \hyperlink{structTru64_1_1nxm__thread__attr}{nxm\_\-thread\_\-attr}
\begin{DoxyCompactList}\small\item\em Thread attributes. \item\end{DoxyCompactList}\item 
struct \hyperlink{structTru64_1_1pre__F64__statfs}{pre\_\-F64\_\-statfs}
\begin{DoxyCompactList}\small\item\em For old \hyperlink{classTru64}{Tru64} v4.x statfs(). \item\end{DoxyCompactList}\item 
struct \hyperlink{structTru64_1_1quad}{quad}
\item 
struct \hyperlink{structTru64_1_1rlimit}{rlimit}
\begin{DoxyCompactList}\small\item\em Limit struct for getrlimit/setrlimit. \item\end{DoxyCompactList}\item 
struct \hyperlink{structTru64_1_1rusage}{rusage}
\begin{DoxyCompactList}\small\item\em For getrusage(). \item\end{DoxyCompactList}\item 
struct \hyperlink{structTru64_1_1sigcontext}{sigcontext}
\begin{DoxyCompactList}\small\item\em For sigreturn(). \item\end{DoxyCompactList}\item 
struct \hyperlink{structTru64_1_1tbl__sysinfo}{tbl\_\-sysinfo}
\begin{DoxyCompactList}\small\item\em For table(). \item\end{DoxyCompactList}\item 
struct \hyperlink{structTru64_1_1timeval}{timeval}
\begin{DoxyCompactList}\small\item\em For gettimeofday. \item\end{DoxyCompactList}\item 
struct \hyperlink{structTru64_1_1ushared__state}{ushared\_\-state}
\begin{DoxyCompactList}\small\item\em Thread state shared between user \& kernel. \item\end{DoxyCompactList}\item 
struct \hyperlink{structTru64_1_1utsname}{utsname}
\begin{DoxyCompactList}\small\item\em Interface struct for uname(). \item\end{DoxyCompactList}\item 
struct \hyperlink{structTru64_1_1vm__stack}{vm\_\-stack}
\begin{DoxyCompactList}\small\item\em For stack\_\-create. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \{ \hyperlink{classTru64_a68c01102755fc7d1c810bb0b0635fa90a7fff089a9b1eae0e9e60e82d7ab27b03}{KERN\_\-NOT\_\-RECEIVER} =  7, 
\hyperlink{classTru64_a68c01102755fc7d1c810bb0b0635fa90ae5ac70379d7d014f8f37ba0ee504f35c}{KERN\_\-NOT\_\-IN\_\-SET} =  12
 \}
\begin{DoxyCompactList}\small\item\em Return values for nxm calls. \item\end{DoxyCompactList}\item 
enum \hyperlink{classTru64_a8fb8339baae435616a985ef0d3fa6af1}{nxm\_\-slot\_\-state\_\-t} \{ \hyperlink{classTru64_a8fb8339baae435616a985ef0d3fa6af1a50b7d030b516364e6a36300e54aedf42}{NXM\_\-SLOT\_\-AVAIL}, 
\hyperlink{classTru64_a8fb8339baae435616a985ef0d3fa6af1ac7fa50c98e9a7cf0683966b0d6a6104e}{NXM\_\-SLOT\_\-BOUND}, 
\hyperlink{classTru64_a8fb8339baae435616a985ef0d3fa6af1af2d76554995e1f7f2990e8deb0e444e5}{NXM\_\-SLOT\_\-UNBOUND}, 
\hyperlink{classTru64_a8fb8339baae435616a985ef0d3fa6af1aa29b88969e5bd1d58b5a3340c872c8ad}{NXM\_\-SLOT\_\-EMPTY}
 \}
\begin{DoxyCompactList}\small\item\em nxm\_\-slot\_\-state\_\-t. \item\end{DoxyCompactList}\item 
enum \hyperlink{classTru64_a047f3ab687492e1d75f613e182664384}{nxm\_\-thread\_\-type} \{ \hyperlink{classTru64_a047f3ab687492e1d75f613e182664384a3ac97f98b04f22186a86480ad5fa471d}{NXM\_\-TYPE\_\-SCS} =  0, 
\hyperlink{classTru64_a047f3ab687492e1d75f613e182664384a1d6a136a94a41d702244a74edccdb312}{NXM\_\-TYPE\_\-VP} =  1, 
\hyperlink{classTru64_a047f3ab687492e1d75f613e182664384a94b977628442e840a44dd81fdeb105ae}{NXM\_\-TYPE\_\-MANAGER} =  2
 \}
\begin{DoxyCompactList}\small\item\em For nxm\_\-thread\_\-create. \item\end{DoxyCompactList}\item 
typedef uint64\_\-t \hyperlink{classTru64_ae770e87ab143e8ad7feaf75b78a89718}{sigset\_\-t}
\begin{DoxyCompactList}\small\item\em Signal set. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\begin{Indent}{\bf }\par
{\em \label{_amgrpd41d8cd98f00b204e9800998ecf8427e}
 }\begin{DoxyCompactItemize}
\item 
typedef uint64\_\-t \hyperlink{classTru64_a186ea1339bffb378854987065835afe3}{size\_\-t}
\begin{DoxyCompactList}\small\item\em Basic \hyperlink{classTru64}{Tru64} types. \item\end{DoxyCompactList}\item 
typedef uint64\_\-t \hyperlink{classTru64_a2cb84cf5f02a29b7e8f237ff151a9225}{off\_\-t}
\item 
typedef uint16\_\-t \hyperlink{classTru64_a772a435921844488d52ef4df39b3e702}{nlink\_\-t}
\item 
typedef int32\_\-t \hyperlink{classTru64_abf62b93d918a43f0c5ee0ab777b1c3ef}{dev\_\-t}
\item 
typedef \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classTru64_af2306308627701b66dc6f3babe821ab4}{uid\_\-t}
\item 
typedef \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classTru64_aa7352f1065fe606194d792e2b292cf83}{gid\_\-t}
\item 
typedef \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classTru64_a3346b04b0420b32ccf6b706551b70762}{time\_\-t}
\item 
typedef \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classTru64_af8f4385bb42836d1e3ad4fea9d71d1b9}{mode\_\-t}
\item 
typedef \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classTru64_aed4e918b44240739869c4bdb1c4787a9}{ino\_\-t}
\item 
typedef \hyperlink{structTru64_1_1quad}{quad} \hyperlink{classTru64_abcb767738eec58d41562764284835524}{fsid\_\-t}
\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Static Public メソッド}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class T $>$ }\\static void \hyperlink{classTru64_ab39f4973592abe61638b8b998bc5691d}{copyOutStatfsBuf} (\hyperlink{classSETranslatingPortProxy}{SETranslatingPortProxy} \&mem, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, \hyperlink{kern_2tru64_2tru64_8hh_a1a8529336c3f2704cb49ee2cd97412a8}{global\_\-statfs} $\ast$host)
\item 
static \hyperlink{classSyscallReturn}{SyscallReturn} \hyperlink{classTru64_a2e7bba81ca6d880e6cbf4e1db6100a68}{getdirentriesFunc} (\hyperlink{classSyscallDesc}{SyscallDesc} $\ast$desc, int callnum, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em Target getdirentries() handler. \item\end{DoxyCompactList}\item 
static \hyperlink{classSyscallReturn}{SyscallReturn} \hyperlink{classTru64_a368f998d81d17c06f2fb1639683f8302}{sigreturnFunc} (\hyperlink{classSyscallDesc}{SyscallDesc} $\ast$desc, int callnum, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em Target sigreturn() handler. \item\end{DoxyCompactList}\item 
static \hyperlink{classSyscallReturn}{SyscallReturn} \hyperlink{classTru64_ac6e3676ee42b0ad6a609f36f0cf654bb}{stack\_\-createFunc} (\hyperlink{classSyscallDesc}{SyscallDesc} $\ast$desc, int callnum, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em Create a stack region for a thread. \item\end{DoxyCompactList}\item 
static \hyperlink{classSyscallReturn}{SyscallReturn} \hyperlink{classTru64_a7393c42ceaadfe69e71c4cab0d059968}{nxm\_\-task\_\-initFunc} (\hyperlink{classSyscallDesc}{SyscallDesc} $\ast$desc, int callnum, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\item 
static void \hyperlink{classTru64_a83da5f99bb14ade814d1509f55d1db1b}{init\_\-thread\_\-context} (\hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{structTru64_1_1nxm__thread__attr}{Tru64::nxm\_\-thread\_\-attr} $\ast$attrp, uint64\_\-t uniq\_\-val)
\begin{DoxyCompactList}\small\item\em Initialize thread context. \item\end{DoxyCompactList}\item 
static \hyperlink{classSyscallReturn}{SyscallReturn} \hyperlink{classTru64_a56167e2aed868ff95f0864b9075adab1}{nxm\_\-thread\_\-createFunc} (\hyperlink{classSyscallDesc}{SyscallDesc} $\ast$desc, int callnum, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em Create thread. \item\end{DoxyCompactList}\item 
static \hyperlink{classSyscallReturn}{SyscallReturn} \hyperlink{classTru64_a7d672681a6c03ce2f3d8e64b159d23d7}{nxm\_\-idleFunc} (\hyperlink{classSyscallDesc}{SyscallDesc} $\ast$desc, int callnum, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em Thread idle call (like yield()). \item\end{DoxyCompactList}\item 
static \hyperlink{classSyscallReturn}{SyscallReturn} \hyperlink{classTru64_a05e8a076d0c534c96b680a3661fc9003}{nxm\_\-thread\_\-blockFunc} (\hyperlink{classSyscallDesc}{SyscallDesc} $\ast$desc, int callnum, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em Block thread. \item\end{DoxyCompactList}\item 
static \hyperlink{classSyscallReturn}{SyscallReturn} \hyperlink{classTru64_ad497f5d8e1f57340b73ad9ea52b88dd3}{nxm\_\-blockFunc} (\hyperlink{classSyscallDesc}{SyscallDesc} $\ast$desc, int callnum, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em block. \item\end{DoxyCompactList}\item 
static \hyperlink{classSyscallReturn}{SyscallReturn} \hyperlink{classTru64_abdd09a9b9645e7199d23afbdae212ef6}{nxm\_\-unblockFunc} (\hyperlink{classSyscallDesc}{SyscallDesc} $\ast$desc, int callnum, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em Unblock thread. \item\end{DoxyCompactList}\item 
static \hyperlink{classSyscallReturn}{SyscallReturn} \hyperlink{classTru64_a447627b7d2862dbc933f4d4a4433cd4c}{swtch\_\-priFunc} (\hyperlink{classSyscallDesc}{SyscallDesc} $\ast$desc, int callnum, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em \hyperlink{classSwitch}{Switch} thread priority. \item\end{DoxyCompactList}\item 
static int \hyperlink{classTru64_aaef9d5f33173de4f6d2875193eb83d7a}{activate\_\-waiting\_\-context} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} uaddr, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, bool activate\_\-all=false)
\item 
static void \hyperlink{classTru64_a029c70f7b96e2ccaa00ea5252875de90}{m5\_\-lock\_\-mutex} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} uaddr, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em M5 hacked-\/up lock acquire. \item\end{DoxyCompactList}\item 
static void \hyperlink{classTru64_ac965ae70992f9a6f184c1e6f177e3b5b}{m5\_\-unlock\_\-mutex} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} uaddr, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em M5 unlock call. \item\end{DoxyCompactList}\item 
static \hyperlink{classSyscallReturn}{SyscallReturn} \hyperlink{classTru64_a5a1fd874973f006aecd51e98ce0b6579}{m5\_\-mutex\_\-lockFunc} (\hyperlink{classSyscallDesc}{SyscallDesc} $\ast$desc, int callnum, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em Lock acquire syscall handler. \item\end{DoxyCompactList}\item 
static \hyperlink{classSyscallReturn}{SyscallReturn} \hyperlink{classTru64_aa8d051ea34736b976895f70df5f48b9d}{m5\_\-mutex\_\-trylockFunc} (\hyperlink{classSyscallDesc}{SyscallDesc} $\ast$desc, int callnum, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em Try lock (non-\/blocking). \item\end{DoxyCompactList}\item 
static \hyperlink{classSyscallReturn}{SyscallReturn} \hyperlink{classTru64_a13ce77bfaa709faa1a3006cea0465959}{m5\_\-mutex\_\-unlockFunc} (\hyperlink{classSyscallDesc}{SyscallDesc} $\ast$desc, int callnum, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em Unlock syscall handler. \item\end{DoxyCompactList}\item 
static \hyperlink{classSyscallReturn}{SyscallReturn} \hyperlink{classTru64_acfc803d4984b3037abb896038e4f6fc1}{m5\_\-cond\_\-signalFunc} (\hyperlink{classSyscallDesc}{SyscallDesc} $\ast$desc, int callnum, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em Signal ocndition. \item\end{DoxyCompactList}\item 
static \hyperlink{classSyscallReturn}{SyscallReturn} \hyperlink{classTru64_a0553f30a35d45bbc6ba7fd2120332c9c}{m5\_\-cond\_\-broadcastFunc} (\hyperlink{classSyscallDesc}{SyscallDesc} $\ast$desc, int callnum, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em Wake up all processes waiting on the condition variable. \item\end{DoxyCompactList}\item 
static \hyperlink{classSyscallReturn}{SyscallReturn} \hyperlink{classTru64_a2c38b28b551cfcfe04f70cbfbff3a55e}{m5\_\-cond\_\-waitFunc} (\hyperlink{classSyscallDesc}{SyscallDesc} $\ast$desc, int callnum, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em Wait on a condition. \item\end{DoxyCompactList}\item 
static \hyperlink{classSyscallReturn}{SyscallReturn} \hyperlink{classTru64_a56f0a437d8a86b1220497375406a3f78}{m5\_\-thread\_\-exitFunc} (\hyperlink{classSyscallDesc}{SyscallDesc} $\ast$desc, int callnum, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em Thread exit. \item\end{DoxyCompactList}\item 
static \hyperlink{classSyscallReturn}{SyscallReturn} \hyperlink{classTru64_a82607daf4ef0639e0013656b0c861927}{indirectSyscallFunc} (\hyperlink{classSyscallDesc}{SyscallDesc} $\ast$desc, int callnum, \hyperlink{classLiveProcess}{LiveProcess} $\ast$process, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\begin{DoxyCompactList}\small\item\em Indirect syscall invocation (call \#0). \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public 変数}
\begin{DoxyCompactItemize}
\item 
static const int \hyperlink{classTru64_a1a19d4c9718c9a4ad5fa2e48271fccc9}{\_\-SYS\_\-NMLN} = 32
\begin{DoxyCompactList}\small\item\em Length of strings in struct \hyperlink{structTru64_1_1utsname}{utsname} (plus 1 for null char). \item\end{DoxyCompactList}\item 
static const int \hyperlink{classTru64_a284276950ab5fbb4ed5432a4fe77c0b4}{NXM\_\-TASK\_\-INIT\_\-VP} = 2
\begin{DoxyCompactList}\small\item\em For nxm\_\-task\_\-init. \item\end{DoxyCompactList}\item 
static const char $\ast$ \hyperlink{classTru64_aad01339e89106fdf68f57ef118956fa9}{hostname}
\begin{DoxyCompactList}\small\item\em The target system's hostname. \item\end{DoxyCompactList}\item 
static const int \hyperlink{classTru64_a42f5e6243e70c3d99afed9a0ab5ac3c1}{NXM\_\-LIB\_\-VERSION} = 301003
\begin{DoxyCompactList}\small\item\em NXM library version stamp. \item\end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{説明}
This class encapsulates the types, structures, constants, functions, and syscall-\/number mappings specific to the Alpha \hyperlink{classTru64}{Tru64} syscall interface. 

\subsection{型定義}
\hypertarget{classTru64_abf62b93d918a43f0c5ee0ab777b1c3ef}{
\index{Tru64@{Tru64}!dev\_\-t@{dev\_\-t}}
\index{dev\_\-t@{dev\_\-t}!Tru64@{Tru64}}
\subsubsection[{dev\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef int32\_\-t {\bf dev\_\-t}}}
\label{classTru64_abf62b93d918a43f0c5ee0ab777b1c3ef}
\hypertarget{classTru64_abcb767738eec58d41562764284835524}{
\index{Tru64@{Tru64}!fsid\_\-t@{fsid\_\-t}}
\index{fsid\_\-t@{fsid\_\-t}!Tru64@{Tru64}}
\subsubsection[{fsid\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf quad} {\bf fsid\_\-t}}}
\label{classTru64_abcb767738eec58d41562764284835524}
\hypertarget{classTru64_aa7352f1065fe606194d792e2b292cf83}{
\index{Tru64@{Tru64}!gid\_\-t@{gid\_\-t}}
\index{gid\_\-t@{gid\_\-t}!Tru64@{Tru64}}
\subsubsection[{gid\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf uint32\_\-t} {\bf gid\_\-t}}}
\label{classTru64_aa7352f1065fe606194d792e2b292cf83}
\hypertarget{classTru64_aed4e918b44240739869c4bdb1c4787a9}{
\index{Tru64@{Tru64}!ino\_\-t@{ino\_\-t}}
\index{ino\_\-t@{ino\_\-t}!Tru64@{Tru64}}
\subsubsection[{ino\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf uint32\_\-t} {\bf ino\_\-t}}}
\label{classTru64_aed4e918b44240739869c4bdb1c4787a9}
\hypertarget{classTru64_af8f4385bb42836d1e3ad4fea9d71d1b9}{
\index{Tru64@{Tru64}!mode\_\-t@{mode\_\-t}}
\index{mode\_\-t@{mode\_\-t}!Tru64@{Tru64}}
\subsubsection[{mode\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf uint32\_\-t} {\bf mode\_\-t}}}
\label{classTru64_af8f4385bb42836d1e3ad4fea9d71d1b9}
\hypertarget{classTru64_a772a435921844488d52ef4df39b3e702}{
\index{Tru64@{Tru64}!nlink\_\-t@{nlink\_\-t}}
\index{nlink\_\-t@{nlink\_\-t}!Tru64@{Tru64}}
\subsubsection[{nlink\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef uint16\_\-t {\bf nlink\_\-t}}}
\label{classTru64_a772a435921844488d52ef4df39b3e702}
\hypertarget{classTru64_a2cb84cf5f02a29b7e8f237ff151a9225}{
\index{Tru64@{Tru64}!off\_\-t@{off\_\-t}}
\index{off\_\-t@{off\_\-t}!Tru64@{Tru64}}
\subsubsection[{off\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef uint64\_\-t {\bf off\_\-t}}}
\label{classTru64_a2cb84cf5f02a29b7e8f237ff151a9225}
\hypertarget{classTru64_ae770e87ab143e8ad7feaf75b78a89718}{
\index{Tru64@{Tru64}!sigset\_\-t@{sigset\_\-t}}
\index{sigset\_\-t@{sigset\_\-t}!Tru64@{Tru64}}
\subsubsection[{sigset\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef uint64\_\-t {\bf sigset\_\-t}}}
\label{classTru64_ae770e87ab143e8ad7feaf75b78a89718}


Signal set. \hypertarget{classTru64_a186ea1339bffb378854987065835afe3}{
\index{Tru64@{Tru64}!size\_\-t@{size\_\-t}}
\index{size\_\-t@{size\_\-t}!Tru64@{Tru64}}
\subsubsection[{size\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef uint64\_\-t {\bf size\_\-t}}}
\label{classTru64_a186ea1339bffb378854987065835afe3}


Basic \hyperlink{classTru64}{Tru64} types. \hypertarget{classTru64_a3346b04b0420b32ccf6b706551b70762}{
\index{Tru64@{Tru64}!time\_\-t@{time\_\-t}}
\index{time\_\-t@{time\_\-t}!Tru64@{Tru64}}
\subsubsection[{time\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf uint32\_\-t} {\bf time\_\-t}}}
\label{classTru64_a3346b04b0420b32ccf6b706551b70762}
\hypertarget{classTru64_af2306308627701b66dc6f3babe821ab4}{
\index{Tru64@{Tru64}!uid\_\-t@{uid\_\-t}}
\index{uid\_\-t@{uid\_\-t}!Tru64@{Tru64}}
\subsubsection[{uid\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf uint32\_\-t} {\bf uid\_\-t}}}
\label{classTru64_af2306308627701b66dc6f3babe821ab4}


\subsection{列挙型}
\hypertarget{classTru64_a68c01102755fc7d1c810bb0b0635fa90}{
\subsubsection[{"@72}]{\setlength{\rightskip}{0pt plus 5cm}anonymous enum}}
\label{classTru64_a68c01102755fc7d1c810bb0b0635fa90}


Return values for nxm calls. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{KERN\_\-NOT\_\-RECEIVER@{KERN\_\-NOT\_\-RECEIVER}!Tru64@{Tru64}}\index{Tru64@{Tru64}!KERN\_\-NOT\_\-RECEIVER@{KERN\_\-NOT\_\-RECEIVER}}\item[{\em 
\hypertarget{classTru64_a68c01102755fc7d1c810bb0b0635fa90a7fff089a9b1eae0e9e60e82d7ab27b03}{
KERN\_\-NOT\_\-RECEIVER}
\label{classTru64_a68c01102755fc7d1c810bb0b0635fa90a7fff089a9b1eae0e9e60e82d7ab27b03}
}]\index{KERN\_\-NOT\_\-IN\_\-SET@{KERN\_\-NOT\_\-IN\_\-SET}!Tru64@{Tru64}}\index{Tru64@{Tru64}!KERN\_\-NOT\_\-IN\_\-SET@{KERN\_\-NOT\_\-IN\_\-SET}}\item[{\em 
\hypertarget{classTru64_a68c01102755fc7d1c810bb0b0635fa90ae5ac70379d7d014f8f37ba0ee504f35c}{
KERN\_\-NOT\_\-IN\_\-SET}
\label{classTru64_a68c01102755fc7d1c810bb0b0635fa90ae5ac70379d7d014f8f37ba0ee504f35c}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
267          {
268         KERN_NOT_RECEIVER = 7,
269         KERN_NOT_IN_SET = 12
270     };
\end{DoxyCode}
\hypertarget{classTru64_a8fb8339baae435616a985ef0d3fa6af1}{
\index{Tru64@{Tru64}!nxm\_\-slot\_\-state\_\-t@{nxm\_\-slot\_\-state\_\-t}}
\index{nxm\_\-slot\_\-state\_\-t@{nxm\_\-slot\_\-state\_\-t}!Tru64@{Tru64}}
\subsubsection[{nxm\_\-slot\_\-state\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf nxm\_\-slot\_\-state\_\-t}}}
\label{classTru64_a8fb8339baae435616a985ef0d3fa6af1}


nxm\_\-slot\_\-state\_\-t. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{NXM\_\-SLOT\_\-AVAIL@{NXM\_\-SLOT\_\-AVAIL}!Tru64@{Tru64}}\index{Tru64@{Tru64}!NXM\_\-SLOT\_\-AVAIL@{NXM\_\-SLOT\_\-AVAIL}}\item[{\em 
\hypertarget{classTru64_a8fb8339baae435616a985ef0d3fa6af1a50b7d030b516364e6a36300e54aedf42}{
NXM\_\-SLOT\_\-AVAIL}
\label{classTru64_a8fb8339baae435616a985ef0d3fa6af1a50b7d030b516364e6a36300e54aedf42}
}]\index{NXM\_\-SLOT\_\-BOUND@{NXM\_\-SLOT\_\-BOUND}!Tru64@{Tru64}}\index{Tru64@{Tru64}!NXM\_\-SLOT\_\-BOUND@{NXM\_\-SLOT\_\-BOUND}}\item[{\em 
\hypertarget{classTru64_a8fb8339baae435616a985ef0d3fa6af1ac7fa50c98e9a7cf0683966b0d6a6104e}{
NXM\_\-SLOT\_\-BOUND}
\label{classTru64_a8fb8339baae435616a985ef0d3fa6af1ac7fa50c98e9a7cf0683966b0d6a6104e}
}]\index{NXM\_\-SLOT\_\-UNBOUND@{NXM\_\-SLOT\_\-UNBOUND}!Tru64@{Tru64}}\index{Tru64@{Tru64}!NXM\_\-SLOT\_\-UNBOUND@{NXM\_\-SLOT\_\-UNBOUND}}\item[{\em 
\hypertarget{classTru64_a8fb8339baae435616a985ef0d3fa6af1af2d76554995e1f7f2990e8deb0e444e5}{
NXM\_\-SLOT\_\-UNBOUND}
\label{classTru64_a8fb8339baae435616a985ef0d3fa6af1af2d76554995e1f7f2990e8deb0e444e5}
}]\index{NXM\_\-SLOT\_\-EMPTY@{NXM\_\-SLOT\_\-EMPTY}!Tru64@{Tru64}}\index{Tru64@{Tru64}!NXM\_\-SLOT\_\-EMPTY@{NXM\_\-SLOT\_\-EMPTY}}\item[{\em 
\hypertarget{classTru64_a8fb8339baae435616a985ef0d3fa6af1aa29b88969e5bd1d58b5a3340c872c8ad}{
NXM\_\-SLOT\_\-EMPTY}
\label{classTru64_a8fb8339baae435616a985ef0d3fa6af1aa29b88969e5bd1d58b5a3340c872c8ad}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
351                           {
352         NXM_SLOT_AVAIL,
353         NXM_SLOT_BOUND,
354         NXM_SLOT_UNBOUND,
355         NXM_SLOT_EMPTY
356     };
\end{DoxyCode}
\hypertarget{classTru64_a047f3ab687492e1d75f613e182664384}{
\index{Tru64@{Tru64}!nxm\_\-thread\_\-type@{nxm\_\-thread\_\-type}}
\index{nxm\_\-thread\_\-type@{nxm\_\-thread\_\-type}!Tru64@{Tru64}}
\subsubsection[{nxm\_\-thread\_\-type}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf nxm\_\-thread\_\-type}}}
\label{classTru64_a047f3ab687492e1d75f613e182664384}


For nxm\_\-thread\_\-create. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{NXM\_\-TYPE\_\-SCS@{NXM\_\-TYPE\_\-SCS}!Tru64@{Tru64}}\index{Tru64@{Tru64}!NXM\_\-TYPE\_\-SCS@{NXM\_\-TYPE\_\-SCS}}\item[{\em 
\hypertarget{classTru64_a047f3ab687492e1d75f613e182664384a3ac97f98b04f22186a86480ad5fa471d}{
NXM\_\-TYPE\_\-SCS}
\label{classTru64_a047f3ab687492e1d75f613e182664384a3ac97f98b04f22186a86480ad5fa471d}
}]\index{NXM\_\-TYPE\_\-VP@{NXM\_\-TYPE\_\-VP}!Tru64@{Tru64}}\index{Tru64@{Tru64}!NXM\_\-TYPE\_\-VP@{NXM\_\-TYPE\_\-VP}}\item[{\em 
\hypertarget{classTru64_a047f3ab687492e1d75f613e182664384a1d6a136a94a41d702244a74edccdb312}{
NXM\_\-TYPE\_\-VP}
\label{classTru64_a047f3ab687492e1d75f613e182664384a1d6a136a94a41d702244a74edccdb312}
}]\index{NXM\_\-TYPE\_\-MANAGER@{NXM\_\-TYPE\_\-MANAGER}!Tru64@{Tru64}}\index{Tru64@{Tru64}!NXM\_\-TYPE\_\-MANAGER@{NXM\_\-TYPE\_\-MANAGER}}\item[{\em 
\hypertarget{classTru64_a047f3ab687492e1d75f613e182664384a94b977628442e840a44dd81fdeb105ae}{
NXM\_\-TYPE\_\-MANAGER}
\label{classTru64_a047f3ab687492e1d75f613e182664384a94b977628442e840a44dd81fdeb105ae}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
369                          {
370         NXM_TYPE_SCS    = 0,
371         NXM_TYPE_VP             = 1,
372         NXM_TYPE_MANAGER        = 2
373     };
\end{DoxyCode}


\subsection{関数}
\hypertarget{classTru64_aaef9d5f33173de4f6d2875193eb83d7a}{
\index{Tru64@{Tru64}!activate\_\-waiting\_\-context@{activate\_\-waiting\_\-context}}
\index{activate\_\-waiting\_\-context@{activate\_\-waiting\_\-context}!Tru64@{Tru64}}
\subsubsection[{activate\_\-waiting\_\-context}]{\setlength{\rightskip}{0pt plus 5cm}static int activate\_\-waiting\_\-context ({\bf Addr} {\em uaddr}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  bool {\em activate\_\-all} = {\ttfamily false})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_aaef9d5f33173de4f6d2875193eb83d7a}
Activate thread context waiting on a channel. Just activate one by default. 


\begin{DoxyCode}
914     {
915         using namespace std;
916 
917         int num_activated = 0;
918 
919         list<Process::WaitRec>::iterator i = process->waitList.begin();
920         list<Process::WaitRec>::iterator end = process->waitList.end();
921 
922         while (i != end && (num_activated == 0 || activate_all)) {
923             if (i->waitChan == uaddr) {
924                 // found waiting process: make it active
925                 ThreadContext *newCtx = i->waitingContext;
926                 assert(newCtx->status() == ThreadContext::Suspended);
927                 newCtx->activate();
928 
929                 // get rid of this record
930                 i = process->waitList.erase(i);
931 
932                 ++num_activated;
933             } else {
934                 ++i;
935             }
936         }
937 
938         return num_activated;
939     }
\end{DoxyCode}
\hypertarget{classTru64_ab39f4973592abe61638b8b998bc5691d}{
\index{Tru64@{Tru64}!copyOutStatfsBuf@{copyOutStatfsBuf}}
\index{copyOutStatfsBuf@{copyOutStatfsBuf}!Tru64@{Tru64}}
\subsubsection[{copyOutStatfsBuf}]{\setlength{\rightskip}{0pt plus 5cm}static void copyOutStatfsBuf ({\bf SETranslatingPortProxy} \& {\em mem}, \/  {\bf Addr} {\em addr}, \/  {\bf global\_\-statfs} $\ast$ {\em host})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_ab39f4973592abe61638b8b998bc5691d}
Helper function to convert a host statfs buffer to a target statfs buffer. Also copies the target buffer out to the simulated memory space. Used by statfs() and fstatfs(). 

\hyperlink{classTru64__F64_ab39f4973592abe61638b8b998bc5691d}{Tru64\_\-F64}, と \hyperlink{classTru64__PreF64_ab39f4973592abe61638b8b998bc5691d}{Tru64\_\-PreF64}で再定義されています。


\begin{DoxyCode}
402     {
403         using namespace TheISA;
404 
405         TypedBufferArg<T> tgt(addr);
406 
407 #if defined(__OpenBSD__) || defined(__APPLE__) || defined(__FreeBSD__)
408         tgt->f_type = 0;
409 #else
410         tgt->f_type = htog(host->f_type);
411 #endif
412         tgt->f_bsize = htog(host->f_bsize);
413         tgt->f_blocks = htog(host->f_blocks);
414         tgt->f_bfree = htog(host->f_bfree);
415         tgt->f_bavail = htog(host->f_bavail);
416         tgt->f_files = htog(host->f_files);
417         tgt->f_ffree = htog(host->f_ffree);
418 
419         // Is this as string normally?
420         memcpy(&tgt->f_fsid, &host->f_fsid, sizeof(host->f_fsid));
421 
422         tgt.copyOut(mem);
423     }
\end{DoxyCode}
\hypertarget{classTru64_a2e7bba81ca6d880e6cbf4e1db6100a68}{
\index{Tru64@{Tru64}!getdirentriesFunc@{getdirentriesFunc}}
\index{getdirentriesFunc@{getdirentriesFunc}!Tru64@{Tru64}}
\subsubsection[{getdirentriesFunc}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf SyscallReturn} getdirentriesFunc ({\bf SyscallDesc} $\ast$ {\em desc}, \/  int {\em callnum}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_a2e7bba81ca6d880e6cbf4e1db6100a68}


Target getdirentries() handler. 


\begin{DoxyCode}
434     {
435         using namespace TheISA;
436 
437 #if defined(__APPLE__) || defined(__CYGWIN__)
438         panic("getdirent not implemented on cygwin!");
439 #else
440         int index = 0;
441         int fd = process->sim_fd(process->getSyscallArg(tc, index));
442         Addr tgt_buf = process->getSyscallArg(tc, index);
443         int tgt_nbytes = process->getSyscallArg(tc, index);
444         Addr tgt_basep = process->getSyscallArg(tc, index);
445 
446         char * const host_buf = new char[tgt_nbytes];
447 
448         // just pass basep through uninterpreted.
449         TypedBufferArg<int64_t> basep(tgt_basep);
450         basep.copyIn(tc->getMemProxy());
451         long host_basep = (off_t)htog((int64_t)*basep);
452         int host_result = getdirentries(fd, host_buf, tgt_nbytes, &host_basep);
453 
454         // check for error
455         if (host_result < 0) {
456             delete [] host_buf;
457             return -errno;
458         }
459 
460         // no error: copy results back to target space
461         Addr tgt_buf_ptr = tgt_buf;
462         char *host_buf_ptr = host_buf;
463         char *host_buf_end = host_buf + host_result;
464         while (host_buf_ptr < host_buf_end) {
465             global_dirent *host_dp = (global_dirent *)host_buf_ptr;
466             int namelen = strlen(host_dp->d_name);
467 
468             // Actual size includes padded string rounded up for alignment.
469             // Subtract 256 for dummy char array in Tru64::dirent definition.
470             // Add 1 to namelen for terminating null char.
471             int tgt_bufsize = sizeof(Tru64::dirent) - 256 + roundUp(namelen+1, 8)
      ;
472             TypedBufferArg<Tru64::dirent> tgt_dp(tgt_buf_ptr, tgt_bufsize);
473             tgt_dp->d_ino = host_dp->d_ino;
474             tgt_dp->d_reclen = tgt_bufsize;
475             tgt_dp->d_namlen = namelen;
476             strcpy(tgt_dp->d_name, host_dp->d_name);
477             tgt_dp.copyOut(tc->getMemProxy());
478 
479             tgt_buf_ptr += tgt_bufsize;
480             host_buf_ptr += host_dp->d_reclen;
481         }
482 
483         delete [] host_buf;
484 
485         *basep = htog((int64_t)host_basep);
486         basep.copyOut(tc->getMemProxy());
487 
488         return tgt_buf_ptr - tgt_buf;
489 #endif
490     }
\end{DoxyCode}
\hypertarget{classTru64_a82607daf4ef0639e0013656b0c861927}{
\index{Tru64@{Tru64}!indirectSyscallFunc@{indirectSyscallFunc}}
\index{indirectSyscallFunc@{indirectSyscallFunc}!Tru64@{Tru64}}
\subsubsection[{indirectSyscallFunc}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf SyscallReturn} indirectSyscallFunc ({\bf SyscallDesc} $\ast$ {\em desc}, \/  int {\em callnum}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_a82607daf4ef0639e0013656b0c861927}


Indirect syscall invocation (call \#0). 


\begin{DoxyCode}
1100     {
1101         int index = 0;
1102         int new_callnum = process->getSyscallArg(tc, index);
1103 
1104         for (int i = 0; i < 5; ++i)
1105             process->setSyscallArg(tc, i, process->getSyscallArg(tc, index));
1106 
1107 
1108         SyscallDesc *new_desc = process->getDesc(new_callnum);
1109         if (desc == NULL)
1110             fatal("Syscall %d out of range", callnum);
1111 
1112         new_desc->doSyscall(new_callnum, process, tc);
1113 
1114         return 0;
1115     }
\end{DoxyCode}
\hypertarget{classTru64_a83da5f99bb14ade814d1509f55d1db1b}{
\index{Tru64@{Tru64}!init\_\-thread\_\-context@{init\_\-thread\_\-context}}
\index{init\_\-thread\_\-context@{init\_\-thread\_\-context}!Tru64@{Tru64}}
\subsubsection[{init\_\-thread\_\-context}]{\setlength{\rightskip}{0pt plus 5cm}static void init\_\-thread\_\-context ({\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Tru64::nxm\_\-thread\_\-attr} $\ast$ {\em attrp}, \/  uint64\_\-t {\em uniq\_\-val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_a83da5f99bb14ade814d1509f55d1db1b}


Initialize thread context. 


\begin{DoxyCode}
694     {
695         using namespace TheISA;
696 
697         tc->clearArchRegs();
698 
699         process->setSyscallArg(tc, 0, gtoh(attrp->registers.a0));
700         tc->setIntReg(27/*t12*/, gtoh(attrp->registers.pc));
701         tc->setIntReg(TheISA::StackPointerReg, gtoh(attrp->registers.sp));
702         tc->setMiscRegNoEffect(AlphaISA::MISCREG_UNIQ, uniq_val);
703 
704         tc->pcState(gtoh(attrp->registers.pc));
705 
706         tc->activate();
707     }
\end{DoxyCode}
\hypertarget{classTru64_a0553f30a35d45bbc6ba7fd2120332c9c}{
\index{Tru64@{Tru64}!m5\_\-cond\_\-broadcastFunc@{m5\_\-cond\_\-broadcastFunc}}
\index{m5\_\-cond\_\-broadcastFunc@{m5\_\-cond\_\-broadcastFunc}!Tru64@{Tru64}}
\subsubsection[{m5\_\-cond\_\-broadcastFunc}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf SyscallReturn} m5\_\-cond\_\-broadcastFunc ({\bf SyscallDesc} $\ast$ {\em desc}, \/  int {\em callnum}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_a0553f30a35d45bbc6ba7fd2120332c9c}


Wake up all processes waiting on the condition variable. 


\begin{DoxyCode}
1051     {
1052         int index = 0;
1053         Addr cond_addr = process->getSyscallArg(tc, index);
1054 
1055         activate_waiting_context(cond_addr, process, true);
1056 
1057         return 0;
1058     }
\end{DoxyCode}
\hypertarget{classTru64_acfc803d4984b3037abb896038e4f6fc1}{
\index{Tru64@{Tru64}!m5\_\-cond\_\-signalFunc@{m5\_\-cond\_\-signalFunc}}
\index{m5\_\-cond\_\-signalFunc@{m5\_\-cond\_\-signalFunc}!Tru64@{Tru64}}
\subsubsection[{m5\_\-cond\_\-signalFunc}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf SyscallReturn} m5\_\-cond\_\-signalFunc ({\bf SyscallDesc} $\ast$ {\em desc}, \/  int {\em callnum}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_acfc803d4984b3037abb896038e4f6fc1}


Signal ocndition. 


\begin{DoxyCode}
1037     {
1038         int index = 0;
1039         Addr cond_addr = process->getSyscallArg(tc, index);
1040 
1041         // Wake up one process waiting on the condition variable.
1042         activate_waiting_context(cond_addr, process);
1043 
1044         return 0;
1045     }
\end{DoxyCode}
\hypertarget{classTru64_a2c38b28b551cfcfe04f70cbfbff3a55e}{
\index{Tru64@{Tru64}!m5\_\-cond\_\-waitFunc@{m5\_\-cond\_\-waitFunc}}
\index{m5\_\-cond\_\-waitFunc@{m5\_\-cond\_\-waitFunc}!Tru64@{Tru64}}
\subsubsection[{m5\_\-cond\_\-waitFunc}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf SyscallReturn} m5\_\-cond\_\-waitFunc ({\bf SyscallDesc} $\ast$ {\em desc}, \/  int {\em callnum}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_a2c38b28b551cfcfe04f70cbfbff3a55e}


Wait on a condition. 


\begin{DoxyCode}
1064     {
1065         using namespace TheISA;
1066 
1067         int index = 0;
1068         Addr cond_addr = process->getSyscallArg(tc, index);
1069         Addr lock_addr = process->getSyscallArg(tc, index);
1070         TypedBufferArg<uint64_t> condp(cond_addr);
1071         TypedBufferArg<uint64_t> lockp(lock_addr);
1072 
1073         // user is supposed to acquire lock before entering
1074         lockp.copyIn(tc->getMemProxy());
1075         assert(gtoh(*lockp) != 0);
1076 
1077         m5_unlock_mutex(lock_addr, process, tc);
1078 
1079         process->waitList.push_back(Process::WaitRec(cond_addr, tc));
1080         tc->suspend();
1081 
1082         return 0;
1083     }
\end{DoxyCode}
\hypertarget{classTru64_a029c70f7b96e2ccaa00ea5252875de90}{
\index{Tru64@{Tru64}!m5\_\-lock\_\-mutex@{m5\_\-lock\_\-mutex}}
\index{m5\_\-lock\_\-mutex@{m5\_\-lock\_\-mutex}!Tru64@{Tru64}}
\subsubsection[{m5\_\-lock\_\-mutex}]{\setlength{\rightskip}{0pt plus 5cm}static void m5\_\-lock\_\-mutex ({\bf Addr} {\em uaddr}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_a029c70f7b96e2ccaa00ea5252875de90}


M5 hacked-\/up lock acquire. 


\begin{DoxyCode}
944     {
945         using namespace TheISA;
946 
947         TypedBufferArg<uint64_t> lockp(uaddr);
948 
949         lockp.copyIn(tc->getMemProxy());
950 
951         if (gtoh(*lockp) == 0) {
952             // lock is free: grab it
953             *lockp = htog(1);
954             lockp.copyOut(tc->getMemProxy());
955         } else {
956             // lock is busy: disable until free
957             process->waitList.push_back(Process::WaitRec(uaddr, tc));
958             tc->suspend();
959         }
960     }
\end{DoxyCode}
\hypertarget{classTru64_a5a1fd874973f006aecd51e98ce0b6579}{
\index{Tru64@{Tru64}!m5\_\-mutex\_\-lockFunc@{m5\_\-mutex\_\-lockFunc}}
\index{m5\_\-mutex\_\-lockFunc@{m5\_\-mutex\_\-lockFunc}!Tru64@{Tru64}}
\subsubsection[{m5\_\-mutex\_\-lockFunc}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf SyscallReturn} m5\_\-mutex\_\-lockFunc ({\bf SyscallDesc} $\ast$ {\em desc}, \/  int {\em callnum}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_a5a1fd874973f006aecd51e98ce0b6579}


Lock acquire syscall handler. 


\begin{DoxyCode}
985     {
986         int index = 0;
987         Addr uaddr = process->getSyscallArg(tc, index);
988 
989         m5_lock_mutex(uaddr, process, tc);
990 
991         // Return 0 since we will always return to the user with the lock
992         // acquired.  We will just keep the context inactive until that is
993         // true.
994         return 0;
995     }
\end{DoxyCode}
\hypertarget{classTru64_aa8d051ea34736b976895f70df5f48b9d}{
\index{Tru64@{Tru64}!m5\_\-mutex\_\-trylockFunc@{m5\_\-mutex\_\-trylockFunc}}
\index{m5\_\-mutex\_\-trylockFunc@{m5\_\-mutex\_\-trylockFunc}!Tru64@{Tru64}}
\subsubsection[{m5\_\-mutex\_\-trylockFunc}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf SyscallReturn} m5\_\-mutex\_\-trylockFunc ({\bf SyscallDesc} $\ast$ {\em desc}, \/  int {\em callnum}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_aa8d051ea34736b976895f70df5f48b9d}


Try lock (non-\/blocking). 


\begin{DoxyCode}
1001     {
1002         using namespace TheISA;
1003 
1004         int index = 0;
1005         Addr uaddr = process->getSyscallArg(tc, index);
1006         TypedBufferArg<uint64_t> lockp(uaddr);
1007 
1008         lockp.copyIn(tc->getMemProxy());
1009 
1010         if (gtoh(*lockp) == 0) {
1011             // lock is free: grab it
1012             *lockp = htog(1);
1013             lockp.copyOut(tc->getMemProxy());
1014             return 0;
1015         } else {
1016             return 1;
1017         }
1018     }
\end{DoxyCode}
\hypertarget{classTru64_a13ce77bfaa709faa1a3006cea0465959}{
\index{Tru64@{Tru64}!m5\_\-mutex\_\-unlockFunc@{m5\_\-mutex\_\-unlockFunc}}
\index{m5\_\-mutex\_\-unlockFunc@{m5\_\-mutex\_\-unlockFunc}!Tru64@{Tru64}}
\subsubsection[{m5\_\-mutex\_\-unlockFunc}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf SyscallReturn} m5\_\-mutex\_\-unlockFunc ({\bf SyscallDesc} $\ast$ {\em desc}, \/  int {\em callnum}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_a13ce77bfaa709faa1a3006cea0465959}


Unlock syscall handler. 


\begin{DoxyCode}
1024     {
1025         int index = 0;
1026         Addr uaddr = process->getSyscallArg(tc, index);
1027 
1028         m5_unlock_mutex(uaddr, process, tc);
1029 
1030         return 0;
1031     }
\end{DoxyCode}
\hypertarget{classTru64_a56f0a437d8a86b1220497375406a3f78}{
\index{Tru64@{Tru64}!m5\_\-thread\_\-exitFunc@{m5\_\-thread\_\-exitFunc}}
\index{m5\_\-thread\_\-exitFunc@{m5\_\-thread\_\-exitFunc}!Tru64@{Tru64}}
\subsubsection[{m5\_\-thread\_\-exitFunc}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf SyscallReturn} m5\_\-thread\_\-exitFunc ({\bf SyscallDesc} $\ast$ {\em desc}, \/  int {\em callnum}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_a56f0a437d8a86b1220497375406a3f78}


Thread exit. 


\begin{DoxyCode}
1089     {
1090         assert(tc->status() == ThreadContext::Active);
1091         tc->halt();
1092 
1093         return 0;
1094     }
\end{DoxyCode}
\hypertarget{classTru64_ac965ae70992f9a6f184c1e6f177e3b5b}{
\index{Tru64@{Tru64}!m5\_\-unlock\_\-mutex@{m5\_\-unlock\_\-mutex}}
\index{m5\_\-unlock\_\-mutex@{m5\_\-unlock\_\-mutex}!Tru64@{Tru64}}
\subsubsection[{m5\_\-unlock\_\-mutex}]{\setlength{\rightskip}{0pt plus 5cm}static void m5\_\-unlock\_\-mutex ({\bf Addr} {\em uaddr}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_ac965ae70992f9a6f184c1e6f177e3b5b}


M5 unlock call. 


\begin{DoxyCode}
965     {
966         TypedBufferArg<uint64_t> lockp(uaddr);
967 
968         lockp.copyIn(tc->getMemProxy());
969         assert(*lockp != 0);
970 
971         // Check for a process waiting on the lock.
972         int num_waiting = activate_waiting_context(uaddr, process);
973 
974         // clear lock field if no waiting context is taking over the lock
975         if (num_waiting == 0) {
976             *lockp = 0;
977             lockp.copyOut(tc->getMemProxy());
978         }
979     }
\end{DoxyCode}
\hypertarget{classTru64_ad497f5d8e1f57340b73ad9ea52b88dd3}{
\index{Tru64@{Tru64}!nxm\_\-blockFunc@{nxm\_\-blockFunc}}
\index{nxm\_\-blockFunc@{nxm\_\-blockFunc}!Tru64@{Tru64}}
\subsubsection[{nxm\_\-blockFunc}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf SyscallReturn} nxm\_\-blockFunc ({\bf SyscallDesc} $\ast$ {\em desc}, \/  int {\em callnum}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_ad497f5d8e1f57340b73ad9ea52b88dd3}


block. 


\begin{DoxyCode}
857     {
858         using namespace std;
859 
860         int index = 0;
861         Addr uaddr = process->getSyscallArg(tc, index);
862         uint64_t val = process->getSyscallArg(tc, index);
863         uint64_t secs = process->getSyscallArg(tc, index);
864         uint64_t usecs = process->getSyscallArg(tc, index);
865         uint64_t flags = process->getSyscallArg(tc, index);
866 
867         BaseCPU *cpu = tc->getCpuPtr();
868 
869         cout << cpu->name() << ": nxm_block "
870              << hex << uaddr << dec << " " << val
871              << " " << secs << " " << usecs
872              << " " << flags << endl;
873 
874         return 0;
875     }
\end{DoxyCode}
\hypertarget{classTru64_a7d672681a6c03ce2f3d8e64b159d23d7}{
\index{Tru64@{Tru64}!nxm\_\-idleFunc@{nxm\_\-idleFunc}}
\index{nxm\_\-idleFunc@{nxm\_\-idleFunc}!Tru64@{Tru64}}
\subsubsection[{nxm\_\-idleFunc}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf SyscallReturn} nxm\_\-idleFunc ({\bf SyscallDesc} $\ast$ {\em desc}, \/  int {\em callnum}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_a7d672681a6c03ce2f3d8e64b159d23d7}


Thread idle call (like yield()). 


\begin{DoxyCode}
829     {
830         return 0;
831     }
\end{DoxyCode}
\hypertarget{classTru64_a7393c42ceaadfe69e71c4cab0d059968}{
\index{Tru64@{Tru64}!nxm\_\-task\_\-initFunc@{nxm\_\-task\_\-initFunc}}
\index{nxm\_\-task\_\-initFunc@{nxm\_\-task\_\-initFunc}!Tru64@{Tru64}}
\subsubsection[{nxm\_\-task\_\-initFunc}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf SyscallReturn} nxm\_\-task\_\-initFunc ({\bf SyscallDesc} $\ast$ {\em desc}, \/  int {\em callnum}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_a7393c42ceaadfe69e71c4cab0d059968}
This call sets up the interface between the user and kernel schedulers by creating a shared-\/memory region. The shared memory region has several structs, some global, some per-\/RAD, some per-\/VP. 


\begin{DoxyCode}
579     {
580         using namespace std;
581         using namespace TheISA;
582 
583         int index = 0;
584         TypedBufferArg<Tru64::nxm_task_attr>
585             attrp(process->getSyscallArg(tc, index));
586         TypedBufferArg<Addr> configptr_ptr(process->getSyscallArg(tc, index));
587 
588         attrp.copyIn(tc->getMemProxy());
589 
590         if (gtoh(attrp->nxm_version) != NXM_LIB_VERSION) {
591             cerr << "nxm_task_init: thread library version mismatch! "
592                  << "got " << attrp->nxm_version
593                  << ", expected " << NXM_LIB_VERSION << endl;
594             abort();
595         }
596 
597         if (gtoh(attrp->flags) != Tru64::NXM_TASK_INIT_VP) {
598             cerr << "nxm_task_init: bad flag value " << attrp->flags
599                  << " (expected " << Tru64::NXM_TASK_INIT_VP << ")" << endl;
600             abort();
601         }
602 
603         Addr base_addr = 0x12000; // was 0x3f0000000LL;
604         Addr cur_addr = base_addr; // next addresses to use
605         // first comes the config_info struct
606         Addr config_addr = cur_addr;
607         cur_addr += sizeof(Tru64::nxm_config_info);
608         // next comes the per-cpu state vector
609         Addr slot_state_addr = cur_addr;
610         int slot_state_size =
611             process->numCpus() * sizeof(Tru64::nxm_slot_state_t);
612         cur_addr += slot_state_size;
613         // now the per-RAD state struct (we only support one RAD)
614         cur_addr = 0x14000;     // bump up addr for alignment
615         Addr rad_state_addr = cur_addr;
616         int rad_state_size =
617             (sizeof(Tru64::nxm_shared)
618              + (process->numCpus()-1) * sizeof(Tru64::nxm_sched_state));
619         cur_addr += rad_state_size;
620 
621         // now initialize a config_info struct and copy it out to user space
622         TypedBufferArg<Tru64::nxm_config_info> config(config_addr);
623 
624         config->nxm_nslots_per_rad = htog(process->numCpus());
625         config->nxm_nrads = htog(1);    // only one RAD in our system!
626         config->nxm_slot_state = htog(slot_state_addr);
627         config->nxm_rad[0] = htog(rad_state_addr);
628 
629         // initialize the slot_state array and copy it out
630         TypedBufferArg<Tru64::nxm_slot_state_t> slot_state(slot_state_addr,
631                                                            slot_state_size);
632         for (int i = 0; i < process->numCpus(); ++i) {
633             // CPU 0 is bound to the calling process; all others are available
634             // XXX this code should have an endian conversion, but I don't think
635             // it works anyway
636             slot_state[i] =
637                 (i == 0) ? Tru64::NXM_SLOT_BOUND : Tru64::NXM_SLOT_AVAIL;
638         }
639 
640         // same for the per-RAD "shared" struct.  Note that we need to
641         // allocate extra bytes for the per-VP array which is embedded at
642         // the end.
643         TypedBufferArg<Tru64::nxm_shared> rad_state(rad_state_addr,
644                                                     rad_state_size);
645 
646         rad_state->nxm_callback = attrp->nxm_callback;
647         rad_state->nxm_version = attrp->nxm_version;
648         rad_state->nxm_uniq_offset = attrp->nxm_uniq_offset;
649         for (int i = 0; i < process->numCpus(); ++i) {
650             Tru64::nxm_sched_state *ssp = &rad_state->nxm_ss[i];
651             ssp->nxm_u.sigmask = htog(0);
652             ssp->nxm_u.sig = htog(0);
653             ssp->nxm_u.flags = htog(0);
654             ssp->nxm_u.cancel_state = htog(0);
655             ssp->nxm_u.nxm_ssig = 0;
656             ssp->nxm_bits = htog(0);
657             ssp->nxm_quantum = attrp->nxm_quantum;
658             ssp->nxm_set_quantum = attrp->nxm_quantum;
659             ssp->nxm_sysevent = htog(0);
660 
661             if (i == 0) {
662                 uint64_t uniq = tc->readMiscRegNoEffect(AlphaISA::MISCREG_UNIQ);
663                 ssp->nxm_u.pth_id = htog(uniq + gtoh(attrp->nxm_uniq_offset));
664                 ssp->nxm_u.nxm_active = htog(uniq | 1);
665             }
666             else {
667                 ssp->nxm_u.pth_id = htog(0);
668                 ssp->nxm_u.nxm_active = htog(0);
669             }
670         }
671 
672         //
673         // copy pointer to shared config area out to user
674         //
675         *configptr_ptr = htog(config_addr);
676 
677         // Register this as a valid address range with the process
678         base_addr = roundDown(base_addr, VMPageSize);
679         int size = cur_addr - base_addr;
680         process->allocateMem(base_addr, roundUp(size, VMPageSize));
681 
682         config.copyOut(tc->getMemProxy());
683         slot_state.copyOut(tc->getMemProxy());
684         rad_state.copyOut(tc->getMemProxy());
685         configptr_ptr.copyOut(tc->getMemProxy());
686 
687         return 0;
688     }
\end{DoxyCode}
\hypertarget{classTru64_a05e8a076d0c534c96b680a3661fc9003}{
\index{Tru64@{Tru64}!nxm\_\-thread\_\-blockFunc@{nxm\_\-thread\_\-blockFunc}}
\index{nxm\_\-thread\_\-blockFunc@{nxm\_\-thread\_\-blockFunc}!Tru64@{Tru64}}
\subsubsection[{nxm\_\-thread\_\-blockFunc}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf SyscallReturn} nxm\_\-thread\_\-blockFunc ({\bf SyscallDesc} $\ast$ {\em desc}, \/  int {\em callnum}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_a05e8a076d0c534c96b680a3661fc9003}


Block thread. 


\begin{DoxyCode}
837     {
838         using namespace std;
839 
840         int index = 0;
841         uint64_t tid = process->getSyscallArg(tc, index);
842         uint64_t secs = process->getSyscallArg(tc, index);
843         uint64_t flags = process->getSyscallArg(tc, index);
844         uint64_t action = process->getSyscallArg(tc, index);
845         uint64_t usecs = process->getSyscallArg(tc, index);
846 
847         cout << tc->getCpuPtr()->name() << ": nxm_thread_block " << tid << " "
848              << secs << " " << flags << " " << action << " " << usecs << endl;
849 
850         return 0;
851     }
\end{DoxyCode}
\hypertarget{classTru64_a56167e2aed868ff95f0864b9075adab1}{
\index{Tru64@{Tru64}!nxm\_\-thread\_\-createFunc@{nxm\_\-thread\_\-createFunc}}
\index{nxm\_\-thread\_\-createFunc@{nxm\_\-thread\_\-createFunc}!Tru64@{Tru64}}
\subsubsection[{nxm\_\-thread\_\-createFunc}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf SyscallReturn} nxm\_\-thread\_\-createFunc ({\bf SyscallDesc} $\ast$ {\em desc}, \/  int {\em callnum}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_a56167e2aed868ff95f0864b9075adab1}


Create thread. 


\begin{DoxyCode}
713     {
714         using namespace std;
715         using namespace TheISA;
716 
717         int index = 0;
718         TypedBufferArg<Tru64::nxm_thread_attr>
719             attrp(process->getSyscallArg(tc, index));
720         TypedBufferArg<uint64_t> kidp(process->getSyscallArg(tc, index));
721         int thread_index = process->getSyscallArg(tc, index);
722 
723         // get attribute args
724         attrp.copyIn(tc->getMemProxy());
725 
726         if (gtoh(attrp->version) != NXM_LIB_VERSION) {
727             cerr << "nxm_thread_create: thread library version mismatch! "
728                  << "got " << attrp->version
729                  << ", expected " << NXM_LIB_VERSION << endl;
730             abort();
731         }
732 
733         if (thread_index < 0 || thread_index > process->numCpus()) {
734             cerr << "nxm_thread_create: bad thread index " << thread_index
735                  << endl;
736             abort();
737         }
738 
739         // On a real machine, the per-RAD shared structure is in
740         // shared memory, so both the user and kernel can get at it.
741         // We don't have that luxury, so we just copy it in and then
742         // back out again.
743         int rad_state_size =
744             (sizeof(Tru64::nxm_shared) +
745              (process->numCpus()-1) * sizeof(Tru64::nxm_sched_state));
746 
747         TypedBufferArg<Tru64::nxm_shared> rad_state(0x14000,
748                                                     rad_state_size);
749         rad_state.copyIn(tc->getMemProxy());
750 
751         uint64_t uniq_val = gtoh(attrp->pthid) - gtoh(rad_state->nxm_uniq_offset)
      ;
752 
753         if (gtoh(attrp->type) == Tru64::NXM_TYPE_MANAGER) {
754             // DEC pthreads seems to always create one of these (in
755             // addition to N application threads), but we don't use it,
756             // so don't bother creating it.
757 
758             // This is supposed to be a port number.  Make something up.
759             *kidp = htog(99);
760             kidp.copyOut(tc->getMemProxy());
761 
762             return 0;
763         } else if (gtoh(attrp->type) == Tru64::NXM_TYPE_VP) {
764             // A real "virtual processor" kernel thread.  Need to fork
765             // this thread on another CPU.
766             Tru64::nxm_sched_state *ssp = &rad_state->nxm_ss[thread_index];
767 
768             if (gtoh(ssp->nxm_u.nxm_active) != 0)
769                 return (int) Tru64::KERN_NOT_RECEIVER;
770 
771             ssp->nxm_u.pth_id = attrp->pthid;
772             ssp->nxm_u.nxm_active = htog(uniq_val | 1);
773 
774             rad_state.copyOut(tc->getMemProxy());
775 
776             Addr slot_state_addr = 0x12000 + sizeof(Tru64::nxm_config_info);
777             int slot_state_size =
778                 process->numCpus() * sizeof(Tru64::nxm_slot_state_t);
779 
780             TypedBufferArg<Tru64::nxm_slot_state_t>
781                 slot_state(slot_state_addr,
782                            slot_state_size);
783 
784             slot_state.copyIn(tc->getMemProxy());
785 
786             if (slot_state[thread_index] != Tru64::NXM_SLOT_AVAIL) {
787                 cerr << "nxm_thread_createFunc: requested VP slot "
788                      << thread_index << " not available!" << endl;
789                 fatal("");
790             }
791 
792             // XXX This should have an endian conversion but I think this code
793             // doesn't work anyway
794             slot_state[thread_index] = Tru64::NXM_SLOT_BOUND;
795 
796             slot_state.copyOut(tc->getMemProxy());
797 
798             // Find a free simulator thread context.
799             ThreadContext *tc = process->findFreeContext();
800             if (tc) {
801                 // inactive context... grab it
802                 init_thread_context(process, tc, attrp, uniq_val);
803 
804                 // This is supposed to be a port number, but we'll try
805                 // and get away with just sticking the thread index
806                 // here.
807                 *kidp = htog(thread_index);
808                 kidp.copyOut(tc->getMemProxy());
809 
810                 return 0;
811             }
812 
813             // fell out of loop... no available inactive context
814             cerr << "nxm_thread_create: no idle contexts available." << endl;
815             abort();
816         } else {
817             cerr << "nxm_thread_create: can't handle thread type "
818                  << attrp->type << endl;
819             abort();
820         }
821 
822         return 0;
823     }
\end{DoxyCode}
\hypertarget{classTru64_abdd09a9b9645e7199d23afbdae212ef6}{
\index{Tru64@{Tru64}!nxm\_\-unblockFunc@{nxm\_\-unblockFunc}}
\index{nxm\_\-unblockFunc@{nxm\_\-unblockFunc}!Tru64@{Tru64}}
\subsubsection[{nxm\_\-unblockFunc}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf SyscallReturn} nxm\_\-unblockFunc ({\bf SyscallDesc} $\ast$ {\em desc}, \/  int {\em callnum}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_abdd09a9b9645e7199d23afbdae212ef6}


Unblock thread. 


\begin{DoxyCode}
881     {
882         using namespace std;
883 
884         int index = 0;
885         Addr uaddr = process->getSyscallArg(tc, index);
886 
887         cout << tc->getCpuPtr()->name() << ": nxm_unblock "
888              << hex << uaddr << dec << endl;
889 
890         return 0;
891     }
\end{DoxyCode}
\hypertarget{classTru64_a368f998d81d17c06f2fb1639683f8302}{
\index{Tru64@{Tru64}!sigreturnFunc@{sigreturnFunc}}
\index{sigreturnFunc@{sigreturnFunc}!Tru64@{Tru64}}
\subsubsection[{sigreturnFunc}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf SyscallReturn} sigreturnFunc ({\bf SyscallDesc} $\ast$ {\em desc}, \/  int {\em callnum}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_a368f998d81d17c06f2fb1639683f8302}


Target sigreturn() handler. 


\begin{DoxyCode}
496     {
497         using namespace TheISA;
498 
499         int index = 0;
500         TypedBufferArg<Tru64::sigcontext> sc(process->getSyscallArg(tc, index));
501 
502         sc.copyIn(tc->getMemProxy());
503 
504         // Restore state from sigcontext structure.
505         // Note that we'll advance PC <- NPC before the end of the cycle,
506         // so we need to restore the desired PC into NPC.
507         // The current regs->pc will get clobbered.
508         PCState pc = tc->pcState();
509         pc.npc(htog(sc->sc_pc));
510         tc->pcState(pc);
511 
512         for (int i = 0; i < 31; ++i) {
513             tc->setIntReg(i, htog(sc->sc_regs[i]));
514             tc->setFloatRegBits(i, htog(sc->sc_fpregs[i]));
515         }
516 
517         tc->setMiscRegNoEffect(AlphaISA::MISCREG_FPCR, htog(sc->sc_fpcr));
518 
519         return 0;
520     }
\end{DoxyCode}
\hypertarget{classTru64_ac6e3676ee42b0ad6a609f36f0cf654bb}{
\index{Tru64@{Tru64}!stack\_\-createFunc@{stack\_\-createFunc}}
\index{stack\_\-createFunc@{stack\_\-createFunc}!Tru64@{Tru64}}
\subsubsection[{stack\_\-createFunc}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf SyscallReturn} stack\_\-createFunc ({\bf SyscallDesc} $\ast$ {\em desc}, \/  int {\em callnum}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_ac6e3676ee42b0ad6a609f36f0cf654bb}


Create a stack region for a thread. 


\begin{DoxyCode}
531     {
532         using namespace TheISA;
533 
534         int index = 0;
535         TypedBufferArg<Tru64::vm_stack> argp(process->getSyscallArg(tc, index));
536 
537         argp.copyIn(tc->getMemProxy());
538 
539         int stack_size =
540             gtoh(argp->rsize) + gtoh(argp->ysize) + gtoh(argp->gsize);
541 
542         // if the user chose an address, just let them have it.  Otherwise
543         // pick one for them.
544         Addr stack_base = gtoh(argp->address);
545 
546         if (stack_base == 0) {
547             stack_base = process->next_thread_stack_base;
548             process->next_thread_stack_base -= stack_size;
549         }
550 
551         Addr rounded_stack_base = roundDown(stack_base, VMPageSize);
552         Addr rounded_stack_size = roundUp(stack_size, VMPageSize);
553 
554         DPRINTF(SyscallVerbose,
555                 "stack_create: allocating stack @ %#x size %#x "
556                 "(rounded from %#x, %#x)\n",
557                 rounded_stack_base, rounded_stack_size,
558                 stack_base, stack_size);
559 
560         // map memory
561         process->allocateMem(rounded_stack_base, rounded_stack_size);
562 
563         argp->address = gtoh(rounded_stack_base);
564         argp.copyOut(tc->getMemProxy());
565 
566         return 0;
567     }
\end{DoxyCode}
\hypertarget{classTru64_a447627b7d2862dbc933f4d4a4433cd4c}{
\index{Tru64@{Tru64}!swtch\_\-priFunc@{swtch\_\-priFunc}}
\index{swtch\_\-priFunc@{swtch\_\-priFunc}!Tru64@{Tru64}}
\subsubsection[{swtch\_\-priFunc}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf SyscallReturn} swtch\_\-priFunc ({\bf SyscallDesc} $\ast$ {\em desc}, \/  int {\em callnum}, \/  {\bf LiveProcess} $\ast$ {\em process}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classTru64_a447627b7d2862dbc933f4d4a4433cd4c}


\hyperlink{classSwitch}{Switch} thread priority. 


\begin{DoxyCode}
897     {
898         // Attempts to switch to another runnable thread (if there is
899         // one).  Returns false if there are no other threads to run
900         // (i.e., the thread can reasonably spin-wait) or true if there
901         // are other threads.
902         //
903         // Since we assume at most one "kernel" thread per CPU, it's
904         // always safe to return false here.
905         return 0; //false;
906     }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classTru64_a1a19d4c9718c9a4ad5fa2e48271fccc9}{
\index{Tru64@{Tru64}!\_\-SYS\_\-NMLN@{\_\-SYS\_\-NMLN}}
\index{\_\-SYS\_\-NMLN@{\_\-SYS\_\-NMLN}!Tru64@{Tru64}}
\subsubsection[{\_\-SYS\_\-NMLN}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf \_\-SYS\_\-NMLN} = 32\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classTru64_a1a19d4c9718c9a4ad5fa2e48271fccc9}


Length of strings in struct \hyperlink{structTru64_1_1utsname}{utsname} (plus 1 for null char). 

\hyperlink{classOperatingSystem_a1a19d4c9718c9a4ad5fa2e48271fccc9}{OperatingSystem}を再定義しています。\hypertarget{classTru64_aad01339e89106fdf68f57ef118956fa9}{
\index{Tru64@{Tru64}!hostname@{hostname}}
\index{hostname@{hostname}!Tru64@{Tru64}}
\subsubsection[{hostname}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ {\bf hostname}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classTru64_aad01339e89106fdf68f57ef118956fa9}


The target system's hostname. \hypertarget{classTru64_a42f5e6243e70c3d99afed9a0ab5ac3c1}{
\index{Tru64@{Tru64}!NXM\_\-LIB\_\-VERSION@{NXM\_\-LIB\_\-VERSION}}
\index{NXM\_\-LIB\_\-VERSION@{NXM\_\-LIB\_\-VERSION}!Tru64@{Tru64}}
\subsubsection[{NXM\_\-LIB\_\-VERSION}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf NXM\_\-LIB\_\-VERSION} = 301003\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classTru64_a42f5e6243e70c3d99afed9a0ab5ac3c1}


NXM library version stamp. \hypertarget{classTru64_a284276950ab5fbb4ed5432a4fe77c0b4}{
\index{Tru64@{Tru64}!NXM\_\-TASK\_\-INIT\_\-VP@{NXM\_\-TASK\_\-INIT\_\-VP}}
\index{NXM\_\-TASK\_\-INIT\_\-VP@{NXM\_\-TASK\_\-INIT\_\-VP}!Tru64@{Tru64}}
\subsubsection[{NXM\_\-TASK\_\-INIT\_\-VP}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf NXM\_\-TASK\_\-INIT\_\-VP} = 2\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classTru64_a284276950ab5fbb4ed5432a4fe77c0b4}


For nxm\_\-task\_\-init. initial thread is VP 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
kern/tru64/\hyperlink{kern_2tru64_2tru64_8hh}{tru64.hh}\end{DoxyCompactItemize}
