\hypertarget{classTimingSimpleCPU}{
\section{クラス TimingSimpleCPU}
\label{classTimingSimpleCPU}\index{TimingSimpleCPU@{TimingSimpleCPU}}
}


{\ttfamily \#include $<$timing.hh$>$}TimingSimpleCPUに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classTimingSimpleCPU}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classTimingSimpleCPU_1_1DcachePort}{DcachePort}
\item 
class \hyperlink{classTimingSimpleCPU_1_1FetchTranslation}{FetchTranslation}
\item 
class \hyperlink{classTimingSimpleCPU_1_1IcachePort}{IcachePort}
\item 
struct \hyperlink{structTimingSimpleCPU_1_1IprEvent}{IprEvent}
\item 
class \hyperlink{classTimingSimpleCPU_1_1SplitFragmentSenderState}{SplitFragmentSenderState}
\item 
class \hyperlink{classTimingSimpleCPU_1_1SplitMainSenderState}{SplitMainSenderState}
\item 
class \hyperlink{classTimingSimpleCPU_1_1TimingCPUPort}{TimingCPUPort}
\item 
class \hyperlink{classTimingSimpleCPU_1_1TimingSimpleCPU}{TimingSimpleCPU}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classTimingSimpleCPU_a6d8b5c088e0456abaaf000e46e346319}{TimingSimpleCPU} (TimingSimpleCPUParams $\ast$params)
\item 
virtual \hyperlink{classTimingSimpleCPU_a637e8aedb9fa159bd5480f48e6574832}{$\sim$TimingSimpleCPU} ()
\item 
virtual void \hyperlink{classTimingSimpleCPU_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
unsigned int \hyperlink{classTimingSimpleCPU_a4e932bfc8aa6dfb998b8496a0f04ace3}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$drain\_\-manager)
\item 
void \hyperlink{classTimingSimpleCPU_a8f020d3237536fe007fc488c4125c5d8}{drainResume} ()
\item 
void \hyperlink{classTimingSimpleCPU_a05f299b443f8cc73a93d61572edc0218}{switchOut} ()
\item 
void \hyperlink{classTimingSimpleCPU_ac82d2b8d331b2e8e6854a95d2917dfa2}{takeOverFrom} (\hyperlink{classBaseCPU_1_1BaseCPU}{BaseCPU} $\ast$oldCPU)
\item 
void \hyperlink{classTimingSimpleCPU_ae2e1ccebe596a180f8105d57f9a93645}{verifyMemoryMode} () const 
\item 
virtual void \hyperlink{classTimingSimpleCPU_ad7a501b28bdbe8b3e708cd1ef69ac191}{activateContext} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} thread\_\-num, \hyperlink{classCycles}{Cycles} delay)
\item 
virtual void \hyperlink{classTimingSimpleCPU_a1dad4c4d2c3df4ef367e14fcc973ce74}{suspendContext} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} thread\_\-num)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classTimingSimpleCPU_a66191b2d8a45050b7df3c3efa7bb07c6}{readMem} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, uint8\_\-t $\ast$data, unsigned size, unsigned flags)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classTimingSimpleCPU_ad46c5edeb1ee9b60445f3e26364e2c5e}{writeMem} (uint8\_\-t $\ast$data, unsigned size, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, unsigned flags, uint64\_\-t $\ast$res)
\item 
void \hyperlink{classTimingSimpleCPU_a3865f8ea93e31d9b5d2726a80c0de966}{fetch} ()
\item 
void \hyperlink{classTimingSimpleCPU_a9c1e81509746ac06253e334c436e1a75}{sendFetch} (\hyperlink{classRefCountingPtr}{Fault} fault, \hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{classBaseSimpleCPU_a4455a4759e69e5ebe68ae7298cbcc37d}{tc})
\item 
void \hyperlink{classTimingSimpleCPU_a20b41c38922ef954c7e338f67bba971f}{completeIfetch} (\hyperlink{classPacket}{PacketPtr})
\item 
void \hyperlink{classTimingSimpleCPU_a0f7f0d3412bbf494cd3d0c0f48e5fcf2}{completeDataAccess} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classTimingSimpleCPU_ab1a431d7af8dd2bbc95d09bd71be13ca}{advanceInst} (\hyperlink{classRefCountingPtr}{Fault} fault)
\item 
bool \hyperlink{classTimingSimpleCPU_add8df091bd836cf92c6987990d130b83}{isSquashed} () const 
\item 
void \hyperlink{classTimingSimpleCPU_a88aa41e2693dd0091afae2604eba9bed}{printAddr} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} a)
\item 
void \hyperlink{classTimingSimpleCPU_a36c2a28eca3086b67fc7168a37367e98}{finishTranslation} (\hyperlink{classWholeTranslationState}{WholeTranslationState} $\ast$state)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{classMasterPort}{MasterPort} \& \hyperlink{classTimingSimpleCPU_aeea6b55ae1c4be53c21dbee434b221d4}{getDataPort} ()
\item 
virtual \hyperlink{classMasterPort}{MasterPort} \& \hyperlink{classTimingSimpleCPU_a40da530cb5dd380fd7fc0d786e94d5eb}{getInstPort} ()
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classTimingSimpleCPU_1_1TimingSimpleCPU}{TimingSimpleCPU},\&TimingSimpleCPU::fetch $>$ \hyperlink{classTimingSimpleCPU_a270bc6f239eb2eb58adf45357010a894}{FetchEvent}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classTimingSimpleCPU_ad6486c2f7c95532e093a31f013b36fe5}{sendData} (\hyperlink{classRequest}{RequestPtr} req, uint8\_\-t $\ast$data, uint64\_\-t $\ast$res, bool read)
\item 
void \hyperlink{classTimingSimpleCPU_a0894ae25efe60dc7855c057cab1684f9}{sendSplitData} (\hyperlink{classRequest}{RequestPtr} req1, \hyperlink{classRequest}{RequestPtr} req2, \hyperlink{classRequest}{RequestPtr} req, uint8\_\-t $\ast$data, bool read)
\item 
void \hyperlink{classTimingSimpleCPU_a5f6223adc354c36cc8773251dd7e0f4d}{translationFault} (\hyperlink{classRefCountingPtr}{Fault} fault)
\item 
void \hyperlink{classTimingSimpleCPU_aefe7c644107e54e9aa677838cd1a947f}{buildPacket} (\hyperlink{classPacket}{PacketPtr} \&pkt, \hyperlink{classRequest}{RequestPtr} req, bool read)
\item 
void \hyperlink{classTimingSimpleCPU_a1a7d0ff7c4efb80ffd4f53439b2291f8}{buildSplitPacket} (\hyperlink{classPacket}{PacketPtr} \&pkt1, \hyperlink{classPacket}{PacketPtr} \&pkt2, \hyperlink{classRequest}{RequestPtr} req1, \hyperlink{classRequest}{RequestPtr} req2, \hyperlink{classRequest}{RequestPtr} req, uint8\_\-t $\ast$data, bool read)
\item 
bool \hyperlink{classTimingSimpleCPU_a9a8beb0dcad34e8759794cea6639f715}{handleReadPacket} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classTimingSimpleCPU_a8d70b3b102cd0f4949ae31e84ee2eb98}{handleWritePacket} ()
\item 
bool \hyperlink{classTimingSimpleCPU_ac166e5bc3ddf730beb1282cf821096ae}{isDrained} ()
\item 
bool \hyperlink{classTimingSimpleCPU_abfea8f75a7a7480716801affeebbe87b}{tryCompleteDrain} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classTimingSimpleCPU_1_1FetchTranslation}{FetchTranslation} \hyperlink{classTimingSimpleCPU_abc9a320383d8f8241113fe01f333d5ca}{fetchTranslation}
\item 
\hyperlink{classTimingSimpleCPU_1_1IcachePort}{IcachePort} \hyperlink{classTimingSimpleCPU_a290723656a84b9cc90dfce377af9aad0}{icachePort}
\item 
\hyperlink{classTimingSimpleCPU_1_1DcachePort}{DcachePort} \hyperlink{classTimingSimpleCPU_a38b03978ad7720fdc910ff6a8b44585f}{dcachePort}
\item 
\hyperlink{classPacket}{PacketPtr} \hyperlink{classTimingSimpleCPU_a82097539e30887f0ad11d7a218c5bcca}{ifetch\_\-pkt}
\item 
\hyperlink{classPacket}{PacketPtr} \hyperlink{classTimingSimpleCPU_a8cdf6dfb358a155d5422c09f961297fe}{dcache\_\-pkt}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classTimingSimpleCPU_acb8e08ce453c8db11437d6cf9b0167bf}{previousCycle}
\item 
\hyperlink{classEventWrapper}{FetchEvent} \hyperlink{classTimingSimpleCPU_a17e7c383c8fb3d4dc450d79c15dd1061}{fetchEvent}
\item 
\hyperlink{classDrainManager}{DrainManager} $\ast$ \hyperlink{classTimingSimpleCPU_a329b71fb934a93312ca0aacbf5a3f982}{drainManager}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classTimingSimpleCPU_a270bc6f239eb2eb58adf45357010a894}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!FetchEvent@{FetchEvent}}
\index{FetchEvent@{FetchEvent}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{FetchEvent}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf EventWrapper}$<${\bf TimingSimpleCPU}, \&TimingSimpleCPU::fetch$>$ {\bf FetchEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTimingSimpleCPU_a270bc6f239eb2eb58adf45357010a894}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classTimingSimpleCPU_a6d8b5c088e0456abaaf000e46e346319}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!TimingSimpleCPU@{TimingSimpleCPU}}
\index{TimingSimpleCPU@{TimingSimpleCPU}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{TimingSimpleCPU}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimingSimpleCPU} (TimingSimpleCPUParams $\ast$ {\em params})}}
\label{classTimingSimpleCPU_a6d8b5c088e0456abaaf000e46e346319}



\begin{DoxyCode}
89     : BaseSimpleCPU(p), fetchTranslation(this), icachePort(this),
90       dcachePort(this), ifetch_pkt(NULL), dcache_pkt(NULL), previousCycle(0),
91       fetchEvent(this), drainManager(NULL)
92 {
93     _status = Idle;
94 
95     system->totalNumInsts = 0;
96 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a637e8aedb9fa159bd5480f48e6574832}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!$\sim$TimingSimpleCPU@{$\sim$TimingSimpleCPU}}
\index{$\sim$TimingSimpleCPU@{$\sim$TimingSimpleCPU}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{$\sim$TimingSimpleCPU}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf TimingSimpleCPU} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTimingSimpleCPU_a637e8aedb9fa159bd5480f48e6574832}



\begin{DoxyCode}
101 {
102 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classTimingSimpleCPU_ad7a501b28bdbe8b3e708cd1ef69ac191}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!activateContext@{activateContext}}
\index{activateContext@{activateContext}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{activateContext}]{\setlength{\rightskip}{0pt plus 5cm}void activateContext ({\bf ThreadID} {\em thread\_\-num}, \/  {\bf Cycles} {\em delay})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTimingSimpleCPU_ad7a501b28bdbe8b3e708cd1ef69ac191}



\begin{DoxyCode}
204 {
205     DPRINTF(SimpleCPU, "ActivateContext %d (%d cycles)\n", thread_num, delay);
206 
207     assert(thread_num == 0);
208     assert(thread);
209 
210     assert(_status == Idle);
211 
212     notIdleFraction = 1;
213     _status = BaseSimpleCPU::Running;
214 
215     // kick things off by initiating the fetch of the next instruction
216     schedule(fetchEvent, clockEdge(delay));
217 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_ab1a431d7af8dd2bbc95d09bd71be13ca}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!advanceInst@{advanceInst}}
\index{advanceInst@{advanceInst}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{advanceInst}]{\setlength{\rightskip}{0pt plus 5cm}void advanceInst ({\bf Fault} {\em fault})}}
\label{classTimingSimpleCPU_ab1a431d7af8dd2bbc95d09bd71be13ca}



\begin{DoxyCode}
625 {
626     if (_status == Faulting)
627         return;
628 
629     if (fault != NoFault) {
630         advancePC(fault);
631         DPRINTF(SimpleCPU, "Fault occured, scheduling fetch event\n");
632         reschedule(fetchEvent, clockEdge(), true);
633         _status = Faulting;
634         return;
635     }
636 
637 
638     if (!stayAtPC)
639         advancePC(fault);
640 
641     if (tryCompleteDrain())
642             return;
643 
644     if (_status == BaseSimpleCPU::Running) {
645         // kick off fetch of next instruction... callback from icache
646         // response will cause that instruction to be executed,
647         // keeping the CPU running.
648         fetch();
649     }
650 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_aefe7c644107e54e9aa677838cd1a947f}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!buildPacket@{buildPacket}}
\index{buildPacket@{buildPacket}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{buildPacket}]{\setlength{\rightskip}{0pt plus 5cm}void buildPacket ({\bf PacketPtr} \& {\em pkt}, \/  {\bf RequestPtr} {\em req}, \/  bool {\em read})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTimingSimpleCPU_aefe7c644107e54e9aa677838cd1a947f}



\begin{DoxyCode}
351 {
352     MemCmd cmd;
353     if (read) {
354         cmd = MemCmd::ReadReq;
355         if (req->isLLSC())
356             cmd = MemCmd::LoadLockedReq;
357     } else {
358         cmd = MemCmd::WriteReq;
359         if (req->isLLSC()) {
360             cmd = MemCmd::StoreCondReq;
361         } else if (req->isSwap()) {
362             cmd = MemCmd::SwapReq;
363         }
364     }
365     pkt = new Packet(req, cmd);
366 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a1a7d0ff7c4efb80ffd4f53439b2291f8}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!buildSplitPacket@{buildSplitPacket}}
\index{buildSplitPacket@{buildSplitPacket}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{buildSplitPacket}]{\setlength{\rightskip}{0pt plus 5cm}void buildSplitPacket ({\bf PacketPtr} \& {\em pkt1}, \/  {\bf PacketPtr} \& {\em pkt2}, \/  {\bf RequestPtr} {\em req1}, \/  {\bf RequestPtr} {\em req2}, \/  {\bf RequestPtr} {\em req}, \/  uint8\_\-t $\ast$ {\em data}, \/  bool {\em read})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTimingSimpleCPU_a1a7d0ff7c4efb80ffd4f53439b2291f8}



\begin{DoxyCode}
372 {
373     pkt1 = pkt2 = NULL;
374 
375     assert(!req1->isMmappedIpr() && !req2->isMmappedIpr());
376 
377     if (req->getFlags().isSet(Request::NO_ACCESS)) {
378         buildPacket(pkt1, req, read);
379         return;
380     }
381 
382     buildPacket(pkt1, req1, read);
383     buildPacket(pkt2, req2, read);
384 
385     req->setPhys(req1->getPaddr(), req->getSize(), req1->getFlags(), dataMasterId
      ());
386     PacketPtr pkt = new Packet(req, pkt1->cmd.responseCommand());
387 
388     pkt->dataDynamicArray<uint8_t>(data);
389     pkt1->dataStatic<uint8_t>(data);
390     pkt2->dataStatic<uint8_t>(data + req1->getSize());
391 
392     SplitMainSenderState * main_send_state = new SplitMainSenderState;
393     pkt->senderState = main_send_state;
394     main_send_state->fragments[0] = pkt1;
395     main_send_state->fragments[1] = pkt2;
396     main_send_state->outstanding = 2;
397     pkt1->senderState = new SplitFragmentSenderState(pkt, 0);
398     pkt2->senderState = new SplitFragmentSenderState(pkt, 1);
399 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a0f7f0d3412bbf494cd3d0c0f48e5fcf2}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!completeDataAccess@{completeDataAccess}}
\index{completeDataAccess@{completeDataAccess}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{completeDataAccess}]{\setlength{\rightskip}{0pt plus 5cm}void completeDataAccess ({\bf PacketPtr} {\em pkt})}}
\label{classTimingSimpleCPU_a0f7f0d3412bbf494cd3d0c0f48e5fcf2}



\begin{DoxyCode}
760 {
761     // received a response from the dcache: complete the load or store
762     // instruction
763     assert(!pkt->isError());
764     assert(_status == DcacheWaitResponse || _status == DTBWaitResponse ||
765            pkt->req->getFlags().isSet(Request::NO_ACCESS));
766 
767     pkt->req->setAccessLatency();
768     numCycles += curCycle() - previousCycle;
769     previousCycle = curCycle();
770 
771     if (pkt->senderState) {
772         SplitFragmentSenderState * send_state =
773             dynamic_cast<SplitFragmentSenderState *>(pkt->senderState);
774         assert(send_state);
775         delete pkt->req;
776         delete pkt;
777         PacketPtr big_pkt = send_state->bigPkt;
778         delete send_state;
779         
780         SplitMainSenderState * main_send_state =
781             dynamic_cast<SplitMainSenderState *>(big_pkt->senderState);
782         assert(main_send_state);
783         // Record the fact that this packet is no longer outstanding.
784         assert(main_send_state->outstanding != 0);
785         main_send_state->outstanding--;
786 
787         if (main_send_state->outstanding) {
788             return;
789         } else {
790             delete main_send_state;
791             big_pkt->senderState = NULL;
792             pkt = big_pkt;
793         }
794     }
795 
796     _status = BaseSimpleCPU::Running;
797 
798     Fault fault = curStaticInst->completeAcc(pkt, this, traceData);
799 
800     // keep an instruction count
801     if (fault == NoFault)
802         countInst();
803     else if (traceData) {
804         // If there was a fault, we shouldn't trace this instruction.
805         delete traceData;
806         traceData = NULL;
807     }
808 
809     // the locked flag may be cleared on the response packet, so check
810     // pkt->req and not pkt to see if it was a load-locked
811     if (pkt->isRead() && pkt->req->isLLSC()) {
812         TheISA::handleLockedRead(thread, pkt->req);
813     }
814 
815     delete pkt->req;
816     delete pkt;
817 
818     postExecute();
819 
820     advanceInst(fault);
821 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a20b41c38922ef954c7e338f67bba971f}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!completeIfetch@{completeIfetch}}
\index{completeIfetch@{completeIfetch}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{completeIfetch}]{\setlength{\rightskip}{0pt plus 5cm}void completeIfetch ({\bf PacketPtr} {\em pkt})}}
\label{classTimingSimpleCPU_a20b41c38922ef954c7e338f67bba971f}



\begin{DoxyCode}
655 {
656     DPRINTF(SimpleCPU, "Complete ICache Fetch for addr %#x\n", pkt ?
657             pkt->getAddr() : 0);
658 
659     // received a response from the icache: execute the received
660     // instruction
661     assert(!pkt || !pkt->isError());
662     assert(_status == IcacheWaitResponse);
663 
664     _status = BaseSimpleCPU::Running;
665 
666     numCycles += curCycle() - previousCycle;
667     previousCycle = curCycle();
668 
669     if (pkt)
670         pkt->req->setAccessLatency();
671 
672 
673     preExecute();
674     if (curStaticInst && curStaticInst->isMemRef()) {
675         // load or store: just send to dcache
676         Fault fault = curStaticInst->initiateAcc(this, traceData);
677 
678         // If we're not running now the instruction will complete in a dcache
679         // response callback or the instruction faulted and has started an
680         // ifetch
681         if (_status == BaseSimpleCPU::Running) {
682             if (fault != NoFault && traceData) {
683                 // If there was a fault, we shouldn't trace this instruction.
684                 delete traceData;
685                 traceData = NULL;
686             }
687 
688             postExecute();
689             // @todo remove me after debugging with legion done
690             if (curStaticInst && (!curStaticInst->isMicroop() ||
691                         curStaticInst->isFirstMicroop()))
692                 instCnt++;
693             advanceInst(fault);
694         }
695     } else if (curStaticInst) {
696         // non-memory instruction: execute completely now
697         Fault fault = curStaticInst->execute(this, traceData);
698 
699         // keep an instruction count
700         if (fault == NoFault)
701             countInst();
702         else if (traceData && !DTRACE(ExecFaulting)) {
703             delete traceData;
704             traceData = NULL;
705         }
706 
707         postExecute();
708         // @todo remove me after debugging with legion done
709         if (curStaticInst && (!curStaticInst->isMicroop() ||
710                     curStaticInst->isFirstMicroop()))
711             instCnt++;
712         advanceInst(fault);
713     } else {
714         advanceInst(NoFault);
715     }
716 
717     if (pkt) {
718         delete pkt->req;
719         delete pkt;
720     }
721 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a4e932bfc8aa6dfb998b8496a0f04ace3}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!drain@{drain}}
\index{drain@{drain}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em drain\_\-manager})}}
\label{classTimingSimpleCPU_a4e932bfc8aa6dfb998b8496a0f04ace3}



\begin{DoxyCode}
106 {
107     assert(!drainManager);
108     if (switchedOut())
109         return 0;
110 
111     if (_status == Idle ||
112         (_status == BaseSimpleCPU::Running && isDrained())) {
113         DPRINTF(Drain, "No need to drain.\n");
114         return 0;
115     } else {
116         drainManager = drain_manager;
117         DPRINTF(Drain, "Requesting drain: %s\n", pcState());
118 
119         // The fetch event can become descheduled if a drain didn't
120         // succeed on the first attempt. We need to reschedule it if
121         // the CPU is waiting for a microcode routine to complete.
122         if (_status == BaseSimpleCPU::Running && !fetchEvent.scheduled())
123             schedule(fetchEvent, clockEdge());
124 
125         return 1;
126     }
127 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a8f020d3237536fe007fc488c4125c5d8}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!drainResume@{drainResume}}
\index{drainResume@{drainResume}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{drainResume}]{\setlength{\rightskip}{0pt plus 5cm}void drainResume ()}}
\label{classTimingSimpleCPU_a8f020d3237536fe007fc488c4125c5d8}



\begin{DoxyCode}
131 {
132     assert(!fetchEvent.scheduled());
133     assert(!drainManager);
134     if (switchedOut())
135         return;
136 
137     DPRINTF(SimpleCPU, "Resume\n");
138     verifyMemoryMode();
139 
140     assert(!threadContexts.empty());
141     if (threadContexts.size() > 1)
142         fatal("The timing CPU only supports one thread.\n");
143 
144     if (thread->status() == ThreadContext::Active) {
145         schedule(fetchEvent, nextCycle());
146         _status = BaseSimpleCPU::Running;
147         notIdleFraction = 1;
148     } else {
149         _status = BaseSimpleCPU::Idle;
150         notIdleFraction = 0;
151     }
152 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a3865f8ea93e31d9b5d2726a80c0de966}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!fetch@{fetch}}
\index{fetch@{fetch}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{fetch}]{\setlength{\rightskip}{0pt plus 5cm}void fetch ()}}
\label{classTimingSimpleCPU_a3865f8ea93e31d9b5d2726a80c0de966}



\begin{DoxyCode}
557 {
558     DPRINTF(SimpleCPU, "Fetch\n");
559 
560     if (!curStaticInst || !curStaticInst->isDelayedCommit())
561         checkForInterrupts();
562 
563     checkPcEventQueue();
564 
565     // We must have just got suspended by a PC event
566     if (_status == Idle)
567         return;
568 
569     TheISA::PCState pcState = thread->pcState();
570     bool needToFetch = !isRomMicroPC(pcState.microPC()) && !curMacroStaticInst;
571 
572     if (needToFetch) {
573         _status = BaseSimpleCPU::Running;
574         Request *ifetch_req = new Request();
575         ifetch_req->taskId(taskId());
576         ifetch_req->setThreadContext(_cpuId, /* thread ID */ 0);
577         setupFetchRequest(ifetch_req);
578         DPRINTF(SimpleCPU, "Translating address %#x\n", ifetch_req->getVaddr());
579         thread->itb->translateTiming(ifetch_req, tc, &fetchTranslation,
580                 BaseTLB::Execute);
581     } else {
582         _status = IcacheWaitResponse;
583         completeIfetch(NULL);
584 
585         numCycles += curCycle() - previousCycle;
586         previousCycle = curCycle();
587     }
588 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a36c2a28eca3086b67fc7168a37367e98}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!finishTranslation@{finishTranslation}}
\index{finishTranslation@{finishTranslation}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{finishTranslation}]{\setlength{\rightskip}{0pt plus 5cm}void finishTranslation ({\bf WholeTranslationState} $\ast$ {\em state})}}
\label{classTimingSimpleCPU_a36c2a28eca3086b67fc7168a37367e98}
Finish a DTB translation. 
\begin{DoxyParams}{引数}
\item[{\em state}]The DTB translation state. \end{DoxyParams}



\begin{DoxyCode}
531 {
532     _status = BaseSimpleCPU::Running;
533 
534     if (state->getFault() != NoFault) {
535         if (state->isPrefetch()) {
536             state->setNoFault();
537         }
538         delete [] state->data;
539         state->deleteReqs();
540         translationFault(state->getFault());
541     } else {
542         if (!state->isSplit) {
543             sendData(state->mainReq, state->data, state->res,
544                      state->mode == BaseTLB::Read);
545         } else {
546             sendSplitData(state->sreqLow, state->sreqHigh, state->mainReq,
547                           state->data, state->mode == BaseTLB::Read);
548         }
549     }
550 
551     delete state;
552 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_aeea6b55ae1c4be53c21dbee434b221d4}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!getDataPort@{getDataPort}}
\index{getDataPort@{getDataPort}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{getDataPort}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf MasterPort}\& getDataPort ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classTimingSimpleCPU_aeea6b55ae1c4be53c21dbee434b221d4}
Return a reference to the data port. 


\begin{DoxyCode}
259 { return dcachePort; }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a40da530cb5dd380fd7fc0d786e94d5eb}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!getInstPort@{getInstPort}}
\index{getInstPort@{getInstPort}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{getInstPort}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf MasterPort}\& getInstPort ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classTimingSimpleCPU_a40da530cb5dd380fd7fc0d786e94d5eb}
Return a reference to the instruction port. 


\begin{DoxyCode}
262 { return icachePort; }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a9a8beb0dcad34e8759794cea6639f715}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!handleReadPacket@{handleReadPacket}}
\index{handleReadPacket@{handleReadPacket}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{handleReadPacket}]{\setlength{\rightskip}{0pt plus 5cm}bool handleReadPacket ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTimingSimpleCPU_a9a8beb0dcad34e8759794cea6639f715}



\begin{DoxyCode}
242 {
243     RequestPtr req = pkt->req;
244     if (req->isMmappedIpr()) {
245         Cycles delay = TheISA::handleIprRead(thread->getTC(), pkt);
246         new IprEvent(pkt, this, clockEdge(delay));
247         _status = DcacheWaitResponse;
248         dcache_pkt = NULL;
249     } else if (!dcachePort.sendTimingReq(pkt)) {
250         _status = DcacheRetry;
251         dcache_pkt = pkt;
252     } else {
253         _status = DcacheWaitResponse;
254         // memory system takes ownership of packet
255         dcache_pkt = NULL;
256     }
257     return dcache_pkt == NULL;
258 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a8d70b3b102cd0f4949ae31e84ee2eb98}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!handleWritePacket@{handleWritePacket}}
\index{handleWritePacket@{handleWritePacket}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{handleWritePacket}]{\setlength{\rightskip}{0pt plus 5cm}bool handleWritePacket ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTimingSimpleCPU_a8d70b3b102cd0f4949ae31e84ee2eb98}



\begin{DoxyCode}
453 {
454     RequestPtr req = dcache_pkt->req;
455     if (req->isMmappedIpr()) {
456         Cycles delay = TheISA::handleIprWrite(thread->getTC(), dcache_pkt);
457         new IprEvent(dcache_pkt, this, clockEdge(delay));
458         _status = DcacheWaitResponse;
459         dcache_pkt = NULL;
460     } else if (!dcachePort.sendTimingReq(dcache_pkt)) {
461         _status = DcacheRetry;
462     } else {
463         _status = DcacheWaitResponse;
464         // memory system takes ownership of packet
465         dcache_pkt = NULL;
466     }
467     return dcache_pkt == NULL;
468 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!init@{init}}
\index{init@{init}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTimingSimpleCPU_a02fd73d861ef2e4aabb38c0c9ff82947}



\begin{DoxyCode}
66 {
67     BaseCPU::init();
68 
69     // Initialise the ThreadContext's memory proxies
70     tcBase()->initMemProxies(tcBase());
71 
72     if (FullSystem && !params()->switched_out) {
73         for (int i = 0; i < threadContexts.size(); ++i) {
74             ThreadContext *tc = threadContexts[i];
75             // initialize CPU, including PC
76             TheISA::initCPU(tc, _cpuId);
77         }
78     }
79 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_ac166e5bc3ddf730beb1282cf821096ae}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!isDrained@{isDrained}}
\index{isDrained@{isDrained}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{isDrained}]{\setlength{\rightskip}{0pt plus 5cm}bool isDrained ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classTimingSimpleCPU_ac166e5bc3ddf730beb1282cf821096ae}
\hyperlink{classCheck}{Check} if a system is in a drained state.

We need to drain if: 
\begin{DoxyItemize}
\item We are in the middle of a microcode sequence as some CPUs (e.g., HW accelerated CPUs) can't be started in the middle of a gem5 microcode sequence.


\item Stay at PC is true.


\item A fetch event is scheduled. Normally this would never be the case with \hyperlink{classBaseSimpleCPU_a1a21696f33a7d38f251687ae0b5e9718}{microPC()} == 0, but right after a context is activated it can happen. 
\end{DoxyItemize}


\begin{DoxyCode}
337                      {
338         return microPC() == 0 && !stayAtPC && !fetchEvent.scheduled();
339     }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_add8df091bd836cf92c6987990d130b83}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!isSquashed@{isSquashed}}
\index{isSquashed@{isSquashed}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{isSquashed}]{\setlength{\rightskip}{0pt plus 5cm}bool isSquashed () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classTimingSimpleCPU_add8df091bd836cf92c6987990d130b83}
This function is used by the page table walker to determine if it could translate the a pending request or if the underlying request has been squashed. This always returns false for the simple timing CPU as it never executes any instructions speculatively. @ return Is the current instruction squashed? 


\begin{DoxyCode}
294 { return false; }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a88aa41e2693dd0091afae2604eba9bed}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!printAddr@{printAddr}}
\index{printAddr@{printAddr}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{printAddr}]{\setlength{\rightskip}{0pt plus 5cm}void printAddr ({\bf Addr} {\em a})}}
\label{classTimingSimpleCPU_a88aa41e2693dd0091afae2604eba9bed}
Print state of address in memory system via PrintReq (for debugging). 


\begin{DoxyCode}
926 {
927     dcachePort.printAddr(a);
928 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a66191b2d8a45050b7df3c3efa7bb07c6}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!readMem@{readMem}}
\index{readMem@{readMem}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{readMem}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} readMem ({\bf Addr} {\em addr}, \/  uint8\_\-t $\ast$ {\em data}, \/  unsigned {\em size}, \/  unsigned {\em flags})}}
\label{classTimingSimpleCPU_a66191b2d8a45050b7df3c3efa7bb07c6}



\begin{DoxyCode}
404 {
405     Fault fault;
406     const int asid = 0;
407     const ThreadID tid = 0;
408     const Addr pc = thread->instAddr();
409     unsigned block_size = cacheLineSize();
410     BaseTLB::Mode mode = BaseTLB::Read;
411 
412     if (traceData) {
413         traceData->setAddr(addr);
414     }
415 
416     RequestPtr req  = new Request(asid, addr, size,
417                                   flags, dataMasterId(), pc, _cpuId, tid);
418 
419     req->taskId(taskId());
420 
421     Addr split_addr = roundDown(addr + size - 1, block_size);
422     assert(split_addr <= addr || split_addr - addr < block_size);
423 
424     _status = DTBWaitResponse;
425     if (split_addr > addr) {
426         RequestPtr req1, req2;
427         assert(!req->isLLSC() && !req->isSwap());
428         req->splitOnVaddr(split_addr, req1, req2);
429 
430         WholeTranslationState *state =
431             new WholeTranslationState(req, req1, req2, new uint8_t[size],
432                                       NULL, mode);
433         DataTranslation<TimingSimpleCPU *> *trans1 =
434             new DataTranslation<TimingSimpleCPU *>(this, state, 0);
435         DataTranslation<TimingSimpleCPU *> *trans2 =
436             new DataTranslation<TimingSimpleCPU *>(this, state, 1);
437 
438         thread->dtb->translateTiming(req1, tc, trans1, mode);
439         thread->dtb->translateTiming(req2, tc, trans2, mode);
440     } else {
441         WholeTranslationState *state =
442             new WholeTranslationState(req, new uint8_t[size], NULL, mode);
443         DataTranslation<TimingSimpleCPU *> *translation
444             = new DataTranslation<TimingSimpleCPU *>(this, state);
445         thread->dtb->translateTiming(req, tc, translation, mode);
446     }
447 
448     return NoFault;
449 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_ad6486c2f7c95532e093a31f013b36fe5}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!sendData@{sendData}}
\index{sendData@{sendData}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{sendData}]{\setlength{\rightskip}{0pt plus 5cm}void sendData ({\bf RequestPtr} {\em req}, \/  uint8\_\-t $\ast$ {\em data}, \/  uint64\_\-t $\ast$ {\em res}, \/  bool {\em read})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTimingSimpleCPU_ad6486c2f7c95532e093a31f013b36fe5}



\begin{DoxyCode}
263 {
264     PacketPtr pkt;
265     buildPacket(pkt, req, read);
266     pkt->dataDynamicArray<uint8_t>(data);
267     if (req->getFlags().isSet(Request::NO_ACCESS)) {
268         assert(!dcache_pkt);
269         pkt->makeResponse();
270         completeDataAccess(pkt);
271     } else if (read) {
272         handleReadPacket(pkt);
273     } else {
274         bool do_access = true;  // flag to suppress cache access
275 
276         if (req->isLLSC()) {
277             do_access = TheISA::handleLockedWrite(thread, req, dcachePort.
      cacheBlockMask);
278         } else if (req->isCondSwap()) {
279             assert(res);
280             req->setExtraData(*res);
281         }
282 
283         if (do_access) {
284             dcache_pkt = pkt;
285             handleWritePacket();
286         } else {
287             _status = DcacheWaitResponse;
288             completeDataAccess(pkt);
289         }
290     }
291 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a9c1e81509746ac06253e334c436e1a75}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!sendFetch@{sendFetch}}
\index{sendFetch@{sendFetch}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{sendFetch}]{\setlength{\rightskip}{0pt plus 5cm}void sendFetch ({\bf Fault} {\em fault}, \/  {\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc})}}
\label{classTimingSimpleCPU_a9c1e81509746ac06253e334c436e1a75}



\begin{DoxyCode}
593 {
594     if (fault == NoFault) {
595         DPRINTF(SimpleCPU, "Sending fetch for addr %#x(pa: %#x)\n",
596                 req->getVaddr(), req->getPaddr());
597         ifetch_pkt = new Packet(req, MemCmd::ReadReq);
598         ifetch_pkt->dataStatic(&inst);
599         DPRINTF(SimpleCPU, " -- pkt addr: %#x\n", ifetch_pkt->getAddr());
600 
601         if (!icachePort.sendTimingReq(ifetch_pkt)) {
602             // Need to wait for retry
603             _status = IcacheRetry;
604         } else {
605             // Need to wait for cache to respond
606             _status = IcacheWaitResponse;
607             // ownership of packet transferred to memory system
608             ifetch_pkt = NULL;
609         }
610     } else {
611         DPRINTF(SimpleCPU, "Translation of addr %#x faulted\n", req->getVaddr());
      
612         delete req;
613         // fetch fault: advance directly to next instruction (fault handler)
614         _status = BaseSimpleCPU::Running;
615         advanceInst(fault);
616     }
617 
618     numCycles += curCycle() - previousCycle;
619     previousCycle = curCycle();
620 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a0894ae25efe60dc7855c057cab1684f9}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!sendSplitData@{sendSplitData}}
\index{sendSplitData@{sendSplitData}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{sendSplitData}]{\setlength{\rightskip}{0pt plus 5cm}void sendSplitData ({\bf RequestPtr} {\em req1}, \/  {\bf RequestPtr} {\em req2}, \/  {\bf RequestPtr} {\em req}, \/  uint8\_\-t $\ast$ {\em data}, \/  bool {\em read})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTimingSimpleCPU_a0894ae25efe60dc7855c057cab1684f9}



\begin{DoxyCode}
296 {
297     PacketPtr pkt1, pkt2;
298     buildSplitPacket(pkt1, pkt2, req1, req2, req, data, read);
299     if (req->getFlags().isSet(Request::NO_ACCESS)) {
300         assert(!dcache_pkt);
301         pkt1->makeResponse();
302         completeDataAccess(pkt1);
303     } else if (read) {
304         SplitFragmentSenderState * send_state =
305             dynamic_cast<SplitFragmentSenderState *>(pkt1->senderState);
306         if (handleReadPacket(pkt1)) {
307             send_state->clearFromParent();
308             send_state = dynamic_cast<SplitFragmentSenderState *>(
309                     pkt2->senderState);
310             if (handleReadPacket(pkt2)) {
311                 send_state->clearFromParent();
312             }
313         }
314     } else {
315         dcache_pkt = pkt1;
316         SplitFragmentSenderState * send_state =
317             dynamic_cast<SplitFragmentSenderState *>(pkt1->senderState);
318         if (handleWritePacket()) {
319             send_state->clearFromParent();
320             dcache_pkt = pkt2;
321             send_state = dynamic_cast<SplitFragmentSenderState *>(
322                     pkt2->senderState);
323             if (handleWritePacket()) {
324                 send_state->clearFromParent();
325             }
326         }
327     }
328 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a1dad4c4d2c3df4ef367e14fcc973ce74}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!suspendContext@{suspendContext}}
\index{suspendContext@{suspendContext}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{suspendContext}]{\setlength{\rightskip}{0pt plus 5cm}void suspendContext ({\bf ThreadID} {\em thread\_\-num})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTimingSimpleCPU_a1dad4c4d2c3df4ef367e14fcc973ce74}



\begin{DoxyCode}
222 {
223     DPRINTF(SimpleCPU, "SuspendContext %d\n", thread_num);
224 
225     assert(thread_num == 0);
226     assert(thread);
227 
228     if (_status == Idle)
229         return;
230 
231     assert(_status == BaseSimpleCPU::Running);
232 
233     // just change status to Idle... if status != Running,
234     // completeInst() will not initiate fetch of next instruction.
235 
236     notIdleFraction = 0;
237     _status = Idle;
238 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a05f299b443f8cc73a93d61572edc0218}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!switchOut@{switchOut}}
\index{switchOut@{switchOut}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{switchOut}]{\setlength{\rightskip}{0pt plus 5cm}void switchOut ()}}
\label{classTimingSimpleCPU_a05f299b443f8cc73a93d61572edc0218}



\begin{DoxyCode}
173 {
174     BaseSimpleCPU::switchOut();
175 
176     assert(!fetchEvent.scheduled());
177     assert(_status == BaseSimpleCPU::Running || _status == Idle);
178     assert(!stayAtPC);
179     assert(microPC() == 0);
180 
181     numCycles += curCycle() - previousCycle;
182 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_ac82d2b8d331b2e8e6854a95d2917dfa2}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ({\bf BaseCPU} $\ast$ {\em oldCPU})}}
\label{classTimingSimpleCPU_ac82d2b8d331b2e8e6854a95d2917dfa2}



\begin{DoxyCode}
187 {
188     BaseSimpleCPU::takeOverFrom(oldCPU);
189 
190     previousCycle = curCycle();
191 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_a5f6223adc354c36cc8773251dd7e0f4d}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!translationFault@{translationFault}}
\index{translationFault@{translationFault}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{translationFault}]{\setlength{\rightskip}{0pt plus 5cm}void translationFault ({\bf Fault} {\em fault})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTimingSimpleCPU_a5f6223adc354c36cc8773251dd7e0f4d}



\begin{DoxyCode}
332 {
333     // fault may be NoFault in cases where a fault is suppressed,
334     // for instance prefetches.
335     numCycles += curCycle() - previousCycle;
336     previousCycle = curCycle();
337 
338     if (traceData) {
339         // Since there was a fault, we shouldn't trace this instruction.
340         delete traceData;
341         traceData = NULL;
342     }
343 
344     postExecute();
345 
346     advanceInst(fault);
347 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_abfea8f75a7a7480716801affeebbe87b}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!tryCompleteDrain@{tryCompleteDrain}}
\index{tryCompleteDrain@{tryCompleteDrain}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{tryCompleteDrain}]{\setlength{\rightskip}{0pt plus 5cm}bool tryCompleteDrain ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTimingSimpleCPU_abfea8f75a7a7480716801affeebbe87b}
Try to complete a drain request.

\begin{DoxyReturn}{戻り値}
true if the CPU is drained, false otherwise. 
\end{DoxyReturn}



\begin{DoxyCode}
156 {
157     if (!drainManager)
158         return false;
159 
160     DPRINTF(Drain, "tryCompleteDrain: %s\n", pcState());
161     if (!isDrained())
162         return false;
163 
164     DPRINTF(Drain, "CPU done draining, processing drain event\n");
165     drainManager->signalDrainDone();
166     drainManager = NULL;
167 
168     return true;
169 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_ae2e1ccebe596a180f8105d57f9a93645}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!verifyMemoryMode@{verifyMemoryMode}}
\index{verifyMemoryMode@{verifyMemoryMode}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{verifyMemoryMode}]{\setlength{\rightskip}{0pt plus 5cm}void verifyMemoryMode () const}}
\label{classTimingSimpleCPU_ae2e1ccebe596a180f8105d57f9a93645}



\begin{DoxyCode}
195 {
196     if (!system->isTimingMode()) {
197         fatal("The timing CPU requires the memory system to be in "
198               "'timing' mode.\n");
199     }
200 }
\end{DoxyCode}
\hypertarget{classTimingSimpleCPU_ad46c5edeb1ee9b60445f3e26364e2c5e}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!writeMem@{writeMem}}
\index{writeMem@{writeMem}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{writeMem}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} writeMem (uint8\_\-t $\ast$ {\em data}, \/  unsigned {\em size}, \/  {\bf Addr} {\em addr}, \/  unsigned {\em flags}, \/  uint64\_\-t $\ast$ {\em res})}}
\label{classTimingSimpleCPU_ad46c5edeb1ee9b60445f3e26364e2c5e}



\begin{DoxyCode}
473 {
474     uint8_t *newData = new uint8_t[size];
475     const int asid = 0;
476     const ThreadID tid = 0;
477     const Addr pc = thread->instAddr();
478     unsigned block_size = cacheLineSize();
479     BaseTLB::Mode mode = BaseTLB::Write;
480 
481     if (data == NULL) {
482         assert(flags & Request::CACHE_BLOCK_ZERO);
483         // This must be a cache block cleaning request
484         memset(newData, 0, size);
485     } else {
486         memcpy(newData, data, size);
487     }
488 
489     if (traceData) {
490         traceData->setAddr(addr);
491     }
492 
493     RequestPtr req = new Request(asid, addr, size,
494                                  flags, dataMasterId(), pc, _cpuId, tid);
495 
496     req->taskId(taskId());
497 
498     Addr split_addr = roundDown(addr + size - 1, block_size);
499     assert(split_addr <= addr || split_addr - addr < block_size);
500 
501     _status = DTBWaitResponse;
502     if (split_addr > addr) {
503         RequestPtr req1, req2;
504         assert(!req->isLLSC() && !req->isSwap());
505         req->splitOnVaddr(split_addr, req1, req2);
506 
507         WholeTranslationState *state =
508             new WholeTranslationState(req, req1, req2, newData, res, mode);
509         DataTranslation<TimingSimpleCPU *> *trans1 =
510             new DataTranslation<TimingSimpleCPU *>(this, state, 0);
511         DataTranslation<TimingSimpleCPU *> *trans2 =
512             new DataTranslation<TimingSimpleCPU *>(this, state, 1);
513 
514         thread->dtb->translateTiming(req1, tc, trans1, mode);
515         thread->dtb->translateTiming(req2, tc, trans2, mode);
516     } else {
517         WholeTranslationState *state =
518             new WholeTranslationState(req, newData, res, mode);
519         DataTranslation<TimingSimpleCPU *> *translation =
520             new DataTranslation<TimingSimpleCPU *>(this, state);
521         thread->dtb->translateTiming(req, tc, translation, mode);
522     }
523 
524     // Translation faults will be returned via finishTranslation()
525     return NoFault;
526 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classTimingSimpleCPU_a8cdf6dfb358a155d5422c09f961297fe}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!dcache\_\-pkt@{dcache\_\-pkt}}
\index{dcache\_\-pkt@{dcache\_\-pkt}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{dcache\_\-pkt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketPtr} {\bf dcache\_\-pkt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTimingSimpleCPU_a8cdf6dfb358a155d5422c09f961297fe}
\hypertarget{classTimingSimpleCPU_a38b03978ad7720fdc910ff6a8b44585f}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!dcachePort@{dcachePort}}
\index{dcachePort@{dcachePort}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{dcachePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DcachePort} {\bf dcachePort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTimingSimpleCPU_a38b03978ad7720fdc910ff6a8b44585f}
\hypertarget{classTimingSimpleCPU_a329b71fb934a93312ca0aacbf5a3f982}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!drainManager@{drainManager}}
\index{drainManager@{drainManager}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{drainManager}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DrainManager}$\ast$ {\bf drainManager}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTimingSimpleCPU_a329b71fb934a93312ca0aacbf5a3f982}
Drain manager to use when signaling drain completion

This pointer is non-\/NULL when draining and NULL otherwise. \hypertarget{classTimingSimpleCPU_a17e7c383c8fb3d4dc450d79c15dd1061}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!fetchEvent@{fetchEvent}}
\index{fetchEvent@{fetchEvent}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{fetchEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FetchEvent} {\bf fetchEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTimingSimpleCPU_a17e7c383c8fb3d4dc450d79c15dd1061}
\hypertarget{classTimingSimpleCPU_abc9a320383d8f8241113fe01f333d5ca}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!fetchTranslation@{fetchTranslation}}
\index{fetchTranslation@{fetchTranslation}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{fetchTranslation}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FetchTranslation} {\bf fetchTranslation}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTimingSimpleCPU_abc9a320383d8f8241113fe01f333d5ca}
\hypertarget{classTimingSimpleCPU_a290723656a84b9cc90dfce377af9aad0}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!icachePort@{icachePort}}
\index{icachePort@{icachePort}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{icachePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IcachePort} {\bf icachePort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTimingSimpleCPU_a290723656a84b9cc90dfce377af9aad0}
\hypertarget{classTimingSimpleCPU_a82097539e30887f0ad11d7a218c5bcca}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!ifetch\_\-pkt@{ifetch\_\-pkt}}
\index{ifetch\_\-pkt@{ifetch\_\-pkt}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{ifetch\_\-pkt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketPtr} {\bf ifetch\_\-pkt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTimingSimpleCPU_a82097539e30887f0ad11d7a218c5bcca}
\hypertarget{classTimingSimpleCPU_acb8e08ce453c8db11437d6cf9b0167bf}{
\index{TimingSimpleCPU@{TimingSimpleCPU}!previousCycle@{previousCycle}}
\index{previousCycle@{previousCycle}!TimingSimpleCPU@{TimingSimpleCPU}}
\subsubsection[{previousCycle}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf previousCycle}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classTimingSimpleCPU_acb8e08ce453c8db11437d6cf9b0167bf}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/simple/\hyperlink{timing_8hh}{timing.hh}\item 
cpu/simple/\hyperlink{timing_8cc}{timing.cc}\end{DoxyCompactItemize}
