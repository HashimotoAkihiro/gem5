\hypertarget{classUseDefUnit}{
\section{クラス UseDefUnit}
\label{classUseDefUnit}\index{UseDefUnit@{UseDefUnit}}
}


{\ttfamily \#include $<$use\_\-def.hh$>$}UseDefUnitに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classUseDefUnit}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classUseDefUnit_1_1UseDefRequest}{UseDefRequest}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classUseDefUnit_a2afce0a47a93eee73a314d53e4890153}{Command} \{ \hyperlink{classUseDefUnit_a2afce0a47a93eee73a314d53e4890153aaeedb0d901f76a332eff9fb2fdb42eee}{ReadSrcReg}, 
\hyperlink{classUseDefUnit_a2afce0a47a93eee73a314d53e4890153aebf3627ab0dc50391abb37f1d20bc375}{WriteDestReg}, 
\hyperlink{classUseDefUnit_a2afce0a47a93eee73a314d53e4890153aa7a98b5cc14566eda10b7248440cafa2}{MarkDestRegs}
 \}
\item 
typedef \hyperlink{classRefCountingPtr}{ThePipeline::DynInstPtr} \hyperlink{classUseDefUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{DynInstPtr}
\item 
typedef TheISA::RegIndex \hyperlink{classUseDefUnit_a36d25e03e43fa3bb4c5482cbefe5e0fb}{RegIndex}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classUseDefUnit_a75c5c187ebe767d923c1cb13ba91df2f}{UseDefUnit} (std::string res\_\-name, int res\_\-id, int res\_\-width, \hyperlink{classCycles}{Cycles} res\_\-latency, \hyperlink{classInOrderCPU}{InOrderCPU} $\ast$\_\-cpu, \hyperlink{namespaceThePipeline_ab62ca16eeca26566ad2422b5df4943ce}{ThePipeline::Params} $\ast$params)
\item 
void \hyperlink{classUseDefUnit_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
\hyperlink{classResourceRequest}{ResourceRequest} $\ast$ \hyperlink{classUseDefUnit_aae5ce84f94a1057d7f60172daf5d731d}{getRequest} (\hyperlink{classRefCountingPtr}{DynInstPtr} \_\-inst, int stage\_\-num, int res\_\-idx, int slot\_\-num, unsigned cmd)
\item 
\hyperlink{classResourceRequest}{ResReqPtr} \hyperlink{classUseDefUnit_ae3afc1c63d17a49a6301bd18fca574a0}{findRequest} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
void \hyperlink{classUseDefUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{execute} (int slot\_\-num)
\item 
void \hyperlink{classUseDefUnit_a339073618ad3c21c492d64a55ce2e216}{updateAfterContextSwitch} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classUseDefUnit_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classRegDepMap}{RegDepMap} $\ast$ \hyperlink{classUseDefUnit_aa0933c90c5ced66e85669c2982b165a6}{regDepMap} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
bool $\ast$ \hyperlink{classUseDefUnit_aa27d1c9b589af0c77a81c490021c7dcb}{nonSpecInstActive} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} $\ast$ \hyperlink{classUseDefUnit_a899b1bc10d38a0f725495bf2108479a3}{nonSpecSeqNum} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
bool \hyperlink{classUseDefUnit_ad4300fb3f2f2ddebbfd44bbcad133c56}{serializeOnNextInst} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classUseDefUnit_a699cfb06a053ac682026566662b62453}{serializeAfterSeqNum} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
\hyperlink{classStats_1_1Average}{Stats::Average} \hyperlink{classUseDefUnit_a796c1916448138c736618531476b9801}{uniqueRegsPerSwitch}
\item 
std::map$<$ \hyperlink{classUseDefUnit_a36d25e03e43fa3bb4c5482cbefe5e0fb}{RegIndex}, bool $>$ \hyperlink{classUseDefUnit_a007316fc06c43d3c786e79da6f3a5265}{uniqueIntRegMap}
\item 
std::map$<$ \hyperlink{classUseDefUnit_a36d25e03e43fa3bb4c5482cbefe5e0fb}{RegIndex}, bool $>$ \hyperlink{classUseDefUnit_a148e8f7c874a196ab74ca1f39662c98c}{uniqueFloatRegMap}
\item 
std::map$<$ \hyperlink{classUseDefUnit_a36d25e03e43fa3bb4c5482cbefe5e0fb}{RegIndex}, bool $>$ \hyperlink{classUseDefUnit_aeab2bd090cc9b29fbf5f386013dd79fd}{uniqueMiscRegMap}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classUseDefUnit_a67e958fedd10dfe72747865179154882}{intRegFileReads}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classUseDefUnit_aa79e36dab324cdcb339de91d5b21f03b}{intRegFileWrites}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classUseDefUnit_abf73f69eb2ade79a3b55b431699c6d07}{intRegFileAccs}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classUseDefUnit_a51481d49e9355c25c8afa3553771605d}{floatRegFileReads}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classUseDefUnit_a5b7ee045b5715d8abb9d7e17502e6f09}{floatRegFileWrites}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classUseDefUnit_a71fd5719f07c55c81f0296e2835a7c90}{floatRegFileAccs}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classUseDefUnit_a37cb2ded859693943151bfb454bcc97f}{regForwards}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classUseDefUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{
\index{UseDefUnit@{UseDefUnit}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!UseDefUnit@{UseDefUnit}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf ThePipeline::DynInstPtr} {\bf DynInstPtr}}}
\label{classUseDefUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}


\hyperlink{classResource_af9d0c8a46736ba6aa2d8bb94da1a5e73}{Resource}を再定義しています。\hypertarget{classUseDefUnit_a36d25e03e43fa3bb4c5482cbefe5e0fb}{
\index{UseDefUnit@{UseDefUnit}!RegIndex@{RegIndex}}
\index{RegIndex@{RegIndex}!UseDefUnit@{UseDefUnit}}
\subsubsection[{RegIndex}]{\setlength{\rightskip}{0pt plus 5cm}typedef TheISA::RegIndex {\bf RegIndex}}}
\label{classUseDefUnit_a36d25e03e43fa3bb4c5482cbefe5e0fb}


\subsection{列挙型}
\hypertarget{classUseDefUnit_a2afce0a47a93eee73a314d53e4890153}{
\index{UseDefUnit@{UseDefUnit}!Command@{Command}}
\index{Command@{Command}!UseDefUnit@{UseDefUnit}}
\subsubsection[{Command}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Command}}}
\label{classUseDefUnit_a2afce0a47a93eee73a314d53e4890153}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{ReadSrcReg@{ReadSrcReg}!UseDefUnit@{UseDefUnit}}\index{UseDefUnit@{UseDefUnit}!ReadSrcReg@{ReadSrcReg}}\item[{\em 
\hypertarget{classUseDefUnit_a2afce0a47a93eee73a314d53e4890153aaeedb0d901f76a332eff9fb2fdb42eee}{
ReadSrcReg}
\label{classUseDefUnit_a2afce0a47a93eee73a314d53e4890153aaeedb0d901f76a332eff9fb2fdb42eee}
}]\index{WriteDestReg@{WriteDestReg}!UseDefUnit@{UseDefUnit}}\index{UseDefUnit@{UseDefUnit}!WriteDestReg@{WriteDestReg}}\item[{\em 
\hypertarget{classUseDefUnit_a2afce0a47a93eee73a314d53e4890153aebf3627ab0dc50391abb37f1d20bc375}{
WriteDestReg}
\label{classUseDefUnit_a2afce0a47a93eee73a314d53e4890153aebf3627ab0dc50391abb37f1d20bc375}
}]\index{MarkDestRegs@{MarkDestRegs}!UseDefUnit@{UseDefUnit}}\index{UseDefUnit@{UseDefUnit}!MarkDestRegs@{MarkDestRegs}}\item[{\em 
\hypertarget{classUseDefUnit_a2afce0a47a93eee73a314d53e4890153aa7a98b5cc14566eda10b7248440cafa2}{
MarkDestRegs}
\label{classUseDefUnit_a2afce0a47a93eee73a314d53e4890153aa7a98b5cc14566eda10b7248440cafa2}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
51                  {
52         ReadSrcReg,
53         WriteDestReg,
54         MarkDestRegs
55     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classUseDefUnit_a75c5c187ebe767d923c1cb13ba91df2f}{
\index{UseDefUnit@{UseDefUnit}!UseDefUnit@{UseDefUnit}}
\index{UseDefUnit@{UseDefUnit}!UseDefUnit@{UseDefUnit}}
\subsubsection[{UseDefUnit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf UseDefUnit} (std::string {\em res\_\-name}, \/  int {\em res\_\-id}, \/  int {\em res\_\-width}, \/  {\bf Cycles} {\em res\_\-latency}, \/  {\bf InOrderCPU} $\ast$ {\em \_\-cpu}, \/  {\bf ThePipeline::Params} $\ast$ {\em params})}}
\label{classUseDefUnit_a75c5c187ebe767d923c1cb13ba91df2f}


\subsection{関数}
\hypertarget{classUseDefUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{
\index{UseDefUnit@{UseDefUnit}!execute@{execute}}
\index{execute@{execute}!UseDefUnit@{UseDefUnit}}
\subsubsection[{execute}]{\setlength{\rightskip}{0pt plus 5cm}void execute (int {\em slot\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classUseDefUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}
Execute the function of this resource. The Default is action is to do nothing. More specific models will derive from this class and define their own execute function. 

\hyperlink{classResource_a39af49c5568d1db3f53c12d7d6914c32}{Resource}を再定義しています。


\begin{DoxyCode}
156 {
157     UseDefRequest* ud_req = dynamic_cast<UseDefRequest*>(reqs[slot_idx]);
158     DynInstPtr inst = ud_req->inst;
159     ThreadID tid = inst->readTid();
160     InstSeqNum seq_num = inst->seqNum;
161     int ud_idx = ud_req->useDefIdx;
162 
163     if (serializeOnNextInst[tid] &&
164         seq_num > serializeAfterSeqNum[tid]) {
165         inst->setSerializeBefore();
166         serializeOnNextInst[tid] = false;
167     }
168 
169     if ((inst->isIprAccess() || inst->isSerializeBefore()) &&
170         cpu->instList[tid].front() != inst) {
171         DPRINTF(InOrderUseDef, "[tid:%i]: [sn:%i] Serialize before instruction en
      countered."
172                 " Blocking until pipeline is clear.\n", tid, seq_num);
173         ud_req->done(false);
174         return;
175     } else if (inst->isStoreConditional() || inst->isSerializeAfter()) {
176         DPRINTF(InOrderUseDef, "[tid:%i]: [sn:%i] Serialize after instruction enc
      ountered."
177                 " Blocking until pipeline is clear.\n", tid, seq_num);
178         serializeOnNextInst[tid] = true;
179         serializeAfterSeqNum[tid] = seq_num;
180     }
181 
182     if (inst->fault != NoFault) {
183         DPRINTF(InOrderUseDef,
184                 "[tid:%i]: [sn:%i]: Detected %s fault @ %x. Forwarding to "
185                 "next stage.\n", inst->readTid(), inst->seqNum, inst->fault->name
      (),
186                 inst->pcState());
187         ud_req->done();
188         return;
189     }
190 
191     // If there is a non-speculative instruction
192     // in the pipeline then stall instructions here
193     // ---
194     if (*nonSpecInstActive[tid] && seq_num > *nonSpecSeqNum[tid]) {
195         DPRINTF(InOrderUseDef, "[tid:%i]: [sn:%i] cannot execute because"
196                 "there is non-speculative instruction [sn:%i] has not "
197                 "graduated.\n", tid, seq_num, *nonSpecSeqNum[tid]);
198         ud_req->done(false);
199         return;
200     } else if (inst->isNonSpeculative()) {
201         *nonSpecInstActive[tid] = true;
202         *nonSpecSeqNum[tid] = seq_num;
203     }
204 
205     switch (ud_req->cmd)
206     {
207       case ReadSrcReg:
208         {
209             RegClass reg_type;
210             RegIndex reg_idx = inst->_srcRegIdx[ud_idx];
211             RegIndex flat_idx = cpu->flattenRegIdx(reg_idx, reg_type, tid);
212             inst->flattenSrcReg(ud_idx, flat_idx);
213             
214             if (flat_idx == TheISA::ZeroReg && reg_type == IntRegClass) {
215                 DPRINTF(InOrderUseDef, "[tid:%i]: [sn:%i]: Ignoring Reading of IS
      A-ZeroReg "
216                         "(Int. Reg %i).\n", tid, inst->seqNum, flat_idx);
217                 ud_req->done();
218                 return;
219             } else {
220                 DPRINTF(InOrderUseDef, "[tid:%i]: [sn:%i]: Attempting to read sou
      rce "
221                         "register idx %i (reg #%i, flat#%i).\n",
222                         tid, seq_num, ud_idx, reg_idx, flat_idx);
223             }
224 
225             if (regDepMap[tid]->canRead(reg_type, flat_idx, inst)) {
226                 switch (reg_type)
227                 {
228                   case IntRegClass:
229                     {
230                         uniqueIntRegMap[flat_idx] = true;
231 
232                         DPRINTF(InOrderUseDef, "[tid:%i]: [sn:%i]: Reading Int Re
      g %i"
233                                 " (%i) from Register File:0x%x.\n",
234                                 tid, seq_num,
235                                 reg_idx, flat_idx,
236                                 cpu->readIntReg(flat_idx,inst->readTid()));
237                         inst->setIntSrc(ud_idx,
238                                         cpu->readIntReg(flat_idx,
239                                                         inst->readTid()));
240                         intRegFileReads++;
241                     }
242                     break;
243 
244                   case FloatRegClass:
245                     {
246                         uniqueFloatRegMap[flat_idx] = true;
247                         DPRINTF(InOrderUseDef, "[tid:%i]: [sn:%i]: Reading Float 
      Reg %i"
248                                 " (%i) from Register File:%x (%08f).\n",
249                                 tid, seq_num,
250                                 reg_idx - FP_Reg_Base, flat_idx,
251                                 cpu->readFloatRegBits(flat_idx,
252                                                       inst->readTid()),
253                                 cpu->readFloatReg(flat_idx,
254                                                   inst->readTid()));
255 
256                         inst->setFloatSrc(ud_idx,
257                                           cpu->readFloatReg(flat_idx,
258                                                             inst->readTid()));
259                         inst->setFloatRegBitsSrc(ud_idx,
260                                                  cpu->readFloatRegBits(flat_idx,
261                                                                        inst->read
      Tid()));
262                         floatRegFileReads++;
263                     }
264                     break;
265 
266                   case MiscRegClass:
267                     {
268                         uniqueMiscRegMap[flat_idx] = true;
269                         DPRINTF(InOrderUseDef, "[tid:%i]: [sn:%i]: Reading Misc R
      eg %i "
270                                 " (%i) from Register File:0x%x.\n",
271                                 tid, seq_num,
272                                 reg_idx - Misc_Reg_Base, flat_idx,
273                                 cpu->readMiscReg(flat_idx,
274                                 inst->readTid()));
275                         inst->setIntSrc(ud_idx,
276                                         cpu->readMiscReg(flat_idx,
277                                                          inst->readTid()));
278                     }
279                     break;
280 
281                   default:
282                     panic("Invalid Register Type: %i", reg_type);
283                 }
284 
285                 ud_req->done();
286             } else {
287                 // Look for forwarding opportunities
288                 DynInstPtr forward_inst = regDepMap[tid]->canForward(reg_type,
289                                                                      flat_idx,
290                                                                      inst);
291 
292                 if (forward_inst) {
293                     int dest_reg_idx =
294                         forward_inst->getDestIdxNum(flat_idx);
295 
296                     switch (reg_type)
297                     {
298                       case IntRegClass:
299                         {
300                             DPRINTF(InOrderUseDef, "[tid:%i]: Forwarding dest."
301                                     " reg %i (%i), value 0x%x from "
302                                     "[sn:%i] to [sn:%i] source #%x.\n",
303                                     tid, reg_idx, flat_idx,
304                                     forward_inst->readIntResult(dest_reg_idx),
305                                     forward_inst->seqNum, 
306                                     inst->seqNum, ud_idx);
307                             inst->setIntSrc(ud_idx, 
308                                             forward_inst->
309                                             readIntResult(dest_reg_idx));
310                         }
311                         break;
312 
313                       case FloatRegClass:
314                         {
315                             DPRINTF(InOrderUseDef, "[tid:%i]: Forwarding dest."
316                                     " reg %i (%i) value 0x%x from "
317                                     "[sn:%i] to [sn:%i] source #%i.\n",
318                                     tid, reg_idx - FP_Reg_Base, flat_idx,
319                                     forward_inst->readFloatResult(dest_reg_idx),
320                                     forward_inst->seqNum, inst->seqNum, ud_idx);
321                             inst->setFloatSrc(ud_idx,
322                                               forward_inst->
323                                               readFloatResult(dest_reg_idx));
324                         }
325                         break;
326 
327                       case MiscRegClass:
328                         {
329                             DPRINTF(InOrderUseDef, "[tid:%i]: Forwarding dest."
330                                     " reg %i (%i) value 0x%x from "
331                                     "[sn:%i] to [sn:%i] source #%i.\n",
332                                     tid, reg_idx - Misc_Reg_Base, flat_idx,
333                                     forward_inst->readIntResult(dest_reg_idx),
334                                     forward_inst->seqNum, 
335                                     inst->seqNum, ud_idx);
336                             inst->setIntSrc(ud_idx, 
337                                             forward_inst->
338                                             readIntResult(dest_reg_idx));
339                         }
340                         break;
341 
342                       default:
343                         panic("Invalid Register Type: %i", reg_type);
344                     }
345 
346                     regForwards++;
347                     ud_req->done();
348                 } else {
349                     DPRINTF(InOrderUseDef, "[tid:%i]: Source register idx: %i "
350                             "is not ready to read.\n",
351                             tid, reg_idx);
352                     DPRINTF(InOrderStall, "STALL: [tid:%i]: waiting to read "
353                             "register (idx=%i)\n",
354                             tid, reg_idx);
355                     ud_req->done(false);
356                 }
357             }
358         }
359         break;
360 
361       case WriteDestReg:
362         {
363             RegClass reg_type;
364             RegIndex reg_idx = inst->_destRegIdx[ud_idx];
365             RegIndex flat_idx = cpu->flattenRegIdx(reg_idx, reg_type, tid);
366 
367             if (flat_idx == TheISA::ZeroReg && reg_type == IntRegClass) {
368                 DPRINTF(IntRegs, "[tid:%i]: Ignoring Writing of ISA-ZeroReg "
369                         "(Int. Reg %i)\n", tid, flat_idx);
370                 ud_req->done();
371                 return;
372             }
373 
374             if (regDepMap[tid]->canWrite(reg_type, flat_idx, inst)) {
375                 DPRINTF(InOrderUseDef, "[tid:%i]: [sn:%i]: Flattening register id
      x %i "
376                         "(%i) and Attempting to write to Register File.\n",
377                         tid, seq_num, reg_idx, flat_idx);
378 
379                 switch (reg_type)
380                 {
381                   case IntRegClass:
382                     {
383                         uniqueIntRegMap[flat_idx] = true;
384 
385                         DPRINTF(InOrderUseDef, "[tid:%i]: [sn:%i]: Writing Int. R
      esult "
386                                 "0x%x to register idx %i (%i).\n",
387                                 tid, seq_num, inst->readIntResult(ud_idx),
388                                 reg_idx, flat_idx);
389 
390                         // Remove Dependencies
391                         regDepMap[tid]->removeFront(reg_type, flat_idx, inst);
392 
393                         cpu->setIntReg(flat_idx,
394                                        inst->readIntResult(ud_idx),
395                                        inst->readTid());
396                         intRegFileWrites++;
397                     }
398                     break;
399 
400                   case FloatRegClass:
401                     {
402                         uniqueFloatRegMap[flat_idx] = true;
403 
404                         // Remove Reg. Dependecny Block on this Register
405                         regDepMap[tid]->removeFront(reg_type, flat_idx, inst);
406 
407                         if (inst->resultType(ud_idx) == 
408                             InOrderDynInst::FloatBits) {
409                             DPRINTF(InOrderUseDef, "[tid:%i]: [sn:%i]: Writing FP
      -Bits "
410                                     "Result %08f (bits:0x%x) to register "
411                                     "idx %i (%i).\n",
412                                     tid, seq_num,
413                                     inst->readFloatResult(ud_idx), 
414                                     inst->readFloatBitsResult(ud_idx),
415                                     reg_idx - FP_Reg_Base, flat_idx);
416 
417                             // Check for FloatRegBits Here
418                             cpu->setFloatRegBits(flat_idx,
419                                                  inst->readFloatBitsResult(ud_idx
      ),
420                                                  inst->readTid());
421                         } else if (inst->resultType(ud_idx) == 
422                                    InOrderDynInst::Float) {
423                             DPRINTF(InOrderUseDef, "[tid:%i]: [sn:%i]: Writing Fl
      oat "
424                                     "Result %08f (bits:0x%x) to register "
425                                     "idx %i (%i).\n",
426                                     tid, seq_num, inst->readFloatResult(ud_idx),
427                                     inst->readIntResult(ud_idx), 
428                                     reg_idx - FP_Reg_Base, flat_idx);
429 
430                             cpu->setFloatReg(flat_idx,
431                                              inst->readFloatResult(ud_idx),
432                                              inst->readTid());
433                         } else if (inst->resultType(ud_idx) == 
434                                    InOrderDynInst::Double) {
435                             DPRINTF(InOrderUseDef, "[tid:%i]: [sn:%i]: Writing Do
      uble "
436                                     "Result %08f (bits:0x%x) to register "
437                                     "idx %i (%i).\n",
438                                     tid, seq_num,
439                                     inst->readFloatResult(ud_idx), 
440                                     inst->readIntResult(ud_idx), 
441                                     reg_idx - FP_Reg_Base, flat_idx);
442 
443                             cpu->setFloatReg(flat_idx,
444                                              inst->readFloatResult(ud_idx),
445                                              inst->readTid());
446                         } else {
447                             panic("Result Type Not Set For [sn:%i] %s.\n", 
448                                   inst->seqNum, inst->instName());
449                         }
450 
451                         floatRegFileWrites++;
452                     }
453                     break;
454 
455                   case MiscRegClass:
456                     {
457                         uniqueMiscRegMap[flat_idx] = true;
458 
459                         DPRINTF(InOrderUseDef, "[tid:%i]: Writing Misc. 0x%x "
460                                 "to register idx %i.\n",
461                                 tid, inst->readIntResult(ud_idx), reg_idx - 
      Misc_Reg_Base);
462 
463                         // Remove Dependencies
464                         regDepMap[tid]->removeFront(reg_type, flat_idx, inst);
465 
466                         cpu->setMiscReg(flat_idx,
467                                     inst->readIntResult(ud_idx),
468                                         inst->readTid());
469                     }
470                     break;
471 
472                   default:
473                     panic("Invalid Register Type: %i", reg_type);
474                 }
475 
476                 ud_req->done();
477             } else {
478                 DPRINTF(InOrderUseDef, "[tid:%i]: [sn:%i]: Dest. register idx: %i
       is "
479                         "not ready to write.\n",
480                         tid, seq_num, reg_idx);
481                 DPRINTF(InOrderStall, "STALL: [tid:%i]: waiting to write "
482                         "register (idx=%i)\n",
483                         tid, reg_idx);
484                 ud_req->done(false);
485             }
486         }
487         break;
488 
489       case MarkDestRegs:
490         {
491             regDepMap[tid]->insert(inst);
492             ud_req->done();
493         }
494         break;
495 
496       default:
497         fatal("Unrecognized command to %s", resName);
498     }
499 
500 }
\end{DoxyCode}
\hypertarget{classUseDefUnit_ae3afc1c63d17a49a6301bd18fca574a0}{
\index{UseDefUnit@{UseDefUnit}!findRequest@{findRequest}}
\index{findRequest@{findRequest}!UseDefUnit@{UseDefUnit}}
\subsubsection[{findRequest}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ResReqPtr} findRequest ({\bf DynInstPtr} {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classUseDefUnit_ae3afc1c63d17a49a6301bd18fca574a0}
Find the request that corresponds to this instruction 

\hyperlink{classResource_ae3afc1c63d17a49a6301bd18fca574a0}{Resource}を再定義しています。


\begin{DoxyCode}
137 {
138     for (int i = 0; i < width; i++) {
139         UseDefRequest* ud_req =
140             dynamic_cast<UseDefRequest*>(reqs[i]);
141         assert(ud_req);
142 
143         if (ud_req->valid &&
144             ud_req->getInst() == inst &&
145             ud_req->cmd == inst->curSkedEntry->cmd &&
146             ud_req->useDefIdx == inst->curSkedEntry->idx) {
147             return ud_req;
148         }
149     }
150 
151     return NULL;
152 }
\end{DoxyCode}
\hypertarget{classUseDefUnit_aae5ce84f94a1057d7f60172daf5d731d}{
\index{UseDefUnit@{UseDefUnit}!getRequest@{getRequest}}
\index{getRequest@{getRequest}!UseDefUnit@{UseDefUnit}}
\subsubsection[{getRequest}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ResReqPtr} getRequest ({\bf DynInstPtr} {\em \_\-inst}, \/  int {\em stage\_\-num}, \/  int {\em res\_\-idx}, \/  int {\em slot\_\-num}, \/  unsigned {\em cmd})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classUseDefUnit_aae5ce84f94a1057d7f60172daf5d731d}
\hyperlink{classRequest}{Request} usage of a resource for this instruction. If this instruction already has made this request to this resource, and that request is uncompleted this function will just return that request 

\hyperlink{classResource_aae5ce84f94a1057d7f60172daf5d731d}{Resource}を再定義しています。


\begin{DoxyCode}
127 {
128     UseDefRequest *ud_req = dynamic_cast<UseDefRequest*>(reqs[slot_num]);
129     ud_req->setRequest(inst, stage_num, id, slot_num, cmd,
130                        inst->curSkedEntry->idx);
131     return ud_req;
132 }
\end{DoxyCode}
\hypertarget{classUseDefUnit_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{UseDefUnit@{UseDefUnit}!init@{init}}
\index{init@{init}!UseDefUnit@{UseDefUnit}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classUseDefUnit_a02fd73d861ef2e4aabb38c0c9ff82947}
Any extra initiliazation stuff can be set up using this function that should get called before the simulation starts (tick 0) 

\hyperlink{classResource_a02fd73d861ef2e4aabb38c0c9ff82947}{Resource}を再定義しています。


\begin{DoxyCode}
109 {
110     // Set Up Resource Events to Appropriate Resource BandWidth
111     if (latency > Cycles(0)) {
112         resourceEvent = new ResourceEvent[width];
113     } else {
114         resourceEvent = NULL;
115     }
116 
117     for (int i = 0; i < width; i++) {
118         reqs[i] = new UseDefRequest(this);
119     }
120 
121     initSlots();
122 }
\end{DoxyCode}
\hypertarget{classUseDefUnit_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{UseDefUnit@{UseDefUnit}!regStats@{regStats}}
\index{regStats@{regStats}!UseDefUnit@{UseDefUnit}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classUseDefUnit_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} \hyperlink{namespaceStats}{Stats} for this resource 

\hyperlink{classResource_ac1739a9be0fbd5d96cf441cd3b2c1c78}{Resource}を再定義しています。


\begin{DoxyCode}
65 {
66     uniqueRegsPerSwitch
67         .name(name() + ".uniqueRegsPerSwitch")
68         .desc("Number of Unique Registers Needed Per Context Switch")
69         .prereq(uniqueRegsPerSwitch);
70 
71     intRegFileReads
72         .name(name() + ".intRegFileReads")
73         .desc("Number of Reads from Int. Register File");
74 
75     intRegFileWrites
76         .name(name() + ".intRegFileWrites")
77         .desc("Number of Writes to Int. Register File");
78 
79     intRegFileAccs
80         .name(name() + ".intRegFileAccesses")
81         .desc("Total Accesses (Read+Write) to the Int. Register File");
82     intRegFileAccs = intRegFileReads + intRegFileWrites;
83 
84     floatRegFileReads
85         .name(name() + ".floatRegFileReads")
86         .desc("Number of Reads from FP Register File");
87 
88     floatRegFileWrites
89         .name(name() + ".floatRegFileWrites")
90         .desc("Number of Writes to FP Register File");
91 
92     floatRegFileAccs
93         .name(name() + ".floatRegFileAccesses")
94         .desc("Total Accesses (Read+Write) to the FP Register File");
95     floatRegFileAccs = floatRegFileReads + floatRegFileWrites;
96 
97     //@todo: add miscreg reads/writes
98     //       add forwarding by type???
99 
100     regForwards
101         .name(name() + ".regForwards")
102         .desc("Number of Registers Read Through Forwarding Logic");
103     
104     Resource::regStats();
105 }
\end{DoxyCode}
\hypertarget{classUseDefUnit_a339073618ad3c21c492d64a55ce2e216}{
\index{UseDefUnit@{UseDefUnit}!updateAfterContextSwitch@{updateAfterContextSwitch}}
\index{updateAfterContextSwitch@{updateAfterContextSwitch}!UseDefUnit@{UseDefUnit}}
\subsubsection[{updateAfterContextSwitch}]{\setlength{\rightskip}{0pt plus 5cm}void updateAfterContextSwitch ({\bf DynInstPtr} {\em inst}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classUseDefUnit_a339073618ad3c21c492d64a55ce2e216}
Will be called the cycle before a context switch. Any bookkeeping that needs to be kept for that, can be done here 

\hyperlink{classResource_a2cf5450ce736e0c76aca0d4ef24b922a}{Resource}を再定義しています。


\begin{DoxyCode}
504 {
505     uniqueRegsPerSwitch = uniqueIntRegMap.size() + uniqueFloatRegMap.size()
506         + uniqueMiscRegMap.size();
507     uniqueIntRegMap.clear();
508     uniqueFloatRegMap.clear();
509     uniqueMiscRegMap.clear();
510 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classUseDefUnit_a71fd5719f07c55c81f0296e2835a7c90}{
\index{UseDefUnit@{UseDefUnit}!floatRegFileAccs@{floatRegFileAccs}}
\index{floatRegFileAccs@{floatRegFileAccs}!UseDefUnit@{UseDefUnit}}
\subsubsection[{floatRegFileAccs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf floatRegFileAccs}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUseDefUnit_a71fd5719f07c55c81f0296e2835a7c90}
Float \hyperlink{classRegister}{Register} File Total Accesses (Read+Write) \hypertarget{classUseDefUnit_a51481d49e9355c25c8afa3553771605d}{
\index{UseDefUnit@{UseDefUnit}!floatRegFileReads@{floatRegFileReads}}
\index{floatRegFileReads@{floatRegFileReads}!UseDefUnit@{UseDefUnit}}
\subsubsection[{floatRegFileReads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf floatRegFileReads}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUseDefUnit_a51481d49e9355c25c8afa3553771605d}
Float \hyperlink{classRegister}{Register} File Reads \hypertarget{classUseDefUnit_a5b7ee045b5715d8abb9d7e17502e6f09}{
\index{UseDefUnit@{UseDefUnit}!floatRegFileWrites@{floatRegFileWrites}}
\index{floatRegFileWrites@{floatRegFileWrites}!UseDefUnit@{UseDefUnit}}
\subsubsection[{floatRegFileWrites}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf floatRegFileWrites}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUseDefUnit_a5b7ee045b5715d8abb9d7e17502e6f09}
Float \hyperlink{classRegister}{Register} File Writes \hypertarget{classUseDefUnit_abf73f69eb2ade79a3b55b431699c6d07}{
\index{UseDefUnit@{UseDefUnit}!intRegFileAccs@{intRegFileAccs}}
\index{intRegFileAccs@{intRegFileAccs}!UseDefUnit@{UseDefUnit}}
\subsubsection[{intRegFileAccs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf intRegFileAccs}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUseDefUnit_abf73f69eb2ade79a3b55b431699c6d07}
Int. \hyperlink{classRegister}{Register} File Total Accesses (Read+Write) \hypertarget{classUseDefUnit_a67e958fedd10dfe72747865179154882}{
\index{UseDefUnit@{UseDefUnit}!intRegFileReads@{intRegFileReads}}
\index{intRegFileReads@{intRegFileReads}!UseDefUnit@{UseDefUnit}}
\subsubsection[{intRegFileReads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf intRegFileReads}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUseDefUnit_a67e958fedd10dfe72747865179154882}
Int. \hyperlink{classRegister}{Register} File Reads \hypertarget{classUseDefUnit_aa79e36dab324cdcb339de91d5b21f03b}{
\index{UseDefUnit@{UseDefUnit}!intRegFileWrites@{intRegFileWrites}}
\index{intRegFileWrites@{intRegFileWrites}!UseDefUnit@{UseDefUnit}}
\subsubsection[{intRegFileWrites}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf intRegFileWrites}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUseDefUnit_aa79e36dab324cdcb339de91d5b21f03b}
Int. \hyperlink{classRegister}{Register} File Writes \hypertarget{classUseDefUnit_aa27d1c9b589af0c77a81c490021c7dcb}{
\index{UseDefUnit@{UseDefUnit}!nonSpecInstActive@{nonSpecInstActive}}
\index{nonSpecInstActive@{nonSpecInstActive}!UseDefUnit@{UseDefUnit}}
\subsubsection[{nonSpecInstActive}]{\setlength{\rightskip}{0pt plus 5cm}bool$\ast$ {\bf nonSpecInstActive}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUseDefUnit_aa27d1c9b589af0c77a81c490021c7dcb}
\hypertarget{classUseDefUnit_a899b1bc10d38a0f725495bf2108479a3}{
\index{UseDefUnit@{UseDefUnit}!nonSpecSeqNum@{nonSpecSeqNum}}
\index{nonSpecSeqNum@{nonSpecSeqNum}!UseDefUnit@{UseDefUnit}}
\subsubsection[{nonSpecSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum}$\ast$ {\bf nonSpecSeqNum}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUseDefUnit_a899b1bc10d38a0f725495bf2108479a3}
\hypertarget{classUseDefUnit_aa0933c90c5ced66e85669c2982b165a6}{
\index{UseDefUnit@{UseDefUnit}!regDepMap@{regDepMap}}
\index{regDepMap@{regDepMap}!UseDefUnit@{UseDefUnit}}
\subsubsection[{regDepMap}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RegDepMap}$\ast$ {\bf regDepMap}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUseDefUnit_aa0933c90c5ced66e85669c2982b165a6}
\hypertarget{classUseDefUnit_a37cb2ded859693943151bfb454bcc97f}{
\index{UseDefUnit@{UseDefUnit}!regForwards@{regForwards}}
\index{regForwards@{regForwards}!UseDefUnit@{UseDefUnit}}
\subsubsection[{regForwards}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf regForwards}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUseDefUnit_a37cb2ded859693943151bfb454bcc97f}
Source \hyperlink{classRegister}{Register} Forwarding \hypertarget{classUseDefUnit_a699cfb06a053ac682026566662b62453}{
\index{UseDefUnit@{UseDefUnit}!serializeAfterSeqNum@{serializeAfterSeqNum}}
\index{serializeAfterSeqNum@{serializeAfterSeqNum}!UseDefUnit@{UseDefUnit}}
\subsubsection[{serializeAfterSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf serializeAfterSeqNum}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUseDefUnit_a699cfb06a053ac682026566662b62453}
\hypertarget{classUseDefUnit_ad4300fb3f2f2ddebbfd44bbcad133c56}{
\index{UseDefUnit@{UseDefUnit}!serializeOnNextInst@{serializeOnNextInst}}
\index{serializeOnNextInst@{serializeOnNextInst}!UseDefUnit@{UseDefUnit}}
\subsubsection[{serializeOnNextInst}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf serializeOnNextInst}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUseDefUnit_ad4300fb3f2f2ddebbfd44bbcad133c56}
\hypertarget{classUseDefUnit_a148e8f7c874a196ab74ca1f39662c98c}{
\index{UseDefUnit@{UseDefUnit}!uniqueFloatRegMap@{uniqueFloatRegMap}}
\index{uniqueFloatRegMap@{uniqueFloatRegMap}!UseDefUnit@{UseDefUnit}}
\subsubsection[{uniqueFloatRegMap}]{\setlength{\rightskip}{0pt plus 5cm}std::map$<${\bf RegIndex}, bool$>$ {\bf uniqueFloatRegMap}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUseDefUnit_a148e8f7c874a196ab74ca1f39662c98c}
\hypertarget{classUseDefUnit_a007316fc06c43d3c786e79da6f3a5265}{
\index{UseDefUnit@{UseDefUnit}!uniqueIntRegMap@{uniqueIntRegMap}}
\index{uniqueIntRegMap@{uniqueIntRegMap}!UseDefUnit@{UseDefUnit}}
\subsubsection[{uniqueIntRegMap}]{\setlength{\rightskip}{0pt plus 5cm}std::map$<${\bf RegIndex}, bool$>$ {\bf uniqueIntRegMap}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUseDefUnit_a007316fc06c43d3c786e79da6f3a5265}
\hypertarget{classUseDefUnit_aeab2bd090cc9b29fbf5f386013dd79fd}{
\index{UseDefUnit@{UseDefUnit}!uniqueMiscRegMap@{uniqueMiscRegMap}}
\index{uniqueMiscRegMap@{uniqueMiscRegMap}!UseDefUnit@{UseDefUnit}}
\subsubsection[{uniqueMiscRegMap}]{\setlength{\rightskip}{0pt plus 5cm}std::map$<${\bf RegIndex}, bool$>$ {\bf uniqueMiscRegMap}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUseDefUnit_aeab2bd090cc9b29fbf5f386013dd79fd}
\hypertarget{classUseDefUnit_a796c1916448138c736618531476b9801}{
\index{UseDefUnit@{UseDefUnit}!uniqueRegsPerSwitch@{uniqueRegsPerSwitch}}
\index{uniqueRegsPerSwitch@{uniqueRegsPerSwitch}!UseDefUnit@{UseDefUnit}}
\subsubsection[{uniqueRegsPerSwitch}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Average} {\bf uniqueRegsPerSwitch}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUseDefUnit_a796c1916448138c736618531476b9801}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/inorder/resources/\hyperlink{use__def_8hh}{use\_\-def.hh}\item 
cpu/inorder/resources/\hyperlink{use__def_8cc}{use\_\-def.cc}\end{DoxyCompactItemize}
