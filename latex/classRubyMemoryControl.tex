\hypertarget{classRubyMemoryControl}{
\section{クラス RubyMemoryControl}
\label{classRubyMemoryControl}\index{RubyMemoryControl@{RubyMemoryControl}}
}


{\ttfamily \#include $<$RubyMemoryControl.hh$>$}RubyMemoryControlに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=5cm]{classRubyMemoryControl}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classRubyMemoryControl_1_1RubyMemoryControl}{RubyMemoryControl}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef RubyMemoryControlParams \hyperlink{classRubyMemoryControl_af43d4e91847a2856227bcb75a70a9a86}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classRubyMemoryControl_a4f3e4d7624fbb425e553c4e36cadcba9}{RubyMemoryControl} (const \hyperlink{classRubyMemoryControl_af43d4e91847a2856227bcb75a70a9a86}{Params} $\ast$p)
\item 
void \hyperlink{classRubyMemoryControl_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
void \hyperlink{classRubyMemoryControl_ad20897c5c8bd47f5d4005989bead0e55}{reset} ()
\item 
\hyperlink{classRubyMemoryControl_ac811a91e31835fa2b05aec4314ca6870}{$\sim$RubyMemoryControl} ()
\item 
unsigned int \hyperlink{classRubyMemoryControl_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)
\item 
void \hyperlink{classRubyMemoryControl_ae674290a26ecbd622c5160e38e8a4fe9}{wakeup} ()
\item 
void \hyperlink{classRubyMemoryControl_a8487c37680239f103e21ada9acf1726d}{setConsumer} (\hyperlink{classConsumer}{Consumer} $\ast$consumer\_\-ptr)
\item 
\hyperlink{classConsumer}{Consumer} $\ast$ \hyperlink{classRubyMemoryControl_a2417fc7252a612b5c976ceaa2d1be4f7}{getConsumer} ()
\item 
void \hyperlink{classRubyMemoryControl_a9cdbe64eebafb111a124edec55ed2340}{setDescription} (const std::string \&name)
\item 
std::string \hyperlink{classRubyMemoryControl_a73da75c3e5ec30855a02eae2ba824e38}{getDescription} ()
\item 
void \hyperlink{classRubyMemoryControl_a068a03cd419d33592fd584ec5877bb64}{enqueue} (const \hyperlink{classRefCountingPtr}{MsgPtr} \&message, \hyperlink{classCycles}{Cycles} latency)
\item 
void \hyperlink{classRubyMemoryControl_aadad7bc8b989cfe93247844131735f70}{enqueueMemRef} (\hyperlink{classMemoryNode}{MemoryNode} $\ast$memRef)
\item 
void \hyperlink{classRubyMemoryControl_a851b6644e3e336c07f8e6fe77234b97f}{dequeue} ()
\item 
const \hyperlink{classMessage}{Message} $\ast$ \hyperlink{classRubyMemoryControl_ab635dc32ebecf260c15d8fbbbb9b21e0}{peek} ()
\item 
\hyperlink{classMemoryNode}{MemoryNode} $\ast$ \hyperlink{classRubyMemoryControl_a8ffbfb520369710755a1260b8451de3d}{peekNode} ()
\item 
bool \hyperlink{classRubyMemoryControl_acbed040576a7a18e2d9c46b2f15e0162}{isReady} ()
\item 
bool \hyperlink{classRubyMemoryControl_a99a0d76f7266570912e6b0901cfaf9cf}{areNSlotsAvailable} (int n)
\item 
void \hyperlink{classRubyMemoryControl_ac55fe386a101fbae38c716067c9966a0}{print} (std::ostream \&out) const 
\item 
void \hyperlink{classRubyMemoryControl_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
const int \hyperlink{classRubyMemoryControl_a26f571eb9a81a077295b54c2ed398aea}{getBank} (const \hyperlink{TypeDefines_8hh_a7901e1a365850c5ff38ec6e12b6b9ffc}{physical\_\-address\_\-t} addr) const 
\item 
const int \hyperlink{classRubyMemoryControl_af8c39d7c9853a48fd242bda859e76222}{getRank} (const \hyperlink{TypeDefines_8hh_a7901e1a365850c5ff38ec6e12b6b9ffc}{physical\_\-address\_\-t} addr) const 
\item 
const int \hyperlink{classRubyMemoryControl_a08f255b8eb3b262916a47fa8f7c12e63}{getChannel} (const \hyperlink{TypeDefines_8hh_a7901e1a365850c5ff38ec6e12b6b9ffc}{physical\_\-address\_\-t} addr) const 
\item 
const int \hyperlink{classRubyMemoryControl_a65314c26cf3c85d8c911524ede56456c}{getRow} (const \hyperlink{TypeDefines_8hh_a7901e1a365850c5ff38ec6e12b6b9ffc}{physical\_\-address\_\-t} addr) const 
\item 
int \hyperlink{classRubyMemoryControl_aba6f6d5c066193ae70ee43153051055b}{getBanksPerRank} ()
\item 
int \hyperlink{classRubyMemoryControl_a6dff017ebfbd9d5b021b86437ff67acc}{getRanksPerDimm} ()
\item 
int \hyperlink{classRubyMemoryControl_a5a9c0e20c20d0171bb8d8a96cb22576f}{getDimmsPerChannel} ()
\item 
bool \hyperlink{classRubyMemoryControl_a898941f27bcf3a1c0383de5988406650}{functionalReadBuffers} (\hyperlink{classPacket}{Packet} $\ast$pkt)
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classRubyMemoryControl_a08f04f912fb872935cb2d40f8570c340}{functionalWriteBuffers} (\hyperlink{classPacket}{Packet} $\ast$pkt)
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classRubyMemoryControl_a5ad0e6ec636d4094ee1b89c121d37dd9}{enqueueToDirectory} (\hyperlink{classMemoryNode}{MemoryNode} $\ast$req, \hyperlink{classCycles}{Cycles} latency)
\item 
const int \hyperlink{classRubyMemoryControl_a39abe91d99c7b551495766a397e212af}{getRank} (int bank) const 
\item 
bool \hyperlink{classRubyMemoryControl_a839c1841354bab0a9007a04ba303ae2c}{queueReady} (int bank)
\item 
void \hyperlink{classRubyMemoryControl_a9dbeedd7a40a225736f517e46ef9915e}{issueRequest} (int bank)
\item 
bool \hyperlink{classRubyMemoryControl_a3907d2ad8de317b5d9488e567b8c29de}{issueRefresh} (int bank)
\item 
void \hyperlink{classRubyMemoryControl_a8fb7d0c7e12bbd524e3bcd193e66426c}{markTfaw} (int rank)
\item 
void \hyperlink{classRubyMemoryControl_ac776b02b70a3c6795e0823d77bf74c73}{executeCycle} ()
\item 
\hyperlink{classRubyMemoryControl_a91e8e84c0a773621f4e6f5adafb726fb}{RubyMemoryControl} (const \hyperlink{classRubyMemoryControl_1_1RubyMemoryControl}{RubyMemoryControl} \&obj)
\item 
\hyperlink{classRubyMemoryControl_1_1RubyMemoryControl}{RubyMemoryControl} \& \hyperlink{classRubyMemoryControl_a625dea61d2ea0f477b1310e9307a33d6}{operator=} (const \hyperlink{classRubyMemoryControl_1_1RubyMemoryControl}{RubyMemoryControl} \&obj)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classConsumer}{Consumer} $\ast$ \hyperlink{classRubyMemoryControl_a83dd1dc8eef330b0c0d184a4167b26b4}{m\_\-consumer\_\-ptr}
\item 
std::string \hyperlink{classRubyMemoryControl_ad50eef5f7fcfa30f62e14f0fac2a4f6e}{m\_\-description}
\item 
int \hyperlink{classRubyMemoryControl_acfac131e63985feff04ed11cbaf0d221}{m\_\-msg\_\-counter}
\item 
int \hyperlink{classRubyMemoryControl_af5a8b76f5c8fdb638e49a8c11c61f492}{m\_\-banks\_\-per\_\-rank}
\item 
int \hyperlink{classRubyMemoryControl_a734869c8bd10780ed7f61eadb638f30c}{m\_\-ranks\_\-per\_\-dimm}
\item 
int \hyperlink{classRubyMemoryControl_acf7c3dd8c1a61ce9fe7ca2e026150caf}{m\_\-dimms\_\-per\_\-channel}
\item 
int \hyperlink{classRubyMemoryControl_a767e3298a0e794bb0c8f422021e6b67d}{m\_\-bank\_\-bit\_\-0}
\item 
int \hyperlink{classRubyMemoryControl_a2262efb9776ae0e8119e999c6efed38b}{m\_\-rank\_\-bit\_\-0}
\item 
int \hyperlink{classRubyMemoryControl_a9d9676a8a7c87644cefbe758f0ef719c}{m\_\-dimm\_\-bit\_\-0}
\item 
unsigned int \hyperlink{classRubyMemoryControl_a6cbe212586b315223f76b124953ea4b2}{m\_\-bank\_\-queue\_\-size}
\item 
int \hyperlink{classRubyMemoryControl_ab11322175e2e2ec5d6ebef835774bc1a}{m\_\-bank\_\-busy\_\-time}
\item 
int \hyperlink{classRubyMemoryControl_a88f33889677c076f1e5fdd8ce7cabc4d}{m\_\-rank\_\-rank\_\-delay}
\item 
int \hyperlink{classRubyMemoryControl_a469ba8ed68dfdab637a67909cd7f494f}{m\_\-read\_\-write\_\-delay}
\item 
int \hyperlink{classRubyMemoryControl_a0537255983f6c88ed3389efd814780e5}{m\_\-basic\_\-bus\_\-busy\_\-time}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classRubyMemoryControl_aaf9472c80a44349fbb83ec29ce2de7ad}{m\_\-mem\_\-ctl\_\-latency}
\item 
int \hyperlink{classRubyMemoryControl_ab046d0568e576a3fd3e751aae694aa6c}{m\_\-refresh\_\-period}
\item 
int \hyperlink{classRubyMemoryControl_a84dc4df49177ba4931742af171541561}{m\_\-mem\_\-random\_\-arbitrate}
\item 
int \hyperlink{classRubyMemoryControl_a278ccfdcd299cca636085e30b57bd77b}{m\_\-tFaw}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classRubyMemoryControl_add64256c91bc7722347f3a8dfe94d375}{m\_\-mem\_\-fixed\_\-delay}
\item 
int \hyperlink{classRubyMemoryControl_ad36478de555240b1cd80c5b0aa4b00cc}{m\_\-total\_\-banks}
\item 
int \hyperlink{classRubyMemoryControl_ae56d0b2636a76e0d08eb304c9845540c}{m\_\-total\_\-ranks}
\item 
int \hyperlink{classRubyMemoryControl_ac226affdfdce1041cdc1adcea108d2d9}{m\_\-refresh\_\-period\_\-system}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classMemoryNode}{MemoryNode} $\ast$ $>$ \hyperlink{classRubyMemoryControl_a6ff73bc35f01b71460125c8973fdcf7f}{m\_\-response\_\-queue}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classMemoryNode}{MemoryNode} $\ast$ $>$ \hyperlink{classRubyMemoryControl_ad59ead9befd4b8ed53d20e31025cc5f2}{m\_\-input\_\-queue}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classMemoryNode}{MemoryNode} $\ast$ $>$ $\ast$ \hyperlink{classRubyMemoryControl_a66d0e61e247049647c7e205d7898f593}{m\_\-bankQueues}
\item 
int $\ast$ \hyperlink{classRubyMemoryControl_a258db92f2ca2cd3335e798fbe1cea189}{m\_\-bankBusyCounter}
\item 
int $\ast$ \hyperlink{classRubyMemoryControl_a546d324998c9280e60ad0d3bdc33b660}{m\_\-oldRequest}
\item 
\hyperlink{TypeDefines_8hh_a29940ae63ec06c9998bba873e25407ad}{uint64} $\ast$ \hyperlink{classRubyMemoryControl_a9dd1941af4ea267b9f8e05a54c70d713}{m\_\-tfaw\_\-shift}
\item 
int $\ast$ \hyperlink{classRubyMemoryControl_a8399af800996db69e2cb64997f0123f4}{m\_\-tfaw\_\-count}
\item 
int \hyperlink{classRubyMemoryControl_a4c6490a8d96034781b7f019c9875637d}{m\_\-busBusyCounter\_\-Write}
\item 
int \hyperlink{classRubyMemoryControl_a9396a0f34b9eb0d3c51bedc04de53b10}{m\_\-busBusyCounter\_\-ReadNewRank}
\item 
int \hyperlink{classRubyMemoryControl_a9622fd6ccdf6aaac725dd5b199651e1f}{m\_\-busBusyCounter\_\-Basic}
\item 
int \hyperlink{classRubyMemoryControl_a0889f6b503357c0dee9ca27b3a777a61}{m\_\-busBusy\_\-WhichRank}
\item 
int \hyperlink{classRubyMemoryControl_ae91016ac7543fa2d2e4fc5ba9748a134}{m\_\-roundRobin}
\item 
int \hyperlink{classRubyMemoryControl_a11c845239e7ec76861ae230df7a575b2}{m\_\-refresh\_\-count}
\item 
int \hyperlink{classRubyMemoryControl_a81b8cb5d4100808f5d49ebb9e7f878bd}{m\_\-need\_\-refresh}
\item 
int \hyperlink{classRubyMemoryControl_a93843e73be2e39683d2b6ce21c8a6298}{m\_\-refresh\_\-bank}
\item 
int \hyperlink{classRubyMemoryControl_aba1d5e3376d7d3bed53b2bafcd056c64}{m\_\-ageCounter}
\item 
int \hyperlink{classRubyMemoryControl_a1b496ca0cf94387967ed0539a43fb126}{m\_\-idleCount}
\item 
\hyperlink{classMemCntrlProfiler}{MemCntrlProfiler} $\ast$ \hyperlink{classRubyMemoryControl_a1f70f7199575ca8bd58b685a72c37f84}{m\_\-profiler\_\-ptr}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classRubyMemoryControl_af43d4e91847a2856227bcb75a70a9a86}{
\index{RubyMemoryControl@{RubyMemoryControl}!Params@{Params}}
\index{Params@{Params}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef RubyMemoryControlParams {\bf Params}}}
\label{classRubyMemoryControl_af43d4e91847a2856227bcb75a70a9a86}


\hyperlink{classMemoryControl_aec6d67eaecba2a2311edc4c4c78fb0f5}{MemoryControl}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classRubyMemoryControl_a4f3e4d7624fbb425e553c4e36cadcba9}{
\index{RubyMemoryControl@{RubyMemoryControl}!RubyMemoryControl@{RubyMemoryControl}}
\index{RubyMemoryControl@{RubyMemoryControl}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{RubyMemoryControl}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RubyMemoryControl} (const {\bf Params} $\ast$ {\em p})}}
\label{classRubyMemoryControl_a4f3e4d7624fbb425e553c4e36cadcba9}



\begin{DoxyCode}
147     : MemoryControl(p)
148 {
149     m_banks_per_rank = p->banks_per_rank;
150     m_ranks_per_dimm = p->ranks_per_dimm;
151     m_dimms_per_channel = p->dimms_per_channel;
152     m_bank_bit_0 = p->bank_bit_0;
153     m_rank_bit_0 = p->rank_bit_0;
154     m_dimm_bit_0 = p->dimm_bit_0;
155     m_bank_queue_size = p->bank_queue_size;
156     m_bank_busy_time = p->bank_busy_time;
157     m_rank_rank_delay = p->rank_rank_delay;
158     m_read_write_delay = p->read_write_delay;
159     m_basic_bus_busy_time = p->basic_bus_busy_time;
160     m_mem_ctl_latency = p->mem_ctl_latency;
161     m_refresh_period = p->refresh_period;
162     m_tFaw = p->tFaw;
163     m_mem_random_arbitrate = p->mem_random_arbitrate;
164     m_mem_fixed_delay = p->mem_fixed_delay;
165 
166     m_profiler_ptr = new MemCntrlProfiler(name(),
167                                           m_banks_per_rank,
168                                           m_ranks_per_dimm,
169                                           m_dimms_per_channel);
170 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_ac811a91e31835fa2b05aec4314ca6870}{
\index{RubyMemoryControl@{RubyMemoryControl}!$\sim$RubyMemoryControl@{$\sim$RubyMemoryControl}}
\index{$\sim$RubyMemoryControl@{$\sim$RubyMemoryControl}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{$\sim$RubyMemoryControl}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf RubyMemoryControl} ()}}
\label{classRubyMemoryControl_ac811a91e31835fa2b05aec4314ca6870}



\begin{DoxyCode}
268 {
269     delete [] m_bankQueues;
270     delete [] m_bankBusyCounter;
271     delete [] m_oldRequest;
272     delete m_profiler_ptr;
273 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a91e8e84c0a773621f4e6f5adafb726fb}{
\index{RubyMemoryControl@{RubyMemoryControl}!RubyMemoryControl@{RubyMemoryControl}}
\index{RubyMemoryControl@{RubyMemoryControl}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{RubyMemoryControl}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RubyMemoryControl} (const {\bf RubyMemoryControl} \& {\em obj})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a91e8e84c0a773621f4e6f5adafb726fb}


\subsection{関数}
\hypertarget{classRubyMemoryControl_a99a0d76f7266570912e6b0901cfaf9cf}{
\index{RubyMemoryControl@{RubyMemoryControl}!areNSlotsAvailable@{areNSlotsAvailable}}
\index{areNSlotsAvailable@{areNSlotsAvailable}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{areNSlotsAvailable}]{\setlength{\rightskip}{0pt plus 5cm}bool areNSlotsAvailable (int {\em n})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classRubyMemoryControl_a99a0d76f7266570912e6b0901cfaf9cf}


\hyperlink{classMemoryControl_ad5bc408383076d5b274d5c3be9b42c89}{MemoryControl}を実装しています。


\begin{DoxyCode}
81 { return true; };  // infinite queue length
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a851b6644e3e336c07f8e6fe77234b97f}{
\index{RubyMemoryControl@{RubyMemoryControl}!dequeue@{dequeue}}
\index{dequeue@{dequeue}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{dequeue}]{\setlength{\rightskip}{0pt plus 5cm}void dequeue ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_a851b6644e3e336c07f8e6fe77234b97f}


\hyperlink{classMemoryControl_abc9fc85f4dd561e833bf6b34a78ebcb8}{MemoryControl}を実装しています。


\begin{DoxyCode}
317 {
318     assert(isReady());
319     MemoryNode *req = m_response_queue.front();
320     m_response_queue.pop_front();
321     delete req;
322 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_aa8a18d230dba7a674ac8a0b4f35bc36a}{
\index{RubyMemoryControl@{RubyMemoryControl}!drain@{drain}}
\index{drain@{drain}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em drainManger})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_aa8a18d230dba7a674ac8a0b4f35bc36a}
Provide a default implementation of the drain interface that simply returns 0 (draining completed) and sets the drain state to Drained. 

\hyperlink{classSimObject_a6bf479c521c7c3eb473822d953275b26}{SimObject}を再定義しています。


\begin{DoxyCode}
675 {
676     DPRINTF(RubyMemory, "MemoryController drain\n");
677     if(m_event.scheduled()) {
678         deschedule(m_event);
679     }
680     return 0;
681 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a068a03cd419d33592fd584ec5877bb64}{
\index{RubyMemoryControl@{RubyMemoryControl}!enqueue@{enqueue}}
\index{enqueue@{enqueue}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{enqueue}]{\setlength{\rightskip}{0pt plus 5cm}void enqueue (const {\bf MsgPtr} \& {\em message}, \/  {\bf Cycles} {\em latency})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_a068a03cd419d33592fd584ec5877bb64}


\hyperlink{classMemoryControl_a8295a9f6c98555275292b9c1296ea35a}{MemoryControl}を実装しています。


\begin{DoxyCode}
278 {
279     Cycles arrival_time = curCycle() + latency;
280     const MemoryMsg* memMess = safe_cast<const MemoryMsg*>(message.get());
281     physical_address_t addr = memMess->getAddr().getAddress();
282     MemoryRequestType type = memMess->getType();
283     bool is_mem_read = (type == MemoryRequestType_MEMORY_READ);
284     MemoryNode *thisReq = new MemoryNode(arrival_time, message, addr,
285                                          is_mem_read, !is_mem_read);
286     enqueueMemRef(thisReq);
287 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_aadad7bc8b989cfe93247844131735f70}{
\index{RubyMemoryControl@{RubyMemoryControl}!enqueueMemRef@{enqueueMemRef}}
\index{enqueueMemRef@{enqueueMemRef}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{enqueueMemRef}]{\setlength{\rightskip}{0pt plus 5cm}void enqueueMemRef ({\bf MemoryNode} $\ast$ {\em memRef})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_aadad7bc8b989cfe93247844131735f70}


\hyperlink{classMemoryControl_a8c508812a5b1b935117dc32877229599}{MemoryControl}を実装しています。


\begin{DoxyCode}
293 {
294     m_msg_counter++;
295     memRef->m_msg_counter = m_msg_counter;
296     physical_address_t addr = memRef->m_addr;
297     int bank = getBank(addr);
298 
299     DPRINTF(RubyMemory,
300             "New memory request%7d: %#08x %c arrived at %10d bank = %3x sched %c\
      n",
301             m_msg_counter, addr, memRef->m_is_mem_read ? 'R':'W',
302             memRef->m_time * g_system_ptr->clockPeriod(),
303             bank, m_event.scheduled() ? 'Y':'N');
304 
305     m_profiler_ptr->profileMemReq(bank);
306     m_input_queue.push_back(memRef);
307 
308     if (!m_event.scheduled()) {
309         schedule(m_event, clockEdge());
310     }
311 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a5ad0e6ec636d4094ee1b89c121d37dd9}{
\index{RubyMemoryControl@{RubyMemoryControl}!enqueueToDirectory@{enqueueToDirectory}}
\index{enqueueToDirectory@{enqueueToDirectory}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{enqueueToDirectory}]{\setlength{\rightskip}{0pt plus 5cm}void enqueueToDirectory ({\bf MemoryNode} $\ast$ {\em req}, \/  {\bf Cycles} {\em latency})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a5ad0e6ec636d4094ee1b89c121d37dd9}



\begin{DoxyCode}
366 {
367     Tick arrival_time = clockEdge(latency);
368     Cycles ruby_arrival_time = g_system_ptr->ticksToCycles(arrival_time);
369     req->m_time = ruby_arrival_time;
370     m_response_queue.push_back(req);
371 
372     DPRINTF(RubyMemory, "Enqueueing msg %#08x %c back to directory at %15d\n",
373             req->m_addr, req->m_is_mem_read ? 'R':'W', arrival_time);
374 
375     // schedule the wake up
376     m_consumer_ptr->scheduleEventAbsolute(arrival_time);
377 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_ac776b02b70a3c6795e0823d77bf74c73}{
\index{RubyMemoryControl@{RubyMemoryControl}!executeCycle@{executeCycle}}
\index{executeCycle@{executeCycle}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{executeCycle}]{\setlength{\rightskip}{0pt plus 5cm}void executeCycle ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_ac776b02b70a3c6795e0823d77bf74c73}



\begin{DoxyCode}
573 {
574     // Keep track of time by counting down the busy counters:
575     for (int bank=0; bank < m_total_banks; bank++) {
576         if (m_bankBusyCounter[bank] > 0) m_bankBusyCounter[bank]--;
577     }
578     if (m_busBusyCounter_Write > 0)
579         m_busBusyCounter_Write--;
580     if (m_busBusyCounter_ReadNewRank > 0)
581         m_busBusyCounter_ReadNewRank--;
582     if (m_busBusyCounter_Basic > 0)
583         m_busBusyCounter_Basic--;
584 
585     // Count down the tFAW shift registers:
586     for (int rank=0; rank < m_total_ranks; rank++) {
587         if (m_tfaw_shift[rank] & 1) m_tfaw_count[rank]--;
588         m_tfaw_shift[rank] >>= 1;
589     }
590 
591     // After time period expires, latch an indication that we need a refresh.
592     // Disable refresh if in mem_fixed_delay mode.
593     if (!m_mem_fixed_delay) m_refresh_count--;
594     if (m_refresh_count == 0) {
595         m_refresh_count = m_refresh_period_system;
596 
597         // Are we overrunning our ability to refresh?
598         assert(m_need_refresh < 10);
599         m_need_refresh++;
600     }
601 
602     // If this batch of requests is all done, make a new batch:
603     m_ageCounter++;
604     int anyOld = 0;
605     for (int bank=0; bank < m_total_banks; bank++) {
606         anyOld |= m_oldRequest[bank];
607     }
608     if (!anyOld) {
609         for (int bank=0; bank < m_total_banks; bank++) {
610             if (!m_bankQueues[bank].empty()) m_oldRequest[bank] = 1;
611         }
612         m_ageCounter = 0;
613     }
614 
615     // If randomness desired, re-randomize round-robin position each cycle
616     if (m_mem_random_arbitrate) {
617         m_roundRobin = random() % m_total_banks;
618     }
619 
620     // For each channel, scan round-robin, and pick an old, ready
621     // request and issue it.  Treat a refresh request as if it were at
622     // the head of its bank queue.  After we issue something, keep
623     // scanning the queues just to gather statistics about how many
624     // are waiting.  If in mem_fixed_delay mode, we can issue more
625     // than one request per cycle.
626     int queueHeads = 0;
627     int banksIssued = 0;
628     for (int i = 0; i < m_total_banks; i++) {
629         m_roundRobin++;
630         if (m_roundRobin >= m_total_banks) m_roundRobin = 0;
631         issueRefresh(m_roundRobin);
632         int qs = m_bankQueues[m_roundRobin].size();
633         if (qs > 1) {
634             m_profiler_ptr->profileMemBankQ(qs-1);
635         }
636         if (qs > 0) {
637             // we're not idle if anything is queued
638             m_idleCount = IDLECOUNT_MAX_VALUE;
639             queueHeads++;
640             if (queueReady(m_roundRobin)) {
641                 issueRequest(m_roundRobin);
642                 banksIssued++;
643                 if (m_mem_fixed_delay) {
644                     m_profiler_ptr->profileMemWaitCycles(m_mem_fixed_delay);
645                 }
646             }
647         }
648     }
649 
650     // memWaitCycles is a redundant catch-all for the specific
651     // counters in queueReady
652     m_profiler_ptr->profileMemWaitCycles(queueHeads - banksIssued);
653 
654     // Check input queue and move anything to bank queues if not full.
655     // Since this is done here at the end of the cycle, there will
656     // always be at least one cycle of latency in the bank queue.  We
657     // deliberately move at most one request per cycle (to simulate
658     // typical hardware).  Note that if one bank queue fills up, other
659     // requests can get stuck behind it here.
660     if (!m_input_queue.empty()) {
661         // we're not idle if anything is pending
662         m_idleCount = IDLECOUNT_MAX_VALUE;
663         MemoryNode *req = m_input_queue.front();
664         int bank = getBank(req->m_addr);
665         if (m_bankQueues[bank].size() < m_bank_queue_size) {
666             m_input_queue.pop_front();
667             m_bankQueues[bank].push_back(req);
668         }
669         m_profiler_ptr->profileMemInputQ(m_input_queue.size());
670     }
671 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a898941f27bcf3a1c0383de5988406650}{
\index{RubyMemoryControl@{RubyMemoryControl}!functionalReadBuffers@{functionalReadBuffers}}
\index{functionalReadBuffers@{functionalReadBuffers}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{functionalReadBuffers}]{\setlength{\rightskip}{0pt plus 5cm}bool functionalReadBuffers ({\bf Packet} $\ast$ {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_a898941f27bcf3a1c0383de5988406650}
This function reads the different buffers that exist in the Ruby Memory \hyperlink{namespaceController}{Controller}, and figures out if any of the buffers hold a message that contains the data for the address provided in the packet. True is returned if any of the messages was read, otherwise false is returned.

I think we should move these buffers to being message buffers, instead of being lists. 

\hyperlink{classMemoryControl_ad587c16967cd8dc8b1dcb52a1ce0002b}{MemoryControl}を再定義しています。


\begin{DoxyCode}
709 {
710     for (std::list<MemoryNode *>::iterator it = m_input_queue.begin();
711          it != m_input_queue.end(); ++it) {
712         Message* msg_ptr = (*it)->m_msgptr.get();
713         if (msg_ptr->functionalRead(pkt)) {
714             return true;
715         }
716     }
717 
718     for (std::list<MemoryNode *>::iterator it = m_response_queue.begin();
719          it != m_response_queue.end(); ++it) {
720         Message* msg_ptr = (*it)->m_msgptr.get();
721         if (msg_ptr->functionalRead(pkt)) {
722             return true;
723         }
724     }
725 
726     for (uint32_t bank = 0; bank < m_total_banks; ++bank) {
727         for (std::list<MemoryNode *>::iterator it = m_bankQueues[bank].begin();
728              it != m_bankQueues[bank].end(); ++it) {
729             Message* msg_ptr = (*it)->m_msgptr.get();
730             if (msg_ptr->functionalRead(pkt)) {
731                 return true;
732             }
733         }
734     }
735 
736     return false;
737 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a08f04f912fb872935cb2d40f8570c340}{
\index{RubyMemoryControl@{RubyMemoryControl}!functionalWriteBuffers@{functionalWriteBuffers}}
\index{functionalWriteBuffers@{functionalWriteBuffers}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{functionalWriteBuffers}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} functionalWriteBuffers ({\bf Packet} $\ast$ {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_a08f04f912fb872935cb2d40f8570c340}
This function reads the different buffers that exist in the Ruby Memory \hyperlink{namespaceController}{Controller}, and figures out if any of the buffers hold a message that needs to functionally written with the data in the packet.

The number of messages written is returned at the end. This is required for debugging purposes. 

\hyperlink{classMemoryControl_aa1cf5fd9152389ffd0e21700945a149d}{MemoryControl}を再定義しています。


\begin{DoxyCode}
749 {
750     uint32_t num_functional_writes = 0;
751 
752     for (std::list<MemoryNode *>::iterator it = m_input_queue.begin();
753          it != m_input_queue.end(); ++it) {
754         Message* msg_ptr = (*it)->m_msgptr.get();
755         if (msg_ptr->functionalWrite(pkt)) {
756             num_functional_writes++;
757         }
758     }
759 
760     for (std::list<MemoryNode *>::iterator it = m_response_queue.begin();
761          it != m_response_queue.end(); ++it) {
762         Message* msg_ptr = (*it)->m_msgptr.get();
763         if (msg_ptr->functionalWrite(pkt)) {
764             num_functional_writes++;
765         }
766     }
767 
768     for (uint32_t bank = 0; bank < m_total_banks; ++bank) {
769         for (std::list<MemoryNode *>::iterator it = m_bankQueues[bank].begin();
770              it != m_bankQueues[bank].end(); ++it) {
771             Message* msg_ptr = (*it)->m_msgptr.get();
772             if (msg_ptr->functionalWrite(pkt)) {
773                 num_functional_writes++;
774             }
775         }
776     }
777 
778     return num_functional_writes;
779 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a26f571eb9a81a077295b54c2ed398aea}{
\index{RubyMemoryControl@{RubyMemoryControl}!getBank@{getBank}}
\index{getBank@{getBank}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{getBank}]{\setlength{\rightskip}{0pt plus 5cm}const int getBank (const {\bf physical\_\-address\_\-t} {\em addr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_a26f571eb9a81a077295b54c2ed398aea}


\hyperlink{classMemoryControl_a7a4691e15d68d8bf9df636adff2c964f}{MemoryControl}を実装しています。


\begin{DoxyCode}
383 {
384     int dimm = (addr >> m_dimm_bit_0) & (m_dimms_per_channel - 1);
385     int rank = (addr >> m_rank_bit_0) & (m_ranks_per_dimm - 1);
386     int bank = (addr >> m_bank_bit_0) & (m_banks_per_rank - 1);
387     return (dimm * m_ranks_per_dimm * m_banks_per_rank)
388         + (rank * m_banks_per_rank)
389         + bank;
390 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_aba6f6d5c066193ae70ee43153051055b}{
\index{RubyMemoryControl@{RubyMemoryControl}!getBanksPerRank@{getBanksPerRank}}
\index{getBanksPerRank@{getBanksPerRank}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{getBanksPerRank}]{\setlength{\rightskip}{0pt plus 5cm}int getBanksPerRank ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classRubyMemoryControl_aba6f6d5c066193ae70ee43153051055b}


\hyperlink{classMemoryControl_a931e1da3d57d22fd7f4ba3583697c336}{MemoryControl}を実装しています。


\begin{DoxyCode}
94 { return m_banks_per_rank; };
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a08f255b8eb3b262916a47fa8f7c12e63}{
\index{RubyMemoryControl@{RubyMemoryControl}!getChannel@{getChannel}}
\index{getChannel@{getChannel}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{getChannel}]{\setlength{\rightskip}{0pt plus 5cm}const int getChannel (const {\bf physical\_\-address\_\-t} {\em addr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_a08f255b8eb3b262916a47fa8f7c12e63}


\hyperlink{classMemoryControl_a439a91ae6f587e18a500ba947d0728d5}{MemoryControl}を実装しています。


\begin{DoxyCode}
414 {
415     assert(false);
416     return -1;
417 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a2417fc7252a612b5c976ceaa2d1be4f7}{
\index{RubyMemoryControl@{RubyMemoryControl}!getConsumer@{getConsumer}}
\index{getConsumer@{getConsumer}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{getConsumer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Consumer}$\ast$ getConsumer ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classRubyMemoryControl_a2417fc7252a612b5c976ceaa2d1be4f7}


\hyperlink{classMemoryControl_acb101bbbf38f858442ec618e9705d039}{MemoryControl}を実装しています。


\begin{DoxyCode}
70 { return m_consumer_ptr; };
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a73da75c3e5ec30855a02eae2ba824e38}{
\index{RubyMemoryControl@{RubyMemoryControl}!getDescription@{getDescription}}
\index{getDescription@{getDescription}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{getDescription}]{\setlength{\rightskip}{0pt plus 5cm}std::string getDescription ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classRubyMemoryControl_a73da75c3e5ec30855a02eae2ba824e38}


\hyperlink{classMemoryControl_a907d681c378517c972b738f4286c25c5}{MemoryControl}を実装しています。


\begin{DoxyCode}
72 { return m_description; };
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a5a9c0e20c20d0171bb8d8a96cb22576f}{
\index{RubyMemoryControl@{RubyMemoryControl}!getDimmsPerChannel@{getDimmsPerChannel}}
\index{getDimmsPerChannel@{getDimmsPerChannel}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{getDimmsPerChannel}]{\setlength{\rightskip}{0pt plus 5cm}int getDimmsPerChannel ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classRubyMemoryControl_a5a9c0e20c20d0171bb8d8a96cb22576f}


\hyperlink{classMemoryControl_a6f39efbb6d1f061b2f6467ac33f6ce34}{MemoryControl}を実装しています。


\begin{DoxyCode}
96 { return m_dimms_per_channel; }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a39abe91d99c7b551495766a397e212af}{
\index{RubyMemoryControl@{RubyMemoryControl}!getRank@{getRank}}
\index{getRank@{getRank}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{getRank}]{\setlength{\rightskip}{0pt plus 5cm}const int getRank (int {\em bank}) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a39abe91d99c7b551495766a397e212af}



\begin{DoxyCode}
405 {
406     int rank = (bank / m_banks_per_rank);
407     assert (rank < (m_ranks_per_dimm * m_dimms_per_channel));
408     return rank;
409 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_af8c39d7c9853a48fd242bda859e76222}{
\index{RubyMemoryControl@{RubyMemoryControl}!getRank@{getRank}}
\index{getRank@{getRank}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{getRank}]{\setlength{\rightskip}{0pt plus 5cm}const int getRank (const {\bf physical\_\-address\_\-t} {\em addr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_af8c39d7c9853a48fd242bda859e76222}


\hyperlink{classMemoryControl_a22565804f54291d8c37b7456c157f814}{MemoryControl}を実装しています。


\begin{DoxyCode}
394 {
395     int bank = getBank(addr);
396     int rank = (bank / m_banks_per_rank);
397     assert (rank < (m_ranks_per_dimm * m_dimms_per_channel));
398     return rank;
399 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a6dff017ebfbd9d5b021b86437ff67acc}{
\index{RubyMemoryControl@{RubyMemoryControl}!getRanksPerDimm@{getRanksPerDimm}}
\index{getRanksPerDimm@{getRanksPerDimm}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{getRanksPerDimm}]{\setlength{\rightskip}{0pt plus 5cm}int getRanksPerDimm ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classRubyMemoryControl_a6dff017ebfbd9d5b021b86437ff67acc}


\hyperlink{classMemoryControl_a8fc5f029d5373799975a32fcd559400c}{MemoryControl}を実装しています。


\begin{DoxyCode}
95 { return m_ranks_per_dimm; };
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a65314c26cf3c85d8c911524ede56456c}{
\index{RubyMemoryControl@{RubyMemoryControl}!getRow@{getRow}}
\index{getRow@{getRow}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{getRow}]{\setlength{\rightskip}{0pt plus 5cm}const int getRow (const {\bf physical\_\-address\_\-t} {\em addr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_a65314c26cf3c85d8c911524ede56456c}


\hyperlink{classMemoryControl_a86eabafc0d8d68214de261fc7a333a04}{MemoryControl}を実装しています。


\begin{DoxyCode}
422 {
423     assert(false);
424     return -1;
425 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{RubyMemoryControl@{RubyMemoryControl}!init@{init}}
\index{init@{init}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classRubyMemoryControl_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classMemoryControl_ab5be7e5a13ea77d59aac45d21dceb6a0}{MemoryControl}を実装しています。


\begin{DoxyCode}
174 {
175     m_msg_counter = 0;
176 
177     assert(m_tFaw <= 62); // must fit in a uint64 shift register
178 
179     m_total_banks = m_banks_per_rank * m_ranks_per_dimm * m_dimms_per_channel;
180     m_total_ranks = m_ranks_per_dimm * m_dimms_per_channel;
181     m_refresh_period_system = m_refresh_period / m_total_banks;
182 
183     m_bankQueues = new list<MemoryNode *> [m_total_banks];
184     assert(m_bankQueues);
185 
186     m_bankBusyCounter = new int [m_total_banks];
187     assert(m_bankBusyCounter);
188 
189     m_oldRequest = new int [m_total_banks];
190     assert(m_oldRequest);
191 
192     for (int i = 0; i < m_total_banks; i++) {
193         m_bankBusyCounter[i] = 0;
194         m_oldRequest[i] = 0;
195     }
196 
197     m_busBusyCounter_Basic = 0;
198     m_busBusyCounter_Write = 0;
199     m_busBusyCounter_ReadNewRank = 0;
200     m_busBusy_WhichRank = 0;
201 
202     m_roundRobin = 0;
203     m_refresh_count = 1;
204     m_need_refresh = 0;
205     m_refresh_bank = 0;
206     m_idleCount = 0;
207     m_ageCounter = 0;
208 
209     // Each tfaw shift register keeps a moving bit pattern
210     // which shows when recent activates have occurred.
211     // m_tfaw_count keeps track of how many 1 bits are set
212     // in each shift register.  When m_tfaw_count is >= 4,
213     // new activates are not allowed.
214     m_tfaw_shift = new uint64[m_total_ranks];
215     m_tfaw_count = new int[m_total_ranks];
216     for (int i = 0; i < m_total_ranks; i++) {
217         m_tfaw_shift[i] = 0;
218         m_tfaw_count[i] = 0;
219     }
220 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_acbed040576a7a18e2d9c46b2f15e0162}{
\index{RubyMemoryControl@{RubyMemoryControl}!isReady@{isReady}}
\index{isReady@{isReady}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{isReady}]{\setlength{\rightskip}{0pt plus 5cm}bool isReady ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_acbed040576a7a18e2d9c46b2f15e0162}


\hyperlink{classMemoryControl_a90b7287ef3808f6b4b355495d24a9b38}{MemoryControl}を実装しています。


\begin{DoxyCode}
347 {
348     return ((!m_response_queue.empty()) &&
349             (m_response_queue.front()->m_time <= g_system_ptr->curCycle()));
350 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a3907d2ad8de317b5d9488e567b8c29de}{
\index{RubyMemoryControl@{RubyMemoryControl}!issueRefresh@{issueRefresh}}
\index{issueRefresh@{issueRefresh}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{issueRefresh}]{\setlength{\rightskip}{0pt plus 5cm}bool issueRefresh (int {\em bank})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a3907d2ad8de317b5d9488e567b8c29de}



\begin{DoxyCode}
494 {
495     if (!m_need_refresh || (m_refresh_bank != bank))
496         return false;
497     if (m_bankBusyCounter[bank] > 0)
498         return false;
499     // Note that m_busBusyCounter will prevent multiple issues during
500     // the same cycle, as well as on different but close cycles:
501     if (m_busBusyCounter_Basic > 0)
502         return false;
503     int rank = getRank(bank);
504     if (m_tfaw_count[rank] >= ACTIVATE_PER_TFAW)
505         return false;
506 
507     // Issue it:
508     DPRINTF(RubyMemory, "Refresh bank %3x\n", bank);
509 
510     m_profiler_ptr->profileMemRefresh();
511     m_need_refresh--;
512     m_refresh_bank++;
513     if (m_refresh_bank >= m_total_banks)
514         m_refresh_bank = 0;
515     m_bankBusyCounter[bank] = m_bank_busy_time;
516     m_busBusyCounter_Basic = m_basic_bus_busy_time;
517     m_busBusyCounter_Write = m_basic_bus_busy_time;
518     m_busBusyCounter_ReadNewRank = m_basic_bus_busy_time;
519     markTfaw(rank);
520     return true;
521 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a9dbeedd7a40a225736f517e46ef9915e}{
\index{RubyMemoryControl@{RubyMemoryControl}!issueRequest@{issueRequest}}
\index{issueRequest@{issueRequest}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{issueRequest}]{\setlength{\rightskip}{0pt plus 5cm}void issueRequest (int {\em bank})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a9dbeedd7a40a225736f517e46ef9915e}



\begin{DoxyCode}
538 {
539     int rank = getRank(bank);
540     MemoryNode *req = m_bankQueues[bank].front();
541     m_bankQueues[bank].pop_front();
542 
543     DPRINTF(RubyMemory, "Mem issue request%7d: %#08x %c "
544             "bank=%3x sched %c\n", req->m_msg_counter, req->m_addr,
545             req->m_is_mem_read? 'R':'W',
546             bank, m_event.scheduled() ? 'Y':'N');
547 
548     if (req->m_msgptr) {  // don't enqueue L3 writebacks
549         enqueueToDirectory(req, Cycles(m_mem_ctl_latency + m_mem_fixed_delay));
550     }
551     m_oldRequest[bank] = 0;
552     markTfaw(rank);
553     m_bankBusyCounter[bank] = m_bank_busy_time;
554     m_busBusy_WhichRank = rank;
555     if (req->m_is_mem_read) {
556         m_profiler_ptr->profileMemRead();
557         m_busBusyCounter_Basic = m_basic_bus_busy_time;
558         m_busBusyCounter_Write = m_basic_bus_busy_time + m_read_write_delay;
559         m_busBusyCounter_ReadNewRank =
560             m_basic_bus_busy_time + m_rank_rank_delay;
561     } else {
562         m_profiler_ptr->profileMemWrite();
563         m_busBusyCounter_Basic = m_basic_bus_busy_time;
564         m_busBusyCounter_Write = m_basic_bus_busy_time;
565         m_busBusyCounter_ReadNewRank = m_basic_bus_busy_time;
566     }
567 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a8fb7d0c7e12bbd524e3bcd193e66426c}{
\index{RubyMemoryControl@{RubyMemoryControl}!markTfaw@{markTfaw}}
\index{markTfaw@{markTfaw}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{markTfaw}]{\setlength{\rightskip}{0pt plus 5cm}void markTfaw (int {\em rank})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a8fb7d0c7e12bbd524e3bcd193e66426c}



\begin{DoxyCode}
526 {
527     if (m_tFaw) {
528         m_tfaw_shift[rank] |= (1 << (m_tFaw-1));
529         m_tfaw_count[rank]++;
530     }
531 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a625dea61d2ea0f477b1310e9307a33d6}{
\index{RubyMemoryControl@{RubyMemoryControl}!operator=@{operator=}}
\index{operator=@{operator=}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RubyMemoryControl}\& operator= (const {\bf RubyMemoryControl} \& {\em obj})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a625dea61d2ea0f477b1310e9307a33d6}
\hypertarget{classRubyMemoryControl_ab635dc32ebecf260c15d8fbbbb9b21e0}{
\index{RubyMemoryControl@{RubyMemoryControl}!peek@{peek}}
\index{peek@{peek}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{peek}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Message} $\ast$ peek ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_ab635dc32ebecf260c15d8fbbbb9b21e0}


\hyperlink{classMemoryControl_a822b263266795dc49c26e24dc6eb4b54}{MemoryControl}を実装しています。


\begin{DoxyCode}
326 {
327     MemoryNode *node = peekNode();
328     Message* msg_ptr = node->m_msgptr.get();
329     assert(msg_ptr != NULL);
330     return msg_ptr;
331 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a8ffbfb520369710755a1260b8451de3d}{
\index{RubyMemoryControl@{RubyMemoryControl}!peekNode@{peekNode}}
\index{peekNode@{peekNode}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{peekNode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemoryNode} $\ast$ peekNode ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_a8ffbfb520369710755a1260b8451de3d}


\hyperlink{classMemoryControl_a1daeb227a1c754432729a75c7997d275}{MemoryControl}を実装しています。


\begin{DoxyCode}
335 {
336     assert(isReady());
337     MemoryNode *req = m_response_queue.front();
338     DPRINTF(RubyMemory, "Peek: memory request%7d: %#08x %c sched %c\n",
339             req->m_msg_counter, req->m_addr, req->m_is_mem_read ? 'R':'W',
340             m_event.scheduled() ? 'Y':'N');
341 
342     return req;
343 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_ac55fe386a101fbae38c716067c9966a0}{
\index{RubyMemoryControl@{RubyMemoryControl}!print@{print}}
\index{print@{print}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}void print (std::ostream \& {\em out}) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_ac55fe386a101fbae38c716067c9966a0}


\hyperlink{classMemoryControl_a3ea5f7af5db62cc24f4e40df9ea5c971}{MemoryControl}を実装しています。\hypertarget{classRubyMemoryControl_a839c1841354bab0a9007a04ba303ae2c}{
\index{RubyMemoryControl@{RubyMemoryControl}!queueReady@{queueReady}}
\index{queueReady@{queueReady}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{queueReady}]{\setlength{\rightskip}{0pt plus 5cm}bool queueReady (int {\em bank})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a839c1841354bab0a9007a04ba303ae2c}



\begin{DoxyCode}
431 {
432     if ((m_bankBusyCounter[bank] > 0) && !m_mem_fixed_delay) {
433         m_profiler_ptr->profileMemBankBusy();
434 
435         DPRINTF(RubyMemory, "bank %x busy %d\n", bank, m_bankBusyCounter[bank]);
436         return false;
437     }
438 
439     if (m_mem_random_arbitrate >= 2) {
440         if ((random() % 100) < m_mem_random_arbitrate) {
441             m_profiler_ptr->profileMemRandBusy();
442             return false;
443         }
444     }
445 
446     if (m_mem_fixed_delay)
447         return true;
448 
449     if ((m_ageCounter > (2 * m_bank_busy_time)) && !m_oldRequest[bank]) {
450         m_profiler_ptr->profileMemNotOld();
451         return false;
452     }
453 
454     if (m_busBusyCounter_Basic == m_basic_bus_busy_time) {
455         // Another bank must have issued this same cycle.  For
456         // profiling, we count this as an arb wait rather than a bus
457         // wait.  This is a little inaccurate since it MIGHT have also
458         // been blocked waiting for a read-write or a read-read
459         // instead, but it's pretty close.
460         m_profiler_ptr->profileMemArbWait(1);
461         return false;
462     }
463 
464     if (m_busBusyCounter_Basic > 0) {
465         m_profiler_ptr->profileMemBusBusy();
466         return false;
467     }
468 
469     int rank = getRank(bank);
470     if (m_tfaw_count[rank] >= ACTIVATE_PER_TFAW) {
471         m_profiler_ptr->profileMemTfawBusy();
472         return false;
473     }
474 
475     bool write = !m_bankQueues[bank].front()->m_is_mem_read;
476     if (write && (m_busBusyCounter_Write > 0)) {
477         m_profiler_ptr->profileMemReadWriteBusy();
478         return false;
479     }
480 
481     if (!write && (rank != m_busBusy_WhichRank)
482         && (m_busBusyCounter_ReadNewRank > 0)) {
483         m_profiler_ptr->profileMemDataBusBusy();
484         return false;
485     }
486 
487     return true;
488 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{RubyMemoryControl@{RubyMemoryControl}!regStats@{regStats}}
\index{regStats@{regStats}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} statistics for this object. 

\hyperlink{classMemoryControl_ac1739a9be0fbd5d96cf441cd3b2c1c78}{MemoryControl}を再定義しています。


\begin{DoxyCode}
783 {
784     m_profiler_ptr->regStats();
785 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_ad20897c5c8bd47f5d4005989bead0e55}{
\index{RubyMemoryControl@{RubyMemoryControl}!reset@{reset}}
\index{reset@{reset}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{reset}]{\setlength{\rightskip}{0pt plus 5cm}void reset ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_ad20897c5c8bd47f5d4005989bead0e55}


\hyperlink{classMemoryControl_a20dcbdfbd0ec77afc802522bb7e379c1}{MemoryControl}を実装しています。


\begin{DoxyCode}
224 {
225     m_msg_counter = 0;
226 
227     assert(m_tFaw <= 62); // must fit in a uint64 shift register
228 
229     m_total_banks = m_banks_per_rank * m_ranks_per_dimm * m_dimms_per_channel;
230     m_total_ranks = m_ranks_per_dimm * m_dimms_per_channel;
231     m_refresh_period_system = m_refresh_period / m_total_banks;
232 
233     assert(m_bankQueues);
234 
235     assert(m_bankBusyCounter);
236 
237     assert(m_oldRequest);
238 
239     for (int i = 0; i < m_total_banks; i++) {
240         m_bankBusyCounter[i] = 0;
241         m_oldRequest[i] = 0;
242     }
243 
244     m_busBusyCounter_Basic = 0;
245     m_busBusyCounter_Write = 0;
246     m_busBusyCounter_ReadNewRank = 0;
247     m_busBusy_WhichRank = 0;
248 
249     m_roundRobin = 0;
250     m_refresh_count = 1;
251     m_need_refresh = 0;
252     m_refresh_bank = 0;
253     m_idleCount = 0;
254     m_ageCounter = 0;
255 
256     // Each tfaw shift register keeps a moving bit pattern
257     // which shows when recent activates have occurred.
258     // m_tfaw_count keeps track of how many 1 bits are set
259     // in each shift register.  When m_tfaw_count is >= 4,
260     // new activates are not allowed.
261     for (int i = 0; i < m_total_ranks; i++) {
262         m_tfaw_shift[i] = 0;
263         m_tfaw_count[i] = 0;
264     }
265 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a8487c37680239f103e21ada9acf1726d}{
\index{RubyMemoryControl@{RubyMemoryControl}!setConsumer@{setConsumer}}
\index{setConsumer@{setConsumer}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{setConsumer}]{\setlength{\rightskip}{0pt plus 5cm}void setConsumer ({\bf Consumer} $\ast$ {\em consumer\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_a8487c37680239f103e21ada9acf1726d}


\hyperlink{classMemoryControl_ac57bc43eacdddc1423b4f98ead12fd1c}{MemoryControl}を実装しています。


\begin{DoxyCode}
354 {
355     m_consumer_ptr = consumer_ptr;
356 }
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_a9cdbe64eebafb111a124edec55ed2340}{
\index{RubyMemoryControl@{RubyMemoryControl}!setDescription@{setDescription}}
\index{setDescription@{setDescription}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{setDescription}]{\setlength{\rightskip}{0pt plus 5cm}void setDescription (const std::string \& {\em name})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classRubyMemoryControl_a9cdbe64eebafb111a124edec55ed2340}


\hyperlink{classMemoryControl_aaf16ee4e399ebed0a6434dd085a6fc10}{MemoryControl}を実装しています。


\begin{DoxyCode}
71 { m_description = name; };
\end{DoxyCode}
\hypertarget{classRubyMemoryControl_ae674290a26ecbd622c5160e38e8a4fe9}{
\index{RubyMemoryControl@{RubyMemoryControl}!wakeup@{wakeup}}
\index{wakeup@{wakeup}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{wakeup}]{\setlength{\rightskip}{0pt plus 5cm}void wakeup ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyMemoryControl_ae674290a26ecbd622c5160e38e8a4fe9}


\hyperlink{classMemoryControl_a623e3e7d1b1c725d70009f7b01a421b9}{MemoryControl}を実装しています。


\begin{DoxyCode}
686 {
687     DPRINTF(RubyMemory, "MemoryController wakeup\n");
688     // execute everything
689     executeCycle();
690 
691     m_idleCount--;
692     if (m_idleCount > 0) {
693         assert(!m_event.scheduled());
694         schedule(m_event, clockEdge(Cycles(1)));
695     }
696 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classRubyMemoryControl_aba1d5e3376d7d3bed53b2bafcd056c64}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-ageCounter@{m\_\-ageCounter}}
\index{m\_\-ageCounter@{m\_\-ageCounter}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-ageCounter}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-ageCounter}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_aba1d5e3376d7d3bed53b2bafcd056c64}
\hypertarget{classRubyMemoryControl_a767e3298a0e794bb0c8f422021e6b67d}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-bank\_\-bit\_\-0@{m\_\-bank\_\-bit\_\-0}}
\index{m\_\-bank\_\-bit\_\-0@{m\_\-bank\_\-bit\_\-0}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-bank\_\-bit\_\-0}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-bank\_\-bit\_\-0}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a767e3298a0e794bb0c8f422021e6b67d}
\hypertarget{classRubyMemoryControl_ab11322175e2e2ec5d6ebef835774bc1a}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-bank\_\-busy\_\-time@{m\_\-bank\_\-busy\_\-time}}
\index{m\_\-bank\_\-busy\_\-time@{m\_\-bank\_\-busy\_\-time}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-bank\_\-busy\_\-time}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-bank\_\-busy\_\-time}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_ab11322175e2e2ec5d6ebef835774bc1a}
\hypertarget{classRubyMemoryControl_a6cbe212586b315223f76b124953ea4b2}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-bank\_\-queue\_\-size@{m\_\-bank\_\-queue\_\-size}}
\index{m\_\-bank\_\-queue\_\-size@{m\_\-bank\_\-queue\_\-size}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-bank\_\-queue\_\-size}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf m\_\-bank\_\-queue\_\-size}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a6cbe212586b315223f76b124953ea4b2}
\hypertarget{classRubyMemoryControl_a258db92f2ca2cd3335e798fbe1cea189}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-bankBusyCounter@{m\_\-bankBusyCounter}}
\index{m\_\-bankBusyCounter@{m\_\-bankBusyCounter}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-bankBusyCounter}]{\setlength{\rightskip}{0pt plus 5cm}int$\ast$ {\bf m\_\-bankBusyCounter}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a258db92f2ca2cd3335e798fbe1cea189}
\hypertarget{classRubyMemoryControl_a66d0e61e247049647c7e205d7898f593}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-bankQueues@{m\_\-bankQueues}}
\index{m\_\-bankQueues@{m\_\-bankQueues}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-bankQueues}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf MemoryNode} $\ast$$>$$\ast$ {\bf m\_\-bankQueues}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a66d0e61e247049647c7e205d7898f593}
\hypertarget{classRubyMemoryControl_af5a8b76f5c8fdb638e49a8c11c61f492}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-banks\_\-per\_\-rank@{m\_\-banks\_\-per\_\-rank}}
\index{m\_\-banks\_\-per\_\-rank@{m\_\-banks\_\-per\_\-rank}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-banks\_\-per\_\-rank}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-banks\_\-per\_\-rank}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_af5a8b76f5c8fdb638e49a8c11c61f492}
\hypertarget{classRubyMemoryControl_a0537255983f6c88ed3389efd814780e5}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-basic\_\-bus\_\-busy\_\-time@{m\_\-basic\_\-bus\_\-busy\_\-time}}
\index{m\_\-basic\_\-bus\_\-busy\_\-time@{m\_\-basic\_\-bus\_\-busy\_\-time}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-basic\_\-bus\_\-busy\_\-time}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-basic\_\-bus\_\-busy\_\-time}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a0537255983f6c88ed3389efd814780e5}
\hypertarget{classRubyMemoryControl_a0889f6b503357c0dee9ca27b3a777a61}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-busBusy\_\-WhichRank@{m\_\-busBusy\_\-WhichRank}}
\index{m\_\-busBusy\_\-WhichRank@{m\_\-busBusy\_\-WhichRank}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-busBusy\_\-WhichRank}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-busBusy\_\-WhichRank}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a0889f6b503357c0dee9ca27b3a777a61}
\hypertarget{classRubyMemoryControl_a9622fd6ccdf6aaac725dd5b199651e1f}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-busBusyCounter\_\-Basic@{m\_\-busBusyCounter\_\-Basic}}
\index{m\_\-busBusyCounter\_\-Basic@{m\_\-busBusyCounter\_\-Basic}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-busBusyCounter\_\-Basic}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-busBusyCounter\_\-Basic}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a9622fd6ccdf6aaac725dd5b199651e1f}
\hypertarget{classRubyMemoryControl_a9396a0f34b9eb0d3c51bedc04de53b10}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-busBusyCounter\_\-ReadNewRank@{m\_\-busBusyCounter\_\-ReadNewRank}}
\index{m\_\-busBusyCounter\_\-ReadNewRank@{m\_\-busBusyCounter\_\-ReadNewRank}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-busBusyCounter\_\-ReadNewRank}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-busBusyCounter\_\-ReadNewRank}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a9396a0f34b9eb0d3c51bedc04de53b10}
\hypertarget{classRubyMemoryControl_a4c6490a8d96034781b7f019c9875637d}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-busBusyCounter\_\-Write@{m\_\-busBusyCounter\_\-Write}}
\index{m\_\-busBusyCounter\_\-Write@{m\_\-busBusyCounter\_\-Write}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-busBusyCounter\_\-Write}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-busBusyCounter\_\-Write}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a4c6490a8d96034781b7f019c9875637d}
\hypertarget{classRubyMemoryControl_a83dd1dc8eef330b0c0d184a4167b26b4}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-consumer\_\-ptr@{m\_\-consumer\_\-ptr}}
\index{m\_\-consumer\_\-ptr@{m\_\-consumer\_\-ptr}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-consumer\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Consumer}$\ast$ {\bf m\_\-consumer\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a83dd1dc8eef330b0c0d184a4167b26b4}
\hypertarget{classRubyMemoryControl_ad50eef5f7fcfa30f62e14f0fac2a4f6e}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-description@{m\_\-description}}
\index{m\_\-description@{m\_\-description}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-description}]{\setlength{\rightskip}{0pt plus 5cm}std::string {\bf m\_\-description}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_ad50eef5f7fcfa30f62e14f0fac2a4f6e}
\hypertarget{classRubyMemoryControl_a9d9676a8a7c87644cefbe758f0ef719c}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-dimm\_\-bit\_\-0@{m\_\-dimm\_\-bit\_\-0}}
\index{m\_\-dimm\_\-bit\_\-0@{m\_\-dimm\_\-bit\_\-0}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-dimm\_\-bit\_\-0}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-dimm\_\-bit\_\-0}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a9d9676a8a7c87644cefbe758f0ef719c}
\hypertarget{classRubyMemoryControl_acf7c3dd8c1a61ce9fe7ca2e026150caf}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-dimms\_\-per\_\-channel@{m\_\-dimms\_\-per\_\-channel}}
\index{m\_\-dimms\_\-per\_\-channel@{m\_\-dimms\_\-per\_\-channel}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-dimms\_\-per\_\-channel}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-dimms\_\-per\_\-channel}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_acf7c3dd8c1a61ce9fe7ca2e026150caf}
\hypertarget{classRubyMemoryControl_a1b496ca0cf94387967ed0539a43fb126}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-idleCount@{m\_\-idleCount}}
\index{m\_\-idleCount@{m\_\-idleCount}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-idleCount}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-idleCount}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a1b496ca0cf94387967ed0539a43fb126}
\hypertarget{classRubyMemoryControl_ad59ead9befd4b8ed53d20e31025cc5f2}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-input\_\-queue@{m\_\-input\_\-queue}}
\index{m\_\-input\_\-queue@{m\_\-input\_\-queue}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-input\_\-queue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf MemoryNode} $\ast$$>$ {\bf m\_\-input\_\-queue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_ad59ead9befd4b8ed53d20e31025cc5f2}
\hypertarget{classRubyMemoryControl_aaf9472c80a44349fbb83ec29ce2de7ad}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-mem\_\-ctl\_\-latency@{m\_\-mem\_\-ctl\_\-latency}}
\index{m\_\-mem\_\-ctl\_\-latency@{m\_\-mem\_\-ctl\_\-latency}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-mem\_\-ctl\_\-latency}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf m\_\-mem\_\-ctl\_\-latency}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_aaf9472c80a44349fbb83ec29ce2de7ad}
\hypertarget{classRubyMemoryControl_add64256c91bc7722347f3a8dfe94d375}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-mem\_\-fixed\_\-delay@{m\_\-mem\_\-fixed\_\-delay}}
\index{m\_\-mem\_\-fixed\_\-delay@{m\_\-mem\_\-fixed\_\-delay}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-mem\_\-fixed\_\-delay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf m\_\-mem\_\-fixed\_\-delay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_add64256c91bc7722347f3a8dfe94d375}
\hypertarget{classRubyMemoryControl_a84dc4df49177ba4931742af171541561}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-mem\_\-random\_\-arbitrate@{m\_\-mem\_\-random\_\-arbitrate}}
\index{m\_\-mem\_\-random\_\-arbitrate@{m\_\-mem\_\-random\_\-arbitrate}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-mem\_\-random\_\-arbitrate}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-mem\_\-random\_\-arbitrate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a84dc4df49177ba4931742af171541561}
\hypertarget{classRubyMemoryControl_acfac131e63985feff04ed11cbaf0d221}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-msg\_\-counter@{m\_\-msg\_\-counter}}
\index{m\_\-msg\_\-counter@{m\_\-msg\_\-counter}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-msg\_\-counter}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-msg\_\-counter}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_acfac131e63985feff04ed11cbaf0d221}
\hypertarget{classRubyMemoryControl_a81b8cb5d4100808f5d49ebb9e7f878bd}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-need\_\-refresh@{m\_\-need\_\-refresh}}
\index{m\_\-need\_\-refresh@{m\_\-need\_\-refresh}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-need\_\-refresh}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-need\_\-refresh}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a81b8cb5d4100808f5d49ebb9e7f878bd}
\hypertarget{classRubyMemoryControl_a546d324998c9280e60ad0d3bdc33b660}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-oldRequest@{m\_\-oldRequest}}
\index{m\_\-oldRequest@{m\_\-oldRequest}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-oldRequest}]{\setlength{\rightskip}{0pt plus 5cm}int$\ast$ {\bf m\_\-oldRequest}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a546d324998c9280e60ad0d3bdc33b660}
\hypertarget{classRubyMemoryControl_a1f70f7199575ca8bd58b685a72c37f84}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-profiler\_\-ptr@{m\_\-profiler\_\-ptr}}
\index{m\_\-profiler\_\-ptr@{m\_\-profiler\_\-ptr}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-profiler\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemCntrlProfiler}$\ast$ {\bf m\_\-profiler\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a1f70f7199575ca8bd58b685a72c37f84}
\hypertarget{classRubyMemoryControl_a2262efb9776ae0e8119e999c6efed38b}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-rank\_\-bit\_\-0@{m\_\-rank\_\-bit\_\-0}}
\index{m\_\-rank\_\-bit\_\-0@{m\_\-rank\_\-bit\_\-0}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-rank\_\-bit\_\-0}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-rank\_\-bit\_\-0}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a2262efb9776ae0e8119e999c6efed38b}
\hypertarget{classRubyMemoryControl_a88f33889677c076f1e5fdd8ce7cabc4d}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-rank\_\-rank\_\-delay@{m\_\-rank\_\-rank\_\-delay}}
\index{m\_\-rank\_\-rank\_\-delay@{m\_\-rank\_\-rank\_\-delay}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-rank\_\-rank\_\-delay}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-rank\_\-rank\_\-delay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a88f33889677c076f1e5fdd8ce7cabc4d}
\hypertarget{classRubyMemoryControl_a734869c8bd10780ed7f61eadb638f30c}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-ranks\_\-per\_\-dimm@{m\_\-ranks\_\-per\_\-dimm}}
\index{m\_\-ranks\_\-per\_\-dimm@{m\_\-ranks\_\-per\_\-dimm}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-ranks\_\-per\_\-dimm}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-ranks\_\-per\_\-dimm}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a734869c8bd10780ed7f61eadb638f30c}
\hypertarget{classRubyMemoryControl_a469ba8ed68dfdab637a67909cd7f494f}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-read\_\-write\_\-delay@{m\_\-read\_\-write\_\-delay}}
\index{m\_\-read\_\-write\_\-delay@{m\_\-read\_\-write\_\-delay}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-read\_\-write\_\-delay}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-read\_\-write\_\-delay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a469ba8ed68dfdab637a67909cd7f494f}
\hypertarget{classRubyMemoryControl_a93843e73be2e39683d2b6ce21c8a6298}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-refresh\_\-bank@{m\_\-refresh\_\-bank}}
\index{m\_\-refresh\_\-bank@{m\_\-refresh\_\-bank}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-refresh\_\-bank}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-refresh\_\-bank}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a93843e73be2e39683d2b6ce21c8a6298}
\hypertarget{classRubyMemoryControl_a11c845239e7ec76861ae230df7a575b2}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-refresh\_\-count@{m\_\-refresh\_\-count}}
\index{m\_\-refresh\_\-count@{m\_\-refresh\_\-count}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-refresh\_\-count}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-refresh\_\-count}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a11c845239e7ec76861ae230df7a575b2}
\hypertarget{classRubyMemoryControl_ab046d0568e576a3fd3e751aae694aa6c}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-refresh\_\-period@{m\_\-refresh\_\-period}}
\index{m\_\-refresh\_\-period@{m\_\-refresh\_\-period}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-refresh\_\-period}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-refresh\_\-period}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_ab046d0568e576a3fd3e751aae694aa6c}
\hypertarget{classRubyMemoryControl_ac226affdfdce1041cdc1adcea108d2d9}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-refresh\_\-period\_\-system@{m\_\-refresh\_\-period\_\-system}}
\index{m\_\-refresh\_\-period\_\-system@{m\_\-refresh\_\-period\_\-system}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-refresh\_\-period\_\-system}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-refresh\_\-period\_\-system}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_ac226affdfdce1041cdc1adcea108d2d9}
\hypertarget{classRubyMemoryControl_a6ff73bc35f01b71460125c8973fdcf7f}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-response\_\-queue@{m\_\-response\_\-queue}}
\index{m\_\-response\_\-queue@{m\_\-response\_\-queue}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-response\_\-queue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf MemoryNode} $\ast$$>$ {\bf m\_\-response\_\-queue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a6ff73bc35f01b71460125c8973fdcf7f}
\hypertarget{classRubyMemoryControl_ae91016ac7543fa2d2e4fc5ba9748a134}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-roundRobin@{m\_\-roundRobin}}
\index{m\_\-roundRobin@{m\_\-roundRobin}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-roundRobin}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-roundRobin}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_ae91016ac7543fa2d2e4fc5ba9748a134}
\hypertarget{classRubyMemoryControl_a278ccfdcd299cca636085e30b57bd77b}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-tFaw@{m\_\-tFaw}}
\index{m\_\-tFaw@{m\_\-tFaw}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-tFaw}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-tFaw}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a278ccfdcd299cca636085e30b57bd77b}
\hypertarget{classRubyMemoryControl_a8399af800996db69e2cb64997f0123f4}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-tfaw\_\-count@{m\_\-tfaw\_\-count}}
\index{m\_\-tfaw\_\-count@{m\_\-tfaw\_\-count}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-tfaw\_\-count}]{\setlength{\rightskip}{0pt plus 5cm}int$\ast$ {\bf m\_\-tfaw\_\-count}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a8399af800996db69e2cb64997f0123f4}
\hypertarget{classRubyMemoryControl_a9dd1941af4ea267b9f8e05a54c70d713}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-tfaw\_\-shift@{m\_\-tfaw\_\-shift}}
\index{m\_\-tfaw\_\-shift@{m\_\-tfaw\_\-shift}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-tfaw\_\-shift}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint64}$\ast$ {\bf m\_\-tfaw\_\-shift}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_a9dd1941af4ea267b9f8e05a54c70d713}
\hypertarget{classRubyMemoryControl_ad36478de555240b1cd80c5b0aa4b00cc}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-total\_\-banks@{m\_\-total\_\-banks}}
\index{m\_\-total\_\-banks@{m\_\-total\_\-banks}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-total\_\-banks}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-total\_\-banks}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_ad36478de555240b1cd80c5b0aa4b00cc}
\hypertarget{classRubyMemoryControl_ae56d0b2636a76e0d08eb304c9845540c}{
\index{RubyMemoryControl@{RubyMemoryControl}!m\_\-total\_\-ranks@{m\_\-total\_\-ranks}}
\index{m\_\-total\_\-ranks@{m\_\-total\_\-ranks}!RubyMemoryControl@{RubyMemoryControl}}
\subsubsection[{m\_\-total\_\-ranks}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-total\_\-ranks}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyMemoryControl_ae56d0b2636a76e0d08eb304c9845540c}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/ruby/system/\hyperlink{RubyMemoryControl_8hh}{RubyMemoryControl.hh}\item 
mem/ruby/system/\hyperlink{RubyMemoryControl_8cc}{RubyMemoryControl.cc}\end{DoxyCompactItemize}
