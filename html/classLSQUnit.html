<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>File&nbsp;GEM5&nbsp;Wrapper: クラス テンプレート LSQUnit&lt; Impl &gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- 作成： Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>メインページ</span></a></li>
      <li><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>構成</span></a></li>
      <li><a href="classes.html"><span>構成索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>構成メンバ</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>クラス テンプレート LSQUnit&lt; Impl &gt;</h1><!-- doxytag: class="LSQUnit" -->
<p><code>#include &lt;<a class="el" href="o3_2lsq__unit_8hh_source.html">lsq_unit.hh</a>&gt;</code></p>

<p><a href="classLSQUnit-members.html">すべてのメンバ一覧</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>構成</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit_1_1LSQSenderState.html">LSQSenderState</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLSQUnit_1_1SQEntry.html">SQEntry</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit_1_1WritebackEvent.html">WritebackEvent</a></td></tr>
<tr><td colspan="2"><h2>Public 型</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Impl::O3CPU&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a44622cf06940413482836cb62931ac3f">O3CPU</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Impl::DynInstPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Impl::CPUPol::IEW&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a23f60a4095b5240dfcb18a4ec40210a9">IEW</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Impl::CPUPol::LSQ&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#acf05a3db8421d1ca800c285cf9a86301">LSQ</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Impl::CPUPol::IssueStruct&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#aa56c7524890b3a6337668c507be0f272">IssueStruct</a></td></tr>
<tr><td colspan="2"><h2>Public メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a0b23136c4d1c97aab007aa60e707763b">LSQUnit</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a45b3b65ba551c17c3b200db265611a4c">init</a> (<a class="el" href="classLSQUnit.html#a44622cf06940413482836cb62931ac3f">O3CPU</a> *cpu_ptr, <a class="el" href="classLSQUnit.html#a23f60a4095b5240dfcb18a4ec40210a9">IEW</a> *iew_ptr, DerivO3CPUParams *params, <a class="el" href="classLSQ.html">LSQ</a> *lsq_ptr, unsigned maxLQEntries, unsigned maxSQEntries, unsigned id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a37627d5d5bba7f4a8690c71c2ab3cb07">name</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a4dc637449366fcdfc4e764cdf12d9b11">regStats</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a8d77cc755c7a424f4eb80130fb627012">setDcachePort</a> (<a class="el" href="classMasterPort.html">MasterPort</a> *dcache_port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a0240eb42fa57fe5d3788093f62b77347">drainSanityCheck</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a8674059ce345e23aac5086b2c3e24a43">takeOverFrom</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a873dd91783f9efb4a590aded1f70d6b0">tick</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a773e88db1aa010c3755e603493bf40ec">insert</a> (<a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> &amp;inst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#ad22b3ecafed2bcd9c59fcab049a1cb98">insertLoad</a> (<a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> &amp;load_inst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a6a4b4e51bfff3639932ebaba45e8a282">insertStore</a> (<a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> &amp;store_inst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefCountingPtr.html">Fault</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a15239c5725d8744a793c867193e4bce7">checkViolations</a> (int load_idx, <a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> &amp;inst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a35b89a864d3af33a4b045b7fe0aa6b5a">checkSnoop</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefCountingPtr.html">Fault</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a30c6332142c2ecca389ed6ee463c692b">executeLoad</a> (<a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> &amp;inst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefCountingPtr.html">Fault</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a091a4d1788ce66e51ceb888bbd85ac08">executeLoad</a> (int lq_idx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefCountingPtr.html">Fault</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#aad78b8a37ee5c61e47df58dd39980340">executeStore</a> (<a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> &amp;inst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a8ddd26e169a62ec5ae591a9f95934839">commitLoad</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a1ae517a923a864a4e3a5aa1eeb2dd2d6">commitLoads</a> (<a class="el" href="inst__seq_8hh.html#a258d93d98edaedee089435c19ea2ea2e">InstSeqNum</a> &amp;youngest_inst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a954ce1ce58b67cae49ba127d5ea40701">commitStores</a> (<a class="el" href="inst__seq_8hh.html#a258d93d98edaedee089435c19ea2ea2e">InstSeqNum</a> &amp;youngest_inst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a5f04e29d6f6feb8b86460491f2ba7547">writebackStores</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a0f7f0d3412bbf494cd3d0c0f48e5fcf2">completeDataAccess</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#ae3af532345dbe6519e8272d9cd677230">clearLQ</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a171cd7891063f418b1ee217f5c03537b">clearSQ</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a3bc9500810cb2d5615e29206e2d6499f">resizeLQ</a> (unsigned size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a341dd6a3bd8d240659fd9d698c3b5c65">resizeSQ</a> (unsigned size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a51dd7e304d5413447717826fac6f4921">squash</a> (const <a class="el" href="inst__seq_8hh.html#a258d93d98edaedee089435c19ea2ea2e">InstSeqNum</a> &amp;squashed_num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a4f720bbfb5fdefdb23516500eeb0b4de">violation</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a30adaf6f5fb6b38b5747f35c419e3f31">getMemDepViolator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a05c413ba417c6453e99f75d87c958590">loadBlocked</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#aaa9628e569d007b553e6830774b8548c">clearLoadBlocked</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#ad0aa91a7b51ca925abf9c9992abad314">isLoadBlockedHandled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#ac8bfb1e163f7ba2261d702623226973d">setLoadBlockedHandled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a028971a565aca048c67ea1c36a6a9d51">numFreeEntries</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a54460b759fb06e2b18e26657279a6f49">numLoads</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#aa0fc32a4a9d77696f5907f4d25e7d07f">numStores</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a3e70330939fdfc4dbc2f60c1a660584d">isFull</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a479432127ee77145cc19d6a2d1590821">isEmpty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a5893daf623130be826f492bbff58f757">lqFull</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a477981d1f905d2d398a1527f7149e3c4">sqFull</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a01d2807c1345befcffd168a2a9dbdbf2">lqEmpty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a5761e9640bec8ba8474945cce57b6501">sqEmpty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a24ba9cb3fa1e726321780a20a960c8cd">getCount</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#ad2e4b46255cfb53e85522adeed4e2089">hasStoresToWB</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a276cdbdaf4551f1b846c4e2535c5f882">numStoresToWB</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a338be821734603396bfef8d9fb8f04b0">willWB</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a29cb5a4f98063ce6e9210eacbdb35298">recvRetry</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#ad0dcc54f6823ec37a9ab4eef289e2305">dumpInsts</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefCountingPtr.html">Fault</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a6f61d3e96e7ebc628121a63027d9c106">read</a> (<a class="el" href="classRequest.html">Request</a> *req, <a class="el" href="classRequest.html">Request</a> *sreqLow, <a class="el" href="classRequest.html">Request</a> *sreqHigh, uint8_t *data, int load_idx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefCountingPtr.html">Fault</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a8910d991217dd388c788727f8ebbb267">write</a> (<a class="el" href="classRequest.html">Request</a> *req, <a class="el" href="classRequest.html">Request</a> *sreqLow, <a class="el" href="classRequest.html">Request</a> *sreqHigh, uint8_t *data, int store_idx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#ad43a7408f4e1c1e181bc40ecab6dc593">getLoadHead</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="inst__seq_8hh.html#a258d93d98edaedee089435c19ea2ea2e">InstSeqNum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#aee7352adadc6b43b7ce36a8c052eb222">getLoadHeadSeqNum</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#ab9d14b0deb8ab44dc09ac784b162e774">getStoreHead</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="inst__seq_8hh.html#a258d93d98edaedee089435c19ea2ea2e">InstSeqNum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a1813b58ab7569d6aeefb5d4e235cceda">getStoreHeadSeqNum</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#af8eb8590fbfa6ecd2f796390677a4c00">isStalled</a> ()</td></tr>
<tr><td colspan="2"><h2>Private メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a755ee993c2d4e9d422c37990b15afa37">resetState</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a3911bacb8817c31cfbeefd125dba0217">writeback</a> (<a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> &amp;inst, <a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a173d8fd73280b1cf5b4d0dd9b68cf0cf">writebackPendingStore</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a6f23a0d213e7d35f445f9cabfd2ed0cc">storePostSend</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a12ec7cad6ac51a53bca7795588885e5c">completeStore</a> (int store_idx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a268a51a93dbdda9a0cff48ba036e673e">sendStore</a> (<a class="el" href="classPacket.html">PacketPtr</a> data_pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a7576fc9eec69e3ce28ce7af7ad87416a">incrStIdx</a> (int &amp;store_idx) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a4ebe3751617bcb686e225184f77f971c">decrStIdx</a> (int &amp;store_idx) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a129dcadec1d9a805428c1cfd14bcad5e">incrLdIdx</a> (int &amp;load_idx) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a313eca7abdfb7c6642078e21bc49a968">decrLdIdx</a> (int &amp;load_idx) const </td></tr>
<tr><td colspan="2"><h2>Private 変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLSQUnit.html#a44622cf06940413482836cb62931ac3f">O3CPU</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLSQUnit.html#a23f60a4095b5240dfcb18a4ec40210a9">IEW</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLSQ.html">LSQ</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#ac0894e8141823f8eea2c9041bac9dab4">lsq</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMasterPort.html">MasterPort</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a2bbddd281625b8b4d716708925673445">dcachePort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a0ee490ba978f48fbf2579acc7eb60b24">lsqID</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="structLSQUnit_1_1SQEntry.html">SQEntry</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#aafa99d800d574095881acbacdbbbcc47">LQEntries</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a38c8af5392da70119dc5cce4e3637cbc">SQEntries</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#ab5dfaaa13f279adbed7a1eafea047796">depCheckShift</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a602a9ccaf8b313e8923d8b07ec5bc439">checkLoads</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a867971f18e464abd16193e069c64a8ad">loads</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a3831a7965ffbe90df177026988476f9c">storesToWB</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#ac09af89928d2ef4da4cbdcfce26fa3f5">loadHead</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a973a489225da164cc85e690f13c86841">loadTail</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a6e87b6f77102183080ea6ab8599b26a9">storeHead</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#acd5c7fbb5578b5cb505ffff16bbf6a8b">storeTail</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#ab2e23636971c40e7ed945026b2a184e1">cachePorts</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a03435d626b7567ed154de5d7d8c3d419">usedPorts</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#af4264b12b32db39099b579e1ed670312">cacheBlockMask</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTimeBuffer.html">TimeBuffer</a>&lt; <a class="el" href="structIssueStruct.html">IssueStruct</a> &gt;::wire&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#af6f43373b6586aa8c486538fb076effb">fromIssue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a6f8bff553ad30865c7d0c62e05421eb8">stalled</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="inst__seq_8hh.html#a258d93d98edaedee089435c19ea2ea2e">InstSeqNum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#afe1cdcfca6b44c28581d862228adc3da">stallingStoreIsn</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#af55bc9000c8b4e4cfcfbd018feca12a7">stallingLoadIdx</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a314ae93c04b3ca96e79e1b1f39a8e478">retryPkt</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a89d931c74b63e0b0e7ad856fe9525ff6">isStoreBlocked</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a95dc31b4ce3ebcb6b9d75a510b3a128c">isLoadBlocked</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a2c1620029c162c7180e523b089e56ed5">loadBlockedHandled</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#aec79dbfe7cf50cf3d047cad7ee8fa157">storeInFlight</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="inst__seq_8hh.html#a258d93d98edaedee089435c19ea2ea2e">InstSeqNum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a3fca34b247fd8d081557578f8ca60fe3">blockedLoadSeqNum</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a270a20c3fa52139e0538288275db9d22">memDepViolator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#ae4914b6850f06ca3589fe9e75451fc2e">hasPendingPkt</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a54d6e1b7bac876ca215b09777bae1d34">pendingPkt</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#abef3db582145f640478056f8413a03e3">needsTSO</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a2adecfd8b85711a16f91e0fbd7ca8f10">lsqForwLoads</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#ab1c6fb6e4b6c6a243412e594629105ea">invAddrLoads</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a737697c5df3fbe8e728541fec8220089">lsqSquashedLoads</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#ad620ac240b0d631c3a8aa19cfd05ad41">lsqIgnoredResponses</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#ac499fc2b461e03a110deae7c695f75bc">lsqMemOrderViolation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a0abe80f8caefb71a0351c3bed4d99c0e">lsqSquashedStores</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a893e9b5b65df5710d85f6a583504a11c">invAddrSwpfs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a5323f1c2b6bf5cccc59253596656eb70">lsqBlockedLoads</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#af5c24658bed91065bf7d69d27ba9fbd6">lsqRescheduledLoads</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSQUnit.html#a33a1cca2455a3e5909f462a778902643">lsqCacheBlocked</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>説明</h2>
<h3>template&lt;class Impl&gt;<br/>
 class LSQUnit&lt; Impl &gt;</h3>

<p>Class that implements the actual LQ and SQ for each specific thread. Both are circular queues; load entries are freed upon committing, while store entries are freed once they writeback. The <a class="el" href="classLSQUnit.html">LSQUnit</a> tracks if there are memory ordering violations, and also detects partial load to store forwarding cases (a store only has part of a load's data) that requires the load to wait until the store writes back. In the former case it holds onto the instruction until the dependence unit looks at it, and in the latter it stalls the <a class="el" href="classLSQ.html">LSQ</a> until the store writes back. At that point the load is replayed. </p>
<hr/><h2>型定義</h2>
<a class="anchor" id="a028ce10889c5f6450239d9e9a7347976"></a><!-- doxytag: member="LSQUnit::DynInstPtr" ref="a028ce10889c5f6450239d9e9a7347976" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Impl::DynInstPtr <a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a23f60a4095b5240dfcb18a4ec40210a9"></a><!-- doxytag: member="LSQUnit::IEW" ref="a23f60a4095b5240dfcb18a4ec40210a9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Impl::CPUPol::IEW <a class="el" href="classLSQUnit.html#a23f60a4095b5240dfcb18a4ec40210a9">IEW</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa56c7524890b3a6337668c507be0f272"></a><!-- doxytag: member="LSQUnit::IssueStruct" ref="aa56c7524890b3a6337668c507be0f272" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Impl::CPUPol::IssueStruct <a class="el" href="structIssueStruct.html">IssueStruct</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acf05a3db8421d1ca800c285cf9a86301"></a><!-- doxytag: member="LSQUnit::LSQ" ref="acf05a3db8421d1ca800c285cf9a86301" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Impl::CPUPol::LSQ <a class="el" href="classLSQ.html">LSQ</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a44622cf06940413482836cb62931ac3f"></a><!-- doxytag: member="LSQUnit::O3CPU" ref="a44622cf06940413482836cb62931ac3f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Impl::O3CPU <a class="el" href="classLSQUnit.html#a44622cf06940413482836cb62931ac3f">O3CPU</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>コンストラクタとデストラクタ</h2>
<a class="anchor" id="a0b23136c4d1c97aab007aa60e707763b"></a><!-- doxytag: member="LSQUnit::LSQUnit" ref="a0b23136c4d1c97aab007aa60e707763b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLSQUnit.html">LSQUnit</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructs an <a class="el" href="classLSQ.html">LSQ</a> unit. <a class="el" href="classLSQUnit.html#a45b3b65ba551c17c3b200db265611a4c">init()</a> must be called prior to use. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00143"></a>00143     : <a class="code" href="classLSQUnit.html#a867971f18e464abd16193e069c64a8ad">loads</a>(0), <a class="code" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a>(0), <a class="code" href="classLSQUnit.html#a3831a7965ffbe90df177026988476f9c">storesToWB</a>(0), <a class="code" href="classLSQUnit.html#af4264b12b32db39099b579e1ed670312">cacheBlockMask</a>(0), <a class="code" href="classLSQUnit.html#a6f8bff553ad30865c7d0c62e05421eb8">stalled</a>(<span class="keyword">false</span>),
<a name="l00144"></a>00144       <a class="code" href="classLSQUnit.html#a89d931c74b63e0b0e7ad856fe9525ff6">isStoreBlocked</a>(<span class="keyword">false</span>), <a class="code" href="classLSQUnit.html#a95dc31b4ce3ebcb6b9d75a510b3a128c">isLoadBlocked</a>(<span class="keyword">false</span>),
<a name="l00145"></a>00145       <a class="code" href="classLSQUnit.html#a2c1620029c162c7180e523b089e56ed5">loadBlockedHandled</a>(<span class="keyword">false</span>), <a class="code" href="classLSQUnit.html#aec79dbfe7cf50cf3d047cad7ee8fa157">storeInFlight</a>(<span class="keyword">false</span>), <a class="code" href="classLSQUnit.html#ae4914b6850f06ca3589fe9e75451fc2e">hasPendingPkt</a>(<span class="keyword">false</span>)
<a name="l00146"></a>00146 {
<a name="l00147"></a>00147 }
</pre></div></p>

</div>
</div>
<hr/><h2>関数</h2>
<a class="anchor" id="a35b89a864d3af33a4b045b7fe0aa6b5a"></a><!-- doxytag: member="LSQUnit::checkSnoop" ref="a35b89a864d3af33a4b045b7fe0aa6b5a" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void checkSnoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classCheck.html">Check</a> if an incoming invalidate hits in the lsq on a load that might have issued out of order wrt another load beacuse of the intermediate invalidate. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00434"></a>00434 {
<a name="l00435"></a>00435     <span class="keywordtype">int</span> load_idx = <a class="code" href="classLSQUnit.html#ac09af89928d2ef4da4cbdcfce26fa3f5">loadHead</a>;
<a name="l00436"></a>00436     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Got snoop for address %#x\n&quot;</span>, pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>());
<a name="l00437"></a>00437 
<a name="l00438"></a>00438     <span class="comment">// Unlock the cpu-local monitor when the CPU sees a snoop to a locked</span>
<a name="l00439"></a>00439     <span class="comment">// address. The CPU can speculatively execute a LL operation after a pending</span>
<a name="l00440"></a>00440     <span class="comment">// SC operation in the pipeline and that can make the cache monitor the CPU</span>
<a name="l00441"></a>00441     <span class="comment">// is connected to valid while it really shouldn&apos;t be.</span>
<a name="l00442"></a>00442     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="namespaceX86ISA.html#ab5f9a01fc40e47853ae9551b008afcbd">x</a> = 0; <a class="code" href="namespaceX86ISA.html#ab5f9a01fc40e47853ae9551b008afcbd">x</a> &lt; <a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;numContexts(); <a class="code" href="namespaceX86ISA.html#ab5f9a01fc40e47853ae9551b008afcbd">x</a>++) {
<a name="l00443"></a>00443         <a class="code" href="classThreadContext.html">ThreadContext</a> *<a class="code" href="namespaceArmISA.html#a5aff829af55e65b802d83dfcef4e9dd0">tc</a> = <a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;getContext(<a class="code" href="namespaceX86ISA.html#ab5f9a01fc40e47853ae9551b008afcbd">x</a>);
<a name="l00444"></a>00444         <span class="keywordtype">bool</span> no_squash = <a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;thread[<a class="code" href="namespaceX86ISA.html#ab5f9a01fc40e47853ae9551b008afcbd">x</a>]-&gt;noSquashFromTC;
<a name="l00445"></a>00445         <a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;thread[<a class="code" href="namespaceX86ISA.html#ab5f9a01fc40e47853ae9551b008afcbd">x</a>]-&gt;noSquashFromTC = <span class="keyword">true</span>;
<a name="l00446"></a>00446         <a class="code" href="namespaceAlphaISA.html#aae6ad66df5dfd5de14b36293aaf2e7f1">TheISA::handleLockedSnoop</a>(tc, pkt, <a class="code" href="classLSQUnit.html#af4264b12b32db39099b579e1ed670312">cacheBlockMask</a>);
<a name="l00447"></a>00447         <a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;thread[<a class="code" href="namespaceX86ISA.html#ab5f9a01fc40e47853ae9551b008afcbd">x</a>]-&gt;noSquashFromTC = no_squash;
<a name="l00448"></a>00448     }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450     <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> invalidate_addr = pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>() &amp; <a class="code" href="classLSQUnit.html#af4264b12b32db39099b579e1ed670312">cacheBlockMask</a>;
<a name="l00451"></a>00451 
<a name="l00452"></a>00452     <a class="code" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> ld_inst = <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[load_idx];
<a name="l00453"></a>00453     <span class="keywordflow">if</span> (ld_inst) {
<a name="l00454"></a>00454         <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> load_addr = ld_inst-&gt;physEffAddr &amp; <a class="code" href="classLSQUnit.html#af4264b12b32db39099b579e1ed670312">cacheBlockMask</a>;
<a name="l00455"></a>00455         <span class="comment">// Check that this snoop didn&apos;t just invalidate our lock flag</span>
<a name="l00456"></a>00456         <span class="keywordflow">if</span> (ld_inst-&gt;effAddrValid() &amp;&amp; load_addr == invalidate_addr &amp;&amp;
<a name="l00457"></a>00457             ld_inst-&gt;memReqFlags &amp; <a class="code" href="classRequest.html#ae940f472047b661a3913d069f9c3bea3">Request::LLSC</a>)
<a name="l00458"></a>00458             <a class="code" href="namespaceAlphaISA.html#a300fd7902bc6b2f2407c79f776d92ee8">TheISA::handleLockedSnoopHit</a>(ld_inst.get());
<a name="l00459"></a>00459     }
<a name="l00460"></a>00460 
<a name="l00461"></a>00461     <span class="comment">// If this is the only load in the LSQ we don&apos;t care</span>
<a name="l00462"></a>00462     <span class="keywordflow">if</span> (load_idx == <a class="code" href="classLSQUnit.html#a973a489225da164cc85e690f13c86841">loadTail</a>)
<a name="l00463"></a>00463         <span class="keywordflow">return</span>;
<a name="l00464"></a>00464 
<a name="l00465"></a>00465     <a class="code" href="classLSQUnit.html#a129dcadec1d9a805428c1cfd14bcad5e">incrLdIdx</a>(load_idx);
<a name="l00466"></a>00466 
<a name="l00467"></a>00467     <span class="keywordtype">bool</span> force_squash = <span class="keyword">false</span>;
<a name="l00468"></a>00468 
<a name="l00469"></a>00469     <span class="keywordflow">while</span> (load_idx != <a class="code" href="classLSQUnit.html#a973a489225da164cc85e690f13c86841">loadTail</a>) {
<a name="l00470"></a>00470         <a class="code" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> ld_inst = <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[load_idx];
<a name="l00471"></a>00471 
<a name="l00472"></a>00472         <span class="keywordflow">if</span> (!ld_inst-&gt;effAddrValid() || ld_inst-&gt;uncacheable()) {
<a name="l00473"></a>00473             <a class="code" href="classLSQUnit.html#a129dcadec1d9a805428c1cfd14bcad5e">incrLdIdx</a>(load_idx);
<a name="l00474"></a>00474             <span class="keywordflow">continue</span>;
<a name="l00475"></a>00475         }
<a name="l00476"></a>00476 
<a name="l00477"></a>00477         <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> load_addr = ld_inst-&gt;physEffAddr &amp; <a class="code" href="classLSQUnit.html#af4264b12b32db39099b579e1ed670312">cacheBlockMask</a>;
<a name="l00478"></a>00478         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;-- inst [sn:%lli] load_addr: %#x to pktAddr:%#x\n&quot;</span>,
<a name="l00479"></a>00479                     ld_inst-&gt;seqNum, load_addr, invalidate_addr);
<a name="l00480"></a>00480 
<a name="l00481"></a>00481         <span class="keywordflow">if</span> (load_addr == invalidate_addr || force_squash) {
<a name="l00482"></a>00482             <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#abef3db582145f640478056f8413a03e3">needsTSO</a>) {
<a name="l00483"></a>00483                 <span class="comment">// If we have a TSO system, as all loads must be ordered with</span>
<a name="l00484"></a>00484                 <span class="comment">// all other loads, this load as well as *all* subsequent loads</span>
<a name="l00485"></a>00485                 <span class="comment">// need to be squashed to prevent possible load reordering.</span>
<a name="l00486"></a>00486                 force_squash = <span class="keyword">true</span>;
<a name="l00487"></a>00487             }
<a name="l00488"></a>00488             <span class="keywordflow">if</span> (ld_inst-&gt;possibleLoadViolation() || force_squash) {
<a name="l00489"></a>00489                 <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Conflicting load at addr %#x [sn:%lli]\n&quot;</span>,
<a name="l00490"></a>00490                         pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), ld_inst-&gt;seqNum);
<a name="l00491"></a>00491 
<a name="l00492"></a>00492                 <span class="comment">// Mark the load for re-execution</span>
<a name="l00493"></a>00493                 ld_inst-&gt;fault = <span class="keyword">new</span> <a class="code" href="classReExec.html">ReExec</a>;
<a name="l00494"></a>00494             } <span class="keywordflow">else</span> {
<a name="l00495"></a>00495                 <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;HitExternal Snoop for addr %#x [sn:%lli]\n&quot;</span>,
<a name="l00496"></a>00496                         pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), ld_inst-&gt;seqNum);
<a name="l00497"></a>00497 
<a name="l00498"></a>00498                 <span class="comment">// Make sure that we don&apos;t lose a snoop hitting a LOCKED</span>
<a name="l00499"></a>00499                 <span class="comment">// address since the LOCK* flags don&apos;t get updated until</span>
<a name="l00500"></a>00500                 <span class="comment">// commit.</span>
<a name="l00501"></a>00501                 <span class="keywordflow">if</span> (ld_inst-&gt;memReqFlags &amp; <a class="code" href="classRequest.html#ae940f472047b661a3913d069f9c3bea3">Request::LLSC</a>)
<a name="l00502"></a>00502                     <a class="code" href="namespaceAlphaISA.html#a300fd7902bc6b2f2407c79f776d92ee8">TheISA::handleLockedSnoopHit</a>(ld_inst.get());
<a name="l00503"></a>00503 
<a name="l00504"></a>00504                 <span class="comment">// If a older load checks this and it&apos;s true</span>
<a name="l00505"></a>00505                 <span class="comment">// then we might have missed the snoop</span>
<a name="l00506"></a>00506                 <span class="comment">// in which case we need to invalidate to be sure</span>
<a name="l00507"></a>00507                 ld_inst-&gt;hitExternalSnoop(<span class="keyword">true</span>);
<a name="l00508"></a>00508             }
<a name="l00509"></a>00509         }
<a name="l00510"></a>00510         <a class="code" href="classLSQUnit.html#a129dcadec1d9a805428c1cfd14bcad5e">incrLdIdx</a>(load_idx);
<a name="l00511"></a>00511     }
<a name="l00512"></a>00512     <span class="keywordflow">return</span>;
<a name="l00513"></a>00513 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a15239c5725d8744a793c867193e4bce7"></a><!-- doxytag: member="LSQUnit::checkViolations" ref="a15239c5725d8744a793c867193e4bce7" args="(int load_idx, DynInstPtr &amp;inst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRefCountingPtr.html">Fault</a> checkViolations </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>load_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classCheck.html">Check</a> for ordering violations in the <a class="el" href="classLSQ.html">LSQ</a>. For a store squash if we ever find a conflicting load. For a load, only squash if we an external snoop invalidate has been seen for that load address </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>load_idx</em>&nbsp;</td><td>index to start checking at </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inst</em>&nbsp;</td><td>the instruction to check </td></tr>
  </table>
  </dd>
</dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000039">TODO:</a></b></dt><dd>in theory you only need to check an instruction that has executed however, there isn't a good way in the pipeline at the moment to check all instructions that will execute before the store writes back. Thus, like the implementation that came before it, we're overly conservative. </dd></dl>
</p>

<p><div class="fragment"><pre class="fragment"><a name="l00518"></a>00518 {
<a name="l00519"></a>00519     <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> inst_eff_addr1 = inst-&gt;effAddr &gt;&gt; <a class="code" href="classLSQUnit.html#ab5dfaaa13f279adbed7a1eafea047796">depCheckShift</a>;
<a name="l00520"></a>00520     <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> inst_eff_addr2 = (inst-&gt;effAddr + inst-&gt;effSize - 1) &gt;&gt; <a class="code" href="classLSQUnit.html#ab5dfaaa13f279adbed7a1eafea047796">depCheckShift</a>;
<a name="l00521"></a>00521 
<a name="l00527"></a>00527     <span class="keywordflow">while</span> (load_idx != <a class="code" href="classLSQUnit.html#a973a489225da164cc85e690f13c86841">loadTail</a>) {
<a name="l00528"></a>00528         <a class="code" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> ld_inst = <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[load_idx];
<a name="l00529"></a>00529         <span class="keywordflow">if</span> (!ld_inst-&gt;effAddrValid() || ld_inst-&gt;uncacheable()) {
<a name="l00530"></a>00530             <a class="code" href="classLSQUnit.html#a129dcadec1d9a805428c1cfd14bcad5e">incrLdIdx</a>(load_idx);
<a name="l00531"></a>00531             <span class="keywordflow">continue</span>;
<a name="l00532"></a>00532         }
<a name="l00533"></a>00533 
<a name="l00534"></a>00534         <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> ld_eff_addr1 = ld_inst-&gt;effAddr &gt;&gt; <a class="code" href="classLSQUnit.html#ab5dfaaa13f279adbed7a1eafea047796">depCheckShift</a>;
<a name="l00535"></a>00535         <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> ld_eff_addr2 =
<a name="l00536"></a>00536             (ld_inst-&gt;effAddr + ld_inst-&gt;effSize - 1) &gt;&gt; <a class="code" href="classLSQUnit.html#ab5dfaaa13f279adbed7a1eafea047796">depCheckShift</a>;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538         <span class="keywordflow">if</span> (inst_eff_addr2 &gt;= ld_eff_addr1 &amp;&amp; inst_eff_addr1 &lt;= ld_eff_addr2) {
<a name="l00539"></a>00539             <span class="keywordflow">if</span> (inst-&gt;isLoad()) {
<a name="l00540"></a>00540                 <span class="comment">// If this load is to the same block as an external snoop</span>
<a name="l00541"></a>00541                 <span class="comment">// invalidate that we&apos;ve observed then the load needs to be</span>
<a name="l00542"></a>00542                 <span class="comment">// squashed as it could have newer data</span>
<a name="l00543"></a>00543                 <span class="keywordflow">if</span> (ld_inst-&gt;hitExternalSnoop()) {
<a name="l00544"></a>00544                     <span class="keywordflow">if</span> (!<a class="code" href="classLSQUnit.html#a270a20c3fa52139e0538288275db9d22">memDepViolator</a> ||
<a name="l00545"></a>00545                             ld_inst-&gt;seqNum &lt; <a class="code" href="classLSQUnit.html#a270a20c3fa52139e0538288275db9d22">memDepViolator</a>-&gt;seqNum) {
<a name="l00546"></a>00546                         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Detected fault with inst [sn:%lli] &quot;</span>
<a name="l00547"></a>00547                                 <span class="stringliteral">&quot;and [sn:%lli] at address %#x\n&quot;</span>,
<a name="l00548"></a>00548                                 inst-&gt;seqNum, ld_inst-&gt;seqNum, ld_eff_addr1);
<a name="l00549"></a>00549                         <a class="code" href="classLSQUnit.html#a270a20c3fa52139e0538288275db9d22">memDepViolator</a> = ld_inst;
<a name="l00550"></a>00550 
<a name="l00551"></a>00551                         ++<a class="code" href="classLSQUnit.html#ac499fc2b461e03a110deae7c695f75bc">lsqMemOrderViolation</a>;
<a name="l00552"></a>00552 
<a name="l00553"></a>00553                         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="namespaceGenericISA.html#a3427cc78f489a7ee730b871fcb4c1960">GenericISA::M5PanicFault</a>(
<a name="l00554"></a>00554                                 <span class="stringliteral">&quot;Detected fault with inst [sn:%lli] and &quot;</span>
<a name="l00555"></a>00555                                 <span class="stringliteral">&quot;[sn:%lli] at address %#x\n&quot;</span>,
<a name="l00556"></a>00556                                 inst-&gt;seqNum, ld_inst-&gt;seqNum, ld_eff_addr1);
<a name="l00557"></a>00557                     }
<a name="l00558"></a>00558                 }
<a name="l00559"></a>00559 
<a name="l00560"></a>00560                 <span class="comment">// Otherwise, mark the load has a possible load violation</span>
<a name="l00561"></a>00561                 <span class="comment">// and if we see a snoop before it&apos;s commited, we need to squash</span>
<a name="l00562"></a>00562                 ld_inst-&gt;possibleLoadViolation(<span class="keyword">true</span>);
<a name="l00563"></a>00563                 <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Found possible load violaiton at addr: %#x&quot;</span>
<a name="l00564"></a>00564                         <span class="stringliteral">&quot; between instructions [sn:%lli] and [sn:%lli]\n&quot;</span>,
<a name="l00565"></a>00565                         inst_eff_addr1, inst-&gt;seqNum, ld_inst-&gt;seqNum);
<a name="l00566"></a>00566             } <span class="keywordflow">else</span> {
<a name="l00567"></a>00567                 <span class="comment">// A load/store incorrectly passed this store.</span>
<a name="l00568"></a>00568                 <span class="comment">// Check if we already have a violator, or if it&apos;s newer</span>
<a name="l00569"></a>00569                 <span class="comment">// squash and refetch.</span>
<a name="l00570"></a>00570                 <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a270a20c3fa52139e0538288275db9d22">memDepViolator</a> &amp;&amp; ld_inst-&gt;seqNum &gt; <a class="code" href="classLSQUnit.html#a270a20c3fa52139e0538288275db9d22">memDepViolator</a>-&gt;seqNum)
<a name="l00571"></a>00571                     <span class="keywordflow">break</span>;
<a name="l00572"></a>00572 
<a name="l00573"></a>00573                 <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Detected fault with inst [sn:%lli] and &quot;</span>
<a name="l00574"></a>00574                         <span class="stringliteral">&quot;[sn:%lli] at address %#x\n&quot;</span>,
<a name="l00575"></a>00575                         inst-&gt;seqNum, ld_inst-&gt;seqNum, ld_eff_addr1);
<a name="l00576"></a>00576                 <a class="code" href="classLSQUnit.html#a270a20c3fa52139e0538288275db9d22">memDepViolator</a> = ld_inst;
<a name="l00577"></a>00577 
<a name="l00578"></a>00578                 ++<a class="code" href="classLSQUnit.html#ac499fc2b461e03a110deae7c695f75bc">lsqMemOrderViolation</a>;
<a name="l00579"></a>00579 
<a name="l00580"></a>00580                 <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="namespaceGenericISA.html#a3427cc78f489a7ee730b871fcb4c1960">GenericISA::M5PanicFault</a>(<span class="stringliteral">&quot;Detected fault with &quot;</span>
<a name="l00581"></a>00581                         <span class="stringliteral">&quot;inst [sn:%lli] and [sn:%lli] at address %#x\n&quot;</span>,
<a name="l00582"></a>00582                         inst-&gt;seqNum, ld_inst-&gt;seqNum, ld_eff_addr1);
<a name="l00583"></a>00583             }
<a name="l00584"></a>00584         }
<a name="l00585"></a>00585 
<a name="l00586"></a>00586         <a class="code" href="classLSQUnit.html#a129dcadec1d9a805428c1cfd14bcad5e">incrLdIdx</a>(load_idx);
<a name="l00587"></a>00587     }
<a name="l00588"></a>00588     <span class="keywordflow">return</span> <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>;
<a name="l00589"></a>00589 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aaa9628e569d007b553e6830774b8548c"></a><!-- doxytag: member="LSQUnit::clearLoadBlocked" ref="aaa9628e569d007b553e6830774b8548c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearLoadBlocked </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears the signal that a load became blocked. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00191"></a>00191     { <a class="code" href="classLSQUnit.html#a95dc31b4ce3ebcb6b9d75a510b3a128c">isLoadBlocked</a> = <span class="keyword">false</span>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae3af532345dbe6519e8272d9cd677230"></a><!-- doxytag: member="LSQUnit::clearLQ" ref="ae3af532345dbe6519e8272d9cd677230" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearLQ </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears all the entries in the LQ. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00274"></a>00274 {
<a name="l00275"></a>00275     <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>.clear();
<a name="l00276"></a>00276 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a171cd7891063f418b1ee217f5c03537b"></a><!-- doxytag: member="LSQUnit::clearSQ" ref="a171cd7891063f418b1ee217f5c03537b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearSQ </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears all the entries in the SQ. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00281"></a>00281 {
<a name="l00282"></a>00282     <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>.clear();
<a name="l00283"></a>00283 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8ddd26e169a62ec5ae591a9f95934839"></a><!-- doxytag: member="LSQUnit::commitLoad" ref="a8ddd26e169a62ec5ae591a9f95934839" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void commitLoad </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Commits the head load. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00699"></a>00699 {
<a name="l00700"></a>00700     assert(<a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[<a class="code" href="classLSQUnit.html#ac09af89928d2ef4da4cbdcfce26fa3f5">loadHead</a>]);
<a name="l00701"></a>00701 
<a name="l00702"></a>00702     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Committing head load instruction, PC %s\n&quot;</span>,
<a name="l00703"></a>00703             <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[<a class="code" href="classLSQUnit.html#ac09af89928d2ef4da4cbdcfce26fa3f5">loadHead</a>]-&gt;pcState());
<a name="l00704"></a>00704 
<a name="l00705"></a>00705     <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[<a class="code" href="classLSQUnit.html#ac09af89928d2ef4da4cbdcfce26fa3f5">loadHead</a>] = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00706"></a>00706 
<a name="l00707"></a>00707     <a class="code" href="classLSQUnit.html#a129dcadec1d9a805428c1cfd14bcad5e">incrLdIdx</a>(<a class="code" href="classLSQUnit.html#ac09af89928d2ef4da4cbdcfce26fa3f5">loadHead</a>);
<a name="l00708"></a>00708 
<a name="l00709"></a>00709     --<a class="code" href="classLSQUnit.html#a867971f18e464abd16193e069c64a8ad">loads</a>;
<a name="l00710"></a>00710 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1ae517a923a864a4e3a5aa1eeb2dd2d6"></a><!-- doxytag: member="LSQUnit::commitLoads" ref="a1ae517a923a864a4e3a5aa1eeb2dd2d6" args="(InstSeqNum &amp;youngest_inst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void commitLoads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="inst__seq_8hh.html#a258d93d98edaedee089435c19ea2ea2e">InstSeqNum</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>youngest_inst</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Commits loads older than a specific sequence number. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00715"></a>00715 {
<a name="l00716"></a>00716     assert(<a class="code" href="classLSQUnit.html#a867971f18e464abd16193e069c64a8ad">loads</a> == 0 || <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[<a class="code" href="classLSQUnit.html#ac09af89928d2ef4da4cbdcfce26fa3f5">loadHead</a>]);
<a name="l00717"></a>00717 
<a name="l00718"></a>00718     <span class="keywordflow">while</span> (<a class="code" href="classLSQUnit.html#a867971f18e464abd16193e069c64a8ad">loads</a> != 0 &amp;&amp; <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[<a class="code" href="classLSQUnit.html#ac09af89928d2ef4da4cbdcfce26fa3f5">loadHead</a>]-&gt;seqNum &lt;= youngest_inst) {
<a name="l00719"></a>00719         <a class="code" href="classLSQUnit.html#a8ddd26e169a62ec5ae591a9f95934839">commitLoad</a>();
<a name="l00720"></a>00720     }
<a name="l00721"></a>00721 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a954ce1ce58b67cae49ba127d5ea40701"></a><!-- doxytag: member="LSQUnit::commitStores" ref="a954ce1ce58b67cae49ba127d5ea40701" args="(InstSeqNum &amp;youngest_inst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void commitStores </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="inst__seq_8hh.html#a258d93d98edaedee089435c19ea2ea2e">InstSeqNum</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>youngest_inst</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Commits stores older than a specific sequence number. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00726"></a>00726 {
<a name="l00727"></a>00727     assert(<a class="code" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a> == 0 || <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a6e87b6f77102183080ea6ab8599b26a9">storeHead</a>].inst);
<a name="l00728"></a>00728 
<a name="l00729"></a>00729     <span class="keywordtype">int</span> store_idx = <a class="code" href="classLSQUnit.html#a6e87b6f77102183080ea6ab8599b26a9">storeHead</a>;
<a name="l00730"></a>00730 
<a name="l00731"></a>00731     <span class="keywordflow">while</span> (store_idx != <a class="code" href="classLSQUnit.html#acd5c7fbb5578b5cb505ffff16bbf6a8b">storeTail</a>) {
<a name="l00732"></a>00732         assert(<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst);
<a name="l00733"></a>00733         <span class="comment">// Mark any stores that are now committed and have not yet</span>
<a name="l00734"></a>00734         <span class="comment">// been marked as able to write back.</span>
<a name="l00735"></a>00735         <span class="keywordflow">if</span> (!<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].canWB) {
<a name="l00736"></a>00736             <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;seqNum &gt; youngest_inst) {
<a name="l00737"></a>00737                 <span class="keywordflow">break</span>;
<a name="l00738"></a>00738             }
<a name="l00739"></a>00739             <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Marking store as able to write back, PC &quot;</span>
<a name="l00740"></a>00740                     <span class="stringliteral">&quot;%s [sn:%lli]\n&quot;</span>,
<a name="l00741"></a>00741                     <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;pcState(),
<a name="l00742"></a>00742                     <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;seqNum);
<a name="l00743"></a>00743 
<a name="l00744"></a>00744             <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].canWB = <span class="keyword">true</span>;
<a name="l00745"></a>00745 
<a name="l00746"></a>00746             ++<a class="code" href="classLSQUnit.html#a3831a7965ffbe90df177026988476f9c">storesToWB</a>;
<a name="l00747"></a>00747         }
<a name="l00748"></a>00748 
<a name="l00749"></a>00749         <a class="code" href="classLSQUnit.html#a7576fc9eec69e3ce28ce7af7ad87416a">incrStIdx</a>(store_idx);
<a name="l00750"></a>00750     }
<a name="l00751"></a>00751 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0f7f0d3412bbf494cd3d0c0f48e5fcf2"></a><!-- doxytag: member="LSQUnit::completeDataAccess" ref="a0f7f0d3412bbf494cd3d0c0f48e5fcf2" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void completeDataAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Completes the data access that has been returned from the memory system. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00095"></a>00095 {
<a name="l00096"></a>00096     LSQSenderState *state = <span class="keyword">dynamic_cast&lt;</span>LSQSenderState *<span class="keyword">&gt;</span>(pkt-&gt;<a class="code" href="classPacket.html#a983ade0479f946c813284dcc65073367">senderState</a>);
<a name="l00097"></a>00097     <a class="code" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> inst = state-&gt;inst;
<a name="l00098"></a>00098     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html#a23f60a4095b5240dfcb18a4ec40210a9">IEW</a>, <span class="stringliteral">&quot;Writeback event [sn:%lli].\n&quot;</span>, inst-&gt;seqNum);
<a name="l00099"></a>00099     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Activity, <span class="stringliteral">&quot;Activity: Writeback event [sn:%lli].\n&quot;</span>, inst-&gt;seqNum);
<a name="l00100"></a>00100 
<a name="l00101"></a>00101     <span class="comment">//iewStage-&gt;ldstQueue.removeMSHR(inst-&gt;threadNumber,inst-&gt;seqNum);</span>
<a name="l00102"></a>00102 
<a name="l00103"></a>00103     <span class="comment">// If this is a split access, wait until all packets are received.</span>
<a name="l00104"></a>00104     <span class="keywordflow">if</span> (<a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a> &amp;&amp; !state-&gt;complete()) {
<a name="l00105"></a>00105         <span class="keyword">delete</span> pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>;
<a name="l00106"></a>00106         <span class="keyword">delete</span> pkt;
<a name="l00107"></a>00107         <span class="keywordflow">return</span>;
<a name="l00108"></a>00108     }
<a name="l00109"></a>00109 
<a name="l00110"></a>00110     assert(!<a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;switchedOut());
<a name="l00111"></a>00111     <span class="keywordflow">if</span> (inst-&gt;isSquashed()) {
<a name="l00112"></a>00112         <a class="code" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a>-&gt;decrWb(inst-&gt;seqNum);
<a name="l00113"></a>00113     } <span class="keywordflow">else</span> {
<a name="l00114"></a>00114         <span class="keywordflow">if</span> (!state-&gt;noWB) {
<a name="l00115"></a>00115             <span class="keywordflow">if</span> (!<a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a> || !state-&gt;isSplit ||
<a name="l00116"></a>00116                 !state-&gt;isLoad) {
<a name="l00117"></a>00117                 <a class="code" href="classLSQUnit.html#a3911bacb8817c31cfbeefd125dba0217">writeback</a>(inst, pkt);
<a name="l00118"></a>00118             } <span class="keywordflow">else</span> {
<a name="l00119"></a>00119                 <a class="code" href="classLSQUnit.html#a3911bacb8817c31cfbeefd125dba0217">writeback</a>(inst, state-&gt;mainPkt);
<a name="l00120"></a>00120             }
<a name="l00121"></a>00121         }
<a name="l00122"></a>00122 
<a name="l00123"></a>00123         <span class="keywordflow">if</span> (inst-&gt;isStore()) {
<a name="l00124"></a>00124             <a class="code" href="classLSQUnit.html#a12ec7cad6ac51a53bca7795588885e5c">completeStore</a>(state-&gt;idx);
<a name="l00125"></a>00125         }
<a name="l00126"></a>00126     }
<a name="l00127"></a>00127 
<a name="l00128"></a>00128     <span class="keywordflow">if</span> (<a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a> &amp;&amp; state-&gt;isSplit &amp;&amp; state-&gt;isLoad) {
<a name="l00129"></a>00129         <span class="keyword">delete</span> state-&gt;mainPkt-&gt;req;
<a name="l00130"></a>00130         <span class="keyword">delete</span> state-&gt;mainPkt;
<a name="l00131"></a>00131     }
<a name="l00132"></a>00132 
<a name="l00133"></a>00133     pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#ae10871c545a9288b0b1cf05f43d49e19">setAccessLatency</a>();
<a name="l00134"></a>00134     <a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;ppDataAccessComplete-&gt;notify(std::make_pair(inst, pkt));
<a name="l00135"></a>00135 
<a name="l00136"></a>00136     <span class="keyword">delete</span> state;
<a name="l00137"></a>00137     <span class="keyword">delete</span> pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>;
<a name="l00138"></a>00138     <span class="keyword">delete</span> pkt;
<a name="l00139"></a>00139 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a12ec7cad6ac51a53bca7795588885e5c"></a><!-- doxytag: member="LSQUnit::completeStore" ref="a12ec7cad6ac51a53bca7795588885e5c" args="(int store_idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void completeStore </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>store_idx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Completes the store at the specified index. </p>

<p><div class="fragment"><pre class="fragment"><a name="l01152"></a>01152 {
<a name="l01153"></a>01153     assert(<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst);
<a name="l01154"></a>01154     <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].completed = <span class="keyword">true</span>;
<a name="l01155"></a>01155     --<a class="code" href="classLSQUnit.html#a3831a7965ffbe90df177026988476f9c">storesToWB</a>;
<a name="l01156"></a>01156     <span class="comment">// A bit conservative because a store completion may not free up entries,</span>
<a name="l01157"></a>01157     <span class="comment">// but hopefully avoids two store completions in one cycle from making</span>
<a name="l01158"></a>01158     <span class="comment">// the CPU tick twice.</span>
<a name="l01159"></a>01159     <a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;wakeCPU();
<a name="l01160"></a>01160     <a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;activityThisCycle();
<a name="l01161"></a>01161 
<a name="l01162"></a>01162     <span class="keywordflow">if</span> (store_idx == <a class="code" href="classLSQUnit.html#a6e87b6f77102183080ea6ab8599b26a9">storeHead</a>) {
<a name="l01163"></a>01163         <span class="keywordflow">do</span> {
<a name="l01164"></a>01164             <a class="code" href="classLSQUnit.html#a7576fc9eec69e3ce28ce7af7ad87416a">incrStIdx</a>(<a class="code" href="classLSQUnit.html#a6e87b6f77102183080ea6ab8599b26a9">storeHead</a>);
<a name="l01165"></a>01165 
<a name="l01166"></a>01166             --<a class="code" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a>;
<a name="l01167"></a>01167         } <span class="keywordflow">while</span> (<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a6e87b6f77102183080ea6ab8599b26a9">storeHead</a>].completed &amp;&amp;
<a name="l01168"></a>01168                  <a class="code" href="classLSQUnit.html#a6e87b6f77102183080ea6ab8599b26a9">storeHead</a> != <a class="code" href="classLSQUnit.html#acd5c7fbb5578b5cb505ffff16bbf6a8b">storeTail</a>);
<a name="l01169"></a>01169 
<a name="l01170"></a>01170         <a class="code" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a>-&gt;updateLSQNextCycle = <span class="keyword">true</span>;
<a name="l01171"></a>01171     }
<a name="l01172"></a>01172 
<a name="l01173"></a>01173     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Completing store [sn:%lli], idx:%i, store head &quot;</span>
<a name="l01174"></a>01174             <span class="stringliteral">&quot;idx:%i\n&quot;</span>,
<a name="l01175"></a>01175             <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;seqNum, store_idx, <a class="code" href="classLSQUnit.html#a6e87b6f77102183080ea6ab8599b26a9">storeHead</a>);
<a name="l01176"></a>01176 
<a name="l01177"></a>01177 <span class="preprocessor">#if TRACING_ON</span>
<a name="l01178"></a>01178 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="trace_8hh.html#af76c9f7776aade1bf9d7dfa8a0c6b341">DTRACE</a>(O3PipeView)) {
<a name="l01179"></a>01179         <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;storeTick =
<a name="l01180"></a>01180             <a class="code" href="statistics_8hh.html#a7acdccbf0d35ce0c159c0cdd36371b22" title="The universal simulation clock.">curTick</a>() - <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;fetchTick;
<a name="l01181"></a>01181     }
<a name="l01182"></a>01182 <span class="preprocessor">#endif</span>
<a name="l01183"></a>01183 <span class="preprocessor"></span>
<a name="l01184"></a>01184     <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#af8eb8590fbfa6ecd2f796390677a4c00">isStalled</a>() &amp;&amp;
<a name="l01185"></a>01185         <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;seqNum == <a class="code" href="classLSQUnit.html#afe1cdcfca6b44c28581d862228adc3da">stallingStoreIsn</a>) {
<a name="l01186"></a>01186         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Unstalling, stalling store [sn:%lli] &quot;</span>
<a name="l01187"></a>01187                 <span class="stringliteral">&quot;load idx:%i\n&quot;</span>,
<a name="l01188"></a>01188                 <a class="code" href="classLSQUnit.html#afe1cdcfca6b44c28581d862228adc3da">stallingStoreIsn</a>, <a class="code" href="classLSQUnit.html#af55bc9000c8b4e4cfcfbd018feca12a7">stallingLoadIdx</a>);
<a name="l01189"></a>01189         <a class="code" href="classLSQUnit.html#a6f8bff553ad30865c7d0c62e05421eb8">stalled</a> = <span class="keyword">false</span>;
<a name="l01190"></a>01190         <a class="code" href="classLSQUnit.html#afe1cdcfca6b44c28581d862228adc3da">stallingStoreIsn</a> = 0;
<a name="l01191"></a>01191         <a class="code" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a>-&gt;replayMemInst(<a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[<a class="code" href="classLSQUnit.html#af55bc9000c8b4e4cfcfbd018feca12a7">stallingLoadIdx</a>]);
<a name="l01192"></a>01192     }
<a name="l01193"></a>01193 
<a name="l01194"></a>01194     <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;setCompleted();
<a name="l01195"></a>01195 
<a name="l01196"></a>01196     <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#abef3db582145f640478056f8413a03e3">needsTSO</a>) {
<a name="l01197"></a>01197         <a class="code" href="classLSQUnit.html#aec79dbfe7cf50cf3d047cad7ee8fa157">storeInFlight</a> = <span class="keyword">false</span>;
<a name="l01198"></a>01198     }
<a name="l01199"></a>01199 
<a name="l01200"></a>01200     <span class="comment">// Tell the checker we&apos;ve completed this instruction.  Some stores</span>
<a name="l01201"></a>01201     <span class="comment">// may get reported twice to the checker, but the checker can</span>
<a name="l01202"></a>01202     <span class="comment">// handle that case.</span>
<a name="l01203"></a>01203     <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;checker) {
<a name="l01204"></a>01204         <a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;checker-&gt;verify(<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst);
<a name="l01205"></a>01205     }
<a name="l01206"></a>01206 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a313eca7abdfb7c6642078e21bc49a968"></a><!-- doxytag: member="LSQUnit::decrLdIdx" ref="a313eca7abdfb7c6642078e21bc49a968" args="(int &amp;load_idx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decrLdIdx </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>load_idx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decrements the given load index (circular queue). </p>

<p><div class="fragment"><pre class="fragment"><a name="l01293"></a>01293 {
<a name="l01294"></a>01294     <span class="keywordflow">if</span> (--load_idx &lt; 0)
<a name="l01295"></a>01295         load_idx += <a class="code" href="classLSQUnit.html#aafa99d800d574095881acbacdbbbcc47">LQEntries</a>;
<a name="l01296"></a>01296 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4ebe3751617bcb686e225184f77f971c"></a><!-- doxytag: member="LSQUnit::decrStIdx" ref="a4ebe3751617bcb686e225184f77f971c" args="(int &amp;store_idx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decrStIdx </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>store_idx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decrements the given store index (circular queue). </p>

<p><div class="fragment"><pre class="fragment"><a name="l01277"></a>01277 {
<a name="l01278"></a>01278     <span class="keywordflow">if</span> (--store_idx &lt; 0)
<a name="l01279"></a>01279         store_idx += <a class="code" href="classLSQUnit.html#a38c8af5392da70119dc5cce4e3637cbc">SQEntries</a>;
<a name="l01280"></a>01280 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0240eb42fa57fe5d3788093f62b77347"></a><!-- doxytag: member="LSQUnit::drainSanityCheck" ref="a0240eb42fa57fe5d3788093f62b77347" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drainSanityCheck </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform sanity checks after a drain. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00288"></a>00288 {
<a name="l00289"></a>00289     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> = 0; <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> &lt; <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>.size(); ++<a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>)
<a name="l00290"></a>00290         assert(!<a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[<a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>]);
<a name="l00291"></a>00291 
<a name="l00292"></a>00292     assert(<a class="code" href="classLSQUnit.html#a3831a7965ffbe90df177026988476f9c">storesToWB</a> == 0);
<a name="l00293"></a>00293     assert(!<a class="code" href="classLSQUnit.html#a314ae93c04b3ca96e79e1b1f39a8e478">retryPkt</a>);
<a name="l00294"></a>00294 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad0dcc54f6823ec37a9ab4eef289e2305"></a><!-- doxytag: member="LSQUnit::dumpInsts" ref="ad0dcc54f6823ec37a9ab4eef289e2305" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dumpInsts </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Debugging function to dump instructions in the <a class="el" href="classLSQ.html">LSQ</a>. </p>

<p><div class="fragment"><pre class="fragment"><a name="l01301"></a>01301 {
<a name="l01302"></a>01302     <a class="code" href="cprintf_8hh.html#a46231f0e413d30a2560384d0ae05536b">cprintf</a>(<span class="stringliteral">&quot;Load store queue: Dumping instructions.\n&quot;</span>);
<a name="l01303"></a>01303     <a class="code" href="cprintf_8hh.html#a46231f0e413d30a2560384d0ae05536b">cprintf</a>(<span class="stringliteral">&quot;Load queue size: %i\n&quot;</span>, <a class="code" href="classLSQUnit.html#a867971f18e464abd16193e069c64a8ad">loads</a>);
<a name="l01304"></a>01304     <a class="code" href="cprintf_8hh.html#a46231f0e413d30a2560384d0ae05536b">cprintf</a>(<span class="stringliteral">&quot;Load queue: &quot;</span>);
<a name="l01305"></a>01305 
<a name="l01306"></a>01306     <span class="keywordtype">int</span> load_idx = <a class="code" href="classLSQUnit.html#ac09af89928d2ef4da4cbdcfce26fa3f5">loadHead</a>;
<a name="l01307"></a>01307 
<a name="l01308"></a>01308     <span class="keywordflow">while</span> (load_idx != <a class="code" href="classLSQUnit.html#a973a489225da164cc85e690f13c86841">loadTail</a> &amp;&amp; <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[load_idx]) {
<a name="l01309"></a>01309         <span class="keyword">const</span> <a class="code" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> &amp;inst(<a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[load_idx]);
<a name="l01310"></a>01310         <a class="code" href="cprintf_8hh.html#a46231f0e413d30a2560384d0ae05536b">cprintf</a>(<span class="stringliteral">&quot;%s.[sn:%i] &quot;</span>, inst-&gt;pcState(), inst-&gt;seqNum);
<a name="l01311"></a>01311 
<a name="l01312"></a>01312         <a class="code" href="classLSQUnit.html#a129dcadec1d9a805428c1cfd14bcad5e">incrLdIdx</a>(load_idx);
<a name="l01313"></a>01313     }
<a name="l01314"></a>01314     <a class="code" href="cprintf_8hh.html#a46231f0e413d30a2560384d0ae05536b">cprintf</a>(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l01315"></a>01315 
<a name="l01316"></a>01316     <a class="code" href="cprintf_8hh.html#a46231f0e413d30a2560384d0ae05536b">cprintf</a>(<span class="stringliteral">&quot;Store queue size: %i\n&quot;</span>, <a class="code" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a>);
<a name="l01317"></a>01317     <a class="code" href="cprintf_8hh.html#a46231f0e413d30a2560384d0ae05536b">cprintf</a>(<span class="stringliteral">&quot;Store queue: &quot;</span>);
<a name="l01318"></a>01318 
<a name="l01319"></a>01319     <span class="keywordtype">int</span> store_idx = <a class="code" href="classLSQUnit.html#a6e87b6f77102183080ea6ab8599b26a9">storeHead</a>;
<a name="l01320"></a>01320 
<a name="l01321"></a>01321     <span class="keywordflow">while</span> (store_idx != <a class="code" href="classLSQUnit.html#acd5c7fbb5578b5cb505ffff16bbf6a8b">storeTail</a> &amp;&amp; <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst) {
<a name="l01322"></a>01322         <span class="keyword">const</span> <a class="code" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> &amp;inst(<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst);
<a name="l01323"></a>01323         <a class="code" href="cprintf_8hh.html#a46231f0e413d30a2560384d0ae05536b">cprintf</a>(<span class="stringliteral">&quot;%s.[sn:%i] &quot;</span>, inst-&gt;pcState(), inst-&gt;seqNum);
<a name="l01324"></a>01324 
<a name="l01325"></a>01325         <a class="code" href="classLSQUnit.html#a7576fc9eec69e3ce28ce7af7ad87416a">incrStIdx</a>(store_idx);
<a name="l01326"></a>01326     }
<a name="l01327"></a>01327 
<a name="l01328"></a>01328     <a class="code" href="cprintf_8hh.html#a46231f0e413d30a2560384d0ae05536b">cprintf</a>(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l01329"></a>01329 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a091a4d1788ce66e51ceb888bbd85ac08"></a><!-- doxytag: member="LSQUnit::executeLoad" ref="a091a4d1788ce66e51ceb888bbd85ac08" args="(int lq_idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRefCountingPtr.html">Fault</a> executeLoad </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lq_idx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00143"></a>00143 { <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;Not implemented&quot;</span>); <span class="keywordflow">return</span> <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a30c6332142c2ecca389ed6ee463c692b"></a><!-- doxytag: member="LSQUnit::executeLoad" ref="a30c6332142c2ecca389ed6ee463c692b" args="(DynInstPtr &amp;inst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRefCountingPtr.html">Fault</a> executeLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inst</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Executes a load instruction. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00597"></a>00597 {
<a name="l00598"></a>00598     <span class="keyword">using namespace </span>TheISA;
<a name="l00599"></a>00599     <span class="comment">// Execute a specific load.</span>
<a name="l00600"></a>00600     <a class="code" href="classRefCountingPtr.html">Fault</a> load_fault = <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>;
<a name="l00601"></a>00601 
<a name="l00602"></a>00602     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Executing load PC %s, [sn:%lli]\n&quot;</span>,
<a name="l00603"></a>00603             inst-&gt;pcState(), inst-&gt;seqNum);
<a name="l00604"></a>00604 
<a name="l00605"></a>00605     assert(!inst-&gt;isSquashed());
<a name="l00606"></a>00606 
<a name="l00607"></a>00607     load_fault = inst-&gt;initiateAcc();
<a name="l00608"></a>00608 
<a name="l00609"></a>00609     <span class="keywordflow">if</span> (inst-&gt;isTranslationDelayed() &amp;&amp;
<a name="l00610"></a>00610         load_fault == <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>)
<a name="l00611"></a>00611         <span class="keywordflow">return</span> load_fault;
<a name="l00612"></a>00612 
<a name="l00613"></a>00613     <span class="comment">// If the instruction faulted or predicated false, then we need to send it</span>
<a name="l00614"></a>00614     <span class="comment">// along to commit without the instruction completing.</span>
<a name="l00615"></a>00615     <span class="keywordflow">if</span> (load_fault != <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a> || !inst-&gt;readPredicate()) {
<a name="l00616"></a>00616         <span class="comment">// Send this instruction to commit, also make sure iew stage</span>
<a name="l00617"></a>00617         <span class="comment">// realizes there is activity.</span>
<a name="l00618"></a>00618         <span class="comment">// Mark it as executed unless it is an uncached load that</span>
<a name="l00619"></a>00619         <span class="comment">// needs to hit the head of commit.</span>
<a name="l00620"></a>00620         <span class="keywordflow">if</span> (!inst-&gt;readPredicate())
<a name="l00621"></a>00621             inst-&gt;forwardOldRegs();
<a name="l00622"></a>00622         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Load [sn:%lli] not executed from %s\n&quot;</span>,
<a name="l00623"></a>00623                 inst-&gt;seqNum,
<a name="l00624"></a>00624                 (load_fault != <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a> ? <span class="stringliteral">&quot;fault&quot;</span> : <span class="stringliteral">&quot;predication&quot;</span>));
<a name="l00625"></a>00625         <span class="keywordflow">if</span> (!(inst-&gt;hasRequest() &amp;&amp; inst-&gt;uncacheable()) ||
<a name="l00626"></a>00626             inst-&gt;isAtCommit()) {
<a name="l00627"></a>00627             inst-&gt;setExecuted();
<a name="l00628"></a>00628         }
<a name="l00629"></a>00629         <a class="code" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a>-&gt;instToCommit(inst);
<a name="l00630"></a>00630         <a class="code" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a>-&gt;activityThisCycle();
<a name="l00631"></a>00631     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="classLSQUnit.html#a05c413ba417c6453e99f75d87c958590">loadBlocked</a>()) {
<a name="l00632"></a>00632         assert(inst-&gt;effAddrValid());
<a name="l00633"></a>00633         <span class="keywordtype">int</span> load_idx = inst-&gt;lqIdx;
<a name="l00634"></a>00634         <a class="code" href="classLSQUnit.html#a129dcadec1d9a805428c1cfd14bcad5e">incrLdIdx</a>(load_idx);
<a name="l00635"></a>00635 
<a name="l00636"></a>00636         <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a602a9ccaf8b313e8923d8b07ec5bc439">checkLoads</a>)
<a name="l00637"></a>00637             <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a15239c5725d8744a793c867193e4bce7">checkViolations</a>(load_idx, inst);
<a name="l00638"></a>00638     }
<a name="l00639"></a>00639 
<a name="l00640"></a>00640     <span class="keywordflow">return</span> load_fault;
<a name="l00641"></a>00641 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aad78b8a37ee5c61e47df58dd39980340"></a><!-- doxytag: member="LSQUnit::executeStore" ref="aad78b8a37ee5c61e47df58dd39980340" args="(DynInstPtr &amp;inst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRefCountingPtr.html">Fault</a> executeStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inst</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Executes a store instruction. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00646"></a>00646 {
<a name="l00647"></a>00647     <span class="keyword">using namespace </span>TheISA;
<a name="l00648"></a>00648     <span class="comment">// Make sure that a store exists.</span>
<a name="l00649"></a>00649     assert(<a class="code" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a> != 0);
<a name="l00650"></a>00650 
<a name="l00651"></a>00651     <span class="keywordtype">int</span> store_idx = store_inst-&gt;sqIdx;
<a name="l00652"></a>00652 
<a name="l00653"></a>00653     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Executing store PC %s [sn:%lli]\n&quot;</span>,
<a name="l00654"></a>00654             store_inst-&gt;pcState(), store_inst-&gt;seqNum);
<a name="l00655"></a>00655 
<a name="l00656"></a>00656     assert(!store_inst-&gt;isSquashed());
<a name="l00657"></a>00657 
<a name="l00658"></a>00658     <span class="comment">// Check the recently completed loads to see if any match this store&apos;s</span>
<a name="l00659"></a>00659     <span class="comment">// address.  If so, then we have a memory ordering violation.</span>
<a name="l00660"></a>00660     <span class="keywordtype">int</span> load_idx = store_inst-&gt;lqIdx;
<a name="l00661"></a>00661 
<a name="l00662"></a>00662     <a class="code" href="classRefCountingPtr.html">Fault</a> store_fault = store_inst-&gt;initiateAcc();
<a name="l00663"></a>00663 
<a name="l00664"></a>00664     <span class="keywordflow">if</span> (store_inst-&gt;isTranslationDelayed() &amp;&amp;
<a name="l00665"></a>00665         store_fault == <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>)
<a name="l00666"></a>00666         <span class="keywordflow">return</span> store_fault;
<a name="l00667"></a>00667 
<a name="l00668"></a>00668     <span class="keywordflow">if</span> (!store_inst-&gt;readPredicate())
<a name="l00669"></a>00669         store_inst-&gt;forwardOldRegs();
<a name="l00670"></a>00670 
<a name="l00671"></a>00671     <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].size == 0) {
<a name="l00672"></a>00672         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>,<span class="stringliteral">&quot;Fault on Store PC %s, [sn:%lli], Size = 0\n&quot;</span>,
<a name="l00673"></a>00673                 store_inst-&gt;pcState(), store_inst-&gt;seqNum);
<a name="l00674"></a>00674 
<a name="l00675"></a>00675         <span class="keywordflow">return</span> store_fault;
<a name="l00676"></a>00676     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!store_inst-&gt;readPredicate()) {
<a name="l00677"></a>00677         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Store [sn:%lli] not executed from predication\n&quot;</span>,
<a name="l00678"></a>00678                 store_inst-&gt;seqNum);
<a name="l00679"></a>00679         <span class="keywordflow">return</span> store_fault;
<a name="l00680"></a>00680     }
<a name="l00681"></a>00681 
<a name="l00682"></a>00682     assert(store_fault == <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>);
<a name="l00683"></a>00683 
<a name="l00684"></a>00684     <span class="keywordflow">if</span> (store_inst-&gt;isStoreConditional()) {
<a name="l00685"></a>00685         <span class="comment">// Store conditionals need to set themselves as able to</span>
<a name="l00686"></a>00686         <span class="comment">// writeback if we haven&apos;t had a fault by here.</span>
<a name="l00687"></a>00687         <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].canWB = <span class="keyword">true</span>;
<a name="l00688"></a>00688 
<a name="l00689"></a>00689         ++<a class="code" href="classLSQUnit.html#a3831a7965ffbe90df177026988476f9c">storesToWB</a>;
<a name="l00690"></a>00690     }
<a name="l00691"></a>00691 
<a name="l00692"></a>00692     <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a15239c5725d8744a793c867193e4bce7">checkViolations</a>(load_idx, store_inst);
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a24ba9cb3fa1e726321780a20a960c8cd"></a><!-- doxytag: member="LSQUnit::getCount" ref="a24ba9cb3fa1e726321780a20a960c8cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned getCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the number of instructions in the <a class="el" href="classLSQ.html">LSQ</a>. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00229"></a>00229 { <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a867971f18e464abd16193e069c64a8ad">loads</a> + <a class="code" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad43a7408f4e1c1e181bc40ecab6dc593"></a><!-- doxytag: member="LSQUnit::getLoadHead" ref="ad43a7408f4e1c1e181bc40ecab6dc593" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getLoadHead </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the index of the head load instruction. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00541"></a>00541 { <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#ac09af89928d2ef4da4cbdcfce26fa3f5">loadHead</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aee7352adadc6b43b7ce36a8c052eb222"></a><!-- doxytag: member="LSQUnit::getLoadHeadSeqNum" ref="aee7352adadc6b43b7ce36a8c052eb222" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inst__seq_8hh.html#a258d93d98edaedee089435c19ea2ea2e">InstSeqNum</a> getLoadHeadSeqNum </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the sequence number of the head load instruction. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00544"></a>00544     {
<a name="l00545"></a>00545         <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[<a class="code" href="classLSQUnit.html#ac09af89928d2ef4da4cbdcfce26fa3f5">loadHead</a>]) {
<a name="l00546"></a>00546             <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[loadHead]-&gt;seqNum;
<a name="l00547"></a>00547         } <span class="keywordflow">else</span> {
<a name="l00548"></a>00548             <span class="keywordflow">return</span> 0;
<a name="l00549"></a>00549         }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a30adaf6f5fb6b38b5747f35c419e3f31"></a><!-- doxytag: member="LSQUnit::getMemDepViolator" ref="a30adaf6f5fb6b38b5747f35c419e3f31" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Impl::DynInstPtr getMemDepViolator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the memory ordering violator. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00407"></a>00407 {
<a name="l00408"></a>00408     <a class="code" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> temp = <a class="code" href="classLSQUnit.html#a270a20c3fa52139e0538288275db9d22">memDepViolator</a>;
<a name="l00409"></a>00409 
<a name="l00410"></a>00410     <a class="code" href="classLSQUnit.html#a270a20c3fa52139e0538288275db9d22">memDepViolator</a> = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00411"></a>00411 
<a name="l00412"></a>00412     <span class="keywordflow">return</span> temp;
<a name="l00413"></a>00413 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab9d14b0deb8ab44dc09ac784b162e774"></a><!-- doxytag: member="LSQUnit::getStoreHead" ref="ab9d14b0deb8ab44dc09ac784b162e774" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getStoreHead </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the index of the head store instruction. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00554"></a>00554 { <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a6e87b6f77102183080ea6ab8599b26a9">storeHead</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1813b58ab7569d6aeefb5d4e235cceda"></a><!-- doxytag: member="LSQUnit::getStoreHeadSeqNum" ref="a1813b58ab7569d6aeefb5d4e235cceda" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inst__seq_8hh.html#a258d93d98edaedee089435c19ea2ea2e">InstSeqNum</a> getStoreHeadSeqNum </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the sequence number of the head store instruction. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00557"></a>00557     {
<a name="l00558"></a>00558         <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a6e87b6f77102183080ea6ab8599b26a9">storeHead</a>].inst) {
<a name="l00559"></a>00559             <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a6e87b6f77102183080ea6ab8599b26a9">storeHead</a>].inst-&gt;seqNum;
<a name="l00560"></a>00560         } <span class="keywordflow">else</span> {
<a name="l00561"></a>00561             <span class="keywordflow">return</span> 0;
<a name="l00562"></a>00562         }
<a name="l00563"></a>00563 
<a name="l00564"></a>00564     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad2e4b46255cfb53e85522adeed4e2089"></a><!-- doxytag: member="LSQUnit::hasStoresToWB" ref="ad2e4b46255cfb53e85522adeed4e2089" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hasStoresToWB </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns if there are any stores to writeback. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00232"></a>00232 { <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a3831a7965ffbe90df177026988476f9c">storesToWB</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a129dcadec1d9a805428c1cfd14bcad5e"></a><!-- doxytag: member="LSQUnit::incrLdIdx" ref="a129dcadec1d9a805428c1cfd14bcad5e" args="(int &amp;load_idx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void incrLdIdx </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>load_idx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increments the given load index (circular queue). </p>

<p><div class="fragment"><pre class="fragment"><a name="l01285"></a>01285 {
<a name="l01286"></a>01286     <span class="keywordflow">if</span> (++load_idx &gt;= <a class="code" href="classLSQUnit.html#aafa99d800d574095881acbacdbbbcc47">LQEntries</a>)
<a name="l01287"></a>01287         load_idx = 0;
<a name="l01288"></a>01288 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7576fc9eec69e3ce28ce7af7ad87416a"></a><!-- doxytag: member="LSQUnit::incrStIdx" ref="a7576fc9eec69e3ce28ce7af7ad87416a" args="(int &amp;store_idx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void incrStIdx </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>store_idx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increments the given store index (circular queue). </p>

<p><div class="fragment"><pre class="fragment"><a name="l01269"></a>01269 {
<a name="l01270"></a>01270     <span class="keywordflow">if</span> (++store_idx &gt;= <a class="code" href="classLSQUnit.html#a38c8af5392da70119dc5cce4e3637cbc">SQEntries</a>)
<a name="l01271"></a>01271         store_idx = 0;
<a name="l01272"></a>01272 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a45b3b65ba551c17c3b200db265611a4c"></a><!-- doxytag: member="LSQUnit::init" ref="a45b3b65ba551c17c3b200db265611a4c" args="(O3CPU *cpu_ptr, IEW *iew_ptr, DerivO3CPUParams *params, LSQ *lsq_ptr, unsigned maxLQEntries, unsigned maxSQEntries, unsigned id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLSQUnit.html#a44622cf06940413482836cb62931ac3f">O3CPU</a> *&nbsp;</td>
          <td class="paramname"> <em>cpu_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLSQUnit.html#a23f60a4095b5240dfcb18a4ec40210a9">IEW</a> *&nbsp;</td>
          <td class="paramname"> <em>iew_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DerivO3CPUParams *&nbsp;</td>
          <td class="paramname"> <em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLSQ.html">LSQ</a> *&nbsp;</td>
          <td class="paramname"> <em>lsq_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>maxLQEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>maxSQEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes the <a class="el" href="classLSQ.html">LSQ</a> unit with the specified number of entries. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00154"></a>00154 {
<a name="l00155"></a>00155     <a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a> = cpu_ptr;
<a name="l00156"></a>00156     <a class="code" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a> = iew_ptr;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158     <a class="code" href="classLSQUnit.html#ac0894e8141823f8eea2c9041bac9dab4">lsq</a> = lsq_ptr;
<a name="l00159"></a>00159 
<a name="l00160"></a>00160     <a class="code" href="classLSQUnit.html#a0ee490ba978f48fbf2579acc7eb60b24">lsqID</a> = <a class="code" href="namespaceSparcISA.html#a2b4cf644f5af9ebaec502fb09986f302">id</a>;
<a name="l00161"></a>00161 
<a name="l00162"></a>00162     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Creating LSQUnit%i object.\n&quot;</span>,<span class="keywordtype">id</span>);
<a name="l00163"></a>00163 
<a name="l00164"></a>00164     <span class="comment">// Add 1 for the sentinel entry (they are circular queues).</span>
<a name="l00165"></a>00165     <a class="code" href="classLSQUnit.html#aafa99d800d574095881acbacdbbbcc47">LQEntries</a> = maxLQEntries + 1;
<a name="l00166"></a>00166     <a class="code" href="classLSQUnit.html#a38c8af5392da70119dc5cce4e3637cbc">SQEntries</a> = maxSQEntries + 1;
<a name="l00167"></a>00167 
<a name="l00168"></a>00168     <span class="comment">//Due to uint8_t index in LSQSenderState</span>
<a name="l00169"></a>00169     assert(<a class="code" href="classLSQUnit.html#aafa99d800d574095881acbacdbbbcc47">LQEntries</a> &lt;= 256);
<a name="l00170"></a>00170     assert(<a class="code" href="classLSQUnit.html#a38c8af5392da70119dc5cce4e3637cbc">SQEntries</a> &lt;= 256);
<a name="l00171"></a>00171 
<a name="l00172"></a>00172     <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>.resize(<a class="code" href="classLSQUnit.html#aafa99d800d574095881acbacdbbbcc47">LQEntries</a>);
<a name="l00173"></a>00173     <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>.resize(<a class="code" href="classLSQUnit.html#a38c8af5392da70119dc5cce4e3637cbc">SQEntries</a>);
<a name="l00174"></a>00174 
<a name="l00175"></a>00175     <a class="code" href="classLSQUnit.html#ab5dfaaa13f279adbed7a1eafea047796">depCheckShift</a> = params-&gt;LSQDepCheckShift;
<a name="l00176"></a>00176     <a class="code" href="classLSQUnit.html#a602a9ccaf8b313e8923d8b07ec5bc439">checkLoads</a> = params-&gt;LSQCheckLoads;
<a name="l00177"></a>00177     <a class="code" href="classLSQUnit.html#ab2e23636971c40e7ed945026b2a184e1">cachePorts</a> = params-&gt;cachePorts;
<a name="l00178"></a>00178     <a class="code" href="classLSQUnit.html#abef3db582145f640478056f8413a03e3">needsTSO</a> = params-&gt;needsTSO;
<a name="l00179"></a>00179 
<a name="l00180"></a>00180     <a class="code" href="classLSQUnit.html#a755ee993c2d4e9d422c37990b15afa37">resetState</a>();
<a name="l00181"></a>00181 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a773e88db1aa010c3755e603493bf40ec"></a><!-- doxytag: member="LSQUnit::insert" ref="a773e88db1aa010c3755e603493bf40ec" args="(DynInstPtr &amp;inst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inst</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts an instruction. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00344"></a>00344 {
<a name="l00345"></a>00345     assert(inst-&gt;isMemRef());
<a name="l00346"></a>00346 
<a name="l00347"></a>00347     assert(inst-&gt;isLoad() || inst-&gt;isStore());
<a name="l00348"></a>00348 
<a name="l00349"></a>00349     <span class="keywordflow">if</span> (inst-&gt;isLoad()) {
<a name="l00350"></a>00350         <a class="code" href="classLSQUnit.html#ad22b3ecafed2bcd9c59fcab049a1cb98">insertLoad</a>(inst);
<a name="l00351"></a>00351     } <span class="keywordflow">else</span> {
<a name="l00352"></a>00352         <a class="code" href="classLSQUnit.html#a6a4b4e51bfff3639932ebaba45e8a282">insertStore</a>(inst);
<a name="l00353"></a>00353     }
<a name="l00354"></a>00354 
<a name="l00355"></a>00355     inst-&gt;setInLSQ();
<a name="l00356"></a>00356 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad22b3ecafed2bcd9c59fcab049a1cb98"></a><!-- doxytag: member="LSQUnit::insertLoad" ref="ad22b3ecafed2bcd9c59fcab049a1cb98" args="(DynInstPtr &amp;load_inst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insertLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>load_inst</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a load instruction. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00361"></a>00361 {
<a name="l00362"></a>00362     assert((<a class="code" href="classLSQUnit.html#a973a489225da164cc85e690f13c86841">loadTail</a> + 1) % <a class="code" href="classLSQUnit.html#aafa99d800d574095881acbacdbbbcc47">LQEntries</a> != <a class="code" href="classLSQUnit.html#ac09af89928d2ef4da4cbdcfce26fa3f5">loadHead</a>);
<a name="l00363"></a>00363     assert(<a class="code" href="classLSQUnit.html#a867971f18e464abd16193e069c64a8ad">loads</a> &lt; <a class="code" href="classLSQUnit.html#aafa99d800d574095881acbacdbbbcc47">LQEntries</a>);
<a name="l00364"></a>00364 
<a name="l00365"></a>00365     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Inserting load PC %s, idx:%i [sn:%lli]\n&quot;</span>,
<a name="l00366"></a>00366             load_inst-&gt;pcState(), <a class="code" href="classLSQUnit.html#a973a489225da164cc85e690f13c86841">loadTail</a>, load_inst-&gt;seqNum);
<a name="l00367"></a>00367 
<a name="l00368"></a>00368     load_inst-&gt;lqIdx = <a class="code" href="classLSQUnit.html#a973a489225da164cc85e690f13c86841">loadTail</a>;
<a name="l00369"></a>00369 
<a name="l00370"></a>00370     <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a> == 0) {
<a name="l00371"></a>00371         load_inst-&gt;sqIdx = -1;
<a name="l00372"></a>00372     } <span class="keywordflow">else</span> {
<a name="l00373"></a>00373         load_inst-&gt;sqIdx = <a class="code" href="classLSQUnit.html#acd5c7fbb5578b5cb505ffff16bbf6a8b">storeTail</a>;
<a name="l00374"></a>00374     }
<a name="l00375"></a>00375 
<a name="l00376"></a>00376     <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[<a class="code" href="classLSQUnit.html#a973a489225da164cc85e690f13c86841">loadTail</a>] = load_inst;
<a name="l00377"></a>00377 
<a name="l00378"></a>00378     <a class="code" href="classLSQUnit.html#a129dcadec1d9a805428c1cfd14bcad5e">incrLdIdx</a>(<a class="code" href="classLSQUnit.html#a973a489225da164cc85e690f13c86841">loadTail</a>);
<a name="l00379"></a>00379 
<a name="l00380"></a>00380     ++<a class="code" href="classLSQUnit.html#a867971f18e464abd16193e069c64a8ad">loads</a>;
<a name="l00381"></a>00381 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6a4b4e51bfff3639932ebaba45e8a282"></a><!-- doxytag: member="LSQUnit::insertStore" ref="a6a4b4e51bfff3639932ebaba45e8a282" args="(DynInstPtr &amp;store_inst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insertStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>store_inst</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a store instruction. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00386"></a>00386 {
<a name="l00387"></a>00387     <span class="comment">// Make sure it is not full before inserting an instruction.</span>
<a name="l00388"></a>00388     assert((<a class="code" href="classLSQUnit.html#acd5c7fbb5578b5cb505ffff16bbf6a8b">storeTail</a> + 1) % <a class="code" href="classLSQUnit.html#a38c8af5392da70119dc5cce4e3637cbc">SQEntries</a> != <a class="code" href="classLSQUnit.html#a6e87b6f77102183080ea6ab8599b26a9">storeHead</a>);
<a name="l00389"></a>00389     assert(<a class="code" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a> &lt; <a class="code" href="classLSQUnit.html#a38c8af5392da70119dc5cce4e3637cbc">SQEntries</a>);
<a name="l00390"></a>00390 
<a name="l00391"></a>00391     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Inserting store PC %s, idx:%i [sn:%lli]\n&quot;</span>,
<a name="l00392"></a>00392             store_inst-&gt;pcState(), <a class="code" href="classLSQUnit.html#acd5c7fbb5578b5cb505ffff16bbf6a8b">storeTail</a>, store_inst-&gt;seqNum);
<a name="l00393"></a>00393 
<a name="l00394"></a>00394     store_inst-&gt;sqIdx = <a class="code" href="classLSQUnit.html#acd5c7fbb5578b5cb505ffff16bbf6a8b">storeTail</a>;
<a name="l00395"></a>00395     store_inst-&gt;lqIdx = <a class="code" href="classLSQUnit.html#a973a489225da164cc85e690f13c86841">loadTail</a>;
<a name="l00396"></a>00396 
<a name="l00397"></a>00397     <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#acd5c7fbb5578b5cb505ffff16bbf6a8b">storeTail</a>] = SQEntry(store_inst);
<a name="l00398"></a>00398 
<a name="l00399"></a>00399     <a class="code" href="classLSQUnit.html#a7576fc9eec69e3ce28ce7af7ad87416a">incrStIdx</a>(<a class="code" href="classLSQUnit.html#acd5c7fbb5578b5cb505ffff16bbf6a8b">storeTail</a>);
<a name="l00400"></a>00400 
<a name="l00401"></a>00401     ++<a class="code" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a>;
<a name="l00402"></a>00402 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a479432127ee77145cc19d6a2d1590821"></a><!-- doxytag: member="LSQUnit::isEmpty" ref="a479432127ee77145cc19d6a2d1590821" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns if both the LQ and SQ are empty. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00214"></a>00214 { <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a01d2807c1345befcffd168a2a9dbdbf2">lqEmpty</a>() &amp;&amp; <a class="code" href="classLSQUnit.html#a5761e9640bec8ba8474945cce57b6501">sqEmpty</a>(); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3e70330939fdfc4dbc2f60c1a660584d"></a><!-- doxytag: member="LSQUnit::isFull" ref="a3e70330939fdfc4dbc2f60c1a660584d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isFull </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns if either the LQ or SQ is full. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00211"></a>00211 { <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a5893daf623130be826f492bbff58f757">lqFull</a>() || <a class="code" href="classLSQUnit.html#a477981d1f905d2d398a1527f7149e3c4">sqFull</a>(); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad0aa91a7b51ca925abf9c9992abad314"></a><!-- doxytag: member="LSQUnit::isLoadBlockedHandled" ref="ad0aa91a7b51ca925abf9c9992abad314" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isLoadBlockedHandled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns if the blocked load was handled. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00195"></a>00195     { <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a2c1620029c162c7180e523b089e56ed5">loadBlockedHandled</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af8eb8590fbfa6ecd2f796390677a4c00"></a><!-- doxytag: member="LSQUnit::isStalled" ref="af8eb8590fbfa6ecd2f796390677a4c00" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isStalled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether or not the <a class="el" href="classLSQ.html">LSQ</a> unit is stalled. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00567"></a>00567 { <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a6f8bff553ad30865c7d0c62e05421eb8">stalled</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a05c413ba417c6453e99f75d87c958590"></a><!-- doxytag: member="LSQUnit::loadBlocked" ref="a05c413ba417c6453e99f75d87c958590" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool loadBlocked </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns if a load became blocked due to the memory system. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00187"></a>00187     { <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a95dc31b4ce3ebcb6b9d75a510b3a128c">isLoadBlocked</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a01d2807c1345befcffd168a2a9dbdbf2"></a><!-- doxytag: member="LSQUnit::lqEmpty" ref="a01d2807c1345befcffd168a2a9dbdbf2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lqEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns if the LQ is empty. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00223"></a>00223 { <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a867971f18e464abd16193e069c64a8ad">loads</a> == 0; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5893daf623130be826f492bbff58f757"></a><!-- doxytag: member="LSQUnit::lqFull" ref="a5893daf623130be826f492bbff58f757" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lqFull </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns if the LQ is full. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00217"></a>00217 { <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a867971f18e464abd16193e069c64a8ad">loads</a> &gt;= (<a class="code" href="classLSQUnit.html#aafa99d800d574095881acbacdbbbcc47">LQEntries</a> - 1); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a37627d5d5bba7f4a8690c71c2ab3cb07"></a><!-- doxytag: member="LSQUnit::name" ref="a37627d5d5bba7f4a8690c71c2ab3cb07" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string name </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the name of the <a class="el" href="classLSQ.html">LSQ</a> unit. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00211"></a>00211 {
<a name="l00212"></a>00212     <span class="keywordflow">if</span> (<a class="code" href="namespaceThePipeline.html#ac9c0bbe9cf27d93e08ea8ccc4096e633">Impl::MaxThreads</a> == 1) {
<a name="l00213"></a>00213         <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a>-&gt;name() + <span class="stringliteral">&quot;.lsq&quot;</span>;
<a name="l00214"></a>00214     } <span class="keywordflow">else</span> {
<a name="l00215"></a>00215         <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a>-&gt;name() + <span class="stringliteral">&quot;.lsq.thread&quot;</span> + <a class="code" href="str_8hh.html#a61cce639667f3e4f1d8790c4fec5c439">to_string</a>(<a class="code" href="classLSQUnit.html#a0ee490ba978f48fbf2579acc7eb60b24">lsqID</a>);
<a name="l00216"></a>00216     }
<a name="l00217"></a>00217 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a028971a565aca048c67ea1c36a6a9d51"></a><!-- doxytag: member="LSQUnit::numFreeEntries" ref="a028971a565aca048c67ea1c36a6a9d51" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned numFreeEntries </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the number of free entries (min of free LQ and SQ entries). </p>

<p><div class="fragment"><pre class="fragment"><a name="l00418"></a>00418 {
<a name="l00419"></a>00419     <span class="keywordtype">unsigned</span> free_lq_entries = <a class="code" href="classLSQUnit.html#aafa99d800d574095881acbacdbbbcc47">LQEntries</a> - <a class="code" href="classLSQUnit.html#a867971f18e464abd16193e069c64a8ad">loads</a>;
<a name="l00420"></a>00420     <span class="keywordtype">unsigned</span> free_sq_entries = <a class="code" href="classLSQUnit.html#a38c8af5392da70119dc5cce4e3637cbc">SQEntries</a> - <a class="code" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a>;
<a name="l00421"></a>00421 
<a name="l00422"></a>00422     <span class="comment">// Both the LQ and SQ entries have an extra dummy entry to differentiate</span>
<a name="l00423"></a>00423     <span class="comment">// empty/full conditions.  Subtract 1 from the free entries.</span>
<a name="l00424"></a>00424     <span class="keywordflow">if</span> (free_lq_entries &lt; free_sq_entries) {
<a name="l00425"></a>00425         <span class="keywordflow">return</span> free_lq_entries - 1;
<a name="l00426"></a>00426     } <span class="keywordflow">else</span> {
<a name="l00427"></a>00427         <span class="keywordflow">return</span> free_sq_entries - 1;
<a name="l00428"></a>00428     }
<a name="l00429"></a>00429 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a54460b759fb06e2b18e26657279a6f49"></a><!-- doxytag: member="LSQUnit::numLoads" ref="a54460b759fb06e2b18e26657279a6f49" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int numLoads </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the number of loads in the LQ. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00205"></a>00205 { <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a867971f18e464abd16193e069c64a8ad">loads</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa0fc32a4a9d77696f5907f4d25e7d07f"></a><!-- doxytag: member="LSQUnit::numStores" ref="aa0fc32a4a9d77696f5907f4d25e7d07f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int numStores </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the number of stores in the SQ. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00208"></a>00208 { <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a276cdbdaf4551f1b846c4e2535c5f882"></a><!-- doxytag: member="LSQUnit::numStoresToWB" ref="a276cdbdaf4551f1b846c4e2535c5f882" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int numStoresToWB </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the number of stores to writeback. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00235"></a>00235 { <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a3831a7965ffbe90df177026988476f9c">storesToWB</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6f61d3e96e7ebc628121a63027d9c106"></a><!-- doxytag: member="LSQUnit::read" ref="a6f61d3e96e7ebc628121a63027d9c106" args="(Request *req, Request *sreqLow, Request *sreqHigh, uint8_t *data, int load_idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRefCountingPtr.html">Fault</a> read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRequest.html">Request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRequest.html">Request</a> *&nbsp;</td>
          <td class="paramname"> <em>sreqLow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRequest.html">Request</a> *&nbsp;</td>
          <td class="paramname"> <em>sreqHigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>load_idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Executes the load at the given index. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00574"></a>00574 {
<a name="l00575"></a>00575     <a class="code" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> load_inst = <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[load_idx];
<a name="l00576"></a>00576 
<a name="l00577"></a>00577     assert(load_inst);
<a name="l00578"></a>00578 
<a name="l00579"></a>00579     assert(!load_inst-&gt;isExecuted());
<a name="l00580"></a>00580 
<a name="l00581"></a>00581     <span class="comment">// Make sure this isn&apos;t an uncacheable access</span>
<a name="l00582"></a>00582     <span class="comment">// A bit of a hackish way to get uncached accesses to work only if they&apos;re</span>
<a name="l00583"></a>00583     <span class="comment">// at the head of the LSQ and are ready to commit (at the head of the ROB</span>
<a name="l00584"></a>00584     <span class="comment">// too).</span>
<a name="l00585"></a>00585     <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#a70c74b2809417ea8701dd6ba9e34312d">isUncacheable</a>() &amp;&amp;
<a name="l00586"></a>00586         (load_idx != <a class="code" href="classLSQUnit.html#ac09af89928d2ef4da4cbdcfce26fa3f5">loadHead</a> || !load_inst-&gt;isAtCommit())) {
<a name="l00587"></a>00587         <a class="code" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a>-&gt;rescheduleMemInst(load_inst);
<a name="l00588"></a>00588         ++<a class="code" href="classLSQUnit.html#af5c24658bed91065bf7d69d27ba9fbd6">lsqRescheduledLoads</a>;
<a name="l00589"></a>00589         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Uncachable load [sn:%lli] PC %s\n&quot;</span>,
<a name="l00590"></a>00590                 load_inst-&gt;seqNum, load_inst-&gt;pcState());
<a name="l00591"></a>00591 
<a name="l00592"></a>00592         <span class="comment">// Must delete request now that it wasn&apos;t handed off to</span>
<a name="l00593"></a>00593         <span class="comment">// memory.  This is quite ugly.  @todo: Figure out the proper</span>
<a name="l00594"></a>00594         <span class="comment">// place to really handle request deletes.</span>
<a name="l00595"></a>00595         <span class="keyword">delete</span> req;
<a name="l00596"></a>00596         <span class="keywordflow">if</span> (<a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a> &amp;&amp; sreqLow) {
<a name="l00597"></a>00597             <span class="keyword">delete</span> sreqLow;
<a name="l00598"></a>00598             <span class="keyword">delete</span> sreqHigh;
<a name="l00599"></a>00599         }
<a name="l00600"></a>00600         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="namespaceGenericISA.html#a3427cc78f489a7ee730b871fcb4c1960">GenericISA::M5PanicFault</a>(
<a name="l00601"></a>00601                 <span class="stringliteral">&quot;Uncachable load [sn:%llx] PC %s\n&quot;</span>,
<a name="l00602"></a>00602                 load_inst-&gt;seqNum, load_inst-&gt;pcState());
<a name="l00603"></a>00603     }
<a name="l00604"></a>00604 
<a name="l00605"></a>00605     <span class="comment">// Check the SQ for any previous stores that might lead to forwarding</span>
<a name="l00606"></a>00606     <span class="keywordtype">int</span> store_idx = load_inst-&gt;sqIdx;
<a name="l00607"></a>00607 
<a name="l00608"></a>00608     <span class="keywordtype">int</span> store_size = 0;
<a name="l00609"></a>00609 
<a name="l00610"></a>00610     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Read called, load idx: %i, store idx: %i, &quot;</span>
<a name="l00611"></a>00611             <span class="stringliteral">&quot;storeHead: %i addr: %#x%s\n&quot;</span>,
<a name="l00612"></a>00612             load_idx, store_idx, <a class="code" href="classLSQUnit.html#a6e87b6f77102183080ea6ab8599b26a9">storeHead</a>, req-&gt;getPaddr(),
<a name="l00613"></a>00613             sreqLow ? <span class="stringliteral">&quot; split&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);
<a name="l00614"></a>00614 
<a name="l00615"></a>00615     <span class="keywordflow">if</span> (req-&gt;isLLSC()) {
<a name="l00616"></a>00616         assert(!sreqLow);
<a name="l00617"></a>00617         <span class="comment">// Disable recording the result temporarily.  Writing to misc</span>
<a name="l00618"></a>00618         <span class="comment">// regs normally updates the result, but this is not the</span>
<a name="l00619"></a>00619         <span class="comment">// desired behavior when handling store conditionals.</span>
<a name="l00620"></a>00620         load_inst-&gt;recordResult(<span class="keyword">false</span>);
<a name="l00621"></a>00621         <a class="code" href="namespaceAlphaISA.html#a00333a272d42606a01cc33c81999a58b">TheISA::handleLockedRead</a>(load_inst.get(), req);
<a name="l00622"></a>00622         load_inst-&gt;recordResult(<span class="keyword">true</span>);
<a name="l00623"></a>00623     }
<a name="l00624"></a>00624 
<a name="l00625"></a>00625     <span class="keywordflow">if</span> (req-&gt;isMmappedIpr()) {
<a name="l00626"></a>00626         assert(!load_inst-&gt;memData);
<a name="l00627"></a>00627         load_inst-&gt;memData = <span class="keyword">new</span> uint8_t[64];
<a name="l00628"></a>00628 
<a name="l00629"></a>00629         <a class="code" href="classThreadContext.html">ThreadContext</a> *thread = <a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;tcBase(<a class="code" href="classLSQUnit.html#a0ee490ba978f48fbf2579acc7eb60b24">lsqID</a>);
<a name="l00630"></a>00630         <a class="code" href="classCycles.html">Cycles</a> delay(0);
<a name="l00631"></a>00631         <a class="code" href="classPacket.html">PacketPtr</a> data_pkt = <span class="keyword">new</span> <a class="code" href="classPacket.html">Packet</a>(req, <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a96120c772a9cb695fe62ca81ec93a53b">MemCmd::ReadReq</a>);
<a name="l00632"></a>00632 
<a name="l00633"></a>00633         <span class="keywordflow">if</span> (!<a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a> || !sreqLow) {
<a name="l00634"></a>00634             data_pkt-&gt;<a class="code" href="classPacket.html#a60621b00d6ecd49b3e336087aca2eda0">dataStatic</a>(load_inst-&gt;memData);
<a name="l00635"></a>00635             delay = <a class="code" href="namespaceGenericISA.html#a0b95fcdc1e1fe57dbb4fcad449a6efd8">TheISA::handleIprRead</a>(thread, data_pkt);
<a name="l00636"></a>00636         } <span class="keywordflow">else</span> {
<a name="l00637"></a>00637             assert(sreqLow-&gt;<a class="code" href="classRequest.html#aad621c262e009350dd86ad5715c50f7a">isMmappedIpr</a>() &amp;&amp; sreqHigh-&gt;<a class="code" href="classRequest.html#aad621c262e009350dd86ad5715c50f7a">isMmappedIpr</a>());
<a name="l00638"></a>00638             <a class="code" href="classPacket.html">PacketPtr</a> fst_data_pkt = <span class="keyword">new</span> <a class="code" href="classPacket.html">Packet</a>(sreqLow, <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a96120c772a9cb695fe62ca81ec93a53b">MemCmd::ReadReq</a>);
<a name="l00639"></a>00639             <a class="code" href="classPacket.html">PacketPtr</a> snd_data_pkt = <span class="keyword">new</span> <a class="code" href="classPacket.html">Packet</a>(sreqHigh, <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a96120c772a9cb695fe62ca81ec93a53b">MemCmd::ReadReq</a>);
<a name="l00640"></a>00640 
<a name="l00641"></a>00641             fst_data_pkt-&gt;dataStatic(load_inst-&gt;memData);
<a name="l00642"></a>00642             snd_data_pkt-&gt;<a class="code" href="classPacket.html#a60621b00d6ecd49b3e336087aca2eda0">dataStatic</a>(load_inst-&gt;memData + sreqLow-&gt;<a class="code" href="classRequest.html#a3c4029b904a61a9873e6d12785ce19a1">getSize</a>());
<a name="l00643"></a>00643 
<a name="l00644"></a>00644             delay = <a class="code" href="namespaceGenericISA.html#a0b95fcdc1e1fe57dbb4fcad449a6efd8">TheISA::handleIprRead</a>(thread, fst_data_pkt);
<a name="l00645"></a>00645             <a class="code" href="classCycles.html">Cycles</a> delay2 = <a class="code" href="namespaceGenericISA.html#a0b95fcdc1e1fe57dbb4fcad449a6efd8">TheISA::handleIprRead</a>(thread, snd_data_pkt);
<a name="l00646"></a>00646             <span class="keywordflow">if</span> (delay2 &gt; delay)
<a name="l00647"></a>00647                 delay = delay2;
<a name="l00648"></a>00648 
<a name="l00649"></a>00649             <span class="keyword">delete</span> sreqLow;
<a name="l00650"></a>00650             <span class="keyword">delete</span> sreqHigh;
<a name="l00651"></a>00651             <span class="keyword">delete</span> fst_data_pkt;
<a name="l00652"></a>00652             <span class="keyword">delete</span> snd_data_pkt;
<a name="l00653"></a>00653         }
<a name="l00654"></a>00654         WritebackEvent *wb = <span class="keyword">new</span> WritebackEvent(load_inst, data_pkt, <span class="keyword">this</span>);
<a name="l00655"></a>00655         <a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;schedule(wb, <a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;clockEdge(delay));
<a name="l00656"></a>00656         <span class="keywordflow">return</span> <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>;
<a name="l00657"></a>00657     }
<a name="l00658"></a>00658 
<a name="l00659"></a>00659     <span class="keywordflow">while</span> (store_idx != -1) {
<a name="l00660"></a>00660         <span class="comment">// End once we&apos;ve reached the top of the LSQ</span>
<a name="l00661"></a>00661         <span class="keywordflow">if</span> (store_idx == <a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>) {
<a name="l00662"></a>00662             <span class="keywordflow">break</span>;
<a name="l00663"></a>00663         }
<a name="l00664"></a>00664 
<a name="l00665"></a>00665         <span class="comment">// Move the index to one younger</span>
<a name="l00666"></a>00666         <span class="keywordflow">if</span> (--store_idx &lt; 0)
<a name="l00667"></a>00667             store_idx += <a class="code" href="classLSQUnit.html#a38c8af5392da70119dc5cce4e3637cbc">SQEntries</a>;
<a name="l00668"></a>00668 
<a name="l00669"></a>00669         assert(<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst);
<a name="l00670"></a>00670 
<a name="l00671"></a>00671         store_size = <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].size;
<a name="l00672"></a>00672 
<a name="l00673"></a>00673         <span class="keywordflow">if</span> (store_size == 0)
<a name="l00674"></a>00674             <span class="keywordflow">continue</span>;
<a name="l00675"></a>00675         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;uncacheable())
<a name="l00676"></a>00676             <span class="keywordflow">continue</span>;
<a name="l00677"></a>00677 
<a name="l00678"></a>00678         assert(<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;effAddrValid());
<a name="l00679"></a>00679 
<a name="l00680"></a>00680         <span class="comment">// Check if the store data is within the lower and upper bounds of</span>
<a name="l00681"></a>00681         <span class="comment">// addresses that the request needs.</span>
<a name="l00682"></a>00682         <span class="keywordtype">bool</span> store_has_lower_limit =
<a name="l00683"></a>00683             req-&gt;getVaddr() &gt;= <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;effAddr;
<a name="l00684"></a>00684         <span class="keywordtype">bool</span> store_has_upper_limit =
<a name="l00685"></a>00685             (req-&gt;getVaddr() + req-&gt;getSize()) &lt;=
<a name="l00686"></a>00686             (<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;effAddr + store_size);
<a name="l00687"></a>00687         <span class="keywordtype">bool</span> lower_load_has_store_part =
<a name="l00688"></a>00688             req-&gt;getVaddr() &lt; (<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;effAddr +
<a name="l00689"></a>00689                            store_size);
<a name="l00690"></a>00690         <span class="keywordtype">bool</span> upper_load_has_store_part =
<a name="l00691"></a>00691             (req-&gt;getVaddr() + req-&gt;getSize()) &gt;
<a name="l00692"></a>00692             <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;effAddr;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694         <span class="comment">// If the store&apos;s data has all of the data needed, we can forward.</span>
<a name="l00695"></a>00695         if ((store_has_lower_limit &amp;&amp; store_has_upper_limit)) {
<a name="l00696"></a>00696             <span class="comment">// Get shift amount for offset into the store&apos;s data.</span>
<a name="l00697"></a>00697             <span class="keywordtype">int</span> shift_amt = req-&gt;getVaddr() - <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;effAddr;
<a name="l00698"></a>00698 
<a name="l00699"></a>00699 
<a name="l00700"></a>00700             <span class="comment">//copy data</span>
<a name="l00701"></a>00701             <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].isAllZeros)
<a name="l00702"></a>00702                 memset(data, 0, req-&gt;getSize());
<a name="l00703"></a>00703             <span class="keywordflow">else</span>
<a name="l00704"></a>00704                 memcpy(data, <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].data + shift_amt,
<a name="l00705"></a>00705                    req-&gt;getSize());
<a name="l00706"></a>00706 
<a name="l00707"></a>00707             assert(!load_inst-&gt;memData);
<a name="l00708"></a>00708             load_inst-&gt;memData = <span class="keyword">new</span> uint8_t[req-&gt;getSize()];
<a name="l00709"></a>00709             <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].isAllZeros)
<a name="l00710"></a>00710                 memset(load_inst-&gt;memData, 0, req-&gt;getSize());
<a name="l00711"></a>00711             <span class="keywordflow">else</span>
<a name="l00712"></a>00712                 memcpy(load_inst-&gt;memData,
<a name="l00713"></a>00713                     <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].data + shift_amt, req-&gt;getSize());
<a name="l00714"></a>00714 
<a name="l00715"></a>00715             <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Forwarding from store idx %i to load to &quot;</span>
<a name="l00716"></a>00716                     <span class="stringliteral">&quot;addr %#x\n&quot;</span>, store_idx, req-&gt;getVaddr());
<a name="l00717"></a>00717 
<a name="l00718"></a>00718             <a class="code" href="classPacket.html">PacketPtr</a> data_pkt = <span class="keyword">new</span> <a class="code" href="classPacket.html">Packet</a>(req, <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a96120c772a9cb695fe62ca81ec93a53b">MemCmd::ReadReq</a>);
<a name="l00719"></a>00719             data_pkt-&gt;dataStatic(load_inst-&gt;memData);
<a name="l00720"></a>00720 
<a name="l00721"></a>00721             WritebackEvent *wb = <span class="keyword">new</span> WritebackEvent(load_inst, data_pkt, <span class="keyword">this</span>);
<a name="l00722"></a>00722 
<a name="l00723"></a>00723             <span class="comment">// We&apos;ll say this has a 1 cycle load-store forwarding latency</span>
<a name="l00724"></a>00724             <span class="comment">// for now.</span>
<a name="l00725"></a>00725             <span class="comment">// @todo: Need to make this a parameter.</span>
<a name="l00726"></a>00726             <a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;schedule(wb, <a class="code" href="statistics_8hh.html#a7acdccbf0d35ce0c159c0cdd36371b22" title="The universal simulation clock.">curTick</a>());
<a name="l00727"></a>00727 
<a name="l00728"></a>00728             <span class="comment">// Don&apos;t need to do anything special for split loads.</span>
<a name="l00729"></a>00729             <span class="keywordflow">if</span> (<a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a> &amp;&amp; sreqLow) {
<a name="l00730"></a>00730                 <span class="keyword">delete</span> sreqLow;
<a name="l00731"></a>00731                 <span class="keyword">delete</span> sreqHigh;
<a name="l00732"></a>00732             }
<a name="l00733"></a>00733 
<a name="l00734"></a>00734             ++<a class="code" href="classLSQUnit.html#a2adecfd8b85711a16f91e0fbd7ca8f10">lsqForwLoads</a>;
<a name="l00735"></a>00735             <span class="keywordflow">return</span> <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>;
<a name="l00736"></a>00736         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((store_has_lower_limit &amp;&amp; lower_load_has_store_part) ||
<a name="l00737"></a>00737                    (store_has_upper_limit &amp;&amp; upper_load_has_store_part) ||
<a name="l00738"></a>00738                    (lower_load_has_store_part &amp;&amp; upper_load_has_store_part)) {
<a name="l00739"></a>00739             <span class="comment">// This is the partial store-load forwarding case where a store</span>
<a name="l00740"></a>00740             <span class="comment">// has only part of the load&apos;s data.</span>
<a name="l00741"></a>00741 
<a name="l00742"></a>00742             <span class="comment">// If it&apos;s already been written back, then don&apos;t worry about</span>
<a name="l00743"></a>00743             <span class="comment">// stalling on it.</span>
<a name="l00744"></a>00744             <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].completed) {
<a name="l00745"></a>00745                 <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;Should not check one of these&quot;</span>);
<a name="l00746"></a>00746                 <span class="keywordflow">continue</span>;
<a name="l00747"></a>00747             }
<a name="l00748"></a>00748 
<a name="l00749"></a>00749             <span class="comment">// Must stall load and force it to retry, so long as it&apos;s the oldest</span>
<a name="l00750"></a>00750             <span class="comment">// load that needs to do so.</span>
<a name="l00751"></a>00751             <span class="keywordflow">if</span> (!<a class="code" href="classLSQUnit.html#a6f8bff553ad30865c7d0c62e05421eb8">stalled</a> ||
<a name="l00752"></a>00752                 (<a class="code" href="classLSQUnit.html#a6f8bff553ad30865c7d0c62e05421eb8">stalled</a> &amp;&amp;
<a name="l00753"></a>00753                  load_inst-&gt;seqNum &lt;
<a name="l00754"></a>00754                  <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[<a class="code" href="classLSQUnit.html#af55bc9000c8b4e4cfcfbd018feca12a7">stallingLoadIdx</a>]-&gt;seqNum)) {
<a name="l00755"></a>00755                 <a class="code" href="classLSQUnit.html#a6f8bff553ad30865c7d0c62e05421eb8">stalled</a> = <span class="keyword">true</span>;
<a name="l00756"></a>00756                 <a class="code" href="classLSQUnit.html#afe1cdcfca6b44c28581d862228adc3da">stallingStoreIsn</a> = <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;seqNum;
<a name="l00757"></a>00757                 stallingLoadIdx = load_idx;
<a name="l00758"></a>00758             }
<a name="l00759"></a>00759 
<a name="l00760"></a>00760             <span class="comment">// Tell IQ/mem dep unit that this instruction will need to be</span>
<a name="l00761"></a>00761             <span class="comment">// rescheduled eventually</span>
<a name="l00762"></a>00762             <a class="code" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a>-&gt;rescheduleMemInst(load_inst);
<a name="l00763"></a>00763             <a class="code" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a>-&gt;decrWb(load_inst-&gt;seqNum);
<a name="l00764"></a>00764             load_inst-&gt;clearIssued();
<a name="l00765"></a>00765             ++<a class="code" href="classLSQUnit.html#af5c24658bed91065bf7d69d27ba9fbd6">lsqRescheduledLoads</a>;
<a name="l00766"></a>00766 
<a name="l00767"></a>00767             <span class="comment">// Do not generate a writeback event as this instruction is not</span>
<a name="l00768"></a>00768             <span class="comment">// complete.</span>
<a name="l00769"></a>00769             <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Load-store forwarding mis-match. &quot;</span>
<a name="l00770"></a>00770                     <span class="stringliteral">&quot;Store idx %i to load addr %#x\n&quot;</span>,
<a name="l00771"></a>00771                     store_idx, req-&gt;getVaddr());
<a name="l00772"></a>00772 
<a name="l00773"></a>00773             <span class="comment">// Must delete request now that it wasn&apos;t handed off to</span>
<a name="l00774"></a>00774             <span class="comment">// memory.  This is quite ugly.  @todo: Figure out the</span>
<a name="l00775"></a>00775             <span class="comment">// proper place to really handle request deletes.</span>
<a name="l00776"></a>00776             <span class="keyword">delete</span> req;
<a name="l00777"></a>00777             <span class="keywordflow">if</span> (<a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a> &amp;&amp; sreqLow) {
<a name="l00778"></a>00778                 <span class="keyword">delete</span> sreqLow;
<a name="l00779"></a>00779                 <span class="keyword">delete</span> sreqHigh;
<a name="l00780"></a>00780             }
<a name="l00781"></a>00781 
<a name="l00782"></a>00782             <span class="keywordflow">return</span> <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>;
<a name="l00783"></a>00783         }
<a name="l00784"></a>00784     }
<a name="l00785"></a>00785 
<a name="l00786"></a>00786     <span class="comment">// If there&apos;s no forwarding case, then go access memory</span>
<a name="l00787"></a>00787     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Doing memory access for inst [sn:%lli] PC %s\n&quot;</span>,
<a name="l00788"></a>00788             load_inst-&gt;seqNum, load_inst-&gt;pcState());
<a name="l00789"></a>00789 
<a name="l00790"></a>00790     assert(!load_inst-&gt;memData);
<a name="l00791"></a>00791     load_inst-&gt;memData = <span class="keyword">new</span> uint8_t[req-&gt;getSize()];
<a name="l00792"></a>00792 
<a name="l00793"></a>00793     ++<a class="code" href="classLSQUnit.html#a03435d626b7567ed154de5d7d8c3d419">usedPorts</a>;
<a name="l00794"></a>00794 
<a name="l00795"></a>00795     <span class="comment">// if we the cache is not blocked, do cache access</span>
<a name="l00796"></a>00796     <span class="keywordtype">bool</span> completedFirst = <span class="keyword">false</span>;
<a name="l00797"></a>00797     <span class="keywordflow">if</span> (!<a class="code" href="classLSQUnit.html#ac0894e8141823f8eea2c9041bac9dab4">lsq</a>-&gt;<a class="code" href="classLSQ.html#a050e3736ea48bf74bd0c216b1cd3f494">cacheBlocked</a>()) {
<a name="l00798"></a>00798         <a class="code" href="classMemCmd.html">MemCmd</a> command =
<a name="l00799"></a>00799             req-&gt;isLLSC() ? <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a1c703221ee751b9d3d635fe33ea8e350">MemCmd::LoadLockedReq</a> : <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a96120c772a9cb695fe62ca81ec93a53b">MemCmd::ReadReq</a>;
<a name="l00800"></a>00800         <a class="code" href="classPacket.html">PacketPtr</a> data_pkt = <span class="keyword">new</span> <a class="code" href="classPacket.html">Packet</a>(req, command);
<a name="l00801"></a>00801         <a class="code" href="classPacket.html">PacketPtr</a> fst_data_pkt = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00802"></a>00802         <a class="code" href="classPacket.html">PacketPtr</a> snd_data_pkt = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00803"></a>00803 
<a name="l00804"></a>00804         data_pkt-&gt;<a class="code" href="classPacket.html#a60621b00d6ecd49b3e336087aca2eda0">dataStatic</a>(load_inst-&gt;memData);
<a name="l00805"></a>00805 
<a name="l00806"></a>00806         LSQSenderState *state = <span class="keyword">new</span> LSQSenderState;
<a name="l00807"></a>00807         state-&gt;isLoad = <span class="keyword">true</span>;
<a name="l00808"></a>00808         state-&gt;idx = load_idx;
<a name="l00809"></a>00809         state-&gt;inst = load_inst;
<a name="l00810"></a>00810         data_pkt-&gt;<a class="code" href="classPacket.html#a983ade0479f946c813284dcc65073367">senderState</a> = state;
<a name="l00811"></a>00811 
<a name="l00812"></a>00812         <span class="keywordflow">if</span> (!<a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a> || !sreqLow) {
<a name="l00813"></a>00813 
<a name="l00814"></a>00814             <span class="comment">// Point the first packet at the main data packet.</span>
<a name="l00815"></a>00815             fst_data_pkt = data_pkt;
<a name="l00816"></a>00816         } <span class="keywordflow">else</span> {
<a name="l00817"></a>00817 
<a name="l00818"></a>00818             <span class="comment">// Create the split packets.</span>
<a name="l00819"></a>00819             fst_data_pkt = <span class="keyword">new</span> <a class="code" href="classPacket.html">Packet</a>(sreqLow, command);
<a name="l00820"></a>00820             snd_data_pkt = <span class="keyword">new</span> <a class="code" href="classPacket.html">Packet</a>(sreqHigh, command);
<a name="l00821"></a>00821 
<a name="l00822"></a>00822             fst_data_pkt-&gt;<a class="code" href="classPacket.html#a60621b00d6ecd49b3e336087aca2eda0">dataStatic</a>(load_inst-&gt;memData);
<a name="l00823"></a>00823             snd_data_pkt-&gt;<a class="code" href="classPacket.html#a60621b00d6ecd49b3e336087aca2eda0">dataStatic</a>(load_inst-&gt;memData + sreqLow-&gt;<a class="code" href="classRequest.html#a3c4029b904a61a9873e6d12785ce19a1">getSize</a>());
<a name="l00824"></a>00824 
<a name="l00825"></a>00825             fst_data_pkt-&gt;<a class="code" href="classPacket.html#a983ade0479f946c813284dcc65073367">senderState</a> = state;
<a name="l00826"></a>00826             snd_data_pkt-&gt;<a class="code" href="classPacket.html#a983ade0479f946c813284dcc65073367">senderState</a> = state;
<a name="l00827"></a>00827 
<a name="l00828"></a>00828             state-&gt;isSplit = <span class="keyword">true</span>;
<a name="l00829"></a>00829             state-&gt;outstanding = 2;
<a name="l00830"></a>00830             state-&gt;mainPkt = data_pkt;
<a name="l00831"></a>00831         }
<a name="l00832"></a>00832 
<a name="l00833"></a>00833         <span class="keywordflow">if</span> (!<a class="code" href="classLSQUnit.html#a2bbddd281625b8b4d716708925673445">dcachePort</a>-&gt;<a class="code" href="classMasterPort.html#aafaf979005392447714384794f1a8610">sendTimingReq</a>(fst_data_pkt)) {
<a name="l00834"></a>00834             <span class="comment">// Delete state and data packet because a load retry</span>
<a name="l00835"></a>00835             <span class="comment">// initiates a pipeline restart; it does not retry.</span>
<a name="l00836"></a>00836             <span class="keyword">delete</span> state;
<a name="l00837"></a>00837             <span class="keyword">delete</span> data_pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>;
<a name="l00838"></a>00838             <span class="keyword">delete</span> data_pkt;
<a name="l00839"></a>00839             <span class="keywordflow">if</span> (<a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a> &amp;&amp; sreqLow) {
<a name="l00840"></a>00840                 <span class="keyword">delete</span> fst_data_pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>;
<a name="l00841"></a>00841                 <span class="keyword">delete</span> fst_data_pkt;
<a name="l00842"></a>00842                 <span class="keyword">delete</span> snd_data_pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>;
<a name="l00843"></a>00843                 <span class="keyword">delete</span> snd_data_pkt;
<a name="l00844"></a>00844                 sreqLow = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00845"></a>00845                 sreqHigh = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00846"></a>00846             }
<a name="l00847"></a>00847 
<a name="l00848"></a>00848             req = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00849"></a>00849 
<a name="l00850"></a>00850             <span class="comment">// If the access didn&apos;t succeed, tell the LSQ by setting</span>
<a name="l00851"></a>00851             <span class="comment">// the retry thread id.</span>
<a name="l00852"></a>00852             <a class="code" href="classLSQUnit.html#ac0894e8141823f8eea2c9041bac9dab4">lsq</a>-&gt;<a class="code" href="classLSQ.html#aca00d390ba2ada0daf6e0c0a7cf75f57">setRetryTid</a>(<a class="code" href="classLSQUnit.html#a0ee490ba978f48fbf2579acc7eb60b24">lsqID</a>);
<a name="l00853"></a>00853         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a> &amp;&amp; sreqLow) {
<a name="l00854"></a>00854             completedFirst = <span class="keyword">true</span>;
<a name="l00855"></a>00855 
<a name="l00856"></a>00856             <span class="comment">// The first packet was sent without problems, so send this one</span>
<a name="l00857"></a>00857             <span class="comment">// too. If there is a problem with this packet then the whole</span>
<a name="l00858"></a>00858             <span class="comment">// load will be squashed, so indicate this to the state object.</span>
<a name="l00859"></a>00859             <span class="comment">// The first packet will return in completeDataAccess and be</span>
<a name="l00860"></a>00860             <span class="comment">// handled there.</span>
<a name="l00861"></a>00861             ++<a class="code" href="classLSQUnit.html#a03435d626b7567ed154de5d7d8c3d419">usedPorts</a>;
<a name="l00862"></a>00862             <span class="keywordflow">if</span> (!<a class="code" href="classLSQUnit.html#a2bbddd281625b8b4d716708925673445">dcachePort</a>-&gt;<a class="code" href="classMasterPort.html#aafaf979005392447714384794f1a8610">sendTimingReq</a>(snd_data_pkt)) {
<a name="l00863"></a>00863 
<a name="l00864"></a>00864                 <span class="comment">// The main packet will be deleted in completeDataAccess.</span>
<a name="l00865"></a>00865                 <span class="keyword">delete</span> snd_data_pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>;
<a name="l00866"></a>00866                 <span class="keyword">delete</span> snd_data_pkt;
<a name="l00867"></a>00867 
<a name="l00868"></a>00868                 state-&gt;complete();
<a name="l00869"></a>00869 
<a name="l00870"></a>00870                 req = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00871"></a>00871                 sreqHigh = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00872"></a>00872 
<a name="l00873"></a>00873                 <a class="code" href="classLSQUnit.html#ac0894e8141823f8eea2c9041bac9dab4">lsq</a>-&gt;<a class="code" href="classLSQ.html#aca00d390ba2ada0daf6e0c0a7cf75f57">setRetryTid</a>(<a class="code" href="classLSQUnit.html#a0ee490ba978f48fbf2579acc7eb60b24">lsqID</a>);
<a name="l00874"></a>00874             }
<a name="l00875"></a>00875         }
<a name="l00876"></a>00876     }
<a name="l00877"></a>00877 
<a name="l00878"></a>00878     <span class="comment">// If the cache was blocked, or has become blocked due to the access,</span>
<a name="l00879"></a>00879     <span class="comment">// handle it.</span>
<a name="l00880"></a>00880     <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#ac0894e8141823f8eea2c9041bac9dab4">lsq</a>-&gt;<a class="code" href="classLSQ.html#a050e3736ea48bf74bd0c216b1cd3f494">cacheBlocked</a>()) {
<a name="l00881"></a>00881         <span class="keywordflow">if</span> (req)
<a name="l00882"></a>00882             <span class="keyword">delete</span> req;
<a name="l00883"></a>00883         <span class="keywordflow">if</span> (<a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a> &amp;&amp; sreqLow &amp;&amp; !completedFirst) {
<a name="l00884"></a>00884             <span class="keyword">delete</span> sreqLow;
<a name="l00885"></a>00885             <span class="keyword">delete</span> sreqHigh;
<a name="l00886"></a>00886         }
<a name="l00887"></a>00887 
<a name="l00888"></a>00888         ++<a class="code" href="classLSQUnit.html#a33a1cca2455a3e5909f462a778902643">lsqCacheBlocked</a>;
<a name="l00889"></a>00889 
<a name="l00890"></a>00890         <span class="comment">// If the first part of a split access succeeds, then let the LSQ</span>
<a name="l00891"></a>00891         <span class="comment">// handle the decrWb when completeDataAccess is called upon return</span>
<a name="l00892"></a>00892         <span class="comment">// of the requested first part of data</span>
<a name="l00893"></a>00893         <span class="keywordflow">if</span> (!completedFirst)
<a name="l00894"></a>00894             <a class="code" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a>-&gt;decrWb(load_inst-&gt;seqNum);
<a name="l00895"></a>00895 
<a name="l00896"></a>00896         <span class="comment">// There&apos;s an older load that&apos;s already going to squash.</span>
<a name="l00897"></a>00897         <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a95dc31b4ce3ebcb6b9d75a510b3a128c">isLoadBlocked</a> &amp;&amp; blockedLoadSeqNum &lt; load_inst-&gt;seqNum)
<a name="l00898"></a>00898             <span class="keywordflow">return</span> <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>;
<a name="l00899"></a>00899 
<a name="l00900"></a>00900         <span class="comment">// Record that the load was blocked due to memory.  This</span>
<a name="l00901"></a>00901         <span class="comment">// load will squash all instructions after it, be</span>
<a name="l00902"></a>00902         <span class="comment">// refetched, and re-executed.</span>
<a name="l00903"></a>00903         <a class="code" href="classLSQUnit.html#a95dc31b4ce3ebcb6b9d75a510b3a128c">isLoadBlocked</a> = <span class="keyword">true</span>;
<a name="l00904"></a>00904         <a class="code" href="classLSQUnit.html#a2c1620029c162c7180e523b089e56ed5">loadBlockedHandled</a> = <span class="keyword">false</span>;
<a name="l00905"></a>00905         <a class="code" href="classLSQUnit.html#a3fca34b247fd8d081557578f8ca60fe3">blockedLoadSeqNum</a> = load_inst-&gt;seqNum;
<a name="l00906"></a>00906         <span class="comment">// No fault occurred, even though the interface is blocked.</span>
<a name="l00907"></a>00907         <span class="keywordflow">return</span> <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>;
<a name="l00908"></a>00908     }
<a name="l00909"></a>00909 
<a name="l00910"></a>00910     <span class="keywordflow">return</span> <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>;
<a name="l00911"></a>00911 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a29cb5a4f98063ce6e9210eacbdb35298"></a><!-- doxytag: member="LSQUnit::recvRetry" ref="a29cb5a4f98063ce6e9210eacbdb35298" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void recvRetry </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handles doing the retry. </p>

<p><div class="fragment"><pre class="fragment"><a name="l01227"></a>01227 {
<a name="l01228"></a>01228     <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a89d931c74b63e0b0e7ad856fe9525ff6">isStoreBlocked</a>) {
<a name="l01229"></a>01229         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Receiving retry: store blocked\n&quot;</span>);
<a name="l01230"></a>01230         assert(<a class="code" href="classLSQUnit.html#a314ae93c04b3ca96e79e1b1f39a8e478">retryPkt</a> != <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>);
<a name="l01231"></a>01231 
<a name="l01232"></a>01232         LSQSenderState *state =
<a name="l01233"></a>01233             <span class="keyword">dynamic_cast&lt;</span>LSQSenderState *<span class="keyword">&gt;</span>(<a class="code" href="classLSQUnit.html#a314ae93c04b3ca96e79e1b1f39a8e478">retryPkt</a>-&gt;<a class="code" href="classPacket.html#a983ade0479f946c813284dcc65073367">senderState</a>);
<a name="l01234"></a>01234 
<a name="l01235"></a>01235         <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a2bbddd281625b8b4d716708925673445">dcachePort</a>-&gt;<a class="code" href="classMasterPort.html#aafaf979005392447714384794f1a8610">sendTimingReq</a>(<a class="code" href="classLSQUnit.html#a314ae93c04b3ca96e79e1b1f39a8e478">retryPkt</a>)) {
<a name="l01236"></a>01236             <span class="comment">// Don&apos;t finish the store unless this is the last packet.</span>
<a name="l01237"></a>01237             <span class="keywordflow">if</span> (!<a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a> || !state-&gt;pktToSend ||
<a name="l01238"></a>01238                     state-&gt;pendingPacket == <a class="code" href="classLSQUnit.html#a314ae93c04b3ca96e79e1b1f39a8e478">retryPkt</a>) {
<a name="l01239"></a>01239                 state-&gt;pktToSend = <span class="keyword">false</span>;
<a name="l01240"></a>01240                 <a class="code" href="classLSQUnit.html#a6f23a0d213e7d35f445f9cabfd2ed0cc">storePostSend</a>(<a class="code" href="classLSQUnit.html#a314ae93c04b3ca96e79e1b1f39a8e478">retryPkt</a>);
<a name="l01241"></a>01241             }
<a name="l01242"></a>01242             <a class="code" href="classLSQUnit.html#a314ae93c04b3ca96e79e1b1f39a8e478">retryPkt</a> = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l01243"></a>01243             <a class="code" href="classLSQUnit.html#a89d931c74b63e0b0e7ad856fe9525ff6">isStoreBlocked</a> = <span class="keyword">false</span>;
<a name="l01244"></a>01244             <a class="code" href="classLSQUnit.html#ac0894e8141823f8eea2c9041bac9dab4">lsq</a>-&gt;<a class="code" href="classLSQ.html#aca00d390ba2ada0daf6e0c0a7cf75f57">setRetryTid</a>(<a class="code" href="base_2types_8hh.html#a192b210a26f038691d0f095d85dc0953">InvalidThreadID</a>);
<a name="l01245"></a>01245 
<a name="l01246"></a>01246             <span class="comment">// Send any outstanding packet.</span>
<a name="l01247"></a>01247             <span class="keywordflow">if</span> (<a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a> &amp;&amp; state-&gt;pktToSend) {
<a name="l01248"></a>01248                 assert(state-&gt;pendingPacket);
<a name="l01249"></a>01249                 <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a268a51a93dbdda9a0cff48ba036e673e">sendStore</a>(state-&gt;pendingPacket)) {
<a name="l01250"></a>01250                     <a class="code" href="classLSQUnit.html#a6f23a0d213e7d35f445f9cabfd2ed0cc">storePostSend</a>(state-&gt;pendingPacket);
<a name="l01251"></a>01251                 }
<a name="l01252"></a>01252             }
<a name="l01253"></a>01253         } <span class="keywordflow">else</span> {
<a name="l01254"></a>01254             <span class="comment">// Still blocked!</span>
<a name="l01255"></a>01255             ++<a class="code" href="classLSQUnit.html#a33a1cca2455a3e5909f462a778902643">lsqCacheBlocked</a>;
<a name="l01256"></a>01256             <a class="code" href="classLSQUnit.html#ac0894e8141823f8eea2c9041bac9dab4">lsq</a>-&gt;<a class="code" href="classLSQ.html#aca00d390ba2ada0daf6e0c0a7cf75f57">setRetryTid</a>(<a class="code" href="classLSQUnit.html#a0ee490ba978f48fbf2579acc7eb60b24">lsqID</a>);
<a name="l01257"></a>01257         }
<a name="l01258"></a>01258     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a95dc31b4ce3ebcb6b9d75a510b3a128c">isLoadBlocked</a>) {
<a name="l01259"></a>01259         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Loads squash themselves and all younger insts, &quot;</span>
<a name="l01260"></a>01260                 <span class="stringliteral">&quot;no need to resend packet.\n&quot;</span>);
<a name="l01261"></a>01261     } <span class="keywordflow">else</span> {
<a name="l01262"></a>01262         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Retry received but LSQ is no longer blocked.\n&quot;</span>);
<a name="l01263"></a>01263     }
<a name="l01264"></a>01264 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4dc637449366fcdfc4e764cdf12d9b11"></a><!-- doxytag: member="LSQUnit::regStats" ref="a4dc637449366fcdfc4e764cdf12d9b11" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regStats </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Registers statistics. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00222"></a>00222 {
<a name="l00223"></a>00223     <a class="code" href="classLSQUnit.html#a2adecfd8b85711a16f91e0fbd7ca8f10">lsqForwLoads</a>
<a name="l00224"></a>00224         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="classLSQUnit.html#a37627d5d5bba7f4a8690c71c2ab3cb07">name</a>() + <span class="stringliteral">&quot;.forwLoads&quot;</span>)
<a name="l00225"></a>00225         .desc(<span class="stringliteral">&quot;Number of loads that had data forwarded from stores&quot;</span>);
<a name="l00226"></a>00226 
<a name="l00227"></a>00227     <a class="code" href="classLSQUnit.html#ab1c6fb6e4b6c6a243412e594629105ea">invAddrLoads</a>
<a name="l00228"></a>00228         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="classLSQUnit.html#a37627d5d5bba7f4a8690c71c2ab3cb07">name</a>() + <span class="stringliteral">&quot;.invAddrLoads&quot;</span>)
<a name="l00229"></a>00229         .desc(<span class="stringliteral">&quot;Number of loads ignored due to an invalid address&quot;</span>);
<a name="l00230"></a>00230 
<a name="l00231"></a>00231     <a class="code" href="classLSQUnit.html#a737697c5df3fbe8e728541fec8220089">lsqSquashedLoads</a>
<a name="l00232"></a>00232         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="classLSQUnit.html#a37627d5d5bba7f4a8690c71c2ab3cb07">name</a>() + <span class="stringliteral">&quot;.squashedLoads&quot;</span>)
<a name="l00233"></a>00233         .desc(<span class="stringliteral">&quot;Number of loads squashed&quot;</span>);
<a name="l00234"></a>00234 
<a name="l00235"></a>00235     <a class="code" href="classLSQUnit.html#ad620ac240b0d631c3a8aa19cfd05ad41">lsqIgnoredResponses</a>
<a name="l00236"></a>00236         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="classLSQUnit.html#a37627d5d5bba7f4a8690c71c2ab3cb07">name</a>() + <span class="stringliteral">&quot;.ignoredResponses&quot;</span>)
<a name="l00237"></a>00237         .desc(<span class="stringliteral">&quot;Number of memory responses ignored because the instruction is squashed&quot;</span>);
<a name="l00238"></a>00238 
<a name="l00239"></a>00239     <a class="code" href="classLSQUnit.html#ac499fc2b461e03a110deae7c695f75bc">lsqMemOrderViolation</a>
<a name="l00240"></a>00240         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="classLSQUnit.html#a37627d5d5bba7f4a8690c71c2ab3cb07">name</a>() + <span class="stringliteral">&quot;.memOrderViolation&quot;</span>)
<a name="l00241"></a>00241         .desc(<span class="stringliteral">&quot;Number of memory ordering violations&quot;</span>);
<a name="l00242"></a>00242 
<a name="l00243"></a>00243     <a class="code" href="classLSQUnit.html#a0abe80f8caefb71a0351c3bed4d99c0e">lsqSquashedStores</a>
<a name="l00244"></a>00244         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="classLSQUnit.html#a37627d5d5bba7f4a8690c71c2ab3cb07">name</a>() + <span class="stringliteral">&quot;.squashedStores&quot;</span>)
<a name="l00245"></a>00245         .desc(<span class="stringliteral">&quot;Number of stores squashed&quot;</span>);
<a name="l00246"></a>00246 
<a name="l00247"></a>00247     <a class="code" href="classLSQUnit.html#a893e9b5b65df5710d85f6a583504a11c">invAddrSwpfs</a>
<a name="l00248"></a>00248         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="classLSQUnit.html#a37627d5d5bba7f4a8690c71c2ab3cb07">name</a>() + <span class="stringliteral">&quot;.invAddrSwpfs&quot;</span>)
<a name="l00249"></a>00249         .desc(<span class="stringliteral">&quot;Number of software prefetches ignored due to an invalid address&quot;</span>);
<a name="l00250"></a>00250 
<a name="l00251"></a>00251     <a class="code" href="classLSQUnit.html#a5323f1c2b6bf5cccc59253596656eb70">lsqBlockedLoads</a>
<a name="l00252"></a>00252         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="classLSQUnit.html#a37627d5d5bba7f4a8690c71c2ab3cb07">name</a>() + <span class="stringliteral">&quot;.blockedLoads&quot;</span>)
<a name="l00253"></a>00253         .desc(<span class="stringliteral">&quot;Number of blocked loads due to partial load-store forwarding&quot;</span>);
<a name="l00254"></a>00254 
<a name="l00255"></a>00255     <a class="code" href="classLSQUnit.html#af5c24658bed91065bf7d69d27ba9fbd6">lsqRescheduledLoads</a>
<a name="l00256"></a>00256         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="classLSQUnit.html#a37627d5d5bba7f4a8690c71c2ab3cb07">name</a>() + <span class="stringliteral">&quot;.rescheduledLoads&quot;</span>)
<a name="l00257"></a>00257         .desc(<span class="stringliteral">&quot;Number of loads that were rescheduled&quot;</span>);
<a name="l00258"></a>00258 
<a name="l00259"></a>00259     <a class="code" href="classLSQUnit.html#a33a1cca2455a3e5909f462a778902643">lsqCacheBlocked</a>
<a name="l00260"></a>00260         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="classLSQUnit.html#a37627d5d5bba7f4a8690c71c2ab3cb07">name</a>() + <span class="stringliteral">&quot;.cacheBlocked&quot;</span>)
<a name="l00261"></a>00261         .desc(<span class="stringliteral">&quot;Number of times an access to memory failed due to the cache being blocked&quot;</span>);
<a name="l00262"></a>00262 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a755ee993c2d4e9d422c37990b15afa37"></a><!-- doxytag: member="LSQUnit::resetState" ref="a755ee993c2d4e9d422c37990b15afa37" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void resetState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the <a class="el" href="classLSQ.html">LSQ</a> state </p>

<p><div class="fragment"><pre class="fragment"><a name="l00187"></a>00187 {
<a name="l00188"></a>00188     <a class="code" href="classLSQUnit.html#a867971f18e464abd16193e069c64a8ad">loads</a> = <a class="code" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a> = <a class="code" href="classLSQUnit.html#a3831a7965ffbe90df177026988476f9c">storesToWB</a> = 0;
<a name="l00189"></a>00189 
<a name="l00190"></a>00190     <a class="code" href="classLSQUnit.html#ac09af89928d2ef4da4cbdcfce26fa3f5">loadHead</a> = <a class="code" href="classLSQUnit.html#a973a489225da164cc85e690f13c86841">loadTail</a> = 0;
<a name="l00191"></a>00191 
<a name="l00192"></a>00192     <a class="code" href="classLSQUnit.html#a6e87b6f77102183080ea6ab8599b26a9">storeHead</a> = <a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a> = <a class="code" href="classLSQUnit.html#acd5c7fbb5578b5cb505ffff16bbf6a8b">storeTail</a> = 0;
<a name="l00193"></a>00193 
<a name="l00194"></a>00194     <a class="code" href="classLSQUnit.html#a03435d626b7567ed154de5d7d8c3d419">usedPorts</a> = 0;
<a name="l00195"></a>00195 
<a name="l00196"></a>00196     <a class="code" href="classLSQUnit.html#a314ae93c04b3ca96e79e1b1f39a8e478">retryPkt</a> = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00197"></a>00197     <a class="code" href="classLSQUnit.html#a270a20c3fa52139e0538288275db9d22">memDepViolator</a> = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00198"></a>00198 
<a name="l00199"></a>00199     <a class="code" href="classLSQUnit.html#a3fca34b247fd8d081557578f8ca60fe3">blockedLoadSeqNum</a> = 0;
<a name="l00200"></a>00200 
<a name="l00201"></a>00201     <a class="code" href="classLSQUnit.html#a6f8bff553ad30865c7d0c62e05421eb8">stalled</a> = <span class="keyword">false</span>;
<a name="l00202"></a>00202     <a class="code" href="classLSQUnit.html#a95dc31b4ce3ebcb6b9d75a510b3a128c">isLoadBlocked</a> = <span class="keyword">false</span>;
<a name="l00203"></a>00203     <a class="code" href="classLSQUnit.html#a2c1620029c162c7180e523b089e56ed5">loadBlockedHandled</a> = <span class="keyword">false</span>;
<a name="l00204"></a>00204 
<a name="l00205"></a>00205     <a class="code" href="classLSQUnit.html#af4264b12b32db39099b579e1ed670312">cacheBlockMask</a> = ~(<a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;cacheLineSize() - 1);
<a name="l00206"></a>00206 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3bc9500810cb2d5615e29206e2d6499f"></a><!-- doxytag: member="LSQUnit::resizeLQ" ref="a3bc9500810cb2d5615e29206e2d6499f" args="(unsigned size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void resizeLQ </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resizes the LQ to a given size. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00306"></a>00306 {
<a name="l00307"></a>00307     <span class="keywordtype">unsigned</span> size_plus_sentinel = size + 1;
<a name="l00308"></a>00308     assert(size_plus_sentinel &gt;= <a class="code" href="classLSQUnit.html#aafa99d800d574095881acbacdbbbcc47">LQEntries</a>);
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     <span class="keywordflow">if</span> (size_plus_sentinel &gt; <a class="code" href="classLSQUnit.html#aafa99d800d574095881acbacdbbbcc47">LQEntries</a>) {
<a name="l00311"></a>00311         <span class="keywordflow">while</span> (size_plus_sentinel &gt; <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>.size()) {
<a name="l00312"></a>00312             <a class="code" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> dummy;
<a name="l00313"></a>00313             <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>.push_back(dummy);
<a name="l00314"></a>00314             <a class="code" href="classLSQUnit.html#aafa99d800d574095881acbacdbbbcc47">LQEntries</a>++;
<a name="l00315"></a>00315         }
<a name="l00316"></a>00316     } <span class="keywordflow">else</span> {
<a name="l00317"></a>00317         <a class="code" href="classLSQUnit.html#aafa99d800d574095881acbacdbbbcc47">LQEntries</a> = size_plus_sentinel;
<a name="l00318"></a>00318     }
<a name="l00319"></a>00319 
<a name="l00320"></a>00320     assert(<a class="code" href="classLSQUnit.html#aafa99d800d574095881acbacdbbbcc47">LQEntries</a> &lt;= 256);
<a name="l00321"></a>00321 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a341dd6a3bd8d240659fd9d698c3b5c65"></a><!-- doxytag: member="LSQUnit::resizeSQ" ref="a341dd6a3bd8d240659fd9d698c3b5c65" args="(unsigned size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void resizeSQ </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resizes the SQ to a given size. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00326"></a>00326 {
<a name="l00327"></a>00327     <span class="keywordtype">unsigned</span> size_plus_sentinel = size + 1;
<a name="l00328"></a>00328     <span class="keywordflow">if</span> (size_plus_sentinel &gt; <a class="code" href="classLSQUnit.html#a38c8af5392da70119dc5cce4e3637cbc">SQEntries</a>) {
<a name="l00329"></a>00329         <span class="keywordflow">while</span> (size_plus_sentinel &gt; <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>.size()) {
<a name="l00330"></a>00330             SQEntry dummy;
<a name="l00331"></a>00331             <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>.push_back(dummy);
<a name="l00332"></a>00332             <a class="code" href="classLSQUnit.html#a38c8af5392da70119dc5cce4e3637cbc">SQEntries</a>++;
<a name="l00333"></a>00333         }
<a name="l00334"></a>00334     } <span class="keywordflow">else</span> {
<a name="l00335"></a>00335         <a class="code" href="classLSQUnit.html#a38c8af5392da70119dc5cce4e3637cbc">SQEntries</a> = size_plus_sentinel;
<a name="l00336"></a>00336     }
<a name="l00337"></a>00337 
<a name="l00338"></a>00338     assert(<a class="code" href="classLSQUnit.html#a38c8af5392da70119dc5cce4e3637cbc">SQEntries</a> &lt;= 256);
<a name="l00339"></a>00339 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a268a51a93dbdda9a0cff48ba036e673e"></a><!-- doxytag: member="LSQUnit::sendStore" ref="a268a51a93dbdda9a0cff48ba036e673e" args="(PacketPtr data_pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sendStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>data_pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Attempts to send a store to the cache. </p>

<p><div class="fragment"><pre class="fragment"><a name="l01211"></a>01211 {
<a name="l01212"></a>01212     <span class="keywordflow">if</span> (!<a class="code" href="classLSQUnit.html#a2bbddd281625b8b4d716708925673445">dcachePort</a>-&gt;<a class="code" href="classMasterPort.html#aafaf979005392447714384794f1a8610">sendTimingReq</a>(data_pkt)) {
<a name="l01213"></a>01213         <span class="comment">// Need to handle becoming blocked on a store.</span>
<a name="l01214"></a>01214         <a class="code" href="classLSQUnit.html#a89d931c74b63e0b0e7ad856fe9525ff6">isStoreBlocked</a> = <span class="keyword">true</span>;
<a name="l01215"></a>01215         ++<a class="code" href="classLSQUnit.html#a33a1cca2455a3e5909f462a778902643">lsqCacheBlocked</a>;
<a name="l01216"></a>01216         assert(<a class="code" href="classLSQUnit.html#a314ae93c04b3ca96e79e1b1f39a8e478">retryPkt</a> == <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>);
<a name="l01217"></a>01217         <a class="code" href="classLSQUnit.html#a314ae93c04b3ca96e79e1b1f39a8e478">retryPkt</a> = data_pkt;
<a name="l01218"></a>01218         <a class="code" href="classLSQUnit.html#ac0894e8141823f8eea2c9041bac9dab4">lsq</a>-&gt;<a class="code" href="classLSQ.html#aca00d390ba2ada0daf6e0c0a7cf75f57">setRetryTid</a>(<a class="code" href="classLSQUnit.html#a0ee490ba978f48fbf2579acc7eb60b24">lsqID</a>);
<a name="l01219"></a>01219         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01220"></a>01220     }
<a name="l01221"></a>01221     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01222"></a>01222 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8d77cc755c7a424f4eb80130fb627012"></a><!-- doxytag: member="LSQUnit::setDcachePort" ref="a8d77cc755c7a424f4eb80130fb627012" args="(MasterPort *dcache_port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setDcachePort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMasterPort.html">MasterPort</a> *&nbsp;</td>
          <td class="paramname"> <em>dcache_port</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the pointer to the dcache port. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00267"></a>00267 {
<a name="l00268"></a>00268     <a class="code" href="classLSQUnit.html#a2bbddd281625b8b4d716708925673445">dcachePort</a> = dcache_port;
<a name="l00269"></a>00269 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac8bfb1e163f7ba2261d702623226973d"></a><!-- doxytag: member="LSQUnit::setLoadBlockedHandled" ref="ac8bfb1e163f7ba2261d702623226973d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setLoadBlockedHandled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Records the blocked load as being handled. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00199"></a>00199     { <a class="code" href="classLSQUnit.html#a2c1620029c162c7180e523b089e56ed5">loadBlockedHandled</a> = <span class="keyword">true</span>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5761e9640bec8ba8474945cce57b6501"></a><!-- doxytag: member="LSQUnit::sqEmpty" ref="a5761e9640bec8ba8474945cce57b6501" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sqEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns if the SQ is empty. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00226"></a>00226 { <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a> == 0; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a477981d1f905d2d398a1527f7149e3c4"></a><!-- doxytag: member="LSQUnit::sqFull" ref="a477981d1f905d2d398a1527f7149e3c4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sqFull </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns if the SQ is full. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00220"></a>00220 { <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a> &gt;= (<a class="code" href="classLSQUnit.html#a38c8af5392da70119dc5cce4e3637cbc">SQEntries</a> - 1); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a51dd7e304d5413447717826fac6f4921"></a><!-- doxytag: member="LSQUnit::squash" ref="a51dd7e304d5413447717826fac6f4921" args="(const InstSeqNum &amp;squashed_num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void squash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="inst__seq_8hh.html#a258d93d98edaedee089435c19ea2ea2e">InstSeqNum</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>squashed_num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Squashes all instructions younger than a specific sequence number. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00992"></a>00992 {
<a name="l00993"></a>00993     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Squashing until [sn:%lli]!&quot;</span>
<a name="l00994"></a>00994             <span class="stringliteral">&quot;(Loads:%i Stores:%i)\n&quot;</span>, squashed_num, <a class="code" href="classLSQUnit.html#a867971f18e464abd16193e069c64a8ad">loads</a>, <a class="code" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a>);
<a name="l00995"></a>00995 
<a name="l00996"></a>00996     <span class="keywordtype">int</span> load_idx = <a class="code" href="classLSQUnit.html#a973a489225da164cc85e690f13c86841">loadTail</a>;
<a name="l00997"></a>00997     <a class="code" href="classLSQUnit.html#a313eca7abdfb7c6642078e21bc49a968">decrLdIdx</a>(load_idx);
<a name="l00998"></a>00998 
<a name="l00999"></a>00999     <span class="keywordflow">while</span> (<a class="code" href="classLSQUnit.html#a867971f18e464abd16193e069c64a8ad">loads</a> != 0 &amp;&amp; <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[load_idx]-&gt;seqNum &gt; squashed_num) {
<a name="l01000"></a>01000         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>,<span class="stringliteral">&quot;Load Instruction PC %s squashed, &quot;</span>
<a name="l01001"></a>01001                 <span class="stringliteral">&quot;[sn:%lli]\n&quot;</span>,
<a name="l01002"></a>01002                 <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[load_idx]-&gt;pcState(),
<a name="l01003"></a>01003                 <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[load_idx]-&gt;seqNum);
<a name="l01004"></a>01004 
<a name="l01005"></a>01005         <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#af8eb8590fbfa6ecd2f796390677a4c00">isStalled</a>() &amp;&amp; load_idx == <a class="code" href="classLSQUnit.html#af55bc9000c8b4e4cfcfbd018feca12a7">stallingLoadIdx</a>) {
<a name="l01006"></a>01006             <a class="code" href="classLSQUnit.html#a6f8bff553ad30865c7d0c62e05421eb8">stalled</a> = <span class="keyword">false</span>;
<a name="l01007"></a>01007             <a class="code" href="classLSQUnit.html#afe1cdcfca6b44c28581d862228adc3da">stallingStoreIsn</a> = 0;
<a name="l01008"></a>01008             <a class="code" href="classLSQUnit.html#af55bc9000c8b4e4cfcfbd018feca12a7">stallingLoadIdx</a> = 0;
<a name="l01009"></a>01009         }
<a name="l01010"></a>01010 
<a name="l01011"></a>01011         <span class="comment">// Clear the smart pointer to make sure it is decremented.</span>
<a name="l01012"></a>01012         <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[load_idx]-&gt;setSquashed();
<a name="l01013"></a>01013         <a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[load_idx] = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l01014"></a>01014         --<a class="code" href="classLSQUnit.html#a867971f18e464abd16193e069c64a8ad">loads</a>;
<a name="l01015"></a>01015 
<a name="l01016"></a>01016         <span class="comment">// Inefficient!</span>
<a name="l01017"></a>01017         <a class="code" href="classLSQUnit.html#a973a489225da164cc85e690f13c86841">loadTail</a> = load_idx;
<a name="l01018"></a>01018 
<a name="l01019"></a>01019         <a class="code" href="classLSQUnit.html#a313eca7abdfb7c6642078e21bc49a968">decrLdIdx</a>(load_idx);
<a name="l01020"></a>01020         ++<a class="code" href="classLSQUnit.html#a737697c5df3fbe8e728541fec8220089">lsqSquashedLoads</a>;
<a name="l01021"></a>01021     }
<a name="l01022"></a>01022 
<a name="l01023"></a>01023     <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a95dc31b4ce3ebcb6b9d75a510b3a128c">isLoadBlocked</a>) {
<a name="l01024"></a>01024         <span class="keywordflow">if</span> (squashed_num &lt; <a class="code" href="classLSQUnit.html#a3fca34b247fd8d081557578f8ca60fe3">blockedLoadSeqNum</a>) {
<a name="l01025"></a>01025             <a class="code" href="classLSQUnit.html#a95dc31b4ce3ebcb6b9d75a510b3a128c">isLoadBlocked</a> = <span class="keyword">false</span>;
<a name="l01026"></a>01026             <a class="code" href="classLSQUnit.html#a2c1620029c162c7180e523b089e56ed5">loadBlockedHandled</a> = <span class="keyword">false</span>;
<a name="l01027"></a>01027             <a class="code" href="classLSQUnit.html#a3fca34b247fd8d081557578f8ca60fe3">blockedLoadSeqNum</a> = 0;
<a name="l01028"></a>01028         }
<a name="l01029"></a>01029     }
<a name="l01030"></a>01030 
<a name="l01031"></a>01031     <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a270a20c3fa52139e0538288275db9d22">memDepViolator</a> &amp;&amp; squashed_num &lt; memDepViolator-&gt;seqNum) {
<a name="l01032"></a>01032         <a class="code" href="classLSQUnit.html#a270a20c3fa52139e0538288275db9d22">memDepViolator</a> = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l01033"></a>01033     }
<a name="l01034"></a>01034 
<a name="l01035"></a>01035     <span class="keywordtype">int</span> store_idx = <a class="code" href="classLSQUnit.html#acd5c7fbb5578b5cb505ffff16bbf6a8b">storeTail</a>;
<a name="l01036"></a>01036     <a class="code" href="classLSQUnit.html#a4ebe3751617bcb686e225184f77f971c">decrStIdx</a>(store_idx);
<a name="l01037"></a>01037 
<a name="l01038"></a>01038     <span class="keywordflow">while</span> (<a class="code" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a> != 0 &amp;&amp;
<a name="l01039"></a>01039            <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;seqNum &gt; squashed_num) {
<a name="l01040"></a>01040         <span class="comment">// Instructions marked as can WB are already committed.</span>
<a name="l01041"></a>01041         <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].canWB) {
<a name="l01042"></a>01042             <span class="keywordflow">break</span>;
<a name="l01043"></a>01043         }
<a name="l01044"></a>01044 
<a name="l01045"></a>01045         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>,<span class="stringliteral">&quot;Store Instruction PC %s squashed, &quot;</span>
<a name="l01046"></a>01046                 <span class="stringliteral">&quot;idx:%i [sn:%lli]\n&quot;</span>,
<a name="l01047"></a>01047                 <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;pcState(),
<a name="l01048"></a>01048                 store_idx, <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;seqNum);
<a name="l01049"></a>01049 
<a name="l01050"></a>01050         <span class="comment">// I don&apos;t think this can happen.  It should have been cleared</span>
<a name="l01051"></a>01051         <span class="comment">// by the stalling load.</span>
<a name="l01052"></a>01052         <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#af8eb8590fbfa6ecd2f796390677a4c00">isStalled</a>() &amp;&amp;
<a name="l01053"></a>01053             <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;seqNum == <a class="code" href="classLSQUnit.html#afe1cdcfca6b44c28581d862228adc3da">stallingStoreIsn</a>) {
<a name="l01054"></a>01054             <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;Is stalled should have been cleared by stalling load!\n&quot;</span>);
<a name="l01055"></a>01055             <a class="code" href="classLSQUnit.html#a6f8bff553ad30865c7d0c62e05421eb8">stalled</a> = <span class="keyword">false</span>;
<a name="l01056"></a>01056             <a class="code" href="classLSQUnit.html#afe1cdcfca6b44c28581d862228adc3da">stallingStoreIsn</a> = 0;
<a name="l01057"></a>01057         }
<a name="l01058"></a>01058 
<a name="l01059"></a>01059         <span class="comment">// Clear the smart pointer to make sure it is decremented.</span>
<a name="l01060"></a>01060         <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;setSquashed();
<a name="l01061"></a>01061         <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l01062"></a>01062         <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].canWB = 0;
<a name="l01063"></a>01063 
<a name="l01064"></a>01064         <span class="comment">// Must delete request now that it wasn&apos;t handed off to</span>
<a name="l01065"></a>01065         <span class="comment">// memory.  This is quite ugly.  @todo: Figure out the proper</span>
<a name="l01066"></a>01066         <span class="comment">// place to really handle request deletes.</span>
<a name="l01067"></a>01067         <span class="keyword">delete</span> <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].req;
<a name="l01068"></a>01068         <span class="keywordflow">if</span> (<a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a> &amp;&amp; <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].isSplit) {
<a name="l01069"></a>01069             <span class="keyword">delete</span> <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].sreqLow;
<a name="l01070"></a>01070             <span class="keyword">delete</span> <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].sreqHigh;
<a name="l01071"></a>01071 
<a name="l01072"></a>01072             <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].sreqLow = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l01073"></a>01073             <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].sreqHigh = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l01074"></a>01074         }
<a name="l01075"></a>01075 
<a name="l01076"></a>01076         <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].req = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l01077"></a>01077         --<a class="code" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a>;
<a name="l01078"></a>01078 
<a name="l01079"></a>01079         <span class="comment">// Inefficient!</span>
<a name="l01080"></a>01080         <a class="code" href="classLSQUnit.html#acd5c7fbb5578b5cb505ffff16bbf6a8b">storeTail</a> = store_idx;
<a name="l01081"></a>01081 
<a name="l01082"></a>01082         <a class="code" href="classLSQUnit.html#a4ebe3751617bcb686e225184f77f971c">decrStIdx</a>(store_idx);
<a name="l01083"></a>01083         ++<a class="code" href="classLSQUnit.html#a0abe80f8caefb71a0351c3bed4d99c0e">lsqSquashedStores</a>;
<a name="l01084"></a>01084     }
<a name="l01085"></a>01085 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6f23a0d213e7d35f445f9cabfd2ed0cc"></a><!-- doxytag: member="LSQUnit::storePostSend" ref="a6f23a0d213e7d35f445f9cabfd2ed0cc" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void storePostSend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handles completing the send of a store to memory. </p>

<p><div class="fragment"><pre class="fragment"><a name="l01090"></a>01090 {
<a name="l01091"></a>01091     <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#af8eb8590fbfa6ecd2f796390677a4c00">isStalled</a>() &amp;&amp;
<a name="l01092"></a>01092         <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].inst-&gt;seqNum == <a class="code" href="classLSQUnit.html#afe1cdcfca6b44c28581d862228adc3da">stallingStoreIsn</a>) {
<a name="l01093"></a>01093         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Unstalling, stalling store [sn:%lli] &quot;</span>
<a name="l01094"></a>01094                 <span class="stringliteral">&quot;load idx:%i\n&quot;</span>,
<a name="l01095"></a>01095                 <a class="code" href="classLSQUnit.html#afe1cdcfca6b44c28581d862228adc3da">stallingStoreIsn</a>, <a class="code" href="classLSQUnit.html#af55bc9000c8b4e4cfcfbd018feca12a7">stallingLoadIdx</a>);
<a name="l01096"></a>01096         <a class="code" href="classLSQUnit.html#a6f8bff553ad30865c7d0c62e05421eb8">stalled</a> = <span class="keyword">false</span>;
<a name="l01097"></a>01097         <a class="code" href="classLSQUnit.html#afe1cdcfca6b44c28581d862228adc3da">stallingStoreIsn</a> = 0;
<a name="l01098"></a>01098         <a class="code" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a>-&gt;replayMemInst(<a class="code" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a>[<a class="code" href="classLSQUnit.html#af55bc9000c8b4e4cfcfbd018feca12a7">stallingLoadIdx</a>]);
<a name="l01099"></a>01099     }
<a name="l01100"></a>01100 
<a name="l01101"></a>01101     <span class="keywordflow">if</span> (!<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].inst-&gt;isStoreConditional()) {
<a name="l01102"></a>01102         <span class="comment">// The store is basically completed at this time. This</span>
<a name="l01103"></a>01103         <span class="comment">// only works so long as the checker doesn&apos;t try to</span>
<a name="l01104"></a>01104         <span class="comment">// verify the value in memory for stores.</span>
<a name="l01105"></a>01105         <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].inst-&gt;setCompleted();
<a name="l01106"></a>01106 
<a name="l01107"></a>01107         <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;checker) {
<a name="l01108"></a>01108             <a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;checker-&gt;verify(<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].inst);
<a name="l01109"></a>01109         }
<a name="l01110"></a>01110     }
<a name="l01111"></a>01111 
<a name="l01112"></a>01112     <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#abef3db582145f640478056f8413a03e3">needsTSO</a>) {
<a name="l01113"></a>01113         <a class="code" href="classLSQUnit.html#aec79dbfe7cf50cf3d047cad7ee8fa157">storeInFlight</a> = <span class="keyword">true</span>;
<a name="l01114"></a>01114     }
<a name="l01115"></a>01115 
<a name="l01116"></a>01116     <a class="code" href="classLSQUnit.html#a7576fc9eec69e3ce28ce7af7ad87416a">incrStIdx</a>(<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>);
<a name="l01117"></a>01117 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8674059ce345e23aac5086b2c3e24a43"></a><!-- doxytag: member="LSQUnit::takeOverFrom" ref="a8674059ce345e23aac5086b2c3e24a43" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void takeOverFrom </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Takes over from another CPU's thread. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00299"></a>00299 {
<a name="l00300"></a>00300     <a class="code" href="classLSQUnit.html#a755ee993c2d4e9d422c37990b15afa37">resetState</a>();
<a name="l00301"></a>00301 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a873dd91783f9efb4a590aded1f70d6b0"></a><!-- doxytag: member="LSQUnit::tick" ref="a873dd91783f9efb4a590aded1f70d6b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tick </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ticks the <a class="el" href="classLSQ.html">LSQ</a> unit, which in this case only resets the number of used cache ports. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000035">TODO:</a></b></dt><dd>: Move the number of used ports up to the <a class="el" href="classLSQ.html">LSQ</a> level so it can be shared by all <a class="el" href="classLSQ.html">LSQ</a> units. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00117"></a>00117 { <a class="code" href="classLSQUnit.html#a03435d626b7567ed154de5d7d8c3d419">usedPorts</a> = 0; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4f720bbfb5fdefdb23516500eeb0b4de"></a><!-- doxytag: member="LSQUnit::violation" ref="a4f720bbfb5fdefdb23516500eeb0b4de" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool violation </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns if there is a memory ordering violation. Value is reset upon call to <a class="el" href="classLSQUnit.html#a30adaf6f5fb6b38b5747f35c419e3f31">getMemDepViolator()</a>. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00180"></a>00180 { <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a270a20c3fa52139e0538288275db9d22">memDepViolator</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a338be821734603396bfef8d9fb8f04b0"></a><!-- doxytag: member="LSQUnit::willWB" ref="a338be821734603396bfef8d9fb8f04b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool willWB </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns if the <a class="el" href="classLSQ.html">LSQ</a> unit will writeback on this cycle. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00238"></a>00238                   { <span class="keywordflow">return</span> <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].canWB &amp;&amp;
<a name="l00239"></a>00239                         !<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].completed &amp;&amp;
<a name="l00240"></a>00240                         !<a class="code" href="classLSQUnit.html#a89d931c74b63e0b0e7ad856fe9525ff6">isStoreBlocked</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8910d991217dd388c788727f8ebbb267"></a><!-- doxytag: member="LSQUnit::write" ref="a8910d991217dd388c788727f8ebbb267" args="(Request *req, Request *sreqLow, Request *sreqHigh, uint8_t *data, int store_idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRefCountingPtr.html">Fault</a> write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRequest.html">Request</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRequest.html">Request</a> *&nbsp;</td>
          <td class="paramname"> <em>sreqLow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRequest.html">Request</a> *&nbsp;</td>
          <td class="paramname"> <em>sreqHigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>store_idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Executes the store at the given index. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00917"></a>00917 {
<a name="l00918"></a>00918     assert(<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst);
<a name="l00919"></a>00919 
<a name="l00920"></a>00920     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Doing write to store idx %i, addr %#x&quot;</span>
<a name="l00921"></a>00921             <span class="stringliteral">&quot; | storeHead:%i [sn:%i]\n&quot;</span>,
<a name="l00922"></a>00922             store_idx, req-&gt;<a class="code" href="classRequest.html#a744ef11a5afe9d3651ce5f954259cb43">getPaddr</a>(), <a class="code" href="classLSQUnit.html#a6e87b6f77102183080ea6ab8599b26a9">storeHead</a>,
<a name="l00923"></a>00923             <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].inst-&gt;seqNum);
<a name="l00924"></a>00924 
<a name="l00925"></a>00925     <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].req = req;
<a name="l00926"></a>00926     <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].sreqLow = sreqLow;
<a name="l00927"></a>00927     <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].sreqHigh = sreqHigh;
<a name="l00928"></a>00928     <span class="keywordtype">unsigned</span> size = req-&gt;<a class="code" href="classRequest.html#a3c4029b904a61a9873e6d12785ce19a1">getSize</a>();
<a name="l00929"></a>00929     <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].size = size;
<a name="l00930"></a>00930     <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].isAllZeros = req-&gt;<a class="code" href="classRequest.html#a8552aa8d45c9ba10449d51ac08e7d490">getFlags</a>() &amp; <a class="code" href="classRequest.html#a4c22f8a3275a06b136b28f633beeee03">Request::CACHE_BLOCK_ZERO</a>;
<a name="l00931"></a>00931     assert(size &lt;= <span class="keyword">sizeof</span>(<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].data) ||
<a name="l00932"></a>00932             (req-&gt;<a class="code" href="classRequest.html#a8552aa8d45c9ba10449d51ac08e7d490">getFlags</a>() &amp; <a class="code" href="classRequest.html#a4c22f8a3275a06b136b28f633beeee03">Request::CACHE_BLOCK_ZERO</a>));
<a name="l00933"></a>00933 
<a name="l00934"></a>00934     <span class="comment">// Split stores can only occur in ISAs with unaligned memory accesses.  If</span>
<a name="l00935"></a>00935     <span class="comment">// a store request has been split, sreqLow and sreqHigh will be non-null.</span>
<a name="l00936"></a>00936     <span class="keywordflow">if</span> (<a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a> &amp;&amp; sreqLow) {
<a name="l00937"></a>00937         <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].isSplit = <span class="keyword">true</span>;
<a name="l00938"></a>00938     }
<a name="l00939"></a>00939 
<a name="l00940"></a>00940     <span class="keywordflow">if</span> (!(req-&gt;<a class="code" href="classRequest.html#a8552aa8d45c9ba10449d51ac08e7d490">getFlags</a>() &amp; <a class="code" href="classRequest.html#a4c22f8a3275a06b136b28f633beeee03">Request::CACHE_BLOCK_ZERO</a>))
<a name="l00941"></a>00941         memcpy(<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[store_idx].data, data, size);
<a name="l00942"></a>00942 
<a name="l00943"></a>00943     <span class="comment">// This function only writes the data to the store queue, so no fault</span>
<a name="l00944"></a>00944     <span class="comment">// can happen here.</span>
<a name="l00945"></a>00945     <span class="keywordflow">return</span> <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>;
<a name="l00946"></a>00946 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3911bacb8817c31cfbeefd125dba0217"></a><!-- doxytag: member="LSQUnit::writeback" ref="a3911bacb8817c31cfbeefd125dba0217" args="(DynInstPtr &amp;inst, PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void writeback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes back the instruction, sending it to IEW. </p>

<p><div class="fragment"><pre class="fragment"><a name="l01122"></a>01122 {
<a name="l01123"></a>01123     <a class="code" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a>-&gt;wakeCPU();
<a name="l01124"></a>01124 
<a name="l01125"></a>01125     <span class="comment">// Squashed instructions do not need to complete their access.</span>
<a name="l01126"></a>01126     <span class="keywordflow">if</span> (inst-&gt;isSquashed()) {
<a name="l01127"></a>01127         <a class="code" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a>-&gt;decrWb(inst-&gt;seqNum);
<a name="l01128"></a>01128         assert(!inst-&gt;isStore());
<a name="l01129"></a>01129         ++<a class="code" href="classLSQUnit.html#ad620ac240b0d631c3a8aa19cfd05ad41">lsqIgnoredResponses</a>;
<a name="l01130"></a>01130         <span class="keywordflow">return</span>;
<a name="l01131"></a>01131     }
<a name="l01132"></a>01132 
<a name="l01133"></a>01133     <span class="keywordflow">if</span> (!inst-&gt;isExecuted()) {
<a name="l01134"></a>01134         inst-&gt;setExecuted();
<a name="l01135"></a>01135 
<a name="l01136"></a>01136         <span class="comment">// Complete access to copy data to proper place.</span>
<a name="l01137"></a>01137         inst-&gt;completeAcc(pkt);
<a name="l01138"></a>01138     }
<a name="l01139"></a>01139 
<a name="l01140"></a>01140     <span class="comment">// Need to insert instruction into queue to commit</span>
<a name="l01141"></a>01141     <a class="code" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a>-&gt;instToCommit(inst);
<a name="l01142"></a>01142 
<a name="l01143"></a>01143     <a class="code" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a>-&gt;activityThisCycle();
<a name="l01144"></a>01144 
<a name="l01145"></a>01145     <span class="comment">// see if this load changed the PC</span>
<a name="l01146"></a>01146     <a class="code" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a>-&gt;checkMisprediction(inst);
<a name="l01147"></a>01147 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a173d8fd73280b1cf5b4d0dd9b68cf0cf"></a><!-- doxytag: member="LSQUnit::writebackPendingStore" ref="a173d8fd73280b1cf5b4d0dd9b68cf0cf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void writebackPendingStore </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes back a store that couldn't be completed the previous cycle. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00756"></a>00756 {
<a name="l00757"></a>00757     <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#ae4914b6850f06ca3589fe9e75451fc2e">hasPendingPkt</a>) {
<a name="l00758"></a>00758         assert(<a class="code" href="classLSQUnit.html#a54d6e1b7bac876ca215b09777bae1d34">pendingPkt</a> != <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>);
<a name="l00759"></a>00759 
<a name="l00760"></a>00760         <span class="comment">// If the cache is blocked, this will store the packet for retry.</span>
<a name="l00761"></a>00761         <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a268a51a93dbdda9a0cff48ba036e673e">sendStore</a>(<a class="code" href="classLSQUnit.html#a54d6e1b7bac876ca215b09777bae1d34">pendingPkt</a>)) {
<a name="l00762"></a>00762             <a class="code" href="classLSQUnit.html#a6f23a0d213e7d35f445f9cabfd2ed0cc">storePostSend</a>(<a class="code" href="classLSQUnit.html#a54d6e1b7bac876ca215b09777bae1d34">pendingPkt</a>);
<a name="l00763"></a>00763         }
<a name="l00764"></a>00764         <a class="code" href="classLSQUnit.html#a54d6e1b7bac876ca215b09777bae1d34">pendingPkt</a> = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00765"></a>00765         <a class="code" href="classLSQUnit.html#ae4914b6850f06ca3589fe9e75451fc2e">hasPendingPkt</a> = <span class="keyword">false</span>;
<a name="l00766"></a>00766     }
<a name="l00767"></a>00767 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5f04e29d6f6feb8b86460491f2ba7547"></a><!-- doxytag: member="LSQUnit::writebackStores" ref="a5f04e29d6f6feb8b86460491f2ba7547" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void writebackStores </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes back stores. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00772"></a>00772 {
<a name="l00773"></a>00773     <span class="comment">// First writeback the second packet from any split store that didn&apos;t</span>
<a name="l00774"></a>00774     <span class="comment">// complete last cycle because there weren&apos;t enough cache ports available.</span>
<a name="l00775"></a>00775     <span class="keywordflow">if</span> (<a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a>) {
<a name="l00776"></a>00776         <a class="code" href="classLSQUnit.html#a173d8fd73280b1cf5b4d0dd9b68cf0cf">writebackPendingStore</a>();
<a name="l00777"></a>00777     }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779     <span class="keywordflow">while</span> (<a class="code" href="classLSQUnit.html#a3831a7965ffbe90df177026988476f9c">storesToWB</a> &gt; 0 &amp;&amp;
<a name="l00780"></a>00780            <a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a> != <a class="code" href="classLSQUnit.html#acd5c7fbb5578b5cb505ffff16bbf6a8b">storeTail</a> &amp;&amp;
<a name="l00781"></a>00781            <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].inst &amp;&amp;
<a name="l00782"></a>00782            <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].canWB &amp;&amp;
<a name="l00783"></a>00783            ((!<a class="code" href="classLSQUnit.html#abef3db582145f640478056f8413a03e3">needsTSO</a>) || (!<a class="code" href="classLSQUnit.html#aec79dbfe7cf50cf3d047cad7ee8fa157">storeInFlight</a>)) &amp;&amp;
<a name="l00784"></a>00784            <a class="code" href="classLSQUnit.html#a03435d626b7567ed154de5d7d8c3d419">usedPorts</a> &lt; <a class="code" href="classLSQUnit.html#ab2e23636971c40e7ed945026b2a184e1">cachePorts</a>) {
<a name="l00785"></a>00785 
<a name="l00786"></a>00786         <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a89d931c74b63e0b0e7ad856fe9525ff6">isStoreBlocked</a> || <a class="code" href="classLSQUnit.html#ac0894e8141823f8eea2c9041bac9dab4">lsq</a>-&gt;<a class="code" href="classLSQ.html#a050e3736ea48bf74bd0c216b1cd3f494">cacheBlocked</a>()) {
<a name="l00787"></a>00787             <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Unable to write back any more stores, cache&quot;</span>
<a name="l00788"></a>00788                     <span class="stringliteral">&quot; is blocked!\n&quot;</span>);
<a name="l00789"></a>00789             <span class="keywordflow">break</span>;
<a name="l00790"></a>00790         }
<a name="l00791"></a>00791 
<a name="l00792"></a>00792         <span class="comment">// Store didn&apos;t write any data so no need to write it back to</span>
<a name="l00793"></a>00793         <span class="comment">// memory.</span>
<a name="l00794"></a>00794         <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].size == 0) {
<a name="l00795"></a>00795             <a class="code" href="classLSQUnit.html#a12ec7cad6ac51a53bca7795588885e5c">completeStore</a>(<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>);
<a name="l00796"></a>00796 
<a name="l00797"></a>00797             <a class="code" href="classLSQUnit.html#a7576fc9eec69e3ce28ce7af7ad87416a">incrStIdx</a>(<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>);
<a name="l00798"></a>00798 
<a name="l00799"></a>00799             <span class="keywordflow">continue</span>;
<a name="l00800"></a>00800         }
<a name="l00801"></a>00801 
<a name="l00802"></a>00802         ++<a class="code" href="classLSQUnit.html#a03435d626b7567ed154de5d7d8c3d419">usedPorts</a>;
<a name="l00803"></a>00803 
<a name="l00804"></a>00804         <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].inst-&gt;isDataPrefetch()) {
<a name="l00805"></a>00805             <a class="code" href="classLSQUnit.html#a7576fc9eec69e3ce28ce7af7ad87416a">incrStIdx</a>(<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>);
<a name="l00806"></a>00806 
<a name="l00807"></a>00807             <span class="keywordflow">continue</span>;
<a name="l00808"></a>00808         }
<a name="l00809"></a>00809 
<a name="l00810"></a>00810         assert(<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].req);
<a name="l00811"></a>00811         assert(!<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].committed);
<a name="l00812"></a>00812 
<a name="l00813"></a>00813         <span class="keywordflow">if</span> (<a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a> &amp;&amp; <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].isSplit) {
<a name="l00814"></a>00814             assert(<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].sreqLow);
<a name="l00815"></a>00815             assert(<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].sreqHigh);
<a name="l00816"></a>00816         }
<a name="l00817"></a>00817 
<a name="l00818"></a>00818         <a class="code" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> inst = <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].inst;
<a name="l00819"></a>00819 
<a name="l00820"></a>00820         <a class="code" href="classRequest.html">Request</a> *req = <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].req;
<a name="l00821"></a>00821         <a class="code" href="classRequest.html">RequestPtr</a> sreqLow = <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].sreqLow;
<a name="l00822"></a>00822         <a class="code" href="classRequest.html">RequestPtr</a> sreqHigh = <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].sreqHigh;
<a name="l00823"></a>00823 
<a name="l00824"></a>00824         <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].committed = <span class="keyword">true</span>;
<a name="l00825"></a>00825 
<a name="l00826"></a>00826         assert(!inst-&gt;memData);
<a name="l00827"></a>00827         inst-&gt;memData = <span class="keyword">new</span> uint8_t[req-&gt;<a class="code" href="classRequest.html#a3c4029b904a61a9873e6d12785ce19a1">getSize</a>()];
<a name="l00828"></a>00828 
<a name="l00829"></a>00829         <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].isAllZeros)
<a name="l00830"></a>00830             memset(inst-&gt;memData, 0, req-&gt;<a class="code" href="classRequest.html#a3c4029b904a61a9873e6d12785ce19a1">getSize</a>());
<a name="l00831"></a>00831         <span class="keywordflow">else</span>
<a name="l00832"></a>00832             memcpy(inst-&gt;memData, <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[<a class="code" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a>].data, req-&gt;<a class="code" href="classRequest.html#a3c4029b904a61a9873e6d12785ce19a1">getSize</a>());
<a name="l00833"></a>00833 
<a name="l00834"></a>00834         <a class="code" href="classMemCmd.html">MemCmd</a> command =
<a name="l00835"></a>00835             req-&gt;<a class="code" href="classRequest.html#a6ec455c5a36403d3a8319bcfbf356bc1">isSwap</a>() ? <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a544e456dc06d65a6998a7df182d247d3">MemCmd::SwapReq</a> :
<a name="l00836"></a>00836             (req-&gt;<a class="code" href="classRequest.html#a8965874e960faf91ad4b6af8dbf31875">isLLSC</a>() ? <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a10ce12df51611216e2e8c4cb9b5d4047">MemCmd::StoreCondReq</a> : <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153aa5ec34a7e56b23ff12c9b819519d168a">MemCmd::WriteReq</a>);
<a name="l00837"></a>00837         <a class="code" href="classPacket.html">PacketPtr</a> data_pkt;
<a name="l00838"></a>00838         <a class="code" href="classPacket.html">PacketPtr</a> snd_data_pkt = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00839"></a>00839 
<a name="l00840"></a>00840         LSQSenderState *state = <span class="keyword">new</span> LSQSenderState;
<a name="l00841"></a>00841         state-&gt;isLoad = <span class="keyword">false</span>;
<a name="l00842"></a>00842         state-&gt;idx = storeWBIdx;
<a name="l00843"></a>00843         state-&gt;inst = inst;
<a name="l00844"></a>00844 
<a name="l00845"></a>00845         <span class="keywordflow">if</span> (!<a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a> || !<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[storeWBIdx].isSplit) {
<a name="l00846"></a>00846 
<a name="l00847"></a>00847             <span class="comment">// Build a single data packet if the store isn&apos;t split.</span>
<a name="l00848"></a>00848             data_pkt = <span class="keyword">new</span> <a class="code" href="classPacket.html">Packet</a>(req, command);
<a name="l00849"></a>00849             data_pkt-&gt;<a class="code" href="classPacket.html#a60621b00d6ecd49b3e336087aca2eda0">dataStatic</a>(inst-&gt;memData);
<a name="l00850"></a>00850             data_pkt-&gt;<a class="code" href="classPacket.html#a983ade0479f946c813284dcc65073367">senderState</a> = state;
<a name="l00851"></a>00851         } <span class="keywordflow">else</span> {
<a name="l00852"></a>00852             <span class="comment">// Create two packets if the store is split in two.</span>
<a name="l00853"></a>00853             data_pkt = <span class="keyword">new</span> <a class="code" href="classPacket.html">Packet</a>(sreqLow, command);
<a name="l00854"></a>00854             snd_data_pkt = <span class="keyword">new</span> <a class="code" href="classPacket.html">Packet</a>(sreqHigh, command);
<a name="l00855"></a>00855 
<a name="l00856"></a>00856             data_pkt-&gt;<a class="code" href="classPacket.html#a60621b00d6ecd49b3e336087aca2eda0">dataStatic</a>(inst-&gt;memData);
<a name="l00857"></a>00857             snd_data_pkt-&gt;<a class="code" href="classPacket.html#a60621b00d6ecd49b3e336087aca2eda0">dataStatic</a>(inst-&gt;memData + sreqLow-&gt;<a class="code" href="classRequest.html#a3c4029b904a61a9873e6d12785ce19a1">getSize</a>());
<a name="l00858"></a>00858 
<a name="l00859"></a>00859             data_pkt-&gt;<a class="code" href="classPacket.html#a983ade0479f946c813284dcc65073367">senderState</a> = state;
<a name="l00860"></a>00860             snd_data_pkt-&gt;<a class="code" href="classPacket.html#a983ade0479f946c813284dcc65073367">senderState</a> = state;
<a name="l00861"></a>00861 
<a name="l00862"></a>00862             state-&gt;isSplit = <span class="keyword">true</span>;
<a name="l00863"></a>00863             state-&gt;outstanding = 2;
<a name="l00864"></a>00864 
<a name="l00865"></a>00865             <span class="comment">// Can delete the main request now.</span>
<a name="l00866"></a>00866             <span class="keyword">delete</span> req;
<a name="l00867"></a>00867             req = sreqLow;
<a name="l00868"></a>00868         }
<a name="l00869"></a>00869 
<a name="l00870"></a>00870         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;D-Cache: Writing back store idx:%i PC:%s &quot;</span>
<a name="l00871"></a>00871                 <span class="stringliteral">&quot;to Addr:%#x, data:%#x [sn:%lli]\n&quot;</span>,
<a name="l00872"></a>00872                 storeWBIdx, inst-&gt;pcState(),
<a name="l00873"></a>00873                 req-&gt;<a class="code" href="classRequest.html#a744ef11a5afe9d3651ce5f954259cb43">getPaddr</a>(), (int)*(inst-&gt;memData),
<a name="l00874"></a>00874                 inst-&gt;seqNum);
<a name="l00875"></a>00875 
<a name="l00876"></a>00876         <span class="comment">// @todo: Remove this SC hack once the memory system handles it.</span>
<a name="l00877"></a>00877         <span class="keywordflow">if</span> (inst-&gt;isStoreConditional()) {
<a name="l00878"></a>00878             assert(!<a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[storeWBIdx].isSplit);
<a name="l00879"></a>00879             <span class="comment">// Disable recording the result temporarily.  Writing to</span>
<a name="l00880"></a>00880             <span class="comment">// misc regs normally updates the result, but this is not</span>
<a name="l00881"></a>00881             <span class="comment">// the desired behavior when handling store conditionals.</span>
<a name="l00882"></a>00882             inst-&gt;recordResult(<span class="keyword">false</span>);
<a name="l00883"></a>00883             <span class="keywordtype">bool</span> success = <a class="code" href="namespaceAlphaISA.html#a1087208351cf56657581daf8f2f918c8">TheISA::handleLockedWrite</a>(inst.get(), req, <a class="code" href="classLSQUnit.html#af4264b12b32db39099b579e1ed670312">cacheBlockMask</a>);
<a name="l00884"></a>00884             inst-&gt;recordResult(<span class="keyword">true</span>);
<a name="l00885"></a>00885 
<a name="l00886"></a>00886             <span class="keywordflow">if</span> (!success) {
<a name="l00887"></a>00887                 <span class="comment">// Instantly complete this store.</span>
<a name="l00888"></a>00888                 <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html">LSQUnit</a>, <span class="stringliteral">&quot;Store conditional [sn:%lli] failed.  &quot;</span>
<a name="l00889"></a>00889                         <span class="stringliteral">&quot;Instantly completing it.\n&quot;</span>,
<a name="l00890"></a>00890                         inst-&gt;seqNum);
<a name="l00891"></a>00891                 WritebackEvent *wb = <span class="keyword">new</span> WritebackEvent(inst, data_pkt, <span class="keyword">this</span>);
<a name="l00892"></a>00892                 <a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;schedule(wb, <a class="code" href="statistics_8hh.html#a7acdccbf0d35ce0c159c0cdd36371b22" title="The universal simulation clock.">curTick</a>() + 1);
<a name="l00893"></a>00893                 <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;checker) {
<a name="l00894"></a>00894                     <span class="comment">// Make sure to set the LLSC data for verification</span>
<a name="l00895"></a>00895                     <span class="comment">// if checker is loaded</span>
<a name="l00896"></a>00896                     inst-&gt;reqToVerify-&gt;setExtraData(0);
<a name="l00897"></a>00897                     inst-&gt;completeAcc(data_pkt);
<a name="l00898"></a>00898                 }
<a name="l00899"></a>00899                 <a class="code" href="classLSQUnit.html#a12ec7cad6ac51a53bca7795588885e5c">completeStore</a>(storeWBIdx);
<a name="l00900"></a>00900                 <a class="code" href="classLSQUnit.html#a7576fc9eec69e3ce28ce7af7ad87416a">incrStIdx</a>(storeWBIdx);
<a name="l00901"></a>00901                 <span class="keywordflow">continue</span>;
<a name="l00902"></a>00902             }
<a name="l00903"></a>00903         } <span class="keywordflow">else</span> {
<a name="l00904"></a>00904             <span class="comment">// Non-store conditionals do not need a writeback.</span>
<a name="l00905"></a>00905             state-&gt;noWB = <span class="keyword">true</span>;
<a name="l00906"></a>00906         }
<a name="l00907"></a>00907 
<a name="l00908"></a>00908         <span class="keywordtype">bool</span> split =
<a name="l00909"></a>00909             <a class="code" href="namespaceAlphaISA.html#a1c3adbc67ce574fe545e332d3bc677be">TheISA::HasUnalignedMemAcc</a> &amp;&amp; <a class="code" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a>[storeWBIdx].isSplit;
<a name="l00910"></a>00910 
<a name="l00911"></a>00911         <a class="code" href="classThreadContext.html">ThreadContext</a> *thread = <a class="code" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a>-&gt;tcBase(<a class="code" href="classLSQUnit.html#a0ee490ba978f48fbf2579acc7eb60b24">lsqID</a>);
<a name="l00912"></a>00912 
<a name="l00913"></a>00913         <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#aad621c262e009350dd86ad5715c50f7a">isMmappedIpr</a>()) {
<a name="l00914"></a>00914             assert(!inst-&gt;isStoreConditional());
<a name="l00915"></a>00915             <a class="code" href="namespaceGenericISA.html#a31c83a2af3232333d9a399a2878dc729">TheISA::handleIprWrite</a>(thread, data_pkt);
<a name="l00916"></a>00916             <span class="keyword">delete</span> data_pkt;
<a name="l00917"></a>00917             <span class="keywordflow">if</span> (split) {
<a name="l00918"></a>00918                 assert(snd_data_pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#aad621c262e009350dd86ad5715c50f7a">isMmappedIpr</a>());
<a name="l00919"></a>00919                 <a class="code" href="namespaceGenericISA.html#a31c83a2af3232333d9a399a2878dc729">TheISA::handleIprWrite</a>(thread, snd_data_pkt);
<a name="l00920"></a>00920                 <span class="keyword">delete</span> snd_data_pkt;
<a name="l00921"></a>00921                 <span class="keyword">delete</span> sreqLow;
<a name="l00922"></a>00922                 <span class="keyword">delete</span> sreqHigh;
<a name="l00923"></a>00923             }
<a name="l00924"></a>00924             <span class="keyword">delete</span> state;
<a name="l00925"></a>00925             <span class="keyword">delete</span> req;
<a name="l00926"></a>00926             <a class="code" href="classLSQUnit.html#a12ec7cad6ac51a53bca7795588885e5c">completeStore</a>(storeWBIdx);
<a name="l00927"></a>00927             <a class="code" href="classLSQUnit.html#a7576fc9eec69e3ce28ce7af7ad87416a">incrStIdx</a>(storeWBIdx);
<a name="l00928"></a>00928         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="classLSQUnit.html#a268a51a93dbdda9a0cff48ba036e673e">sendStore</a>(data_pkt)) {
<a name="l00929"></a>00929             <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html#a23f60a4095b5240dfcb18a4ec40210a9">IEW</a>, <span class="stringliteral">&quot;D-Cache became blocked when writing [sn:%lli], will&quot;</span>
<a name="l00930"></a>00930                     <span class="stringliteral">&quot;retry later\n&quot;</span>,
<a name="l00931"></a>00931                     inst-&gt;seqNum);
<a name="l00932"></a>00932 
<a name="l00933"></a>00933             <span class="comment">// Need to store the second packet, if split.</span>
<a name="l00934"></a>00934             <span class="keywordflow">if</span> (split) {
<a name="l00935"></a>00935                 state-&gt;pktToSend = <span class="keyword">true</span>;
<a name="l00936"></a>00936                 state-&gt;pendingPacket = snd_data_pkt;
<a name="l00937"></a>00937             }
<a name="l00938"></a>00938         } <span class="keywordflow">else</span> {
<a name="l00939"></a>00939 
<a name="l00940"></a>00940             <span class="comment">// If split, try to send the second packet too</span>
<a name="l00941"></a>00941             <span class="keywordflow">if</span> (split) {
<a name="l00942"></a>00942                 assert(snd_data_pkt);
<a name="l00943"></a>00943 
<a name="l00944"></a>00944                 <span class="comment">// Ensure there are enough ports to use.</span>
<a name="l00945"></a>00945                 <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a03435d626b7567ed154de5d7d8c3d419">usedPorts</a> &lt; <a class="code" href="classLSQUnit.html#ab2e23636971c40e7ed945026b2a184e1">cachePorts</a>) {
<a name="l00946"></a>00946                     ++<a class="code" href="classLSQUnit.html#a03435d626b7567ed154de5d7d8c3d419">usedPorts</a>;
<a name="l00947"></a>00947                     <span class="keywordflow">if</span> (<a class="code" href="classLSQUnit.html#a268a51a93dbdda9a0cff48ba036e673e">sendStore</a>(snd_data_pkt)) {
<a name="l00948"></a>00948                         <a class="code" href="classLSQUnit.html#a6f23a0d213e7d35f445f9cabfd2ed0cc">storePostSend</a>(snd_data_pkt);
<a name="l00949"></a>00949                     } <span class="keywordflow">else</span> {
<a name="l00950"></a>00950                         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classLSQUnit.html#a23f60a4095b5240dfcb18a4ec40210a9">IEW</a>, <span class="stringliteral">&quot;D-Cache became blocked when writing&quot;</span>
<a name="l00951"></a>00951                                 <span class="stringliteral">&quot; [sn:%lli] second packet, will retry later\n&quot;</span>,
<a name="l00952"></a>00952                                 inst-&gt;seqNum);
<a name="l00953"></a>00953                     }
<a name="l00954"></a>00954                 } <span class="keywordflow">else</span> {
<a name="l00955"></a>00955 
<a name="l00956"></a>00956                     <span class="comment">// Store the packet for when there&apos;s free ports.</span>
<a name="l00957"></a>00957                     assert(<a class="code" href="classLSQUnit.html#a54d6e1b7bac876ca215b09777bae1d34">pendingPkt</a> == <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>);
<a name="l00958"></a>00958                     <a class="code" href="classLSQUnit.html#a54d6e1b7bac876ca215b09777bae1d34">pendingPkt</a> = snd_data_pkt;
<a name="l00959"></a>00959                     <a class="code" href="classLSQUnit.html#ae4914b6850f06ca3589fe9e75451fc2e">hasPendingPkt</a> = <span class="keyword">true</span>;
<a name="l00960"></a>00960                 }
<a name="l00961"></a>00961             } <span class="keywordflow">else</span> {
<a name="l00962"></a>00962 
<a name="l00963"></a>00963                 <span class="comment">// Not a split store.</span>
<a name="l00964"></a>00964                 <a class="code" href="classLSQUnit.html#a6f23a0d213e7d35f445f9cabfd2ed0cc">storePostSend</a>(data_pkt);
<a name="l00965"></a>00965             }
<a name="l00966"></a>00966         }
<a name="l00967"></a>00967     }
<a name="l00968"></a>00968 
<a name="l00969"></a>00969     <span class="comment">// Not sure this should set it to 0.</span>
<a name="l00970"></a>00970     <a class="code" href="classLSQUnit.html#a03435d626b7567ed154de5d7d8c3d419">usedPorts</a> = 0;
<a name="l00971"></a>00971 
<a name="l00972"></a>00972     assert(<a class="code" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a> &gt;= 0 &amp;&amp; <a class="code" href="classLSQUnit.html#a3831a7965ffbe90df177026988476f9c">storesToWB</a> &gt;= 0);
<a name="l00973"></a>00973 }
</pre></div></p>

</div>
</div>
<hr/><h2>変数</h2>
<a class="anchor" id="a3fca34b247fd8d081557578f8ca60fe3"></a><!-- doxytag: member="LSQUnit::blockedLoadSeqNum" ref="a3fca34b247fd8d081557578f8ca60fe3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inst__seq_8hh.html#a258d93d98edaedee089435c19ea2ea2e">InstSeqNum</a> <a class="el" href="classLSQUnit.html#a3fca34b247fd8d081557578f8ca60fe3">blockedLoadSeqNum</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The sequence number of the blocked load. </p>

</div>
</div>
<a class="anchor" id="af4264b12b32db39099b579e1ed670312"></a><!-- doxytag: member="LSQUnit::cacheBlockMask" ref="af4264b12b32db39099b579e1ed670312" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="classLSQUnit.html#af4264b12b32db39099b579e1ed670312">cacheBlockMask</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classAddress.html">Address</a> Mask for a cache block (e.g. ~(cache_block_size-1)) </p>

</div>
</div>
<a class="anchor" id="ab2e23636971c40e7ed945026b2a184e1"></a><!-- doxytag: member="LSQUnit::cachePorts" ref="ab2e23636971c40e7ed945026b2a184e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLSQUnit.html#ab2e23636971c40e7ed945026b2a184e1">cachePorts</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000038">TODO:</a></b></dt><dd>Consider moving to a more advanced model with write vs read ports </dd></dl>
<p>The number of cache ports available each cycle. </p>

</div>
</div>
<a class="anchor" id="a602a9ccaf8b313e8923d8b07ec5bc439"></a><!-- doxytag: member="LSQUnit::checkLoads" ref="a602a9ccaf8b313e8923d8b07ec5bc439" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLSQUnit.html#a602a9ccaf8b313e8923d8b07ec5bc439">checkLoads</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Should loads be checked for dependency issues </p>

</div>
</div>
<a class="anchor" id="a1379cf882a12ac6fc9eba5da7c84b18b"></a><!-- doxytag: member="LSQUnit::cpu" ref="a1379cf882a12ac6fc9eba5da7c84b18b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLSQUnit.html#a44622cf06940413482836cb62931ac3f">O3CPU</a>* <a class="el" href="classLSQUnit.html#a1379cf882a12ac6fc9eba5da7c84b18b">cpu</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer to the CPU. </p>

</div>
</div>
<a class="anchor" id="a2bbddd281625b8b4d716708925673445"></a><!-- doxytag: member="LSQUnit::dcachePort" ref="a2bbddd281625b8b4d716708925673445" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMasterPort.html">MasterPort</a>* <a class="el" href="classLSQUnit.html#a2bbddd281625b8b4d716708925673445">dcachePort</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer to the dcache port. Used only for sending. </p>

</div>
</div>
<a class="anchor" id="ab5dfaaa13f279adbed7a1eafea047796"></a><!-- doxytag: member="LSQUnit::depCheckShift" ref="ab5dfaaa13f279adbed7a1eafea047796" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classLSQUnit.html#ab5dfaaa13f279adbed7a1eafea047796">depCheckShift</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The number of places to shift addresses in the <a class="el" href="classLSQ.html">LSQ</a> before checking for dependency violations </p>

</div>
</div>
<a class="anchor" id="af6f43373b6586aa8c486538fb076effb"></a><!-- doxytag: member="LSQUnit::fromIssue" ref="af6f43373b6586aa8c486538fb076effb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTimeBuffer.html">TimeBuffer</a>&lt;<a class="el" href="structIssueStruct.html">IssueStruct</a>&gt;::wire <a class="el" href="classLSQUnit.html#af6f43373b6586aa8c486538fb076effb">fromIssue</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classWire.html">Wire</a> to read information from the issue stage time queue. </p>

</div>
</div>
<a class="anchor" id="ae4914b6850f06ca3589fe9e75451fc2e"></a><!-- doxytag: member="LSQUnit::hasPendingPkt" ref="ae4914b6850f06ca3589fe9e75451fc2e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLSQUnit.html#ae4914b6850f06ca3589fe9e75451fc2e">hasPendingPkt</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Whether or not there is a packet that couldn't be sent because of a lack of cache ports. </p>

</div>
</div>
<a class="anchor" id="a4e9ef25d8913b270d432be4bbfe4965c"></a><!-- doxytag: member="LSQUnit::iewStage" ref="a4e9ef25d8913b270d432be4bbfe4965c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLSQUnit.html#a23f60a4095b5240dfcb18a4ec40210a9">IEW</a>* <a class="el" href="classLSQUnit.html#a4e9ef25d8913b270d432be4bbfe4965c">iewStage</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer to the IEW stage. </p>

</div>
</div>
<a class="anchor" id="ab1c6fb6e4b6c6a243412e594629105ea"></a><!-- doxytag: member="LSQUnit::invAddrLoads" ref="ab1c6fb6e4b6c6a243412e594629105ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classLSQUnit.html#ab1c6fb6e4b6c6a243412e594629105ea">invAddrLoads</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Total number of loads ignored due to invalid addresses. </p>

</div>
</div>
<a class="anchor" id="a893e9b5b65df5710d85f6a583504a11c"></a><!-- doxytag: member="LSQUnit::invAddrSwpfs" ref="a893e9b5b65df5710d85f6a583504a11c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classLSQUnit.html#a893e9b5b65df5710d85f6a583504a11c">invAddrSwpfs</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Total number of software prefetches ignored due to invalid addresses. </p>

</div>
</div>
<a class="anchor" id="a95dc31b4ce3ebcb6b9d75a510b3a128c"></a><!-- doxytag: member="LSQUnit::isLoadBlocked" ref="a95dc31b4ce3ebcb6b9d75a510b3a128c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLSQUnit.html#a95dc31b4ce3ebcb6b9d75a510b3a128c">isLoadBlocked</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Whether or not a load is blocked due to the memory system. </p>

</div>
</div>
<a class="anchor" id="a89d931c74b63e0b0e7ad856fe9525ff6"></a><!-- doxytag: member="LSQUnit::isStoreBlocked" ref="a89d931c74b63e0b0e7ad856fe9525ff6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLSQUnit.html#a89d931c74b63e0b0e7ad856fe9525ff6">isStoreBlocked</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Whehter or not a store is blocked due to the memory system. </p>

</div>
</div>
<a class="anchor" id="a2c1620029c162c7180e523b089e56ed5"></a><!-- doxytag: member="LSQUnit::loadBlockedHandled" ref="a2c1620029c162c7180e523b089e56ed5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLSQUnit.html#a2c1620029c162c7180e523b089e56ed5">loadBlockedHandled</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Has the blocked load been handled. </p>

</div>
</div>
<a class="anchor" id="ac09af89928d2ef4da4cbdcfce26fa3f5"></a><!-- doxytag: member="LSQUnit::loadHead" ref="ac09af89928d2ef4da4cbdcfce26fa3f5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLSQUnit.html#ac09af89928d2ef4da4cbdcfce26fa3f5">loadHead</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The index of the head instruction in the LQ. </p>

</div>
</div>
<a class="anchor" id="aa5f3703c5d7c5ce21a497352b94c7465"></a><!-- doxytag: member="LSQUnit::loadQueue" ref="aa5f3703c5d7c5ce21a497352b94c7465" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a>&gt; <a class="el" href="classLSQUnit.html#aa5f3703c5d7c5ce21a497352b94c7465">loadQueue</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The load queue. </p>

</div>
</div>
<a class="anchor" id="a867971f18e464abd16193e069c64a8ad"></a><!-- doxytag: member="LSQUnit::loads" ref="a867971f18e464abd16193e069c64a8ad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLSQUnit.html#a867971f18e464abd16193e069c64a8ad">loads</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The number of load instructions in the LQ. </p>

</div>
</div>
<a class="anchor" id="a973a489225da164cc85e690f13c86841"></a><!-- doxytag: member="LSQUnit::loadTail" ref="a973a489225da164cc85e690f13c86841" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLSQUnit.html#a973a489225da164cc85e690f13c86841">loadTail</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The index of the tail instruction in the LQ. </p>

</div>
</div>
<a class="anchor" id="aafa99d800d574095881acbacdbbbcc47"></a><!-- doxytag: member="LSQUnit::LQEntries" ref="aafa99d800d574095881acbacdbbbcc47" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classLSQUnit.html#aafa99d800d574095881acbacdbbbcc47">LQEntries</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The number of LQ entries, plus a sentinel entry (circular queue). </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000036">TODO:</a></b></dt><dd>: Consider having var that records the true number of LQ entries. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0894e8141823f8eea2c9041bac9dab4"></a><!-- doxytag: member="LSQUnit::lsq" ref="ac0894e8141823f8eea2c9041bac9dab4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLSQ.html">LSQ</a>* <a class="el" href="classLSQUnit.html#ac0894e8141823f8eea2c9041bac9dab4">lsq</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer to the <a class="el" href="classLSQ.html">LSQ</a>. </p>

</div>
</div>
<a class="anchor" id="a5323f1c2b6bf5cccc59253596656eb70"></a><!-- doxytag: member="LSQUnit::lsqBlockedLoads" ref="a5323f1c2b6bf5cccc59253596656eb70" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classLSQUnit.html#a5323f1c2b6bf5cccc59253596656eb70">lsqBlockedLoads</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ready loads blocked due to partial store-forwarding. </p>

</div>
</div>
<a class="anchor" id="a33a1cca2455a3e5909f462a778902643"></a><!-- doxytag: member="LSQUnit::lsqCacheBlocked" ref="a33a1cca2455a3e5909f462a778902643" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classLSQUnit.html#a33a1cca2455a3e5909f462a778902643">lsqCacheBlocked</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number of times the <a class="el" href="classLSQ.html">LSQ</a> is blocked due to the cache. </p>

</div>
</div>
<a class="anchor" id="a2adecfd8b85711a16f91e0fbd7ca8f10"></a><!-- doxytag: member="LSQUnit::lsqForwLoads" ref="a2adecfd8b85711a16f91e0fbd7ca8f10" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classLSQUnit.html#a2adecfd8b85711a16f91e0fbd7ca8f10">lsqForwLoads</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Total number of loads forwaded from <a class="el" href="classLSQ.html">LSQ</a> stores. </p>

</div>
</div>
<a class="anchor" id="a0ee490ba978f48fbf2579acc7eb60b24"></a><!-- doxytag: member="LSQUnit::lsqID" ref="a0ee490ba978f48fbf2579acc7eb60b24" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a> <a class="el" href="classLSQUnit.html#a0ee490ba978f48fbf2579acc7eb60b24">lsqID</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The <a class="el" href="classLSQUnit.html">LSQUnit</a> thread id. </p>

</div>
</div>
<a class="anchor" id="ad620ac240b0d631c3a8aa19cfd05ad41"></a><!-- doxytag: member="LSQUnit::lsqIgnoredResponses" ref="ad620ac240b0d631c3a8aa19cfd05ad41" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classLSQUnit.html#ad620ac240b0d631c3a8aa19cfd05ad41">lsqIgnoredResponses</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Total number of responses from the memory system that are ignored due to the instruction already being squashed. </p>

</div>
</div>
<a class="anchor" id="ac499fc2b461e03a110deae7c695f75bc"></a><!-- doxytag: member="LSQUnit::lsqMemOrderViolation" ref="ac499fc2b461e03a110deae7c695f75bc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classLSQUnit.html#ac499fc2b461e03a110deae7c695f75bc">lsqMemOrderViolation</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tota number of memory ordering violations. </p>

</div>
</div>
<a class="anchor" id="af5c24658bed91065bf7d69d27ba9fbd6"></a><!-- doxytag: member="LSQUnit::lsqRescheduledLoads" ref="af5c24658bed91065bf7d69d27ba9fbd6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classLSQUnit.html#af5c24658bed91065bf7d69d27ba9fbd6">lsqRescheduledLoads</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number of loads that were rescheduled. </p>

</div>
</div>
<a class="anchor" id="a737697c5df3fbe8e728541fec8220089"></a><!-- doxytag: member="LSQUnit::lsqSquashedLoads" ref="a737697c5df3fbe8e728541fec8220089" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classLSQUnit.html#a737697c5df3fbe8e728541fec8220089">lsqSquashedLoads</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Total number of squashed loads. </p>

</div>
</div>
<a class="anchor" id="a0abe80f8caefb71a0351c3bed4d99c0e"></a><!-- doxytag: member="LSQUnit::lsqSquashedStores" ref="a0abe80f8caefb71a0351c3bed4d99c0e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classLSQUnit.html#a0abe80f8caefb71a0351c3bed4d99c0e">lsqSquashedStores</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Total number of squashed stores. </p>

</div>
</div>
<a class="anchor" id="a270a20c3fa52139e0538288275db9d22"></a><!-- doxytag: member="LSQUnit::memDepViolator" ref="a270a20c3fa52139e0538288275db9d22" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLSQUnit.html#a028ce10889c5f6450239d9e9a7347976">DynInstPtr</a> <a class="el" href="classLSQUnit.html#a270a20c3fa52139e0538288275db9d22">memDepViolator</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The oldest load that caused a memory ordering violation. </p>

</div>
</div>
<a class="anchor" id="abef3db582145f640478056f8413a03e3"></a><!-- doxytag: member="LSQUnit::needsTSO" ref="abef3db582145f640478056f8413a03e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLSQUnit.html#abef3db582145f640478056f8413a03e3">needsTSO</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flag for memory model. </p>

</div>
</div>
<a class="anchor" id="a54d6e1b7bac876ca215b09777bae1d34"></a><!-- doxytag: member="LSQUnit::pendingPkt" ref="a54d6e1b7bac876ca215b09777bae1d34" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPacket.html">PacketPtr</a> <a class="el" href="classLSQUnit.html#a54d6e1b7bac876ca215b09777bae1d34">pendingPkt</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The packet that is pending free cache ports. </p>

</div>
</div>
<a class="anchor" id="a314ae93c04b3ca96e79e1b1f39a8e478"></a><!-- doxytag: member="LSQUnit::retryPkt" ref="a314ae93c04b3ca96e79e1b1f39a8e478" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPacket.html">PacketPtr</a> <a class="el" href="classLSQUnit.html#a314ae93c04b3ca96e79e1b1f39a8e478">retryPkt</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The packet that needs to be retried. </p>

</div>
</div>
<a class="anchor" id="a38c8af5392da70119dc5cce4e3637cbc"></a><!-- doxytag: member="LSQUnit::SQEntries" ref="a38c8af5392da70119dc5cce4e3637cbc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classLSQUnit.html#a38c8af5392da70119dc5cce4e3637cbc">SQEntries</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The number of SQ entries, plus a sentinel entry (circular queue). </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000037">TODO:</a></b></dt><dd>: Consider having var that records the true number of SQ entries. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f8bff553ad30865c7d0c62e05421eb8"></a><!-- doxytag: member="LSQUnit::stalled" ref="a6f8bff553ad30865c7d0c62e05421eb8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLSQUnit.html#a6f8bff553ad30865c7d0c62e05421eb8">stalled</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Whether or not the <a class="el" href="classLSQ.html">LSQ</a> is stalled. </p>

</div>
</div>
<a class="anchor" id="af55bc9000c8b4e4cfcfbd018feca12a7"></a><!-- doxytag: member="LSQUnit::stallingLoadIdx" ref="af55bc9000c8b4e4cfcfbd018feca12a7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLSQUnit.html#af55bc9000c8b4e4cfcfbd018feca12a7">stallingLoadIdx</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The index of the above store. </p>

</div>
</div>
<a class="anchor" id="afe1cdcfca6b44c28581d862228adc3da"></a><!-- doxytag: member="LSQUnit::stallingStoreIsn" ref="afe1cdcfca6b44c28581d862228adc3da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="inst__seq_8hh.html#a258d93d98edaedee089435c19ea2ea2e">InstSeqNum</a> <a class="el" href="classLSQUnit.html#afe1cdcfca6b44c28581d862228adc3da">stallingStoreIsn</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The store that causes the stall due to partial store to load forwarding. </p>

</div>
</div>
<a class="anchor" id="a6e87b6f77102183080ea6ab8599b26a9"></a><!-- doxytag: member="LSQUnit::storeHead" ref="a6e87b6f77102183080ea6ab8599b26a9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLSQUnit.html#a6e87b6f77102183080ea6ab8599b26a9">storeHead</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The index of the head instruction in the SQ. </p>

</div>
</div>
<a class="anchor" id="aec79dbfe7cf50cf3d047cad7ee8fa157"></a><!-- doxytag: member="LSQUnit::storeInFlight" ref="aec79dbfe7cf50cf3d047cad7ee8fa157" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLSQUnit.html#aec79dbfe7cf50cf3d047cad7ee8fa157">storeInFlight</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Whether or not a store is in flight. </p>

</div>
</div>
<a class="anchor" id="a1d370cdc36d253e0f786d46c6af77a40"></a><!-- doxytag: member="LSQUnit::storeQueue" ref="a1d370cdc36d253e0f786d46c6af77a40" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="structLSQUnit_1_1SQEntry.html">SQEntry</a>&gt; <a class="el" href="classLSQUnit.html#a1d370cdc36d253e0f786d46c6af77a40">storeQueue</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The store queue. </p>

</div>
</div>
<a class="anchor" id="ade9e895aa9c5ace27779c985c4f43326"></a><!-- doxytag: member="LSQUnit::stores" ref="ade9e895aa9c5ace27779c985c4f43326" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLSQUnit.html#ade9e895aa9c5ace27779c985c4f43326">stores</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The number of store instructions in the SQ. </p>

</div>
</div>
<a class="anchor" id="a3831a7965ffbe90df177026988476f9c"></a><!-- doxytag: member="LSQUnit::storesToWB" ref="a3831a7965ffbe90df177026988476f9c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLSQUnit.html#a3831a7965ffbe90df177026988476f9c">storesToWB</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The number of store instructions in the SQ waiting to writeback. </p>

</div>
</div>
<a class="anchor" id="acd5c7fbb5578b5cb505ffff16bbf6a8b"></a><!-- doxytag: member="LSQUnit::storeTail" ref="acd5c7fbb5578b5cb505ffff16bbf6a8b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLSQUnit.html#acd5c7fbb5578b5cb505ffff16bbf6a8b">storeTail</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The index of the tail instruction in the SQ. </p>

</div>
</div>
<a class="anchor" id="a9023e0813d4f3e566d17fb6334a2da02"></a><!-- doxytag: member="LSQUnit::storeWBIdx" ref="a9023e0813d4f3e566d17fb6334a2da02" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLSQUnit.html#a9023e0813d4f3e566d17fb6334a2da02">storeWBIdx</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The index of the first instruction that may be ready to be written back, and has not yet been written back. </p>

</div>
</div>
<a class="anchor" id="a03435d626b7567ed154de5d7d8c3d419"></a><!-- doxytag: member="LSQUnit::usedPorts" ref="a03435d626b7567ed154de5d7d8c3d419" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classLSQUnit.html#a03435d626b7567ed154de5d7d8c3d419">usedPorts</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The number of used cache ports in this cycle. </p>

</div>
</div>
<hr/>このクラスの説明は次のファイルから生成されました:<ul>
<li>cpu/o3/<a class="el" href="o3_2lsq__unit_8hh_source.html">lsq_unit.hh</a></li>
<li>cpu/o3/<a class="el" href="o3_2lsq__unit__impl_8hh_source.html">lsq_unit_impl.hh</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>File&nbsp;GEM5&nbsp;Wrapperに対して25 May 2015に生成されました。&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
