\hypertarget{classm5_1_1SimObject_1_1MetaSimObject}{
\section{クラス MetaSimObject}
\label{classm5_1_1SimObject_1_1MetaSimObject}\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_a2f15a4676204349e06bcced484b06b70}{\_\-\_\-new\_\-\_\-}
\item 
def \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_ac775ee34451fdfa742b318538164070e}{\_\-\_\-init\_\-\_\-}
\item 
def \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_a6287b7a16286568d5442b6e2e90215b5}{\_\-\_\-setattr\_\-\_\-}
\item 
def \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_a0a990b3ec3889d40889daca9ee5e4695}{\_\-\_\-getattr\_\-\_\-}
\item 
def \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_aa7a4b9bc0941308e362738503137460e}{\_\-\_\-str\_\-\_\-}
\item 
def \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_a0b408a11a14bd1d770e28f71a6e14ab5}{cxx\_\-predecls}
\item 
def \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_ab3dbcf5716623eac67a8ccc074fa7e13}{swig\_\-predecls}
\item 
def \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_ab373c5eaef9a7b80491a097389260f4a}{export\_\-methods}
\item 
def \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_a4c94af862ca1bc3ebde2094d5e778ef1}{export\_\-method\_\-cxx\_\-predecls}
\item 
def \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_ac19f60f4d41b7b37c7f282db24e5d743}{export\_\-method\_\-swig\_\-predecls}
\item 
def \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_a83526365333b680bfcbd9b037527cc25}{swig\_\-decl}
\item 
def \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_af533aa789436bfde5727387a36ca9178}{cxx\_\-param\_\-decl}
\end{DoxyCompactItemize}
\subsection*{Static Public 変数}
\begin{DoxyCompactItemize}
\item 
dictionary \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_a608ecb4a2947d6894ab9594d7f59f0a8}{init\_\-keywords}
\item 
dictionary \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_a834325b701200b492fc4d7422529cc70}{keywords} = \{ 'check' : FunctionType \}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_a5abb9e05651c6ebea8a449d8b9f631da}{\_\-set\_\-keyword}
\item 
def \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_ac8e49572c0c90b02af544331ef1fe28c}{\_\-new\_\-param}
\item 
def \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_ad9738835519febeb368f901e6185df14}{\_\-set\_\-param}
\item 
def \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_a0d41fdb3a505fbc4c37db240d67c1140}{\_\-add\_\-cls\_\-child}
\item 
def \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_a6490df0f3d3befd9c38994fa46520f70}{\_\-new\_\-port}
\item 
def \hyperlink{classm5_1_1SimObject_1_1MetaSimObject_aed37f2662342d9fb731fb7b3454eda7f}{\_\-cls\_\-get\_\-port\_\-ref}
\end{DoxyCompactItemize}


\subsection{関数}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_a0a990b3ec3889d40889daca9ee5e4695}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!\_\-\_\-getattr\_\-\_\-@{\_\-\_\-getattr\_\-\_\-}}
\index{\_\-\_\-getattr\_\-\_\-@{\_\-\_\-getattr\_\-\_\-}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{\_\-\_\-getattr\_\-\_\-}]{\setlength{\rightskip}{0pt plus 5cm}def \_\-\_\-getattr\_\-\_\- ( {\em cls}, \/   {\em attr})}}
\label{classm5_1_1SimObject_1_1MetaSimObject_a0a990b3ec3889d40889daca9ee5e4695}



\begin{DoxyCode}
360                               :
361         if attr == 'cxx_class_path':
362             return cls.cxx_class.split('::')
363 
364         if attr == 'cxx_class_name':
365             return cls.cxx_class_path[-1]
366 
367         if attr == 'cxx_namespaces':
368             return cls.cxx_class_path[:-1]
369 
370         if cls._values.has_key(attr):
371             return cls._values[attr]
372 
373         if cls._children.has_key(attr):
374             return cls._children[attr]
375 
376         raise AttributeError, \
377               "object '%s' has no attribute '%s'" % (cls.__name__, attr)
378 
    def __str__(cls):
\end{DoxyCode}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_ac775ee34451fdfa742b318538164070e}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!\_\-\_\-init\_\-\_\-@{\_\-\_\-init\_\-\_\-}}
\index{\_\-\_\-init\_\-\_\-@{\_\-\_\-init\_\-\_\-}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{\_\-\_\-init\_\-\_\-}]{\setlength{\rightskip}{0pt plus 5cm}def \_\-\_\-init\_\-\_\- ( {\em cls}, \/   {\em name}, \/   {\em bases}, \/   {\em dict})}}
\label{classm5_1_1SimObject_1_1MetaSimObject_ac775ee34451fdfa742b318538164070e}



\begin{DoxyCode}
171                                         :
172         # calls type.__init__()... I think that's a no-op, but leave
173         # it here just in case it's not.
174         super(MetaSimObject, cls).__init__(name, bases, dict)
175 
176         # initialize required attributes
177 
178         # class-only attributes
179         cls._params = multidict() # param descriptions
180         cls._ports = multidict()  # port descriptions
181 
182         # class or instance attributes
183         cls._values = multidict()   # param values
184         cls._children = multidict() # SimObject children
185         cls._port_refs = multidict() # port ref objects
186         cls._instantiated = False # really instantiated, cloned, or subclassed
187 
188         # We don't support multiple inheritance of sim objects.  If you want
189         # to, you must fix multidict to deal with it properly. Non sim-objects
190         # are ok, though
191         bTotal = 0
192         for c in bases:
193             if isinstance(c, MetaSimObject):
194                 bTotal += 1
195             if bTotal > 1:
196                 raise TypeError, "SimObjects do not support multiple inheritance"
      
197 
198         base = bases[0]
199 
200         # Set up general inheritance via multidicts.  A subclass will
201         # inherit all its settings from the base class.  The only time
202         # the following is not true is when we define the SimObject
203         # class itself (in which case the multidicts have no parent).
204         if isinstance(base, MetaSimObject):
205             cls._base = base
206             cls._params.parent = base._params
207             cls._ports.parent = base._ports
208             cls._values.parent = base._values
209             cls._children.parent = base._children
210             cls._port_refs.parent = base._port_refs
211             # mark base as having been subclassed
212             base._instantiated = True
213         else:
214             cls._base = None
215 
216         # default keyword values
217         if 'type' in cls._value_dict:
218             if 'cxx_class' not in cls._value_dict:
219                 cls._value_dict['cxx_class'] = cls._value_dict['type']
220 
221             cls._value_dict['cxx_type'] = '%s *' % cls._value_dict['cxx_class']
222 
223             if 'cxx_header' not in cls._value_dict:
224                 global noCxxHeader
225                 noCxxHeader = True
226                 warn("No header file specified for SimObject: %s", name)
227 
228         # Export methods are automatically inherited via C++, so we
229         # don't want the method declarations to get inherited on the
230         # python side (and thus end up getting repeated in the wrapped
231         # versions of derived classes).  The code below basicallly
232         # suppresses inheritance by substituting in the base (null)
233         # versions of these methods unless a different version is
234         # explicitly supplied.
235         for method_name in ('export_methods', 'export_method_cxx_predecls',
236                             'export_method_swig_predecls'):
237             if method_name not in cls.__dict__:
238                 base_method = getattr(MetaSimObject, method_name)
239                 m = MethodType(base_method, cls, MetaSimObject)
240                 setattr(cls, method_name, m)
241 
242         # Now process the _value_dict items.  They could be defining
243         # new (or overriding existing) parameters or ports, setting
244         # class keywords (e.g., 'abstract'), or setting parameter
245         # values or port bindings.  The first 3 can only be set when
246         # the class is defined, so we handle them here.  The others
247         # can be set later too, so just emulate that by calling
248         # setattr().
249         for key,val in cls._value_dict.items():
250             # param descriptions
251             if isinstance(val, ParamDesc):
252                 cls._new_param(key, val)
253 
254             # port objects
255             elif isinstance(val, Port):
256                 cls._new_port(key, val)
257 
258             # init-time-only keywords
259             elif cls.init_keywords.has_key(key):
260                 cls._set_keyword(key, val, cls.init_keywords[key])
261 
262             # default: use normal path (ends up in __setattr__)
263             else:
264                 setattr(cls, key, val)
265 
    def _set_keyword(cls, keyword, val, kwtype):
\end{DoxyCode}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_a2f15a4676204349e06bcced484b06b70}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!\_\-\_\-new\_\-\_\-@{\_\-\_\-new\_\-\_\-}}
\index{\_\-\_\-new\_\-\_\-@{\_\-\_\-new\_\-\_\-}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{\_\-\_\-new\_\-\_\-}]{\setlength{\rightskip}{0pt plus 5cm}def \_\-\_\-new\_\-\_\- ( {\em mcls}, \/   {\em name}, \/   {\em bases}, \/   {\em dict})}}
\label{classm5_1_1SimObject_1_1MetaSimObject_a2f15a4676204349e06bcced484b06b70}



\begin{DoxyCode}
146                                         :
147         assert name not in allClasses, "SimObject %s already present" % name
148 
149         # Copy "private" attributes, functions, and classes to the
150         # official dict.  Everything else goes in _init_dict to be
151         # filtered in __init__.
152         cls_dict = {}
153         value_dict = {}
154         for key,val in dict.items():
155             if public_value(key, val):
156                 cls_dict[key] = val
157             else:
158                 # must be a param/port setting
159                 value_dict[key] = val
160         if 'abstract' not in value_dict:
161             value_dict['abstract'] = False
162         if 'cxx_bases' not in value_dict:
163             value_dict['cxx_bases'] = []
164         cls_dict['_value_dict'] = value_dict
165         cls = super(MetaSimObject, mcls).__new__(mcls, name, bases, cls_dict)
166         if 'type' in value_dict:
167             allClasses[name] = cls
168         return cls
169 
170     # subclass initialization
    def __init__(cls, name, bases, dict):
\end{DoxyCode}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_a6287b7a16286568d5442b6e2e90215b5}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!\_\-\_\-setattr\_\-\_\-@{\_\-\_\-setattr\_\-\_\-}}
\index{\_\-\_\-setattr\_\-\_\-@{\_\-\_\-setattr\_\-\_\-}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{\_\-\_\-setattr\_\-\_\-}]{\setlength{\rightskip}{0pt plus 5cm}def \_\-\_\-setattr\_\-\_\- ( {\em cls}, \/   {\em attr}, \/   {\em value})}}
\label{classm5_1_1SimObject_1_1MetaSimObject_a6287b7a16286568d5442b6e2e90215b5}



\begin{DoxyCode}
325                                      :
326         # normal processing for private attributes
327         if public_value(attr, value):
328             type.__setattr__(cls, attr, value)
329             return
330 
331         if cls.keywords.has_key(attr):
332             cls._set_keyword(attr, value, cls.keywords[attr])
333             return
334 
335         if cls._ports.has_key(attr):
336             cls._cls_get_port_ref(attr).connect(value)
337             return
338 
339         if isSimObjectOrSequence(value) and cls._instantiated:
340             raise RuntimeError, \
341                   "cannot set SimObject parameter '%s' after\n" \
342                   "    class %s has been instantiated or subclassed" \
343                   % (attr, cls.__name__)
344 
345         # check for param
346         param = cls._params.get(attr)
347         if param:
348             cls._set_param(attr, value, param)
349             return
350 
351         if isSimObjectOrSequence(value):
352             # If RHS is a SimObject, it's an implicit child assignment.
353             cls._add_cls_child(attr, coerceSimObjectOrVector(value))
354             return
355 
356         # no valid assignment... raise exception
357         raise AttributeError, \
358               "Class %s has no parameter \'%s\'" % (cls.__name__, attr)
359 
    def __getattr__(cls, attr):
\end{DoxyCode}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_aa7a4b9bc0941308e362738503137460e}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!\_\-\_\-str\_\-\_\-@{\_\-\_\-str\_\-\_\-}}
\index{\_\-\_\-str\_\-\_\-@{\_\-\_\-str\_\-\_\-}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{\_\-\_\-str\_\-\_\-}]{\setlength{\rightskip}{0pt plus 5cm}def \_\-\_\-str\_\-\_\- ( {\em cls})}}
\label{classm5_1_1SimObject_1_1MetaSimObject_aa7a4b9bc0941308e362738503137460e}



\begin{DoxyCode}
379                     :
380         return cls.__name__
381 
382     # See ParamValue.cxx_predecls for description.
    def cxx_predecls(cls, code):
\end{DoxyCode}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_a0d41fdb3a505fbc4c37db240d67c1140}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!\_\-add\_\-cls\_\-child@{\_\-add\_\-cls\_\-child}}
\index{\_\-add\_\-cls\_\-child@{\_\-add\_\-cls\_\-child}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{\_\-add\_\-cls\_\-child}]{\setlength{\rightskip}{0pt plus 5cm}def \_\-add\_\-cls\_\-child ( {\em cls}, \/   {\em name}, \/   {\em child})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classm5_1_1SimObject_1_1MetaSimObject_a0d41fdb3a505fbc4c37db240d67c1140}



\begin{DoxyCode}
297                                         :
298         # It's a little funky to have a class as a parent, but these
299         # objects should never be instantiated (only cloned, which
300         # clears the parent pointer), and this makes it clear that the
301         # object is not an orphan and can provide better error
302         # messages.
303         child.set_parent(cls, name)
304         cls._children[name] = child
305 
    def _new_port(cls, name, port):
\end{DoxyCode}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_aed37f2662342d9fb731fb7b3454eda7f}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!\_\-cls\_\-get\_\-port\_\-ref@{\_\-cls\_\-get\_\-port\_\-ref}}
\index{\_\-cls\_\-get\_\-port\_\-ref@{\_\-cls\_\-get\_\-port\_\-ref}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{\_\-cls\_\-get\_\-port\_\-ref}]{\setlength{\rightskip}{0pt plus 5cm}def \_\-cls\_\-get\_\-port\_\-ref ( {\em cls}, \/   {\em attr})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classm5_1_1SimObject_1_1MetaSimObject_aed37f2662342d9fb731fb7b3454eda7f}



\begin{DoxyCode}
313                                     :
314         # Return reference that can be assigned to another port
315         # via __setattr__.  There is only ever one reference
316         # object per port, but we create them lazily here.
317         ref = cls._port_refs.get(attr)
318         if not ref:
319             ref = cls._ports[attr].makeRef(cls)
320             cls._port_refs[attr] = ref
321         return ref
322 
323     # Set attribute (called on foo.attr = value when foo is an
324     # instance of class cls).
    def __setattr__(cls, attr, value):
\end{DoxyCode}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_ac8e49572c0c90b02af544331ef1fe28c}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!\_\-new\_\-param@{\_\-new\_\-param}}
\index{\_\-new\_\-param@{\_\-new\_\-param}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{\_\-new\_\-param}]{\setlength{\rightskip}{0pt plus 5cm}def \_\-new\_\-param ( {\em cls}, \/   {\em name}, \/   {\em pdesc})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classm5_1_1SimObject_1_1MetaSimObject_ac8e49572c0c90b02af544331ef1fe28c}



\begin{DoxyCode}
274                                     :
275         # each param desc should be uniquely assigned to one variable
276         assert(not hasattr(pdesc, 'name'))
277         pdesc.name = name
278         cls._params[name] = pdesc
279         if hasattr(pdesc, 'default'):
280             cls._set_param(name, pdesc.default, pdesc)
281 
    def _set_param(cls, name, value, param):
\end{DoxyCode}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_a6490df0f3d3befd9c38994fa46520f70}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!\_\-new\_\-port@{\_\-new\_\-port}}
\index{\_\-new\_\-port@{\_\-new\_\-port}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{\_\-new\_\-port}]{\setlength{\rightskip}{0pt plus 5cm}def \_\-new\_\-port ( {\em cls}, \/   {\em name}, \/   {\em port})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classm5_1_1SimObject_1_1MetaSimObject_a6490df0f3d3befd9c38994fa46520f70}



\begin{DoxyCode}
306                                   :
307         # each port should be uniquely assigned to one variable
308         assert(not hasattr(port, 'name'))
309         port.name = name
310         cls._ports[name] = port
311 
312     # same as _get_port_ref, effectively, but for classes
    def _cls_get_port_ref(cls, attr):
\end{DoxyCode}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_a5abb9e05651c6ebea8a449d8b9f631da}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!\_\-set\_\-keyword@{\_\-set\_\-keyword}}
\index{\_\-set\_\-keyword@{\_\-set\_\-keyword}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{\_\-set\_\-keyword}]{\setlength{\rightskip}{0pt plus 5cm}def \_\-set\_\-keyword ( {\em cls}, \/   {\em keyword}, \/   {\em val}, \/   {\em kwtype})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classm5_1_1SimObject_1_1MetaSimObject_a5abb9e05651c6ebea8a449d8b9f631da}



\begin{DoxyCode}
266                                                :
267         if not isinstance(val, kwtype):
268             raise TypeError, 'keyword %s has bad type %s (expecting %s)' % \
269                   (keyword, type(val), kwtype)
270         if isinstance(val, FunctionType):
271             val = classmethod(val)
272         type.__setattr__(cls, keyword, val)
273 
    def _new_param(cls, name, pdesc):
\end{DoxyCode}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_ad9738835519febeb368f901e6185df14}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!\_\-set\_\-param@{\_\-set\_\-param}}
\index{\_\-set\_\-param@{\_\-set\_\-param}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{\_\-set\_\-param}]{\setlength{\rightskip}{0pt plus 5cm}def \_\-set\_\-param ( {\em cls}, \/   {\em name}, \/   {\em value}, \/   {\em param})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classm5_1_1SimObject_1_1MetaSimObject_ad9738835519febeb368f901e6185df14}



\begin{DoxyCode}
282                                            :
283         assert(param.name == name)
284         try:
285             value = param.convert(value)
286         except Exception, e:
287             msg = "%s\nError setting param %s.%s to %s\n" % \
288                   (e, cls.__name__, name, value)
289             e.args = (msg, )
290             raise
291         cls._values[name] = value
292         # if param value is a SimObject, make it a child too, so that
293         # it gets cloned properly when the class is instantiated
294         if isSimObjectOrVector(value) and not value.has_parent():
295             cls._add_cls_child(name, value)
296 
    def _add_cls_child(cls, name, child):
\end{DoxyCode}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_af533aa789436bfde5727387a36ca9178}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!cxx\_\-param\_\-decl@{cxx\_\-param\_\-decl}}
\index{cxx\_\-param\_\-decl@{cxx\_\-param\_\-decl}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{cxx\_\-param\_\-decl}]{\setlength{\rightskip}{0pt plus 5cm}def cxx\_\-param\_\-decl ( {\em cls}, \/   {\em code})}}
\label{classm5_1_1SimObject_1_1MetaSimObject_af533aa789436bfde5727387a36ca9178}



\begin{DoxyCode}
499                                  :
500         # The 'local' attribute restricts us to the params declared in
501         # the object itself, not including inherited params (which
502         # will also be inherited from the base class's param struct
503         # here).
504         params = cls._params.local.values()
505         ports = cls._ports.local
506         try:
507             ptypes = [p.ptype for p in params]
508         except:
509             print cls, p, p.ptype_str
510             print params
511             raise
512 
513         class_path = cls._value_dict['cxx_class'].split('::')
514 
515         code('''\
516 #ifndef __PARAMS__${cls}__
517 #define __PARAMS__${cls}__
518 
519 ''')
520 
521         # A forward class declaration is sufficient since we are just
522         # declaring a pointer.
523         for ns in class_path[:-1]:
524             code('namespace $ns {')
525         code('class $0;', class_path[-1])
526         for ns in reversed(class_path[:-1]):
527             code('} // namespace $ns')
528         code()
529 
530         # The base SimObject has a couple of params that get
531         # automatically set from Python without being declared through
532         # the normal Param mechanism; we slip them in here (needed
533         # predecls now, actual declarations below)
534         if cls == SimObject:
535             code('''
536 #ifndef PY_VERSION
537 struct PyObject;
538 #endif
539 
540 #include <string>
541 ''')
542         for param in params:
543             param.cxx_predecls(code)
544         for port in ports.itervalues():
545             port.cxx_predecls(code)
546         code()
547 
548         if cls._base:
549             code('#include "params/${{cls._base.type}}.hh"')
550             code()
551 
552         for ptype in ptypes:
553             if issubclass(ptype, Enum):
554                 code('#include "enums/${{ptype.__name__}}.hh"')
555                 code()
556 
557         # now generate the actual param struct
558         code("struct ${cls}Params")
559         if cls._base:
560             code("    : public ${{cls._base.type}}Params")
561         code("{")
562         if not hasattr(cls, 'abstract') or not cls.abstract:
563             if 'type' in cls.__dict__:
564                 code("    ${{cls.cxx_type}} create();")
565 
566         code.indent()
567         if cls == SimObject:
568             code('''
569     SimObjectParams() {}
570     virtual ~SimObjectParams() {}
571 
572     std::string name;
573     PyObject *pyobj;
574             ''')
575         for param in params:
576             param.cxx_decl(code)
577         for port in ports.itervalues():
578             port.cxx_decl(code)
579 
580         code.dedent()
581         code('};')
582 
583         code()
584         code('#endif // __PARAMS__${cls}__')
585         return code
586 
587 
588 # This *temporary* definition is required to support calls from the
589 # SimObject class definition to the MetaSimObject methods (in
590 # particular _set_param, which gets called for parameters with default
591 # values defined on the SimObject class itself).  It will get
592 # overridden by the permanent definition (which requires that
593 # SimObject be defined) lower in this file.
def isSimObjectOrVector(value):
\end{DoxyCode}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_a0b408a11a14bd1d770e28f71a6e14ab5}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!cxx\_\-predecls@{cxx\_\-predecls}}
\index{cxx\_\-predecls@{cxx\_\-predecls}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{cxx\_\-predecls}]{\setlength{\rightskip}{0pt plus 5cm}def cxx\_\-predecls ( {\em cls}, \/   {\em code})}}
\label{classm5_1_1SimObject_1_1MetaSimObject_a0b408a11a14bd1d770e28f71a6e14ab5}



\begin{DoxyCode}
383                                :
384         code('#include "params/$cls.hh"')
385 
386     # See ParamValue.swig_predecls for description.
    def swig_predecls(cls, code):
\end{DoxyCode}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_a4c94af862ca1bc3ebde2094d5e778ef1}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!export\_\-method\_\-cxx\_\-predecls@{export\_\-method\_\-cxx\_\-predecls}}
\index{export\_\-method\_\-cxx\_\-predecls@{export\_\-method\_\-cxx\_\-predecls}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{export\_\-method\_\-cxx\_\-predecls}]{\setlength{\rightskip}{0pt plus 5cm}def export\_\-method\_\-cxx\_\-predecls ( {\em cls}, \/   {\em code})}}
\label{classm5_1_1SimObject_1_1MetaSimObject_a4c94af862ca1bc3ebde2094d5e778ef1}



\begin{DoxyCode}
400                                              :
401         pass
402 
403     # Generate the code needed as a prerequisite for the C++ methods
404     # exported via export_methods() to be processed by SWIG.
405     # Typically generates one or more %include or %import statements.
406     # If any methods are exported, typically at least the C++ header
407     # declaring the relevant SimObject class must be included.
    def export_method_swig_predecls(cls, code):
\end{DoxyCode}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_ac19f60f4d41b7b37c7f282db24e5d743}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!export\_\-method\_\-swig\_\-predecls@{export\_\-method\_\-swig\_\-predecls}}
\index{export\_\-method\_\-swig\_\-predecls@{export\_\-method\_\-swig\_\-predecls}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{export\_\-method\_\-swig\_\-predecls}]{\setlength{\rightskip}{0pt plus 5cm}def export\_\-method\_\-swig\_\-predecls ( {\em cls}, \/   {\em code})}}
\label{classm5_1_1SimObject_1_1MetaSimObject_ac19f60f4d41b7b37c7f282db24e5d743}



\begin{DoxyCode}
408                                               :
409         pass
410 
411     # Generate the declaration for this object for wrapping with SWIG.
412     # Generates code that goes into a SWIG .i file.  Called from
413     # src/SConscript.
    def swig_decl(cls, code):
\end{DoxyCode}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_ab373c5eaef9a7b80491a097389260f4a}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!export\_\-methods@{export\_\-methods}}
\index{export\_\-methods@{export\_\-methods}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{export\_\-methods}]{\setlength{\rightskip}{0pt plus 5cm}def export\_\-methods ( {\em cls}, \/   {\em code})}}
\label{classm5_1_1SimObject_1_1MetaSimObject_ab373c5eaef9a7b80491a097389260f4a}



\begin{DoxyCode}
392                                  :
393         pass
394 
395     # Generate the code needed as a prerequisite for the C++ methods
396     # exported via export_methods() to be compiled in the _wrap.cc
397     # file.  Typically generates one or more #include statements.  If
398     # any methods are exported, typically at least the C++ header
399     # declaring the relevant SimObject class must be included.
    def export_method_cxx_predecls(cls, code):
\end{DoxyCode}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_a83526365333b680bfcbd9b037527cc25}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!swig\_\-decl@{swig\_\-decl}}
\index{swig\_\-decl@{swig\_\-decl}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{swig\_\-decl}]{\setlength{\rightskip}{0pt plus 5cm}def swig\_\-decl ( {\em cls}, \/   {\em code})}}
\label{classm5_1_1SimObject_1_1MetaSimObject_a83526365333b680bfcbd9b037527cc25}



\begin{DoxyCode}
414                             :
415         class_path = cls.cxx_class.split('::')
416         classname = class_path[-1]
417         namespaces = class_path[:-1]
418 
419         # The 'local' attribute restricts us to the params declared in
420         # the object itself, not including inherited params (which
421         # will also be inherited from the base class's param struct
422         # here).
423         params = cls._params.local.values()
424         ports = cls._ports.local
425 
426         code('%module(package="m5.internal") param_$cls')
427         code()
428         code('%{')
429         code('#include "sim/sim_object.hh"')
430         code('#include "params/$cls.hh"')
431         for param in params:
432             param.cxx_predecls(code)
433         code('#include "${{cls.cxx_header}}"')
434         cls.export_method_cxx_predecls(code)
435         code('''\
436 /**
437   * This is a workaround for bug in swig. Prior to gcc 4.6.1 the STL
438   * headers like vector, string, etc. used to automatically pull in
439   * the cstddef header but starting with gcc 4.6.1 they no longer do.
440   * This leads to swig generated a file that does not compile so we
441   * explicitly include cstddef. Additionally, including version 2.0.4,
442   * swig uses ptrdiff_t without the std:: namespace prefix which is
443   * required with gcc 4.6.1. We explicitly provide access to it.
444   */
445 #include <cstddef>
446 using std::ptrdiff_t;
447 ''')
448         code('%}')
449         code()
450 
451         for param in params:
452             param.swig_predecls(code)
453         cls.export_method_swig_predecls(code)
454 
455         code()
456         if cls._base:
457             code('%import "python/m5/internal/param_${{cls._base}}.i"')
458         code()
459 
460         for ns in namespaces:
461             code('namespace $ns {')
462 
463         if namespaces:
464             code('// avoid name conflicts')
465             sep_string = '_COLONS_'
466             flat_name = sep_string.join(class_path)
467             code('%rename($flat_name) $classname;')
468 
469         code()
470         code('// stop swig from creating/wrapping default ctor/dtor')
471         code('%nodefault $classname;')
472         code('class $classname')
473         if cls._base:
474             bases = [ cls._base.cxx_class ] + cls.cxx_bases
475         else:
476             bases = cls.cxx_bases
477         base_first = True
478         for base in bases:
479             if base_first:
480                 code('    : public ${{base}}')
481                 base_first = False
482             else:
483                 code('    , public ${{base}}')
484 
485         code('{')
486         code('  public:')
487         cls.export_methods(code)
488         code('};')
489 
490         for ns in reversed(namespaces):
491             code('} // namespace $ns')
492 
493         code()
494         code('%include "params/$cls.hh"')
495 
496 
497     # Generate the C++ declaration (.hh file) for this SimObject's
498     # param struct.  Called from src/SConscript.
    def cxx_param_decl(cls, code):
\end{DoxyCode}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_ab3dbcf5716623eac67a8ccc074fa7e13}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!swig\_\-predecls@{swig\_\-predecls}}
\index{swig\_\-predecls@{swig\_\-predecls}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{swig\_\-predecls}]{\setlength{\rightskip}{0pt plus 5cm}def swig\_\-predecls ( {\em cls}, \/   {\em code})}}
\label{classm5_1_1SimObject_1_1MetaSimObject_ab3dbcf5716623eac67a8ccc074fa7e13}



\begin{DoxyCode}
387                                 :
388         code('%import "python/m5/internal/param_$cls.i"')
389 
390     # Hook for exporting additional C++ methods to Python via SWIG.
391     # Default is none, override using @classmethod in class definition.
    def export_methods(cls, code):
\end{DoxyCode}


\subsection{変数}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_a608ecb4a2947d6894ab9594d7f59f0a8}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!init\_\-keywords@{init\_\-keywords}}
\index{init\_\-keywords@{init\_\-keywords}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{init\_\-keywords}]{\setlength{\rightskip}{0pt plus 5cm}dictionary {\bf init\_\-keywords}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classm5_1_1SimObject_1_1MetaSimObject_a608ecb4a2947d6894ab9594d7f59f0a8}
{\bfseries 初期値:}
\begin{DoxyCode}
{ 'abstract' : bool,
                      'cxx_class' : str,
                      'cxx_type' : str,
                      'cxx_header' : str,
                      'type' : str,
                      'cxx_bases' : list }
\end{DoxyCode}
\hypertarget{classm5_1_1SimObject_1_1MetaSimObject_a834325b701200b492fc4d7422529cc70}{
\index{m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}!keywords@{keywords}}
\index{keywords@{keywords}!m5::SimObject::MetaSimObject@{m5::SimObject::MetaSimObject}}
\subsubsection[{keywords}]{\setlength{\rightskip}{0pt plus 5cm}dictionary {\bf keywords} = \{ 'check' : FunctionType \}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classm5_1_1SimObject_1_1MetaSimObject_a834325b701200b492fc4d7422529cc70}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
python/m5/\hyperlink{SimObject_8py}{SimObject.py}\end{DoxyCompactItemize}
