\hypertarget{classAbstractController}{
\section{クラス AbstractController}
\label{classAbstractController}\index{AbstractController@{AbstractController}}
}


{\ttfamily \#include $<$AbstractController.hh$>$}AbstractControllerに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4cm]{classAbstractController}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classAbstractController_1_1StatsCallback}{StatsCallback}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef RubyControllerParams \hyperlink{classAbstractController_a8dd24df4fce13403813bb4f7243a3b13}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classAbstractController_a59d22e188a5f6fde018cb048098296d5}{AbstractController} (const \hyperlink{classAbstractController_a8dd24df4fce13403813bb4f7243a3b13}{Params} $\ast$p)
\item 
void \hyperlink{classAbstractController_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
const \hyperlink{classAbstractController_a8dd24df4fce13403813bb4f7243a3b13}{Params} $\ast$ \hyperlink{classAbstractController_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
const \hyperlink{TypeDefines_8hh_a83c14b4ae37e80071f6b3506a6c46151}{NodeID} \hyperlink{classAbstractController_a35b384df19605d0186339f088df677d5}{getVersion} () const 
\item 
const MachineType \hyperlink{classAbstractController_a7a63a33844df1ce5a3b16096dfbbe0f9}{getType} () const 
\item 
void \hyperlink{classAbstractController_a319f9c65d0c91a62be0c99b53a702e8d}{initNetworkPtr} (\hyperlink{classNetwork}{Network} $\ast$net\_\-ptr)
\item 
void \hyperlink{classAbstractController_af682f6c6bb8d16137c284112954156fb}{blockOnQueue} (\hyperlink{classAddress}{Address}, \hyperlink{classMessageBuffer}{MessageBuffer} $\ast$)
\item 
void \hyperlink{classAbstractController_a6da828f9409955e467e80f6d5290fcfd}{unblock} (\hyperlink{classAddress}{Address})
\item 
virtual \hyperlink{classMessageBuffer}{MessageBuffer} $\ast$ \hyperlink{classAbstractController_a80b4b6fca935f6914fd15ea5715e2170}{getMandatoryQueue} () const =0
\item 
virtual const std::string \hyperlink{classAbstractController_adb24cab1ca6d817bdcdef245731b8b77}{toString} () const =0
\item 
virtual AccessPermission \hyperlink{classAbstractController_ab14bc832dc06fbcb264f043d44a8915c}{getAccessPermission} (const \hyperlink{classAddress}{Address} \&addr)=0
\item 
virtual \hyperlink{classDataBlock}{DataBlock} \& \hyperlink{classAbstractController_ae014657139e530ad9d75dfd8f52302a4}{getDataBlock} (const \hyperlink{classAddress}{Address} \&addr)=0
\item 
virtual void \hyperlink{classAbstractController_a3ea5f7af5db62cc24f4e40df9ea5c971}{print} (std::ostream \&out) const =0
\item 
virtual void \hyperlink{classAbstractController_a623e3e7d1b1c725d70009f7b01a421b9}{wakeup} ()=0
\item 
virtual void \hyperlink{classAbstractController_a9820f96c5343e42ad3fcbc97b83f59d5}{resetStats} ()=0
\item 
virtual void \hyperlink{classAbstractController_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
virtual void \hyperlink{classAbstractController_a4ca8c1956ef762ec2219ff377a68c7ba}{recordCacheTrace} (int cntrl, \hyperlink{classCacheRecorder}{CacheRecorder} $\ast$tr)=0
\item 
virtual \hyperlink{classSequencer}{Sequencer} $\ast$ \hyperlink{classAbstractController_ada806654b26aababb417afe9bfbf66e5}{getSequencer} () const =0
\item 
virtual bool \hyperlink{classAbstractController_ab4c57c1f46545be8cb011b32d4949330}{functionalReadBuffers} (\hyperlink{classPacket}{PacketPtr} \&)=0
\item 
virtual \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classAbstractController_a87a5fc3e2b5c5e1813ed7ed3ef1689ae}{functionalWriteBuffers} (\hyperlink{classPacket}{PacketPtr} \&)=0
\item 
virtual void \hyperlink{classAbstractController_a4498badc3fa7137b6d66736d302623ae}{enqueuePrefetch} (const \hyperlink{classAddress}{Address} \&, const RubyRequestType \&)
\begin{DoxyCompactList}\small\item\em Function for enqueuing a prefetch request. \item\end{DoxyCompactList}\item 
virtual void \hyperlink{classAbstractController_ae3089fd60541650eefd9605c2c1abc68}{collateStats} ()
\item 
\hyperlink{structMachineID}{MachineID} \hyperlink{classAbstractController_abaec6aa0c0c0f1d34472f0b3702d86c4}{getMachineID} () const 
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \& \hyperlink{classAbstractController_a8c0950c725a8898f340f7b267ff208be}{getDelayHist} ()
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \& \hyperlink{classAbstractController_a2fc801bc03037a99f6689b7d1bb4eda9}{getDelayVCHist} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} index)
\item 
\hyperlink{classMessageBuffer}{MessageBuffer} $\ast$ \hyperlink{classAbstractController_a3a55ba724e099baf8906b6ba1a943b52}{getPeerQueue} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} pid)
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMessageBuffer}{MessageBuffer} $\ast$ $>$ \hyperlink{classAbstractController_a7c9a43de9f27c3319add6df9c0d2e948}{MsgVecType}
\item 
typedef std::map$<$ \hyperlink{classAddress}{Address}, \hyperlink{classstd_1_1vector}{MsgVecType} $\ast$ $>$ \hyperlink{classAbstractController_afcfa4bb0b120bb22dce11fc367b702af}{WaitingBufType}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classAbstractController_a8bb6029436f36f339582bda79270fa10}{profileRequest} (const std::string \&request)
\begin{DoxyCompactList}\small\item\em Profiles original cache requests including PUTs. \item\end{DoxyCompactList}\item 
void \hyperlink{classAbstractController_a6bc3835966ece2b6fb72a056f447a68e}{profileMsgDelay} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} virtualNetwork, \hyperlink{classCycles}{Cycles} delay)
\begin{DoxyCompactList}\small\item\em Profiles the delay associated with messages. \item\end{DoxyCompactList}\item 
void \hyperlink{classAbstractController_a8d382287e22ac84bc108ad9ea6621603}{connectWithPeer} (\hyperlink{classAbstractController}{AbstractController} $\ast$)
\begin{DoxyCompactList}\small\item\em Function for connecting peer controllers. \item\end{DoxyCompactList}\item 
virtual void \hyperlink{classAbstractController_a9a66179697aa43bfa97cee9cf8dbad19}{getQueuesFromPeer} (\hyperlink{classAbstractController}{AbstractController} $\ast$)
\item 
void \hyperlink{classAbstractController_a4f512122c5d5042bb9da1a0d1fb4c920}{stallBuffer} (\hyperlink{classMessageBuffer}{MessageBuffer} $\ast$buf, \hyperlink{classAddress}{Address} addr)
\item 
void \hyperlink{classAbstractController_aa205de64042612c18d6104532fc72024}{wakeUpBuffers} (\hyperlink{classAddress}{Address} addr)
\item 
void \hyperlink{classAbstractController_ac01a761bbe6f761c62b6f5ff72ab1c3f}{wakeUpAllBuffers} (\hyperlink{classAddress}{Address} addr)
\item 
void \hyperlink{classAbstractController_aa595bebc4acf9a8dfec0b5a99f0b86e2}{wakeUpAllBuffers} ()
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{TypeDefines_8hh_a83c14b4ae37e80071f6b3506a6c46151}{NodeID} \hyperlink{classAbstractController_aa54fd03777fe9911cb24303071f918c7}{m\_\-version}
\item 
\hyperlink{structMachineID}{MachineID} \hyperlink{classAbstractController_a4d3bc5bdeb83c6982ed2341fa055ae19}{m\_\-machineID}
\item 
\hyperlink{TypeDefines_8hh_a83c14b4ae37e80071f6b3506a6c46151}{NodeID} \hyperlink{classAbstractController_a5fddc9f932bac7163c96fc4ccf27790c}{m\_\-clusterID}
\item 
\hyperlink{classNetwork}{Network} $\ast$ \hyperlink{classAbstractController_a6ffbec7c57469120487119d74fb1fae7}{m\_\-net\_\-ptr}
\item 
bool \hyperlink{classAbstractController_a0ea33ffe10dd66af8bdd7928b4d953b5}{m\_\-is\_\-blocking}
\item 
std::map$<$ \hyperlink{classAddress}{Address}, \hyperlink{classMessageBuffer}{MessageBuffer} $\ast$ $>$ \hyperlink{classAbstractController_ad9f87101fff45853a32f5fe42f9d43b0}{m\_\-block\_\-map}
\item 
\hyperlink{classAbstractController_afcfa4bb0b120bb22dce11fc367b702af}{WaitingBufType} \hyperlink{classAbstractController_a90f25dd5a7f1085002cab4e1e98f9232}{m\_\-waiting\_\-buffers}
\item 
unsigned int \hyperlink{classAbstractController_af686856d627ada54f36461fd10bc0371}{m\_\-in\_\-ports}
\item 
unsigned int \hyperlink{classAbstractController_aef85e61fde66cb7b942c755043b43520}{m\_\-cur\_\-in\_\-port}
\item 
int \hyperlink{classAbstractController_a9fe046cc3878d0da925915f0f90ab8c2}{m\_\-number\_\-of\_\-TBEs}
\item 
int \hyperlink{classAbstractController_a3fa70d035aed57776ef789fbdafa7276}{m\_\-transitions\_\-per\_\-cycle}
\item 
unsigned int \hyperlink{classAbstractController_a71fd0f20cbb3b3edc07df4aeb43b6b98}{m\_\-buffer\_\-size}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classAbstractController_a896a9ceedfb77c22a82b490f05ae4624}{m\_\-recycle\_\-latency}
\item 
std::map$<$ \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t}, \hyperlink{classMessageBuffer}{MessageBuffer} $\ast$ $>$ \hyperlink{classAbstractController_ab2e155eabfce9e3d4b821328ecb302f9}{peerQueueMap}
\begin{DoxyCompactList}\small\item\em Map from physical network number to the \hyperlink{classMessage}{Message} \hyperlink{classBuffer}{Buffer}. \item\end{DoxyCompactList}\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classAbstractController_a0de33847c40bca29af78bf6c48a40e0c}{m\_\-fully\_\-busy\_\-cycles}
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \hyperlink{classAbstractController_a32315b21a536469475414901e05bfe36}{m\_\-delayHistogram}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classStats_1_1Histogram}{Stats::Histogram} $\ast$ $>$ \hyperlink{classAbstractController_aba317e33c2fc730b07d01be02e743bd7}{m\_\-delayVCHistogram}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classAbstractController_a7c9a43de9f27c3319add6df9c0d2e948}{
\index{AbstractController@{AbstractController}!MsgVecType@{MsgVecType}}
\index{MsgVecType@{MsgVecType}!AbstractController@{AbstractController}}
\subsubsection[{MsgVecType}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::vector}$<${\bf MessageBuffer}$\ast$$>$ {\bf MsgVecType}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_a7c9a43de9f27c3319add6df9c0d2e948}
\hypertarget{classAbstractController_a8dd24df4fce13403813bb4f7243a3b13}{
\index{AbstractController@{AbstractController}!Params@{Params}}
\index{Params@{Params}!AbstractController@{AbstractController}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef RubyControllerParams {\bf Params}}}
\label{classAbstractController_a8dd24df4fce13403813bb4f7243a3b13}


\hyperlink{classSimObject_a0f0761d2db586a23bb2a2880b8f387bb}{SimObject}を再定義しています。\hypertarget{classAbstractController_afcfa4bb0b120bb22dce11fc367b702af}{
\index{AbstractController@{AbstractController}!WaitingBufType@{WaitingBufType}}
\index{WaitingBufType@{WaitingBufType}!AbstractController@{AbstractController}}
\subsubsection[{WaitingBufType}]{\setlength{\rightskip}{0pt plus 5cm}typedef std::map$<$ {\bf Address}, {\bf MsgVecType}$\ast$ $>$ {\bf WaitingBufType}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_afcfa4bb0b120bb22dce11fc367b702af}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classAbstractController_a59d22e188a5f6fde018cb048098296d5}{
\index{AbstractController@{AbstractController}!AbstractController@{AbstractController}}
\index{AbstractController@{AbstractController}!AbstractController@{AbstractController}}
\subsubsection[{AbstractController}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AbstractController} (const {\bf Params} $\ast$ {\em p})}}
\label{classAbstractController_a59d22e188a5f6fde018cb048098296d5}



\begin{DoxyCode}
34     : ClockedObject(p), Consumer(this)
35 {
36     m_version = p->version;
37     m_clusterID = p->cluster_id;
38 
39     m_transitions_per_cycle = p->transitions_per_cycle;
40     m_buffer_size = p->buffer_size;
41     m_recycle_latency = p->recycle_latency;
42     m_number_of_TBEs = p->number_of_TBEs;
43     m_is_blocking = false;
44 
45     if (m_version == 0) {
46         // Combine the statistics from all controllers
47         // of this particular type.
48         Stats::registerDumpCallback(new StatsCallback(this));
49     }
50 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classAbstractController_af682f6c6bb8d16137c284112954156fb}{
\index{AbstractController@{AbstractController}!blockOnQueue@{blockOnQueue}}
\index{blockOnQueue@{blockOnQueue}!AbstractController@{AbstractController}}
\subsubsection[{blockOnQueue}]{\setlength{\rightskip}{0pt plus 5cm}void blockOnQueue ({\bf Address} {\em addr}, \/  {\bf MessageBuffer} $\ast$ {\em port})}}
\label{classAbstractController_af682f6c6bb8d16137c284112954156fb}



\begin{DoxyCode}
184 {
185     m_is_blocking = true;
186     m_block_map[addr] = port;
187 }
\end{DoxyCode}
\hypertarget{classAbstractController_ae3089fd60541650eefd9605c2c1abc68}{
\index{AbstractController@{AbstractController}!collateStats@{collateStats}}
\index{collateStats@{collateStats}!AbstractController@{AbstractController}}
\subsubsection[{collateStats}]{\setlength{\rightskip}{0pt plus 5cm}virtual void collateStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classAbstractController_ae3089fd60541650eefd9605c2c1abc68}
Function for collating statistics from all the controllers of this particular type. This function should only be called from the version 0 of this controller type. 


\begin{DoxyCode}
99     {fatal("collateStats() should be overridden!");}
\end{DoxyCode}
\hypertarget{classAbstractController_a8d382287e22ac84bc108ad9ea6621603}{
\index{AbstractController@{AbstractController}!connectWithPeer@{connectWithPeer}}
\index{connectWithPeer@{connectWithPeer}!AbstractController@{AbstractController}}
\subsubsection[{connectWithPeer}]{\setlength{\rightskip}{0pt plus 5cm}void connectWithPeer ({\bf AbstractController} $\ast$ {\em c})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_a8d382287e22ac84bc108ad9ea6621603}


Function for connecting peer controllers. 


\begin{DoxyCode}
93 {
94     getQueuesFromPeer(c);
95     c->getQueuesFromPeer(this);
96 }
\end{DoxyCode}
\hypertarget{classAbstractController_a4498badc3fa7137b6d66736d302623ae}{
\index{AbstractController@{AbstractController}!enqueuePrefetch@{enqueuePrefetch}}
\index{enqueuePrefetch@{enqueuePrefetch}!AbstractController@{AbstractController}}
\subsubsection[{enqueuePrefetch}]{\setlength{\rightskip}{0pt plus 5cm}virtual void enqueuePrefetch (const {\bf Address} \&, \/  const RubyRequestType \&)\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classAbstractController_a4498badc3fa7137b6d66736d302623ae}


Function for enqueuing a prefetch request. 


\begin{DoxyCode}
93     { fatal("Prefetches not implemented!");}
\end{DoxyCode}
\hypertarget{classAbstractController_ab4c57c1f46545be8cb011b32d4949330}{
\index{AbstractController@{AbstractController}!functionalReadBuffers@{functionalReadBuffers}}
\index{functionalReadBuffers@{functionalReadBuffers}!AbstractController@{AbstractController}}
\subsubsection[{functionalReadBuffers}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool functionalReadBuffers ({\bf PacketPtr} \&)\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classAbstractController_ab4c57c1f46545be8cb011b32d4949330}
These functions are used by ruby system to read/write the message queues that exist with in the controller. The boolean return value indicates if the read was performed successfully. \hypertarget{classAbstractController_a87a5fc3e2b5c5e1813ed7ed3ef1689ae}{
\index{AbstractController@{AbstractController}!functionalWriteBuffers@{functionalWriteBuffers}}
\index{functionalWriteBuffers@{functionalWriteBuffers}!AbstractController@{AbstractController}}
\subsubsection[{functionalWriteBuffers}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf uint32\_\-t} functionalWriteBuffers ({\bf PacketPtr} \&)\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classAbstractController_a87a5fc3e2b5c5e1813ed7ed3ef1689ae}
The return value indicates the number of messages written with the data from the packet. \hypertarget{classAbstractController_ab14bc832dc06fbcb264f043d44a8915c}{
\index{AbstractController@{AbstractController}!getAccessPermission@{getAccessPermission}}
\index{getAccessPermission@{getAccessPermission}!AbstractController@{AbstractController}}
\subsubsection[{getAccessPermission}]{\setlength{\rightskip}{0pt plus 5cm}virtual AccessPermission getAccessPermission (const {\bf Address} \& {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classAbstractController_ab14bc832dc06fbcb264f043d44a8915c}
\hypertarget{classAbstractController_ae014657139e530ad9d75dfd8f52302a4}{
\index{AbstractController@{AbstractController}!getDataBlock@{getDataBlock}}
\index{getDataBlock@{getDataBlock}!AbstractController@{AbstractController}}
\subsubsection[{getDataBlock}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf DataBlock}\& getDataBlock (const {\bf Address} \& {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classAbstractController_ae014657139e530ad9d75dfd8f52302a4}
\hypertarget{classAbstractController_a8c0950c725a8898f340f7b267ff208be}{
\index{AbstractController@{AbstractController}!getDelayHist@{getDelayHist}}
\index{getDelayHist@{getDelayHist}!AbstractController@{AbstractController}}
\subsubsection[{getDelayHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram}\& getDelayHist ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAbstractController_a8c0950c725a8898f340f7b267ff208be}



\begin{DoxyCode}
104 { return m_delayHistogram; }
\end{DoxyCode}
\hypertarget{classAbstractController_a2fc801bc03037a99f6689b7d1bb4eda9}{
\index{AbstractController@{AbstractController}!getDelayVCHist@{getDelayVCHist}}
\index{getDelayVCHist@{getDelayVCHist}!AbstractController@{AbstractController}}
\subsubsection[{getDelayVCHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram}\& getDelayVCHist ({\bf uint32\_\-t} {\em index})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAbstractController_a2fc801bc03037a99f6689b7d1bb4eda9}



\begin{DoxyCode}
106     { return *(m_delayVCHistogram[index]); }
\end{DoxyCode}
\hypertarget{classAbstractController_abaec6aa0c0c0f1d34472f0b3702d86c4}{
\index{AbstractController@{AbstractController}!getMachineID@{getMachineID}}
\index{getMachineID@{getMachineID}!AbstractController@{AbstractController}}
\subsubsection[{getMachineID}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MachineID} getMachineID () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAbstractController_abaec6aa0c0c0f1d34472f0b3702d86c4}



\begin{DoxyCode}
102 { return m_machineID; }
\end{DoxyCode}
\hypertarget{classAbstractController_a80b4b6fca935f6914fd15ea5715e2170}{
\index{AbstractController@{AbstractController}!getMandatoryQueue@{getMandatoryQueue}}
\index{getMandatoryQueue@{getMandatoryQueue}!AbstractController@{AbstractController}}
\subsubsection[{getMandatoryQueue}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf MessageBuffer}$\ast$ getMandatoryQueue () const\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classAbstractController_a80b4b6fca935f6914fd15ea5715e2170}
\hypertarget{classAbstractController_a3a55ba724e099baf8906b6ba1a943b52}{
\index{AbstractController@{AbstractController}!getPeerQueue@{getPeerQueue}}
\index{getPeerQueue@{getPeerQueue}!AbstractController@{AbstractController}}
\subsubsection[{getPeerQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MessageBuffer}$\ast$ getPeerQueue ({\bf uint32\_\-t} {\em pid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAbstractController_a3a55ba724e099baf8906b6ba1a943b52}



\begin{DoxyCode}
109     {
110         std::map<uint32_t, MessageBuffer *>::iterator it =
111                                         peerQueueMap.find(pid);
112         assert(it != peerQueueMap.end());
113         return (*it).second;
114     }
\end{DoxyCode}
\hypertarget{classAbstractController_a9a66179697aa43bfa97cee9cf8dbad19}{
\index{AbstractController@{AbstractController}!getQueuesFromPeer@{getQueuesFromPeer}}
\index{getQueuesFromPeer@{getQueuesFromPeer}!AbstractController@{AbstractController}}
\subsubsection[{getQueuesFromPeer}]{\setlength{\rightskip}{0pt plus 5cm}virtual void getQueuesFromPeer ({\bf AbstractController} $\ast$)\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classAbstractController_a9a66179697aa43bfa97cee9cf8dbad19}



\begin{DoxyCode}
125     { fatal("getQueuesFromPeer() should be called only if implemented!"); }
\end{DoxyCode}
\hypertarget{classAbstractController_ada806654b26aababb417afe9bfbf66e5}{
\index{AbstractController@{AbstractController}!getSequencer@{getSequencer}}
\index{getSequencer@{getSequencer}!AbstractController@{AbstractController}}
\subsubsection[{getSequencer}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Sequencer}$\ast$ getSequencer () const\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classAbstractController_ada806654b26aababb417afe9bfbf66e5}
\hypertarget{classAbstractController_a7a63a33844df1ce5a3b16096dfbbe0f9}{
\index{AbstractController@{AbstractController}!getType@{getType}}
\index{getType@{getType}!AbstractController@{AbstractController}}
\subsubsection[{getType}]{\setlength{\rightskip}{0pt plus 5cm}const MachineType getType () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAbstractController_a7a63a33844df1ce5a3b16096dfbbe0f9}



\begin{DoxyCode}
60 { return m_machineID.getType(); }
\end{DoxyCode}
\hypertarget{classAbstractController_a35b384df19605d0186339f088df677d5}{
\index{AbstractController@{AbstractController}!getVersion@{getVersion}}
\index{getVersion@{getVersion}!AbstractController@{AbstractController}}
\subsubsection[{getVersion}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf NodeID} getVersion () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAbstractController_a35b384df19605d0186339f088df677d5}



\begin{DoxyCode}
59 { return m_machineID.getNum(); }
\end{DoxyCode}
\hypertarget{classAbstractController_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{AbstractController@{AbstractController}!init@{init}}
\index{init@{init}!AbstractController@{AbstractController}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classAbstractController_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classAbstractController_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{SimObject}を再定義しています。


\begin{DoxyCode}
54 {
55     params()->ruby_system->registerAbstractController(this);
56     m_delayHistogram.init(10);
57     uint32_t size = Network::getNumberOfVirtualNetworks();
58     for (uint32_t i = 0; i < size; i++) {
59         m_delayVCHistogram.push_back(new Stats::Histogram());
60         m_delayVCHistogram[i]->init(10);
61     }
62 }
\end{DoxyCode}
\hypertarget{classAbstractController_a319f9c65d0c91a62be0c99b53a702e8d}{
\index{AbstractController@{AbstractController}!initNetworkPtr@{initNetworkPtr}}
\index{initNetworkPtr@{initNetworkPtr}!AbstractController@{AbstractController}}
\subsubsection[{initNetworkPtr}]{\setlength{\rightskip}{0pt plus 5cm}void initNetworkPtr ({\bf Network} $\ast$ {\em net\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAbstractController_a319f9c65d0c91a62be0c99b53a702e8d}



\begin{DoxyCode}
62 { m_net_ptr = net_ptr; }
\end{DoxyCode}
\hypertarget{classAbstractController_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{AbstractController@{AbstractController}!params@{params}}
\index{params@{params}!AbstractController@{AbstractController}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAbstractController_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classSimObject_acd3c3feb78ae7a8f88fe0f110a718dff}{SimObject}を再定義しています。


\begin{DoxyCode}
57 { return (const Params *)_params; }
\end{DoxyCode}
\hypertarget{classAbstractController_a3ea5f7af5db62cc24f4e40df9ea5c971}{
\index{AbstractController@{AbstractController}!print@{print}}
\index{print@{print}!AbstractController@{AbstractController}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}virtual void print (std::ostream \& {\em out}) const\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classAbstractController_a3ea5f7af5db62cc24f4e40df9ea5c971}


\hyperlink{classConsumer_a3ea5f7af5db62cc24f4e40df9ea5c971}{Consumer}を実装しています。\hypertarget{classAbstractController_a6bc3835966ece2b6fb72a056f447a68e}{
\index{AbstractController@{AbstractController}!profileMsgDelay@{profileMsgDelay}}
\index{profileMsgDelay@{profileMsgDelay}!AbstractController@{AbstractController}}
\subsubsection[{profileMsgDelay}]{\setlength{\rightskip}{0pt plus 5cm}void profileMsgDelay ({\bf uint32\_\-t} {\em virtualNetwork}, \/  {\bf Cycles} {\em delay})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_a6bc3835966ece2b6fb72a056f447a68e}


Profiles the delay associated with messages. 


\begin{DoxyCode}
85 {
86     assert(virtualNetwork < m_delayVCHistogram.size());
87     m_delayHistogram.sample(delay);
88     m_delayVCHistogram[virtualNetwork]->sample(delay);
89 }
\end{DoxyCode}
\hypertarget{classAbstractController_a8bb6029436f36f339582bda79270fa10}{
\index{AbstractController@{AbstractController}!profileRequest@{profileRequest}}
\index{profileRequest@{profileRequest}!AbstractController@{AbstractController}}
\subsubsection[{profileRequest}]{\setlength{\rightskip}{0pt plus 5cm}void profileRequest (const std::string \& {\em request})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_a8bb6029436f36f339582bda79270fa10}


Profiles original cache requests including PUTs. \hypertarget{classAbstractController_a4ca8c1956ef762ec2219ff377a68c7ba}{
\index{AbstractController@{AbstractController}!recordCacheTrace@{recordCacheTrace}}
\index{recordCacheTrace@{recordCacheTrace}!AbstractController@{AbstractController}}
\subsubsection[{recordCacheTrace}]{\setlength{\rightskip}{0pt plus 5cm}virtual void recordCacheTrace (int {\em cntrl}, \/  {\bf CacheRecorder} $\ast$ {\em tr})\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classAbstractController_a4ca8c1956ef762ec2219ff377a68c7ba}
\hypertarget{classAbstractController_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{AbstractController@{AbstractController}!regStats@{regStats}}
\index{regStats@{regStats}!AbstractController@{AbstractController}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classAbstractController_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} statistics for this object. 

\hyperlink{classSimObject_a4dc637449366fcdfc4e764cdf12d9b11}{SimObject}を再定義しています。


\begin{DoxyCode}
76 {
77     m_fully_busy_cycles
78         .name(name() + ".fully_busy_cycles")
79         .desc("cycles for which number of transistions == max transitions")
80         .flags(Stats::nozero);
81 }
\end{DoxyCode}
\hypertarget{classAbstractController_a9820f96c5343e42ad3fcbc97b83f59d5}{
\index{AbstractController@{AbstractController}!resetStats@{resetStats}}
\index{resetStats@{resetStats}!AbstractController@{AbstractController}}
\subsubsection[{resetStats}]{\setlength{\rightskip}{0pt plus 5cm}void resetStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classAbstractController_a9820f96c5343e42ad3fcbc97b83f59d5}
Reset statistics associated with this object. 

\hyperlink{classSimObject_a65880e61108132689a1bd769b9187fb7}{SimObject}を再定義しています。


\begin{DoxyCode}
66 {
67     m_delayHistogram.reset();
68     uint32_t size = Network::getNumberOfVirtualNetworks();
69     for (uint32_t i = 0; i < size; i++) {
70         m_delayVCHistogram[i]->reset();
71     }
72 }
\end{DoxyCode}
\hypertarget{classAbstractController_a4f512122c5d5042bb9da1a0d1fb4c920}{
\index{AbstractController@{AbstractController}!stallBuffer@{stallBuffer}}
\index{stallBuffer@{stallBuffer}!AbstractController@{AbstractController}}
\subsubsection[{stallBuffer}]{\setlength{\rightskip}{0pt plus 5cm}void stallBuffer ({\bf MessageBuffer} $\ast$ {\em buf}, \/  {\bf Address} {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_a4f512122c5d5042bb9da1a0d1fb4c920}



\begin{DoxyCode}
100 {
101     if (m_waiting_buffers.count(addr) == 0) {
102         MsgVecType* msgVec = new MsgVecType;
103         msgVec->resize(m_in_ports, NULL);
104         m_waiting_buffers[addr] = msgVec;
105     }
106     (*(m_waiting_buffers[addr]))[m_cur_in_port] = buf;
107 }
\end{DoxyCode}
\hypertarget{classAbstractController_adb24cab1ca6d817bdcdef245731b8b77}{
\index{AbstractController@{AbstractController}!toString@{toString}}
\index{toString@{toString}!AbstractController@{AbstractController}}
\subsubsection[{toString}]{\setlength{\rightskip}{0pt plus 5cm}virtual const std::string toString () const\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classAbstractController_adb24cab1ca6d817bdcdef245731b8b77}
\hypertarget{classAbstractController_a6da828f9409955e467e80f6d5290fcfd}{
\index{AbstractController@{AbstractController}!unblock@{unblock}}
\index{unblock@{unblock}!AbstractController@{AbstractController}}
\subsubsection[{unblock}]{\setlength{\rightskip}{0pt plus 5cm}void unblock ({\bf Address} {\em addr})}}
\label{classAbstractController_a6da828f9409955e467e80f6d5290fcfd}



\begin{DoxyCode}
191 {
192     m_block_map.erase(addr);
193     if (m_block_map.size() == 0) {
194        m_is_blocking = false;
195     }
196 }
\end{DoxyCode}
\hypertarget{classAbstractController_a623e3e7d1b1c725d70009f7b01a421b9}{
\index{AbstractController@{AbstractController}!wakeup@{wakeup}}
\index{wakeup@{wakeup}!AbstractController@{AbstractController}}
\subsubsection[{wakeup}]{\setlength{\rightskip}{0pt plus 5cm}virtual void wakeup ()\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classAbstractController_a623e3e7d1b1c725d70009f7b01a421b9}


\hyperlink{classConsumer_a623e3e7d1b1c725d70009f7b01a421b9}{Consumer}を実装しています。\hypertarget{classAbstractController_aa595bebc4acf9a8dfec0b5a99f0b86e2}{
\index{AbstractController@{AbstractController}!wakeUpAllBuffers@{wakeUpAllBuffers}}
\index{wakeUpAllBuffers@{wakeUpAllBuffers}!AbstractController@{AbstractController}}
\subsubsection[{wakeUpAllBuffers}]{\setlength{\rightskip}{0pt plus 5cm}void wakeUpAllBuffers ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_aa595bebc4acf9a8dfec0b5a99f0b86e2}



\begin{DoxyCode}
151 {
152     //
153     // Wake up all possible buffers that could be waiting on any message.
154     //
155 
156     std::vector<MsgVecType*> wokeUpMsgVecs;
157 
158     if(m_waiting_buffers.size() > 0) {
159         for (WaitingBufType::iterator buf_iter = m_waiting_buffers.begin();
160              buf_iter != m_waiting_buffers.end();
161              ++buf_iter) {
162              for (MsgVecType::iterator vec_iter = buf_iter->second->begin();
163                   vec_iter != buf_iter->second->end();
164                   ++vec_iter) {
165                   if (*vec_iter != NULL) {
166                       (*vec_iter)->reanalyzeAllMessages();
167                   }
168              }
169              wokeUpMsgVecs.push_back(buf_iter->second);
170         }
171 
172         for (std::vector<MsgVecType*>::iterator wb_iter = wokeUpMsgVecs.begin();
173              wb_iter != wokeUpMsgVecs.end();
174              ++wb_iter) {
175              delete (*wb_iter);
176         }
177 
178         m_waiting_buffers.clear();
179     }
180 }
\end{DoxyCode}
\hypertarget{classAbstractController_ac01a761bbe6f761c62b6f5ff72ab1c3f}{
\index{AbstractController@{AbstractController}!wakeUpAllBuffers@{wakeUpAllBuffers}}
\index{wakeUpAllBuffers@{wakeUpAllBuffers}!AbstractController@{AbstractController}}
\subsubsection[{wakeUpAllBuffers}]{\setlength{\rightskip}{0pt plus 5cm}void wakeUpAllBuffers ({\bf Address} {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_ac01a761bbe6f761c62b6f5ff72ab1c3f}



\begin{DoxyCode}
131 {
132     if (m_waiting_buffers.count(addr) > 0) {
133         //
134         // Wake up all possible lower rank (i.e. lower priority) buffers that cou
      ld
135         // be waiting on this message.
136         //
137         for (int in_port_rank = m_in_ports - 1;
138              in_port_rank >= 0;
139              in_port_rank--) {
140             if ((*(m_waiting_buffers[addr]))[in_port_rank] != NULL) {
141                 (*(m_waiting_buffers[addr]))[in_port_rank]->reanalyzeMessages(add
      r);
142             }
143         }
144         delete m_waiting_buffers[addr];
145         m_waiting_buffers.erase(addr);
146     }
147 }
\end{DoxyCode}
\hypertarget{classAbstractController_aa205de64042612c18d6104532fc72024}{
\index{AbstractController@{AbstractController}!wakeUpBuffers@{wakeUpBuffers}}
\index{wakeUpBuffers@{wakeUpBuffers}!AbstractController@{AbstractController}}
\subsubsection[{wakeUpBuffers}]{\setlength{\rightskip}{0pt plus 5cm}void wakeUpBuffers ({\bf Address} {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_aa205de64042612c18d6104532fc72024}



\begin{DoxyCode}
111 {
112     if (m_waiting_buffers.count(addr) > 0) {
113         //
114         // Wake up all possible lower rank (i.e. lower priority) buffers that cou
      ld
115         // be waiting on this message.
116         //
117         for (int in_port_rank = m_cur_in_port - 1;
118              in_port_rank >= 0;
119              in_port_rank--) {
120             if ((*(m_waiting_buffers[addr]))[in_port_rank] != NULL) {
121                 (*(m_waiting_buffers[addr]))[in_port_rank]->reanalyzeMessages(add
      r);
122             }
123         }
124         delete m_waiting_buffers[addr];
125         m_waiting_buffers.erase(addr);
126     }
127 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classAbstractController_ad9f87101fff45853a32f5fe42f9d43b0}{
\index{AbstractController@{AbstractController}!m\_\-block\_\-map@{m\_\-block\_\-map}}
\index{m\_\-block\_\-map@{m\_\-block\_\-map}!AbstractController@{AbstractController}}
\subsubsection[{m\_\-block\_\-map}]{\setlength{\rightskip}{0pt plus 5cm}std::map$<${\bf Address}, {\bf MessageBuffer}$\ast$$>$ {\bf m\_\-block\_\-map}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_ad9f87101fff45853a32f5fe42f9d43b0}
\hypertarget{classAbstractController_a71fd0f20cbb3b3edc07df4aeb43b6b98}{
\index{AbstractController@{AbstractController}!m\_\-buffer\_\-size@{m\_\-buffer\_\-size}}
\index{m\_\-buffer\_\-size@{m\_\-buffer\_\-size}!AbstractController@{AbstractController}}
\subsubsection[{m\_\-buffer\_\-size}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf m\_\-buffer\_\-size}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_a71fd0f20cbb3b3edc07df4aeb43b6b98}
\hypertarget{classAbstractController_a5fddc9f932bac7163c96fc4ccf27790c}{
\index{AbstractController@{AbstractController}!m\_\-clusterID@{m\_\-clusterID}}
\index{m\_\-clusterID@{m\_\-clusterID}!AbstractController@{AbstractController}}
\subsubsection[{m\_\-clusterID}]{\setlength{\rightskip}{0pt plus 5cm}{\bf NodeID} {\bf m\_\-clusterID}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_a5fddc9f932bac7163c96fc4ccf27790c}
\hypertarget{classAbstractController_aef85e61fde66cb7b942c755043b43520}{
\index{AbstractController@{AbstractController}!m\_\-cur\_\-in\_\-port@{m\_\-cur\_\-in\_\-port}}
\index{m\_\-cur\_\-in\_\-port@{m\_\-cur\_\-in\_\-port}!AbstractController@{AbstractController}}
\subsubsection[{m\_\-cur\_\-in\_\-port}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf m\_\-cur\_\-in\_\-port}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_aef85e61fde66cb7b942c755043b43520}
\hypertarget{classAbstractController_a32315b21a536469475414901e05bfe36}{
\index{AbstractController@{AbstractController}!m\_\-delayHistogram@{m\_\-delayHistogram}}
\index{m\_\-delayHistogram@{m\_\-delayHistogram}!AbstractController@{AbstractController}}
\subsubsection[{m\_\-delayHistogram}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram} {\bf m\_\-delayHistogram}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_a32315b21a536469475414901e05bfe36}
\hyperlink{classHistogram}{Histogram} for profiling delay for the messages this controller cares for \hypertarget{classAbstractController_aba317e33c2fc730b07d01be02e743bd7}{
\index{AbstractController@{AbstractController}!m\_\-delayVCHistogram@{m\_\-delayVCHistogram}}
\index{m\_\-delayVCHistogram@{m\_\-delayVCHistogram}!AbstractController@{AbstractController}}
\subsubsection[{m\_\-delayVCHistogram}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf Stats::Histogram} $\ast$$>$ {\bf m\_\-delayVCHistogram}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_aba317e33c2fc730b07d01be02e743bd7}
\hypertarget{classAbstractController_a0de33847c40bca29af78bf6c48a40e0c}{
\index{AbstractController@{AbstractController}!m\_\-fully\_\-busy\_\-cycles@{m\_\-fully\_\-busy\_\-cycles}}
\index{m\_\-fully\_\-busy\_\-cycles@{m\_\-fully\_\-busy\_\-cycles}!AbstractController@{AbstractController}}
\subsubsection[{m\_\-fully\_\-busy\_\-cycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf m\_\-fully\_\-busy\_\-cycles}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_a0de33847c40bca29af78bf6c48a40e0c}
Counter for the number of cycles when the transitions carried out were equal to the maximum allowed \hypertarget{classAbstractController_af686856d627ada54f36461fd10bc0371}{
\index{AbstractController@{AbstractController}!m\_\-in\_\-ports@{m\_\-in\_\-ports}}
\index{m\_\-in\_\-ports@{m\_\-in\_\-ports}!AbstractController@{AbstractController}}
\subsubsection[{m\_\-in\_\-ports}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf m\_\-in\_\-ports}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_af686856d627ada54f36461fd10bc0371}
\hypertarget{classAbstractController_a0ea33ffe10dd66af8bdd7928b4d953b5}{
\index{AbstractController@{AbstractController}!m\_\-is\_\-blocking@{m\_\-is\_\-blocking}}
\index{m\_\-is\_\-blocking@{m\_\-is\_\-blocking}!AbstractController@{AbstractController}}
\subsubsection[{m\_\-is\_\-blocking}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf m\_\-is\_\-blocking}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_a0ea33ffe10dd66af8bdd7928b4d953b5}
\hypertarget{classAbstractController_a4d3bc5bdeb83c6982ed2341fa055ae19}{
\index{AbstractController@{AbstractController}!m\_\-machineID@{m\_\-machineID}}
\index{m\_\-machineID@{m\_\-machineID}!AbstractController@{AbstractController}}
\subsubsection[{m\_\-machineID}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MachineID} {\bf m\_\-machineID}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_a4d3bc5bdeb83c6982ed2341fa055ae19}
\hypertarget{classAbstractController_a6ffbec7c57469120487119d74fb1fae7}{
\index{AbstractController@{AbstractController}!m\_\-net\_\-ptr@{m\_\-net\_\-ptr}}
\index{m\_\-net\_\-ptr@{m\_\-net\_\-ptr}!AbstractController@{AbstractController}}
\subsubsection[{m\_\-net\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Network}$\ast$ {\bf m\_\-net\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_a6ffbec7c57469120487119d74fb1fae7}
\hypertarget{classAbstractController_a9fe046cc3878d0da925915f0f90ab8c2}{
\index{AbstractController@{AbstractController}!m\_\-number\_\-of\_\-TBEs@{m\_\-number\_\-of\_\-TBEs}}
\index{m\_\-number\_\-of\_\-TBEs@{m\_\-number\_\-of\_\-TBEs}!AbstractController@{AbstractController}}
\subsubsection[{m\_\-number\_\-of\_\-TBEs}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-number\_\-of\_\-TBEs}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_a9fe046cc3878d0da925915f0f90ab8c2}
\hypertarget{classAbstractController_a896a9ceedfb77c22a82b490f05ae4624}{
\index{AbstractController@{AbstractController}!m\_\-recycle\_\-latency@{m\_\-recycle\_\-latency}}
\index{m\_\-recycle\_\-latency@{m\_\-recycle\_\-latency}!AbstractController@{AbstractController}}
\subsubsection[{m\_\-recycle\_\-latency}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf m\_\-recycle\_\-latency}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_a896a9ceedfb77c22a82b490f05ae4624}
\hypertarget{classAbstractController_a3fa70d035aed57776ef789fbdafa7276}{
\index{AbstractController@{AbstractController}!m\_\-transitions\_\-per\_\-cycle@{m\_\-transitions\_\-per\_\-cycle}}
\index{m\_\-transitions\_\-per\_\-cycle@{m\_\-transitions\_\-per\_\-cycle}!AbstractController@{AbstractController}}
\subsubsection[{m\_\-transitions\_\-per\_\-cycle}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-transitions\_\-per\_\-cycle}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_a3fa70d035aed57776ef789fbdafa7276}
\hypertarget{classAbstractController_aa54fd03777fe9911cb24303071f918c7}{
\index{AbstractController@{AbstractController}!m\_\-version@{m\_\-version}}
\index{m\_\-version@{m\_\-version}!AbstractController@{AbstractController}}
\subsubsection[{m\_\-version}]{\setlength{\rightskip}{0pt plus 5cm}{\bf NodeID} {\bf m\_\-version}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_aa54fd03777fe9911cb24303071f918c7}
\hypertarget{classAbstractController_a90f25dd5a7f1085002cab4e1e98f9232}{
\index{AbstractController@{AbstractController}!m\_\-waiting\_\-buffers@{m\_\-waiting\_\-buffers}}
\index{m\_\-waiting\_\-buffers@{m\_\-waiting\_\-buffers}!AbstractController@{AbstractController}}
\subsubsection[{m\_\-waiting\_\-buffers}]{\setlength{\rightskip}{0pt plus 5cm}{\bf WaitingBufType} {\bf m\_\-waiting\_\-buffers}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_a90f25dd5a7f1085002cab4e1e98f9232}
\hypertarget{classAbstractController_ab2e155eabfce9e3d4b821328ecb302f9}{
\index{AbstractController@{AbstractController}!peerQueueMap@{peerQueueMap}}
\index{peerQueueMap@{peerQueueMap}!AbstractController@{AbstractController}}
\subsubsection[{peerQueueMap}]{\setlength{\rightskip}{0pt plus 5cm}std::map$<${\bf uint32\_\-t}, {\bf MessageBuffer}$\ast$$>$ {\bf peerQueueMap}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractController_ab2e155eabfce9e3d4b821328ecb302f9}


Map from physical network number to the \hyperlink{classMessage}{Message} \hyperlink{classBuffer}{Buffer}. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/ruby/slicc\_\-interface/\hyperlink{AbstractController_8hh}{AbstractController.hh}\item 
mem/ruby/slicc\_\-interface/\hyperlink{AbstractController_8cc}{AbstractController.cc}\end{DoxyCompactItemize}
