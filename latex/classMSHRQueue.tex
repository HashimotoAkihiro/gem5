\hypertarget{classMSHRQueue}{
\section{クラス MSHRQueue}
\label{classMSHRQueue}\index{MSHRQueue@{MSHRQueue}}
}


{\ttfamily \#include $<$mshr\_\-queue.hh$>$}MSHRQueueに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classMSHRQueue}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMSHRQueue_a72708efb7b001e844259a19264e0f275}{MSHRQueue} (const std::string \&\_\-label, int num\_\-entries, int reserve, int \hyperlink{classMSHRQueue_a32b76ccceab9e1bba3e8c4ef2947d1d8}{index})
\item 
\hyperlink{classMSHR}{MSHR} $\ast$ \hyperlink{classMSHRQueue_aab842d63dcd254dfe655e16075f7e0fe}{findMatch} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, bool is\_\-secure) const 
\item 
bool \hyperlink{classMSHRQueue_a020dd5bb628863baf3800f816cfba197}{findMatches} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, bool is\_\-secure, \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMSHR}{MSHR} $\ast$ $>$ \&matches) const 
\item 
\hyperlink{classMSHR}{MSHR} $\ast$ \hyperlink{classMSHRQueue_affbbf09e05a34a8c06a00eeb8425be92}{findPending} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, int size, bool is\_\-secure) const 
\item 
bool \hyperlink{classMSHRQueue_ab1a1044e709a5b00c99cf14430b3ff53}{checkFunctional} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} blk\_\-addr)
\item 
\hyperlink{classMSHR}{MSHR} $\ast$ \hyperlink{classMSHRQueue_a5215a381ac6546c5ef5730b060b38e61}{allocate} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, int size, \hyperlink{classPacket}{PacketPtr} \&pkt, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} when, \hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} order)
\item 
void \hyperlink{classMSHRQueue_a1704942edaee695477bdfc7598bd8ad7}{deallocate} (\hyperlink{classMSHR}{MSHR} $\ast$mshr)
\item 
\hyperlink{classMSHR_af944263ff3027ab76cf07354d3a3f0c6}{MSHR::Iterator} \hyperlink{classMSHRQueue_a8a69fab976c144c9128fec59358d3196}{deallocateOne} (\hyperlink{classMSHR}{MSHR} $\ast$mshr)
\item 
void \hyperlink{classMSHRQueue_a2a53c836e41157cdbf2c19b6fd30e276}{moveToFront} (\hyperlink{classMSHR}{MSHR} $\ast$mshr)
\item 
void \hyperlink{classMSHRQueue_a1131b37f2a7bef3428b45951455cfcad}{markInService} (\hyperlink{classMSHR}{MSHR} $\ast$mshr, \hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classMSHRQueue_ab0f258b25fe50dc16d5e3e5890214c5c}{markPending} (\hyperlink{classMSHR}{MSHR} $\ast$mshr)
\item 
void \hyperlink{classMSHRQueue_a94c2c174856cbab1e3478cb02ae8ed80}{squash} (int threadNum)
\item 
bool \hyperlink{classMSHRQueue_acda43ebd9ff1813951d7d0ab3eaad05c}{forceDeallocateTarget} (\hyperlink{classMSHR}{MSHR} $\ast$mshr)
\item 
bool \hyperlink{classMSHRQueue_aef5fae0b3798035ac6f7ad1ab9038aca}{havePending} () const 
\item 
bool \hyperlink{classMSHRQueue_a7ffe8a6212a0eb3fc7bbc8e9bc51dfcd}{isFull} () const 
\item 
\hyperlink{classMSHR}{MSHR} $\ast$ \hyperlink{classMSHRQueue_a98b9ba341284c5251a7908cd45918066}{getNextMSHR} () const 
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classMSHRQueue_a4601a57ba7740776052541f212c29cbd}{nextMSHRReadyTime} () const 
\item 
unsigned int \hyperlink{classMSHRQueue_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classMSHRQueue_a115235fc25fdf1c03d856bd072b6cead}{allocated}
\item 
int \hyperlink{classMSHRQueue_aa4871243af391ed1f0d5e3f964bc13d0}{inServiceEntries}
\item 
const int \hyperlink{classMSHRQueue_a32b76ccceab9e1bba3e8c4ef2947d1d8}{index}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMSHR_af944263ff3027ab76cf07354d3a3f0c6}{MSHR::Iterator} \hyperlink{classMSHRQueue_a80c2dad36455852eae13562756599fa4}{addToReadyList} (\hyperlink{classMSHR}{MSHR} $\ast$mshr)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
const std::string \hyperlink{classMSHRQueue_ae471a4c4073716b769170188214fe93d}{label}
\item 
const int \hyperlink{classMSHRQueue_aac2a0fada965c3dd6220aeb40a28c587}{numEntries}
\item 
const int \hyperlink{classMSHRQueue_a2c97f85062902d3990c3a9c163306547}{numReserve}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMSHR}{MSHR} $>$ \hyperlink{classMSHRQueue_a61e75efe923d1fa4bbb72f426a219b7e}{registers}
\item 
\hyperlink{classstd_1_1list}{MSHR::List} \hyperlink{classMSHRQueue_a4bac1d00b2059c983d4afaf4df82f4ac}{allocatedList}
\item 
\hyperlink{classstd_1_1list}{MSHR::List} \hyperlink{classMSHRQueue_ab090e7fb494c0f9af81d19d1959684a0}{readyList}
\item 
\hyperlink{classstd_1_1list}{MSHR::List} \hyperlink{classMSHRQueue_abad3c0dea35aa5b18c234af72cd8ac89}{freeList}
\item 
\hyperlink{classDrainManager}{DrainManager} $\ast$ \hyperlink{classMSHRQueue_a329b71fb934a93312ca0aacbf5a3f982}{drainManager}
\end{DoxyCompactItemize}


\subsection{説明}
A Class for maintaining a list of pending and allocated memory requests. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classMSHRQueue_a72708efb7b001e844259a19264e0f275}{
\index{MSHRQueue@{MSHRQueue}!MSHRQueue@{MSHRQueue}}
\index{MSHRQueue@{MSHRQueue}!MSHRQueue@{MSHRQueue}}
\subsubsection[{MSHRQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHRQueue} (const std::string \& {\em \_\-label}, \/  int {\em num\_\-entries}, \/  int {\em reserve}, \/  int {\em index})}}
\label{classMSHRQueue_a72708efb7b001e844259a19264e0f275}
Create a queue with a given number of entries. 
\begin{DoxyParams}{引数}
\item[{\em num\_\-entrys}]The number of entries in this queue. \item[{\em reserve}]The minimum number of entries needed to satisfy any access. \end{DoxyParams}



\begin{DoxyCode}
54     : label(_label), numEntries(num_entries + reserve - 1),
55       numReserve(reserve), registers(numEntries),
56       drainManager(NULL), allocated(0), inServiceEntries(0), index(_index)
57 {
58     for (int i = 0; i < numEntries; ++i) {
59         registers[i].queue = this;
60         freeList.push_back(&registers[i]);
61     }
62 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classMSHRQueue_a80c2dad36455852eae13562756599fa4}{
\index{MSHRQueue@{MSHRQueue}!addToReadyList@{addToReadyList}}
\index{addToReadyList@{addToReadyList}!MSHRQueue@{MSHRQueue}}
\subsubsection[{addToReadyList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHR::Iterator} addToReadyList ({\bf MSHR} $\ast$ {\em mshr})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHRQueue_a80c2dad36455852eae13562756599fa4}



\begin{DoxyCode}
138 {
139     if (readyList.empty() || readyList.back()->readyTime <= mshr->readyTime) {
140         return readyList.insert(readyList.end(), mshr);
141     }
142 
143     MSHR::Iterator i = readyList.begin();
144     MSHR::Iterator end = readyList.end();
145     for (; i != end; ++i) {
146         if ((*i)->readyTime > mshr->readyTime) {
147             return readyList.insert(i, mshr);
148         }
149     }
150     assert(false);
151     return end;  // keep stupid compilers happy
152 }
\end{DoxyCode}
\hypertarget{classMSHRQueue_a5215a381ac6546c5ef5730b060b38e61}{
\index{MSHRQueue@{MSHRQueue}!allocate@{allocate}}
\index{allocate@{allocate}!MSHRQueue@{MSHRQueue}}
\subsubsection[{allocate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHR} $\ast$ allocate ({\bf Addr} {\em addr}, \/  int {\em size}, \/  {\bf PacketPtr} \& {\em pkt}, \/  {\bf Tick} {\em when}, \/  {\bf Counter} {\em order})}}
\label{classMSHRQueue_a5215a381ac6546c5ef5730b060b38e61}
Allocates a new \hyperlink{classMSHR}{MSHR} for the request and size. This places the request as the first target in the \hyperlink{classMSHR}{MSHR}. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]The request to handle. \item[{\em size}]The number in bytes to fetch from memory. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
The a pointer to the \hyperlink{classMSHR}{MSHR} allocated.
\end{DoxyReturn}
\begin{DoxyPrecond}{事前条件}
There are free entries. 
\end{DoxyPrecond}



\begin{DoxyCode}
158 {
159     assert(!freeList.empty());
160     MSHR *mshr = freeList.front();
161     assert(mshr->getNumTargets() == 0);
162     freeList.pop_front();
163 
164     mshr->allocate(addr, size, pkt, when, order);
165     mshr->allocIter = allocatedList.insert(allocatedList.end(), mshr);
166     mshr->readyIter = addToReadyList(mshr);
167 
168     allocated += 1;
169     return mshr;
170 }
\end{DoxyCode}
\hypertarget{classMSHRQueue_ab1a1044e709a5b00c99cf14430b3ff53}{
\index{MSHRQueue@{MSHRQueue}!checkFunctional@{checkFunctional}}
\index{checkFunctional@{checkFunctional}!MSHRQueue@{MSHRQueue}}
\subsubsection[{checkFunctional}]{\setlength{\rightskip}{0pt plus 5cm}bool checkFunctional ({\bf PacketPtr} {\em pkt}, \/  {\bf Addr} {\em blk\_\-addr})}}
\label{classMSHRQueue_ab1a1044e709a5b00c99cf14430b3ff53}



\begin{DoxyCode}
99 {
100     pkt->pushLabel(label);
101     MSHR::ConstIterator i = allocatedList.begin();
102     MSHR::ConstIterator end = allocatedList.end();
103     for (; i != end; ++i) {
104         MSHR *mshr = *i;
105         if (mshr->addr == blk_addr && mshr->checkFunctional(pkt)) {
106             pkt->popLabel();
107             return true;
108         }
109     }
110     pkt->popLabel();
111     return false;
112 }
\end{DoxyCode}
\hypertarget{classMSHRQueue_a1704942edaee695477bdfc7598bd8ad7}{
\index{MSHRQueue@{MSHRQueue}!deallocate@{deallocate}}
\index{deallocate@{deallocate}!MSHRQueue@{MSHRQueue}}
\subsubsection[{deallocate}]{\setlength{\rightskip}{0pt plus 5cm}void deallocate ({\bf MSHR} $\ast$ {\em mshr})}}
\label{classMSHRQueue_a1704942edaee695477bdfc7598bd8ad7}
Removes the given \hyperlink{classMSHR}{MSHR} from the queue. This places the \hyperlink{classMSHR}{MSHR} on the free list. 
\begin{DoxyParams}{引数}
\item[{\em mshr}]\end{DoxyParams}



\begin{DoxyCode}
175 {
176     deallocateOne(mshr);
177 }
\end{DoxyCode}
\hypertarget{classMSHRQueue_a8a69fab976c144c9128fec59358d3196}{
\index{MSHRQueue@{MSHRQueue}!deallocateOne@{deallocateOne}}
\index{deallocateOne@{deallocateOne}!MSHRQueue@{MSHRQueue}}
\subsubsection[{deallocateOne}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHR::Iterator} deallocateOne ({\bf MSHR} $\ast$ {\em mshr})}}
\label{classMSHRQueue_a8a69fab976c144c9128fec59358d3196}
Remove a \hyperlink{classMSHR}{MSHR} from the queue. Returns an iterator into the allocatedList for faster squash implementation. 
\begin{DoxyParams}{引数}
\item[{\em mshr}]The \hyperlink{classMSHR}{MSHR} to remove. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
An iterator to the next entry in the allocatedList. 
\end{DoxyReturn}



\begin{DoxyCode}
181 {
182     MSHR::Iterator retval = allocatedList.erase(mshr->allocIter);
183     freeList.push_front(mshr);
184     allocated--;
185     if (mshr->inService) {
186         inServiceEntries--;
187     } else {
188         readyList.erase(mshr->readyIter);
189     }
190     mshr->deallocate();
191     if (drainManager && allocated == 0) {
192         // Notify the drain manager that we have completed draining if
193         // there are no other outstanding requests in this MSHR queue.
194         drainManager->signalDrainDone();
195         drainManager = NULL;
196         setDrainState(Drainable::Drained);
197     }
198     return retval;
199 }
\end{DoxyCode}
\hypertarget{classMSHRQueue_aa8a18d230dba7a674ac8a0b4f35bc36a}{
\index{MSHRQueue@{MSHRQueue}!drain@{drain}}
\index{drain@{drain}!MSHRQueue@{MSHRQueue}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em drainManager})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classMSHRQueue_aa8a18d230dba7a674ac8a0b4f35bc36a}
Determine if an object needs draining and register a \hyperlink{classDrainManager}{DrainManager}.

When draining the state of an object, the simulator calls drain with a pointer to a drain manager. If the object does not need further simulation to drain internal buffers, it switched to the Drained state and returns 0, otherwise it switches to the Draining state and returns the number of times that it will call \hyperlink{classEvent_a142b75b68a6291400e20fb0dd905b1c8}{Event::process()} on the drain event. Most objects are expected to return either 0 or 1.

\begin{DoxyNote}{覚え書き}
An object that has entered the Drained state can be disturbed by other objects in the system and consequently be forced to enter the Draining state again. The simulator therefore repeats the draining process until all objects return 0 on the first call to \hyperlink{classMSHRQueue_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain()}.
\end{DoxyNote}

\begin{DoxyParams}{引数}
\item[{\em drainManager}]\hyperlink{classDrainManager}{DrainManager} to use to inform the simulator when draining has completed.\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
0 if the object is ready for serialization now, $>$0 if it needs further simulation. 
\end{DoxyReturn}


\hyperlink{classDrainable_a1ed42c14f2f622ea6b0df3865e89c8b4}{Drainable}を実装しています。


\begin{DoxyCode}
279 {
280     if (allocated == 0) {
281         setDrainState(Drainable::Drained);
282         return 0;
283     } else {
284         drainManager = dm;
285         setDrainState(Drainable::Draining);
286         return 1;
287     }
288 }
\end{DoxyCode}
\hypertarget{classMSHRQueue_aab842d63dcd254dfe655e16075f7e0fe}{
\index{MSHRQueue@{MSHRQueue}!findMatch@{findMatch}}
\index{findMatch@{findMatch}!MSHRQueue@{MSHRQueue}}
\subsubsection[{findMatch}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHR} $\ast$ findMatch ({\bf Addr} {\em addr}, \/  bool {\em is\_\-secure}) const}}
\label{classMSHRQueue_aab842d63dcd254dfe655e16075f7e0fe}
Find the first \hyperlink{classMSHR}{MSHR} that matches the provided address. 
\begin{DoxyParams}{引数}
\item[{\em addr}]The address to find. \item[{\em is\_\-secure}]True if the target memory space is secure. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Pointer to the matching \hyperlink{classMSHR}{MSHR}, null if not found. 
\end{DoxyReturn}



\begin{DoxyCode}
66 {
67     MSHR::ConstIterator i = allocatedList.begin();
68     MSHR::ConstIterator end = allocatedList.end();
69     for (; i != end; ++i) {
70         MSHR *mshr = *i;
71         if (mshr->addr == addr && mshr->isSecure == is_secure) {
72             return mshr;
73         }
74     }
75     return NULL;
76 }
\end{DoxyCode}
\hypertarget{classMSHRQueue_a020dd5bb628863baf3800f816cfba197}{
\index{MSHRQueue@{MSHRQueue}!findMatches@{findMatches}}
\index{findMatches@{findMatches}!MSHRQueue@{MSHRQueue}}
\subsubsection[{findMatches}]{\setlength{\rightskip}{0pt plus 5cm}bool findMatches ({\bf Addr} {\em addr}, \/  bool {\em is\_\-secure}, \/  {\bf std::vector}$<$ {\bf MSHR} $\ast$ $>$ \& {\em matches}) const}}
\label{classMSHRQueue_a020dd5bb628863baf3800f816cfba197}
Find and return all the matching entries in the provided vector. 
\begin{DoxyParams}{引数}
\item[{\em addr}]The address to find. \item[{\em is\_\-secure}]True if the target memory space is secure. \item[{\em matches}]The vector to return pointers to the matching entries. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
True if any matches are found, false otherwise. 
\end{DoxyReturn}
\begin{Desc}
\item[\hyperlink{todo__todo000078}{TODO}]Typedef the vector?? \end{Desc}



\begin{DoxyCode}
80 {
81     // Need an empty vector
82     assert(matches.empty());
83     bool retval = false;
84     MSHR::ConstIterator i = allocatedList.begin();
85     MSHR::ConstIterator end = allocatedList.end();
86     for (; i != end; ++i) {
87         MSHR *mshr = *i;
88         if (mshr->addr == addr && mshr->isSecure == is_secure) {
89             retval = true;
90             matches.push_back(mshr);
91         }
92     }
93     return retval;
94 }
\end{DoxyCode}
\hypertarget{classMSHRQueue_affbbf09e05a34a8c06a00eeb8425be92}{
\index{MSHRQueue@{MSHRQueue}!findPending@{findPending}}
\index{findPending@{findPending}!MSHRQueue@{MSHRQueue}}
\subsubsection[{findPending}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHR} $\ast$ findPending ({\bf Addr} {\em addr}, \/  int {\em size}, \/  bool {\em is\_\-secure}) const}}
\label{classMSHRQueue_affbbf09e05a34a8c06a00eeb8425be92}
Find any pending requests that overlap the given request. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]The request to find. \item[{\em is\_\-secure}]True if the target memory space is secure. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A pointer to the earliest matching \hyperlink{classMSHR}{MSHR}. 
\end{DoxyReturn}



\begin{DoxyCode}
117 {
118     MSHR::ConstIterator i = readyList.begin();
119     MSHR::ConstIterator end = readyList.end();
120     for (; i != end; ++i) {
121         MSHR *mshr = *i;
122         if (mshr->isSecure == is_secure) {
123             if (mshr->addr < addr) {
124                 if (mshr->addr + mshr->size > addr)
125                     return mshr;
126             } else {
127                 if (addr + size > mshr->addr)
128                     return mshr;
129             }
130         }
131     }
132     return NULL;
133 }
\end{DoxyCode}
\hypertarget{classMSHRQueue_acda43ebd9ff1813951d7d0ab3eaad05c}{
\index{MSHRQueue@{MSHRQueue}!forceDeallocateTarget@{forceDeallocateTarget}}
\index{forceDeallocateTarget@{forceDeallocateTarget}!MSHRQueue@{MSHRQueue}}
\subsubsection[{forceDeallocateTarget}]{\setlength{\rightskip}{0pt plus 5cm}bool forceDeallocateTarget ({\bf MSHR} $\ast$ {\em mshr})}}
\label{classMSHRQueue_acda43ebd9ff1813951d7d0ab3eaad05c}
Deallocate top target, possibly freeing the \hyperlink{classMSHR}{MSHR} \begin{DoxyReturn}{戻り値}
if \hyperlink{classMSHR}{MSHR} queue is no longer full 
\end{DoxyReturn}



\begin{DoxyCode}
237 {
238     bool was_full = isFull();
239     assert(mshr->hasTargets());
240     // Pop the prefetch off of the target list
241     mshr->popTarget();
242     // Delete mshr if no remaining targets
243     if (!mshr->hasTargets() && !mshr->promoteDeferredTargets()) {
244         deallocateOne(mshr);
245     }
246 
247     // Notify if MSHR queue no longer full
248     return was_full && !isFull();
249 }
\end{DoxyCode}
\hypertarget{classMSHRQueue_a98b9ba341284c5251a7908cd45918066}{
\index{MSHRQueue@{MSHRQueue}!getNextMSHR@{getNextMSHR}}
\index{getNextMSHR@{getNextMSHR}!MSHRQueue@{MSHRQueue}}
\subsubsection[{getNextMSHR}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHR}$\ast$ getNextMSHR () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMSHRQueue_a98b9ba341284c5251a7908cd45918066}
Returns the \hyperlink{classMSHR}{MSHR} at the head of the readyList. \begin{DoxyReturn}{戻り値}
The next request to service. 
\end{DoxyReturn}



\begin{DoxyCode}
225     {
226         if (readyList.empty() || readyList.front()->readyTime > curTick()) {
227             return NULL;
228         }
229         return readyList.front();
230     }
\end{DoxyCode}
\hypertarget{classMSHRQueue_aef5fae0b3798035ac6f7ad1ab9038aca}{
\index{MSHRQueue@{MSHRQueue}!havePending@{havePending}}
\index{havePending@{havePending}!MSHRQueue@{MSHRQueue}}
\subsubsection[{havePending}]{\setlength{\rightskip}{0pt plus 5cm}bool havePending () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMSHRQueue_aef5fae0b3798035ac6f7ad1ab9038aca}
Returns true if the pending list is not empty. \begin{DoxyReturn}{戻り値}
True if there are outstanding requests. 
\end{DoxyReturn}



\begin{DoxyCode}
207     {
208         return !readyList.empty();
209     }
\end{DoxyCode}
\hypertarget{classMSHRQueue_a7ffe8a6212a0eb3fc7bbc8e9bc51dfcd}{
\index{MSHRQueue@{MSHRQueue}!isFull@{isFull}}
\index{isFull@{isFull}!MSHRQueue@{MSHRQueue}}
\subsubsection[{isFull}]{\setlength{\rightskip}{0pt plus 5cm}bool isFull () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMSHRQueue_a7ffe8a6212a0eb3fc7bbc8e9bc51dfcd}
Returns true if there are no free entries. \begin{DoxyReturn}{戻り値}
True if this queue is full. 
\end{DoxyReturn}



\begin{DoxyCode}
216     {
217         return (allocated > numEntries - numReserve);
218     }
\end{DoxyCode}
\hypertarget{classMSHRQueue_a1131b37f2a7bef3428b45951455cfcad}{
\index{MSHRQueue@{MSHRQueue}!markInService@{markInService}}
\index{markInService@{markInService}!MSHRQueue@{MSHRQueue}}
\subsubsection[{markInService}]{\setlength{\rightskip}{0pt plus 5cm}void markInService ({\bf MSHR} $\ast$ {\em mshr}, \/  {\bf PacketPtr} {\em pkt})}}
\label{classMSHRQueue_a1131b37f2a7bef3428b45951455cfcad}
Mark the given \hyperlink{classMSHR}{MSHR} as in service. This removes the \hyperlink{classMSHR}{MSHR} from the readyList. Deallocates the \hyperlink{classMSHR}{MSHR} if it does not expect a response. 
\begin{DoxyParams}{引数}
\item[{\em mshr}]The \hyperlink{classMSHR}{MSHR} to mark in service. \end{DoxyParams}



\begin{DoxyCode}
213 {
214     if (mshr->markInService(pkt)) {
215         deallocate(mshr);
216     } else {
217         readyList.erase(mshr->readyIter);
218         inServiceEntries += 1;
219     }
220 }
\end{DoxyCode}
\hypertarget{classMSHRQueue_ab0f258b25fe50dc16d5e3e5890214c5c}{
\index{MSHRQueue@{MSHRQueue}!markPending@{markPending}}
\index{markPending@{markPending}!MSHRQueue@{MSHRQueue}}
\subsubsection[{markPending}]{\setlength{\rightskip}{0pt plus 5cm}void markPending ({\bf MSHR} $\ast$ {\em mshr})}}
\label{classMSHRQueue_ab0f258b25fe50dc16d5e3e5890214c5c}
Mark an in service entry as pending, used to resend a request. 
\begin{DoxyParams}{引数}
\item[{\em mshr}]The \hyperlink{classMSHR}{MSHR} to resend. \end{DoxyParams}


@ todo might want to add rerequests to front of pending list for performance.


\begin{DoxyCode}
224 {
225     assert(mshr->inService);
226     mshr->inService = false;
227     --inServiceEntries;
232     mshr->readyIter = addToReadyList(mshr);
233 }
\end{DoxyCode}
\hypertarget{classMSHRQueue_a2a53c836e41157cdbf2c19b6fd30e276}{
\index{MSHRQueue@{MSHRQueue}!moveToFront@{moveToFront}}
\index{moveToFront@{moveToFront}!MSHRQueue@{MSHRQueue}}
\subsubsection[{moveToFront}]{\setlength{\rightskip}{0pt plus 5cm}void moveToFront ({\bf MSHR} $\ast$ {\em mshr})}}
\label{classMSHRQueue_a2a53c836e41157cdbf2c19b6fd30e276}
Moves the \hyperlink{classMSHR}{MSHR} to the front of the pending list if it is not in service. 
\begin{DoxyParams}{引数}
\item[{\em mshr}]The entry to move. \end{DoxyParams}



\begin{DoxyCode}
203 {
204     if (!mshr->inService) {
205         assert(mshr == *(mshr->readyIter));
206         readyList.erase(mshr->readyIter);
207         mshr->readyIter = readyList.insert(readyList.begin(), mshr);
208     }
209 }
\end{DoxyCode}
\hypertarget{classMSHRQueue_a4601a57ba7740776052541f212c29cbd}{
\index{MSHRQueue@{MSHRQueue}!nextMSHRReadyTime@{nextMSHRReadyTime}}
\index{nextMSHRReadyTime@{nextMSHRReadyTime}!MSHRQueue@{MSHRQueue}}
\subsubsection[{nextMSHRReadyTime}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} nextMSHRReadyTime () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMSHRQueue_a4601a57ba7740776052541f212c29cbd}



\begin{DoxyCode}
233     {
234         return readyList.empty() ? MaxTick : readyList.front()->readyTime;
235     }
\end{DoxyCode}
\hypertarget{classMSHRQueue_a94c2c174856cbab1e3478cb02ae8ed80}{
\index{MSHRQueue@{MSHRQueue}!squash@{squash}}
\index{squash@{squash}!MSHRQueue@{MSHRQueue}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash (int {\em threadNum})}}
\label{classMSHRQueue_a94c2c174856cbab1e3478cb02ae8ed80}
Squash outstanding requests with the given thread number. If a request is in service, just squashes the targets. 
\begin{DoxyParams}{引数}
\item[{\em threadNum}]The thread to squash. \end{DoxyParams}



\begin{DoxyCode}
253 {
254     MSHR::Iterator i = allocatedList.begin();
255     MSHR::Iterator end = allocatedList.end();
256     for (; i != end;) {
257         MSHR *mshr = *i;
258         if (mshr->threadNum == threadNum) {
259             while (mshr->hasTargets()) {
260                 mshr->popTarget();
261                 assert(0/*target->req->threadId()*/ == threadNum);
262             }
263             assert(!mshr->hasTargets());
264             assert(mshr->getNumTargets()==0);
265             if (!mshr->inService) {
266                 i = deallocateOne(mshr);
267             } else {
268                 //mshr->pkt->flags &= ~CACHE_LINE_FILL;
269                 ++i;
270             }
271         } else {
272             ++i;
273         }
274     }
275 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classMSHRQueue_a115235fc25fdf1c03d856bd072b6cead}{
\index{MSHRQueue@{MSHRQueue}!allocated@{allocated}}
\index{allocated@{allocated}!MSHRQueue@{MSHRQueue}}
\subsubsection[{allocated}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf allocated}}}
\label{classMSHRQueue_a115235fc25fdf1c03d856bd072b6cead}
The number of allocated entries. \hypertarget{classMSHRQueue_a4bac1d00b2059c983d4afaf4df82f4ac}{
\index{MSHRQueue@{MSHRQueue}!allocatedList@{allocatedList}}
\index{allocatedList@{allocatedList}!MSHRQueue@{MSHRQueue}}
\subsubsection[{allocatedList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHR::List} {\bf allocatedList}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHRQueue_a4bac1d00b2059c983d4afaf4df82f4ac}
Holds pointers to all allocated entries. \hypertarget{classMSHRQueue_a329b71fb934a93312ca0aacbf5a3f982}{
\index{MSHRQueue@{MSHRQueue}!drainManager@{drainManager}}
\index{drainManager@{drainManager}!MSHRQueue@{MSHRQueue}}
\subsubsection[{drainManager}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DrainManager}$\ast$ {\bf drainManager}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHRQueue_a329b71fb934a93312ca0aacbf5a3f982}
Drain manager to inform of a completed drain \hypertarget{classMSHRQueue_abad3c0dea35aa5b18c234af72cd8ac89}{
\index{MSHRQueue@{MSHRQueue}!freeList@{freeList}}
\index{freeList@{freeList}!MSHRQueue@{MSHRQueue}}
\subsubsection[{freeList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHR::List} {\bf freeList}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHRQueue_abad3c0dea35aa5b18c234af72cd8ac89}
Holds non allocated entries. \hypertarget{classMSHRQueue_a32b76ccceab9e1bba3e8c4ef2947d1d8}{
\index{MSHRQueue@{MSHRQueue}!index@{index}}
\index{index@{index}!MSHRQueue@{MSHRQueue}}
\subsubsection[{index}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf index}}}
\label{classMSHRQueue_a32b76ccceab9e1bba3e8c4ef2947d1d8}
The index of this queue within the cache (\hyperlink{classMSHR}{MSHR} queue vs. write buffer). \hypertarget{classMSHRQueue_aa4871243af391ed1f0d5e3f964bc13d0}{
\index{MSHRQueue@{MSHRQueue}!inServiceEntries@{inServiceEntries}}
\index{inServiceEntries@{inServiceEntries}!MSHRQueue@{MSHRQueue}}
\subsubsection[{inServiceEntries}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf inServiceEntries}}}
\label{classMSHRQueue_aa4871243af391ed1f0d5e3f964bc13d0}
The number of entries that have been forwarded to the bus. \hypertarget{classMSHRQueue_ae471a4c4073716b769170188214fe93d}{
\index{MSHRQueue@{MSHRQueue}!label@{label}}
\index{label@{label}!MSHRQueue@{MSHRQueue}}
\subsubsection[{label}]{\setlength{\rightskip}{0pt plus 5cm}const std::string {\bf label}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHRQueue_ae471a4c4073716b769170188214fe93d}
Local label (for functional print requests) \hypertarget{classMSHRQueue_aac2a0fada965c3dd6220aeb40a28c587}{
\index{MSHRQueue@{MSHRQueue}!numEntries@{numEntries}}
\index{numEntries@{numEntries}!MSHRQueue@{MSHRQueue}}
\subsubsection[{numEntries}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf numEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHRQueue_aac2a0fada965c3dd6220aeb40a28c587}
The total number of entries in this queue. This number is set as the number of entries requested plus (numReserve -\/ 1). This allows for the same number of effective entries while still maintaining the reserve. \hypertarget{classMSHRQueue_a2c97f85062902d3990c3a9c163306547}{
\index{MSHRQueue@{MSHRQueue}!numReserve@{numReserve}}
\index{numReserve@{numReserve}!MSHRQueue@{MSHRQueue}}
\subsubsection[{numReserve}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf numReserve}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHRQueue_a2c97f85062902d3990c3a9c163306547}
The number of entries to hold in reserve. This is needed because copy operations can allocate upto 4 entries at one time. \hypertarget{classMSHRQueue_ab090e7fb494c0f9af81d19d1959684a0}{
\index{MSHRQueue@{MSHRQueue}!readyList@{readyList}}
\index{readyList@{readyList}!MSHRQueue@{MSHRQueue}}
\subsubsection[{readyList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHR::List} {\bf readyList}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHRQueue_ab090e7fb494c0f9af81d19d1959684a0}
Holds pointers to entries that haven't been sent to the bus. \hypertarget{classMSHRQueue_a61e75efe923d1fa4bbb72f426a219b7e}{
\index{MSHRQueue@{MSHRQueue}!registers@{registers}}
\index{registers@{registers}!MSHRQueue@{MSHRQueue}}
\subsubsection[{registers}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf MSHR}$>$ {\bf registers}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHRQueue_a61e75efe923d1fa4bbb72f426a219b7e}
\hyperlink{classMSHR}{MSHR} storage. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/cache/\hyperlink{mshr__queue_8hh}{mshr\_\-queue.hh}\item 
mem/cache/\hyperlink{mshr__queue_8cc}{mshr\_\-queue.cc}\end{DoxyCompactItemize}
