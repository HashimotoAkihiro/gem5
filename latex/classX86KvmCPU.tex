\hypertarget{classX86KvmCPU}{
\section{クラス X86KvmCPU}
\label{classX86KvmCPU}\index{X86KvmCPU@{X86KvmCPU}}
}


{\ttfamily \#include $<$x86\_\-cpu.hh$>$}X86KvmCPUに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classX86KvmCPU}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classX86KvmCPU_1_1X86KvmCPU}{X86KvmCPU}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classX86KvmCPU_a775cadafe573db795406b498b53cff43}{X86KvmCPU} (X86KvmCPUParams $\ast$params)
\item 
virtual \hyperlink{classX86KvmCPU_ad55c9b8bef2361530e30e7f3eb1a58c1}{$\sim$X86KvmCPU} ()
\item 
void \hyperlink{classX86KvmCPU_aecc7d8debf54990ffeaaed5bac7d7d81}{startup} ()
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classstd_1_1vector}{std::vector}$<$ struct kvm\_\-msr\_\-entry $>$ \hyperlink{classX86KvmCPU_aa498445286177d1e3901b007c40f52c9}{KvmMSRVector}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classX86KvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}{kvmRun} (\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} ticks)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classX86KvmCPU_a405afc17ad0dee3b816012ce909b2b6f}{kvmRunDrain} ()
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classX86KvmCPU_afae1f96b6b1a482f400cd925b8709325}{kvmRunWrapper} (\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} ticks)
\item 
uint64\_\-t \hyperlink{classX86KvmCPU_abcad2a22057ba48360b17b978f694b48}{getHostCycles} () const 
\item 
const \hyperlink{classstd_1_1vector}{Kvm::MSRIndexVector} \& \hyperlink{classX86KvmCPU_abab51da6ec6a0f14d2dde6b0857b7b34}{getMsrIntersection} () const 
\item 
void \hyperlink{classX86KvmCPU_a93c6e8c82dfb63c7039f0cbf064fae5d}{updateKvmState} ()
\item 
void \hyperlink{classX86KvmCPU_adbd5e38eae7c8c3021f2c4f430b399fd}{updateThreadContext} ()
\item 
void \hyperlink{classX86KvmCPU_a7f9a05aa2521efe15d995cad6a739aa5}{deliverInterrupts} ()
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classX86KvmCPU_a404fbd80d6676724d026a932b2258dc7}{handleKvmExitIO} ()
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classX86KvmCPU_a405e34c9d079e8823ac2a1ca0e816a47}{handleKvmExitIRQWindowOpen} ()
\item 
bool \hyperlink{classX86KvmCPU_a1d97c7e0665d576bb463335078bb02ec}{archIsDrained} () const 
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classX86KvmCPU_adcec996536ccdb020b08a11d61a47d44}{updateCPUID} ()
\item 
void \hyperlink{classX86KvmCPU_a58452f4681b53990ff7470d1884ac13c}{handleIOMiscReg32} (int miscreg)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classRequest}{Request} \hyperlink{classX86KvmCPU_ab9e917350d26247b9eb4153e891f348a}{io\_\-req}
\item 
\hyperlink{classstd_1_1vector}{Kvm::MSRIndexVector} \hyperlink{classX86KvmCPU_aa0f07c7b56f9fd1e68e7ebdc2e3a9428}{cachedMsrIntersection}
\end{DoxyCompactItemize}
\label{_amgrpd41d8cd98f00b204e9800998ecf8427e}
 \begin{DoxyCompactItemize}
\item 
bool \hyperlink{classX86KvmCPU_ab7c96fcfb73a6d3ca276a6dce2ee76bb}{haveDebugRegs}
\item 
bool \hyperlink{classX86KvmCPU_ac0fd3f6d7cf7fa1132de384a5953228c}{haveXSave}
\item 
bool \hyperlink{classX86KvmCPU_ab966ae6cc1b380746dcb2713f2559e65}{useXSave}
\item 
bool \hyperlink{classX86KvmCPU_acb9f794b9c9ccc1422b1b5ba9e4823b6}{haveXCRs}
\item 
void \hyperlink{classX86KvmCPU_accd2600060dbaee3a3b41aed4034c63c}{dump} ()
\item 
void \hyperlink{classX86KvmCPU_aa1a18283b9b8e7cb68c16a67fec2259c}{dumpFpuRegs} () const 
\item 
void \hyperlink{classX86KvmCPU_af077d8e3ed2e320aa9a94718f0757a37}{dumpIntRegs} () const 
\item 
void \hyperlink{classX86KvmCPU_a8a8d697d582ced238ec0dfca97be2a75}{dumpSpecRegs} () const 
\item 
void \hyperlink{classX86KvmCPU_a90a32da18747ec95f59f6042fa5b448d}{dumpDebugRegs} () const 
\item 
void \hyperlink{classX86KvmCPU_a80e6ff34faeb5d05343e77809a203ec8}{dumpXCRs} () const 
\item 
void \hyperlink{classX86KvmCPU_a84c89612fa5d62bf131915036e99c8ee}{dumpXSave} () const 
\item 
void \hyperlink{classX86KvmCPU_ab17603ee90366735647c3ed5407e23ec}{dumpVCpuEvents} () const 
\item 
void \hyperlink{classX86KvmCPU_ad68abbbf4ef33ea6b6ed643fee2c13e6}{dumpMSRs} () const 
\item 
void \hyperlink{classX86KvmCPU_ae1aa75790696eb8780d159812f607921}{setCPUID} (const struct kvm\_\-cpuid2 \&cpuid)
\item 
void \hyperlink{classX86KvmCPU_a6782fae08bf69ed6903f49bfbee81566}{setCPUID} (const \hyperlink{classstd_1_1vector}{Kvm::CPUIDVector} \&cpuid)
\item 
void \hyperlink{classX86KvmCPU_a37c723660e4a4aa0ebb42ee498df990b}{setMSRs} (const struct kvm\_\-msrs \&msrs)
\item 
void \hyperlink{classX86KvmCPU_acc0ac79f886623c5e0ce73b393402148}{setMSRs} (const \hyperlink{classstd_1_1vector}{KvmMSRVector} \&msrs)
\item 
void \hyperlink{classX86KvmCPU_aee0c514e035c18531c33ea1219e621bf}{getMSRs} (struct kvm\_\-msrs \&msrs) const 
\item 
void \hyperlink{classX86KvmCPU_a3d32029e1dfb4da512897794d56e9fc8}{setMSR} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} index, uint64\_\-t value)
\item 
uint64\_\-t \hyperlink{classX86KvmCPU_ad242a06d6443c10c74eac568fb44fcfe}{getMSR} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} index) const 
\item 
void \hyperlink{classX86KvmCPU_a62688c8626ebb350e3748a2cd1fa44a8}{getDebugRegisters} (struct kvm\_\-debugregs \&regs) const 
\item 
void \hyperlink{classX86KvmCPU_a0c0b94046f41e2b83c8f224e9f227d0f}{setDebugRegisters} (const struct kvm\_\-debugregs \&regs)
\item 
void \hyperlink{classX86KvmCPU_a6744a04655bbdcee8aa24919573d8698}{getXCRs} (struct kvm\_\-xcrs \&regs) const 
\item 
void \hyperlink{classX86KvmCPU_a929420a323cb83ab21bdf3efa22edd24}{setXCRs} (const struct kvm\_\-xcrs \&regs)
\item 
void \hyperlink{classX86KvmCPU_af9f89d561ce9170ad89e6582071c1169}{getXSave} (struct kvm\_\-xsave \&xsave) const 
\item 
void \hyperlink{classX86KvmCPU_aa05e7c39fbe7374815b387728b7de06d}{setXSave} (const struct kvm\_\-xsave \&xsave)
\item 
void \hyperlink{classX86KvmCPU_a7c08fc9f9ab36f8eda2a3cfe6c234635}{getVCpuEvents} (struct kvm\_\-vcpu\_\-events \&events) const 
\item 
void \hyperlink{classX86KvmCPU_a70cfa7f84580af5396fbc82f540c8a5b}{setVCpuEvents} (const struct kvm\_\-vcpu\_\-events \&events)
\item 
void \hyperlink{classX86KvmCPU_a54e3879c7bcd8aac9d1b88350e7674fe}{updateKvmStateRegs} ()
\item 
void \hyperlink{classX86KvmCPU_af58754cb34827756e0e0fc8474c54a8e}{updateKvmStateSRegs} ()
\item 
void \hyperlink{classX86KvmCPU_a1c8ff9ec0ad33f11a2212a37e2a79f6c}{updateKvmStateFPU} ()
\item 
void \hyperlink{classX86KvmCPU_a3eccabf97e73ee194068ee37c2422c50}{updateKvmStateFPULegacy} ()
\item 
void \hyperlink{classX86KvmCPU_aa1d3c8572c67dd0c4457ba46307f35f1}{updateKvmStateFPUXSave} ()
\item 
void \hyperlink{classX86KvmCPU_ad04202aafaacd818cf2621c5a31926c1}{updateKvmStateMSRs} ()
\item 
void \hyperlink{classX86KvmCPU_a3e652bccdd2770630eb4e7bfb0b31b5e}{updateThreadContextRegs} (const struct kvm\_\-regs \&regs, const struct kvm\_\-sregs \&sregs)
\item 
void \hyperlink{classX86KvmCPU_aaca63820cd695ae9a2d1bafa76f2ebf6}{updateThreadContextSRegs} (const struct kvm\_\-sregs \&sregs)
\item 
void \hyperlink{classX86KvmCPU_a1f9b85cc469eb72bbf377872c1404c1e}{updateThreadContextFPU} (const struct kvm\_\-fpu \&fpu)
\item 
void \hyperlink{classX86KvmCPU_a64c8d7da4ee94fdaeb4e61d7106c01cf}{updateThreadContextXSave} (const struct kvm\_\-xsave \&kxsave)
\item 
void \hyperlink{classX86KvmCPU_ad0f81dc69ee0b095b4c9eeec4491ed39}{updateThreadContextMSRs} ()
\end{DoxyCompactItemize}


\subsection{説明}
x86 implementation of a KVM-\/based hardware virtualized CPU. 

\subsection{型定義}
\hypertarget{classX86KvmCPU_aa498445286177d1e3901b007c40f52c9}{
\index{X86KvmCPU@{X86KvmCPU}!KvmMSRVector@{KvmMSRVector}}
\index{KvmMSRVector@{KvmMSRVector}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{KvmMSRVector}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::vector}$<$struct kvm\_\-msr\_\-entry$>$ {\bf KvmMSRVector}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_aa498445286177d1e3901b007c40f52c9}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classX86KvmCPU_a775cadafe573db795406b498b53cff43}{
\index{X86KvmCPU@{X86KvmCPU}!X86KvmCPU@{X86KvmCPU}}
\index{X86KvmCPU@{X86KvmCPU}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{X86KvmCPU}]{\setlength{\rightskip}{0pt plus 5cm}{\bf X86KvmCPU} (X86KvmCPUParams $\ast$ {\em params})}}
\label{classX86KvmCPU_a775cadafe573db795406b498b53cff43}



\begin{DoxyCode}
519     : BaseKvmCPU(params),
520       useXSave(params->useXSave)
521 {
522     Kvm &kvm(vm.kvm);
523 
524     if (!kvm.capSetTSSAddress())
525         panic("KVM: Missing capability (KVM_CAP_SET_TSS_ADDR)\n");
526     if (!kvm.capExtendedCPUID())
527         panic("KVM: Missing capability (KVM_CAP_EXT_CPUID)\n");
528     if (!kvm.capUserNMI())
529         warn("KVM: Missing capability (KVM_CAP_USER_NMI)\n");
530     if (!kvm.capVCPUEvents())
531         warn("KVM: Missing capability (KVM_CAP_VCPU_EVENTS)\n");
532 
533     haveDebugRegs = kvm.capDebugRegs();
534     haveXSave = kvm.capXSave();
535     haveXCRs = kvm.capXCRs();
536 
537     if (useXSave && !haveXSave) {
538         warn("KVM: XSAVE not supported by host. MXCSR synchronization might be "
539              "unreliable due to kernel bugs.\n");
540         useXSave = false;
541     } else if (!useXSave) {
542         warn("KVM: XSave FPU/SIMD synchronization disabled by user.\n");
543     }
544 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_ad55c9b8bef2361530e30e7f3eb1a58c1}{
\index{X86KvmCPU@{X86KvmCPU}!$\sim$X86KvmCPU@{$\sim$X86KvmCPU}}
\index{$\sim$X86KvmCPU@{$\sim$X86KvmCPU}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{$\sim$X86KvmCPU}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf X86KvmCPU} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86KvmCPU_ad55c9b8bef2361530e30e7f3eb1a58c1}



\begin{DoxyCode}
547 {
548 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classX86KvmCPU_a1d97c7e0665d576bb463335078bb02ec}{
\index{X86KvmCPU@{X86KvmCPU}!archIsDrained@{archIsDrained}}
\index{archIsDrained@{archIsDrained}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{archIsDrained}]{\setlength{\rightskip}{0pt plus 5cm}bool archIsDrained () const\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classX86KvmCPU_a1d97c7e0665d576bb463335078bb02ec}
\hyperlink{classCheck}{Check} if there are pending events in the vCPU that prevents it from being drained.

There are cases after interrupt injection where the interrupt is still pending in the guest. This method detects such cases and requests additional draining.

\begin{DoxyReturn}{戻り値}
False if there are pending events in the guest, True otherwise. 
\end{DoxyReturn}


\hyperlink{classBaseKvmCPU_a4ee4cbdc5d3315fd8016b44d3e77abd5}{BaseKvmCPU}を再定義しています。


\begin{DoxyCode}
1380 {
1381     struct kvm_vcpu_events events;
1382 
1383     getVCpuEvents(events);
1384 
1385     // We could probably handle this in a by re-inserting interrupts
1386     // that are pending into gem5 on a drain. However, that would
1387     // probably be tricky to do reliably, so we'll just prevent a
1388     // drain if there is anything pending in the
1389     // guest. X86KvmCPU::kvmRunDrain() minimizes the amount of code
1390     // executed in the guest by requesting an interrupt window if
1391     // there are pending interrupts.
1392     const bool pending_events(events.exception.injected ||
1393                               events.interrupt.injected ||
1394                               events.nmi.injected || events.nmi.pending);
1395 
1396     if (pending_events) {
1397         DPRINTF(Drain, "archIsDrained: Pending events: %s %s %s %s\n",
1398                 events.exception.injected ? "exception" : "",
1399                 events.interrupt.injected ? "interrupt" : "",
1400                 events.nmi.injected ? "nmi[i]" : "",
1401                 events.nmi.pending ? "nmi[p]" : "");
1402     }
1403 
1404     return !pending_events;
1405 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a7f9a05aa2521efe15d995cad6a739aa5}{
\index{X86KvmCPU@{X86KvmCPU}!deliverInterrupts@{deliverInterrupts}}
\index{deliverInterrupts@{deliverInterrupts}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{deliverInterrupts}]{\setlength{\rightskip}{0pt plus 5cm}void deliverInterrupts ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_a7f9a05aa2521efe15d995cad6a739aa5}
Inject pending interrupts from gem5 into the virtual CPU. 


\begin{DoxyCode}
1136 {
1137     Fault fault;
1138 
1139     syncThreadContext();
1140 
1141     {
1142         // Migrate to the interrupt controller's thread to get the
1143         // interrupt. Even though the individual methods are safe to
1144         // call across threads, we might still lose interrupts unless
1145         // they are getInterrupt() and updateIntrInfo() are called
1146         // atomically.
1147         EventQueue::ScopedMigration migrate(interrupts->eventQueue());
1148         fault = interrupts->getInterrupt(tc);
1149         interrupts->updateIntrInfo(tc);
1150     }
1151 
1152     X86Interrupt *x86int(dynamic_cast<X86Interrupt *>(fault.get()));
1153     if (dynamic_cast<NonMaskableInterrupt *>(fault.get())) {
1154         DPRINTF(KvmInt, "Delivering NMI\n");
1155         kvmNonMaskableInterrupt();
1156     } else if (dynamic_cast<InitInterrupt *>(fault.get())) {
1157         DPRINTF(KvmInt, "INIT interrupt\n");
1158         fault.get()->invoke(tc);
1159         // Delay the kvm state update since we won't enter KVM on this
1160         // tick.
1161         threadContextDirty = true;
1162         // HACK: gem5 doesn't actually have any BIOS code, which means
1163         // that we need to halt the thread and wait for a startup
1164         // interrupt before restarting the thread. The simulated CPUs
1165         // use the same kind of hack using a microcode routine.
1166         thread->suspend();
1167     } else if (dynamic_cast<StartupInterrupt *>(fault.get())) {
1168         DPRINTF(KvmInt, "STARTUP interrupt\n");
1169         fault.get()->invoke(tc);
1170         // The kvm state is assumed to have been updated when entering
1171         // kvmRun(), so we need to update manually it here.
1172         updateKvmState();
1173     } else if (x86int) {
1174         struct kvm_interrupt kvm_int;
1175         kvm_int.irq = x86int->getVector();
1176 
1177         DPRINTF(KvmInt, "Delivering interrupt: %s (%u)\n",
1178                 fault->name(), kvm_int.irq);
1179 
1180         kvmInterrupt(kvm_int);
1181     } else {
1182         panic("KVM: Unknown interrupt type\n");
1183     }
1184 
1185 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_accd2600060dbaee3a3b41aed4034c63c}{
\index{X86KvmCPU@{X86KvmCPU}!dump@{dump}}
\index{dump@{dump}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{dump}]{\setlength{\rightskip}{0pt plus 5cm}void dump ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86KvmCPU_accd2600060dbaee3a3b41aed4034c63c}


\hyperlink{classBaseKvmCPU_accd2600060dbaee3a3b41aed4034c63c}{BaseKvmCPU}を再定義しています。


\begin{DoxyCode}
568 {
569     dumpIntRegs();
570     if (useXSave)
571         dumpXSave();
572     else
573         dumpFpuRegs();
574     dumpSpecRegs();
575     dumpDebugRegs();
576     dumpXCRs();
577     dumpVCpuEvents();
578     dumpMSRs();
579 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a90a32da18747ec95f59f6042fa5b448d}{
\index{X86KvmCPU@{X86KvmCPU}!dumpDebugRegs@{dumpDebugRegs}}
\index{dumpDebugRegs@{dumpDebugRegs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{dumpDebugRegs}]{\setlength{\rightskip}{0pt plus 5cm}void dumpDebugRegs () const}}
\label{classX86KvmCPU_a90a32da18747ec95f59f6042fa5b448d}



\begin{DoxyCode}
607 {
608     if (haveDebugRegs) {
609 #ifdef KVM_GET_DEBUGREGS
610         struct kvm_debugregs dregs;
611         getDebugRegisters(dregs);
612         dumpKvm(dregs);
613 #endif
614     } else {
615         inform("Debug registers not supported by kernel.\n");
616     }
617 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_aa1a18283b9b8e7cb68c16a67fec2259c}{
\index{X86KvmCPU@{X86KvmCPU}!dumpFpuRegs@{dumpFpuRegs}}
\index{dumpFpuRegs@{dumpFpuRegs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{dumpFpuRegs}]{\setlength{\rightskip}{0pt plus 5cm}void dumpFpuRegs () const}}
\label{classX86KvmCPU_aa1a18283b9b8e7cb68c16a67fec2259c}



\begin{DoxyCode}
583 {
584     struct kvm_fpu fpu;
585     getFPUState(fpu);
586     dumpKvm(fpu);
587 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_af077d8e3ed2e320aa9a94718f0757a37}{
\index{X86KvmCPU@{X86KvmCPU}!dumpIntRegs@{dumpIntRegs}}
\index{dumpIntRegs@{dumpIntRegs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{dumpIntRegs}]{\setlength{\rightskip}{0pt plus 5cm}void dumpIntRegs () const}}
\label{classX86KvmCPU_af077d8e3ed2e320aa9a94718f0757a37}



\begin{DoxyCode}
591 {
592     struct kvm_regs regs;
593     getRegisters(regs);
594     dumpKvm(regs);
595 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_ad68abbbf4ef33ea6b6ed643fee2c13e6}{
\index{X86KvmCPU@{X86KvmCPU}!dumpMSRs@{dumpMSRs}}
\index{dumpMSRs@{dumpMSRs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{dumpMSRs}]{\setlength{\rightskip}{0pt plus 5cm}void dumpMSRs () const}}
\label{classX86KvmCPU_ad68abbbf4ef33ea6b6ed643fee2c13e6}



\begin{DoxyCode}
653 {
654     const Kvm::MSRIndexVector &supported_msrs(vm.kvm.getSupportedMSRs());
655     std::unique_ptr<struct kvm_msrs> msrs(
656         newVarStruct<struct kvm_msrs, struct kvm_msr_entry>(
657             supported_msrs.size()));
658 
659     msrs->nmsrs = supported_msrs.size();
660     for (int i = 0; i < supported_msrs.size(); ++i) {
661         struct kvm_msr_entry &e(msrs->entries[i]);
662         e.index = supported_msrs[i];
663         e.reserved = 0;
664         e.data = 0;
665     }
666     getMSRs(*msrs.get());
667 
668     dumpKvm(*msrs.get());
669 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a8a8d697d582ced238ec0dfca97be2a75}{
\index{X86KvmCPU@{X86KvmCPU}!dumpSpecRegs@{dumpSpecRegs}}
\index{dumpSpecRegs@{dumpSpecRegs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{dumpSpecRegs}]{\setlength{\rightskip}{0pt plus 5cm}void dumpSpecRegs () const}}
\label{classX86KvmCPU_a8a8d697d582ced238ec0dfca97be2a75}



\begin{DoxyCode}
599 {
600     struct kvm_sregs sregs;
601     getSpecialRegisters(sregs);
602     dumpKvm(sregs);
603 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_ab17603ee90366735647c3ed5407e23ec}{
\index{X86KvmCPU@{X86KvmCPU}!dumpVCpuEvents@{dumpVCpuEvents}}
\index{dumpVCpuEvents@{dumpVCpuEvents}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{dumpVCpuEvents}]{\setlength{\rightskip}{0pt plus 5cm}void dumpVCpuEvents () const}}
\label{classX86KvmCPU_ab17603ee90366735647c3ed5407e23ec}



\begin{DoxyCode}
645 {
646     struct kvm_vcpu_events events;
647     getVCpuEvents(events);
648     dumpKvm(events);
649 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a80e6ff34faeb5d05343e77809a203ec8}{
\index{X86KvmCPU@{X86KvmCPU}!dumpXCRs@{dumpXCRs}}
\index{dumpXCRs@{dumpXCRs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{dumpXCRs}]{\setlength{\rightskip}{0pt plus 5cm}void dumpXCRs () const}}
\label{classX86KvmCPU_a80e6ff34faeb5d05343e77809a203ec8}



\begin{DoxyCode}
621 {
622     if (haveXCRs) {
623         struct kvm_xcrs xcrs;
624         getXCRs(xcrs);
625         dumpKvm(xcrs);
626     } else {
627         inform("XCRs not supported by kernel.\n");
628     }
629 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a84c89612fa5d62bf131915036e99c8ee}{
\index{X86KvmCPU@{X86KvmCPU}!dumpXSave@{dumpXSave}}
\index{dumpXSave@{dumpXSave}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{dumpXSave}]{\setlength{\rightskip}{0pt plus 5cm}void dumpXSave () const}}
\label{classX86KvmCPU_a84c89612fa5d62bf131915036e99c8ee}



\begin{DoxyCode}
633 {
634     if (haveXSave) {
635         struct kvm_xsave xsave;
636         getXSave(xsave);
637         dumpKvm(xsave);
638     } else {
639         inform("XSave not supported by kernel.\n");
640     }
641 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a62688c8626ebb350e3748a2cd1fa44a8}{
\index{X86KvmCPU@{X86KvmCPU}!getDebugRegisters@{getDebugRegisters}}
\index{getDebugRegisters@{getDebugRegisters}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{getDebugRegisters}]{\setlength{\rightskip}{0pt plus 5cm}void getDebugRegisters (struct kvm\_\-debugregs \& {\em regs}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_a62688c8626ebb350e3748a2cd1fa44a8}
Wrappers around KVM's state transfer methods. 


\begin{DoxyCode}
1562 {
1563 #ifdef KVM_GET_DEBUGREGS
1564     if (ioctl(KVM_GET_DEBUGREGS, &regs) == -1)
1565         panic("KVM: Failed to get guest debug registers\n");
1566 #else
1567     panic("KVM: Unsupported getDebugRegisters call.\n");
1568 #endif
1569 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_abcad2a22057ba48360b17b978f694b48}{
\index{X86KvmCPU@{X86KvmCPU}!getHostCycles@{getHostCycles}}
\index{getHostCycles@{getHostCycles}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{getHostCycles}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t getHostCycles () const\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classX86KvmCPU_abcad2a22057ba48360b17b978f694b48}
Get the value of the hardware cycle counter in the guest.

This method is supposed to return the total number of cycles executed in hardware mode relative to some arbitrary point in the past. It's mainly used when estimating the number of cycles actually executed by the CPU in \hyperlink{classX86KvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}{kvmRun()}. The default behavior of this method is to use the cycles performance counter, but some architectures may want to use internal registers instead.

\begin{DoxyReturn}{戻り値}
Number of host cycles executed relative to an undefined point in the past. 
\end{DoxyReturn}


\hyperlink{classBaseKvmCPU_abcad2a22057ba48360b17b978f694b48}{BaseKvmCPU}を再定義しています。


\begin{DoxyCode}
1279 {
1280     return getMSR(MSR_TSC);
1281 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_ad242a06d6443c10c74eac568fb44fcfe}{
\index{X86KvmCPU@{X86KvmCPU}!getMSR@{getMSR}}
\index{getMSR@{getMSR}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{getMSR}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t getMSR ({\bf uint32\_\-t} {\em index}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_ad242a06d6443c10c74eac568fb44fcfe}



\begin{DoxyCode}
1525 {
1526     std::unique_ptr<struct kvm_msrs> kvm_msrs(
1527         newVarStruct<struct kvm_msrs, struct kvm_msr_entry>(1));
1528     struct kvm_msr_entry &entry(kvm_msrs->entries[0]);
1529 
1530     kvm_msrs->nmsrs = 1;
1531     entry.index = index;
1532     entry.reserved = 0;
1533     entry.data = 0;
1534 
1535     getMSRs(*kvm_msrs.get());
1536     return entry.data;
1537 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_abab51da6ec6a0f14d2dde6b0857b7b34}{
\index{X86KvmCPU@{X86KvmCPU}!getMsrIntersection@{getMsrIntersection}}
\index{getMsrIntersection@{getMsrIntersection}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{getMsrIntersection}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Kvm::MSRIndexVector} \& getMsrIntersection () const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_abab51da6ec6a0f14d2dde6b0857b7b34}
Get a list of MSRs supported by both gem5 and KVM.

\begin{DoxyNote}{覚え書き}
This method uses an internal cache and only generates the MSR list once.
\end{DoxyNote}
\begin{DoxyReturn}{戻り値}
reference to a list of msr indices 
\end{DoxyReturn}



\begin{DoxyCode}
1541 {
1542     if (cachedMsrIntersection.empty()) {
1543         const Kvm::MSRIndexVector &kvm_msrs(vm.kvm.getSupportedMSRs());
1544 
1545         DPRINTF(Kvm, "kvm-x86: Updating MSR intersection\n");
1546         for (auto it = kvm_msrs.cbegin(); it != kvm_msrs.cend(); ++it) {
1547             if (X86ISA::msrMap.find(*it) != X86ISA::msrMap.end()) {
1548                 cachedMsrIntersection.push_back(*it);
1549                 DPRINTF(Kvm, "kvm-x86: Adding MSR 0x%x\n", *it);
1550             } else {
1551                 warn("kvm-x86: MSR (0x%x) unsupported by gem5. Skipping.\n",
1552                      *it);
1553             }
1554         }
1555     }
1556 
1557     return cachedMsrIntersection;
1558 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_aee0c514e035c18531c33ea1219e621bf}{
\index{X86KvmCPU@{X86KvmCPU}!getMSRs@{getMSRs}}
\index{getMSRs@{getMSRs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{getMSRs}]{\setlength{\rightskip}{0pt plus 5cm}void getMSRs (struct kvm\_\-msrs \& {\em msrs}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_aee0c514e035c18531c33ea1219e621bf}



\begin{DoxyCode}
1501 {
1502     if (ioctl(KVM_GET_MSRS, (void *)&msrs) == -1)
1503         panic("KVM: Failed to get guest MSRs (errno: %i)\n",
1504               errno);
1505 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a7c08fc9f9ab36f8eda2a3cfe6c234635}{
\index{X86KvmCPU@{X86KvmCPU}!getVCpuEvents@{getVCpuEvents}}
\index{getVCpuEvents@{getVCpuEvents}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{getVCpuEvents}]{\setlength{\rightskip}{0pt plus 5cm}void getVCpuEvents (struct kvm\_\-vcpu\_\-events \& {\em events}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_a7c08fc9f9ab36f8eda2a3cfe6c234635}



\begin{DoxyCode}
1613 {
1614     if (ioctl(KVM_GET_VCPU_EVENTS, &events) == -1)
1615         panic("KVM: Failed to get guest debug registers\n");
1616 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a6744a04655bbdcee8aa24919573d8698}{
\index{X86KvmCPU@{X86KvmCPU}!getXCRs@{getXCRs}}
\index{getXCRs@{getXCRs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{getXCRs}]{\setlength{\rightskip}{0pt plus 5cm}void getXCRs (struct kvm\_\-xcrs \& {\em regs}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_a6744a04655bbdcee8aa24919573d8698}



\begin{DoxyCode}
1584 {
1585     if (ioctl(KVM_GET_XCRS, &regs) == -1)
1586         panic("KVM: Failed to get guest debug registers\n");
1587 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_af9f89d561ce9170ad89e6582071c1169}{
\index{X86KvmCPU@{X86KvmCPU}!getXSave@{getXSave}}
\index{getXSave@{getXSave}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{getXSave}]{\setlength{\rightskip}{0pt plus 5cm}void getXSave (struct kvm\_\-xsave \& {\em xsave}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_af9f89d561ce9170ad89e6582071c1169}



\begin{DoxyCode}
1598 {
1599     if (ioctl(KVM_GET_XSAVE, &xsave) == -1)
1600         panic("KVM: Failed to get guest debug registers\n");
1601 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a58452f4681b53990ff7470d1884ac13c}{
\index{X86KvmCPU@{X86KvmCPU}!handleIOMiscReg32@{handleIOMiscReg32}}
\index{handleIOMiscReg32@{handleIOMiscReg32}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{handleIOMiscReg32}]{\setlength{\rightskip}{0pt plus 5cm}void handleIOMiscReg32 (int {\em miscreg})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86KvmCPU_a58452f4681b53990ff7470d1884ac13c}
Handle a 32-\/bit IO access that should be mapped to a MiscReg.

\begin{DoxyNote}{覚え書き}
This method can only be called on when handling IO after a KVM\_\-EXIT\_\-IO.
\end{DoxyNote}

\begin{DoxyParams}{引数}
\item[{\em miscreg}]\hyperlink{classRegister}{Register} to map the current IO access to. \end{DoxyParams}



\begin{DoxyCode}
1285 {
1286     struct kvm_run &kvm_run(*getKvmRunState());
1287     const uint16_t port(kvm_run.io.port);
1288 
1289     assert(kvm_run.exit_reason == KVM_EXIT_IO);
1290 
1291     if (kvm_run.io.size != 4) {
1292         panic("Unexpected IO size (%u) for address 0x%x.\n",
1293               kvm_run.io.size, port);
1294     }
1295 
1296     if (kvm_run.io.count != 1) {
1297         panic("Unexpected IO count (%u) for address 0x%x.\n",
1298               kvm_run.io.count, port);
1299     }
1300 
1301     uint32_t *data((uint32_t *)getGuestData(kvm_run.io.data_offset));
1302     if (kvm_run.io.direction == KVM_EXIT_IO_OUT)
1303         tc->setMiscReg(miscreg, *data);
1304     else
1305         *data = tc->readMiscRegNoEffect(miscreg);
1306 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a404fbd80d6676724d026a932b2258dc7}{
\index{X86KvmCPU@{X86KvmCPU}!handleKvmExitIO@{handleKvmExitIO}}
\index{handleKvmExitIO@{handleKvmExitIO}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{handleKvmExitIO}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} handleKvmExitIO ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classX86KvmCPU_a404fbd80d6676724d026a932b2258dc7}
Handle x86 legacy IO (in/out) 

\hyperlink{classBaseKvmCPU_a404fbd80d6676724d026a932b2258dc7}{BaseKvmCPU}を再定義しています。


\begin{DoxyCode}
1310 {
1311     struct kvm_run &kvm_run(*getKvmRunState());
1312     bool isWrite(kvm_run.io.direction == KVM_EXIT_IO_OUT);
1313     unsigned char *guestData(getGuestData(kvm_run.io.data_offset));
1314     Tick delay(0);
1315     uint16_t port(kvm_run.io.port);
1316     Addr pAddr;
1317     const int count(kvm_run.io.count);
1318 
1319     assert(kvm_run.io.direction == KVM_EXIT_IO_IN ||
1320            kvm_run.io.direction == KVM_EXIT_IO_OUT);
1321 
1322     DPRINTF(KvmIO, "KVM-x86: Handling IO instruction (%s) (port: 0x%x)\n",
1323             (isWrite ? "out" : "in"), kvm_run.io.port);
1324 
1325     /* Vanilla gem5 handles PCI discovery in the TLB(!). Since we
1326      * don't use the TLB component, we need to intercept and handle
1327      * the PCI configuration space IO ports here.
1328      *
1329      * The IO port PCI discovery mechanism uses one address register
1330      * and one data register. We map the address register to a misc
1331      * reg and use that to re-route data register accesses to the
1332      * right location in the PCI configuration space.
1333      */
1334     if (port == IO_PCI_CONF_ADDR) {
1335         handleIOMiscReg32(MISCREG_PCI_CONFIG_ADDRESS);
1336         return 0;
1337     } else if ((port & ~0x3) == IO_PCI_CONF_DATA_BASE) {
1338         Addr pciConfigAddr(tc->readMiscRegNoEffect(MISCREG_PCI_CONFIG_ADDRESS));
1339         if (pciConfigAddr & 0x80000000) {
1340             pAddr = X86ISA::x86PciConfigAddress((pciConfigAddr & 0x7ffffffc) |
1341                                                 (port & 0x3));
1342         } else {
1343             pAddr = X86ISA::x86IOAddress(port);
1344         }
1345     } else {
1346         pAddr = X86ISA::x86IOAddress(port);
1347     }
1348 
1349     io_req.setPhys(pAddr, kvm_run.io.size, Request::UNCACHEABLE,
1350                    dataMasterId());
1351 
1352     const MemCmd cmd(isWrite ? MemCmd::WriteReq : MemCmd::ReadReq);
1353     // Temporarily lock and migrate to the event queue of the
1354     // VM. This queue is assumed to "own" all devices we need to
1355     // access if running in multi-core mode.
1356     EventQueue::ScopedMigration migrate(vm.eventQueue());
1357     for (int i = 0; i < count; ++i) {
1358         Packet pkt(&io_req, cmd);
1359 
1360         pkt.dataStatic(guestData);
1361         delay += dataPort.sendAtomic(&pkt);
1362 
1363         guestData += kvm_run.io.size;
1364     }
1365 
1366     return delay;
1367 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a405e34c9d079e8823ac2a1ca0e816a47}{
\index{X86KvmCPU@{X86KvmCPU}!handleKvmExitIRQWindowOpen@{handleKvmExitIRQWindowOpen}}
\index{handleKvmExitIRQWindowOpen@{handleKvmExitIRQWindowOpen}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{handleKvmExitIRQWindowOpen}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} handleKvmExitIRQWindowOpen ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classX86KvmCPU_a405e34c9d079e8823ac2a1ca0e816a47}
The guest exited because an interrupt window was requested

The guest exited because an interrupt window was requested (request\_\-interrupt\_\-window in the kvm\_\-run structure was set to 1 before calling kvmRun) and it is now ready to receive

\begin{DoxyReturn}{戻り値}
Number of ticks spent servicing the IRQ 
\end{DoxyReturn}


\hyperlink{classBaseKvmCPU_a405e34c9d079e8823ac2a1ca0e816a47}{BaseKvmCPU}を再定義しています。


\begin{DoxyCode}
1371 {
1372     // We don't need to do anything here since this is caught the next
1373     // time we execute kvmRun(). We still overload the exit event to
1374     // silence the warning about an unhandled exit event.
1375     return 0;
1376 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}{
\index{X86KvmCPU@{X86KvmCPU}!kvmRun@{kvmRun}}
\index{kvmRun@{kvmRun}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{kvmRun}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} kvmRun ({\bf Tick} {\em ticks})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classX86KvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}
\hyperlink{classRequest}{Request} KVM to run the guest for a given number of ticks. The method returns the approximate number of ticks executed.

\begin{DoxyNote}{覚え書き}
The returned number of ticks can be both larger or smaller than the requested number of ticks. A smaller number can, for example, occur when the guest executes MMIO. A larger number is typically due to performance counter inaccuracies.

This method is virtual in order to allow implementations to check for architecture specific events (e.g., interrupts) before entering the VM.

It is the response of the caller (normally \hyperlink{classBaseKvmCPU_a873dd91783f9efb4a590aded1f70d6b0}{tick()}) to make sure that the KVM state is synchronized and that the TC is invalidated after entering KVM.

This method does not normally cause any state transitions. However, if it may suspend the CPU by suspending the thread, which leads to a transition to the Idle state. In such a case, kvm {\itshape must not\/} be entered.
\end{DoxyNote}

\begin{DoxyParams}{引数}
\item[{\em ticks}]Number of ticks to execute, set to 0 to exit immediately after finishing pending operations. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Number of ticks executed (see note) 
\end{DoxyReturn}


\hyperlink{classBaseKvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}{BaseKvmCPU}を再定義しています。


\begin{DoxyCode}
1189 {
1190     struct kvm_run &kvm_run(*getKvmRunState());
1191 
1192     if (interrupts->checkInterruptsRaw()) {
1193         if (interrupts->hasPendingUnmaskable()) {
1194             DPRINTF(KvmInt,
1195                     "Delivering unmaskable interrupt.\n");
1196             syncThreadContext();
1197             deliverInterrupts();
1198         } else if (kvm_run.ready_for_interrupt_injection) {
1199             // KVM claims that it is ready for an interrupt. It might
1200             // be lying if we just updated rflags and disabled
1201             // interrupts (e.g., by doing a CPU handover). Let's sync
1202             // the thread context and check if there are /really/
1203             // interrupts that should be delivered now.
1204             syncThreadContext();
1205             if (interrupts->checkInterrupts(tc)) {
1206                 DPRINTF(KvmInt,
1207                         "M5 has pending interrupts, delivering interrupt.\n");
1208 
1209                 deliverInterrupts();
1210             } else {
1211                 DPRINTF(KvmInt,
1212                         "Interrupt delivery delayed due to KVM confusion.\n");
1213                 kvm_run.request_interrupt_window = 1;
1214             }
1215         } else if (!kvm_run.request_interrupt_window) {
1216             DPRINTF(KvmInt,
1217                     "M5 has pending interrupts, requesting interrupt "
1218                     "window.\n");
1219             kvm_run.request_interrupt_window = 1;
1220         }
1221     } else {
1222         kvm_run.request_interrupt_window = 0;
1223     }
1224 
1225     // The CPU might have been suspended as a result of the INIT
1226     // interrupt delivery hack. In that case, don't enter into KVM.
1227     if (_status == Idle)
1228         return 0;
1229     else
1230         return kvmRunWrapper(ticks);
1231 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a405afc17ad0dee3b816012ce909b2b6f}{
\index{X86KvmCPU@{X86KvmCPU}!kvmRunDrain@{kvmRunDrain}}
\index{kvmRunDrain@{kvmRunDrain}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{kvmRunDrain}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} kvmRunDrain ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classX86KvmCPU_a405afc17ad0dee3b816012ce909b2b6f}
Run the virtual CPU until draining completes.

In addition to the base functionality provided by \hyperlink{classBaseKvmCPU_a405afc17ad0dee3b816012ce909b2b6f}{BaseKvmCPU::kvmRunDrain()}, this method handles x86-\/specific cases where there are pending interrupt events in the virtual CPU. These are handled by requesting an interrupt window if interrupts are pending (causing the vCPU to execute until interrupts can be delivered again).

\begin{DoxySeeAlso}{参照}
\hyperlink{classBaseKvmCPU_a405afc17ad0dee3b816012ce909b2b6f}{BaseKvmCPU::kvmRunDrain()} 

\hyperlink{classX86KvmCPU_a1d97c7e0665d576bb463335078bb02ec}{archIsDrained()}
\end{DoxySeeAlso}
\begin{DoxyReturn}{戻り値}
Number of ticks executed 
\end{DoxyReturn}


\hyperlink{classBaseKvmCPU_a405afc17ad0dee3b816012ce909b2b6f}{BaseKvmCPU}を再定義しています。


\begin{DoxyCode}
1235 {
1236     struct kvm_run &kvm_run(*getKvmRunState());
1237 
1238     if (!archIsDrained()) {
1239         DPRINTF(Drain, "kvmRunDrain: Architecture code isn't drained\n");
1240 
1241         // Tell KVM to find a suitable place to deliver interrupts. This
1242         // should ensure that pending interrupts have been delivered and
1243         // things are reasonably consistent (i.e., no interrupts pending
1244         // in the guest).
1245         kvm_run.request_interrupt_window = 1;
1246 
1247         // Limit the run to 1 millisecond. That is hopefully enough to
1248         // reach an interrupt window. Otherwise, we'll just try again
1249         // later.
1250         return kvmRunWrapper(1 * SimClock::Float::ms);
1251     } else {
1252         DPRINTF(Drain, "kvmRunDrain: Delivering pending IO\n");
1253 
1254         return kvmRunWrapper(0);
1255     }
1256 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_afae1f96b6b1a482f400cd925b8709325}{
\index{X86KvmCPU@{X86KvmCPU}!kvmRunWrapper@{kvmRunWrapper}}
\index{kvmRunWrapper@{kvmRunWrapper}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{kvmRunWrapper}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} kvmRunWrapper ({\bf Tick} {\em ticks})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_afae1f96b6b1a482f400cd925b8709325}
Wrapper that synchronizes state in kvm\_\-run 


\begin{DoxyCode}
1260 {
1261     struct kvm_run &kvm_run(*getKvmRunState());
1262 
1263     // Synchronize the APIC base and CR8 here since they are present
1264     // in the kvm_run struct, which makes the synchronization really
1265     // cheap.
1266     kvm_run.apic_base = tc->readMiscReg(MISCREG_APIC_BASE);
1267     kvm_run.cr8 = tc->readMiscReg(MISCREG_CR8);
1268 
1269     const Tick run_ticks(BaseKvmCPU::kvmRun(ticks));
1270 
1271     tc->setMiscReg(MISCREG_APIC_BASE, kvm_run.apic_base);
1272     kvm_run.cr8 = tc->readMiscReg(MISCREG_CR8);
1273 
1274     return run_ticks;
1275 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a6782fae08bf69ed6903f49bfbee81566}{
\index{X86KvmCPU@{X86KvmCPU}!setCPUID@{setCPUID}}
\index{setCPUID@{setCPUID}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{setCPUID}]{\setlength{\rightskip}{0pt plus 5cm}void setCPUID (const {\bf Kvm::CPUIDVector} \& {\em cpuid})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_a6782fae08bf69ed6903f49bfbee81566}



\begin{DoxyCode}
1469 {
1470     std::unique_ptr<struct kvm_cpuid2> kvm_cpuid(
1471         newVarStruct<struct kvm_cpuid2, struct kvm_cpuid_entry2>(cpuid.size()));
1472 
1473     kvm_cpuid->nent = cpuid.size();
1474     std::copy(cpuid.begin(), cpuid.end(), kvm_cpuid->entries);
1475 
1476     setCPUID(*kvm_cpuid);
1477 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_ae1aa75790696eb8780d159812f607921}{
\index{X86KvmCPU@{X86KvmCPU}!setCPUID@{setCPUID}}
\index{setCPUID@{setCPUID}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{setCPUID}]{\setlength{\rightskip}{0pt plus 5cm}void setCPUID (const struct kvm\_\-cpuid2 \& {\em cpuid})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_ae1aa75790696eb8780d159812f607921}
Methods to access CPUID information using the extended API. Only available if \hyperlink{classKvm_a6db5aefbe1a9535f5124ef07a04e23a5}{Kvm::capExtendedCPUID()} is true. 


\begin{DoxyCode}
1461 {
1462     if (ioctl(KVM_SET_CPUID2, (void *)&cpuid) == -1)
1463         panic("KVM: Failed to set guest CPUID2 (errno: %i)\n",
1464               errno);
1465 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a0c0b94046f41e2b83c8f224e9f227d0f}{
\index{X86KvmCPU@{X86KvmCPU}!setDebugRegisters@{setDebugRegisters}}
\index{setDebugRegisters@{setDebugRegisters}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{setDebugRegisters}]{\setlength{\rightskip}{0pt plus 5cm}void setDebugRegisters (const struct kvm\_\-debugregs \& {\em regs})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_a0c0b94046f41e2b83c8f224e9f227d0f}



\begin{DoxyCode}
1573 {
1574 #ifdef KVM_SET_DEBUGREGS
1575     if (ioctl(KVM_SET_DEBUGREGS, (void *)&regs) == -1)
1576         panic("KVM: Failed to set guest debug registers\n");
1577 #else
1578     panic("KVM: Unsupported setDebugRegisters call.\n");
1579 #endif
1580 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a3d32029e1dfb4da512897794d56e9fc8}{
\index{X86KvmCPU@{X86KvmCPU}!setMSR@{setMSR}}
\index{setMSR@{setMSR}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{setMSR}]{\setlength{\rightskip}{0pt plus 5cm}void setMSR ({\bf uint32\_\-t} {\em index}, \/  uint64\_\-t {\em value})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_a3d32029e1dfb4da512897794d56e9fc8}



\begin{DoxyCode}
1510 {
1511     std::unique_ptr<struct kvm_msrs> kvm_msrs(
1512         newVarStruct<struct kvm_msrs, struct kvm_msr_entry>(1));
1513     struct kvm_msr_entry &entry(kvm_msrs->entries[0]);
1514 
1515     kvm_msrs->nmsrs = 1;
1516     entry.index = index;
1517     entry.reserved = 0;
1518     entry.data = value;
1519 
1520     setMSRs(*kvm_msrs.get());
1521 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_acc0ac79f886623c5e0ce73b393402148}{
\index{X86KvmCPU@{X86KvmCPU}!setMSRs@{setMSRs}}
\index{setMSRs@{setMSRs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{setMSRs}]{\setlength{\rightskip}{0pt plus 5cm}void setMSRs (const {\bf KvmMSRVector} \& {\em msrs})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_acc0ac79f886623c5e0ce73b393402148}



\begin{DoxyCode}
1489 {
1490     std::unique_ptr<struct kvm_msrs> kvm_msrs(
1491         newVarStruct<struct kvm_msrs, struct kvm_msr_entry>(msrs.size()));
1492 
1493     kvm_msrs->nmsrs = msrs.size();
1494     std::copy(msrs.begin(), msrs.end(), kvm_msrs->entries);
1495 
1496     setMSRs(*kvm_msrs);
1497 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a37c723660e4a4aa0ebb42ee498df990b}{
\index{X86KvmCPU@{X86KvmCPU}!setMSRs@{setMSRs}}
\index{setMSRs@{setMSRs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{setMSRs}]{\setlength{\rightskip}{0pt plus 5cm}void setMSRs (const struct kvm\_\-msrs \& {\em msrs})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_a37c723660e4a4aa0ebb42ee498df990b}
Methods to access MSRs in the guest. 


\begin{DoxyCode}
1481 {
1482     if (ioctl(KVM_SET_MSRS, (void *)&msrs) == -1)
1483         panic("KVM: Failed to set guest MSRs (errno: %i)\n",
1484               errno);
1485 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a70cfa7f84580af5396fbc82f540c8a5b}{
\index{X86KvmCPU@{X86KvmCPU}!setVCpuEvents@{setVCpuEvents}}
\index{setVCpuEvents@{setVCpuEvents}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{setVCpuEvents}]{\setlength{\rightskip}{0pt plus 5cm}void setVCpuEvents (const struct kvm\_\-vcpu\_\-events \& {\em events})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_a70cfa7f84580af5396fbc82f540c8a5b}



\begin{DoxyCode}
1620 {
1621     if (ioctl(KVM_SET_VCPU_EVENTS, (void *)&events) == -1)
1622         panic("KVM: Failed to set guest debug registers\n");
1623 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a929420a323cb83ab21bdf3efa22edd24}{
\index{X86KvmCPU@{X86KvmCPU}!setXCRs@{setXCRs}}
\index{setXCRs@{setXCRs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{setXCRs}]{\setlength{\rightskip}{0pt plus 5cm}void setXCRs (const struct kvm\_\-xcrs \& {\em regs})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_a929420a323cb83ab21bdf3efa22edd24}



\begin{DoxyCode}
1591 {
1592     if (ioctl(KVM_SET_XCRS, (void *)&regs) == -1)
1593         panic("KVM: Failed to set guest debug registers\n");
1594 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_aa05e7c39fbe7374815b387728b7de06d}{
\index{X86KvmCPU@{X86KvmCPU}!setXSave@{setXSave}}
\index{setXSave@{setXSave}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{setXSave}]{\setlength{\rightskip}{0pt plus 5cm}void setXSave (const struct kvm\_\-xsave \& {\em xsave})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86KvmCPU_aa05e7c39fbe7374815b387728b7de06d}



\begin{DoxyCode}
1605 {
1606     if (ioctl(KVM_SET_XSAVE, (void *)&xsave) == -1)
1607         panic("KVM: Failed to set guest debug registers\n");
1608 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_aecc7d8debf54990ffeaaed5bac7d7d81}{
\index{X86KvmCPU@{X86KvmCPU}!startup@{startup}}
\index{startup@{startup}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{startup}]{\setlength{\rightskip}{0pt plus 5cm}void startup ()}}
\label{classX86KvmCPU_aecc7d8debf54990ffeaaed5bac7d7d81}


\hyperlink{classBaseKvmCPU_aecc7d8debf54990ffeaaed5bac7d7d81}{BaseKvmCPU}を再定義しています。


\begin{DoxyCode}
552 {
553     BaseKvmCPU::startup();
554 
555     updateCPUID();
556 
557     io_req.setThreadContext(tc->contextId(), 0);
558 
559     // TODO: Do we need to create an identity mapped TSS area? We
560     // should call kvm.vm.setTSSAddress() here in that case. It should
561     // only be needed for old versions of the virtualization
562     // extensions. We should make sure that the identity range is
563     // reserved in the e820 memory map in that case.
564 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_adcec996536ccdb020b08a11d61a47d44}{
\index{X86KvmCPU@{X86KvmCPU}!updateCPUID@{updateCPUID}}
\index{updateCPUID@{updateCPUID}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{updateCPUID}]{\setlength{\rightskip}{0pt plus 5cm}void updateCPUID ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86KvmCPU_adcec996536ccdb020b08a11d61a47d44}
Transfer gem5's CPUID values into the virtual CPU. 


\begin{DoxyCode}
1425 {
1426     Kvm::CPUIDVector m5_supported;
1427 
1428     /* TODO: We currently don't support any of the functions that
1429      * iterate through data structures in the CPU using an index. It's
1430      * currently not a problem since M5 doesn't expose any of them at
1431      * the moment.
1432      */
1433 
1434     /* Basic features */
1435     CpuidResult func0;
1436     X86ISA::doCpuid(tc, 0x0, 0, func0);
1437     for (uint32_t function = 0; function <= func0.rax; ++function) {
1438         CpuidResult cpuid;
1439         uint32_t idx(0);
1440 
1441         X86ISA::doCpuid(tc, function, idx, cpuid);
1442         m5_supported.push_back(makeKvmCpuid(function, idx, cpuid));
1443     }
1444 
1445     /* Extended features */
1446     CpuidResult efunc0;
1447     X86ISA::doCpuid(tc, 0x80000000, 0, efunc0);
1448     for (uint32_t function = 0x80000000; function <= efunc0.rax; ++function) {
1449         CpuidResult cpuid;
1450         uint32_t idx(0);
1451 
1452         X86ISA::doCpuid(tc, function, idx, cpuid);
1453         m5_supported.push_back(makeKvmCpuid(function, idx, cpuid));
1454     }
1455 
1456     setCPUID(m5_supported);
1457 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a93c6e8c82dfb63c7039f0cbf064fae5d}{
\index{X86KvmCPU@{X86KvmCPU}!updateKvmState@{updateKvmState}}
\index{updateKvmState@{updateKvmState}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{updateKvmState}]{\setlength{\rightskip}{0pt plus 5cm}void updateKvmState ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classX86KvmCPU_a93c6e8c82dfb63c7039f0cbf064fae5d}
Update the KVM state from the current thread context

The base CPU calls this method before starting the guest CPU when the contextDirty flag is set. The architecture dependent CPU implementation is expected to update all guest state (registers, special registers, and FPU state). 

\hyperlink{classBaseKvmCPU_a48817be7bf03ef44cc5114ecf4df9b27}{BaseKvmCPU}を実装しています。


\begin{DoxyCode}
673 {
674     updateKvmStateRegs();
675     updateKvmStateSRegs();
676     updateKvmStateFPU();
677     updateKvmStateMSRs();
678 
679     DPRINTF(KvmContext, "X86KvmCPU::updateKvmState():\n");
680     if (DTRACE(KvmContext))
681         dump();
682 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a1c8ff9ec0ad33f11a2212a37e2a79f6c}{
\index{X86KvmCPU@{X86KvmCPU}!updateKvmStateFPU@{updateKvmStateFPU}}
\index{updateKvmStateFPU@{updateKvmStateFPU}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{updateKvmStateFPU}]{\setlength{\rightskip}{0pt plus 5cm}void updateKvmStateFPU ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86KvmCPU_a1c8ff9ec0ad33f11a2212a37e2a79f6c}
Update FPU and SIMD registers

This method uses the appropriate (depending on availability and user configuration) kernel API by calling \hyperlink{classX86KvmCPU_a3eccabf97e73ee194068ee37c2422c50}{updateKvmStateFPULegacy()} or \hyperlink{classX86KvmCPU_aa1d3c8572c67dd0c4457ba46307f35f1}{updateKvmStateFPUXSave()}.

\begin{DoxySeeAlso}{参照}
\hyperlink{classX86KvmCPU_a3eccabf97e73ee194068ee37c2422c50}{updateKvmStateFPULegacy()} 

\hyperlink{classX86KvmCPU_aa1d3c8572c67dd0c4457ba46307f35f1}{updateKvmStateFPUXSave()} 
\end{DoxySeeAlso}



\begin{DoxyCode}
907 {
908     if (useXSave)
909         updateKvmStateFPUXSave();
910     else
911         updateKvmStateFPULegacy();
912 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a3eccabf97e73ee194068ee37c2422c50}{
\index{X86KvmCPU@{X86KvmCPU}!updateKvmStateFPULegacy@{updateKvmStateFPULegacy}}
\index{updateKvmStateFPULegacy@{updateKvmStateFPULegacy}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{updateKvmStateFPULegacy}]{\setlength{\rightskip}{0pt plus 5cm}void updateKvmStateFPULegacy ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86KvmCPU_a3eccabf97e73ee194068ee37c2422c50}
Update FPU and SIMD registers using the legacy API

\begin{DoxyNote}{覚え書き}
This method should normally only be called by \hyperlink{classX86KvmCPU_a1c8ff9ec0ad33f11a2212a37e2a79f6c}{updateKvmStateFPU()} which automatically chooses between available APIs. 
\end{DoxyNote}



\begin{DoxyCode}
858 {
859     struct kvm_fpu fpu;
860 
861     // There is some padding in the FP registers, so we'd better zero
862     // the whole struct.
863     memset(&fpu, 0, sizeof(fpu));
864 
865     updateKvmStateFPUCommon(tc, fpu);
866 
867     if (tc->readMiscRegNoEffect(MISCREG_FISEG))
868         warn_once("MISCREG_FISEG is non-zero.\n");
869 
870     fpu.last_ip = tc->readMiscRegNoEffect(MISCREG_FIOFF);
871 
872     if (tc->readMiscRegNoEffect(MISCREG_FOSEG))
873         warn_once("MISCREG_FOSEG is non-zero.\n");
874 
875     fpu.last_dp = tc->readMiscRegNoEffect(MISCREG_FOOFF);
876 
877     setFPUState(fpu);
878 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_aa1d3c8572c67dd0c4457ba46307f35f1}{
\index{X86KvmCPU@{X86KvmCPU}!updateKvmStateFPUXSave@{updateKvmStateFPUXSave}}
\index{updateKvmStateFPUXSave@{updateKvmStateFPUXSave}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{updateKvmStateFPUXSave}]{\setlength{\rightskip}{0pt plus 5cm}void updateKvmStateFPUXSave ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86KvmCPU_aa1d3c8572c67dd0c4457ba46307f35f1}
Update FPU and SIMD registers using the XSave API

\begin{DoxyNote}{覚え書き}
This method should normally only be called by \hyperlink{classX86KvmCPU_a1c8ff9ec0ad33f11a2212a37e2a79f6c}{updateKvmStateFPU()} which automatically chooses between available APIs. 
\end{DoxyNote}



\begin{DoxyCode}
882 {
883     struct kvm_xsave kxsave;
884     FXSave &xsave(*(FXSave *)kxsave.region);
885 
886     // There is some padding and reserved fields in the structure, so
887     // we'd better zero the whole thing.
888     memset(&kxsave, 0, sizeof(kxsave));
889 
890     updateKvmStateFPUCommon(tc, xsave);
891 
892     if (tc->readMiscRegNoEffect(MISCREG_FISEG))
893         warn_once("MISCREG_FISEG is non-zero.\n");
894 
895     xsave.ctrl64.fpu_ip = tc->readMiscRegNoEffect(MISCREG_FIOFF);
896 
897     if (tc->readMiscRegNoEffect(MISCREG_FOSEG))
898         warn_once("MISCREG_FOSEG is non-zero.\n");
899 
900     xsave.ctrl64.fpu_dp = tc->readMiscRegNoEffect(MISCREG_FOOFF);
901 
902     setXSave(kxsave);
903 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_ad04202aafaacd818cf2621c5a31926c1}{
\index{X86KvmCPU@{X86KvmCPU}!updateKvmStateMSRs@{updateKvmStateMSRs}}
\index{updateKvmStateMSRs@{updateKvmStateMSRs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{updateKvmStateMSRs}]{\setlength{\rightskip}{0pt plus 5cm}void updateKvmStateMSRs ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86KvmCPU_ad04202aafaacd818cf2621c5a31926c1}
Update MSR registers 


\begin{DoxyCode}
916 {
917     KvmMSRVector msrs;
918 
919     const Kvm::MSRIndexVector &indices(getMsrIntersection());
920 
921     for (auto it = indices.cbegin(); it != indices.cend(); ++it) {
922         struct kvm_msr_entry e;
923 
924         e.index = *it;
925         e.reserved = 0;
926         e.data = tc->readMiscReg(msrMap.at(*it));
927         DPRINTF(KvmContext, "Adding MSR: idx: 0x%x, data: 0x%x\n",
928                 e.index, e.data);
929 
930         msrs.push_back(e);
931     }
932 
933     setMSRs(msrs);
934 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a54e3879c7bcd8aac9d1b88350e7674fe}{
\index{X86KvmCPU@{X86KvmCPU}!updateKvmStateRegs@{updateKvmStateRegs}}
\index{updateKvmStateRegs@{updateKvmStateRegs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{updateKvmStateRegs}]{\setlength{\rightskip}{0pt plus 5cm}void updateKvmStateRegs ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86KvmCPU_a54e3879c7bcd8aac9d1b88350e7674fe}
Support routines to update the state of the KVM CPU from gem5's state representation. Update integer registers 


\begin{DoxyCode}
686 {
687     struct kvm_regs regs;
688 
689 #define APPLY_IREG(kreg, mreg) regs.kreg = tc->readIntReg(mreg)
690     FOREACH_IREG();
691 #undef APPLY_IREG
692 
693     regs.rip = tc->instAddr() - tc->readMiscReg(MISCREG_CS_BASE);
694 
695     /* You might think that setting regs.rflags to the contents
696      * MISCREG_RFLAGS here would suffice. In that case you're
697      * mistaken. We need to reconstruct it from a bunch of ucode
698      * registers and wave a dead chicken over it (aka mask out and set
699      * reserved bits) to get it to work.
700      */
701     regs.rflags = X86ISA::getRFlags(tc);
702 
703     setRegisters(regs);
704 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_af58754cb34827756e0e0fc8474c54a8e}{
\index{X86KvmCPU@{X86KvmCPU}!updateKvmStateSRegs@{updateKvmStateSRegs}}
\index{updateKvmStateSRegs@{updateKvmStateSRegs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{updateKvmStateSRegs}]{\setlength{\rightskip}{0pt plus 5cm}void updateKvmStateSRegs ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86KvmCPU_af58754cb34827756e0e0fc8474c54a8e}
Update control registers (CRx, segments, etc.) 


\begin{DoxyCode}
753 {
754     struct kvm_sregs sregs;
755 
756 #define APPLY_SREG(kreg, mreg) sregs.kreg = tc->readMiscRegNoEffect(mreg)
757 #define APPLY_SEGMENT(kreg, idx) setKvmSegmentReg(tc, sregs.kreg, idx)
758 #define APPLY_DTABLE(kreg, idx) setKvmDTableReg(tc, sregs.kreg, idx)
759 
760     FOREACH_SREG();
761     FOREACH_SEGMENT();
762     FOREACH_DTABLE();
763 
764 #undef APPLY_SREG
765 #undef APPLY_SEGMENT
766 #undef APPLY_DTABLE
767 
768     // Clear the interrupt bitmap
769     memset(&sregs.interrupt_bitmap, 0, sizeof(sregs.interrupt_bitmap));
770 
771     // VMX requires CS, SS, DS, ES, FS, and GS to have the accessed
772     // bit in the type field set.
773     forceSegAccessed(sregs.cs);
774     forceSegAccessed(sregs.ss);
775     forceSegAccessed(sregs.ds);
776     forceSegAccessed(sregs.es);
777     forceSegAccessed(sregs.fs);
778     forceSegAccessed(sregs.gs);
779 
780     // There are currently some cases where the active task isn't
781     // marked as busy. This is illegal in VMX, so we force it to busy.
782     if (sregs.tr.type == SEG_SYS_TYPE_TSS_AVAILABLE) {
783         hack("tr.type (%i) is not busy. Forcing the busy bit.\n",
784              sregs.tr.type);
785         sregs.tr.type = SEG_SYS_TYPE_TSS_BUSY;
786     }
787 
788     // VMX requires the DPL of SS and CS to be the same for
789     // non-conforming code segments. It seems like m5 doesn't set the
790     // DPL of SS correctly when taking interrupts, so we need to fix
791     // that here.
792     if ((sregs.cs.type == SEG_CS_TYPE_ACCESSED ||
793          sregs.cs.type == SEG_CS_TYPE_READ_ACCESSED) &&
794         sregs.cs.dpl != sregs.ss.dpl) {
795 
796         hack("CS.DPL (%i) != SS.DPL (%i): Forcing SS.DPL to %i\n",
797              sregs.cs.dpl, sregs.ss.dpl, sregs.cs.dpl);
798         sregs.ss.dpl = sregs.cs.dpl;
799     }
800 
801     // Do checks after fixing up the state to avoid getting excessive
802     // amounts of warnings.
803     RFLAGS rflags_nocc(tc->readMiscReg(MISCREG_RFLAGS));
804     if (!rflags_nocc.vm) {
805         // Do segment verification if the CPU isn't entering virtual
806         // 8086 mode.  We currently assume that unrestricted guest
807         // mode is available.
808 
809 #define APPLY_SEGMENT(kreg, idx) \
810         checkSeg(# kreg, idx + MISCREG_SEG_SEL_BASE, sregs.kreg, sregs)
811 
812         FOREACH_SEGMENT();
813 #undef APPLY_SEGMENT
814     }
815 
816     setSpecialRegisters(sregs);
817 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_adbd5e38eae7c8c3021f2c4f430b399fd}{
\index{X86KvmCPU@{X86KvmCPU}!updateThreadContext@{updateThreadContext}}
\index{updateThreadContext@{updateThreadContext}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{updateThreadContext}]{\setlength{\rightskip}{0pt plus 5cm}void updateThreadContext ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classX86KvmCPU_adbd5e38eae7c8c3021f2c4f430b399fd}
Update the current thread context with the KVM state

The base CPU after the guest updates any of the KVM state. In practice, this happens after kvmRun is called. The architecture dependent code is expected to read the state of the guest CPU and update gem5's thread state. 

\hyperlink{classBaseKvmCPU_ac47bfb587580ca76050e0c9bc753c10d}{BaseKvmCPU}を実装しています。


\begin{DoxyCode}
938 {
939     struct kvm_regs regs;
940     struct kvm_sregs sregs;
941 
942     getRegisters(regs);
943     getSpecialRegisters(sregs);
944 
945     DPRINTF(KvmContext, "X86KvmCPU::updateThreadContext():\n");
946     if (DTRACE(KvmContext))
947         dump();
948 
949     updateThreadContextRegs(regs, sregs);
950     updateThreadContextSRegs(sregs);
951     if (useXSave) {
952         struct kvm_xsave xsave;
953         getXSave(xsave);
954 
955        updateThreadContextXSave(xsave);
956     } else {
957         struct kvm_fpu fpu;
958         getFPUState(fpu);
959 
960         updateThreadContextFPU(fpu);
961     }
962     updateThreadContextMSRs();
963 
964     // The M5 misc reg caches some values from other
965     // registers. Writing to it with side effects causes it to be
966     // updated from its source registers.
967     tc->setMiscReg(MISCREG_M5_REG, 0);
968 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a1f9b85cc469eb72bbf377872c1404c1e}{
\index{X86KvmCPU@{X86KvmCPU}!updateThreadContextFPU@{updateThreadContextFPU}}
\index{updateThreadContextFPU@{updateThreadContextFPU}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{updateThreadContextFPU}]{\setlength{\rightskip}{0pt plus 5cm}void updateThreadContextFPU (const struct kvm\_\-fpu \& {\em fpu})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86KvmCPU_a1f9b85cc469eb72bbf377872c1404c1e}
Update FPU and SIMD registers using the legacy API 


\begin{DoxyCode}
1082 {
1083     updateThreadContextFPUCommon(tc, fpu);
1084 
1085     tc->setMiscRegNoEffect(MISCREG_FISEG, 0);
1086     tc->setMiscRegNoEffect(MISCREG_FIOFF, fpu.last_ip);
1087     tc->setMiscRegNoEffect(MISCREG_FOSEG, 0);
1088     tc->setMiscRegNoEffect(MISCREG_FOOFF, fpu.last_dp);
1089 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_ad0f81dc69ee0b095b4c9eeec4491ed39}{
\index{X86KvmCPU@{X86KvmCPU}!updateThreadContextMSRs@{updateThreadContextMSRs}}
\index{updateThreadContextMSRs@{updateThreadContextMSRs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{updateThreadContextMSRs}]{\setlength{\rightskip}{0pt plus 5cm}void updateThreadContextMSRs ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86KvmCPU_ad0f81dc69ee0b095b4c9eeec4491ed39}
Update MSR registers 


\begin{DoxyCode}
1106 {
1107     const Kvm::MSRIndexVector &msrs(getMsrIntersection());
1108 
1109     std::unique_ptr<struct kvm_msrs> kvm_msrs(
1110         newVarStruct<struct kvm_msrs, struct kvm_msr_entry>(msrs.size()));
1111     struct kvm_msr_entry *entry;
1112 
1113     // Create a list of MSRs to read
1114     kvm_msrs->nmsrs = msrs.size();
1115     entry = &kvm_msrs->entries[0];
1116     for (auto it = msrs.cbegin(); it != msrs.cend(); ++it, ++entry) {
1117         entry->index = *it;
1118         entry->reserved = 0;
1119         entry->data = 0;
1120     }
1121 
1122     getMSRs(*kvm_msrs.get());
1123 
1124     // Update M5's state
1125     entry = &kvm_msrs->entries[0];
1126     for (int i = 0; i < kvm_msrs->nmsrs; ++i, ++entry) {
1127         DPRINTF(KvmContext, "Setting M5 MSR: idx: 0x%x, data: 0x%x\n",
1128                 entry->index, entry->data);
1129 
1130         tc->setMiscReg(X86ISA::msrMap.at(entry->index), entry->data);
1131     }
1132 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a3e652bccdd2770630eb4e7bfb0b31b5e}{
\index{X86KvmCPU@{X86KvmCPU}!updateThreadContextRegs@{updateThreadContextRegs}}
\index{updateThreadContextRegs@{updateThreadContextRegs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{updateThreadContextRegs}]{\setlength{\rightskip}{0pt plus 5cm}void updateThreadContextRegs (const struct kvm\_\-regs \& {\em regs}, \/  const struct kvm\_\-sregs \& {\em sregs})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86KvmCPU_a3e652bccdd2770630eb4e7bfb0b31b5e}
Support routines to update the state of gem5's thread context from KVM's state representation. Update integer registers 


\begin{DoxyCode}
973 {
974 #define APPLY_IREG(kreg, mreg) tc->setIntReg(mreg, regs.kreg)
975 
976     FOREACH_IREG();
977 
978 #undef APPLY_IREG
979 
980     tc->pcState(PCState(regs.rip + sregs.cs.base));
981 
982     // Flags are spread out across multiple semi-magic registers so we
983     // need some special care when updating them.
984     X86ISA::setRFlags(tc, regs.rflags);
985 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_aaca63820cd695ae9a2d1bafa76f2ebf6}{
\index{X86KvmCPU@{X86KvmCPU}!updateThreadContextSRegs@{updateThreadContextSRegs}}
\index{updateThreadContextSRegs@{updateThreadContextSRegs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{updateThreadContextSRegs}]{\setlength{\rightskip}{0pt plus 5cm}void updateThreadContextSRegs (const struct kvm\_\-sregs \& {\em sregs})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86KvmCPU_aaca63820cd695ae9a2d1bafa76f2ebf6}
Update control registers (CRx, segments, etc.) 


\begin{DoxyCode}
1026 {
1027     assert(getKvmRunState()->apic_base == sregs.apic_base);
1028     assert(getKvmRunState()->cr8 == sregs.cr8);
1029 
1030 #define APPLY_SREG(kreg, mreg) tc->setMiscRegNoEffect(mreg, sregs.kreg)
1031 #define APPLY_SEGMENT(kreg, idx) setContextSegment(tc, sregs.kreg, idx)
1032 #define APPLY_DTABLE(kreg, idx) setContextSegment(tc, sregs.kreg, idx)
1033     FOREACH_SREG();
1034     FOREACH_SEGMENT();
1035     FOREACH_DTABLE();
1036 #undef APPLY_SREG
1037 #undef APPLY_SEGMENT
1038 #undef APPLY_DTABLE
1039 }
\end{DoxyCode}
\hypertarget{classX86KvmCPU_a64c8d7da4ee94fdaeb4e61d7106c01cf}{
\index{X86KvmCPU@{X86KvmCPU}!updateThreadContextXSave@{updateThreadContextXSave}}
\index{updateThreadContextXSave@{updateThreadContextXSave}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{updateThreadContextXSave}]{\setlength{\rightskip}{0pt plus 5cm}void updateThreadContextXSave (const struct kvm\_\-xsave \& {\em kxsave})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86KvmCPU_a64c8d7da4ee94fdaeb4e61d7106c01cf}
Update FPU and SIMD registers using the XSave API 


\begin{DoxyCode}
1093 {
1094     const FXSave &xsave(*(const FXSave *)kxsave.region);
1095 
1096     updateThreadContextFPUCommon(tc, xsave);
1097 
1098     tc->setMiscRegNoEffect(MISCREG_FISEG, 0);
1099     tc->setMiscRegNoEffect(MISCREG_FIOFF, xsave.ctrl64.fpu_ip);
1100     tc->setMiscRegNoEffect(MISCREG_FOSEG, 0);
1101     tc->setMiscRegNoEffect(MISCREG_FOOFF, xsave.ctrl64.fpu_dp);
1102 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classX86KvmCPU_aa0f07c7b56f9fd1e68e7ebdc2e3a9428}{
\index{X86KvmCPU@{X86KvmCPU}!cachedMsrIntersection@{cachedMsrIntersection}}
\index{cachedMsrIntersection@{cachedMsrIntersection}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{cachedMsrIntersection}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Kvm::MSRIndexVector} {\bf cachedMsrIntersection}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, private\mbox{]}}}}
\label{classX86KvmCPU_aa0f07c7b56f9fd1e68e7ebdc2e3a9428}
Cached intersection of supported MSRs \hypertarget{classX86KvmCPU_ab7c96fcfb73a6d3ca276a6dce2ee76bb}{
\index{X86KvmCPU@{X86KvmCPU}!haveDebugRegs@{haveDebugRegs}}
\index{haveDebugRegs@{haveDebugRegs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{haveDebugRegs}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf haveDebugRegs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86KvmCPU_ab7c96fcfb73a6d3ca276a6dce2ee76bb}
\hyperlink{classKvm_a4e15b92a17300f1d37ceca6e4a984086}{Kvm::capDebugRegs()} available? \hypertarget{classX86KvmCPU_acb9f794b9c9ccc1422b1b5ba9e4823b6}{
\index{X86KvmCPU@{X86KvmCPU}!haveXCRs@{haveXCRs}}
\index{haveXCRs@{haveXCRs}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{haveXCRs}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf haveXCRs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86KvmCPU_acb9f794b9c9ccc1422b1b5ba9e4823b6}
\hyperlink{classKvm_aa9b34836edde016c16df3006fb33b0a9}{Kvm::capXCRs()} available? \hypertarget{classX86KvmCPU_ac0fd3f6d7cf7fa1132de384a5953228c}{
\index{X86KvmCPU@{X86KvmCPU}!haveXSave@{haveXSave}}
\index{haveXSave@{haveXSave}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{haveXSave}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf haveXSave}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86KvmCPU_ac0fd3f6d7cf7fa1132de384a5953228c}
\hyperlink{classKvm_a9c6bbe65d43e3f2708723fc21f00b4cd}{Kvm::capXSave()} available? \hypertarget{classX86KvmCPU_ab9e917350d26247b9eb4153e891f348a}{
\index{X86KvmCPU@{X86KvmCPU}!io\_\-req@{io\_\-req}}
\index{io\_\-req@{io\_\-req}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{io\_\-req}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Request} {\bf io\_\-req}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86KvmCPU_ab9e917350d26247b9eb4153e891f348a}
Reusable IO request \hypertarget{classX86KvmCPU_ab966ae6cc1b380746dcb2713f2559e65}{
\index{X86KvmCPU@{X86KvmCPU}!useXSave@{useXSave}}
\index{useXSave@{useXSave}!X86KvmCPU@{X86KvmCPU}}
\subsubsection[{useXSave}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf useXSave}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86KvmCPU_ab966ae6cc1b380746dcb2713f2559e65}
Should the XSave interface be used to sync the FPU and SIMD registers? 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/kvm/\hyperlink{x86__cpu_8hh}{x86\_\-cpu.hh}\item 
cpu/kvm/\hyperlink{x86__cpu_8cc}{x86\_\-cpu.cc}\end{DoxyCompactItemize}
