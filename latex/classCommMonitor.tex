\hypertarget{classCommMonitor}{
\section{クラス CommMonitor}
\label{classCommMonitor}\index{CommMonitor@{CommMonitor}}
}


{\ttfamily \#include $<$comm\_\-monitor.hh$>$}CommMonitorに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=5cm]{classCommMonitor}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classCommMonitor_1_1CommMonitor}{CommMonitor}
\item 
class \hyperlink{classCommMonitor_1_1CommMonitorSenderState}{CommMonitorSenderState}
\item 
class \hyperlink{classCommMonitor_1_1MonitorMasterPort}{MonitorMasterPort}
\item 
class \hyperlink{classCommMonitor_1_1MonitorSlavePort}{MonitorSlavePort}
\item 
struct \hyperlink{structCommMonitor_1_1MonitorStats}{MonitorStats}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef CommMonitorParams \hyperlink{classCommMonitor_a945848d2cb95179e45fffc6a7f41da84}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
const \hyperlink{classCommMonitor_a945848d2cb95179e45fffc6a7f41da84}{Params} $\ast$ \hyperlink{classCommMonitor_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{classCommMonitor_af8e768be1328f879d2240d44e6f430e1}{CommMonitor} (\hyperlink{classCommMonitor_a945848d2cb95179e45fffc6a7f41da84}{Params} $\ast$params)
\item 
\hyperlink{classCommMonitor_a47022a49dc532464956ee511797d53e9}{$\sim$CommMonitor} ()
\item 
void \hyperlink{classCommMonitor_a1a9faf3ec2cf5587b9f182041981b72c}{closeStreams} ()
\item 
virtual \hyperlink{classBaseMasterPort}{BaseMasterPort} \& \hyperlink{classCommMonitor_adc4e675e51defbdd1e354dac729d0703}{getMasterPort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
virtual \hyperlink{classBaseSlavePort}{BaseSlavePort} \& \hyperlink{classCommMonitor_ac918a145092d7514ebc6dbd952dceafb}{getSlavePort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
virtual void \hyperlink{classCommMonitor_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
void \hyperlink{classCommMonitor_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classCommMonitor_aeefa907fb6d6a787e6dab90e8138ea90}{recvFunctional} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classCommMonitor_a284dfb90c168233c9d416bc07de8fefe}{recvFunctionalSnoop} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classCommMonitor_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{recvAtomic} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classCommMonitor_a886d584c81ee4e398ff8069907f6e1a5}{recvAtomicSnoop} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classCommMonitor_a3344d9dd0f83257feab5424e761f31c6}{recvTimingReq} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classCommMonitor_a482dba5588f4bee43e498875a61e5e0b}{recvTimingResp} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classCommMonitor_aff3031c56fc4947a19695c868bb8233e}{recvTimingSnoopReq} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classCommMonitor_a9b643d565edc21dac11ce15a560238a7}{recvTimingSnoopResp} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classCommMonitor_a36cf113d5e5e091ebddb32306c098fae}{getAddrRanges} () const 
\item 
bool \hyperlink{classCommMonitor_a5ce11b7a254d3cb756d94568f7cbc25d}{isSnooping} () const 
\item 
void \hyperlink{classCommMonitor_a74fc0d5bf99b08c9899269e3dd7fab6a}{recvRetryMaster} ()
\item 
void \hyperlink{classCommMonitor_a2292f62803fe220e9629886f24aae91a}{recvRetrySlave} ()
\item 
void \hyperlink{classCommMonitor_aecf310a01b533ae8700eccac2cf20480}{recvRangeChange} ()
\item 
void \hyperlink{classCommMonitor_a31e31032fcf23dfbf54cf733a71c87a3}{periodicTraceDump} ()
\item 
void \hyperlink{classCommMonitor_a8d8196ff6539b2e3b6deb4ae81156fc6}{samplePeriodic} ()
\item 
void \hyperlink{classCommMonitor_aecc7d8debf54990ffeaaed5bac7d7d81}{startup} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classCommMonitor_1_1MonitorMasterPort}{MonitorMasterPort} \hyperlink{classCommMonitor_a2eb439e94fc831a4b07a2e5d4268a365}{masterPort}
\item 
\hyperlink{classCommMonitor_1_1MonitorSlavePort}{MonitorSlavePort} \hyperlink{classCommMonitor_a3a2b0c2e0b88fa0a90bf89c0d7e6809e}{slavePort}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classCommMonitor_1_1CommMonitor}{CommMonitor},\&CommMonitor::samplePeriodic $>$ \hyperlink{classCommMonitor_a59f6dafc1b1b5cf7eda2e4a47a47c515}{samplePeriodicEvent}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classCommMonitor_a087522d1bccfcac06ee7396d5da731e9}{samplePeriodTicks}
\item 
\hyperlink{classTime}{Time} \hyperlink{classCommMonitor_a2b79d72692e74b1c084ea31e63c5cf55}{samplePeriod}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classCommMonitor_abf0db97222382e11cb1264c6709629b3}{readAddrMask}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classCommMonitor_aed61db18cf47a6b2d34ba6179dd19b40}{writeAddrMask}
\item 
\hyperlink{structCommMonitor_1_1MonitorStats}{MonitorStats} \hyperlink{classCommMonitor_a271fb3be9460a6727cb088bba7fde65e}{stats}
\item 
\hyperlink{classProtoOutputStream}{ProtoOutputStream} $\ast$ \hyperlink{classCommMonitor_afcb6a80c2432e45a3730484625ee1d20}{traceStream}
\item 
\hyperlink{classSystem}{System} $\ast$ \hyperlink{classCommMonitor_af27ccd765f13a4b7bd119dc7579e2746}{system}
\end{DoxyCompactItemize}


\subsection{説明}
The communication monitor is a \hyperlink{classMemObject}{MemObject} which can monitor statistics of the communication happening between two ports in the memory system.

Currently the following stats are implemented: Histograms of read/write transactions, read/write burst lengths, read/write bandwidth, outstanding read/write requests, read latency and inter transaction time (read-\/read, write-\/write, read/write-\/read/write). Furthermore it allows to capture the number of accesses to an address over time (\char`\"{}heat map\char`\"{}). All stats can be disabled from Python. 

\subsection{型定義}
\hypertarget{classCommMonitor_a945848d2cb95179e45fffc6a7f41da84}{
\index{CommMonitor@{CommMonitor}!Params@{Params}}
\index{Params@{Params}!CommMonitor@{CommMonitor}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef CommMonitorParams {\bf Params}}}
\label{classCommMonitor_a945848d2cb95179e45fffc6a7f41da84}
Parameters of communication monitor 

\hyperlink{classMemObject_a905bbc621eeec0ed08859e21c8c95412}{MemObject}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classCommMonitor_af8e768be1328f879d2240d44e6f430e1}{
\index{CommMonitor@{CommMonitor}!CommMonitor@{CommMonitor}}
\index{CommMonitor@{CommMonitor}!CommMonitor@{CommMonitor}}
\subsubsection[{CommMonitor}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CommMonitor} ({\bf Params} $\ast$ {\em params})}}
\label{classCommMonitor_af8e768be1328f879d2240d44e6f430e1}
Constructor based on the Python params


\begin{DoxyParams}{引数}
\item[{\em params}]Python parameters \end{DoxyParams}



\begin{DoxyCode}
50     : MemObject(params),
51       masterPort(name() + "-master", *this),
52       slavePort(name() + "-slave", *this),
53       samplePeriodicEvent(this),
54       samplePeriodTicks(params->sample_period),
55       readAddrMask(params->read_addr_mask),
56       writeAddrMask(params->write_addr_mask),
57       stats(params),
58       traceStream(NULL),
59       system(params->system)
60 {
61     // If we are using a trace file, then open the file
62     if (params->trace_enable) {
63         std::string filename;
64         if (params->trace_file != "") {
65             // If the trace file is not specified as an absolute path,
66             // append the current simulation output directory
67             filename = simout.resolve(params->trace_file);
68 
69             std::string suffix = ".gz";
70             // If trace_compress has been set, check the suffix. Append
71             // accordingly.
72             if (params->trace_compress &&
73                 filename.compare(filename.size() - suffix.size(), suffix.size(),
74                                  suffix) != 0)
75                     filename = filename + suffix;
76         } else {
77             // Generate a filename from the name of the SimObject. Append .trc
78             // and .gz if we want compression enabled.
79             filename = simout.resolve(name() + ".trc" +
80                                       (params->trace_compress ? ".gz" : ""));
81         }
82 
83         traceStream = new ProtoOutputStream(filename);
84 
85         // Create a protobuf message for the header and write it to
86         // the stream
87         Message::PacketHeader header_msg;
88         header_msg.set_obj_id(name());
89         header_msg.set_tick_freq(SimClock::Frequency);
90         traceStream->write(header_msg);
91 
92         // Register a callback to compensate for the destructor not
93         // being called. The callback forces the stream to flush and
94         // closes the output file.
95         Callback* cb = new MakeCallback<CommMonitor,
96             &CommMonitor::closeStreams>(this);
97         registerExitCallback(cb);
98     }
99 
100     // keep track of the sample period both in ticks and absolute time
101     samplePeriod.setTick(params->sample_period);
102 
103     DPRINTF(CommMonitor,
104             "Created monitor %s with sample period %d ticks (%f ms)\n",
105             name(), samplePeriodTicks, samplePeriod.msec());
106 }
\end{DoxyCode}
\hypertarget{classCommMonitor_a47022a49dc532464956ee511797d53e9}{
\index{CommMonitor@{CommMonitor}!$\sim$CommMonitor@{$\sim$CommMonitor}}
\index{$\sim$CommMonitor@{$\sim$CommMonitor}!CommMonitor@{CommMonitor}}
\subsubsection[{$\sim$CommMonitor}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf CommMonitor} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCommMonitor_a47022a49dc532464956ee511797d53e9}
Destructor 


\begin{DoxyCode}
80 {}
\end{DoxyCode}


\subsection{関数}
\hypertarget{classCommMonitor_a1a9faf3ec2cf5587b9f182041981b72c}{
\index{CommMonitor@{CommMonitor}!closeStreams@{closeStreams}}
\index{closeStreams@{closeStreams}!CommMonitor@{CommMonitor}}
\subsubsection[{closeStreams}]{\setlength{\rightskip}{0pt plus 5cm}void closeStreams ()}}
\label{classCommMonitor_a1a9faf3ec2cf5587b9f182041981b72c}
\hyperlink{classCallback}{Callback} to flush and close all open output streams on exit. If we were calling the destructor it could be done there. 


\begin{DoxyCode}
110 {
111     if (traceStream != NULL)
112         delete traceStream;
113 }
\end{DoxyCode}
\hypertarget{classCommMonitor_a36cf113d5e5e091ebddb32306c098fae}{
\index{CommMonitor@{CommMonitor}!getAddrRanges@{getAddrRanges}}
\index{getAddrRanges@{getAddrRanges}!CommMonitor@{CommMonitor}}
\subsubsection[{getAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRangeList} getAddrRanges () const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_a36cf113d5e5e091ebddb32306c098fae}



\begin{DoxyCode}
408 {
409     // get the address ranges of the connected slave port
410     return masterPort.getAddrRanges();
411 }
\end{DoxyCode}
\hypertarget{classCommMonitor_adc4e675e51defbdd1e354dac729d0703}{
\index{CommMonitor@{CommMonitor}!getMasterPort@{getMasterPort}}
\index{getMasterPort@{getMasterPort}!CommMonitor@{CommMonitor}}
\subsubsection[{getMasterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseMasterPort} \& getMasterPort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCommMonitor_adc4e675e51defbdd1e354dac729d0703}
Get a master port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classMemObject_adc4e675e51defbdd1e354dac729d0703}{MemObject}を再定義しています。


\begin{DoxyCode}
138 {
139     if (if_name == "master") {
140         return masterPort;
141     } else {
142         return MemObject::getMasterPort(if_name, idx);
143     }
144 }
\end{DoxyCode}
\hypertarget{classCommMonitor_ac918a145092d7514ebc6dbd952dceafb}{
\index{CommMonitor@{CommMonitor}!getSlavePort@{getSlavePort}}
\index{getSlavePort@{getSlavePort}!CommMonitor@{CommMonitor}}
\subsubsection[{getSlavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseSlavePort} \& getSlavePort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCommMonitor_ac918a145092d7514ebc6dbd952dceafb}
Get a slave port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classMemObject_ac918a145092d7514ebc6dbd952dceafb}{MemObject}を再定義しています。


\begin{DoxyCode}
148 {
149     if (if_name == "slave") {
150         return slavePort;
151     } else {
152         return MemObject::getSlavePort(if_name, idx);
153     }
154 }
\end{DoxyCode}
\hypertarget{classCommMonitor_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{CommMonitor@{CommMonitor}!init@{init}}
\index{init@{init}!CommMonitor@{CommMonitor}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCommMonitor_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classCommMonitor_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{SimObject}を再定義しています。


\begin{DoxyCode}
123 {
124     // make sure both sides of the monitor are connected
125     if (!slavePort.isConnected() || !masterPort.isConnected())
126         fatal("Communication monitor is not connected on both sides.\n");
127 
128     if (traceStream != NULL) {
129         // Check the memory mode. We only record something when in
130         // timing mode. Warn accordingly.
131         if (!system->isTimingMode())
132             warn("%s: Not in timing mode. No trace will be recorded.", name());
133     }
134 }
\end{DoxyCode}
\hypertarget{classCommMonitor_a5ce11b7a254d3cb756d94568f7cbc25d}{
\index{CommMonitor@{CommMonitor}!isSnooping@{isSnooping}}
\index{isSnooping@{isSnooping}!CommMonitor@{CommMonitor}}
\subsubsection[{isSnooping}]{\setlength{\rightskip}{0pt plus 5cm}bool isSnooping () const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_a5ce11b7a254d3cb756d94568f7cbc25d}



\begin{DoxyCode}
401 {
402     // check if the connected master port is snooping
403     return slavePort.isSnooping();
404 }
\end{DoxyCode}
\hypertarget{classCommMonitor_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{CommMonitor@{CommMonitor}!params@{params}}
\index{params@{params}!CommMonitor@{CommMonitor}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCommMonitor_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classMemObject_acd3c3feb78ae7a8f88fe0f110a718dff}{MemObject}を再定義しています。


\begin{DoxyCode}
70     { return reinterpret_cast<const Params*>(_params); }
\end{DoxyCode}
\hypertarget{classCommMonitor_a31e31032fcf23dfbf54cf733a71c87a3}{
\index{CommMonitor@{CommMonitor}!periodicTraceDump@{periodicTraceDump}}
\index{periodicTraceDump@{periodicTraceDump}!CommMonitor@{CommMonitor}}
\subsubsection[{periodicTraceDump}]{\setlength{\rightskip}{0pt plus 5cm}void periodicTraceDump ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_a31e31032fcf23dfbf54cf733a71c87a3}
\hypertarget{classCommMonitor_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{
\index{CommMonitor@{CommMonitor}!recvAtomic@{recvAtomic}}
\index{recvAtomic@{recvAtomic}!CommMonitor@{CommMonitor}}
\subsubsection[{recvAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvAtomic ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}



\begin{DoxyCode}
170 {
171     return masterPort.sendAtomic(pkt);
172 }
\end{DoxyCode}
\hypertarget{classCommMonitor_a886d584c81ee4e398ff8069907f6e1a5}{
\index{CommMonitor@{CommMonitor}!recvAtomicSnoop@{recvAtomicSnoop}}
\index{recvAtomicSnoop@{recvAtomicSnoop}!CommMonitor@{CommMonitor}}
\subsubsection[{recvAtomicSnoop}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvAtomicSnoop ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_a886d584c81ee4e398ff8069907f6e1a5}



\begin{DoxyCode}
176 {
177     return slavePort.sendAtomicSnoop(pkt);
178 }
\end{DoxyCode}
\hypertarget{classCommMonitor_aeefa907fb6d6a787e6dab90e8138ea90}{
\index{CommMonitor@{CommMonitor}!recvFunctional@{recvFunctional}}
\index{recvFunctional@{recvFunctional}!CommMonitor@{CommMonitor}}
\subsubsection[{recvFunctional}]{\setlength{\rightskip}{0pt plus 5cm}void recvFunctional ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_aeefa907fb6d6a787e6dab90e8138ea90}



\begin{DoxyCode}
158 {
159     masterPort.sendFunctional(pkt);
160 }
\end{DoxyCode}
\hypertarget{classCommMonitor_a284dfb90c168233c9d416bc07de8fefe}{
\index{CommMonitor@{CommMonitor}!recvFunctionalSnoop@{recvFunctionalSnoop}}
\index{recvFunctionalSnoop@{recvFunctionalSnoop}!CommMonitor@{CommMonitor}}
\subsubsection[{recvFunctionalSnoop}]{\setlength{\rightskip}{0pt plus 5cm}void recvFunctionalSnoop ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_a284dfb90c168233c9d416bc07de8fefe}



\begin{DoxyCode}
164 {
165     slavePort.sendFunctionalSnoop(pkt);
166 }
\end{DoxyCode}
\hypertarget{classCommMonitor_aecf310a01b533ae8700eccac2cf20480}{
\index{CommMonitor@{CommMonitor}!recvRangeChange@{recvRangeChange}}
\index{recvRangeChange@{recvRangeChange}!CommMonitor@{CommMonitor}}
\subsubsection[{recvRangeChange}]{\setlength{\rightskip}{0pt plus 5cm}void recvRangeChange ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_aecf310a01b533ae8700eccac2cf20480}



\begin{DoxyCode}
427 {
428     slavePort.sendRangeChange();
429 }
\end{DoxyCode}
\hypertarget{classCommMonitor_a74fc0d5bf99b08c9899269e3dd7fab6a}{
\index{CommMonitor@{CommMonitor}!recvRetryMaster@{recvRetryMaster}}
\index{recvRetryMaster@{recvRetryMaster}!CommMonitor@{CommMonitor}}
\subsubsection[{recvRetryMaster}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetryMaster ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_a74fc0d5bf99b08c9899269e3dd7fab6a}



\begin{DoxyCode}
415 {
416     slavePort.sendRetry();
417 }
\end{DoxyCode}
\hypertarget{classCommMonitor_a2292f62803fe220e9629886f24aae91a}{
\index{CommMonitor@{CommMonitor}!recvRetrySlave@{recvRetrySlave}}
\index{recvRetrySlave@{recvRetrySlave}!CommMonitor@{CommMonitor}}
\subsubsection[{recvRetrySlave}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetrySlave ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_a2292f62803fe220e9629886f24aae91a}



\begin{DoxyCode}
421 {
422     masterPort.sendRetry();
423 }
\end{DoxyCode}
\hypertarget{classCommMonitor_a3344d9dd0f83257feab5424e761f31c6}{
\index{CommMonitor@{CommMonitor}!recvTimingReq@{recvTimingReq}}
\index{recvTimingReq@{recvTimingReq}!CommMonitor@{CommMonitor}}
\subsubsection[{recvTimingReq}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingReq ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_a3344d9dd0f83257feab5424e761f31c6}



\begin{DoxyCode}
182 {
183     // should always see a request
184     assert(pkt->isRequest());
185 
186     // Store relevant fields of packet, because packet may be modified
187     // or even deleted when sendTiming() is called.
188     bool is_read = pkt->isRead();
189     bool is_write = pkt->isWrite();
190     int cmd = pkt->cmdToIndex();
191     Request::FlagsType req_flags = pkt->req->getFlags();
192     unsigned size = pkt->getSize();
193     Addr addr = pkt->getAddr();
194     bool expects_response = pkt->needsResponse() && !pkt->memInhibitAsserted();
195 
196     // If a cache miss is served by a cache, a monitor near the memory
197     // would see a request which needs a response, but this response
198     // would be inhibited and not come back from the memory. Therefore
199     // we additionally have to check the inhibit flag.
200     if (expects_response && !stats.disableLatencyHists) {
201         pkt->pushSenderState(new CommMonitorSenderState(curTick()));
202     }
203 
204     // Attempt to send the packet (always succeeds for inhibited
205     // packets)
206     bool successful = masterPort.sendTimingReq(pkt);
207 
208     // If not successful, restore the sender state
209     if (!successful && expects_response && !stats.disableLatencyHists) {
210         delete pkt->popSenderState();
211     }
212 
213     if (successful && traceStream != NULL) {
214         // Create a protobuf message representing the
215         // packet. Currently we do not preserve the flags in the
216         // trace.
217         Message::Packet pkt_msg;
218         pkt_msg.set_tick(curTick());
219         pkt_msg.set_cmd(cmd);
220         pkt_msg.set_flags(req_flags);
221         pkt_msg.set_addr(addr);
222         pkt_msg.set_size(size);
223 
224         traceStream->write(pkt_msg);
225     }
226 
227     if (successful && is_read) {
228         DPRINTF(CommMonitor, "Forwarded read request\n");
229 
230         // Increment number of observed read transactions
231         if (!stats.disableTransactionHists) {
232             ++stats.readTrans;
233         }
234 
235         // Get sample of burst length
236         if (!stats.disableBurstLengthHists) {
237             stats.readBurstLengthHist.sample(size);
238         }
239 
240         // Sample the masked address
241         if (!stats.disableAddrDists) {
242             stats.readAddrDist.sample(addr & readAddrMask);
243         }
244 
245         // If it needs a response increment number of outstanding read
246         // requests
247         if (!stats.disableOutstandingHists && expects_response) {
248             ++stats.outstandingReadReqs;
249         }
250 
251         if (!stats.disableITTDists) {
252             // Sample value of read-read inter transaction time
253             if (stats.timeOfLastRead != 0) {
254                 stats.ittReadRead.sample(curTick() - stats.timeOfLastRead);
255             }
256             stats.timeOfLastRead = curTick();
257 
258             // Sample value of req-req inter transaction time
259             if (stats.timeOfLastReq != 0) {
260                 stats.ittReqReq.sample(curTick() - stats.timeOfLastReq);
261             }
262             stats.timeOfLastReq = curTick();
263         }
264     } else if (successful && is_write) {
265         DPRINTF(CommMonitor, "Forwarded write request\n");
266 
267         // Same as for reads
268         if (!stats.disableTransactionHists) {
269             ++stats.writeTrans;
270         }
271 
272         if (!stats.disableBurstLengthHists) {
273             stats.writeBurstLengthHist.sample(size);
274         }
275 
276         // Update the bandwidth stats on the request
277         if (!stats.disableBandwidthHists) {
278             stats.writtenBytes += size;
279             stats.totalWrittenBytes += size;
280         }
281 
282         // Sample the masked write address
283         if (!stats.disableAddrDists) {
284             stats.writeAddrDist.sample(addr & writeAddrMask);
285         }
286 
287         if (!stats.disableOutstandingHists && expects_response) {
288             ++stats.outstandingWriteReqs;
289         }
290 
291         if (!stats.disableITTDists) {
292             // Sample value of write-to-write inter transaction time
293             if (stats.timeOfLastWrite != 0) {
294                 stats.ittWriteWrite.sample(curTick() - stats.timeOfLastWrite);
295             }
296             stats.timeOfLastWrite = curTick();
297 
298             // Sample value of req-to-req inter transaction time
299             if (stats.timeOfLastReq != 0) {
300                 stats.ittReqReq.sample(curTick() - stats.timeOfLastReq);
301             }
302             stats.timeOfLastReq = curTick();
303         }
304     } else if (successful) {
305         DPRINTF(CommMonitor, "Forwarded non read/write request\n");
306     }
307 
308     return successful;
309 }
\end{DoxyCode}
\hypertarget{classCommMonitor_a482dba5588f4bee43e498875a61e5e0b}{
\index{CommMonitor@{CommMonitor}!recvTimingResp@{recvTimingResp}}
\index{recvTimingResp@{recvTimingResp}!CommMonitor@{CommMonitor}}
\subsubsection[{recvTimingResp}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingResp ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_a482dba5588f4bee43e498875a61e5e0b}



\begin{DoxyCode}
313 {
314     // should always see responses
315     assert(pkt->isResponse());
316 
317     // Store relevant fields of packet, because packet may be modified
318     // or even deleted when sendTiming() is called.
319     bool is_read = pkt->isRead();
320     bool is_write = pkt->isWrite();
321     unsigned size = pkt->getSize();
322     Tick latency = 0;
323     CommMonitorSenderState* received_state =
324         dynamic_cast<CommMonitorSenderState*>(pkt->senderState);
325 
326     if (!stats.disableLatencyHists) {
327         // Restore initial sender state
328         if (received_state == NULL)
329             panic("Monitor got a response without monitor sender state\n");
330 
331         // Restore the sate
332         pkt->senderState = received_state->predecessor;
333     }
334 
335     // Attempt to send the packet
336     bool successful = slavePort.sendTimingResp(pkt);
337 
338     if (!stats.disableLatencyHists) {
339         // If packet successfully send, sample value of latency,
340         // afterwards delete sender state, otherwise restore state
341         if (successful) {
342             latency = curTick() - received_state->transmitTime;
343             DPRINTF(CommMonitor, "Latency: %d\n", latency);
344             delete received_state;
345         } else {
346             // Don't delete anything and let the packet look like we
347             // did not touch it
348             pkt->senderState = received_state;
349         }
350     }
351 
352     if (successful && is_read) {
353         // Decrement number of outstanding read requests
354         DPRINTF(CommMonitor, "Received read response\n");
355         if (!stats.disableOutstandingHists) {
356             assert(stats.outstandingReadReqs != 0);
357             --stats.outstandingReadReqs;
358         }
359 
360         if (!stats.disableLatencyHists) {
361             stats.readLatencyHist.sample(latency);
362         }
363 
364         // Update the bandwidth stats based on responses for reads
365         if (!stats.disableBandwidthHists) {
366             stats.readBytes += size;
367             stats.totalReadBytes += size;
368         }
369 
370     } else if (successful && is_write) {
371         // Decrement number of outstanding write requests
372         DPRINTF(CommMonitor, "Received write response\n");
373         if (!stats.disableOutstandingHists) {
374             assert(stats.outstandingWriteReqs != 0);
375             --stats.outstandingWriteReqs;
376         }
377 
378         if (!stats.disableLatencyHists) {
379             stats.writeLatencyHist.sample(latency);
380         }
381     } else if (successful) {
382         DPRINTF(CommMonitor, "Received non read/write response\n");
383     }
384     return successful;
385 }
\end{DoxyCode}
\hypertarget{classCommMonitor_aff3031c56fc4947a19695c868bb8233e}{
\index{CommMonitor@{CommMonitor}!recvTimingSnoopReq@{recvTimingSnoopReq}}
\index{recvTimingSnoopReq@{recvTimingSnoopReq}!CommMonitor@{CommMonitor}}
\subsubsection[{recvTimingSnoopReq}]{\setlength{\rightskip}{0pt plus 5cm}void recvTimingSnoopReq ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_aff3031c56fc4947a19695c868bb8233e}



\begin{DoxyCode}
389 {
390     slavePort.sendTimingSnoopReq(pkt);
391 }
\end{DoxyCode}
\hypertarget{classCommMonitor_a9b643d565edc21dac11ce15a560238a7}{
\index{CommMonitor@{CommMonitor}!recvTimingSnoopResp@{recvTimingSnoopResp}}
\index{recvTimingSnoopResp@{recvTimingSnoopResp}!CommMonitor@{CommMonitor}}
\subsubsection[{recvTimingSnoopResp}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingSnoopResp ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_a9b643d565edc21dac11ce15a560238a7}



\begin{DoxyCode}
395 {
396     return masterPort.sendTimingSnoopResp(pkt);
397 }
\end{DoxyCode}
\hypertarget{classCommMonitor_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{CommMonitor@{CommMonitor}!regStats@{regStats}}
\index{regStats@{regStats}!CommMonitor@{CommMonitor}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCommMonitor_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} statistics 

\hyperlink{classSimObject_a4dc637449366fcdfc4e764cdf12d9b11}{SimObject}を再定義しています。


\begin{DoxyCode}
433 {
434     // Initialise all the monitor stats
435     using namespace Stats;
436 
437     stats.readBurstLengthHist
438         .init(params()->burst_length_bins)
439         .name(name() + ".readBurstLengthHist")
440         .desc("Histogram of burst lengths of transmitted packets")
441         .flags(stats.disableBurstLengthHists ? nozero : pdf);
442 
443     stats.writeBurstLengthHist
444         .init(params()->burst_length_bins)
445         .name(name() + ".writeBurstLengthHist")
446         .desc("Histogram of burst lengths of transmitted packets")
447         .flags(stats.disableBurstLengthHists ? nozero : pdf);
448 
449     // Stats based on received responses
450     stats.readBandwidthHist
451         .init(params()->bandwidth_bins)
452         .name(name() + ".readBandwidthHist")
453         .desc("Histogram of read bandwidth per sample period (bytes/s)")
454         .flags(stats.disableBandwidthHists ? nozero : pdf);
455 
456     stats.averageReadBW
457         .name(name() + ".averageReadBandwidth")
458         .desc("Average read bandwidth (bytes/s)")
459         .flags(stats.disableBandwidthHists ? nozero : pdf);
460 
461     stats.totalReadBytes
462         .name(name() + ".totalReadBytes")
463         .desc("Number of bytes read")
464         .flags(stats.disableBandwidthHists ? nozero : pdf);
465 
466     stats.averageReadBW = stats.totalReadBytes / simSeconds;
467 
468     // Stats based on successfully sent requests
469     stats.writeBandwidthHist
470         .init(params()->bandwidth_bins)
471         .name(name() + ".writeBandwidthHist")
472         .desc("Histogram of write bandwidth (bytes/s)")
473         .flags(stats.disableBandwidthHists ? (pdf | nozero) : pdf);
474 
475     stats.averageWriteBW
476         .name(name() + ".averageWriteBandwidth")
477         .desc("Average write bandwidth (bytes/s)")
478         .flags(stats.disableBandwidthHists ? nozero : pdf);
479 
480     stats.totalWrittenBytes
481         .name(name() + ".totalWrittenBytes")
482         .desc("Number of bytes written")
483         .flags(stats.disableBandwidthHists ? nozero : pdf);
484 
485     stats.averageWriteBW = stats.totalWrittenBytes / simSeconds;
486 
487     stats.readLatencyHist
488         .init(params()->latency_bins)
489         .name(name() + ".readLatencyHist")
490         .desc("Read request-response latency")
491         .flags(stats.disableLatencyHists ? nozero : pdf);
492 
493     stats.writeLatencyHist
494         .init(params()->latency_bins)
495         .name(name() + ".writeLatencyHist")
496         .desc("Write request-response latency")
497         .flags(stats.disableLatencyHists ? nozero : pdf);
498 
499     stats.ittReadRead
500         .init(1, params()->itt_max_bin, params()->itt_max_bin /
501               params()->itt_bins)
502         .name(name() + ".ittReadRead")
503         .desc("Read-to-read inter transaction time")
504         .flags(stats.disableITTDists ? nozero : pdf);
505 
506     stats.ittWriteWrite
507         .init(1, params()->itt_max_bin, params()->itt_max_bin /
508               params()->itt_bins)
509         .name(name() + ".ittWriteWrite")
510         .desc("Write-to-write inter transaction time")
511         .flags(stats.disableITTDists ? nozero : pdf);
512 
513     stats.ittReqReq
514         .init(1, params()->itt_max_bin, params()->itt_max_bin /
515               params()->itt_bins)
516         .name(name() + ".ittReqReq")
517         .desc("Request-to-request inter transaction time")
518         .flags(stats.disableITTDists ? nozero : pdf);
519 
520     stats.outstandingReadsHist
521         .init(params()->outstanding_bins)
522         .name(name() + ".outstandingReadsHist")
523         .desc("Outstanding read transactions")
524         .flags(stats.disableOutstandingHists ? nozero : pdf);
525 
526     stats.outstandingWritesHist
527         .init(params()->outstanding_bins)
528         .name(name() + ".outstandingWritesHist")
529         .desc("Outstanding write transactions")
530         .flags(stats.disableOutstandingHists ? nozero : pdf);
531 
532     stats.readTransHist
533         .init(params()->transaction_bins)
534         .name(name() + ".readTransHist")
535         .desc("Histogram of read transactions per sample period")
536         .flags(stats.disableTransactionHists ? nozero : pdf);
537 
538     stats.writeTransHist
539         .init(params()->transaction_bins)
540         .name(name() + ".writeTransHist")
541         .desc("Histogram of read transactions per sample period")
542         .flags(stats.disableTransactionHists ? nozero : pdf);
543 
544     stats.readAddrDist
545         .init(0)
546         .name(name() + ".readAddrDist")
547         .desc("Read address distribution")
548         .flags(stats.disableAddrDists ? nozero : pdf);
549 
550     stats.writeAddrDist
551         .init(0)
552         .name(name() + ".writeAddrDist")
553         .desc("Write address distribution")
554         .flags(stats.disableAddrDists ? nozero : pdf);
555 }
\end{DoxyCode}
\hypertarget{classCommMonitor_a8d8196ff6539b2e3b6deb4ae81156fc6}{
\index{CommMonitor@{CommMonitor}!samplePeriodic@{samplePeriodic}}
\index{samplePeriodic@{samplePeriodic}!CommMonitor@{CommMonitor}}
\subsubsection[{samplePeriodic}]{\setlength{\rightskip}{0pt plus 5cm}void samplePeriodic ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_a8d8196ff6539b2e3b6deb4ae81156fc6}
This function is called periodically at the end of each time bin 


\begin{DoxyCode}
559 {
560     // the periodic stats update runs on the granularity of sample
561     // periods, but in combination with this there may also be a
562     // external resets and dumps of the stats (through schedStatEvent)
563     // causing the stats themselves to capture less than a sample
564     // period
565 
566     // only capture if we have not reset the stats during the last
567     // sample period
568     if (simTicks.value() >= samplePeriodTicks) {
569         if (!stats.disableTransactionHists) {
570             stats.readTransHist.sample(stats.readTrans);
571             stats.writeTransHist.sample(stats.writeTrans);
572         }
573 
574         if (!stats.disableBandwidthHists) {
575             stats.readBandwidthHist.sample(stats.readBytes / samplePeriod);
576             stats.writeBandwidthHist.sample(stats.writtenBytes / samplePeriod);
577         }
578 
579         if (!stats.disableOutstandingHists) {
580             stats.outstandingReadsHist.sample(stats.outstandingReadReqs);
581             stats.outstandingWritesHist.sample(stats.outstandingWriteReqs);
582         }
583     }
584 
585     // reset the sampled values
586     stats.readTrans = 0;
587     stats.writeTrans = 0;
588 
589     stats.readBytes = 0;
590     stats.writtenBytes = 0;
591 
592     schedule(samplePeriodicEvent, curTick() + samplePeriodTicks);
593 }
\end{DoxyCode}
\hypertarget{classCommMonitor_aecc7d8debf54990ffeaaed5bac7d7d81}{
\index{CommMonitor@{CommMonitor}!startup@{startup}}
\index{startup@{startup}!CommMonitor@{CommMonitor}}
\subsubsection[{startup}]{\setlength{\rightskip}{0pt plus 5cm}void startup ()\hspace{0.3cm}{\ttfamily  \mbox{[}private, virtual\mbox{]}}}}
\label{classCommMonitor_aecc7d8debf54990ffeaaed5bac7d7d81}
Schedule the first periodic event 

\hyperlink{classSimObject_aecc7d8debf54990ffeaaed5bac7d7d81}{SimObject}を再定義しています。


\begin{DoxyCode}
597 {
598     schedule(samplePeriodicEvent, curTick() + samplePeriodTicks);
599 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classCommMonitor_a2eb439e94fc831a4b07a2e5d4268a365}{
\index{CommMonitor@{CommMonitor}!masterPort@{masterPort}}
\index{masterPort@{masterPort}!CommMonitor@{CommMonitor}}
\subsubsection[{masterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MonitorMasterPort} {\bf masterPort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_a2eb439e94fc831a4b07a2e5d4268a365}
Instance of master port, facing the memory side \hypertarget{classCommMonitor_abf0db97222382e11cb1264c6709629b3}{
\index{CommMonitor@{CommMonitor}!readAddrMask@{readAddrMask}}
\index{readAddrMask@{readAddrMask}!CommMonitor@{CommMonitor}}
\subsubsection[{readAddrMask}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf readAddrMask}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_abf0db97222382e11cb1264c6709629b3}
\hyperlink{classAddress}{Address} mask for sources of read accesses to be captured \hypertarget{classCommMonitor_a2b79d72692e74b1c084ea31e63c5cf55}{
\index{CommMonitor@{CommMonitor}!samplePeriod@{samplePeriod}}
\index{samplePeriod@{samplePeriod}!CommMonitor@{CommMonitor}}
\subsubsection[{samplePeriod}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time} {\bf samplePeriod}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_a2b79d72692e74b1c084ea31e63c5cf55}
\hypertarget{classCommMonitor_a59f6dafc1b1b5cf7eda2e4a47a47c515}{
\index{CommMonitor@{CommMonitor}!samplePeriodicEvent@{samplePeriodicEvent}}
\index{samplePeriodicEvent@{samplePeriodicEvent}!CommMonitor@{CommMonitor}}
\subsubsection[{samplePeriodicEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf CommMonitor}, \&CommMonitor::samplePeriodic$>$ {\bf samplePeriodicEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_a59f6dafc1b1b5cf7eda2e4a47a47c515}
Periodic event called at the end of each simulation time bin \hypertarget{classCommMonitor_a087522d1bccfcac06ee7396d5da731e9}{
\index{CommMonitor@{CommMonitor}!samplePeriodTicks@{samplePeriodTicks}}
\index{samplePeriodTicks@{samplePeriodTicks}!CommMonitor@{CommMonitor}}
\subsubsection[{samplePeriodTicks}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf samplePeriodTicks}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_a087522d1bccfcac06ee7396d5da731e9}
Length of simulation time bin \hypertarget{classCommMonitor_a3a2b0c2e0b88fa0a90bf89c0d7e6809e}{
\index{CommMonitor@{CommMonitor}!slavePort@{slavePort}}
\index{slavePort@{slavePort}!CommMonitor@{CommMonitor}}
\subsubsection[{slavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MonitorSlavePort} {\bf slavePort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_a3a2b0c2e0b88fa0a90bf89c0d7e6809e}
Instance of slave port, i.e. on the CPU side \hypertarget{classCommMonitor_a271fb3be9460a6727cb088bba7fde65e}{
\index{CommMonitor@{CommMonitor}!stats@{stats}}
\index{stats@{stats}!CommMonitor@{CommMonitor}}
\subsubsection[{stats}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MonitorStats} {\bf stats}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_a271fb3be9460a6727cb088bba7fde65e}
Instantiate stats \hypertarget{classCommMonitor_af27ccd765f13a4b7bd119dc7579e2746}{
\index{CommMonitor@{CommMonitor}!system@{system}}
\index{system@{system}!CommMonitor@{CommMonitor}}
\subsubsection[{system}]{\setlength{\rightskip}{0pt plus 5cm}{\bf System}$\ast$ {\bf system}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_af27ccd765f13a4b7bd119dc7579e2746}
The system in which the monitor lives \hypertarget{classCommMonitor_afcb6a80c2432e45a3730484625ee1d20}{
\index{CommMonitor@{CommMonitor}!traceStream@{traceStream}}
\index{traceStream@{traceStream}!CommMonitor@{CommMonitor}}
\subsubsection[{traceStream}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ProtoOutputStream}$\ast$ {\bf traceStream}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_afcb6a80c2432e45a3730484625ee1d20}
Output stream for a potential trace. \hypertarget{classCommMonitor_aed61db18cf47a6b2d34ba6179dd19b40}{
\index{CommMonitor@{CommMonitor}!writeAddrMask@{writeAddrMask}}
\index{writeAddrMask@{writeAddrMask}!CommMonitor@{CommMonitor}}
\subsubsection[{writeAddrMask}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf writeAddrMask}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCommMonitor_aed61db18cf47a6b2d34ba6179dd19b40}
\hyperlink{classAddress}{Address} mask for sources of write accesses to be captured 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{comm__monitor_8hh}{comm\_\-monitor.hh}\item 
mem/\hyperlink{comm__monitor_8cc}{comm\_\-monitor.cc}\end{DoxyCompactItemize}
