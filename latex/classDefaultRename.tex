\hypertarget{classDefaultRename}{
\section{クラス テンプレート DefaultRename$<$ Impl $>$}
\label{classDefaultRename}\index{DefaultRename@{DefaultRename}}
}


{\ttfamily \#include $<$rename.hh$>$}\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structDefaultRename_1_1FreeEntries}{FreeEntries}
\item 
struct \hyperlink{structDefaultRename_1_1RenameHistory}{RenameHistory}
\item 
struct \hyperlink{structDefaultRename_1_1Stalls}{Stalls}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classDefaultRename_ac9f77d94a52c9029448b6d7b61d32718}{RenameStatus} \{ \hyperlink{classDefaultRename_ac9f77d94a52c9029448b6d7b61d32718a26bd8444261cc58df7a86753c79d2520}{Active}, 
\hyperlink{classDefaultRename_ac9f77d94a52c9029448b6d7b61d32718a969c924a722daf6334fca64346092ae6}{Inactive}
 \}
\item 
enum \hyperlink{classDefaultRename_ae2739961013a00cede621d4d72f2173c}{ThreadStatus} \{ \par
\hyperlink{classDefaultRename_ae2739961013a00cede621d4d72f2173ca2f5f2c4a8c4f4f0519d503dcdfbf55cb}{Running}, 
\hyperlink{classDefaultRename_ae2739961013a00cede621d4d72f2173cad3fa9ae9431d6cb1772f9d9df48cab19}{Idle}, 
\hyperlink{classDefaultRename_ae2739961013a00cede621d4d72f2173ca19a48e232b72697e4bb7ea1b6075ed49}{StartSquash}, 
\hyperlink{classDefaultRename_ae2739961013a00cede621d4d72f2173ca22a648855197e326dc88f548634c0ec7}{Squashing}, 
\par
\hyperlink{classDefaultRename_ae2739961013a00cede621d4d72f2173ca9463ee9b8700258a1019b4b9d2d77a30}{Blocked}, 
\hyperlink{classDefaultRename_ae2739961013a00cede621d4d72f2173caf2a3acf850890cb1651bc41dcbacb7e0}{Unblocking}, 
\hyperlink{classDefaultRename_ae2739961013a00cede621d4d72f2173caca0d28c09e2dcdb3aec968eda81d65f3}{SerializeStall}
 \}
\item 
typedef Impl::CPUPol \hyperlink{classDefaultRename_a87d662eaeb9eab249d671b63cb4ba11a}{CPUPol}
\item 
typedef Impl::DynInstPtr \hyperlink{classDefaultRename_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}
\item 
typedef Impl::O3CPU \hyperlink{classDefaultRename_a44622cf06940413482836cb62931ac3f}{O3CPU}
\item 
typedef CPUPol::DecodeStruct \hyperlink{classDefaultRename_a38077cd156cf219016abf92d8c5b523b}{DecodeStruct}
\item 
typedef CPUPol::RenameStruct \hyperlink{classDefaultRename_a0c2a89ad2edad9ad605d0461f9b132a5}{RenameStruct}
\item 
typedef CPUPol::TimeStruct \hyperlink{classDefaultRename_ab7dd3632ef639702a5c6e7c2c3a2f82a}{TimeStruct}
\item 
typedef CPUPol::FreeList \hyperlink{classDefaultRename_ab784c356bacd490590fba42443e0f786}{FreeList}
\item 
typedef CPUPol::RenameMap \hyperlink{classDefaultRename_a341963bcea1928476182a17e357f98e3}{RenameMap}
\item 
typedef CPUPol::IEW \hyperlink{classDefaultRename_a2e298f790f528754f0e0ffa0cb8088f6}{IEW}
\item 
typedef CPUPol::Commit \hyperlink{classDefaultRename_a05a26def5ee77f19d25b86079d161ebd}{Commit}
\item 
typedef TheISA::RegIndex \hyperlink{classDefaultRename_a36d25e03e43fa3bb4c5482cbefe5e0fb}{RegIndex}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classDefaultRename_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classDefaultRename_adba1ac227fff8c6f9b17ded2fb270e77}{InstQueue}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classDefaultRename_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$::iterator \hyperlink{classDefaultRename_a184cb829e22cc656acb41864f68f51ea}{ListIt}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDefaultRename_a6035d792bb85b9f4c301d53c20885dfc}{DefaultRename} (\hyperlink{classDefaultRename_a44622cf06940413482836cb62931ac3f}{O3CPU} $\ast$\_\-cpu, DerivO3CPUParams $\ast$params)
\item 
std::string \hyperlink{classDefaultRename_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classDefaultRename_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classDefaultRename_a2b521ea5f191fff72265f60d4ed5187b}{setTimeBuffer} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$ $\ast$tb\_\-ptr)
\item 
void \hyperlink{classDefaultRename_a701624f92a819fe4205faede6e614d9f}{setRenameQueue} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultRename_a0c2a89ad2edad9ad605d0461f9b132a5}{RenameStruct} $>$ $\ast$rq\_\-ptr)
\item 
void \hyperlink{classDefaultRename_a21f95db13a2fc05d7a5fcc43fec1f1e7}{setDecodeQueue} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultRename_a38077cd156cf219016abf92d8c5b523b}{DecodeStruct} $>$ $\ast$dq\_\-ptr)
\item 
void \hyperlink{classDefaultRename_a4b6d8e4b2cf6249763ed2fc73eb1af47}{setIEWStage} (\hyperlink{classDefaultRename_a2e298f790f528754f0e0ffa0cb8088f6}{IEW} $\ast$iew\_\-stage)
\item 
void \hyperlink{classDefaultRename_a1e488bc36055daaf1f86a9b4e58118c2}{setCommitStage} (\hyperlink{classDefaultRename_a05a26def5ee77f19d25b86079d161ebd}{Commit} $\ast$commit\_\-stage)
\item 
void \hyperlink{classDefaultRename_a31d4cbdab16d4ff8d6bc7f84ece727da}{startupStage} ()
\item 
void \hyperlink{classDefaultRename_aab96bdacf8bd420402cbb543f994e054}{setActiveThreads} (\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$at\_\-ptr)
\item 
void \hyperlink{classDefaultRename_a6f0aaedb2c39d674ef86c25d0aeb4211}{setRenameMap} (\hyperlink{classDefaultRename_a341963bcea1928476182a17e357f98e3}{RenameMap} rm\_\-ptr\mbox{[}Impl::MaxThreads\mbox{]})
\item 
void \hyperlink{classDefaultRename_a2d3550e87cb180105600dfaefcf83358}{setFreeList} (\hyperlink{classDefaultRename_ab784c356bacd490590fba42443e0f786}{FreeList} $\ast$fl\_\-ptr)
\item 
void \hyperlink{classDefaultRename_a0b50ac63f22501d5c688294031615b6e}{setScoreboard} (\hyperlink{classScoreboard}{Scoreboard} $\ast$\_\-scoreboard)
\item 
void \hyperlink{classDefaultRename_a0240eb42fa57fe5d3788093f62b77347}{drainSanityCheck} () const 
\item 
bool \hyperlink{classDefaultRename_adf5473c18a3d7c1e88c4a2072bce5526}{isDrained} () const 
\item 
void \hyperlink{classDefaultRename_a8674059ce345e23aac5086b2c3e24a43}{takeOverFrom} ()
\item 
void \hyperlink{classDefaultRename_aa896d7ff2c9da1e6e96d46ab4580ec9d}{squash} (const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&squash\_\-seq\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultRename_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\item 
void \hyperlink{classDefaultRename_a697961c6f132b511d2921ed9feed80fa}{dumpHistory} ()
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classDefaultRename_ae3b7ca6b65ac494b86816b5f1dd24e96}{FullSource} \{ \hyperlink{classDefaultRename_ae3b7ca6b65ac494b86816b5f1dd24e96a5040344e9d10f27af23c05c21c5e284f}{ROB}, 
\hyperlink{classDefaultRename_ae3b7ca6b65ac494b86816b5f1dd24e96a7608065caa4249ff47a58c32d6f3c531}{IQ}, 
\hyperlink{classDefaultRename_ae3b7ca6b65ac494b86816b5f1dd24e96a4cc572b5087c4e67104941ee638a8512}{LSQ}, 
\hyperlink{classDefaultRename_ae3b7ca6b65ac494b86816b5f1dd24e96ac157bdf0b85a40d2619cbc8bc1ae5fe2}{NONE}
 \}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classDefaultRename_ada2a699094bc420f977abf2a17ed14c8}{resetStage} ()
\item 
void \hyperlink{classDefaultRename_ae79f7fcdd0255495d6df18c063988432}{rename} (bool \&status\_\-change, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultRename_a8ff86a7781da8390490774c08b1819f2}{renameInsts} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultRename_ac24515147270ef9b85991bbe13bd47af}{skidInsert} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultRename_a9ff2aa32ab0f40674cb3518108d62f8e}{sortInsts} ()
\item 
bool \hyperlink{classDefaultRename_afe3e2673d17dd5c568862ef5ae68b4d8}{skidsEmpty} ()
\item 
void \hyperlink{classDefaultRename_a4bb9486757ce225941aaaf759b357a57}{updateStatus} ()
\item 
bool \hyperlink{classDefaultRename_ad1993925abd15d3fb59fde2ccfa3d678}{block} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classDefaultRename_a9cc3b95f6969935f78c0158aa5145021}{unblock} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultRename_a32818ae72457917ca9551faa708ba584}{doSquash} (const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&squash\_\-seq\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultRename_a4e15b4f66caef87aacbd195e4a02804d}{removeFromHistory} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} inst\_\-seq\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultRename_a8c18390fbeba66214f3854d7325a1d0e}{renameSrcRegs} (\hyperlink{classDefaultRename_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultRename_a21ced1baf75f43ecfa99d8c90ae210d6}{renameDestRegs} (\hyperlink{classDefaultRename_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
int \hyperlink{classDefaultRename_a6367314e59f9295e1bf57419938874c5}{calcFreeROBEntries} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
int \hyperlink{classDefaultRename_a27fa95f1f1dd353635a73f0b56a64e24}{calcFreeIQEntries} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
int \hyperlink{classDefaultRename_a31f50b46622924ea0e53e641b635887c}{calcFreeLSQEntries} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
unsigned \hyperlink{classDefaultRename_ad533c56329b83d5b1aef92d0a6594b2c}{validInsts} ()
\item 
void \hyperlink{classDefaultRename_ad65c9f053a6038ac8c34c34bfe9a88c3}{readStallSignals} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classDefaultRename_a2dd2400250619a315cb46f95f777db01}{checkStall} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultRename_a7dc4c8fb34921e56b869bac55a7f3806}{readFreeEntries} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classDefaultRename_af77f2bf38a75182c65e633b9fdf295d2}{checkSignalsAndUpdate} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultRename_a4010b268c107b9aa7289a98f67171e08}{serializeAfter} (\hyperlink{classstd_1_1list}{InstQueue} \&inst\_\-list, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultRename_a11c6015950a669c6a37e5d9bee62bbbf}{incrFullStat} (const \hyperlink{classDefaultRename_ae3b7ca6b65ac494b86816b5f1dd24e96}{FullSource} \&source)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDefaultRename_ac9f77d94a52c9029448b6d7b61d32718}{RenameStatus} \hyperlink{classDefaultRename_a1564313ed7a74659481a1b5ea2bacf88}{\_\-status}
\item 
\hyperlink{classDefaultRename_ae2739961013a00cede621d4d72f2173c}{ThreadStatus} \hyperlink{classDefaultRename_a8c157bf422205d3cdd7e7c75c2592b6f}{renameStatus} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classDefaultRename_a2e298f790f528754f0e0ffa0cb8088f6}{IEW} $\ast$ \hyperlink{classDefaultRename_abf7286da8e826739b29fa67855f4216b}{iew\_\-ptr}
\item 
\hyperlink{classDefaultRename_a05a26def5ee77f19d25b86079d161ebd}{Commit} $\ast$ \hyperlink{classDefaultRename_a51b23beeb9e078c0c11831d0f2e56bfd}{commit\_\-ptr}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{structDefaultRename_1_1RenameHistory}{RenameHistory} $>$ \hyperlink{classDefaultRename_adc01dc05e6459841df629cb3353ddde9}{historyBuffer} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classDefaultRename_a44622cf06940413482836cb62931ac3f}{O3CPU} $\ast$ \hyperlink{classDefaultRename_a1379cf882a12ac6fc9eba5da7c84b18b}{cpu}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$ $\ast$ \hyperlink{classDefaultRename_a83f9ee976e732665aeb08dbc19acfd45}{timeBuffer}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classDefaultRename_a6c9093e88770a58dc8853f49a09bbac8}{fromIEW}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classDefaultRename_a0055a92bd94eda21c2641d46ff013dac}{fromCommit}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classDefaultRename_aeb2f0e9b4602def9a8a57f7e3e12cf27}{toDecode}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultRename_a0c2a89ad2edad9ad605d0461f9b132a5}{RenameStruct} $>$ $\ast$ \hyperlink{classDefaultRename_ae9b536282159ba75153a223be77515ba}{renameQueue}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultRename_a0c2a89ad2edad9ad605d0461f9b132a5}{RenameStruct} $>$::wire \hyperlink{classDefaultRename_a20add800a4fdb85a3d370265f248a006}{toIEW}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultRename_a38077cd156cf219016abf92d8c5b523b}{DecodeStruct} $>$ $\ast$ \hyperlink{classDefaultRename_a7860fc5736574343c9e294cb2bef9d93}{decodeQueue}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultRename_a38077cd156cf219016abf92d8c5b523b}{DecodeStruct} $>$::wire \hyperlink{classDefaultRename_a8bf861a7b2c3731d3a69bf370564e975}{fromDecode}
\item 
\hyperlink{classstd_1_1list}{InstQueue} \hyperlink{classDefaultRename_a4b6cd9f78efe8b5101b48dbf35a43c11}{insts} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classstd_1_1list}{InstQueue} \hyperlink{classDefaultRename_a64b861e400ea5adcf7a2f2dbe605e221}{skidBuffer} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classDefaultRename_a341963bcea1928476182a17e357f98e3}{RenameMap} $\ast$ \hyperlink{classDefaultRename_ac305c101c17d28451cc1f023b187b08b}{renameMap} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classDefaultRename_ab784c356bacd490590fba42443e0f786}{FreeList} $\ast$ \hyperlink{classDefaultRename_a2e829c52dbc56e7ac6d2fc6a0524ff9c}{freeList}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$ \hyperlink{classDefaultRename_af6eaea53db532812052f71bf0380dab5}{activeThreads}
\item 
\hyperlink{classScoreboard}{Scoreboard} $\ast$ \hyperlink{classDefaultRename_a265ad15229da2a6a05f908da093b3ed5}{scoreboard}
\item 
int \hyperlink{classDefaultRename_af301c62fee41266f36b1318688c8aa55}{instsInProgress} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
bool \hyperlink{classDefaultRename_a2c7e870d4babdac0dc91fc7ffabd0f3d}{wroteToTimeBuffer}
\item 
\hyperlink{structDefaultRename_1_1FreeEntries}{FreeEntries} \hyperlink{classDefaultRename_a20d0243bc02977001bfbd4834a7d8b5d}{freeEntries} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
bool \hyperlink{classDefaultRename_a5a3345554ca63a6e859943d7174d714f}{emptyROB} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{structDefaultRename_1_1Stalls}{Stalls} \hyperlink{classDefaultRename_ade48cf321f5741ea8e54e071680cacdc}{stalls} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classDefaultRename_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classDefaultRename_a12ab5fca837718e12cc837d0f3c1da82}{serializeInst} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
bool \hyperlink{classDefaultRename_a4d99bc7f86d1a17d44e59c316c273262}{serializeOnNextInst} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
int \hyperlink{classDefaultRename_a3069f8fd673d0e9ea2b1a8ce0ad3fe06}{iewToRenameDelay}
\item 
int \hyperlink{classDefaultRename_a4ff2f51d1e391f739d6d1c73a6bcd0c1}{decodeToRenameDelay}
\item 
unsigned \hyperlink{classDefaultRename_a03ebbedbf40ac0005574e50b3577a651}{commitToRenameDelay}
\item 
unsigned \hyperlink{classDefaultRename_a4b41704382bddb6ee06b5ce97b47dd7b}{renameWidth}
\item 
unsigned \hyperlink{classDefaultRename_aeab15260a0ccc0ea470bb74344b63d17}{commitWidth}
\item 
unsigned \hyperlink{classDefaultRename_abb033b9572d00b4ffa5aca6c7fb51427}{toIEWIndex}
\item 
bool \hyperlink{classDefaultRename_a5a5235d747599dbd49a887663f3739e8}{blockThisCycle}
\item 
bool \hyperlink{classDefaultRename_afa9ffeefc4b3ff8ae1ea9919bedbd1e4}{resumeSerialize}
\item 
bool \hyperlink{classDefaultRename_aacc2e9a4766def499954195037465d42}{resumeUnblocking}
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classDefaultRename_a88377f855dbf5adeeecb06b5bb821d35}{numThreads}
\item 
unsigned \hyperlink{classDefaultRename_a268414a6444b620140f263013a739a17}{skidBufferMax}
\item 
\hyperlink{o3_2comm_8hh_a5ec29599c4bc29a3054c451674969e7b}{PhysRegIndex} \hyperlink{classDefaultRename_acc18d044ab2bf32e6515938485638d28}{maxPhysicalRegs}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_a8931e7bb259c1fe875fd5a88017b29e2}{renameSquashCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_a53baed8fe49369b373c3dd986c683596}{renameIdleCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_a45732215f002b5052d042ef5798735f0}{renameBlockCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_a712d72379bc583c374e2f6179e8ee58f}{renameSerializeStallCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_a7dd03c8b7a88da84ff7e1bdd6b938d47}{renameRunCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_a2f14c493f619ee24a84fbe959ed72a97}{renameUnblockCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_aee6bb4587ea6f254fc29dda4d565afc9}{renameRenamedInsts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_ae988aa97bbfa339fc6e6bf0cbad90832}{renameSquashedInsts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_a41408b25638b2531bc9e3b6ee622d148}{renameROBFullEvents}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_a9a4bab1aece13e48ae2d2a3f247b3354}{renameIQFullEvents}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_aba431e021496d1070a1d8f9ad7ec71f2}{renameLSQFullEvents}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_ac012d0908acb20c3f68593787f626711}{renameFullRegistersEvents}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_a3e2c435288350f7d805557b4d1a2b7a5}{renameRenamedOperands}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_ab0b7632e67fcf2fe1e6bb1cef111eda4}{renameRenameLookups}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_ae2548cb038c1868f0dcf4c5df1154b12}{intRenameLookups}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_ad27b51042b9dc458c5dd63b8c5f8d467}{fpRenameLookups}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_a5d4c3559dbd988f18cc6d1c0e0470fcb}{renameCommittedMaps}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_ae0c8395975c577671916d55df6e05b16}{renameUndoneMaps}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_a6e383a41c8a2b8902dd659805c40621e}{renamedSerializing}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_a94f16020be7d9c91aa978ce88f0adb1b}{renamedTempSerializing}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultRename_a50c910ed2a23d1bbb3e7861c2d1f33f4}{renameSkidInsts}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$class Impl$>$ class DefaultRename$<$ Impl $>$}

\hyperlink{classDefaultRename}{DefaultRename} handles both single threaded and SMT rename. Its width is specified by the parameters; each cycle it tries to rename that many instructions. It holds onto the rename history of all instructions with destination registers, storing the arch. register, the new physical register, and the old physical register, to allow for undoing of mappings if squashing happens, or freeing up registers upon commit. Rename handles blocking if the \hyperlink{classROB}{ROB}, IQ, or \hyperlink{classLSQ}{LSQ} is going to be full. Rename also handles barriers, and does so by stalling on the instruction until the \hyperlink{classROB}{ROB} is empty and there are no instructions in flight to the \hyperlink{classROB}{ROB}. 

\subsection{型定義}
\hypertarget{classDefaultRename_a05a26def5ee77f19d25b86079d161ebd}{
\index{DefaultRename@{DefaultRename}!Commit@{Commit}}
\index{Commit@{Commit}!DefaultRename@{DefaultRename}}
\subsubsection[{Commit}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::Commit {\bf Commit}}}
\label{classDefaultRename_a05a26def5ee77f19d25b86079d161ebd}
\hypertarget{classDefaultRename_a87d662eaeb9eab249d671b63cb4ba11a}{
\index{DefaultRename@{DefaultRename}!CPUPol@{CPUPol}}
\index{CPUPol@{CPUPol}!DefaultRename@{DefaultRename}}
\subsubsection[{CPUPol}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::CPUPol {\bf CPUPol}}}
\label{classDefaultRename_a87d662eaeb9eab249d671b63cb4ba11a}
\hypertarget{classDefaultRename_a38077cd156cf219016abf92d8c5b523b}{
\index{DefaultRename@{DefaultRename}!DecodeStruct@{DecodeStruct}}
\index{DecodeStruct@{DecodeStruct}!DefaultRename@{DefaultRename}}
\subsubsection[{DecodeStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::DecodeStruct {\bf DecodeStruct}}}
\label{classDefaultRename_a38077cd156cf219016abf92d8c5b523b}
\hypertarget{classDefaultRename_a028ce10889c5f6450239d9e9a7347976}{
\index{DefaultRename@{DefaultRename}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!DefaultRename@{DefaultRename}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInstPtr {\bf DynInstPtr}}}
\label{classDefaultRename_a028ce10889c5f6450239d9e9a7347976}
\hypertarget{classDefaultRename_ab784c356bacd490590fba42443e0f786}{
\index{DefaultRename@{DefaultRename}!FreeList@{FreeList}}
\index{FreeList@{FreeList}!DefaultRename@{DefaultRename}}
\subsubsection[{FreeList}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::FreeList {\bf FreeList}}}
\label{classDefaultRename_ab784c356bacd490590fba42443e0f786}
\hypertarget{classDefaultRename_a2e298f790f528754f0e0ffa0cb8088f6}{
\index{DefaultRename@{DefaultRename}!IEW@{IEW}}
\index{IEW@{IEW}!DefaultRename@{DefaultRename}}
\subsubsection[{IEW}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::IEW {\bf IEW}}}
\label{classDefaultRename_a2e298f790f528754f0e0ffa0cb8088f6}
\hypertarget{classDefaultRename_adba1ac227fff8c6f9b17ded2fb270e77}{
\index{DefaultRename@{DefaultRename}!InstQueue@{InstQueue}}
\index{InstQueue@{InstQueue}!DefaultRename@{DefaultRename}}
\subsubsection[{InstQueue}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf DynInstPtr}$>$ {\bf InstQueue}}}
\label{classDefaultRename_adba1ac227fff8c6f9b17ded2fb270e77}
\hypertarget{classDefaultRename_a184cb829e22cc656acb41864f68f51ea}{
\index{DefaultRename@{DefaultRename}!ListIt@{ListIt}}
\index{ListIt@{ListIt}!DefaultRename@{DefaultRename}}
\subsubsection[{ListIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf DynInstPtr}$>$::iterator {\bf ListIt}}}
\label{classDefaultRename_a184cb829e22cc656acb41864f68f51ea}
\hypertarget{classDefaultRename_a44622cf06940413482836cb62931ac3f}{
\index{DefaultRename@{DefaultRename}!O3CPU@{O3CPU}}
\index{O3CPU@{O3CPU}!DefaultRename@{DefaultRename}}
\subsubsection[{O3CPU}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::O3CPU {\bf O3CPU}}}
\label{classDefaultRename_a44622cf06940413482836cb62931ac3f}
\hypertarget{classDefaultRename_a36d25e03e43fa3bb4c5482cbefe5e0fb}{
\index{DefaultRename@{DefaultRename}!RegIndex@{RegIndex}}
\index{RegIndex@{RegIndex}!DefaultRename@{DefaultRename}}
\subsubsection[{RegIndex}]{\setlength{\rightskip}{0pt plus 5cm}typedef TheISA::RegIndex {\bf RegIndex}}}
\label{classDefaultRename_a36d25e03e43fa3bb4c5482cbefe5e0fb}
\hypertarget{classDefaultRename_a341963bcea1928476182a17e357f98e3}{
\index{DefaultRename@{DefaultRename}!RenameMap@{RenameMap}}
\index{RenameMap@{RenameMap}!DefaultRename@{DefaultRename}}
\subsubsection[{RenameMap}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::RenameMap {\bf RenameMap}}}
\label{classDefaultRename_a341963bcea1928476182a17e357f98e3}
\hypertarget{classDefaultRename_a0c2a89ad2edad9ad605d0461f9b132a5}{
\index{DefaultRename@{DefaultRename}!RenameStruct@{RenameStruct}}
\index{RenameStruct@{RenameStruct}!DefaultRename@{DefaultRename}}
\subsubsection[{RenameStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::RenameStruct {\bf RenameStruct}}}
\label{classDefaultRename_a0c2a89ad2edad9ad605d0461f9b132a5}
\hypertarget{classDefaultRename_ab7dd3632ef639702a5c6e7c2c3a2f82a}{
\index{DefaultRename@{DefaultRename}!TimeStruct@{TimeStruct}}
\index{TimeStruct@{TimeStruct}!DefaultRename@{DefaultRename}}
\subsubsection[{TimeStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::TimeStruct {\bf TimeStruct}}}
\label{classDefaultRename_ab7dd3632ef639702a5c6e7c2c3a2f82a}


\subsection{列挙型}
\hypertarget{classDefaultRename_ae3b7ca6b65ac494b86816b5f1dd24e96}{
\index{DefaultRename@{DefaultRename}!FullSource@{FullSource}}
\index{FullSource@{FullSource}!DefaultRename@{DefaultRename}}
\subsubsection[{FullSource}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf FullSource}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_ae3b7ca6b65ac494b86816b5f1dd24e96}
Enum to record the source of a structure full stall. Can come from either \hyperlink{classROB}{ROB}, IQ, \hyperlink{classLSQ}{LSQ}, and it is priortized in that order. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{ROB@{ROB}!DefaultRename@{DefaultRename}}\index{DefaultRename@{DefaultRename}!ROB@{ROB}}\item[{\em 
\hypertarget{classDefaultRename_ae3b7ca6b65ac494b86816b5f1dd24e96a5040344e9d10f27af23c05c21c5e284f}{
ROB}
\label{classDefaultRename_ae3b7ca6b65ac494b86816b5f1dd24e96a5040344e9d10f27af23c05c21c5e284f}
}]\index{IQ@{IQ}!DefaultRename@{DefaultRename}}\index{DefaultRename@{DefaultRename}!IQ@{IQ}}\item[{\em 
\hypertarget{classDefaultRename_ae3b7ca6b65ac494b86816b5f1dd24e96a7608065caa4249ff47a58c32d6f3c531}{
IQ}
\label{classDefaultRename_ae3b7ca6b65ac494b86816b5f1dd24e96a7608065caa4249ff47a58c32d6f3c531}
}]\index{LSQ@{LSQ}!DefaultRename@{DefaultRename}}\index{DefaultRename@{DefaultRename}!LSQ@{LSQ}}\item[{\em 
\hypertarget{classDefaultRename_ae3b7ca6b65ac494b86816b5f1dd24e96a4cc572b5087c4e67104941ee638a8512}{
LSQ}
\label{classDefaultRename_ae3b7ca6b65ac494b86816b5f1dd24e96a4cc572b5087c4e67104941ee638a8512}
}]\index{NONE@{NONE}!DefaultRename@{DefaultRename}}\index{DefaultRename@{DefaultRename}!NONE@{NONE}}\item[{\em 
\hypertarget{classDefaultRename_ae3b7ca6b65ac494b86816b5f1dd24e96ac157bdf0b85a40d2619cbc8bc1ae5fe2}{
NONE}
\label{classDefaultRename_ae3b7ca6b65ac494b86816b5f1dd24e96ac157bdf0b85a40d2619cbc8bc1ae5fe2}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
444                     {
445         ROB,
446         IQ,
447         LSQ,
448         NONE
449     };
\end{DoxyCode}
\hypertarget{classDefaultRename_ac9f77d94a52c9029448b6d7b61d32718}{
\index{DefaultRename@{DefaultRename}!RenameStatus@{RenameStatus}}
\index{RenameStatus@{RenameStatus}!DefaultRename@{DefaultRename}}
\subsubsection[{RenameStatus}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf RenameStatus}}}
\label{classDefaultRename_ac9f77d94a52c9029448b6d7b61d32718}
Overall rename status. Used to determine if the CPU can deschedule itself due to a lack of activity. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Active@{Active}!DefaultRename@{DefaultRename}}\index{DefaultRename@{DefaultRename}!Active@{Active}}\item[{\em 
\hypertarget{classDefaultRename_ac9f77d94a52c9029448b6d7b61d32718a26bd8444261cc58df7a86753c79d2520}{
Active}
\label{classDefaultRename_ac9f77d94a52c9029448b6d7b61d32718a26bd8444261cc58df7a86753c79d2520}
}]\index{Inactive@{Inactive}!DefaultRename@{DefaultRename}}\index{DefaultRename@{DefaultRename}!Inactive@{Inactive}}\item[{\em 
\hypertarget{classDefaultRename_ac9f77d94a52c9029448b6d7b61d32718a969c924a722daf6334fca64346092ae6}{
Inactive}
\label{classDefaultRename_ac9f77d94a52c9029448b6d7b61d32718a969c924a722daf6334fca64346092ae6}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
99                       {
100         Active,
101         Inactive
102     };
\end{DoxyCode}
\hypertarget{classDefaultRename_ae2739961013a00cede621d4d72f2173c}{
\index{DefaultRename@{DefaultRename}!ThreadStatus@{ThreadStatus}}
\index{ThreadStatus@{ThreadStatus}!DefaultRename@{DefaultRename}}
\subsubsection[{ThreadStatus}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ThreadStatus}}}
\label{classDefaultRename_ae2739961013a00cede621d4d72f2173c}
Individual thread status. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Running@{Running}!DefaultRename@{DefaultRename}}\index{DefaultRename@{DefaultRename}!Running@{Running}}\item[{\em 
\hypertarget{classDefaultRename_ae2739961013a00cede621d4d72f2173ca2f5f2c4a8c4f4f0519d503dcdfbf55cb}{
Running}
\label{classDefaultRename_ae2739961013a00cede621d4d72f2173ca2f5f2c4a8c4f4f0519d503dcdfbf55cb}
}]\index{Idle@{Idle}!DefaultRename@{DefaultRename}}\index{DefaultRename@{DefaultRename}!Idle@{Idle}}\item[{\em 
\hypertarget{classDefaultRename_ae2739961013a00cede621d4d72f2173cad3fa9ae9431d6cb1772f9d9df48cab19}{
Idle}
\label{classDefaultRename_ae2739961013a00cede621d4d72f2173cad3fa9ae9431d6cb1772f9d9df48cab19}
}]\index{StartSquash@{StartSquash}!DefaultRename@{DefaultRename}}\index{DefaultRename@{DefaultRename}!StartSquash@{StartSquash}}\item[{\em 
\hypertarget{classDefaultRename_ae2739961013a00cede621d4d72f2173ca19a48e232b72697e4bb7ea1b6075ed49}{
StartSquash}
\label{classDefaultRename_ae2739961013a00cede621d4d72f2173ca19a48e232b72697e4bb7ea1b6075ed49}
}]\index{Squashing@{Squashing}!DefaultRename@{DefaultRename}}\index{DefaultRename@{DefaultRename}!Squashing@{Squashing}}\item[{\em 
\hypertarget{classDefaultRename_ae2739961013a00cede621d4d72f2173ca22a648855197e326dc88f548634c0ec7}{
Squashing}
\label{classDefaultRename_ae2739961013a00cede621d4d72f2173ca22a648855197e326dc88f548634c0ec7}
}]\index{Blocked@{Blocked}!DefaultRename@{DefaultRename}}\index{DefaultRename@{DefaultRename}!Blocked@{Blocked}}\item[{\em 
\hypertarget{classDefaultRename_ae2739961013a00cede621d4d72f2173ca9463ee9b8700258a1019b4b9d2d77a30}{
Blocked}
\label{classDefaultRename_ae2739961013a00cede621d4d72f2173ca9463ee9b8700258a1019b4b9d2d77a30}
}]\index{Unblocking@{Unblocking}!DefaultRename@{DefaultRename}}\index{DefaultRename@{DefaultRename}!Unblocking@{Unblocking}}\item[{\em 
\hypertarget{classDefaultRename_ae2739961013a00cede621d4d72f2173caf2a3acf850890cb1651bc41dcbacb7e0}{
Unblocking}
\label{classDefaultRename_ae2739961013a00cede621d4d72f2173caf2a3acf850890cb1651bc41dcbacb7e0}
}]\index{SerializeStall@{SerializeStall}!DefaultRename@{DefaultRename}}\index{DefaultRename@{DefaultRename}!SerializeStall@{SerializeStall}}\item[{\em 
\hypertarget{classDefaultRename_ae2739961013a00cede621d4d72f2173caca0d28c09e2dcdb3aec968eda81d65f3}{
SerializeStall}
\label{classDefaultRename_ae2739961013a00cede621d4d72f2173caca0d28c09e2dcdb3aec968eda81d65f3}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
105                       {
106         Running,
107         Idle,
108         StartSquash,
109         Squashing,
110         Blocked,
111         Unblocking,
112         SerializeStall
113     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classDefaultRename_a6035d792bb85b9f4c301d53c20885dfc}{
\index{DefaultRename@{DefaultRename}!DefaultRename@{DefaultRename}}
\index{DefaultRename@{DefaultRename}!DefaultRename@{DefaultRename}}
\subsubsection[{DefaultRename}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DefaultRename} ({\bf O3CPU} $\ast$ {\em \_\-cpu}, \/  DerivO3CPUParams $\ast$ {\em params})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultRename_a6035d792bb85b9f4c301d53c20885dfc}
\hyperlink{classDefaultRename}{DefaultRename} constructor. 


\begin{DoxyCode}
64     : cpu(_cpu),
65       iewToRenameDelay(params->iewToRenameDelay),
66       decodeToRenameDelay(params->decodeToRenameDelay),
67       commitToRenameDelay(params->commitToRenameDelay),
68       renameWidth(params->renameWidth),
69       commitWidth(params->commitWidth),
70       numThreads(params->numThreads),
71       maxPhysicalRegs(params->numPhysIntRegs + params->numPhysFloatRegs
72                       + params->numPhysCCRegs)
73 {
74     if (renameWidth > Impl::MaxWidth)
75         fatal("renameWidth (%d) is larger than compiled limit (%d),\n"
76              "\tincrease MaxWidth in src/cpu/o3/impl.hh\n",
77              renameWidth, static_cast<int>(Impl::MaxWidth));
78 
79     // @todo: Make into a parameter.
80     skidBufferMax = (2 * (decodeToRenameDelay * params->decodeWidth)) + 
      renameWidth;
81 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classDefaultRename_ad1993925abd15d3fb59fde2ccfa3d678}{
\index{DefaultRename@{DefaultRename}!block@{block}}
\index{block@{block}!DefaultRename@{DefaultRename}}
\subsubsection[{block}]{\setlength{\rightskip}{0pt plus 5cm}bool block ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_ad1993925abd15d3fb59fde2ccfa3d678}
Switches rename to blocking, and signals back that rename has become blocked. \begin{DoxyReturn}{戻り値}
Returns true if there is a status change. 
\end{DoxyReturn}



\begin{DoxyCode}
812 {
813     DPRINTF(Rename, "[tid:%u]: Blocking.\n", tid);
814 
815     // Add the current inputs onto the skid buffer, so they can be
816     // reprocessed when this stage unblocks.
817     skidInsert(tid);
818 
819     // Only signal backwards to block if the previous stages do not think
820     // rename is already blocked.
821     if (renameStatus[tid] != Blocked) {
822         // If resumeUnblocking is set, we unblocked during the squash,
823         // but now we're have unblocking status. We need to tell earlier
824         // stages to block.
825         if (resumeUnblocking || renameStatus[tid] != Unblocking) {
826             toDecode->renameBlock[tid] = true;
827             toDecode->renameUnblock[tid] = false;
828             wroteToTimeBuffer = true;
829         }
830 
831         // Rename can not go from SerializeStall to Blocked, otherwise
832         // it would not know to complete the serialize stall.
833         if (renameStatus[tid] != SerializeStall) {
834             // Set status to Blocked.
835             renameStatus[tid] = Blocked;
836             return true;
837         }
838     }
839 
840     return false;
841 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a27fa95f1f1dd353635a73f0b56a64e24}{
\index{DefaultRename@{DefaultRename}!calcFreeIQEntries@{calcFreeIQEntries}}
\index{calcFreeIQEntries@{calcFreeIQEntries}!DefaultRename@{DefaultRename}}
\subsubsection[{calcFreeIQEntries}]{\setlength{\rightskip}{0pt plus 5cm}int calcFreeIQEntries ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_a27fa95f1f1dd353635a73f0b56a64e24}
Calculates the number of free IQ entries for a specific thread. 


\begin{DoxyCode}
1114 {
1115     int num_free = freeEntries[tid].iqEntries -
1116                   (instsInProgress[tid] - fromIEW->iewInfo[tid].dispatched);
1117 
1118     //DPRINTF(Rename,"[tid:%i]: %i iq free\n",tid,num_free);
1119 
1120     return num_free;
1121 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a31f50b46622924ea0e53e641b635887c}{
\index{DefaultRename@{DefaultRename}!calcFreeLSQEntries@{calcFreeLSQEntries}}
\index{calcFreeLSQEntries@{calcFreeLSQEntries}!DefaultRename@{DefaultRename}}
\subsubsection[{calcFreeLSQEntries}]{\setlength{\rightskip}{0pt plus 5cm}int calcFreeLSQEntries ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_a31f50b46622924ea0e53e641b635887c}
Calculates the number of free \hyperlink{classLSQ}{LSQ} entries for a specific thread. 


\begin{DoxyCode}
1126 {
1127     int num_free = freeEntries[tid].lsqEntries -
1128                   (instsInProgress[tid] - fromIEW->iewInfo[tid].dispatchedToLSQ);
      
1129 
1130     //DPRINTF(Rename,"[tid:%i]: %i lsq free\n",tid,num_free);
1131 
1132     return num_free;
1133 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a6367314e59f9295e1bf57419938874c5}{
\index{DefaultRename@{DefaultRename}!calcFreeROBEntries@{calcFreeROBEntries}}
\index{calcFreeROBEntries@{calcFreeROBEntries}!DefaultRename@{DefaultRename}}
\subsubsection[{calcFreeROBEntries}]{\setlength{\rightskip}{0pt plus 5cm}int calcFreeROBEntries ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_a6367314e59f9295e1bf57419938874c5}
Calculates the number of free \hyperlink{classROB}{ROB} entries for a specific thread. 


\begin{DoxyCode}
1102 {
1103     int num_free = freeEntries[tid].robEntries -
1104                   (instsInProgress[tid] - fromIEW->iewInfo[tid].dispatched);
1105 
1106     //DPRINTF(Rename,"[tid:%i]: %i rob free\n",tid,num_free);
1107 
1108     return num_free;
1109 }
\end{DoxyCode}
\hypertarget{classDefaultRename_af77f2bf38a75182c65e633b9fdf295d2}{
\index{DefaultRename@{DefaultRename}!checkSignalsAndUpdate@{checkSignalsAndUpdate}}
\index{checkSignalsAndUpdate@{checkSignalsAndUpdate}!DefaultRename@{DefaultRename}}
\subsubsection[{checkSignalsAndUpdate}]{\setlength{\rightskip}{0pt plus 5cm}bool checkSignalsAndUpdate ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_af77f2bf38a75182c65e633b9fdf295d2}
Checks the signals and updates the status. 


\begin{DoxyCode}
1236 {
1237     // Check if there's a squash signal, squash if there is
1238     // Check stall signals, block if necessary.
1239     // If status was blocked
1240     //     check if stall conditions have passed
1241     //         if so then go to unblocking
1242     // If status was Squashing
1243     //     check if squashing is not high.  Switch to running this cycle.
1244     // If status was serialize stall
1245     //     check if ROB is empty and no insts are in flight to the ROB
1246 
1247     readFreeEntries(tid);
1248     readStallSignals(tid);
1249 
1250     if (fromCommit->commitInfo[tid].squash) {
1251         DPRINTF(Rename, "[tid:%u]: Squashing instructions due to squash from "
1252                 "commit.\n", tid);
1253 
1254         squash(fromCommit->commitInfo[tid].doneSeqNum, tid);
1255 
1256         return true;
1257     }
1258 
1259     if (fromCommit->commitInfo[tid].robSquashing) {
1260         DPRINTF(Rename, "[tid:%u]: ROB is still squashing.\n", tid);
1261 
1262         renameStatus[tid] = Squashing;
1263 
1264         return true;
1265     }
1266 
1267     if (checkStall(tid)) {
1268         return block(tid);
1269     }
1270 
1271     if (renameStatus[tid] == Blocked) {
1272         DPRINTF(Rename, "[tid:%u]: Done blocking, switching to unblocking.\n",
1273                 tid);
1274 
1275         renameStatus[tid] = Unblocking;
1276 
1277         unblock(tid);
1278 
1279         return true;
1280     }
1281 
1282     if (renameStatus[tid] == Squashing) {
1283         // Switch status to running if rename isn't being told to block or
1284         // squash this cycle.
1285         if (resumeSerialize) {
1286             DPRINTF(Rename, "[tid:%u]: Done squashing, switching to serialize.\n"
      ,
1287                     tid);
1288 
1289             renameStatus[tid] = SerializeStall;
1290             return true;
1291         } else if (resumeUnblocking) {
1292             DPRINTF(Rename, "[tid:%u]: Done squashing, switching to unblocking.\n
      ",
1293                     tid);
1294             renameStatus[tid] = Unblocking;
1295             return true;
1296         } else {
1297             DPRINTF(Rename, "[tid:%u]: Done squashing, switching to running.\n",
1298                     tid);
1299 
1300             renameStatus[tid] = Running;
1301             return false;
1302         }
1303     }
1304 
1305     if (renameStatus[tid] == SerializeStall) {
1306         // Stall ends once the ROB is free.
1307         DPRINTF(Rename, "[tid:%u]: Done with serialize stall, switching to "
1308                 "unblocking.\n", tid);
1309 
1310         DynInstPtr serial_inst = serializeInst[tid];
1311 
1312         renameStatus[tid] = Unblocking;
1313 
1314         unblock(tid);
1315 
1316         DPRINTF(Rename, "[tid:%u]: Processing instruction [%lli] with "
1317                 "PC %s.\n", tid, serial_inst->seqNum, serial_inst->pcState());
1318 
1319         // Put instruction into queue here.
1320         serial_inst->clearSerializeBefore();
1321 
1322         if (!skidBuffer[tid].empty()) {
1323             skidBuffer[tid].push_front(serial_inst);
1324         } else {
1325             insts[tid].push_front(serial_inst);
1326         }
1327 
1328         DPRINTF(Rename, "[tid:%u]: Instruction must be processed by rename."
1329                 " Adding to front of list.\n", tid);
1330 
1331         serializeInst[tid] = NULL;
1332 
1333         return true;
1334     }
1335 
1336     // If we've reached this point, we have not gotten any signals that
1337     // cause rename to change its status.  Rename remains the same as before.
1338     return false;
1339 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a2dd2400250619a315cb46f95f777db01}{
\index{DefaultRename@{DefaultRename}!checkStall@{checkStall}}
\index{checkStall@{checkStall}!DefaultRename@{DefaultRename}}
\subsubsection[{checkStall}]{\setlength{\rightskip}{0pt plus 5cm}bool checkStall ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_a2dd2400250619a315cb46f95f777db01}
Checks if any stages are telling rename to block. 


\begin{DoxyCode}
1175 {
1176     bool ret_val = false;
1177 
1178     if (stalls[tid].iew) {
1179         DPRINTF(Rename,"[tid:%i]: Stall from IEW stage detected.\n", tid);
1180         ret_val = true;
1181     } else if (stalls[tid].commit) {
1182         DPRINTF(Rename,"[tid:%i]: Stall from Commit stage detected.\n", tid);
1183         ret_val = true;
1184     } else if (calcFreeROBEntries(tid) <= 0) {
1185         DPRINTF(Rename,"[tid:%i]: Stall: ROB has 0 free entries.\n", tid);
1186         ret_val = true;
1187     } else if (calcFreeIQEntries(tid) <= 0) {
1188         DPRINTF(Rename,"[tid:%i]: Stall: IQ has 0 free entries.\n", tid);
1189         ret_val = true;
1190     } else if (calcFreeLSQEntries(tid) <= 0) {
1191         DPRINTF(Rename,"[tid:%i]: Stall: LSQ has 0 free entries.\n", tid);
1192         ret_val = true;
1193     } else if (renameMap[tid]->numFreeEntries() <= 0) {
1194         DPRINTF(Rename,"[tid:%i]: Stall: RenameMap has 0 free entries.\n", tid);
1195         ret_val = true;
1196     } else if (renameStatus[tid] == SerializeStall &&
1197                (!emptyROB[tid] || instsInProgress[tid])) {
1198         DPRINTF(Rename,"[tid:%i]: Stall: Serialize stall and ROB is not "
1199                 "empty.\n",
1200                 tid);
1201         ret_val = true;
1202     }
1203 
1204     return ret_val;
1205 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a32818ae72457917ca9551faa708ba584}{
\index{DefaultRename@{DefaultRename}!doSquash@{doSquash}}
\index{doSquash@{doSquash}!DefaultRename@{DefaultRename}}
\subsubsection[{doSquash}]{\setlength{\rightskip}{0pt plus 5cm}void doSquash (const {\bf InstSeqNum} \& {\em squash\_\-seq\_\-num}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_a32818ae72457917ca9551faa708ba584}
Executes actual squash, removing squashed instructions. 


\begin{DoxyCode}
867 {
868     typename std::list<RenameHistory>::iterator hb_it =
869         historyBuffer[tid].begin();
870 
871     // After a syscall squashes everything, the history buffer may be empty
872     // but the ROB may still be squashing instructions.
873     if (historyBuffer[tid].empty()) {
874         return;
875     }
876 
877     // Go through the most recent instructions, undoing the mappings
878     // they did and freeing up the registers.
879     while (!historyBuffer[tid].empty() &&
880            hb_it->instSeqNum > squashed_seq_num) {
881         assert(hb_it != historyBuffer[tid].end());
882 
883         DPRINTF(Rename, "[tid:%u]: Removing history entry with sequence "
884                 "number %i.\n", tid, hb_it->instSeqNum);
885 
886         // Undo the rename mapping only if it was really a change.
887         // Special regs that are not really renamed (like misc regs
888         // and the zero reg) can be recognized because the new mapping
889         // is the same as the old one.  While it would be merely a
890         // waste of time to update the rename table, we definitely
891         // don't want to put these on the free list.
892         if (hb_it->newPhysReg != hb_it->prevPhysReg) {
893             // Tell the rename map to set the architected register to the
894             // previous physical register that it was renamed to.
895             renameMap[tid]->setEntry(hb_it->archReg, hb_it->prevPhysReg);
896 
897             // Put the renamed physical register back on the free list.
898             freeList->addReg(hb_it->newPhysReg);
899         }
900 
901         historyBuffer[tid].erase(hb_it++);
902 
903         ++renameUndoneMaps;
904     }
905 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a0240eb42fa57fe5d3788093f62b77347}{
\index{DefaultRename@{DefaultRename}!drainSanityCheck@{drainSanityCheck}}
\index{drainSanityCheck@{drainSanityCheck}!DefaultRename@{DefaultRename}}
\subsubsection[{drainSanityCheck}]{\setlength{\rightskip}{0pt plus 5cm}void drainSanityCheck () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultRename_a0240eb42fa57fe5d3788093f62b77347}
Perform sanity checks after a drain. 


\begin{DoxyCode}
308 {
309     for (ThreadID tid = 0; tid < numThreads; tid++) {
310         assert(historyBuffer[tid].empty());
311         assert(insts[tid].empty());
312         assert(skidBuffer[tid].empty());
313         assert(instsInProgress[tid] == 0);
314     }
315 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a697961c6f132b511d2921ed9feed80fa}{
\index{DefaultRename@{DefaultRename}!dumpHistory@{dumpHistory}}
\index{dumpHistory@{dumpHistory}!DefaultRename@{DefaultRename}}
\subsubsection[{dumpHistory}]{\setlength{\rightskip}{0pt plus 5cm}void dumpHistory ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultRename_a697961c6f132b511d2921ed9feed80fa}
Debugging function used to dump history buffer of renamings. 


\begin{DoxyCode}
1378 {
1379     typename std::list<RenameHistory>::iterator buf_it;
1380 
1381     for (ThreadID tid = 0; tid < numThreads; tid++) {
1382 
1383         buf_it = historyBuffer[tid].begin();
1384 
1385         while (buf_it != historyBuffer[tid].end()) {
1386             cprintf("Seq num: %i\nArch reg: %i New phys reg: %i Old phys "
1387                     "reg: %i\n", (*buf_it).instSeqNum, (int)(*buf_it).archReg,
1388                     (int)(*buf_it).newPhysReg, (int)(*buf_it).prevPhysReg);
1389 
1390             buf_it++;
1391         }
1392     }
1393 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a11c6015950a669c6a37e5d9bee62bbbf}{
\index{DefaultRename@{DefaultRename}!incrFullStat@{incrFullStat}}
\index{incrFullStat@{incrFullStat}!DefaultRename@{DefaultRename}}
\subsubsection[{incrFullStat}]{\setlength{\rightskip}{0pt plus 5cm}void incrFullStat (const {\bf FullSource} \& {\em source})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_a11c6015950a669c6a37e5d9bee62bbbf}
Function used to increment the stat that corresponds to the source of the stall. 


\begin{DoxyCode}
1358 {
1359     switch (source) {
1360       case ROB:
1361         ++renameROBFullEvents;
1362         break;
1363       case IQ:
1364         ++renameIQFullEvents;
1365         break;
1366       case LSQ:
1367         ++renameLSQFullEvents;
1368         break;
1369       default:
1370         panic("Rename full stall stat should be incremented for a reason!");
1371         break;
1372     }
1373 }
\end{DoxyCode}
\hypertarget{classDefaultRename_adf5473c18a3d7c1e88c4a2072bce5526}{
\index{DefaultRename@{DefaultRename}!isDrained@{isDrained}}
\index{isDrained@{isDrained}!DefaultRename@{DefaultRename}}
\subsubsection[{isDrained}]{\setlength{\rightskip}{0pt plus 5cm}bool isDrained () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultRename_adf5473c18a3d7c1e88c4a2072bce5526}
Has the stage drained? 


\begin{DoxyCode}
287 {
288     for (ThreadID tid = 0; tid < numThreads; tid++) {
289         if (instsInProgress[tid] != 0 ||
290             !historyBuffer[tid].empty() ||
291             !skidBuffer[tid].empty() ||
292             !insts[tid].empty())
293             return false;
294     }
295     return true;
296 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{DefaultRename@{DefaultRename}!name@{name}}
\index{name@{name}!DefaultRename@{DefaultRename}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultRename_a37627d5d5bba7f4a8690c71c2ab3cb07}
Returns the name of rename. 


\begin{DoxyCode}
86 {
87     return cpu->name() + ".rename";
88 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a7dc4c8fb34921e56b869bac55a7f3806}{
\index{DefaultRename@{DefaultRename}!readFreeEntries@{readFreeEntries}}
\index{readFreeEntries@{readFreeEntries}!DefaultRename@{DefaultRename}}
\subsubsection[{readFreeEntries}]{\setlength{\rightskip}{0pt plus 5cm}void readFreeEntries ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_a7dc4c8fb34921e56b869bac55a7f3806}
Gets the number of free entries for a specific thread. 


\begin{DoxyCode}
1210 {
1211     if (fromIEW->iewInfo[tid].usedIQ)
1212         freeEntries[tid].iqEntries = fromIEW->iewInfo[tid].freeIQEntries;
1213 
1214     if (fromIEW->iewInfo[tid].usedLSQ)
1215         freeEntries[tid].lsqEntries = fromIEW->iewInfo[tid].freeLSQEntries;
1216 
1217     if (fromCommit->commitInfo[tid].usedROB) {
1218         freeEntries[tid].robEntries =
1219             fromCommit->commitInfo[tid].freeROBEntries;
1220         emptyROB[tid] = fromCommit->commitInfo[tid].emptyROB;
1221     }
1222 
1223     DPRINTF(Rename, "[tid:%i]: Free IQ: %i, Free ROB: %i, Free LSQ: %i\n",
1224             tid,
1225             freeEntries[tid].iqEntries,
1226             freeEntries[tid].robEntries,
1227             freeEntries[tid].lsqEntries);
1228 
1229     DPRINTF(Rename, "[tid:%i]: %i instructions not yet in ROB\n",
1230             tid, instsInProgress[tid]);
1231 }
\end{DoxyCode}
\hypertarget{classDefaultRename_ad65c9f053a6038ac8c34c34bfe9a88c3}{
\index{DefaultRename@{DefaultRename}!readStallSignals@{readStallSignals}}
\index{readStallSignals@{readStallSignals}!DefaultRename@{DefaultRename}}
\subsubsection[{readStallSignals}]{\setlength{\rightskip}{0pt plus 5cm}void readStallSignals ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_ad65c9f053a6038ac8c34c34bfe9a88c3}
Reads signals telling rename to block/unblock. 


\begin{DoxyCode}
1152 {
1153     if (fromIEW->iewBlock[tid]) {
1154         stalls[tid].iew = true;
1155     }
1156 
1157     if (fromIEW->iewUnblock[tid]) {
1158         assert(stalls[tid].iew);
1159         stalls[tid].iew = false;
1160     }
1161 
1162     if (fromCommit->commitBlock[tid]) {
1163         stalls[tid].commit = true;
1164     }
1165 
1166     if (fromCommit->commitUnblock[tid]) {
1167         assert(stalls[tid].commit);
1168         stalls[tid].commit = false;
1169     }
1170 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{DefaultRename@{DefaultRename}!regStats@{regStats}}
\index{regStats@{regStats}!DefaultRename@{DefaultRename}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultRename_a4dc637449366fcdfc4e764cdf12d9b11}
Registers statistics. 


\begin{DoxyCode}
93 {
94     renameSquashCycles
95         .name(name() + ".SquashCycles")
96         .desc("Number of cycles rename is squashing")
97         .prereq(renameSquashCycles);
98     renameIdleCycles
99         .name(name() + ".IdleCycles")
100         .desc("Number of cycles rename is idle")
101         .prereq(renameIdleCycles);
102     renameBlockCycles
103         .name(name() + ".BlockCycles")
104         .desc("Number of cycles rename is blocking")
105         .prereq(renameBlockCycles);
106     renameSerializeStallCycles
107         .name(name() + ".serializeStallCycles")
108         .desc("count of cycles rename stalled for serializing inst")
109         .flags(Stats::total);
110     renameRunCycles
111         .name(name() + ".RunCycles")
112         .desc("Number of cycles rename is running")
113         .prereq(renameIdleCycles);
114     renameUnblockCycles
115         .name(name() + ".UnblockCycles")
116         .desc("Number of cycles rename is unblocking")
117         .prereq(renameUnblockCycles);
118     renameRenamedInsts
119         .name(name() + ".RenamedInsts")
120         .desc("Number of instructions processed by rename")
121         .prereq(renameRenamedInsts);
122     renameSquashedInsts
123         .name(name() + ".SquashedInsts")
124         .desc("Number of squashed instructions processed by rename")
125         .prereq(renameSquashedInsts);
126     renameROBFullEvents
127         .name(name() + ".ROBFullEvents")
128         .desc("Number of times rename has blocked due to ROB full")
129         .prereq(renameROBFullEvents);
130     renameIQFullEvents
131         .name(name() + ".IQFullEvents")
132         .desc("Number of times rename has blocked due to IQ full")
133         .prereq(renameIQFullEvents);
134     renameLSQFullEvents
135         .name(name() + ".LSQFullEvents")
136         .desc("Number of times rename has blocked due to LSQ full")
137         .prereq(renameLSQFullEvents);
138     renameFullRegistersEvents
139         .name(name() + ".FullRegisterEvents")
140         .desc("Number of times there has been no free registers")
141         .prereq(renameFullRegistersEvents);
142     renameRenamedOperands
143         .name(name() + ".RenamedOperands")
144         .desc("Number of destination operands rename has renamed")
145         .prereq(renameRenamedOperands);
146     renameRenameLookups
147         .name(name() + ".RenameLookups")
148         .desc("Number of register rename lookups that rename has made")
149         .prereq(renameRenameLookups);
150     renameCommittedMaps
151         .name(name() + ".CommittedMaps")
152         .desc("Number of HB maps that are committed")
153         .prereq(renameCommittedMaps);
154     renameUndoneMaps
155         .name(name() + ".UndoneMaps")
156         .desc("Number of HB maps that are undone due to squashing")
157         .prereq(renameUndoneMaps);
158     renamedSerializing
159         .name(name() + ".serializingInsts")
160         .desc("count of serializing insts renamed")
161         .flags(Stats::total)
162         ;
163     renamedTempSerializing
164         .name(name() + ".tempSerializingInsts")
165         .desc("count of temporary serializing insts renamed")
166         .flags(Stats::total)
167         ;
168     renameSkidInsts
169         .name(name() + ".skidInsts")
170         .desc("count of insts added to the skid buffer")
171         .flags(Stats::total)
172         ;
173     intRenameLookups
174         .name(name() + ".int_rename_lookups")
175         .desc("Number of integer rename lookups")
176         .prereq(intRenameLookups);
177     fpRenameLookups
178         .name(name() + ".fp_rename_lookups")
179         .desc("Number of floating rename lookups")
180         .prereq(fpRenameLookups);
181 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a4e15b4f66caef87aacbd195e4a02804d}{
\index{DefaultRename@{DefaultRename}!removeFromHistory@{removeFromHistory}}
\index{removeFromHistory@{removeFromHistory}!DefaultRename@{DefaultRename}}
\subsubsection[{removeFromHistory}]{\setlength{\rightskip}{0pt plus 5cm}void removeFromHistory ({\bf InstSeqNum} {\em inst\_\-seq\_\-num}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_a4e15b4f66caef87aacbd195e4a02804d}
Removes a committed instruction's rename history. 


\begin{DoxyCode}
910 {
911     DPRINTF(Rename, "[tid:%u]: Removing a committed instruction from the "
912             "history buffer %u (size=%i), until [sn:%lli].\n",
913             tid, tid, historyBuffer[tid].size(), inst_seq_num);
914 
915     typename std::list<RenameHistory>::iterator hb_it =
916         historyBuffer[tid].end();
917 
918     --hb_it;
919 
920     if (historyBuffer[tid].empty()) {
921         DPRINTF(Rename, "[tid:%u]: History buffer is empty.\n", tid);
922         return;
923     } else if (hb_it->instSeqNum > inst_seq_num) {
924         DPRINTF(Rename, "[tid:%u]: Old sequence number encountered.  Ensure "
925                 "that a syscall happened recently.\n", tid);
926         return;
927     }
928 
929     // Commit all the renames up until (and including) the committed sequence
930     // number. Some or even all of the committed instructions may not have
931     // rename histories if they did not have destination registers that were
932     // renamed.
933     while (!historyBuffer[tid].empty() &&
934            hb_it != historyBuffer[tid].end() &&
935            hb_it->instSeqNum <= inst_seq_num) {
936 
937         DPRINTF(Rename, "[tid:%u]: Freeing up older rename of reg %i, "
938                 "[sn:%lli].\n",
939                 tid, hb_it->prevPhysReg, hb_it->instSeqNum);
940 
941         // Don't free special phys regs like misc and zero regs, which
942         // can be recognized because the new mapping is the same as
943         // the old one.
944         if (hb_it->newPhysReg != hb_it->prevPhysReg) {
945             freeList->addReg(hb_it->prevPhysReg);
946         }
947 
948         ++renameCommittedMaps;
949 
950         historyBuffer[tid].erase(hb_it--);
951     }
952 }
\end{DoxyCode}
\hypertarget{classDefaultRename_ae79f7fcdd0255495d6df18c063988432}{
\index{DefaultRename@{DefaultRename}!rename@{rename}}
\index{rename@{rename}!DefaultRename@{DefaultRename}}
\subsubsection[{rename}]{\setlength{\rightskip}{0pt plus 5cm}void rename (bool \& {\em status\_\-change}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_ae79f7fcdd0255495d6df18c063988432}
Determines what to do based on rename's current status. 
\begin{DoxyParams}{引数}
\item[{\em status\_\-change}]\hyperlink{classDefaultRename_ae79f7fcdd0255495d6df18c063988432}{rename()} sets this variable if there was a status change (ie switching from blocking to unblocking). \item[{\em tid}]Thread id to rename instructions from. \end{DoxyParams}



\begin{DoxyCode}
432 {
433     // If status is Running or idle,
434     //     call renameInsts()
435     // If status is Unblocking,
436     //     buffer any instructions coming from decode
437     //     continue trying to empty skid buffer
438     //     check if stall conditions have passed
439 
440     if (renameStatus[tid] == Blocked) {
441         ++renameBlockCycles;
442     } else if (renameStatus[tid] == Squashing) {
443         ++renameSquashCycles;
444     } else if (renameStatus[tid] == SerializeStall) {
445         ++renameSerializeStallCycles;
446         // If we are currently in SerializeStall and resumeSerialize
447         // was set, then that means that we are resuming serializing
448         // this cycle.  Tell the previous stages to block.
449         if (resumeSerialize) {
450             resumeSerialize = false;
451             block(tid);
452             toDecode->renameUnblock[tid] = false;
453         }
454     } else if (renameStatus[tid] == Unblocking) {
455         if (resumeUnblocking) {
456             block(tid);
457             resumeUnblocking = false;
458             toDecode->renameUnblock[tid] = false;
459         }
460     }
461 
462     if (renameStatus[tid] == Running ||
463         renameStatus[tid] == Idle) {
464         DPRINTF(Rename, "[tid:%u]: Not blocked, so attempting to run "
465                 "stage.\n", tid);
466 
467         renameInsts(tid);
468     } else if (renameStatus[tid] == Unblocking) {
469         renameInsts(tid);
470 
471         if (validInsts()) {
472             // Add the current inputs to the skid buffer so they can be
473             // reprocessed when this stage unblocks.
474             skidInsert(tid);
475         }
476 
477         // If we switched over to blocking, then there's a potential for
478         // an overall status change.
479         status_change = unblock(tid) || status_change || blockThisCycle;
480     }
481 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a21ced1baf75f43ecfa99d8c90ae210d6}{
\index{DefaultRename@{DefaultRename}!renameDestRegs@{renameDestRegs}}
\index{renameDestRegs@{renameDestRegs}!DefaultRename@{DefaultRename}}
\subsubsection[{renameDestRegs}]{\setlength{\rightskip}{0pt plus 5cm}void renameDestRegs ({\bf DynInstPtr} \& {\em inst}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_a21ced1baf75f43ecfa99d8c90ae210d6}
Renames the destination registers of an instruction. 


\begin{DoxyCode}
1022 {
1023     ThreadContext *tc = inst->tcBase();
1024     RenameMap *map = renameMap[tid];
1025     unsigned num_dest_regs = inst->numDestRegs();
1026 
1027     // Rename the destination registers.
1028     for (int dest_idx = 0; dest_idx < num_dest_regs; dest_idx++) {
1029         RegIndex dest_reg = inst->destRegIdx(dest_idx);
1030         RegIndex rel_dest_reg;
1031         RegIndex flat_rel_dest_reg;
1032         RegIndex flat_uni_dest_reg;
1033         typename RenameMap::RenameInfo rename_result;
1034 
1035         switch (regIdxToClass(dest_reg, &rel_dest_reg)) {
1036           case IntRegClass:
1037             flat_rel_dest_reg = tc->flattenIntIndex(rel_dest_reg);
1038             rename_result = map->renameInt(flat_rel_dest_reg);
1039             flat_uni_dest_reg = flat_rel_dest_reg;  // 1:1 mapping
1040             break;
1041 
1042           case FloatRegClass:
1043             flat_rel_dest_reg = tc->flattenFloatIndex(rel_dest_reg);
1044             rename_result = map->renameFloat(flat_rel_dest_reg);
1045             flat_uni_dest_reg = flat_rel_dest_reg + TheISA::FP_Reg_Base;
1046             break;
1047 
1048           case CCRegClass:
1049             flat_rel_dest_reg = tc->flattenCCIndex(rel_dest_reg);
1050             rename_result = map->renameCC(flat_rel_dest_reg);
1051             flat_uni_dest_reg = flat_rel_dest_reg + TheISA::CC_Reg_Base;
1052             break;
1053 
1054           case MiscRegClass:
1055             // misc regs don't get flattened
1056             flat_rel_dest_reg = rel_dest_reg;
1057             rename_result = map->renameMisc(flat_rel_dest_reg);
1058             flat_uni_dest_reg = flat_rel_dest_reg + TheISA::Misc_Reg_Base;
1059             break;
1060 
1061           default:
1062             panic("Reg index is out of bound: %d.", dest_reg);
1063         }
1064 
1065         inst->flattenDestReg(dest_idx, flat_uni_dest_reg);
1066 
1067         // Mark Scoreboard entry as not ready
1068         scoreboard->unsetReg(rename_result.first);
1069 
1070         DPRINTF(Rename, "[tid:%u]: Renaming arch reg %i to physical "
1071                 "reg %i.\n", tid, (int)flat_rel_dest_reg,
1072                 (int)rename_result.first);
1073 
1074         // Record the rename information so that a history can be kept.
1075         RenameHistory hb_entry(inst->seqNum, flat_uni_dest_reg,
1076                                rename_result.first,
1077                                rename_result.second);
1078 
1079         historyBuffer[tid].push_front(hb_entry);
1080 
1081         DPRINTF(Rename, "[tid:%u]: Adding instruction to history buffer "
1082                 "(size=%i), [sn:%lli].\n",tid,
1083                 historyBuffer[tid].size(),
1084                 (*historyBuffer[tid].begin()).instSeqNum);
1085 
1086         // Tell the instruction to rename the appropriate destination
1087         // register (dest_idx) to the new physical register
1088         // (rename_result.first), and record the previous physical
1089         // register that the same logical register was renamed to
1090         // (rename_result.second).
1091         inst->renameDestReg(dest_idx,
1092                             rename_result.first,
1093                             rename_result.second);
1094 
1095         ++renameRenamedOperands;
1096     }
1097 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a8ff86a7781da8390490774c08b1819f2}{
\index{DefaultRename@{DefaultRename}!renameInsts@{renameInsts}}
\index{renameInsts@{renameInsts}!DefaultRename@{DefaultRename}}
\subsubsection[{renameInsts}]{\setlength{\rightskip}{0pt plus 5cm}void renameInsts ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_a8ff86a7781da8390490774c08b1819f2}
Renames instructions for the given thread. Also handles serializing instructions. 


\begin{DoxyCode}
486 {
487     // Instructions can be either in the skid buffer or the queue of
488     // instructions coming from decode, depending on the status.
489     int insts_available = renameStatus[tid] == Unblocking ?
490         skidBuffer[tid].size() : insts[tid].size();
491 
492     // Check the decode queue to see if instructions are available.
493     // If there are no available instructions to rename, then do nothing.
494     if (insts_available == 0) {
495         DPRINTF(Rename, "[tid:%u]: Nothing to do, breaking out early.\n",
496                 tid);
497         // Should I change status to idle?
498         ++renameIdleCycles;
499         return;
500     } else if (renameStatus[tid] == Unblocking) {
501         ++renameUnblockCycles;
502     } else if (renameStatus[tid] == Running) {
503         ++renameRunCycles;
504     }
505 
506     DynInstPtr inst;
507 
508     // Will have to do a different calculation for the number of free
509     // entries.
510     int free_rob_entries = calcFreeROBEntries(tid);
511     int free_iq_entries  = calcFreeIQEntries(tid);
512     int free_lsq_entries = calcFreeLSQEntries(tid);
513     int min_free_entries = free_rob_entries;
514 
515     FullSource source = ROB;
516 
517     if (free_iq_entries < min_free_entries) {
518         min_free_entries = free_iq_entries;
519         source = IQ;
520     }
521 
522     if (free_lsq_entries < min_free_entries) {
523         min_free_entries = free_lsq_entries;
524         source = LSQ;
525     }
526 
527     // Check if there's any space left.
528     if (min_free_entries <= 0) {
529         DPRINTF(Rename, "[tid:%u]: Blocking due to no free ROB/IQ/LSQ "
530                 "entries.\n"
531                 "ROB has %i free entries.\n"
532                 "IQ has %i free entries.\n"
533                 "LSQ has %i free entries.\n",
534                 tid,
535                 free_rob_entries,
536                 free_iq_entries,
537                 free_lsq_entries);
538 
539         blockThisCycle = true;
540 
541         block(tid);
542 
543         incrFullStat(source);
544 
545         return;
546     } else if (min_free_entries < insts_available) {
547         DPRINTF(Rename, "[tid:%u]: Will have to block this cycle."
548                 "%i insts available, but only %i insts can be "
549                 "renamed due to ROB/IQ/LSQ limits.\n",
550                 tid, insts_available, min_free_entries);
551 
552         insts_available = min_free_entries;
553 
554         blockThisCycle = true;
555 
556         incrFullStat(source);
557     }
558 
559     InstQueue &insts_to_rename = renameStatus[tid] == Unblocking ?
560         skidBuffer[tid] : insts[tid];
561 
562     DPRINTF(Rename, "[tid:%u]: %i available instructions to "
563             "send iew.\n", tid, insts_available);
564 
565     DPRINTF(Rename, "[tid:%u]: %i insts pipelining from Rename | %i insts "
566             "dispatched to IQ last cycle.\n",
567             tid, instsInProgress[tid], fromIEW->iewInfo[tid].dispatched);
568 
569     // Handle serializing the next instruction if necessary.
570     if (serializeOnNextInst[tid]) {
571         if (emptyROB[tid] && instsInProgress[tid] == 0) {
572             // ROB already empty; no need to serialize.
573             serializeOnNextInst[tid] = false;
574         } else if (!insts_to_rename.empty()) {
575             insts_to_rename.front()->setSerializeBefore();
576         }
577     }
578 
579     int renamed_insts = 0;
580 
581     while (insts_available > 0 &&  toIEWIndex < renameWidth) {
582         DPRINTF(Rename, "[tid:%u]: Sending instructions to IEW.\n", tid);
583 
584         assert(!insts_to_rename.empty());
585 
586         inst = insts_to_rename.front();
587 
588         insts_to_rename.pop_front();
589 
590         if (renameStatus[tid] == Unblocking) {
591             DPRINTF(Rename,"[tid:%u]: Removing [sn:%lli] PC:%s from rename "
592                     "skidBuffer\n", tid, inst->seqNum, inst->pcState());
593         }
594 
595         if (inst->isSquashed()) {
596             DPRINTF(Rename, "[tid:%u]: instruction %i with PC %s is "
597                     "squashed, skipping.\n", tid, inst->seqNum,
598                     inst->pcState());
599 
600             ++renameSquashedInsts;
601 
602             // Decrement how many instructions are available.
603             --insts_available;
604 
605             continue;
606         }
607 
608         DPRINTF(Rename, "[tid:%u]: Processing instruction [sn:%lli] with "
609                 "PC %s.\n", tid, inst->seqNum, inst->pcState());
610 
611         // Check here to make sure there are enough destination registers
612         // to rename to.  Otherwise block.
613         if (renameMap[tid]->numFreeEntries() < inst->numDestRegs()) {
614             DPRINTF(Rename, "Blocking due to lack of free "
615                     "physical registers to rename to.\n");
616             blockThisCycle = true;
617             insts_to_rename.push_front(inst);
618             ++renameFullRegistersEvents;
619 
620             break;
621         }
622 
623         // Handle serializeAfter/serializeBefore instructions.
624         // serializeAfter marks the next instruction as serializeBefore.
625         // serializeBefore makes the instruction wait in rename until the ROB
626         // is empty.
627 
628         // In this model, IPR accesses are serialize before
629         // instructions, and store conditionals are serialize after
630         // instructions.  This is mainly due to lack of support for
631         // out-of-order operations of either of those classes of
632         // instructions.
633         if ((inst->isIprAccess() || inst->isSerializeBefore()) &&
634             !inst->isSerializeHandled()) {
635             DPRINTF(Rename, "Serialize before instruction encountered.\n");
636 
637             if (!inst->isTempSerializeBefore()) {
638                 renamedSerializing++;
639                 inst->setSerializeHandled();
640             } else {
641                 renamedTempSerializing++;
642             }
643 
644             // Change status over to SerializeStall so that other stages know
645             // what this is blocked on.
646             renameStatus[tid] = SerializeStall;
647 
648             serializeInst[tid] = inst;
649 
650             blockThisCycle = true;
651 
652             break;
653         } else if ((inst->isStoreConditional() || inst->isSerializeAfter()) &&
654                    !inst->isSerializeHandled()) {
655             DPRINTF(Rename, "Serialize after instruction encountered.\n");
656 
657             renamedSerializing++;
658 
659             inst->setSerializeHandled();
660 
661             serializeAfter(insts_to_rename, tid);
662         }
663 
664         renameSrcRegs(inst, inst->threadNumber);
665 
666         renameDestRegs(inst, inst->threadNumber);
667 
668         ++renamed_insts;
669 
670 
671         // Put instruction in rename queue.
672         toIEW->insts[toIEWIndex] = inst;
673         ++(toIEW->size);
674 
675         // Increment which instruction we're on.
676         ++toIEWIndex;
677 
678         // Decrement how many instructions are available.
679         --insts_available;
680     }
681 
682     instsInProgress[tid] += renamed_insts;
683     renameRenamedInsts += renamed_insts;
684 
685     // If we wrote to the time buffer, record this.
686     if (toIEWIndex) {
687         wroteToTimeBuffer = true;
688     }
689 
690     // Check if there's any instructions left that haven't yet been renamed.
691     // If so then block.
692     if (insts_available) {
693         blockThisCycle = true;
694     }
695 
696     if (blockThisCycle) {
697         block(tid);
698         toDecode->renameUnblock[tid] = false;
699     }
700 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a8c18390fbeba66214f3854d7325a1d0e}{
\index{DefaultRename@{DefaultRename}!renameSrcRegs@{renameSrcRegs}}
\index{renameSrcRegs@{renameSrcRegs}!DefaultRename@{DefaultRename}}
\subsubsection[{renameSrcRegs}]{\setlength{\rightskip}{0pt plus 5cm}void renameSrcRegs ({\bf DynInstPtr} \& {\em inst}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_a8c18390fbeba66214f3854d7325a1d0e}
Renames the source registers of an instruction. 


\begin{DoxyCode}
957 {
958     ThreadContext *tc = inst->tcBase();
959     RenameMap *map = renameMap[tid];
960     unsigned num_src_regs = inst->numSrcRegs();
961 
962     // Get the architectual register numbers from the source and
963     // operands, and redirect them to the right physical register.
964     for (int src_idx = 0; src_idx < num_src_regs; src_idx++) {
965         RegIndex src_reg = inst->srcRegIdx(src_idx);
966         RegIndex rel_src_reg;
967         RegIndex flat_rel_src_reg;
968         PhysRegIndex renamed_reg;
969 
970         switch (regIdxToClass(src_reg, &rel_src_reg)) {
971           case IntRegClass:
972             flat_rel_src_reg = tc->flattenIntIndex(rel_src_reg);
973             renamed_reg = map->lookupInt(flat_rel_src_reg);
974             intRenameLookups++;
975             break;
976 
977           case FloatRegClass:
978             flat_rel_src_reg = tc->flattenFloatIndex(rel_src_reg);
979             renamed_reg = map->lookupFloat(flat_rel_src_reg);
980             fpRenameLookups++;
981             break;
982 
983           case CCRegClass:
984             flat_rel_src_reg = tc->flattenCCIndex(rel_src_reg);
985             renamed_reg = map->lookupCC(flat_rel_src_reg);
986             break;
987 
988           case MiscRegClass:
989             // misc regs don't get flattened
990             flat_rel_src_reg = rel_src_reg;
991             renamed_reg = map->lookupMisc(flat_rel_src_reg);
992             break;
993 
994           default:
995             panic("Reg index is out of bound: %d.", src_reg);
996         }
997 
998         DPRINTF(Rename, "[tid:%u]: Looking up %s arch reg %i (flattened %i), "
999                 "got phys reg %i\n", tid, RegClassStrings[regIdxToClass(src_reg)]
      ,
1000                 (int)src_reg, (int)flat_rel_src_reg, (int)renamed_reg);
1001 
1002         inst->renameSrcReg(src_idx, renamed_reg);
1003 
1004         // See if the register is ready or not.
1005         if (scoreboard->getReg(renamed_reg)) {
1006             DPRINTF(Rename, "[tid:%u]: Register %d is ready.\n",
1007                     tid, renamed_reg);
1008 
1009             inst->markSrcRegReady(src_idx);
1010         } else {
1011             DPRINTF(Rename, "[tid:%u]: Register %d is not ready.\n",
1012                     tid, renamed_reg);
1013         }
1014 
1015         ++renameRenameLookups;
1016     }
1017 }
\end{DoxyCode}
\hypertarget{classDefaultRename_ada2a699094bc420f977abf2a17ed14c8}{
\index{DefaultRename@{DefaultRename}!resetStage@{resetStage}}
\index{resetStage@{resetStage}!DefaultRename@{DefaultRename}}
\subsubsection[{resetStage}]{\setlength{\rightskip}{0pt plus 5cm}void resetStage ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_ada2a699094bc420f977abf2a17ed14c8}
Reset this pipeline stage 


\begin{DoxyCode}
229 {
230     _status = Inactive;
231 
232     resumeSerialize = false;
233     resumeUnblocking = false;
234 
235     // Grab the number of free entries directly from the stages.
236     for (ThreadID tid = 0; tid < numThreads; tid++) {
237         renameStatus[tid] = Idle;
238 
239         freeEntries[tid].iqEntries = iew_ptr->instQueue.numFreeEntries(tid);
240         freeEntries[tid].lsqEntries = iew_ptr->ldstQueue.numFreeEntries(tid);
241         freeEntries[tid].robEntries = commit_ptr->numROBFreeEntries(tid);
242         emptyROB[tid] = true;
243 
244         stalls[tid].iew = false;
245         stalls[tid].commit = false;
246         serializeInst[tid] = NULL;
247 
248         instsInProgress[tid] = 0;
249 
250         serializeOnNextInst[tid] = false;
251     }
252 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a4010b268c107b9aa7289a98f67171e08}{
\index{DefaultRename@{DefaultRename}!serializeAfter@{serializeAfter}}
\index{serializeAfter@{serializeAfter}!DefaultRename@{DefaultRename}}
\subsubsection[{serializeAfter}]{\setlength{\rightskip}{0pt plus 5cm}void serializeAfter ({\bf InstQueue} \& {\em inst\_\-list}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_a4010b268c107b9aa7289a98f67171e08}
Either serializes on the next instruction available in the \hyperlink{classInstQueue}{InstQueue}, or records that it must serialize on the next instruction to enter rename. 
\begin{DoxyParams}{引数}
\item[{\em inst\_\-list}]The list of younger, unprocessed instructions for the thread that has the serializeAfter instruction. \item[{\em tid}]The thread id. \end{DoxyParams}



\begin{DoxyCode}
1344 {
1345     if (inst_list.empty()) {
1346         // Mark a bit to say that I must serialize on the next instruction.
1347         serializeOnNextInst[tid] = true;
1348         return;
1349     }
1350 
1351     // Set the next instruction as serializing.
1352     inst_list.front()->setSerializeBefore();
1353 }
\end{DoxyCode}
\hypertarget{classDefaultRename_aab96bdacf8bd420402cbb543f994e054}{
\index{DefaultRename@{DefaultRename}!setActiveThreads@{setActiveThreads}}
\index{setActiveThreads@{setActiveThreads}!DefaultRename@{DefaultRename}}
\subsubsection[{setActiveThreads}]{\setlength{\rightskip}{0pt plus 5cm}void setActiveThreads ({\bf std::list}$<$ {\bf ThreadID} $>$ $\ast$ {\em at\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultRename_aab96bdacf8bd420402cbb543f994e054}
Sets pointer to list of active threads. 


\begin{DoxyCode}
257 {
258     activeThreads = at_ptr;
259 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a1e488bc36055daaf1f86a9b4e58118c2}{
\index{DefaultRename@{DefaultRename}!setCommitStage@{setCommitStage}}
\index{setCommitStage@{setCommitStage}!DefaultRename@{DefaultRename}}
\subsubsection[{setCommitStage}]{\setlength{\rightskip}{0pt plus 5cm}void setCommitStage ({\bf Commit} $\ast$ {\em commit\_\-stage})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultRename_a1e488bc36055daaf1f86a9b4e58118c2}
Sets pointer to commit stage. Used only for initialization. 


\begin{DoxyCode}
147     { commit_ptr = commit_stage; }
\end{DoxyCode}
\hypertarget{classDefaultRename_a21f95db13a2fc05d7a5fcc43fec1f1e7}{
\index{DefaultRename@{DefaultRename}!setDecodeQueue@{setDecodeQueue}}
\index{setDecodeQueue@{setDecodeQueue}!DefaultRename@{DefaultRename}}
\subsubsection[{setDecodeQueue}]{\setlength{\rightskip}{0pt plus 5cm}void setDecodeQueue ({\bf TimeBuffer}$<$ {\bf DecodeStruct} $>$ $\ast$ {\em dq\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultRename_a21f95db13a2fc05d7a5fcc43fec1f1e7}
Sets pointer to time buffer coming from decode. 


\begin{DoxyCode}
212 {
213     decodeQueue = dq_ptr;
214 
215     // Setup wire to get information from decode.
216     fromDecode = decodeQueue->getWire(-decodeToRenameDelay);
217 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a2d3550e87cb180105600dfaefcf83358}{
\index{DefaultRename@{DefaultRename}!setFreeList@{setFreeList}}
\index{setFreeList@{setFreeList}!DefaultRename@{DefaultRename}}
\subsubsection[{setFreeList}]{\setlength{\rightskip}{0pt plus 5cm}void setFreeList ({\bf FreeList} $\ast$ {\em fl\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultRename_a2d3550e87cb180105600dfaefcf83358}
Sets pointer to the free list. 


\begin{DoxyCode}
273 {
274     freeList = fl_ptr;
275 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a4b6d8e4b2cf6249763ed2fc73eb1af47}{
\index{DefaultRename@{DefaultRename}!setIEWStage@{setIEWStage}}
\index{setIEWStage@{setIEWStage}!DefaultRename@{DefaultRename}}
\subsubsection[{setIEWStage}]{\setlength{\rightskip}{0pt plus 5cm}void setIEWStage ({\bf IEW} $\ast$ {\em iew\_\-stage})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultRename_a4b6d8e4b2cf6249763ed2fc73eb1af47}
Sets pointer to IEW stage. Used only for initialization. 


\begin{DoxyCode}
143     { iew_ptr = iew_stage; }
\end{DoxyCode}
\hypertarget{classDefaultRename_a6f0aaedb2c39d674ef86c25d0aeb4211}{
\index{DefaultRename@{DefaultRename}!setRenameMap@{setRenameMap}}
\index{setRenameMap@{setRenameMap}!DefaultRename@{DefaultRename}}
\subsubsection[{setRenameMap}]{\setlength{\rightskip}{0pt plus 5cm}void setRenameMap ({\bf RenameMap} {\em rm\_\-ptr}\mbox{[}Impl::MaxThreads\mbox{]})}}
\label{classDefaultRename_a6f0aaedb2c39d674ef86c25d0aeb4211}
Sets pointer to rename maps (per-\/thread structures). \hypertarget{classDefaultRename_a701624f92a819fe4205faede6e614d9f}{
\index{DefaultRename@{DefaultRename}!setRenameQueue@{setRenameQueue}}
\index{setRenameQueue@{setRenameQueue}!DefaultRename@{DefaultRename}}
\subsubsection[{setRenameQueue}]{\setlength{\rightskip}{0pt plus 5cm}void setRenameQueue ({\bf TimeBuffer}$<$ {\bf RenameStruct} $>$ $\ast$ {\em rq\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultRename_a701624f92a819fe4205faede6e614d9f}
Sets pointer to time buffer used to communicate to the next stage. 


\begin{DoxyCode}
202 {
203     renameQueue = rq_ptr;
204 
205     // Setup wire to write information to future stages.
206     toIEW = renameQueue->getWire(0);
207 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a0b50ac63f22501d5c688294031615b6e}{
\index{DefaultRename@{DefaultRename}!setScoreboard@{setScoreboard}}
\index{setScoreboard@{setScoreboard}!DefaultRename@{DefaultRename}}
\subsubsection[{setScoreboard}]{\setlength{\rightskip}{0pt plus 5cm}void setScoreboard ({\bf Scoreboard} $\ast$ {\em \_\-scoreboard})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultRename_a0b50ac63f22501d5c688294031615b6e}
Sets pointer to the scoreboard. 


\begin{DoxyCode}
280 {
281     scoreboard = _scoreboard;
282 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a2b521ea5f191fff72265f60d4ed5187b}{
\index{DefaultRename@{DefaultRename}!setTimeBuffer@{setTimeBuffer}}
\index{setTimeBuffer@{setTimeBuffer}!DefaultRename@{DefaultRename}}
\subsubsection[{setTimeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}void setTimeBuffer ({\bf TimeBuffer}$<$ {\bf TimeStruct} $>$ $\ast$ {\em tb\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultRename_a2b521ea5f191fff72265f60d4ed5187b}
Sets the main backwards communication time buffer pointer. 


\begin{DoxyCode}
186 {
187     timeBuffer = tb_ptr;
188 
189     // Setup wire to read information from time buffer, from IEW stage.
190     fromIEW = timeBuffer->getWire(-iewToRenameDelay);
191 
192     // Setup wire to read infromation from time buffer, from commit stage.
193     fromCommit = timeBuffer->getWire(-commitToRenameDelay);
194 
195     // Setup wire to write information to previous stages.
196     toDecode = timeBuffer->getWire(0);
197 }
\end{DoxyCode}
\hypertarget{classDefaultRename_ac24515147270ef9b85991bbe13bd47af}{
\index{DefaultRename@{DefaultRename}!skidInsert@{skidInsert}}
\index{skidInsert@{skidInsert}!DefaultRename@{DefaultRename}}
\subsubsection[{skidInsert}]{\setlength{\rightskip}{0pt plus 5cm}void skidInsert ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_ac24515147270ef9b85991bbe13bd47af}
Inserts unused instructions from a given thread into the skid buffer, to be renamed once rename unblocks. 


\begin{DoxyCode}
705 {
706     DynInstPtr inst = NULL;
707 
708     while (!insts[tid].empty()) {
709         inst = insts[tid].front();
710 
711         insts[tid].pop_front();
712 
713         assert(tid == inst->threadNumber);
714 
715         DPRINTF(Rename, "[tid:%u]: Inserting [sn:%lli] PC: %s into Rename "
716                 "skidBuffer\n", tid, inst->seqNum, inst->pcState());
717 
718         ++renameSkidInsts;
719 
720         skidBuffer[tid].push_back(inst);
721     }
722 
723     if (skidBuffer[tid].size() > skidBufferMax)
724     {
725         typename InstQueue::iterator it;
726         warn("Skidbuffer contents:\n");
727         for(it = skidBuffer[tid].begin(); it != skidBuffer[tid].end(); it++)
728         {
729             warn("[tid:%u]: %s [sn:%i].\n", tid,
730                     (*it)->staticInst->disassemble(inst->instAddr()),
731                     (*it)->seqNum);
732         }
733         panic("Skidbuffer Exceeded Max Size");
734     }
735 }
\end{DoxyCode}
\hypertarget{classDefaultRename_afe3e2673d17dd5c568862ef5ae68b4d8}{
\index{DefaultRename@{DefaultRename}!skidsEmpty@{skidsEmpty}}
\index{skidsEmpty@{skidsEmpty}!DefaultRename@{DefaultRename}}
\subsubsection[{skidsEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool skidsEmpty ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_afe3e2673d17dd5c568862ef5ae68b4d8}
Returns if all of the skid buffers are empty. 


\begin{DoxyCode}
756 {
757     list<ThreadID>::iterator threads = activeThreads->begin();
758     list<ThreadID>::iterator end = activeThreads->end();
759 
760     while (threads != end) {
761         ThreadID tid = *threads++;
762 
763         if (!skidBuffer[tid].empty())
764             return false;
765     }
766 
767     return true;
768 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a9ff2aa32ab0f40674cb3518108d62f8e}{
\index{DefaultRename@{DefaultRename}!sortInsts@{sortInsts}}
\index{sortInsts@{sortInsts}!DefaultRename@{DefaultRename}}
\subsubsection[{sortInsts}]{\setlength{\rightskip}{0pt plus 5cm}void sortInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_a9ff2aa32ab0f40674cb3518108d62f8e}
Separates instructions from decode into individual lists of instructions sorted by thread. 


\begin{DoxyCode}
740 {
741     int insts_from_decode = fromDecode->size;
742     for (int i = 0; i < insts_from_decode; ++i) {
743         DynInstPtr inst = fromDecode->insts[i];
744         insts[inst->threadNumber].push_back(inst);
745 #if TRACING_ON
746         if (DTRACE(O3PipeView)) {
747             inst->renameTick = curTick() - inst->fetchTick;
748         }
749 #endif
750     }
751 }
\end{DoxyCode}
\hypertarget{classDefaultRename_aa896d7ff2c9da1e6e96d46ab4580ec9d}{
\index{DefaultRename@{DefaultRename}!squash@{squash}}
\index{squash@{squash}!DefaultRename@{DefaultRename}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash (const {\bf InstSeqNum} \& {\em squash\_\-seq\_\-num}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultRename_aa896d7ff2c9da1e6e96d46ab4580ec9d}
Squashes all instructions in a thread. 


\begin{DoxyCode}
320 {
321     DPRINTF(Rename, "[tid:%u]: Squashing instructions.\n",tid);
322 
323     // Clear the stall signal if rename was blocked or unblocking before.
324     // If it still needs to block, the blocking should happen the next
325     // cycle and there should be space to hold everything due to the squash.
326     if (renameStatus[tid] == Blocked ||
327         renameStatus[tid] == Unblocking) {
328         toDecode->renameUnblock[tid] = 1;
329 
330         resumeSerialize = false;
331         serializeInst[tid] = NULL;
332     } else if (renameStatus[tid] == SerializeStall) {
333         if (serializeInst[tid]->seqNum <= squash_seq_num) {
334             DPRINTF(Rename, "Rename will resume serializing after squash\n");
335             resumeSerialize = true;
336             assert(serializeInst[tid]);
337         } else {
338             resumeSerialize = false;
339             toDecode->renameUnblock[tid] = 1;
340 
341             serializeInst[tid] = NULL;
342         }
343     }
344 
345     // Set the status to Squashing.
346     renameStatus[tid] = Squashing;
347 
348     // Squash any instructions from decode.
349     for (int i=0; i<fromDecode->size; i++) {
350         if (fromDecode->insts[i]->threadNumber == tid &&
351             fromDecode->insts[i]->seqNum > squash_seq_num) {
352             fromDecode->insts[i]->setSquashed();
353             wroteToTimeBuffer = true;
354         }
355 
356     }
357 
358     // Clear the instruction list and skid buffer in case they have any
359     // insts in them.
360     insts[tid].clear();
361 
362     // Clear the skid buffer in case it has any data in it.
363     skidBuffer[tid].clear();
364 
365     doSquash(squash_seq_num, tid);
366 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a31d4cbdab16d4ff8d6bc7f84ece727da}{
\index{DefaultRename@{DefaultRename}!startupStage@{startupStage}}
\index{startupStage@{startupStage}!DefaultRename@{DefaultRename}}
\subsubsection[{startupStage}]{\setlength{\rightskip}{0pt plus 5cm}void startupStage ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultRename_a31d4cbdab16d4ff8d6bc7f84ece727da}
Initializes variables for the stage. 


\begin{DoxyCode}
222 {
223     resetStage();
224 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a8674059ce345e23aac5086b2c3e24a43}{
\index{DefaultRename@{DefaultRename}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!DefaultRename@{DefaultRename}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultRename_a8674059ce345e23aac5086b2c3e24a43}
Takes over from another CPU's thread. 


\begin{DoxyCode}
301 {
302     resetStage();
303 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a873dd91783f9efb4a590aded1f70d6b0}{
\index{DefaultRename@{DefaultRename}!tick@{tick}}
\index{tick@{tick}!DefaultRename@{DefaultRename}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultRename_a873dd91783f9efb4a590aded1f70d6b0}
Ticks rename, which processes all input signals and attempts to rename as many instructions as possible. 


\begin{DoxyCode}
371 {
372     wroteToTimeBuffer = false;
373 
374     blockThisCycle = false;
375 
376     bool status_change = false;
377 
378     toIEWIndex = 0;
379 
380     sortInsts();
381 
382     list<ThreadID>::iterator threads = activeThreads->begin();
383     list<ThreadID>::iterator end = activeThreads->end();
384 
385     // Check stall and squash signals.
386     while (threads != end) {
387         ThreadID tid = *threads++;
388 
389         DPRINTF(Rename, "Processing [tid:%i]\n", tid);
390 
391         status_change = checkSignalsAndUpdate(tid) || status_change;
392 
393         rename(status_change, tid);
394     }
395 
396     if (status_change) {
397         updateStatus();
398     }
399 
400     if (wroteToTimeBuffer) {
401         DPRINTF(Activity, "Activity this cycle.\n");
402         cpu->activityThisCycle();
403     }
404 
405     threads = activeThreads->begin();
406 
407     while (threads != end) {
408         ThreadID tid = *threads++;
409 
410         // If we committed this cycle then doneSeqNum will be > 0
411         if (fromCommit->commitInfo[tid].doneSeqNum != 0 &&
412             !fromCommit->commitInfo[tid].squash &&
413             renameStatus[tid] != Squashing) {
414 
415             removeFromHistory(fromCommit->commitInfo[tid].doneSeqNum,
416                                   tid);
417         }
418     }
419 
420     // @todo: make into updateProgress function
421     for (ThreadID tid = 0; tid < numThreads; tid++) {
422         instsInProgress[tid] -= fromIEW->iewInfo[tid].dispatched;
423 
424         assert(instsInProgress[tid] >=0);
425     }
426 
427 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a9cc3b95f6969935f78c0158aa5145021}{
\index{DefaultRename@{DefaultRename}!unblock@{unblock}}
\index{unblock@{unblock}!DefaultRename@{DefaultRename}}
\subsubsection[{unblock}]{\setlength{\rightskip}{0pt plus 5cm}bool unblock ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_a9cc3b95f6969935f78c0158aa5145021}
Switches rename to unblocking if the skid buffer is empty, and signals back that rename has unblocked. \begin{DoxyReturn}{戻り値}
Returns true if there is a status change. 
\end{DoxyReturn}



\begin{DoxyCode}
846 {
847     DPRINTF(Rename, "[tid:%u]: Trying to unblock.\n", tid);
848 
849     // Rename is done unblocking if the skid buffer is empty.
850     if (skidBuffer[tid].empty() && renameStatus[tid] != SerializeStall) {
851 
852         DPRINTF(Rename, "[tid:%u]: Done unblocking.\n", tid);
853 
854         toDecode->renameUnblock[tid] = true;
855         wroteToTimeBuffer = true;
856 
857         renameStatus[tid] = Running;
858         return true;
859     }
860 
861     return false;
862 }
\end{DoxyCode}
\hypertarget{classDefaultRename_a4bb9486757ce225941aaaf759b357a57}{
\index{DefaultRename@{DefaultRename}!updateStatus@{updateStatus}}
\index{updateStatus@{updateStatus}!DefaultRename@{DefaultRename}}
\subsubsection[{updateStatus}]{\setlength{\rightskip}{0pt plus 5cm}void updateStatus ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_a4bb9486757ce225941aaaf759b357a57}
Updates overall rename status based on all of the threads' statuses. 


\begin{DoxyCode}
773 {
774     bool any_unblocking = false;
775 
776     list<ThreadID>::iterator threads = activeThreads->begin();
777     list<ThreadID>::iterator end = activeThreads->end();
778 
779     while (threads != end) {
780         ThreadID tid = *threads++;
781 
782         if (renameStatus[tid] == Unblocking) {
783             any_unblocking = true;
784             break;
785         }
786     }
787 
788     // Rename will have activity if it's unblocking.
789     if (any_unblocking) {
790         if (_status == Inactive) {
791             _status = Active;
792 
793             DPRINTF(Activity, "Activating stage.\n");
794 
795             cpu->activateStage(O3CPU::RenameIdx);
796         }
797     } else {
798         // If it's not unblocking, then rename will not have any internal
799         // activity.  Switch it to inactive.
800         if (_status == Active) {
801             _status = Inactive;
802             DPRINTF(Activity, "Deactivating stage.\n");
803 
804             cpu->deactivateStage(O3CPU::RenameIdx);
805         }
806     }
807 }
\end{DoxyCode}
\hypertarget{classDefaultRename_ad533c56329b83d5b1aef92d0a6594b2c}{
\index{DefaultRename@{DefaultRename}!validInsts@{validInsts}}
\index{validInsts@{validInsts}!DefaultRename@{DefaultRename}}
\subsubsection[{validInsts}]{\setlength{\rightskip}{0pt plus 5cm}unsigned validInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultRename_ad533c56329b83d5b1aef92d0a6594b2c}
Returns the number of valid instructions coming from decode. 


\begin{DoxyCode}
1138 {
1139     unsigned inst_count = 0;
1140 
1141     for (int i=0; i<fromDecode->size; i++) {
1142         if (!fromDecode->insts[i]->isSquashed())
1143             inst_count++;
1144     }
1145 
1146     return inst_count;
1147 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classDefaultRename_a1564313ed7a74659481a1b5ea2bacf88}{
\index{DefaultRename@{DefaultRename}!\_\-status@{\_\-status}}
\index{\_\-status@{\_\-status}!DefaultRename@{DefaultRename}}
\subsubsection[{\_\-status}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RenameStatus} {\bf \_\-status}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a1564313ed7a74659481a1b5ea2bacf88}
Rename status. \hypertarget{classDefaultRename_af6eaea53db532812052f71bf0380dab5}{
\index{DefaultRename@{DefaultRename}!activeThreads@{activeThreads}}
\index{activeThreads@{activeThreads}!DefaultRename@{DefaultRename}}
\subsubsection[{activeThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf ThreadID}$>$$\ast$ {\bf activeThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_af6eaea53db532812052f71bf0380dab5}
Pointer to the list of active threads. \hypertarget{classDefaultRename_a5a5235d747599dbd49a887663f3739e8}{
\index{DefaultRename@{DefaultRename}!blockThisCycle@{blockThisCycle}}
\index{blockThisCycle@{blockThisCycle}!DefaultRename@{DefaultRename}}
\subsubsection[{blockThisCycle}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf blockThisCycle}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a5a5235d747599dbd49a887663f3739e8}
Whether or not rename needs to block this cycle. \hypertarget{classDefaultRename_a51b23beeb9e078c0c11831d0f2e56bfd}{
\index{DefaultRename@{DefaultRename}!commit\_\-ptr@{commit\_\-ptr}}
\index{commit\_\-ptr@{commit\_\-ptr}!DefaultRename@{DefaultRename}}
\subsubsection[{commit\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Commit}$\ast$ {\bf commit\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a51b23beeb9e078c0c11831d0f2e56bfd}
Pointer to commit stage. Used only for initialization. \hypertarget{classDefaultRename_a03ebbedbf40ac0005574e50b3577a651}{
\index{DefaultRename@{DefaultRename}!commitToRenameDelay@{commitToRenameDelay}}
\index{commitToRenameDelay@{commitToRenameDelay}!DefaultRename@{DefaultRename}}
\subsubsection[{commitToRenameDelay}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf commitToRenameDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a03ebbedbf40ac0005574e50b3577a651}
Delay between commit and rename, in ticks. \hypertarget{classDefaultRename_aeab15260a0ccc0ea470bb74344b63d17}{
\index{DefaultRename@{DefaultRename}!commitWidth@{commitWidth}}
\index{commitWidth@{commitWidth}!DefaultRename@{DefaultRename}}
\subsubsection[{commitWidth}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf commitWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_aeab15260a0ccc0ea470bb74344b63d17}
Commit width, in instructions. Used so rename knows how many instructions might have freed registers in the previous cycle. \hypertarget{classDefaultRename_a1379cf882a12ac6fc9eba5da7c84b18b}{
\index{DefaultRename@{DefaultRename}!cpu@{cpu}}
\index{cpu@{cpu}!DefaultRename@{DefaultRename}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf O3CPU}$\ast$ {\bf cpu}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a1379cf882a12ac6fc9eba5da7c84b18b}
Pointer to CPU. \hypertarget{classDefaultRename_a7860fc5736574343c9e294cb2bef9d93}{
\index{DefaultRename@{DefaultRename}!decodeQueue@{decodeQueue}}
\index{decodeQueue@{decodeQueue}!DefaultRename@{DefaultRename}}
\subsubsection[{decodeQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf DecodeStruct}$>$$\ast$ {\bf decodeQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a7860fc5736574343c9e294cb2bef9d93}
Decode instruction queue interface. \hypertarget{classDefaultRename_a4ff2f51d1e391f739d6d1c73a6bcd0c1}{
\index{DefaultRename@{DefaultRename}!decodeToRenameDelay@{decodeToRenameDelay}}
\index{decodeToRenameDelay@{decodeToRenameDelay}!DefaultRename@{DefaultRename}}
\subsubsection[{decodeToRenameDelay}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf decodeToRenameDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a4ff2f51d1e391f739d6d1c73a6bcd0c1}
Delay between decode and rename, in ticks. \hypertarget{classDefaultRename_a5a3345554ca63a6e859943d7174d714f}{
\index{DefaultRename@{DefaultRename}!emptyROB@{emptyROB}}
\index{emptyROB@{emptyROB}!DefaultRename@{DefaultRename}}
\subsubsection[{emptyROB}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf emptyROB}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a5a3345554ca63a6e859943d7174d714f}
Records if the \hyperlink{classROB}{ROB} is empty. In SMT mode the \hyperlink{classROB}{ROB} may be dynamically partitioned between threads, so the \hyperlink{classROB}{ROB} must tell rename when it is empty. \hypertarget{classDefaultRename_ad27b51042b9dc458c5dd63b8c5f8d467}{
\index{DefaultRename@{DefaultRename}!fpRenameLookups@{fpRenameLookups}}
\index{fpRenameLookups@{fpRenameLookups}!DefaultRename@{DefaultRename}}
\subsubsection[{fpRenameLookups}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fpRenameLookups}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_ad27b51042b9dc458c5dd63b8c5f8d467}
\hypertarget{classDefaultRename_a20d0243bc02977001bfbd4834a7d8b5d}{
\index{DefaultRename@{DefaultRename}!freeEntries@{freeEntries}}
\index{freeEntries@{freeEntries}!DefaultRename@{DefaultRename}}
\subsubsection[{freeEntries}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FreeEntries} {\bf freeEntries}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a20d0243bc02977001bfbd4834a7d8b5d}
Per-\/thread tracking of the number of free entries of back-\/end structures. \hypertarget{classDefaultRename_a2e829c52dbc56e7ac6d2fc6a0524ff9c}{
\index{DefaultRename@{DefaultRename}!freeList@{freeList}}
\index{freeList@{freeList}!DefaultRename@{DefaultRename}}
\subsubsection[{freeList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FreeList}$\ast$ {\bf freeList}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a2e829c52dbc56e7ac6d2fc6a0524ff9c}
Free list interface. \hypertarget{classDefaultRename_a0055a92bd94eda21c2641d46ff013dac}{
\index{DefaultRename@{DefaultRename}!fromCommit@{fromCommit}}
\index{fromCommit@{fromCommit}!DefaultRename@{DefaultRename}}
\subsubsection[{fromCommit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf fromCommit}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a0055a92bd94eda21c2641d46ff013dac}
\hyperlink{classWire}{Wire} to get commit's output from backwards time buffer. \hypertarget{classDefaultRename_a8bf861a7b2c3731d3a69bf370564e975}{
\index{DefaultRename@{DefaultRename}!fromDecode@{fromDecode}}
\index{fromDecode@{fromDecode}!DefaultRename@{DefaultRename}}
\subsubsection[{fromDecode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf DecodeStruct}$>$::wire {\bf fromDecode}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a8bf861a7b2c3731d3a69bf370564e975}
\hyperlink{classWire}{Wire} to get decode's output from decode queue. \hypertarget{classDefaultRename_a6c9093e88770a58dc8853f49a09bbac8}{
\index{DefaultRename@{DefaultRename}!fromIEW@{fromIEW}}
\index{fromIEW@{fromIEW}!DefaultRename@{DefaultRename}}
\subsubsection[{fromIEW}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf fromIEW}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a6c9093e88770a58dc8853f49a09bbac8}
\hyperlink{classWire}{Wire} to get IEW's output from backwards time buffer. \hypertarget{classDefaultRename_adc01dc05e6459841df629cb3353ddde9}{
\index{DefaultRename@{DefaultRename}!historyBuffer@{historyBuffer}}
\index{historyBuffer@{historyBuffer}!DefaultRename@{DefaultRename}}
\subsubsection[{historyBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf RenameHistory}$>$ {\bf historyBuffer}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_adc01dc05e6459841df629cb3353ddde9}
A per-\/thread list of all destination register renames, used to either undo rename mappings or free old physical registers. \hypertarget{classDefaultRename_abf7286da8e826739b29fa67855f4216b}{
\index{DefaultRename@{DefaultRename}!iew\_\-ptr@{iew\_\-ptr}}
\index{iew\_\-ptr@{iew\_\-ptr}!DefaultRename@{DefaultRename}}
\subsubsection[{iew\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IEW}$\ast$ {\bf iew\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_abf7286da8e826739b29fa67855f4216b}
Pointer to IEW stage. Used only for initialization. \hypertarget{classDefaultRename_a3069f8fd673d0e9ea2b1a8ce0ad3fe06}{
\index{DefaultRename@{DefaultRename}!iewToRenameDelay@{iewToRenameDelay}}
\index{iewToRenameDelay@{iewToRenameDelay}!DefaultRename@{DefaultRename}}
\subsubsection[{iewToRenameDelay}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf iewToRenameDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a3069f8fd673d0e9ea2b1a8ce0ad3fe06}
Delay between iew and rename, in ticks. \hypertarget{classDefaultRename_a4b6cd9f78efe8b5101b48dbf35a43c11}{
\index{DefaultRename@{DefaultRename}!insts@{insts}}
\index{insts@{insts}!DefaultRename@{DefaultRename}}
\subsubsection[{insts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstQueue} {\bf insts}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a4b6cd9f78efe8b5101b48dbf35a43c11}
Queue of all instructions coming from decode this cycle. \hypertarget{classDefaultRename_af301c62fee41266f36b1318688c8aa55}{
\index{DefaultRename@{DefaultRename}!instsInProgress@{instsInProgress}}
\index{instsInProgress@{instsInProgress}!DefaultRename@{DefaultRename}}
\subsubsection[{instsInProgress}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf instsInProgress}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_af301c62fee41266f36b1318688c8aa55}
Count of instructions in progress that have been sent off to the IQ and \hyperlink{classROB}{ROB}, but are not yet included in their occupancy counts. \hypertarget{classDefaultRename_ae2548cb038c1868f0dcf4c5df1154b12}{
\index{DefaultRename@{DefaultRename}!intRenameLookups@{intRenameLookups}}
\index{intRenameLookups@{intRenameLookups}!DefaultRename@{DefaultRename}}
\subsubsection[{intRenameLookups}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf intRenameLookups}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_ae2548cb038c1868f0dcf4c5df1154b12}
\hypertarget{classDefaultRename_acc18d044ab2bf32e6515938485638d28}{
\index{DefaultRename@{DefaultRename}!maxPhysicalRegs@{maxPhysicalRegs}}
\index{maxPhysicalRegs@{maxPhysicalRegs}!DefaultRename@{DefaultRename}}
\subsubsection[{maxPhysicalRegs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PhysRegIndex} {\bf maxPhysicalRegs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_acc18d044ab2bf32e6515938485638d28}
\hypertarget{classDefaultRename_a88377f855dbf5adeeecb06b5bb821d35}{
\index{DefaultRename@{DefaultRename}!numThreads@{numThreads}}
\index{numThreads@{numThreads}!DefaultRename@{DefaultRename}}
\subsubsection[{numThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} {\bf numThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a88377f855dbf5adeeecb06b5bb821d35}
The number of threads active in rename. \hypertarget{classDefaultRename_a45732215f002b5052d042ef5798735f0}{
\index{DefaultRename@{DefaultRename}!renameBlockCycles@{renameBlockCycles}}
\index{renameBlockCycles@{renameBlockCycles}!DefaultRename@{DefaultRename}}
\subsubsection[{renameBlockCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renameBlockCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a45732215f002b5052d042ef5798735f0}
Stat for total number of cycles spent blocking. \hypertarget{classDefaultRename_a5d4c3559dbd988f18cc6d1c0e0470fcb}{
\index{DefaultRename@{DefaultRename}!renameCommittedMaps@{renameCommittedMaps}}
\index{renameCommittedMaps@{renameCommittedMaps}!DefaultRename@{DefaultRename}}
\subsubsection[{renameCommittedMaps}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renameCommittedMaps}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a5d4c3559dbd988f18cc6d1c0e0470fcb}
Stat for total number of committed renaming mappings. \hypertarget{classDefaultRename_a6e383a41c8a2b8902dd659805c40621e}{
\index{DefaultRename@{DefaultRename}!renamedSerializing@{renamedSerializing}}
\index{renamedSerializing@{renamedSerializing}!DefaultRename@{DefaultRename}}
\subsubsection[{renamedSerializing}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renamedSerializing}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a6e383a41c8a2b8902dd659805c40621e}
Number of serialize instructions handled. \hypertarget{classDefaultRename_a94f16020be7d9c91aa978ce88f0adb1b}{
\index{DefaultRename@{DefaultRename}!renamedTempSerializing@{renamedTempSerializing}}
\index{renamedTempSerializing@{renamedTempSerializing}!DefaultRename@{DefaultRename}}
\subsubsection[{renamedTempSerializing}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renamedTempSerializing}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a94f16020be7d9c91aa978ce88f0adb1b}
Number of instructions marked as temporarily serializing. \hypertarget{classDefaultRename_ac012d0908acb20c3f68593787f626711}{
\index{DefaultRename@{DefaultRename}!renameFullRegistersEvents@{renameFullRegistersEvents}}
\index{renameFullRegistersEvents@{renameFullRegistersEvents}!DefaultRename@{DefaultRename}}
\subsubsection[{renameFullRegistersEvents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renameFullRegistersEvents}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_ac012d0908acb20c3f68593787f626711}
Stat for total number of times that rename runs out of free registers to use to rename. \hypertarget{classDefaultRename_a53baed8fe49369b373c3dd986c683596}{
\index{DefaultRename@{DefaultRename}!renameIdleCycles@{renameIdleCycles}}
\index{renameIdleCycles@{renameIdleCycles}!DefaultRename@{DefaultRename}}
\subsubsection[{renameIdleCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renameIdleCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a53baed8fe49369b373c3dd986c683596}
Stat for total number of cycles spent idle. \hypertarget{classDefaultRename_a9a4bab1aece13e48ae2d2a3f247b3354}{
\index{DefaultRename@{DefaultRename}!renameIQFullEvents@{renameIQFullEvents}}
\index{renameIQFullEvents@{renameIQFullEvents}!DefaultRename@{DefaultRename}}
\subsubsection[{renameIQFullEvents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renameIQFullEvents}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a9a4bab1aece13e48ae2d2a3f247b3354}
Stat for total number of times that the IQ starts a stall in rename. \hypertarget{classDefaultRename_aba431e021496d1070a1d8f9ad7ec71f2}{
\index{DefaultRename@{DefaultRename}!renameLSQFullEvents@{renameLSQFullEvents}}
\index{renameLSQFullEvents@{renameLSQFullEvents}!DefaultRename@{DefaultRename}}
\subsubsection[{renameLSQFullEvents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renameLSQFullEvents}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_aba431e021496d1070a1d8f9ad7ec71f2}
Stat for total number of times that the \hyperlink{classLSQ}{LSQ} starts a stall in rename. \hypertarget{classDefaultRename_ac305c101c17d28451cc1f023b187b08b}{
\index{DefaultRename@{DefaultRename}!renameMap@{renameMap}}
\index{renameMap@{renameMap}!DefaultRename@{DefaultRename}}
\subsubsection[{renameMap}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RenameMap}$\ast$ {\bf renameMap}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_ac305c101c17d28451cc1f023b187b08b}
Rename map interface. \hypertarget{classDefaultRename_ae9b536282159ba75153a223be77515ba}{
\index{DefaultRename@{DefaultRename}!renameQueue@{renameQueue}}
\index{renameQueue@{renameQueue}!DefaultRename@{DefaultRename}}
\subsubsection[{renameQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf RenameStruct}$>$$\ast$ {\bf renameQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_ae9b536282159ba75153a223be77515ba}
Rename instruction queue. \hypertarget{classDefaultRename_aee6bb4587ea6f254fc29dda4d565afc9}{
\index{DefaultRename@{DefaultRename}!renameRenamedInsts@{renameRenamedInsts}}
\index{renameRenamedInsts@{renameRenamedInsts}!DefaultRename@{DefaultRename}}
\subsubsection[{renameRenamedInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renameRenamedInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_aee6bb4587ea6f254fc29dda4d565afc9}
Stat for total number of renamed instructions. \hypertarget{classDefaultRename_a3e2c435288350f7d805557b4d1a2b7a5}{
\index{DefaultRename@{DefaultRename}!renameRenamedOperands@{renameRenamedOperands}}
\index{renameRenamedOperands@{renameRenamedOperands}!DefaultRename@{DefaultRename}}
\subsubsection[{renameRenamedOperands}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renameRenamedOperands}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a3e2c435288350f7d805557b4d1a2b7a5}
Stat for total number of renamed destination registers. \hypertarget{classDefaultRename_ab0b7632e67fcf2fe1e6bb1cef111eda4}{
\index{DefaultRename@{DefaultRename}!renameRenameLookups@{renameRenameLookups}}
\index{renameRenameLookups@{renameRenameLookups}!DefaultRename@{DefaultRename}}
\subsubsection[{renameRenameLookups}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renameRenameLookups}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_ab0b7632e67fcf2fe1e6bb1cef111eda4}
Stat for total number of source register rename lookups. \hypertarget{classDefaultRename_a41408b25638b2531bc9e3b6ee622d148}{
\index{DefaultRename@{DefaultRename}!renameROBFullEvents@{renameROBFullEvents}}
\index{renameROBFullEvents@{renameROBFullEvents}!DefaultRename@{DefaultRename}}
\subsubsection[{renameROBFullEvents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renameROBFullEvents}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a41408b25638b2531bc9e3b6ee622d148}
Stat for total number of times that the \hyperlink{classROB}{ROB} starts a stall in rename. \hypertarget{classDefaultRename_a7dd03c8b7a88da84ff7e1bdd6b938d47}{
\index{DefaultRename@{DefaultRename}!renameRunCycles@{renameRunCycles}}
\index{renameRunCycles@{renameRunCycles}!DefaultRename@{DefaultRename}}
\subsubsection[{renameRunCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renameRunCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a7dd03c8b7a88da84ff7e1bdd6b938d47}
Stat for total number of cycles spent running normally. \hypertarget{classDefaultRename_a712d72379bc583c374e2f6179e8ee58f}{
\index{DefaultRename@{DefaultRename}!renameSerializeStallCycles@{renameSerializeStallCycles}}
\index{renameSerializeStallCycles@{renameSerializeStallCycles}!DefaultRename@{DefaultRename}}
\subsubsection[{renameSerializeStallCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renameSerializeStallCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a712d72379bc583c374e2f6179e8ee58f}
Stat for total number of cycles spent stalling for a serializing inst. \hypertarget{classDefaultRename_a50c910ed2a23d1bbb3e7861c2d1f33f4}{
\index{DefaultRename@{DefaultRename}!renameSkidInsts@{renameSkidInsts}}
\index{renameSkidInsts@{renameSkidInsts}!DefaultRename@{DefaultRename}}
\subsubsection[{renameSkidInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renameSkidInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a50c910ed2a23d1bbb3e7861c2d1f33f4}
Number of instructions inserted into skid buffers. \hypertarget{classDefaultRename_a8931e7bb259c1fe875fd5a88017b29e2}{
\index{DefaultRename@{DefaultRename}!renameSquashCycles@{renameSquashCycles}}
\index{renameSquashCycles@{renameSquashCycles}!DefaultRename@{DefaultRename}}
\subsubsection[{renameSquashCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renameSquashCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a8931e7bb259c1fe875fd5a88017b29e2}
Stat for total number of cycles spent squashing. \hypertarget{classDefaultRename_ae988aa97bbfa339fc6e6bf0cbad90832}{
\index{DefaultRename@{DefaultRename}!renameSquashedInsts@{renameSquashedInsts}}
\index{renameSquashedInsts@{renameSquashedInsts}!DefaultRename@{DefaultRename}}
\subsubsection[{renameSquashedInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renameSquashedInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_ae988aa97bbfa339fc6e6bf0cbad90832}
Stat for total number of squashed instructions that rename discards. \hypertarget{classDefaultRename_a8c157bf422205d3cdd7e7c75c2592b6f}{
\index{DefaultRename@{DefaultRename}!renameStatus@{renameStatus}}
\index{renameStatus@{renameStatus}!DefaultRename@{DefaultRename}}
\subsubsection[{renameStatus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadStatus} {\bf renameStatus}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a8c157bf422205d3cdd7e7c75c2592b6f}
Per-\/thread status. \hypertarget{classDefaultRename_a2f14c493f619ee24a84fbe959ed72a97}{
\index{DefaultRename@{DefaultRename}!renameUnblockCycles@{renameUnblockCycles}}
\index{renameUnblockCycles@{renameUnblockCycles}!DefaultRename@{DefaultRename}}
\subsubsection[{renameUnblockCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renameUnblockCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a2f14c493f619ee24a84fbe959ed72a97}
Stat for total number of cycles spent unblocking. \hypertarget{classDefaultRename_ae0c8395975c577671916d55df6e05b16}{
\index{DefaultRename@{DefaultRename}!renameUndoneMaps@{renameUndoneMaps}}
\index{renameUndoneMaps@{renameUndoneMaps}!DefaultRename@{DefaultRename}}
\subsubsection[{renameUndoneMaps}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf renameUndoneMaps}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_ae0c8395975c577671916d55df6e05b16}
Stat for total number of mappings that were undone due to a squash. \hypertarget{classDefaultRename_a4b41704382bddb6ee06b5ce97b47dd7b}{
\index{DefaultRename@{DefaultRename}!renameWidth@{renameWidth}}
\index{renameWidth@{renameWidth}!DefaultRename@{DefaultRename}}
\subsubsection[{renameWidth}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf renameWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a4b41704382bddb6ee06b5ce97b47dd7b}
Rename width, in instructions. \hypertarget{classDefaultRename_afa9ffeefc4b3ff8ae1ea9919bedbd1e4}{
\index{DefaultRename@{DefaultRename}!resumeSerialize@{resumeSerialize}}
\index{resumeSerialize@{resumeSerialize}!DefaultRename@{DefaultRename}}
\subsubsection[{resumeSerialize}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf resumeSerialize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_afa9ffeefc4b3ff8ae1ea9919bedbd1e4}
Whether or not rename needs to resume a serialize instruction after squashing. \hypertarget{classDefaultRename_aacc2e9a4766def499954195037465d42}{
\index{DefaultRename@{DefaultRename}!resumeUnblocking@{resumeUnblocking}}
\index{resumeUnblocking@{resumeUnblocking}!DefaultRename@{DefaultRename}}
\subsubsection[{resumeUnblocking}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf resumeUnblocking}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_aacc2e9a4766def499954195037465d42}
Whether or not rename needs to resume clearing out the skidbuffer after squashing. \hypertarget{classDefaultRename_a265ad15229da2a6a05f908da093b3ed5}{
\index{DefaultRename@{DefaultRename}!scoreboard@{scoreboard}}
\index{scoreboard@{scoreboard}!DefaultRename@{DefaultRename}}
\subsubsection[{scoreboard}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Scoreboard}$\ast$ {\bf scoreboard}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a265ad15229da2a6a05f908da093b3ed5}
Pointer to the scoreboard. \hypertarget{classDefaultRename_a12ab5fca837718e12cc837d0f3c1da82}{
\index{DefaultRename@{DefaultRename}!serializeInst@{serializeInst}}
\index{serializeInst@{serializeInst}!DefaultRename@{DefaultRename}}
\subsubsection[{serializeInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf serializeInst}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a12ab5fca837718e12cc837d0f3c1da82}
The serialize instruction that rename has stalled on. \hypertarget{classDefaultRename_a4d99bc7f86d1a17d44e59c316c273262}{
\index{DefaultRename@{DefaultRename}!serializeOnNextInst@{serializeOnNextInst}}
\index{serializeOnNextInst@{serializeOnNextInst}!DefaultRename@{DefaultRename}}
\subsubsection[{serializeOnNextInst}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf serializeOnNextInst}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a4d99bc7f86d1a17d44e59c316c273262}
Records if rename needs to serialize on the next instruction for any thread. \hypertarget{classDefaultRename_a64b861e400ea5adcf7a2f2dbe605e221}{
\index{DefaultRename@{DefaultRename}!skidBuffer@{skidBuffer}}
\index{skidBuffer@{skidBuffer}!DefaultRename@{DefaultRename}}
\subsubsection[{skidBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstQueue} {\bf skidBuffer}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a64b861e400ea5adcf7a2f2dbe605e221}
Skid buffer between rename and decode. \hypertarget{classDefaultRename_a268414a6444b620140f263013a739a17}{
\index{DefaultRename@{DefaultRename}!skidBufferMax@{skidBufferMax}}
\index{skidBufferMax@{skidBufferMax}!DefaultRename@{DefaultRename}}
\subsubsection[{skidBufferMax}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf skidBufferMax}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a268414a6444b620140f263013a739a17}
The maximum skid buffer size. \hypertarget{classDefaultRename_ade48cf321f5741ea8e54e071680cacdc}{
\index{DefaultRename@{DefaultRename}!stalls@{stalls}}
\index{stalls@{stalls}!DefaultRename@{DefaultRename}}
\subsubsection[{stalls}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stalls} {\bf stalls}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_ade48cf321f5741ea8e54e071680cacdc}
Tracks which stages are telling decode to stall. \hypertarget{classDefaultRename_a83f9ee976e732665aeb08dbc19acfd45}{
\index{DefaultRename@{DefaultRename}!timeBuffer@{timeBuffer}}
\index{timeBuffer@{timeBuffer}!DefaultRename@{DefaultRename}}
\subsubsection[{timeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$$\ast$ {\bf timeBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a83f9ee976e732665aeb08dbc19acfd45}
Pointer to main time buffer used for backwards communication. \hypertarget{classDefaultRename_aeb2f0e9b4602def9a8a57f7e3e12cf27}{
\index{DefaultRename@{DefaultRename}!toDecode@{toDecode}}
\index{toDecode@{toDecode}!DefaultRename@{DefaultRename}}
\subsubsection[{toDecode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf toDecode}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_aeb2f0e9b4602def9a8a57f7e3e12cf27}
\hyperlink{classWire}{Wire} to write infromation heading to previous stages. \hypertarget{classDefaultRename_a20add800a4fdb85a3d370265f248a006}{
\index{DefaultRename@{DefaultRename}!toIEW@{toIEW}}
\index{toIEW@{toIEW}!DefaultRename@{DefaultRename}}
\subsubsection[{toIEW}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf RenameStruct}$>$::wire {\bf toIEW}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a20add800a4fdb85a3d370265f248a006}
\hyperlink{classWire}{Wire} to write any information heading to IEW. \hypertarget{classDefaultRename_abb033b9572d00b4ffa5aca6c7fb51427}{
\index{DefaultRename@{DefaultRename}!toIEWIndex@{toIEWIndex}}
\index{toIEWIndex@{toIEWIndex}!DefaultRename@{DefaultRename}}
\subsubsection[{toIEWIndex}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf toIEWIndex}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_abb033b9572d00b4ffa5aca6c7fb51427}
The index of the instruction in the time buffer to IEW that rename is currently using. \hypertarget{classDefaultRename_a2c7e870d4babdac0dc91fc7ffabd0f3d}{
\index{DefaultRename@{DefaultRename}!wroteToTimeBuffer@{wroteToTimeBuffer}}
\index{wroteToTimeBuffer@{wroteToTimeBuffer}!DefaultRename@{DefaultRename}}
\subsubsection[{wroteToTimeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf wroteToTimeBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultRename_a2c7e870d4babdac0dc91fc7ffabd0f3d}
Variable that tracks if decode has written to the time buffer this cycle. Used to tell CPU if there is activity this cycle. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/o3/\hyperlink{rename_8hh}{rename.hh}\item 
cpu/o3/\hyperlink{rename__impl_8hh}{rename\_\-impl.hh}\end{DoxyCompactItemize}
