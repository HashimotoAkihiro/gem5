<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>File&nbsp;GEM5&nbsp;Wrapper: クラス テンプレート Cache&lt; TagStore &gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- 作成： Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>メインページ</span></a></li>
      <li><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>構成</span></a></li>
      <li><a href="classes.html"><span>構成索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>構成メンバ</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>クラス テンプレート Cache&lt; TagStore &gt;</h1><!-- doxytag: class="Cache" --><!-- doxytag: inherits="BaseCache" -->
<p><code>#include &lt;<a class="el" href="cache_8hh_source.html">cache.hh</a>&gt;</code></p>
<div class="dynheader">
Cache&lt; TagStore &gt;に対する継承グラフ</div>
<div class="dynsection">
 <div class="center">
  <img src="classCache.gif" usemap="#Cache&lt; TagStore &gt;_map" alt=""/>
  <map id="Cache&lt; TagStore &gt;_map" name="Cache&lt; TagStore &gt;_map">
<area href="classBaseCache.html" alt="BaseCache" shape="rect" coords="134,224,258,248"/>
<area href="classMemObject.html" alt="MemObject" shape="rect" coords="134,168,258,192"/>
<area href="classClockedObject.html" alt="ClockedObject" shape="rect" coords="134,112,258,136"/>
<area href="classSimObject.html" alt="SimObject" shape="rect" coords="134,56,258,80"/>
<area href="classEventManager.html" alt="EventManager" shape="rect" coords="0,0,124,24"/>
<area href="classSerializable.html" alt="Serializable" shape="rect" coords="134,0,258,24"/>
<area href="classDrainable.html" alt="Drainable" shape="rect" coords="268,0,392,24"/>
</map>
 </div>
</div>

<p><a href="classCache-members.html">すべてのメンバ一覧</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>構成</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache_1_1CpuSidePort.html">CpuSidePort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache_1_1MemSidePacketQueue.html">MemSidePacketQueue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache_1_1MemSidePort.html">MemSidePort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache_1_1RubyCache.html">RubyCache</a></td></tr>
<tr><td colspan="2"><h2>Public 型</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef TagStore::BlkType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef TagStore::BlkList&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a83744fbcce9e00711343dafa32bcb921">BlkList</a></td></tr>
<tr><td colspan="2"><h2>Public メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a82f0d3b81dc0dc573633d0634508218a">Cache</a> (const <a class="el" href="classBaseCache.html#a23c1728f4d2cabb1996560194937d427">Params</a> *p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a899b8bf120ecc87b59e142f00b2987b0">~Cache</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a4dc637449366fcdfc4e764cdf12d9b11">regStats</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a53e036786d17361be4c7320d39c99b84">serialize</a> (std::ostream &amp;os)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#af22e5d6d660b97db37003ac61ac4ee49">unserialize</a> (<a class="el" href="classCheckpoint.html">Checkpoint</a> *cp, const std::string &amp;section)</td></tr>
<tr><td colspan="2"><h2>Protected 型</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classCacheBlkVisitorWrapper.html">CacheBlkVisitorWrapper</a><br class="typebreak"/>
&lt; <a class="el" href="classCache.html">Cache</a>&lt; TagStore &gt;, <a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#afe5f62b7007c3a3cf9170e85041b38d8">WrappedBlkVisitor</a></td></tr>
<tr><td colspan="2"><h2>Protected メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#ae24e0e790eea2373d750eb6642007750">access</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt, <a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *&amp;blk, <a class="el" href="classCycles.html">Cycles</a> &amp;lat, <a class="el" href="classstd_1_1list.html">PacketList</a> &amp;<a class="el" href="group__CacheStatistics.html#gace2b37e760e47862f243e4b03c05ef5e">writebacks</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a911af8215907296fb2453c696cb89a02">cmpAndSwap</a> (<a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *blk, <a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a3da8f395921d5519e28d1c60961ae6c5">allocateBlock</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> addr, bool is_secure, <a class="el" href="classstd_1_1list.html">PacketList</a> &amp;<a class="el" href="group__CacheStatistics.html#gace2b37e760e47862f243e4b03c05ef5e">writebacks</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a4943b9a8a4801f454a968416b456dc21">handleFill</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt, <a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *blk, <a class="el" href="classstd_1_1list.html">PacketList</a> &amp;<a class="el" href="group__CacheStatistics.html#gace2b37e760e47862f243e4b03c05ef5e">writebacks</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a3344d9dd0f83257feab5424e761f31c6">recvTimingReq</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a083c4da6cf866d660a126f4174bba7fc">recvTimingResp</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#aff3031c56fc4947a19695c868bb8233e">recvTimingSnoopReq</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a55143a3333ff75d0df66bd6e4eb50fb7">recvTimingSnoopResp</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a5f0b4c4a94f6b0053f9d7a4eb9c2518a">recvAtomic</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a886d584c81ee4e398ff8069907f6e1a5">recvAtomicSnoop</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#ae764e8af8ed82d5b1e78530e56a16470">functionalAccess</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt, bool fromCpuSide)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a5d5d5944479d29a7bfc183f4b2b6a4fa">satisfyCpuSideRequest</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt, <a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *blk, bool deferred_response=false, bool pending_downgrade=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a65c1c67b81573ca17c8ad40e0e6d85d8">satisfyMSHR</a> (<a class="el" href="classMSHR.html">MSHR</a> *mshr, <a class="el" href="classPacket.html">PacketPtr</a> pkt, <a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *blk)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a87256886a1eea4638abe1b437f4fe226">doTimingSupplyResponse</a> (<a class="el" href="classPacket.html">PacketPtr</a> req_pkt, uint8_t *blk_data, bool already_copied, bool pending_inval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#affa22df454ca8619381018b222c49c2d">handleSnoop</a> (<a class="el" href="classPacket.html">PacketPtr</a> ptk, <a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *blk, bool is_timing, bool is_deferred, bool pending_inval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a4451141787cceb771eec3ea4d4a4a8d4">writebackBlk</a> (<a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *blk)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a381272ae5c2cc173adb59cd67a76b458">memWriteback</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#afea64b0aa579c17485db54c6a5c2ede3">memInvalidate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#ad66f409af3c387e166ff7ee95169b7b6">isDirty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a0f9ea802ec68e58830a83fdf795a9b9f">writebackVisitor</a> (<a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> &amp;blk)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a0a830cf4879a74de1790653f861c7d93">invalidateVisitor</a> (<a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> &amp;blk)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#af5dfa0f9fd3542f24b728e25a1d658b2">uncacheableFlush</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a94c2c174856cbab1e3478cb02ae8ed80">squash</a> (int threadNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a3bdcf30020fcb7b18e1d1f95cc86648e">getBusPacket</a> (<a class="el" href="classPacket.html">PacketPtr</a> cpu_pkt, <a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *blk, bool needsExclusive) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMSHR.html">MSHR</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a3ce02537ee4a8918300802fda9b82b47">getNextMSHR</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a52bd0127c43c9167c1d092fc060cc472">getTimingPacket</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#ac7fb6ca824d25de54878584fd9dd8162">markInService</a> (<a class="el" href="classMSHR.html">MSHR</a> *mshr, <a class="el" href="classPacket.html">PacketPtr</a> pkt=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#ac40e843a35136aebfb61fc0c9f57aa27">outstandingMisses</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCacheBlk.html">CacheBlk</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a4789f9031d3220604c62c0e31a94c539">findBlock</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> addr, bool is_secure) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a2a9a72a19c7910262542bc96de2488fb">inCache</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> addr, bool is_secure) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a01f08168ad1a2fee8ccff0f562da70de">inMissQueue</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> addr, bool is_secure) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a4601a57ba7740776052541f212c29cbd">nextMSHRReadyTime</a> () const </td></tr>
<tr><td colspan="2"><h2>Protected 変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TagStore *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBasePrefetcher.html">BasePrefetcher</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a320f5a2352104b9b633113f9045461a3">prefetcher</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a0ca2086b66114357dd17032178adce17">tempBlock</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a9b589ab6323a2796b7ae762dc7236bb5">doFastWrites</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a146f074bf7af4a70fc378862eab0b15a">prefetchOnAccess</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classPacket.html">PacketPtr</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCache.html#a21da4bea3554874b557428e4cce5d4a4">pendingDelete</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>説明</h2>
<h3>template&lt;class TagStore&gt;<br/>
 class Cache&lt; TagStore &gt;</h3>

<p>A template-policy based cache. The behavior of the cache can be altered by supplying different template policies. TagStore handles all tag and data storage </p>
<dl class="see"><dt><b>参照:</b></dt><dd>TagStore, gem5 Memory System </dd></dl>
<hr/><h2>型定義</h2>
<a class="anchor" id="a83744fbcce9e00711343dafa32bcb921"></a><!-- doxytag: member="Cache::BlkList" ref="a83744fbcce9e00711343dafa32bcb921" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef TagStore::BlkList <a class="el" href="classCache.html#a83744fbcce9e00711343dafa32bcb921">BlkList</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A typedef for a list of BlkType pointers. </p>

</div>
</div>
<a class="anchor" id="a10db52a1c10bfd238e0e3d37c4560495"></a><!-- doxytag: member="Cache::BlkType" ref="a10db52a1c10bfd238e0e3d37c4560495" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef TagStore::BlkType <a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Define the type of cache block to use. </p>

</div>
</div>
<a class="anchor" id="afe5f62b7007c3a3cf9170e85041b38d8"></a><!-- doxytag: member="Cache::WrappedBlkVisitor" ref="afe5f62b7007c3a3cf9170e85041b38d8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classCacheBlkVisitorWrapper.html">CacheBlkVisitorWrapper</a>&lt;<a class="el" href="classCache.html">Cache</a>&lt;TagStore&gt;, <a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a>&gt; <a class="el" href="classCacheBlkVisitorWrapper.html">WrappedBlkVisitor</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>コンストラクタとデストラクタ</h2>
<a class="anchor" id="a82f0d3b81dc0dc573633d0634508218a"></a><!-- doxytag: member="Cache::Cache" ref="a82f0d3b81dc0dc573633d0634508218a" args="(const Params *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCache.html">Cache</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBaseCache.html#a23c1728f4d2cabb1996560194937d427">Params</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Instantiates a basic cache object. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00070"></a>00070     : <a class="code" href="classBaseCache.html#a6c1d60cbb9ab660c557bca8bfb40d768">BaseCache</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>),
<a name="l00071"></a>00071       <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>(dynamic_cast&lt;TagStore*&gt;(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;tags)),
<a name="l00072"></a>00072       <a class="code" href="classCache.html#a320f5a2352104b9b633113f9045461a3">prefetcher</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;prefetcher),
<a name="l00073"></a>00073       <a class="code" href="classCache.html#a9b589ab6323a2796b7ae762dc7236bb5">doFastWrites</a>(<span class="keyword">true</span>),
<a name="l00074"></a>00074       <a class="code" href="classCache.html#a146f074bf7af4a70fc378862eab0b15a">prefetchOnAccess</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;prefetch_on_access)
<a name="l00075"></a>00075 {
<a name="l00076"></a>00076     <a class="code" href="classCache.html#a0ca2086b66114357dd17032178adce17">tempBlock</a> = <span class="keyword">new</span> <a class="code" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a>();
<a name="l00077"></a>00077     <a class="code" href="classCache.html#a0ca2086b66114357dd17032178adce17">tempBlock</a>-&gt;data = <span class="keyword">new</span> uint8_t[<a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a>];
<a name="l00078"></a>00078 
<a name="l00079"></a>00079     <a class="code" href="classBaseCache.html#a14913ffff181227d085f25a95e6ada42">cpuSidePort</a> = <span class="keyword">new</span> CpuSidePort(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;name + <span class="stringliteral">&quot;.cpu_side&quot;</span>, <span class="keyword">this</span>,
<a name="l00080"></a>00080                                   <span class="stringliteral">&quot;CpuSidePort&quot;</span>);
<a name="l00081"></a>00081     <a class="code" href="classBaseCache.html#af29f0c640654a651bf26558b4b39623b">memSidePort</a> = <span class="keyword">new</span> MemSidePort(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;name + <span class="stringliteral">&quot;.mem_side&quot;</span>, <span class="keyword">this</span>,
<a name="l00082"></a>00082                                   <span class="stringliteral">&quot;MemSidePort&quot;</span>);
<a name="l00083"></a>00083 
<a name="l00084"></a>00084     <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;setCache(<span class="keyword">this</span>);
<a name="l00085"></a>00085     <span class="keywordflow">if</span> (<a class="code" href="classCache.html#a320f5a2352104b9b633113f9045461a3">prefetcher</a>)
<a name="l00086"></a>00086         <a class="code" href="classCache.html#a320f5a2352104b9b633113f9045461a3">prefetcher</a>-&gt;<a class="code" href="classBasePrefetcher.html#a6a5d34a51c5ba1c4f87dbcc59e8b13fb">setCache</a>(<span class="keyword">this</span>);
<a name="l00087"></a>00087 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a899b8bf120ecc87b59e142f00b2987b0"></a><!-- doxytag: member="Cache::~Cache" ref="a899b8bf120ecc87b59e142f00b2987b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classCache.html">Cache</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Non-default destructor is needed to deallocate memory. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00091"></a>00091 {
<a name="l00092"></a>00092     <span class="keyword">delete</span> [] <a class="code" href="classCache.html#a0ca2086b66114357dd17032178adce17">tempBlock</a>-&gt;data;
<a name="l00093"></a>00093     <span class="keyword">delete</span> <a class="code" href="classCache.html#a0ca2086b66114357dd17032178adce17">tempBlock</a>;
<a name="l00094"></a>00094 
<a name="l00095"></a>00095     <span class="keyword">delete</span> <a class="code" href="classBaseCache.html#a14913ffff181227d085f25a95e6ada42">cpuSidePort</a>;
<a name="l00096"></a>00096     <span class="keyword">delete</span> <a class="code" href="classBaseCache.html#af29f0c640654a651bf26558b4b39623b">memSidePort</a>;
<a name="l00097"></a>00097 }
</pre></div></p>

</div>
</div>
<hr/><h2>関数</h2>
<a class="anchor" id="ae24e0e790eea2373d750eb6642007750"></a><!-- doxytag: member="Cache::access" ref="ae24e0e790eea2373d750eb6642007750" args="(PacketPtr pkt, BlkType *&amp;blk, Cycles &amp;lat, PacketList &amp;writebacks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCycles.html">Cycles</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstd_1_1list.html">PacketList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writebacks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Does all the processing necessary to perform the provided request. </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td>The memory request to perform. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blk</em>&nbsp;</td><td>The cache block to be updated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lat</em>&nbsp;</td><td>The latency of the access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>writebacks</em>&nbsp;</td><td>List for any writebacks that need to be performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Boolean indicating whether the request was satisfied. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00293"></a>00293 {
<a name="l00294"></a>00294     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;%s for %s address %x size %d\n&quot;</span>, __func__,
<a name="l00295"></a>00295             pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(), pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), pkt-&gt;<a class="code" href="classPacket.html#a1d18ba49c7be427da1f4a42d53e35f48">getSize</a>());
<a name="l00296"></a>00296     <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a70c74b2809417ea8701dd6ba9e34312d">isUncacheable</a>()) {
<a name="l00297"></a>00297         <a class="code" href="classCache.html#af5dfa0f9fd3542f24b728e25a1d658b2">uncacheableFlush</a>(pkt);
<a name="l00298"></a>00298         blk = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00299"></a>00299         lat = <a class="code" href="classBaseCache.html#a4075fdc5720f8f0f57c379c396e74718">hitLatency</a>;
<a name="l00300"></a>00300         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00301"></a>00301     }
<a name="l00302"></a>00302 
<a name="l00303"></a>00303     <span class="keywordtype">int</span> <span class="keywordtype">id</span> = pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a2b2cd3fd53b1fb8c401187ca87f810f5">hasContextId</a>() ? pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a651d5d14e7a4e95ebe6d7f5b8ee5a107">contextId</a>() : -1;
<a name="l00304"></a>00304     blk = <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;accessBlock(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>(), lat, id);
<a name="l00305"></a>00305 
<a name="l00306"></a>00306     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;%s%s %x (%s) %s %s\n&quot;</span>, pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(),
<a name="l00307"></a>00307             pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#ae742b8e8aaa2e18506dc64c7b7f3fc0a">isInstFetch</a>() ? <span class="stringliteral">&quot; (ifetch)&quot;</span> : <span class="stringliteral">&quot;&quot;</span>,
<a name="l00308"></a>00308             pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>() ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;ns&quot;</span>,
<a name="l00309"></a>00309             blk ? <span class="stringliteral">&quot;hit&quot;</span> : <span class="stringliteral">&quot;miss&quot;</span>, blk ? blk-&gt;print() : <span class="stringliteral">&quot;&quot;</span>);
<a name="l00310"></a>00310 
<a name="l00311"></a>00311     <span class="keywordflow">if</span> (blk != <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>) {
<a name="l00312"></a>00312 
<a name="l00313"></a>00313         <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#aa8e449288b878ff3ff7f286eb4d28b6a">needsExclusive</a>() ? blk-&gt;isWritable() : blk-&gt;isReadable()) {
<a name="l00314"></a>00314             <span class="comment">// OK to satisfy access</span>
<a name="l00315"></a>00315             <a class="code" href="classBaseCache.html#a5d0c42b459c95506252f8916dc4abc9c">incHitCount</a>(pkt);
<a name="l00316"></a>00316             <a class="code" href="classCache.html#a5d5d5944479d29a7bfc183f4b2b6a4fa">satisfyCpuSideRequest</a>(pkt, blk);
<a name="l00317"></a>00317             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00318"></a>00318         }
<a name="l00319"></a>00319     }
<a name="l00320"></a>00320 
<a name="l00321"></a>00321     <span class="comment">// Can&apos;t satisfy access normally... either no block (blk == NULL)</span>
<a name="l00322"></a>00322     <span class="comment">// or have block but need exclusive &amp; only have shared.</span>
<a name="l00323"></a>00323 
<a name="l00324"></a>00324     <span class="comment">// Writeback handling is special case.  We can write the block</span>
<a name="l00325"></a>00325     <span class="comment">// into the cache without having a writeable copy (or any copy at</span>
<a name="l00326"></a>00326     <span class="comment">// all).</span>
<a name="l00327"></a>00327     <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a89447e3db973b10c03f68d590c65e8e6">MemCmd::Writeback</a>) {
<a name="l00328"></a>00328         assert(<a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a> == pkt-&gt;<a class="code" href="classPacket.html#a1d18ba49c7be427da1f4a42d53e35f48">getSize</a>());
<a name="l00329"></a>00329         <span class="keywordflow">if</span> (blk == <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>) {
<a name="l00330"></a>00330             <span class="comment">// need to do a replacement</span>
<a name="l00331"></a>00331             blk = <a class="code" href="classCache.html#a3da8f395921d5519e28d1c60961ae6c5">allocateBlock</a>(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>(), writebacks);
<a name="l00332"></a>00332             <span class="keywordflow">if</span> (blk == <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>) {
<a name="l00333"></a>00333                 <span class="comment">// no replaceable block available, give up.</span>
<a name="l00334"></a>00334                 <span class="comment">// writeback will be forwarded to next level.</span>
<a name="l00335"></a>00335                 <a class="code" href="classBaseCache.html#a998427ec80c26469aae228b0d6bd9bd0">incMissCount</a>(pkt);
<a name="l00336"></a>00336                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00337"></a>00337             }
<a name="l00338"></a>00338             <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;insertBlock(pkt, blk);
<a name="l00339"></a>00339             blk-&gt;status = <a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7acd687680ed8ee756c990233bd44ccc7a">BlkValid</a> | <a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7ac413eacf0a0c4c85665e24fc3138ad50">BlkReadable</a>;
<a name="l00340"></a>00340         }
<a name="l00341"></a>00341         std::memcpy(blk-&gt;data, pkt-&gt;<a class="code" href="classPacket.html#a5c451baf3f0a89084e79e69bb9061200">getPtr</a>&lt;uint8_t&gt;(), <a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a>);
<a name="l00342"></a>00342         blk-&gt;status |= <a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7a87715983fd384f5ee41ec0608f5c6e5f">BlkDirty</a>;
<a name="l00343"></a>00343         <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#ae74f555f87001a9695338ce38a6ce8ee">isSupplyExclusive</a>()) {
<a name="l00344"></a>00344             blk-&gt;status |= <a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7a202d95c1090db0082a7a954856ad5358">BlkWritable</a>;
<a name="l00345"></a>00345         }
<a name="l00346"></a>00346         <span class="comment">// nothing else to do; writeback doesn&apos;t expect response</span>
<a name="l00347"></a>00347         assert(!pkt-&gt;<a class="code" href="classPacket.html#a390c6cced05593f0a2c75a38a7a24fa9">needsResponse</a>());
<a name="l00348"></a>00348         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;%s new state is %s\n&quot;</span>, __func__, blk-&gt;print());
<a name="l00349"></a>00349         <a class="code" href="classBaseCache.html#a5d0c42b459c95506252f8916dc4abc9c">incHitCount</a>(pkt);
<a name="l00350"></a>00350         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00351"></a>00351     }
<a name="l00352"></a>00352 
<a name="l00353"></a>00353     <a class="code" href="classBaseCache.html#a998427ec80c26469aae228b0d6bd9bd0">incMissCount</a>(pkt);
<a name="l00354"></a>00354 
<a name="l00355"></a>00355     <span class="keywordflow">if</span> (blk == <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a> &amp;&amp; pkt-&gt;<a class="code" href="classPacket.html#a8965874e960faf91ad4b6af8dbf31875">isLLSC</a>() &amp;&amp; pkt-&gt;<a class="code" href="classPacket.html#ab699d2f0d186312531fd1c279fd27b73">isWrite</a>()) {
<a name="l00356"></a>00356         <span class="comment">// complete miss on store conditional... just give up now</span>
<a name="l00357"></a>00357         pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#ac73800a0bae4776befb9d416e95ea6d9">setExtraData</a>(0);
<a name="l00358"></a>00358         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00359"></a>00359     }
<a name="l00360"></a>00360 
<a name="l00361"></a>00361     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00362"></a>00362 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3da8f395921d5519e28d1c60961ae6c5"></a><!-- doxytag: member="Cache::allocateBlock" ref="a3da8f395921d5519e28d1c60961ae6c5" args="(Addr addr, bool is_secure, PacketList &amp;writebacks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCache.html">Cache</a>&lt; TagStore &gt;::<a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> * allocateBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_secure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstd_1_1list.html">PacketList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writebacks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a block frame for new block at address addr targeting the given security space, assuming that the block is not currently in the cache. Append writebacks if any to provided packet list. Return free block frame. May return NULL if there are no replaceable blocks at the moment. </p>

<p><div class="fragment"><pre class="fragment"><a name="l01205"></a>01205 {
<a name="l01206"></a>01206     <a class="code" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *blk = <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;findVictim(<a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a>);
<a name="l01207"></a>01207 
<a name="l01208"></a>01208     <span class="keywordflow">if</span> (blk-&gt;isValid()) {
<a name="l01209"></a>01209         <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> repl_addr = <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;regenerateBlkAddr(blk-&gt;tag, blk-&gt;set);
<a name="l01210"></a>01210         <a class="code" href="classMSHR.html">MSHR</a> *repl_mshr = <a class="code" href="classBaseCache.html#aa73933a75144caca7a7d3d77cf285c23">mshrQueue</a>.<a class="code" href="classMSHRQueue.html#aab842d63dcd254dfe655e16075f7e0fe">findMatch</a>(repl_addr, blk-&gt;isSecure());
<a name="l01211"></a>01211         <span class="keywordflow">if</span> (repl_mshr) {
<a name="l01212"></a>01212             <span class="comment">// must be an outstanding upgrade request on block</span>
<a name="l01213"></a>01213             <span class="comment">// we&apos;re about to replace...</span>
<a name="l01214"></a>01214             assert(!blk-&gt;isWritable());
<a name="l01215"></a>01215             assert(repl_mshr-&gt;<a class="code" href="classMSHR.html#aa8e449288b878ff3ff7f286eb4d28b6a">needsExclusive</a>());
<a name="l01216"></a>01216             <span class="comment">// too hard to replace block with transient state</span>
<a name="l01217"></a>01217             <span class="comment">// allocation failed, block not inserted</span>
<a name="l01218"></a>01218             <span class="keywordflow">return</span> <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l01219"></a>01219         } <span class="keywordflow">else</span> {
<a name="l01220"></a>01220             <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;replacement: replacing %x (%s) with %x (%s): %s\n&quot;</span>,
<a name="l01221"></a>01221                     repl_addr, blk-&gt;isSecure() ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;ns&quot;</span>,
<a name="l01222"></a>01222                     <a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a>, is_secure ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;ns&quot;</span>,
<a name="l01223"></a>01223                     blk-&gt;isDirty() ? <span class="stringliteral">&quot;writeback&quot;</span> : <span class="stringliteral">&quot;clean&quot;</span>);
<a name="l01224"></a>01224 
<a name="l01225"></a>01225             <span class="keywordflow">if</span> (blk-&gt;isDirty()) {
<a name="l01226"></a>01226                 <span class="comment">// Save writeback packet for handling by caller</span>
<a name="l01227"></a>01227                 writebacks.push_back(<a class="code" href="classCache.html#a4451141787cceb771eec3ea4d4a4a8d4">writebackBlk</a>(blk));
<a name="l01228"></a>01228             }
<a name="l01229"></a>01229         }
<a name="l01230"></a>01230     }
<a name="l01231"></a>01231 
<a name="l01232"></a>01232     <span class="keywordflow">return</span> blk;
<a name="l01233"></a>01233 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a911af8215907296fb2453c696cb89a02"></a><!-- doxytag: member="Cache::cmpAndSwap" ref="a911af8215907296fb2453c696cb89a02" args="(BlkType *blk, PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmpAndSwap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *&nbsp;</td>
          <td class="paramname"> <em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handle doing the Compare and Swap function for SPARC. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00109"></a>00109 {
<a name="l00110"></a>00110     uint64_t overwrite_val;
<a name="l00111"></a>00111     <span class="keywordtype">bool</span> overwrite_mem;
<a name="l00112"></a>00112     uint64_t condition_val64;
<a name="l00113"></a>00113     <a class="code" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> condition_val32;
<a name="l00114"></a>00114 
<a name="l00115"></a>00115     <span class="keywordtype">int</span> <a class="code" href="namespaceArmISA.html#a87b7a740701cddafb930a9460e9f4eba">offset</a> = <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;extractBlkOffset(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>());
<a name="l00116"></a>00116     uint8_t *blk_data = blk-&gt;data + offset;
<a name="l00117"></a>00117 
<a name="l00118"></a>00118     assert(<span class="keyword">sizeof</span>(uint64_t) &gt;= pkt-&gt;<a class="code" href="classPacket.html#a1d18ba49c7be427da1f4a42d53e35f48">getSize</a>());
<a name="l00119"></a>00119 
<a name="l00120"></a>00120     overwrite_mem = <span class="keyword">true</span>;
<a name="l00121"></a>00121     <span class="comment">// keep a copy of our possible write value, and copy what is at the</span>
<a name="l00122"></a>00122     <span class="comment">// memory address into the packet</span>
<a name="l00123"></a>00123     pkt-&gt;<a class="code" href="classPacket.html#a2388a13bab41142d6e403b0e5a0fb649">writeData</a>((uint8_t *)&amp;overwrite_val);
<a name="l00124"></a>00124     pkt-&gt;<a class="code" href="classPacket.html#aaa0b1cd19807fc630d9331be9f5d1d36">setData</a>(blk_data);
<a name="l00125"></a>00125 
<a name="l00126"></a>00126     <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a086ef1e55d60089d0aa0232ff797eaef">isCondSwap</a>()) {
<a name="l00127"></a>00127         <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a1d18ba49c7be427da1f4a42d53e35f48">getSize</a>() == <span class="keyword">sizeof</span>(uint64_t)) {
<a name="l00128"></a>00128             condition_val64 = pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#af848a06a731668855b203d679077623d">getExtraData</a>();
<a name="l00129"></a>00129             overwrite_mem = !std::memcmp(&amp;condition_val64, blk_data,
<a name="l00130"></a>00130                                          <span class="keyword">sizeof</span>(uint64_t));
<a name="l00131"></a>00131         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a1d18ba49c7be427da1f4a42d53e35f48">getSize</a>() == <span class="keyword">sizeof</span>(<a class="code" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)) {
<a name="l00132"></a>00132             condition_val32 = (<a class="code" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#af848a06a731668855b203d679077623d">getExtraData</a>();
<a name="l00133"></a>00133             overwrite_mem = !std::memcmp(&amp;condition_val32, blk_data,
<a name="l00134"></a>00134                                          <span class="keyword">sizeof</span>(<a class="code" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>));
<a name="l00135"></a>00135         } <span class="keywordflow">else</span>
<a name="l00136"></a>00136             <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;Invalid size for conditional read/write\n&quot;</span>);
<a name="l00137"></a>00137     }
<a name="l00138"></a>00138 
<a name="l00139"></a>00139     <span class="keywordflow">if</span> (overwrite_mem) {
<a name="l00140"></a>00140         std::memcpy(blk_data, &amp;overwrite_val, pkt-&gt;<a class="code" href="classPacket.html#a1d18ba49c7be427da1f4a42d53e35f48">getSize</a>());
<a name="l00141"></a>00141         blk-&gt;status |= <a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7a87715983fd384f5ee41ec0608f5c6e5f">BlkDirty</a>;
<a name="l00142"></a>00142     }
<a name="l00143"></a>00143 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a87256886a1eea4638abe1b437f4fe226"></a><!-- doxytag: member="Cache::doTimingSupplyResponse" ref="a87256886a1eea4638abe1b437f4fe226" args="(PacketPtr req_pkt, uint8_t *blk_data, bool already_copied, bool pending_inval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void doTimingSupplyResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>req_pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>blk_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>already_copied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pending_inval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l01325"></a>01325 {
<a name="l01326"></a>01326     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;%s for %s address %x size %d\n&quot;</span>, __func__,
<a name="l01327"></a>01327             req_pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(), req_pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), req_pkt-&gt;<a class="code" href="classPacket.html#a1d18ba49c7be427da1f4a42d53e35f48">getSize</a>());
<a name="l01328"></a>01328     <span class="comment">// timing-mode snoop responses require a new packet, unless we</span>
<a name="l01329"></a>01329     <span class="comment">// already made a copy...</span>
<a name="l01330"></a>01330     <a class="code" href="classPacket.html">PacketPtr</a> pkt = already_copied ? req_pkt : <span class="keyword">new</span> <a class="code" href="classPacket.html">Packet</a>(req_pkt);
<a name="l01331"></a>01331     assert(req_pkt-&gt;<a class="code" href="classPacket.html#a4a1a39b8ffab2d6266cd9d794ca332e3">isInvalidate</a>() || pkt-&gt;sharedAsserted());
<a name="l01332"></a>01332     pkt-&gt;allocate();
<a name="l01333"></a>01333     pkt-&gt;makeTimingResponse();
<a name="l01334"></a>01334     <span class="comment">// @todo Make someone pay for this</span>
<a name="l01335"></a>01335     pkt-&gt;busFirstWordDelay = pkt-&gt;busLastWordDelay = 0;
<a name="l01336"></a>01336     <span class="keywordflow">if</span> (pkt-&gt;isRead()) {
<a name="l01337"></a>01337         pkt-&gt;setDataFromBlock(blk_data, <a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a>);
<a name="l01338"></a>01338     }
<a name="l01339"></a>01339     <span class="keywordflow">if</span> (pkt-&gt;cmd == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153ab3b23336c0b9e51ce2b80101dc975aa2">MemCmd::ReadResp</a> &amp;&amp; pending_inval) {
<a name="l01340"></a>01340         <span class="comment">// Assume we defer a response to a read from a far-away cache</span>
<a name="l01341"></a>01341         <span class="comment">// A, then later defer a ReadExcl from a cache B on the same</span>
<a name="l01342"></a>01342         <span class="comment">// bus as us.  We&apos;ll assert MemInhibit in both cases, but in</span>
<a name="l01343"></a>01343         <span class="comment">// the latter case MemInhibit will keep the invalidation from</span>
<a name="l01344"></a>01344         <span class="comment">// reaching cache A.  This special response tells cache A that</span>
<a name="l01345"></a>01345         <span class="comment">// it gets the block to satisfy its read, but must immediately</span>
<a name="l01346"></a>01346         <span class="comment">// invalidate it.</span>
<a name="l01347"></a>01347         pkt-&gt;cmd = <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a2cea517c889453c5a51450f7ad62b9e6">MemCmd::ReadRespWithInvalidate</a>;
<a name="l01348"></a>01348     }
<a name="l01349"></a>01349     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;%s created response: %s address %x size %d\n&quot;</span>,
<a name="l01350"></a>01350             __func__, pkt-&gt;cmdString(), pkt-&gt;getAddr(), pkt-&gt;getSize());
<a name="l01351"></a>01351     <a class="code" href="classBaseCache.html#af29f0c640654a651bf26558b4b39623b">memSidePort</a>-&gt;<a class="code" href="classQueuedMasterPort.html#aedc38469f895c00a0ffcb993598b7a53">schedTimingSnoopResp</a>(pkt, <a class="code" href="classClockedObject.html#a773956693f216cafb7d4cad92ad582e5">clockEdge</a>(<a class="code" href="classBaseCache.html#a4075fdc5720f8f0f57c379c396e74718">hitLatency</a>));
<a name="l01352"></a>01352 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4789f9031d3220604c62c0e31a94c539"></a><!-- doxytag: member="Cache::findBlock" ref="a4789f9031d3220604c62c0e31a94c539" args="(Addr addr, bool is_secure) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCacheBlk.html">CacheBlk</a>* findBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_secure</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00388"></a>00388                                                          {
<a name="l00389"></a>00389         <span class="keywordflow">return</span> <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;findBlock(<a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a>, is_secure);
<a name="l00390"></a>00390     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae764e8af8ed82d5b1e78530e56a16470"></a><!-- doxytag: member="Cache::functionalAccess" ref="ae764e8af8ed82d5b1e78530e56a16470" args="(PacketPtr pkt, bool fromCpuSide)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void functionalAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fromCpuSide</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Performs the access specified by the request. </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td>The request to perform. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fromCpuSide</em>&nbsp;</td><td>from the CPU side port or the memory side port </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00803"></a>00803 {
<a name="l00804"></a>00804     <span class="keywordflow">if</span> (<a class="code" href="classBaseCache.html#af27ccd765f13a4b7bd119dc7579e2746">system</a>-&gt;<a class="code" href="classSystem.html#a613d9d917b0e950cd322026de403d702">bypassCaches</a>()) {
<a name="l00805"></a>00805         <span class="comment">// Packets from the memory side are snoop request and</span>
<a name="l00806"></a>00806         <span class="comment">// shouldn&apos;t happen in bypass mode.</span>
<a name="l00807"></a>00807         assert(fromCpuSide);
<a name="l00808"></a>00808 
<a name="l00809"></a>00809         <span class="comment">// The cache should be flushed if we are in cache bypass mode,</span>
<a name="l00810"></a>00810         <span class="comment">// so we don&apos;t need to check if we need to update anything.</span>
<a name="l00811"></a>00811         <a class="code" href="classBaseCache.html#af29f0c640654a651bf26558b4b39623b">memSidePort</a>-&gt;<a class="code" href="classMasterPort.html#aef8a57d30c0da6a2d2a599a14a9b8751">sendFunctional</a>(pkt);
<a name="l00812"></a>00812         <span class="keywordflow">return</span>;
<a name="l00813"></a>00813     }
<a name="l00814"></a>00814 
<a name="l00815"></a>00815     <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> blk_addr = <a class="code" href="classBaseCache.html#a676df8321350e810fc857d99cdcebc22">blockAlign</a>(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>());
<a name="l00816"></a>00816     <span class="keywordtype">bool</span> is_secure = pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>();
<a name="l00817"></a>00817     <a class="code" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *blk = <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;findBlock(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), is_secure);
<a name="l00818"></a>00818     <a class="code" href="classMSHR.html">MSHR</a> *mshr = <a class="code" href="classBaseCache.html#aa73933a75144caca7a7d3d77cf285c23">mshrQueue</a>.<a class="code" href="classMSHRQueue.html#aab842d63dcd254dfe655e16075f7e0fe">findMatch</a>(blk_addr, is_secure);
<a name="l00819"></a>00819 
<a name="l00820"></a>00820     pkt-&gt;<a class="code" href="classPacket.html#ad2656c333949d4b445823d47398829f2">pushLabel</a>(<a class="code" href="classSimObject.html#adbcff144e5e199d332a1352af1798148">name</a>());
<a name="l00821"></a>00821 
<a name="l00822"></a>00822     <a class="code" href="classCacheBlkPrintWrapper.html">CacheBlkPrintWrapper</a> cbpw(blk);
<a name="l00823"></a>00823 
<a name="l00824"></a>00824     <span class="comment">// Note that just because an L2/L3 has valid data doesn&apos;t mean an</span>
<a name="l00825"></a>00825     <span class="comment">// L1 doesn&apos;t have a more up-to-date modified copy that still</span>
<a name="l00826"></a>00826     <span class="comment">// needs to be found.  As a result we always update the request if</span>
<a name="l00827"></a>00827     <span class="comment">// we have it, but only declare it satisfied if we are the owner.</span>
<a name="l00828"></a>00828 
<a name="l00829"></a>00829     <span class="comment">// see if we have data at all (owned or otherwise)</span>
<a name="l00830"></a>00830     <span class="keywordtype">bool</span> have_data = blk &amp;&amp; blk-&gt;isValid()
<a name="l00831"></a>00831         &amp;&amp; pkt-&gt;<a class="code" href="classPacket.html#a77410f93ce8057ce67882c121ac2e667">checkFunctional</a>(&amp;cbpw, blk_addr, is_secure, <a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a>,
<a name="l00832"></a>00832                                 blk-&gt;data);
<a name="l00833"></a>00833 
<a name="l00834"></a>00834     <span class="comment">// data we have is dirty if marked as such or if valid &amp; ownership</span>
<a name="l00835"></a>00835     <span class="comment">// pending due to outstanding UpgradeReq</span>
<a name="l00836"></a>00836     <span class="keywordtype">bool</span> have_dirty =
<a name="l00837"></a>00837         have_data &amp;&amp; (blk-&gt;isDirty() ||
<a name="l00838"></a>00838                       (mshr &amp;&amp; mshr-&gt;<a class="code" href="classMSHR.html#a7f5c4fb6e9162689992ccd0cd7bce17b">inService</a> &amp;&amp; mshr-&gt;<a class="code" href="classMSHR.html#a46636974002da45a91f2019ff47b5025">isPendingDirty</a>()));
<a name="l00839"></a>00839 
<a name="l00840"></a>00840     <span class="keywordtype">bool</span> done = have_dirty
<a name="l00841"></a>00841         || <a class="code" href="classBaseCache.html#a14913ffff181227d085f25a95e6ada42">cpuSidePort</a>-&gt;<a class="code" href="classQueuedSlavePort.html#a8eb60d4744b6212ad749f3a586759266">checkFunctional</a>(pkt)
<a name="l00842"></a>00842         || <a class="code" href="classBaseCache.html#aa73933a75144caca7a7d3d77cf285c23">mshrQueue</a>.<a class="code" href="classMSHRQueue.html#ab1a1044e709a5b00c99cf14430b3ff53">checkFunctional</a>(pkt, blk_addr)
<a name="l00843"></a>00843         || <a class="code" href="classBaseCache.html#ad44ec41bd8517224df8584b5e7fbe372">writeBuffer</a>.<a class="code" href="classMSHRQueue.html#ab1a1044e709a5b00c99cf14430b3ff53">checkFunctional</a>(pkt, blk_addr)
<a name="l00844"></a>00844         || <a class="code" href="classBaseCache.html#af29f0c640654a651bf26558b4b39623b">memSidePort</a>-&gt;<a class="code" href="classQueuedMasterPort.html#a8eb60d4744b6212ad749f3a586759266">checkFunctional</a>(pkt);
<a name="l00845"></a>00845 
<a name="l00846"></a>00846     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;functional %s %x (%s) %s%s%s\n&quot;</span>,
<a name="l00847"></a>00847             pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(), pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), is_secure ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;ns&quot;</span>,
<a name="l00848"></a>00848             (blk &amp;&amp; blk-&gt;isValid()) ? <span class="stringliteral">&quot;valid &quot;</span> : <span class="stringliteral">&quot;&quot;</span>,
<a name="l00849"></a>00849             have_data ? <span class="stringliteral">&quot;data &quot;</span> : <span class="stringliteral">&quot;&quot;</span>, done ? <span class="stringliteral">&quot;done &quot;</span> : <span class="stringliteral">&quot;&quot;</span>);
<a name="l00850"></a>00850 
<a name="l00851"></a>00851     <span class="comment">// We&apos;re leaving the cache, so pop cache-&gt;name() label</span>
<a name="l00852"></a>00852     pkt-&gt;<a class="code" href="classPacket.html#a3ab6da7065be0d85f45a8dd050515f16">popLabel</a>();
<a name="l00853"></a>00853 
<a name="l00854"></a>00854     <span class="keywordflow">if</span> (done) {
<a name="l00855"></a>00855         pkt-&gt;<a class="code" href="classPacket.html#a9330bf4cbbc7e25bbfc9626182df27e5">makeResponse</a>();
<a name="l00856"></a>00856     } <span class="keywordflow">else</span> {
<a name="l00857"></a>00857         <span class="comment">// if it came as a request from the CPU side then make sure it</span>
<a name="l00858"></a>00858         <span class="comment">// continues towards the memory side</span>
<a name="l00859"></a>00859         <span class="keywordflow">if</span> (fromCpuSide) {
<a name="l00860"></a>00860             <a class="code" href="classBaseCache.html#af29f0c640654a651bf26558b4b39623b">memSidePort</a>-&gt;<a class="code" href="classMasterPort.html#aef8a57d30c0da6a2d2a599a14a9b8751">sendFunctional</a>(pkt);
<a name="l00861"></a>00861         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classBaseCache.html#ac8d6ebb7f62e1afe78ddc7c774316d66">forwardSnoops</a> &amp;&amp; <a class="code" href="classBaseCache.html#a14913ffff181227d085f25a95e6ada42">cpuSidePort</a>-&gt;<a class="code" href="classSlavePort.html#a5ce11b7a254d3cb756d94568f7cbc25d">isSnooping</a>()) {
<a name="l00862"></a>00862             <span class="comment">// if it came from the memory side, it must be a snoop request</span>
<a name="l00863"></a>00863             <span class="comment">// and we should only forward it if we are forwarding snoops</span>
<a name="l00864"></a>00864             <a class="code" href="classBaseCache.html#a14913ffff181227d085f25a95e6ada42">cpuSidePort</a>-&gt;<a class="code" href="classSlavePort.html#a821cf873ae00e77f71d77505a63cfed7">sendFunctionalSnoop</a>(pkt);
<a name="l00865"></a>00865         }
<a name="l00866"></a>00866     }
<a name="l00867"></a>00867 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3bdcf30020fcb7b18e1d1f95cc86648e"></a><!-- doxytag: member="Cache::getBusPacket" ref="a3bdcf30020fcb7b18e1d1f95cc86648e" args="(PacketPtr cpu_pkt, BlkType *blk, bool needsExclusive) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPacket.html">PacketPtr</a> getBusPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>cpu_pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *&nbsp;</td>
          <td class="paramname"> <em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>needsExclusive</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generate an appropriate downstream bus request packet for the given parameters. </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_pkt</em>&nbsp;</td><td>The upstream request that needs to be satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blk</em>&nbsp;</td><td>The block currently in the cache corresponding to cpu_pkt (NULL if none). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>needsExclusive</em>&nbsp;</td><td>Indicates that an exclusive copy is required even if the request in cpu_pkt doesn't indicate that. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>A new <a class="el" href="classPacket.html">Packet</a> containing the request, or NULL if the current request in cpu_pkt should just be forwarded on. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00628"></a>00628 {
<a name="l00629"></a>00629     <span class="keywordtype">bool</span> blkValid = blk &amp;&amp; blk-&gt;isValid();
<a name="l00630"></a>00630 
<a name="l00631"></a>00631     <span class="keywordflow">if</span> (cpu_pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a70c74b2809417ea8701dd6ba9e34312d">isUncacheable</a>()) {
<a name="l00632"></a>00632         <span class="comment">//assert(blk == NULL);</span>
<a name="l00633"></a>00633         <span class="keywordflow">return</span> <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00634"></a>00634     }
<a name="l00635"></a>00635 
<a name="l00636"></a>00636     <span class="keywordflow">if</span> (!blkValid &amp;&amp;
<a name="l00637"></a>00637         (cpu_pkt-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a89447e3db973b10c03f68d590c65e8e6">MemCmd::Writeback</a> || cpu_pkt-&gt;<a class="code" href="classPacket.html#aadb2fde0aba4a65b45d591e9ef5b6a63">isUpgrade</a>())) {
<a name="l00638"></a>00638         <span class="comment">// Writebacks that weren&apos;t allocated in access() and upgrades</span>
<a name="l00639"></a>00639         <span class="comment">// from upper-level caches that missed completely just go</span>
<a name="l00640"></a>00640         <span class="comment">// through.</span>
<a name="l00641"></a>00641         <span class="keywordflow">return</span> <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00642"></a>00642     }
<a name="l00643"></a>00643 
<a name="l00644"></a>00644     assert(cpu_pkt-&gt;<a class="code" href="classPacket.html#a390c6cced05593f0a2c75a38a7a24fa9">needsResponse</a>());
<a name="l00645"></a>00645 
<a name="l00646"></a>00646     <a class="code" href="classMemCmd.html">MemCmd</a> cmd;
<a name="l00647"></a>00647     <span class="comment">// @TODO make useUpgrades a parameter.</span>
<a name="l00648"></a>00648     <span class="comment">// Note that ownership protocols require upgrade, otherwise a</span>
<a name="l00649"></a>00649     <span class="comment">// write miss on a shared owned block will generate a ReadExcl,</span>
<a name="l00650"></a>00650     <span class="comment">// which will clobber the owned copy.</span>
<a name="l00651"></a>00651     <span class="keyword">const</span> <span class="keywordtype">bool</span> useUpgrades = <span class="keyword">true</span>;
<a name="l00652"></a>00652     <span class="keywordflow">if</span> (blkValid &amp;&amp; useUpgrades) {
<a name="l00653"></a>00653         <span class="comment">// only reason to be here is that blk is shared</span>
<a name="l00654"></a>00654         <span class="comment">// (read-only) and we need exclusive</span>
<a name="l00655"></a>00655         assert(needsExclusive &amp;&amp; !blk-&gt;isWritable());
<a name="l00656"></a>00656         cmd = cpu_pkt-&gt;<a class="code" href="classPacket.html#a8965874e960faf91ad4b6af8dbf31875">isLLSC</a>() ? <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a26dd5b7b190f0af191e3d07399cbf1d5">MemCmd::SCUpgradeReq</a> : <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a4f223f365c25887900892b6c520ed89e">MemCmd::UpgradeReq</a>;
<a name="l00657"></a>00657     } <span class="keywordflow">else</span> {
<a name="l00658"></a>00658         <span class="comment">// block is invalid</span>
<a name="l00659"></a>00659         cmd = needsExclusive ? <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a9add93dbfe06a6be0bb0340705785f6c">MemCmd::ReadExReq</a> : <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a96120c772a9cb695fe62ca81ec93a53b">MemCmd::ReadReq</a>;
<a name="l00660"></a>00660     }
<a name="l00661"></a>00661     <a class="code" href="classPacket.html">PacketPtr</a> pkt = <span class="keyword">new</span> <a class="code" href="classPacket.html">Packet</a>(cpu_pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>, cmd, <a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a>);
<a name="l00662"></a>00662 
<a name="l00663"></a>00663     pkt-&gt;<a class="code" href="classPacket.html#acaefe811b78a2fdc4a0dba0c4029c3ef">allocate</a>();
<a name="l00664"></a>00664     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;%s created %s address %x size %d\n&quot;</span>,
<a name="l00665"></a>00665             __func__, pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(), pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), pkt-&gt;<a class="code" href="classPacket.html#a1d18ba49c7be427da1f4a42d53e35f48">getSize</a>());
<a name="l00666"></a>00666     <span class="keywordflow">return</span> pkt;
<a name="l00667"></a>00667 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3ce02537ee4a8918300802fda9b82b47"></a><!-- doxytag: member="Cache::getNextMSHR" ref="a3ce02537ee4a8918300802fda9b82b47" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMSHR.html">MSHR</a> * getNextMSHR </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the next <a class="el" href="classMSHR.html">MSHR</a> to service, either a pending miss from the mshrQueue, a buffered write from the write buffer, or something from the prefetcher. This function is responsible for prioritizing among those sources on the fly. </p>

<p><div class="fragment"><pre class="fragment"><a name="l01621"></a>01621 {
<a name="l01622"></a>01622     <span class="comment">// Check both MSHR queue and write buffer for potential requests</span>
<a name="l01623"></a>01623     <a class="code" href="classMSHR.html">MSHR</a> *miss_mshr  = <a class="code" href="classBaseCache.html#aa73933a75144caca7a7d3d77cf285c23">mshrQueue</a>.<a class="code" href="classMSHRQueue.html#a98b9ba341284c5251a7908cd45918066">getNextMSHR</a>();
<a name="l01624"></a>01624     <a class="code" href="classMSHR.html">MSHR</a> *write_mshr = <a class="code" href="classBaseCache.html#ad44ec41bd8517224df8584b5e7fbe372">writeBuffer</a>.<a class="code" href="classMSHRQueue.html#a98b9ba341284c5251a7908cd45918066">getNextMSHR</a>();
<a name="l01625"></a>01625 
<a name="l01626"></a>01626     <span class="comment">// Now figure out which one to send... some cases are easy</span>
<a name="l01627"></a>01627     <span class="keywordflow">if</span> (miss_mshr &amp;&amp; !write_mshr) {
<a name="l01628"></a>01628         <span class="keywordflow">return</span> miss_mshr;
<a name="l01629"></a>01629     }
<a name="l01630"></a>01630     <span class="keywordflow">if</span> (write_mshr &amp;&amp; !miss_mshr) {
<a name="l01631"></a>01631         <span class="keywordflow">return</span> write_mshr;
<a name="l01632"></a>01632     }
<a name="l01633"></a>01633 
<a name="l01634"></a>01634     <span class="keywordflow">if</span> (miss_mshr &amp;&amp; write_mshr) {
<a name="l01635"></a>01635         <span class="comment">// We have one of each... normally we favor the miss request</span>
<a name="l01636"></a>01636         <span class="comment">// unless the write buffer is full</span>
<a name="l01637"></a>01637         <span class="keywordflow">if</span> (<a class="code" href="classBaseCache.html#ad44ec41bd8517224df8584b5e7fbe372">writeBuffer</a>.<a class="code" href="classMSHRQueue.html#a7ffe8a6212a0eb3fc7bbc8e9bc51dfcd">isFull</a>() &amp;&amp; <a class="code" href="classBaseCache.html#ad44ec41bd8517224df8584b5e7fbe372">writeBuffer</a>.<a class="code" href="classMSHRQueue.html#aa4871243af391ed1f0d5e3f964bc13d0">inServiceEntries</a> == 0) {
<a name="l01638"></a>01638             <span class="comment">// Write buffer is full, so we&apos;d like to issue a write;</span>
<a name="l01639"></a>01639             <span class="comment">// need to search MSHR queue for conflicting earlier miss.</span>
<a name="l01640"></a>01640             <a class="code" href="classMSHR.html">MSHR</a> *conflict_mshr =
<a name="l01641"></a>01641                 <a class="code" href="classBaseCache.html#aa73933a75144caca7a7d3d77cf285c23">mshrQueue</a>.<a class="code" href="classMSHRQueue.html#affbbf09e05a34a8c06a00eeb8425be92">findPending</a>(write_mshr-&gt;<a class="code" href="classMSHR.html#a0bb77b4ba61e408313e1118250f9278c">addr</a>, write_mshr-&gt;<a class="code" href="classMSHR.html#a439227feff9d7f55384e8780cfc2eb82">size</a>,
<a name="l01642"></a>01642                                       write_mshr-&gt;<a class="code" href="classMSHR.html#a62bc84f4251f16cf0cfa0f8d96e00c37">isSecure</a>);
<a name="l01643"></a>01643 
<a name="l01644"></a>01644             <span class="keywordflow">if</span> (conflict_mshr &amp;&amp; conflict_mshr-&gt;<a class="code" href="classMSHR.html#a268baba59d9078c070be7059fd90d9bc">order</a> &lt; write_mshr-&gt;<a class="code" href="classMSHR.html#a268baba59d9078c070be7059fd90d9bc">order</a>) {
<a name="l01645"></a>01645                 <span class="comment">// Service misses in order until conflict is cleared.</span>
<a name="l01646"></a>01646                 <span class="keywordflow">return</span> conflict_mshr;
<a name="l01647"></a>01647             }
<a name="l01648"></a>01648 
<a name="l01649"></a>01649             <span class="comment">// No conflicts; issue write</span>
<a name="l01650"></a>01650             <span class="keywordflow">return</span> write_mshr;
<a name="l01651"></a>01651         }
<a name="l01652"></a>01652 
<a name="l01653"></a>01653         <span class="comment">// Write buffer isn&apos;t full, but need to check it for</span>
<a name="l01654"></a>01654         <span class="comment">// conflicting earlier writeback</span>
<a name="l01655"></a>01655         <a class="code" href="classMSHR.html">MSHR</a> *conflict_mshr =
<a name="l01656"></a>01656             <a class="code" href="classBaseCache.html#ad44ec41bd8517224df8584b5e7fbe372">writeBuffer</a>.<a class="code" href="classMSHRQueue.html#affbbf09e05a34a8c06a00eeb8425be92">findPending</a>(miss_mshr-&gt;<a class="code" href="classMSHR.html#a0bb77b4ba61e408313e1118250f9278c">addr</a>, miss_mshr-&gt;<a class="code" href="classMSHR.html#a439227feff9d7f55384e8780cfc2eb82">size</a>,
<a name="l01657"></a>01657                                     miss_mshr-&gt;<a class="code" href="classMSHR.html#a62bc84f4251f16cf0cfa0f8d96e00c37">isSecure</a>);
<a name="l01658"></a>01658         <span class="keywordflow">if</span> (conflict_mshr) {
<a name="l01659"></a>01659             <span class="comment">// not sure why we don&apos;t check order here... it was in the</span>
<a name="l01660"></a>01660             <span class="comment">// original code but commented out.</span>
<a name="l01661"></a>01661 
<a name="l01662"></a>01662             <span class="comment">// The only way this happens is if we are</span>
<a name="l01663"></a>01663             <span class="comment">// doing a write and we didn&apos;t have permissions</span>
<a name="l01664"></a>01664             <span class="comment">// then subsequently saw a writeback (owned got evicted)</span>
<a name="l01665"></a>01665             <span class="comment">// We need to make sure to perform the writeback first</span>
<a name="l01666"></a>01666             <span class="comment">// To preserve the dirty data, then we can issue the write</span>
<a name="l01667"></a>01667 
<a name="l01668"></a>01668             <span class="comment">// should we return write_mshr here instead?  I.e. do we</span>
<a name="l01669"></a>01669             <span class="comment">// have to flush writes in order?  I don&apos;t think so... not</span>
<a name="l01670"></a>01670             <span class="comment">// for Alpha anyway.  Maybe for x86?</span>
<a name="l01671"></a>01671             <span class="keywordflow">return</span> conflict_mshr;
<a name="l01672"></a>01672         }
<a name="l01673"></a>01673 
<a name="l01674"></a>01674         <span class="comment">// No conflicts; issue read</span>
<a name="l01675"></a>01675         <span class="keywordflow">return</span> miss_mshr;
<a name="l01676"></a>01676     }
<a name="l01677"></a>01677 
<a name="l01678"></a>01678     <span class="comment">// fall through... no pending requests.  Try a prefetch.</span>
<a name="l01679"></a>01679     assert(!miss_mshr &amp;&amp; !write_mshr);
<a name="l01680"></a>01680     <span class="keywordflow">if</span> (<a class="code" href="classCache.html#a320f5a2352104b9b633113f9045461a3">prefetcher</a> &amp;&amp; !<a class="code" href="classBaseCache.html#aa73933a75144caca7a7d3d77cf285c23">mshrQueue</a>.<a class="code" href="classMSHRQueue.html#a7ffe8a6212a0eb3fc7bbc8e9bc51dfcd">isFull</a>()) {
<a name="l01681"></a>01681         <span class="comment">// If we have a miss queue slot, we can try a prefetch</span>
<a name="l01682"></a>01682         <a class="code" href="classPacket.html">PacketPtr</a> pkt = <a class="code" href="classCache.html#a320f5a2352104b9b633113f9045461a3">prefetcher</a>-&gt;<a class="code" href="classBasePrefetcher.html#a248e1528ea5a374640182955f4793d3f">getPacket</a>();
<a name="l01683"></a>01683         <span class="keywordflow">if</span> (pkt) {
<a name="l01684"></a>01684             <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> pf_addr = <a class="code" href="classBaseCache.html#a676df8321350e810fc857d99cdcebc22">blockAlign</a>(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>());
<a name="l01685"></a>01685             <span class="keywordflow">if</span> (!<a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;findBlock(pf_addr, pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>()) &amp;&amp;
<a name="l01686"></a>01686                 !<a class="code" href="classBaseCache.html#aa73933a75144caca7a7d3d77cf285c23">mshrQueue</a>.<a class="code" href="classMSHRQueue.html#aab842d63dcd254dfe655e16075f7e0fe">findMatch</a>(pf_addr, pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>()) &amp;&amp;
<a name="l01687"></a>01687                 !<a class="code" href="classBaseCache.html#ad44ec41bd8517224df8584b5e7fbe372">writeBuffer</a>.<a class="code" href="classMSHRQueue.html#aab842d63dcd254dfe655e16075f7e0fe">findMatch</a>(pf_addr, pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>())) {
<a name="l01688"></a>01688                 <span class="comment">// Update statistic on number of prefetches issued</span>
<a name="l01689"></a>01689                 <span class="comment">// (hwpf_mshr_misses)</span>
<a name="l01690"></a>01690                 assert(pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a9b7d32db0521388c0953e531c79aab50">masterId</a>() &lt; <a class="code" href="classBaseCache.html#af27ccd765f13a4b7bd119dc7579e2746">system</a>-&gt;<a class="code" href="classSystem.html#a4cd916c36458ce47e9ba4ccbfc75a095">maxMasters</a>());
<a name="l01691"></a>01691                 <a class="code" href="group__CacheStatistics.html#gaececf7d3c236db3a8f26999e5330a7f8">mshr_misses</a>[pkt-&gt;<a class="code" href="classPacket.html#a8db75870e65b9d86793f2805097c05a0" title="Return the index of this command.">cmdToIndex</a>()][pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a9b7d32db0521388c0953e531c79aab50">masterId</a>()]++;
<a name="l01692"></a>01692                 <span class="comment">// Don&apos;t request bus, since we already have it</span>
<a name="l01693"></a>01693                 <span class="keywordflow">return</span> <a class="code" href="classBaseCache.html#ac37432bbe5fab7cdf422ee29acf155f2">allocateMissBuffer</a>(pkt, <a class="code" href="statistics_8hh.html#a7acdccbf0d35ce0c159c0cdd36371b22" title="The universal simulation clock.">curTick</a>(), <span class="keyword">false</span>);
<a name="l01694"></a>01694             } <span class="keywordflow">else</span> {
<a name="l01695"></a>01695                 <span class="comment">// free the request and packet</span>
<a name="l01696"></a>01696                 <span class="keyword">delete</span> pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>;
<a name="l01697"></a>01697                 <span class="keyword">delete</span> pkt;
<a name="l01698"></a>01698             }
<a name="l01699"></a>01699         }
<a name="l01700"></a>01700     }
<a name="l01701"></a>01701 
<a name="l01702"></a>01702     <span class="keywordflow">return</span> <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l01703"></a>01703 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a52bd0127c43c9167c1d092fc060cc472"></a><!-- doxytag: member="Cache::getTimingPacket" ref="a52bd0127c43c9167c1d092fc060cc472" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPacket.html">PacketPtr</a> getTimingPacket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Selects an outstanding request to service. Called when the cache gets granted the downstream bus in timing mode. </p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>The request to service, NULL if none found. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01709"></a>01709 {
<a name="l01710"></a>01710     <a class="code" href="classMSHR.html">MSHR</a> *mshr = <a class="code" href="classCache.html#a3ce02537ee4a8918300802fda9b82b47">getNextMSHR</a>();
<a name="l01711"></a>01711 
<a name="l01712"></a>01712     <span class="keywordflow">if</span> (mshr == <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>) {
<a name="l01713"></a>01713         <span class="keywordflow">return</span> <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l01714"></a>01714     }
<a name="l01715"></a>01715 
<a name="l01716"></a>01716     <span class="comment">// use request from 1st target</span>
<a name="l01717"></a>01717     <a class="code" href="classPacket.html">PacketPtr</a> tgt_pkt = mshr-&gt;<a class="code" href="classMSHR.html#ae068bab5bed8991efdfcd7829d9ca5e3">getTarget</a>()-&gt;pkt;
<a name="l01718"></a>01718     <a class="code" href="classPacket.html">PacketPtr</a> pkt = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l01719"></a>01719 
<a name="l01720"></a>01720     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(CachePort, <span class="stringliteral">&quot;%s %s for address %x size %d\n&quot;</span>, __func__,
<a name="l01721"></a>01721             tgt_pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(), tgt_pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), tgt_pkt-&gt;<a class="code" href="classPacket.html#a1d18ba49c7be427da1f4a42d53e35f48">getSize</a>());
<a name="l01722"></a>01722 
<a name="l01723"></a>01723     <span class="keywordflow">if</span> (tgt_pkt-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153ac6ef7b72a17dbdd8c061094bf7554753">MemCmd::SCUpgradeFailReq</a> ||
<a name="l01724"></a>01724         tgt_pkt-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a74dd6ebac6e139815fdc22edbae3cce3">MemCmd::StoreCondFailReq</a>) {
<a name="l01725"></a>01725         <span class="comment">// SCUpgradeReq or StoreCondReq saw invalidation while queued</span>
<a name="l01726"></a>01726         <span class="comment">// in MSHR, so now that we are getting around to processing</span>
<a name="l01727"></a>01727         <span class="comment">// it, just treat it as if we got a failure response</span>
<a name="l01728"></a>01728         pkt = <span class="keyword">new</span> <a class="code" href="classPacket.html">Packet</a>(tgt_pkt);
<a name="l01729"></a>01729         pkt-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> = <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153acf35994719250044eeb50aa07d996ed6">MemCmd::UpgradeFailResp</a>;
<a name="l01730"></a>01730         pkt-&gt;<a class="code" href="classPacket.html#a983ade0479f946c813284dcc65073367">senderState</a> = mshr;
<a name="l01731"></a>01731         pkt-&gt;<a class="code" href="classPacket.html#af8986a05caa6c5b96b0b01bb6cf47772">busFirstWordDelay</a> = pkt-&gt;<a class="code" href="classPacket.html#a7bf8ae0a056329f751eda8b39ca4c268">busLastWordDelay</a> = 0;
<a name="l01732"></a>01732         <a class="code" href="classCache.html#a083c4da6cf866d660a126f4174bba7fc">recvTimingResp</a>(pkt);
<a name="l01733"></a>01733         <span class="keywordflow">return</span> <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l01734"></a>01734     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mshr-&gt;<a class="code" href="classMSHR.html#aee2f7196808cfdd31122d93d11b633de">isForwardNoResponse</a>()) {
<a name="l01735"></a>01735         <span class="comment">// no response expected, just forward packet as it is</span>
<a name="l01736"></a>01736         assert(<a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;findBlock(mshr-&gt;<a class="code" href="classMSHR.html#a0bb77b4ba61e408313e1118250f9278c">addr</a>, mshr-&gt;<a class="code" href="classMSHR.html#a62bc84f4251f16cf0cfa0f8d96e00c37">isSecure</a>) == <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>);
<a name="l01737"></a>01737         pkt = tgt_pkt;
<a name="l01738"></a>01738     } <span class="keywordflow">else</span> {
<a name="l01739"></a>01739         <a class="code" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *blk = <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;findBlock(mshr-&gt;<a class="code" href="classMSHR.html#a0bb77b4ba61e408313e1118250f9278c">addr</a>, mshr-&gt;<a class="code" href="classMSHR.html#a62bc84f4251f16cf0cfa0f8d96e00c37">isSecure</a>);
<a name="l01740"></a>01740 
<a name="l01741"></a>01741         <span class="keywordflow">if</span> (tgt_pkt-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153af939e2f740d217d26e90546059593b39">MemCmd::HardPFReq</a>) {
<a name="l01742"></a>01742             <span class="comment">// It might be possible for a writeback to arrive between</span>
<a name="l01743"></a>01743             <span class="comment">// the time the prefetch is placed in the MSHRs and when</span>
<a name="l01744"></a>01744             <span class="comment">// it&apos;s selected to send... if so, this assert will catch</span>
<a name="l01745"></a>01745             <span class="comment">// that, and then we&apos;ll have to figure out what to do.</span>
<a name="l01746"></a>01746             assert(blk == <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>);
<a name="l01747"></a>01747 
<a name="l01748"></a>01748             <span class="comment">// We need to check the caches above us to verify that</span>
<a name="l01749"></a>01749             <span class="comment">// they don&apos;t have a copy of this block in the dirty state</span>
<a name="l01750"></a>01750             <span class="comment">// at the moment. Without this check we could get a stale</span>
<a name="l01751"></a>01751             <span class="comment">// copy from memory that might get used in place of the</span>
<a name="l01752"></a>01752             <span class="comment">// dirty one.</span>
<a name="l01753"></a>01753             <a class="code" href="classPacket.html">Packet</a> snoop_pkt(tgt_pkt, <span class="keyword">true</span>);
<a name="l01754"></a>01754             snoop_pkt.setExpressSnoop();
<a name="l01755"></a>01755             snoop_pkt.senderState = mshr;
<a name="l01756"></a>01756             <a class="code" href="classBaseCache.html#a14913ffff181227d085f25a95e6ada42">cpuSidePort</a>-&gt;<a class="code" href="classSlavePort.html#a44317ff11e2c240ae72ca2f5f1d9076d">sendTimingSnoopReq</a>(&amp;snoop_pkt);
<a name="l01757"></a>01757 
<a name="l01758"></a>01758             <span class="comment">// Check to see if the prefetch was squashed by an upper cache</span>
<a name="l01759"></a>01759             <span class="keywordflow">if</span> (snoop_pkt.prefetchSquashed()) {
<a name="l01760"></a>01760                 <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;Prefetch squashed by upper cache.  &quot;</span>
<a name="l01761"></a>01761                                <span class="stringliteral">&quot;Deallocating mshr target %#x.\n&quot;</span>, mshr-&gt;<a class="code" href="classMSHR.html#a0bb77b4ba61e408313e1118250f9278c">addr</a>);
<a name="l01762"></a>01762 
<a name="l01763"></a>01763                 <span class="comment">// Deallocate the mshr target</span>
<a name="l01764"></a>01764                 <span class="keywordflow">if</span> (mshr-&gt;<a class="code" href="classMSHR.html#a524ec1b0c7b11e23904171e42211679e">queue</a>-&gt;<a class="code" href="classMSHRQueue.html#acda43ebd9ff1813951d7d0ab3eaad05c">forceDeallocateTarget</a>(mshr)) {
<a name="l01765"></a>01765                     <span class="comment">// Clear block if this deallocation resulted freed an</span>
<a name="l01766"></a>01766                     <span class="comment">// mshr when all had previously been utilized</span>
<a name="l01767"></a>01767                     <a class="code" href="classBaseCache.html#a78948a7bd2b849859bfc6fee2fc3d070">clearBlocked</a>((<a class="code" href="classBaseCache.html#a98297f294858ead7eafd19af93e64c6d">BlockedCause</a>)(mshr-&gt;<a class="code" href="classMSHR.html#a524ec1b0c7b11e23904171e42211679e">queue</a>-&gt;<a class="code" href="classMSHRQueue.html#a32b76ccceab9e1bba3e8c4ef2947d1d8">index</a>));
<a name="l01768"></a>01768                 }
<a name="l01769"></a>01769                 <span class="keywordflow">return</span> <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l01770"></a>01770             }
<a name="l01771"></a>01771 
<a name="l01772"></a>01772             <span class="keywordflow">if</span> (snoop_pkt.memInhibitAsserted()) {
<a name="l01773"></a>01773                 <a class="code" href="classCache.html#ac7fb6ca824d25de54878584fd9dd8162">markInService</a>(mshr, &amp;snoop_pkt);
<a name="l01774"></a>01774                 <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;Upward snoop of prefetch for addr&quot;</span>
<a name="l01775"></a>01775                         <span class="stringliteral">&quot; %#x (%s) hit\n&quot;</span>,
<a name="l01776"></a>01776                         tgt_pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), tgt_pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>()? <span class="stringliteral">&quot;s&quot;</span>: <span class="stringliteral">&quot;ns&quot;</span>);
<a name="l01777"></a>01777                 <span class="keywordflow">return</span> <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l01778"></a>01778             }
<a name="l01779"></a>01779         }
<a name="l01780"></a>01780 
<a name="l01781"></a>01781         pkt = <a class="code" href="classCache.html#a3bdcf30020fcb7b18e1d1f95cc86648e">getBusPacket</a>(tgt_pkt, blk, mshr-&gt;<a class="code" href="classMSHR.html#aa8e449288b878ff3ff7f286eb4d28b6a">needsExclusive</a>());
<a name="l01782"></a>01782 
<a name="l01783"></a>01783         mshr-&gt;<a class="code" href="classMSHR.html#a9b36b981f171b10bc35fbd5f79c3bae1">isForward</a> = (pkt == <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>);
<a name="l01784"></a>01784 
<a name="l01785"></a>01785         <span class="keywordflow">if</span> (mshr-&gt;<a class="code" href="classMSHR.html#a9b36b981f171b10bc35fbd5f79c3bae1">isForward</a>) {
<a name="l01786"></a>01786             <span class="comment">// not a cache block request, but a response is expected</span>
<a name="l01787"></a>01787             <span class="comment">// make copy of current packet to forward, keep current</span>
<a name="l01788"></a>01788             <span class="comment">// copy for response handling</span>
<a name="l01789"></a>01789             pkt = <span class="keyword">new</span> <a class="code" href="classPacket.html">Packet</a>(tgt_pkt);
<a name="l01790"></a>01790             pkt-&gt;<a class="code" href="classPacket.html#acaefe811b78a2fdc4a0dba0c4029c3ef">allocate</a>();
<a name="l01791"></a>01791             <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#ab699d2f0d186312531fd1c279fd27b73">isWrite</a>()) {
<a name="l01792"></a>01792                 pkt-&gt;<a class="code" href="classPacket.html#aaa0b1cd19807fc630d9331be9f5d1d36">setData</a>(tgt_pkt-&gt;<a class="code" href="classPacket.html#a5c451baf3f0a89084e79e69bb9061200">getPtr</a>&lt;uint8_t&gt;());
<a name="l01793"></a>01793             }
<a name="l01794"></a>01794         }
<a name="l01795"></a>01795     }
<a name="l01796"></a>01796 
<a name="l01797"></a>01797     assert(pkt != <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>);
<a name="l01798"></a>01798     pkt-&gt;<a class="code" href="classPacket.html#a983ade0479f946c813284dcc65073367">senderState</a> = mshr;
<a name="l01799"></a>01799     <span class="keywordflow">return</span> pkt;
<a name="l01800"></a>01800 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4943b9a8a4801f454a968416b456dc21"></a><!-- doxytag: member="Cache::handleFill" ref="a4943b9a8a4801f454a968416b456dc21" args="(PacketPtr pkt, BlkType *blk, PacketList &amp;writebacks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCache.html">Cache</a>&lt; TagStore &gt;::<a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> * handleFill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *&nbsp;</td>
          <td class="paramname"> <em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstd_1_1list.html">PacketList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writebacks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Populates a cache block and handles all outstanding requests for the satisfied fill request. This version takes two memory requests. One contains the fill data, the other is an optional target to satisfy. </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td>The memory request with the fill data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blk</em>&nbsp;</td><td>The cache block if it already exists. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>writebacks</em>&nbsp;</td><td>List for any writebacks that need to be performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Pointer to the new cache block. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01245"></a>01245 {
<a name="l01246"></a>01246     <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a> = pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>();
<a name="l01247"></a>01247     <span class="keywordtype">bool</span> is_secure = pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>();
<a name="l01248"></a>01248 <span class="preprocessor">#if TRACING_ON</span>
<a name="l01249"></a>01249 <span class="preprocessor"></span>    <a class="code" href="classCacheBlk.html#a09dbc3a4ce615f45c897d9ee6fbffb2a">CacheBlk::State</a> old_state = blk ? blk-&gt;status : 0;
<a name="l01250"></a>01250 <span class="preprocessor">#endif</span>
<a name="l01251"></a>01251 <span class="preprocessor"></span>
<a name="l01252"></a>01252     <span class="keywordflow">if</span> (blk == <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>) {
<a name="l01253"></a>01253         <span class="comment">// better have read new data...</span>
<a name="l01254"></a>01254         assert(pkt-&gt;<a class="code" href="classPacket.html#a0effbd4cf91891700ac41e86defe4aa6">hasData</a>());
<a name="l01255"></a>01255         <span class="comment">// need to do a replacement</span>
<a name="l01256"></a>01256         blk = <a class="code" href="classCache.html#a3da8f395921d5519e28d1c60961ae6c5">allocateBlock</a>(addr, is_secure, writebacks);
<a name="l01257"></a>01257         <span class="keywordflow">if</span> (blk == <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>) {
<a name="l01258"></a>01258             <span class="comment">// No replaceable block... just use temporary storage to</span>
<a name="l01259"></a>01259             <span class="comment">// complete the current request and then get rid of it</span>
<a name="l01260"></a>01260             assert(!<a class="code" href="classCache.html#a0ca2086b66114357dd17032178adce17">tempBlock</a>-&gt;isValid());
<a name="l01261"></a>01261             blk = <a class="code" href="classCache.html#a0ca2086b66114357dd17032178adce17">tempBlock</a>;
<a name="l01262"></a>01262             <a class="code" href="classCache.html#a0ca2086b66114357dd17032178adce17">tempBlock</a>-&gt;set = <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;extractSet(addr);
<a name="l01263"></a>01263             <a class="code" href="classCache.html#a0ca2086b66114357dd17032178adce17">tempBlock</a>-&gt;tag = <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;extractTag(addr);
<a name="l01264"></a>01264             <span class="comment">// @todo: set security state as well...</span>
<a name="l01265"></a>01265             <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;using temp block for %x (%s)\n&quot;</span>, addr,
<a name="l01266"></a>01266                     is_secure ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;ns&quot;</span>);
<a name="l01267"></a>01267         } <span class="keywordflow">else</span> {
<a name="l01268"></a>01268             <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;insertBlock(pkt, blk);
<a name="l01269"></a>01269         }
<a name="l01270"></a>01270 
<a name="l01271"></a>01271         <span class="comment">// we should never be overwriting a valid block</span>
<a name="l01272"></a>01272         assert(!blk-&gt;isValid());
<a name="l01273"></a>01273     } <span class="keywordflow">else</span> {
<a name="l01274"></a>01274         <span class="comment">// existing block... probably an upgrade</span>
<a name="l01275"></a>01275         assert(blk-&gt;tag == <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;extractTag(addr));
<a name="l01276"></a>01276         <span class="comment">// either we&apos;re getting new data or the block should already be valid</span>
<a name="l01277"></a>01277         assert(pkt-&gt;<a class="code" href="classPacket.html#a0effbd4cf91891700ac41e86defe4aa6">hasData</a>() || blk-&gt;isValid());
<a name="l01278"></a>01278         <span class="comment">// don&apos;t clear block status... if block is already dirty we</span>
<a name="l01279"></a>01279         <span class="comment">// don&apos;t want to lose that</span>
<a name="l01280"></a>01280     }
<a name="l01281"></a>01281 
<a name="l01282"></a>01282     <span class="keywordflow">if</span> (is_secure)
<a name="l01283"></a>01283         blk-&gt;status |= <a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7ae61b87ec40871a2ddb384c14fc1e46e2">BlkSecure</a>;
<a name="l01284"></a>01284     blk-&gt;status |= <a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7acd687680ed8ee756c990233bd44ccc7a">BlkValid</a> | <a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7ac413eacf0a0c4c85665e24fc3138ad50">BlkReadable</a>;
<a name="l01285"></a>01285 
<a name="l01286"></a>01286     <span class="keywordflow">if</span> (!pkt-&gt;<a class="code" href="classPacket.html#a298938bfa2613955b13f630ce2b591e4">sharedAsserted</a>()) {
<a name="l01287"></a>01287         blk-&gt;status |= <a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7a202d95c1090db0082a7a954856ad5358">BlkWritable</a>;
<a name="l01288"></a>01288         <span class="comment">// If we got this via cache-to-cache transfer (i.e., from a</span>
<a name="l01289"></a>01289         <span class="comment">// cache that was an owner) and took away that owner&apos;s copy,</span>
<a name="l01290"></a>01290         <span class="comment">// then we need to write it back.  Normally this happens</span>
<a name="l01291"></a>01291         <span class="comment">// anyway as a side effect of getting a copy to write it, but</span>
<a name="l01292"></a>01292         <span class="comment">// there are cases (such as failed store conditionals or</span>
<a name="l01293"></a>01293         <span class="comment">// compare-and-swaps) where we&apos;ll demand an exclusive copy but</span>
<a name="l01294"></a>01294         <span class="comment">// end up not writing it.</span>
<a name="l01295"></a>01295         <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a9693a1ffeda326646443ab2a2a92be41">memInhibitAsserted</a>())
<a name="l01296"></a>01296             blk-&gt;status |= <a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7a87715983fd384f5ee41ec0608f5c6e5f">BlkDirty</a>;
<a name="l01297"></a>01297     }
<a name="l01298"></a>01298 
<a name="l01299"></a>01299     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;Block addr %x (%s) moving from state %x to %s\n&quot;</span>,
<a name="l01300"></a>01300             addr, is_secure ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;ns&quot;</span>, old_state, blk-&gt;print());
<a name="l01301"></a>01301 
<a name="l01302"></a>01302     <span class="comment">// if we got new data, copy it in</span>
<a name="l01303"></a>01303     <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#adc47901747fc3c447db3abddaf01491a">isRead</a>()) {
<a name="l01304"></a>01304         std::memcpy(blk-&gt;data, pkt-&gt;<a class="code" href="classPacket.html#a5c451baf3f0a89084e79e69bb9061200">getPtr</a>&lt;uint8_t&gt;(), <a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a>);
<a name="l01305"></a>01305     }
<a name="l01306"></a>01306 
<a name="l01307"></a>01307     blk-&gt;whenReady = <a class="code" href="classClockedObject.html#a773956693f216cafb7d4cad92ad582e5">clockEdge</a>() + <a class="code" href="classBaseCache.html#ab3672589b3ea30e547b2a30f50d814eb">responseLatency</a> * <a class="code" href="classClockedObject.html#a78c89cef17196c60470c4f2f76d43d8a">clockPeriod</a>() +
<a name="l01308"></a>01308         pkt-&gt;<a class="code" href="classPacket.html#a7bf8ae0a056329f751eda8b39ca4c268">busLastWordDelay</a>;
<a name="l01309"></a>01309 
<a name="l01310"></a>01310     <span class="keywordflow">return</span> blk;
<a name="l01311"></a>01311 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="affa22df454ca8619381018b222c49c2d"></a><!-- doxytag: member="Cache::handleSnoop" ref="affa22df454ca8619381018b222c49c2d" args="(PacketPtr ptk, BlkType *blk, bool is_timing, bool is_deferred, bool pending_inval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handleSnoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>ptk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *&nbsp;</td>
          <td class="paramname"> <em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_timing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_deferred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pending_inval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the blk to the new state. </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blk</em>&nbsp;</td><td>The cache block being snooped. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_state</em>&nbsp;</td><td>The new coherence state for the block. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01359"></a>01359 {
<a name="l01360"></a>01360     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;%s for %s address %x size %d\n&quot;</span>, __func__,
<a name="l01361"></a>01361             pkt-&gt;cmdString(), pkt-&gt;getAddr(), pkt-&gt;getSize());
<a name="l01362"></a>01362     <span class="comment">// deferred snoops can only happen in timing mode</span>
<a name="l01363"></a>01363     assert(!(is_deferred &amp;&amp; !is_timing));
<a name="l01364"></a>01364     <span class="comment">// pending_inval only makes sense on deferred snoops</span>
<a name="l01365"></a>01365     assert(!(pending_inval &amp;&amp; !is_deferred));
<a name="l01366"></a>01366     assert(pkt-&gt;isRequest());
<a name="l01367"></a>01367 
<a name="l01368"></a>01368     <span class="comment">// the packet may get modified if we or a forwarded snooper</span>
<a name="l01369"></a>01369     <span class="comment">// responds in atomic mode, so remember a few things about the</span>
<a name="l01370"></a>01370     <span class="comment">// original packet up front</span>
<a name="l01371"></a>01371     <span class="keywordtype">bool</span> invalidate = pkt-&gt;isInvalidate();
<a name="l01372"></a>01372     <span class="keywordtype">bool</span> M5_VAR_USED needs_exclusive = pkt-&gt;needsExclusive();
<a name="l01373"></a>01373 
<a name="l01374"></a>01374     <span class="keywordflow">if</span> (<a class="code" href="classBaseCache.html#ac8d6ebb7f62e1afe78ddc7c774316d66">forwardSnoops</a>) {
<a name="l01375"></a>01375         <span class="comment">// first propagate snoop upward to see if anyone above us wants to</span>
<a name="l01376"></a>01376         <span class="comment">// handle it.  save &amp; restore packet src since it will get</span>
<a name="l01377"></a>01377         <span class="comment">// rewritten to be relative to cpu-side bus (if any)</span>
<a name="l01378"></a>01378         <span class="keywordtype">bool</span> alreadyResponded = pkt-&gt;memInhibitAsserted();
<a name="l01379"></a>01379         <span class="keywordflow">if</span> (is_timing) {
<a name="l01380"></a>01380             <a class="code" href="classPacket.html">Packet</a> snoopPkt(pkt, <span class="keyword">true</span>);  <span class="comment">// clear flags</span>
<a name="l01381"></a>01381             snoopPkt.setExpressSnoop();
<a name="l01382"></a>01382             snoopPkt.pushSenderState(<span class="keyword">new</span> <a class="code" href="classForwardResponseRecord.html">ForwardResponseRecord</a>(pkt-&gt;getSrc()));
<a name="l01383"></a>01383             <span class="comment">// the snoop packet does not need to wait any additional</span>
<a name="l01384"></a>01384             <span class="comment">// time</span>
<a name="l01385"></a>01385             snoopPkt.busFirstWordDelay = snoopPkt.busLastWordDelay = 0;
<a name="l01386"></a>01386             <a class="code" href="classBaseCache.html#a14913ffff181227d085f25a95e6ada42">cpuSidePort</a>-&gt;<a class="code" href="classSlavePort.html#a44317ff11e2c240ae72ca2f5f1d9076d">sendTimingSnoopReq</a>(&amp;snoopPkt);
<a name="l01387"></a>01387             <span class="keywordflow">if</span> (snoopPkt.memInhibitAsserted()) {
<a name="l01388"></a>01388                 <span class="comment">// cache-to-cache response from some upper cache</span>
<a name="l01389"></a>01389                 assert(!alreadyResponded);
<a name="l01390"></a>01390                 pkt-&gt;assertMemInhibit();
<a name="l01391"></a>01391             } <span class="keywordflow">else</span> {
<a name="l01392"></a>01392                 <span class="keyword">delete</span> snoopPkt.popSenderState();
<a name="l01393"></a>01393             }
<a name="l01394"></a>01394             <span class="keywordflow">if</span> (snoopPkt.sharedAsserted()) {
<a name="l01395"></a>01395                 pkt-&gt;assertShared();
<a name="l01396"></a>01396             }
<a name="l01397"></a>01397             <span class="comment">// If this request is a prefetch and an</span>
<a name="l01398"></a>01398             <span class="comment">// upper level squashes the prefetch request,</span>
<a name="l01399"></a>01399             <span class="comment">// make sure to propogate the squash to the requester.</span>
<a name="l01400"></a>01400             <span class="keywordflow">if</span> (snoopPkt.prefetchSquashed()) {
<a name="l01401"></a>01401                 pkt-&gt;setPrefetchSquashed();
<a name="l01402"></a>01402             }
<a name="l01403"></a>01403         } <span class="keywordflow">else</span> {
<a name="l01404"></a>01404             <a class="code" href="classBaseCache.html#a14913ffff181227d085f25a95e6ada42">cpuSidePort</a>-&gt;<a class="code" href="classSlavePort.html#a4cc4d76bd3aaf333980c232125c8acc8">sendAtomicSnoop</a>(pkt);
<a name="l01405"></a>01405             <span class="keywordflow">if</span> (!alreadyResponded &amp;&amp; pkt-&gt;memInhibitAsserted()) {
<a name="l01406"></a>01406                 <span class="comment">// cache-to-cache response from some upper cache:</span>
<a name="l01407"></a>01407                 <span class="comment">// forward response to original requester</span>
<a name="l01408"></a>01408                 assert(pkt-&gt;isResponse());
<a name="l01409"></a>01409             }
<a name="l01410"></a>01410         }
<a name="l01411"></a>01411     }
<a name="l01412"></a>01412 
<a name="l01413"></a>01413      <span class="keywordflow">if</span> (!blk || !blk-&gt;isValid()) {
<a name="l01414"></a>01414          <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;%s snoop miss for %s address %x size %d\n&quot;</span>,
<a name="l01415"></a>01415                  __func__, pkt-&gt;cmdString(), pkt-&gt;getAddr(), pkt-&gt;getSize());
<a name="l01416"></a>01416          <span class="keywordflow">return</span>;
<a name="l01417"></a>01417      } <span class="keywordflow">else</span> {
<a name="l01418"></a>01418         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;%s snoop hit for %s for address %x size %d, &quot;</span>
<a name="l01419"></a>01419                 <span class="stringliteral">&quot;old state is %s\n&quot;</span>, __func__, pkt-&gt;cmdString(),
<a name="l01420"></a>01420                 pkt-&gt;getAddr(), pkt-&gt;getSize(), blk-&gt;print());
<a name="l01421"></a>01421      }
<a name="l01422"></a>01422 
<a name="l01423"></a>01423     <span class="comment">// we may end up modifying both the block state and the packet (if</span>
<a name="l01424"></a>01424     <span class="comment">// we respond in atomic mode), so just figure out what to do now</span>
<a name="l01425"></a>01425     <span class="comment">// and then do it later</span>
<a name="l01426"></a>01426     <span class="keywordtype">bool</span> respond = blk-&gt;isDirty() &amp;&amp; pkt-&gt;needsResponse();
<a name="l01427"></a>01427     <span class="keywordtype">bool</span> have_exclusive = blk-&gt;isWritable();
<a name="l01428"></a>01428 
<a name="l01429"></a>01429     <span class="comment">// Invalidate any prefetch&apos;s from below that would strip write permissions</span>
<a name="l01430"></a>01430     <span class="comment">// MemCmd::HardPFReq is only observed by upstream caches.  After missing</span>
<a name="l01431"></a>01431     <span class="comment">// above and in it&apos;s own cache, a new MemCmd::ReadReq is created that</span>
<a name="l01432"></a>01432     <span class="comment">// downstream caches observe.</span>
<a name="l01433"></a>01433     <span class="keywordflow">if</span> (pkt-&gt;cmd == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153af939e2f740d217d26e90546059593b39">MemCmd::HardPFReq</a>) {
<a name="l01434"></a>01434         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;Squashing prefetch from lower cache %#x\n&quot;</span>,
<a name="l01435"></a>01435                 pkt-&gt;getAddr());
<a name="l01436"></a>01436         pkt-&gt;setPrefetchSquashed();
<a name="l01437"></a>01437         <span class="keywordflow">return</span>;
<a name="l01438"></a>01438     }
<a name="l01439"></a>01439 
<a name="l01440"></a>01440     <span class="keywordflow">if</span> (pkt-&gt;isRead() &amp;&amp; !invalidate) {
<a name="l01441"></a>01441         assert(!needs_exclusive);
<a name="l01442"></a>01442         pkt-&gt;assertShared();
<a name="l01443"></a>01443         <span class="keywordtype">int</span> bits_to_clear = <a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7a202d95c1090db0082a7a954856ad5358">BlkWritable</a>;
<a name="l01444"></a>01444         <span class="keyword">const</span> <span class="keywordtype">bool</span> haveOwnershipState = <span class="keyword">true</span>; <span class="comment">// for now</span>
<a name="l01445"></a>01445         <span class="keywordflow">if</span> (!haveOwnershipState) {
<a name="l01446"></a>01446             <span class="comment">// if we don&apos;t support pure ownership (dirty &amp;&amp; !writable),</span>
<a name="l01447"></a>01447             <span class="comment">// have to clear dirty bit here, assume memory snarfs data</span>
<a name="l01448"></a>01448             <span class="comment">// on cache-to-cache xfer</span>
<a name="l01449"></a>01449             bits_to_clear |= <a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7a87715983fd384f5ee41ec0608f5c6e5f">BlkDirty</a>;
<a name="l01450"></a>01450         }
<a name="l01451"></a>01451         blk-&gt;status &amp;= ~bits_to_clear;
<a name="l01452"></a>01452     }
<a name="l01453"></a>01453 
<a name="l01454"></a>01454     <span class="keywordflow">if</span> (respond) {
<a name="l01455"></a>01455         assert(!pkt-&gt;memInhibitAsserted());
<a name="l01456"></a>01456         pkt-&gt;assertMemInhibit();
<a name="l01457"></a>01457         <span class="keywordflow">if</span> (have_exclusive) {
<a name="l01458"></a>01458             pkt-&gt;setSupplyExclusive();
<a name="l01459"></a>01459         }
<a name="l01460"></a>01460         <span class="keywordflow">if</span> (is_timing) {
<a name="l01461"></a>01461             <a class="code" href="classCache.html#a87256886a1eea4638abe1b437f4fe226">doTimingSupplyResponse</a>(pkt, blk-&gt;data, is_deferred, pending_inval);
<a name="l01462"></a>01462         } <span class="keywordflow">else</span> {
<a name="l01463"></a>01463             pkt-&gt;makeAtomicResponse();
<a name="l01464"></a>01464             pkt-&gt;setDataFromBlock(blk-&gt;data, <a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a>);
<a name="l01465"></a>01465         }
<a name="l01466"></a>01466     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_timing &amp;&amp; is_deferred) {
<a name="l01467"></a>01467         <span class="comment">// if it&apos;s a deferred timing snoop then we&apos;ve made a copy of</span>
<a name="l01468"></a>01468         <span class="comment">// the packet, and so if we&apos;re not using that copy to respond</span>
<a name="l01469"></a>01469         <span class="comment">// then we need to delete it here.</span>
<a name="l01470"></a>01470         <span class="keyword">delete</span> pkt;
<a name="l01471"></a>01471     }
<a name="l01472"></a>01472 
<a name="l01473"></a>01473     <span class="comment">// Do this last in case it deallocates block data or something</span>
<a name="l01474"></a>01474     <span class="comment">// like that</span>
<a name="l01475"></a>01475     <span class="keywordflow">if</span> (invalidate) {
<a name="l01476"></a>01476         <span class="keywordflow">if</span> (blk != <a class="code" href="classCache.html#a0ca2086b66114357dd17032178adce17">tempBlock</a>)
<a name="l01477"></a>01477             <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;invalidate(blk);
<a name="l01478"></a>01478         blk-&gt;invalidate();
<a name="l01479"></a>01479     }
<a name="l01480"></a>01480 
<a name="l01481"></a>01481     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;new state is %s\n&quot;</span>, blk-&gt;print());
<a name="l01482"></a>01482 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2a9a72a19c7910262542bc96de2488fb"></a><!-- doxytag: member="Cache::inCache" ref="a2a9a72a19c7910262542bc96de2488fb" args="(Addr addr, bool is_secure) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool inCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_secure</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classBaseCache.html#a2ac85ef6d4c6f16111c1da31c2363aa7">BaseCache</a>を実装しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00392"></a>00392                                                   {
<a name="l00393"></a>00393         <span class="keywordflow">return</span> (<a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;findBlock(<a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a>, is_secure) != 0);
<a name="l00394"></a>00394     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a01f08168ad1a2fee8ccff0f562da70de"></a><!-- doxytag: member="Cache::inMissQueue" ref="a01f08168ad1a2fee8ccff0f562da70de" args="(Addr addr, bool is_secure) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool inMissQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_secure</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classBaseCache.html#abb47bf01a0bb0aa1c4e3d60fc2ca8175">BaseCache</a>を実装しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00396"></a>00396                                                       {
<a name="l00397"></a>00397         <span class="keywordflow">return</span> (<a class="code" href="classBaseCache.html#aa73933a75144caca7a7d3d77cf285c23">mshrQueue</a>.<a class="code" href="classMSHRQueue.html#aab842d63dcd254dfe655e16075f7e0fe">findMatch</a>(<a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a>, is_secure) != 0);
<a name="l00398"></a>00398     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0a830cf4879a74de1790653f861c7d93"></a><!-- doxytag: member="Cache::invalidateVisitor" ref="a0a830cf4879a74de1790653f861c7d93" args="(BlkType &amp;blk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool invalidateVisitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>blk</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classCache.html">Cache</a> block visitor that invalidates all blocks in the cache.</p>
<p>Dirty cache lines will not be written back to memory.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Always returns true. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01168"></a>01168 {
<a name="l01169"></a>01169 
<a name="l01170"></a>01170     <span class="keywordflow">if</span> (blk.isDirty())
<a name="l01171"></a>01171         <a class="code" href="base_2misc_8hh.html#abb243c15dfbeedf4ae64aa213f4f18c7">warn_once</a>(<span class="stringliteral">&quot;Invalidating dirty cache lines. Expect things to break.\n&quot;</span>);
<a name="l01172"></a>01172 
<a name="l01173"></a>01173     <span class="keywordflow">if</span> (blk.isValid()) {
<a name="l01174"></a>01174         assert(!blk.isDirty());
<a name="l01175"></a>01175         <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;invalidate(dynamic_cast&lt; BlkType *&gt;(&amp;blk));
<a name="l01176"></a>01176         blk.invalidate();
<a name="l01177"></a>01177     }
<a name="l01178"></a>01178 
<a name="l01179"></a>01179     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01180"></a>01180 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad66f409af3c387e166ff7ee95169b7b6"></a><!-- doxytag: member="Cache::isDirty" ref="ad66f409af3c387e166ff7ee95169b7b6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isDirty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine if there are any dirty blocks in the cache.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>true if at least one block is dirty, false otherwise. </dd></dl>

<p><a class="el" href="classBaseCache.html#a373dc1334f26db2ba94e827f3c9adc83">BaseCache</a>を実装しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l01136"></a>01136 {
<a name="l01137"></a>01137     <a class="code" href="classCacheBlkIsDirtyVisitor.html">CacheBlkIsDirtyVisitor&lt;BlkType&gt;</a> visitor;
<a name="l01138"></a>01138     <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;forEachBlk(visitor);
<a name="l01139"></a>01139 
<a name="l01140"></a>01140     <span class="keywordflow">return</span> visitor.<a class="code" href="classCacheBlkIsDirtyVisitor.html#ad66f409af3c387e166ff7ee95169b7b6">isDirty</a>();
<a name="l01141"></a>01141 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac7fb6ca824d25de54878584fd9dd8162"></a><!-- doxytag: member="Cache::markInService" ref="ac7fb6ca824d25de54878584fd9dd8162" args="(MSHR *mshr, PacketPtr pkt=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void markInService </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMSHR.html">MSHR</a> *&nbsp;</td>
          <td class="paramname"> <em>mshr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Marks a request as in service (sent on the bus). This can have side effect since storage for no response commands is deallocated once they are successfully sent. </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td>The request that was sent on the bus. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00245"></a>00245 {
<a name="l00246"></a>00246     <a class="code" href="classBaseCache.html#a08042a551e2a1bcdd036c84d277bc89f">markInServiceInternal</a>(mshr, pkt);
<a name="l00247"></a>00247 <span class="preprocessor">#if 0</span>
<a name="l00248"></a>00248 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (mshr-&gt;originalCmd == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153af939e2f740d217d26e90546059593b39">MemCmd::HardPFReq</a>) {
<a name="l00249"></a>00249             <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(HWPrefetch, <span class="stringliteral">&quot;%s:Marking a HW_PF in service\n&quot;</span>,
<a name="l00250"></a>00250                     <a class="code" href="classSimObject.html#adbcff144e5e199d332a1352af1798148">name</a>());
<a name="l00251"></a>00251             <span class="comment">//Also clear pending if need be</span>
<a name="l00252"></a>00252             <span class="keywordflow">if</span> (!<a class="code" href="classCache.html#a320f5a2352104b9b633113f9045461a3">prefetcher</a>-&gt;<a class="code" href="classBasePrefetcher.html#a1ea6e3ce1b4860ce7b2da36b169e6ff5">havePending</a>())
<a name="l00253"></a>00253             {
<a name="l00254"></a>00254                 <a class="code" href="classBaseCache.html#a7eb041ca3a51fe243525b95dea36f813">deassertMemSideBusRequest</a>(<a class="code" href="classBaseCache.html#a8ca466a3028d5dd05a9f31798a0115b8ad591c96d60dbceaf75076c496d695d14">Request_PF</a>);
<a name="l00255"></a>00255             }
<a name="l00256"></a>00256         }
<a name="l00257"></a>00257 <span class="preprocessor">#endif</span>
<a name="l00258"></a>00258 <span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="afea64b0aa579c17485db54c6a5c2ede3"></a><!-- doxytag: member="Cache::memInvalidate" ref="afea64b0aa579c17485db54c6a5c2ede3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void memInvalidate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invalidates all blocks in the cache.</p>
<p>Dirty cache lines will not be written back to memory. Make sure to call functionalWriteback() first if you want the to write them to memory. </p>

<p><a class="el" href="classBaseCache.html#aeb9356f940fbf8410f41920ee1d5864d">BaseCache</a>を実装しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l01128"></a>01128 {
<a name="l01129"></a>01129     <a class="code" href="classCache.html#afe5f62b7007c3a3cf9170e85041b38d8">WrappedBlkVisitor</a> visitor(*<span class="keyword">this</span>, &amp;<a class="code" href="classCache.html">Cache&lt;TagStore&gt;::invalidateVisitor</a>);
<a name="l01130"></a>01130     <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;forEachBlk(visitor);
<a name="l01131"></a>01131 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a381272ae5c2cc173adb59cd67a76b458"></a><!-- doxytag: member="Cache::memWriteback" ref="a381272ae5c2cc173adb59cd67a76b458" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void memWriteback </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write back dirty blocks in the cache using functional accesses. </p>

<p><a class="el" href="classBaseCache.html#afd3c83f1883488031612de6c47fcaabb">BaseCache</a>を実装しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l01120"></a>01120 {
<a name="l01121"></a>01121     <a class="code" href="classCache.html#afe5f62b7007c3a3cf9170e85041b38d8">WrappedBlkVisitor</a> visitor(*<span class="keyword">this</span>, &amp;<a class="code" href="classCache.html">Cache&lt;TagStore&gt;::writebackVisitor</a>);
<a name="l01122"></a>01122     <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;forEachBlk(visitor);
<a name="l01123"></a>01123 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4601a57ba7740776052541f212c29cbd"></a><!-- doxytag: member="Cache::nextMSHRReadyTime" ref="a4601a57ba7740776052541f212c29cbd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> nextMSHRReadyTime </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find next request ready time from among possible sources. </p>

<p><div class="fragment"><pre class="fragment"><a name="l01806"></a>01806 {
<a name="l01807"></a>01807     <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> nextReady = std::min(<a class="code" href="classBaseCache.html#aa73933a75144caca7a7d3d77cf285c23">mshrQueue</a>.<a class="code" href="classMSHRQueue.html#a4601a57ba7740776052541f212c29cbd">nextMSHRReadyTime</a>(),
<a name="l01808"></a>01808                               <a class="code" href="classBaseCache.html#ad44ec41bd8517224df8584b5e7fbe372">writeBuffer</a>.<a class="code" href="classMSHRQueue.html#a4601a57ba7740776052541f212c29cbd">nextMSHRReadyTime</a>());
<a name="l01809"></a>01809 
<a name="l01810"></a>01810     <span class="keywordflow">if</span> (<a class="code" href="classCache.html#a320f5a2352104b9b633113f9045461a3">prefetcher</a>) {
<a name="l01811"></a>01811         nextReady = std::min(nextReady,
<a name="l01812"></a>01812                              <a class="code" href="classCache.html#a320f5a2352104b9b633113f9045461a3">prefetcher</a>-&gt;<a class="code" href="classBasePrefetcher.html#a7b66a659d072bb2b2e105351949f7b2e">nextPrefetchReadyTime</a>());
<a name="l01813"></a>01813     }
<a name="l01814"></a>01814 
<a name="l01815"></a>01815     <span class="keywordflow">return</span> nextReady;
<a name="l01816"></a>01816 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac40e843a35136aebfb61fc0c9f57aa27"></a><!-- doxytag: member="Cache::outstandingMisses" ref="ac40e843a35136aebfb61fc0c9f57aa27" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool outstandingMisses </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return whether there are any outstanding misses. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00384"></a>00384     {
<a name="l00385"></a>00385         <span class="keywordflow">return</span> <a class="code" href="classBaseCache.html#aa73933a75144caca7a7d3d77cf285c23">mshrQueue</a>.<a class="code" href="classMSHRQueue.html#a115235fc25fdf1c03d856bd072b6cead">allocated</a> != 0;
<a name="l00386"></a>00386     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5f0b4c4a94f6b0053f9d7a4eb9c2518a"></a><!-- doxytag: member="Cache::recvAtomic" ref="a5f0b4c4a94f6b0053f9d7a4eb9c2518a" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> recvAtomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Performs the access specified by the request. </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td>The request to perform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>The number of ticks required for the access. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00673"></a>00673 {
<a name="l00674"></a>00674     <a class="code" href="classCycles.html">Cycles</a> lat = <a class="code" href="classBaseCache.html#a4075fdc5720f8f0f57c379c396e74718">hitLatency</a>;
<a name="l00675"></a>00675 
<a name="l00676"></a>00676     <span class="comment">// @TODO: make this a parameter</span>
<a name="l00677"></a>00677     <span class="keywordtype">bool</span> last_level_cache = <span class="keyword">false</span>;
<a name="l00678"></a>00678 
<a name="l00679"></a>00679     <span class="comment">// Forward the request if the system is in cache bypass mode.</span>
<a name="l00680"></a>00680     <span class="keywordflow">if</span> (<a class="code" href="classBaseCache.html#af27ccd765f13a4b7bd119dc7579e2746">system</a>-&gt;<a class="code" href="classSystem.html#a613d9d917b0e950cd322026de403d702">bypassCaches</a>())
<a name="l00681"></a>00681         <span class="keywordflow">return</span> <a class="code" href="classClockedObject.html#a91cfeb85669839d1ecafb7e62cf9d57a">ticksToCycles</a>(<a class="code" href="classBaseCache.html#af29f0c640654a651bf26558b4b39623b">memSidePort</a>-&gt;<a class="code" href="classMasterPort.html#a49fe5ebde5a0349bff76527b969b7643">sendAtomic</a>(pkt));
<a name="l00682"></a>00682 
<a name="l00683"></a>00683     <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a9693a1ffeda326646443ab2a2a92be41">memInhibitAsserted</a>()) {
<a name="l00684"></a>00684         assert(!pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a70c74b2809417ea8701dd6ba9e34312d">isUncacheable</a>());
<a name="l00685"></a>00685         <span class="comment">// have to invalidate ourselves and any lower caches even if</span>
<a name="l00686"></a>00686         <span class="comment">// upper cache will be responding</span>
<a name="l00687"></a>00687         <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a4a1a39b8ffab2d6266cd9d794ca332e3">isInvalidate</a>()) {
<a name="l00688"></a>00688             <a class="code" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *blk = <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;findBlock(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>());
<a name="l00689"></a>00689             <span class="keywordflow">if</span> (blk &amp;&amp; blk-&gt;isValid()) {
<a name="l00690"></a>00690                 <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;invalidate(blk);
<a name="l00691"></a>00691                 blk-&gt;invalidate();
<a name="l00692"></a>00692                 <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;rcvd mem-inhibited %s on 0x%x (%s):&quot;</span>
<a name="l00693"></a>00693                         <span class="stringliteral">&quot; invalidating\n&quot;</span>,
<a name="l00694"></a>00694                         pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(), pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(),
<a name="l00695"></a>00695                         pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>() ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;ns&quot;</span>);
<a name="l00696"></a>00696             }
<a name="l00697"></a>00697             <span class="keywordflow">if</span> (!last_level_cache) {
<a name="l00698"></a>00698                 <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;forwarding mem-inhibited %s on 0x%x (%s)\n&quot;</span>,
<a name="l00699"></a>00699                         pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(), pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(),
<a name="l00700"></a>00700                         pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>() ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;ns&quot;</span>);
<a name="l00701"></a>00701                 lat += <a class="code" href="classClockedObject.html#a91cfeb85669839d1ecafb7e62cf9d57a">ticksToCycles</a>(<a class="code" href="classBaseCache.html#af29f0c640654a651bf26558b4b39623b">memSidePort</a>-&gt;<a class="code" href="classMasterPort.html#a49fe5ebde5a0349bff76527b969b7643">sendAtomic</a>(pkt));
<a name="l00702"></a>00702             }
<a name="l00703"></a>00703         } <span class="keywordflow">else</span> {
<a name="l00704"></a>00704             <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;rcvd mem-inhibited %s on 0x%x: not responding\n&quot;</span>,
<a name="l00705"></a>00705                     pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(), pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>());
<a name="l00706"></a>00706         }
<a name="l00707"></a>00707 
<a name="l00708"></a>00708         <span class="keywordflow">return</span> lat * <a class="code" href="classClockedObject.html#a78c89cef17196c60470c4f2f76d43d8a">clockPeriod</a>();
<a name="l00709"></a>00709     }
<a name="l00710"></a>00710 
<a name="l00711"></a>00711     <span class="comment">// should assert here that there are no outstanding MSHRs or</span>
<a name="l00712"></a>00712     <span class="comment">// writebacks... that would mean that someone used an atomic</span>
<a name="l00713"></a>00713     <span class="comment">// access in timing mode</span>
<a name="l00714"></a>00714 
<a name="l00715"></a>00715     <a class="code" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *blk = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00716"></a>00716     <a class="code" href="classstd_1_1list.html">PacketList</a> <a class="code" href="group__CacheStatistics.html#gace2b37e760e47862f243e4b03c05ef5e">writebacks</a>;
<a name="l00717"></a>00717 
<a name="l00718"></a>00718     <span class="keywordflow">if</span> (!<a class="code" href="classCache.html#ae24e0e790eea2373d750eb6642007750">access</a>(pkt, blk, lat, writebacks)) {
<a name="l00719"></a>00719         <span class="comment">// MISS</span>
<a name="l00720"></a>00720         <a class="code" href="classPacket.html">PacketPtr</a> bus_pkt = <a class="code" href="classCache.html#a3bdcf30020fcb7b18e1d1f95cc86648e">getBusPacket</a>(pkt, blk, pkt-&gt;<a class="code" href="classPacket.html#aa8e449288b878ff3ff7f286eb4d28b6a">needsExclusive</a>());
<a name="l00721"></a>00721 
<a name="l00722"></a>00722         <span class="keywordtype">bool</span> is_forward = (bus_pkt == <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>);
<a name="l00723"></a>00723 
<a name="l00724"></a>00724         <span class="keywordflow">if</span> (is_forward) {
<a name="l00725"></a>00725             <span class="comment">// just forwarding the same request to the next level</span>
<a name="l00726"></a>00726             <span class="comment">// no local cache operation involved</span>
<a name="l00727"></a>00727             bus_pkt = pkt;
<a name="l00728"></a>00728         }
<a name="l00729"></a>00729 
<a name="l00730"></a>00730         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;Sending an atomic %s for %x (%s)\n&quot;</span>,
<a name="l00731"></a>00731                 bus_pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(), bus_pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(),
<a name="l00732"></a>00732                 bus_pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>() ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;ns&quot;</span>);
<a name="l00733"></a>00733 
<a name="l00734"></a>00734 <span class="preprocessor">#if TRACING_ON</span>
<a name="l00735"></a>00735 <span class="preprocessor"></span>        <a class="code" href="classCacheBlk.html#a09dbc3a4ce615f45c897d9ee6fbffb2a">CacheBlk::State</a> old_state = blk ? blk-&gt;status : 0;
<a name="l00736"></a>00736 <span class="preprocessor">#endif</span>
<a name="l00737"></a>00737 <span class="preprocessor"></span>
<a name="l00738"></a>00738         lat += <a class="code" href="classClockedObject.html#a91cfeb85669839d1ecafb7e62cf9d57a">ticksToCycles</a>(<a class="code" href="classBaseCache.html#af29f0c640654a651bf26558b4b39623b">memSidePort</a>-&gt;<a class="code" href="classMasterPort.html#a49fe5ebde5a0349bff76527b969b7643">sendAtomic</a>(bus_pkt));
<a name="l00739"></a>00739 
<a name="l00740"></a>00740         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;Receive response: %s for addr %x (%s) in state %i\n&quot;</span>,
<a name="l00741"></a>00741                 bus_pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(), bus_pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(),
<a name="l00742"></a>00742                 bus_pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>() ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;ns&quot;</span>,
<a name="l00743"></a>00743                 old_state);
<a name="l00744"></a>00744 
<a name="l00745"></a>00745         <span class="comment">// If packet was a forward, the response (if any) is already</span>
<a name="l00746"></a>00746         <span class="comment">// in place in the bus_pkt == pkt structure, so we don&apos;t need</span>
<a name="l00747"></a>00747         <span class="comment">// to do anything.  Otherwise, use the separate bus_pkt to</span>
<a name="l00748"></a>00748         <span class="comment">// generate response to pkt and then delete it.</span>
<a name="l00749"></a>00749         <span class="keywordflow">if</span> (!is_forward) {
<a name="l00750"></a>00750             <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a390c6cced05593f0a2c75a38a7a24fa9">needsResponse</a>()) {
<a name="l00751"></a>00751                 assert(bus_pkt-&gt;<a class="code" href="classPacket.html#a5f89a108755a6cb3e8185d85c850a816">isResponse</a>());
<a name="l00752"></a>00752                 <span class="keywordflow">if</span> (bus_pkt-&gt;<a class="code" href="classPacket.html#a32759931a1b2d6380407c6a18abd46e3">isError</a>()) {
<a name="l00753"></a>00753                     pkt-&gt;<a class="code" href="classPacket.html#ad664e704f09d6bb5c116573721034ebd">makeAtomicResponse</a>();
<a name="l00754"></a>00754                     pkt-&gt;<a class="code" href="classPacket.html#a838dc8f424eaa81aa7ee30fb4c5900a0">copyError</a>(bus_pkt);
<a name="l00755"></a>00755                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bus_pkt-&gt;<a class="code" href="classPacket.html#adc47901747fc3c447db3abddaf01491a">isRead</a>() ||
<a name="l00756"></a>00756                            bus_pkt-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153aff67b7f8eb8b6a17a896579c2dd6195c">MemCmd::UpgradeResp</a>) {
<a name="l00757"></a>00757                     <span class="comment">// we&apos;re updating cache state to allow us to</span>
<a name="l00758"></a>00758                     <span class="comment">// satisfy the upstream request from the cache</span>
<a name="l00759"></a>00759                     blk = <a class="code" href="classCache.html#a4943b9a8a4801f454a968416b456dc21">handleFill</a>(bus_pkt, blk, writebacks);
<a name="l00760"></a>00760                     <a class="code" href="classCache.html#a5d5d5944479d29a7bfc183f4b2b6a4fa">satisfyCpuSideRequest</a>(pkt, blk);
<a name="l00761"></a>00761                 } <span class="keywordflow">else</span> {
<a name="l00762"></a>00762                     <span class="comment">// we&apos;re satisfying the upstream request without</span>
<a name="l00763"></a>00763                     <span class="comment">// modifying cache state, e.g., a write-through</span>
<a name="l00764"></a>00764                     pkt-&gt;<a class="code" href="classPacket.html#ad664e704f09d6bb5c116573721034ebd">makeAtomicResponse</a>();
<a name="l00765"></a>00765                 }
<a name="l00766"></a>00766             }
<a name="l00767"></a>00767             <span class="keyword">delete</span> bus_pkt;
<a name="l00768"></a>00768         }
<a name="l00769"></a>00769     }
<a name="l00770"></a>00770 
<a name="l00771"></a>00771     <span class="comment">// Note that we don&apos;t invoke the prefetcher at all in atomic mode.</span>
<a name="l00772"></a>00772     <span class="comment">// It&apos;s not clear how to do it properly, particularly for</span>
<a name="l00773"></a>00773     <span class="comment">// prefetchers that aggressively generate prefetch candidates and</span>
<a name="l00774"></a>00774     <span class="comment">// rely on bandwidth contention to throttle them; these will tend</span>
<a name="l00775"></a>00775     <span class="comment">// to pollute the cache in atomic mode since there is no bandwidth</span>
<a name="l00776"></a>00776     <span class="comment">// contention.  If we ever do want to enable prefetching in atomic</span>
<a name="l00777"></a>00777     <span class="comment">// mode, though, this is the place to do it... see timingAccess()</span>
<a name="l00778"></a>00778     <span class="comment">// for an example (though we&apos;d want to issue the prefetch(es)</span>
<a name="l00779"></a>00779     <span class="comment">// immediately rather than calling requestMemSideBus() as we do</span>
<a name="l00780"></a>00780     <span class="comment">// there).</span>
<a name="l00781"></a>00781 
<a name="l00782"></a>00782     <span class="comment">// Handle writebacks if needed</span>
<a name="l00783"></a>00783     <span class="keywordflow">while</span> (!writebacks.empty()){
<a name="l00784"></a>00784         <a class="code" href="classPacket.html">PacketPtr</a> wbPkt = writebacks.front();
<a name="l00785"></a>00785         <a class="code" href="classBaseCache.html#af29f0c640654a651bf26558b4b39623b">memSidePort</a>-&gt;<a class="code" href="classMasterPort.html#a49fe5ebde5a0349bff76527b969b7643">sendAtomic</a>(wbPkt);
<a name="l00786"></a>00786         writebacks.pop_front();
<a name="l00787"></a>00787         <span class="keyword">delete</span> wbPkt;
<a name="l00788"></a>00788     }
<a name="l00789"></a>00789 
<a name="l00790"></a>00790     <span class="comment">// We now have the block one way or another (hit or completed miss)</span>
<a name="l00791"></a>00791 
<a name="l00792"></a>00792     <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a390c6cced05593f0a2c75a38a7a24fa9">needsResponse</a>()) {
<a name="l00793"></a>00793         pkt-&gt;<a class="code" href="classPacket.html#ad664e704f09d6bb5c116573721034ebd">makeAtomicResponse</a>();
<a name="l00794"></a>00794     }
<a name="l00795"></a>00795 
<a name="l00796"></a>00796     <span class="keywordflow">return</span> lat * <a class="code" href="classClockedObject.html#a78c89cef17196c60470c4f2f76d43d8a">clockPeriod</a>();
<a name="l00797"></a>00797 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a886d584c81ee4e398ff8069907f6e1a5"></a><!-- doxytag: member="Cache::recvAtomicSnoop" ref="a886d584c81ee4e398ff8069907f6e1a5" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> recvAtomicSnoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Snoop for the provided request in the cache and return the estimated time taken. </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td>The memory request to snoop </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>The number of ticks required for the snoop. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01602"></a>01602 {
<a name="l01603"></a>01603     <span class="comment">// Snoops shouldn&apos;t happen when bypassing caches</span>
<a name="l01604"></a>01604     assert(!<a class="code" href="classBaseCache.html#af27ccd765f13a4b7bd119dc7579e2746">system</a>-&gt;<a class="code" href="classSystem.html#a613d9d917b0e950cd322026de403d702">bypassCaches</a>());
<a name="l01605"></a>01605 
<a name="l01606"></a>01606     <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a70c74b2809417ea8701dd6ba9e34312d">isUncacheable</a>() || pkt-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a89447e3db973b10c03f68d590c65e8e6">MemCmd::Writeback</a>) {
<a name="l01607"></a>01607         <span class="comment">// Can&apos;t get a hit on an uncacheable address</span>
<a name="l01608"></a>01608         <span class="comment">// Revisit this for multi level coherence</span>
<a name="l01609"></a>01609         <span class="keywordflow">return</span> 0;
<a name="l01610"></a>01610     }
<a name="l01611"></a>01611 
<a name="l01612"></a>01612     <a class="code" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *blk = <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;findBlock(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>());
<a name="l01613"></a>01613     <a class="code" href="classCache.html#affa22df454ca8619381018b222c49c2d">handleSnoop</a>(pkt, blk, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l01614"></a>01614     <span class="keywordflow">return</span> <a class="code" href="classBaseCache.html#a4075fdc5720f8f0f57c379c396e74718">hitLatency</a> * <a class="code" href="classClockedObject.html#a78c89cef17196c60470c4f2f76d43d8a">clockPeriod</a>();
<a name="l01615"></a>01615 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3344d9dd0f83257feab5424e761f31c6"></a><!-- doxytag: member="Cache::recvTimingReq" ref="a3344d9dd0f83257feab5424e761f31c6" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool recvTimingReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Performs the access specified by the request. </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td>The request to perform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>The result of the access. </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000075">TODO:</a></b></dt><dd>temporary hack to deal with memory corruption issue until 4-phase transactions are complete </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000076">TODO:</a></b></dt><dd>nominally we should just delete the packet here, however, until 4-phase stuff we can't because sending cache is still relying on it </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000077">TODO:</a></b></dt><dd>nominally we should just delete the packet here, however, until 4-phase stuff we can't because sending cache is still relying on it </dd></dl>
<p><a class="el" href="classMSHR.html">MSHR</a> hit </p>
<dl class="note"><dt><b>覚え書き:</b></dt><dd>writebacks will be checked in <a class="el" href="classCache.html#a3ce02537ee4a8918300802fda9b82b47">getNextMSHR()</a> for any conflicting requests to the same block </dd></dl>
</p>

<p><div class="fragment"><pre class="fragment"><a name="l00411"></a>00411 {
<a name="l00412"></a>00412     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(CacheTags, <span class="stringliteral">&quot;%s tags: %s\n&quot;</span>, __func__, <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;print());
<a name="l00413"></a>00413 <span class="comment">//@todo Add back in MemDebug Calls</span>
<a name="l00414"></a>00414 <span class="comment">//    MemDebug::cacheAccess(pkt);</span>
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 
<a name="l00419"></a>00419     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="namespaceX86ISA.html#ab5f9a01fc40e47853ae9551b008afcbd">x</a> = 0; <a class="code" href="namespaceX86ISA.html#ab5f9a01fc40e47853ae9551b008afcbd">x</a> &lt; <a class="code" href="classCache.html#a21da4bea3554874b557428e4cce5d4a4">pendingDelete</a>.size(); <a class="code" href="namespaceX86ISA.html#ab5f9a01fc40e47853ae9551b008afcbd">x</a>++)
<a name="l00420"></a>00420         <span class="keyword">delete</span> <a class="code" href="classCache.html#a21da4bea3554874b557428e4cce5d4a4">pendingDelete</a>[<a class="code" href="namespaceX86ISA.html#ab5f9a01fc40e47853ae9551b008afcbd">x</a>];
<a name="l00421"></a>00421     <a class="code" href="classCache.html#a21da4bea3554874b557428e4cce5d4a4">pendingDelete</a>.clear();
<a name="l00422"></a>00422 
<a name="l00423"></a>00423     <span class="comment">// we charge hitLatency for doing just about anything here</span>
<a name="l00424"></a>00424     <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> time = <a class="code" href="classClockedObject.html#a773956693f216cafb7d4cad92ad582e5">clockEdge</a>(<a class="code" href="classBaseCache.html#a4075fdc5720f8f0f57c379c396e74718">hitLatency</a>);
<a name="l00425"></a>00425 
<a name="l00426"></a>00426     assert(pkt-&gt;<a class="code" href="classPacket.html#af21986d725d75fa8e1b6c83457cd4501">isRequest</a>());
<a name="l00427"></a>00427 
<a name="l00428"></a>00428     <span class="comment">// Just forward the packet if caches are disabled.</span>
<a name="l00429"></a>00429     <span class="keywordflow">if</span> (<a class="code" href="classBaseCache.html#af27ccd765f13a4b7bd119dc7579e2746">system</a>-&gt;<a class="code" href="classSystem.html#a613d9d917b0e950cd322026de403d702">bypassCaches</a>()) {
<a name="l00430"></a>00430         <a class="code" href="classBaseCache.html#af29f0c640654a651bf26558b4b39623b">memSidePort</a>-&gt;<a class="code" href="classMasterPort.html#aafaf979005392447714384794f1a8610">sendTimingReq</a>(pkt);
<a name="l00431"></a>00431         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00432"></a>00432     }
<a name="l00433"></a>00433 
<a name="l00434"></a>00434     <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a9693a1ffeda326646443ab2a2a92be41">memInhibitAsserted</a>()) {
<a name="l00435"></a>00435         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;mem inhibited on 0x%x (%s): not responding\n&quot;</span>,
<a name="l00436"></a>00436                 pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>() ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;ns&quot;</span>);
<a name="l00437"></a>00437         assert(!pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a70c74b2809417ea8701dd6ba9e34312d">isUncacheable</a>());
<a name="l00438"></a>00438         <span class="comment">// Special tweak for multilevel coherence: snoop downward here</span>
<a name="l00439"></a>00439         <span class="comment">// on invalidates since there may be other caches below here</span>
<a name="l00440"></a>00440         <span class="comment">// that have shared copies.  Not necessary if we know that</span>
<a name="l00441"></a>00441         <span class="comment">// supplier had exclusive copy to begin with.</span>
<a name="l00442"></a>00442         <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#aa8e449288b878ff3ff7f286eb4d28b6a">needsExclusive</a>() &amp;&amp; !pkt-&gt;<a class="code" href="classPacket.html#ae74f555f87001a9695338ce38a6ce8ee">isSupplyExclusive</a>()) {
<a name="l00443"></a>00443             <a class="code" href="classPacket.html">Packet</a> *snoopPkt = <span class="keyword">new</span> <a class="code" href="classPacket.html">Packet</a>(pkt, <span class="keyword">true</span>);  <span class="comment">// clear flags</span>
<a name="l00444"></a>00444             <span class="comment">// also reset the bus time that the original packet has</span>
<a name="l00445"></a>00445             <span class="comment">// not yet paid for</span>
<a name="l00446"></a>00446             snoopPkt-&gt;<a class="code" href="classPacket.html#af8986a05caa6c5b96b0b01bb6cf47772">busFirstWordDelay</a> = snoopPkt-&gt;<a class="code" href="classPacket.html#a7bf8ae0a056329f751eda8b39ca4c268">busLastWordDelay</a> = 0;
<a name="l00447"></a>00447             snoopPkt-&gt;<a class="code" href="classPacket.html#a556d03576cc3d726f41c7e1ad6fbb64a">setExpressSnoop</a>();
<a name="l00448"></a>00448             snoopPkt-&gt;<a class="code" href="classPacket.html#a159497b4ab2144a0c1c36d2266df17d1">assertMemInhibit</a>();
<a name="l00449"></a>00449             <a class="code" href="classBaseCache.html#af29f0c640654a651bf26558b4b39623b">memSidePort</a>-&gt;<a class="code" href="classMasterPort.html#aafaf979005392447714384794f1a8610">sendTimingReq</a>(snoopPkt);
<a name="l00450"></a>00450             <span class="comment">// main memory will delete snoopPkt</span>
<a name="l00451"></a>00451         }
<a name="l00452"></a>00452         <span class="comment">// since we&apos;re the official target but we aren&apos;t responding,</span>
<a name="l00453"></a>00453         <span class="comment">// delete the packet now.</span>
<a name="l00454"></a>00454 
<a name="l00458"></a>00458         <a class="code" href="classCache.html#a21da4bea3554874b557428e4cce5d4a4">pendingDelete</a>.push_back(pkt);
<a name="l00459"></a>00459         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00460"></a>00460     }
<a name="l00461"></a>00461 
<a name="l00462"></a>00462     <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a70c74b2809417ea8701dd6ba9e34312d">isUncacheable</a>()) {
<a name="l00463"></a>00463         <a class="code" href="classCache.html#af5dfa0f9fd3542f24b728e25a1d658b2">uncacheableFlush</a>(pkt);
<a name="l00464"></a>00464 
<a name="l00465"></a>00465         <span class="comment">// @todo: someone should pay for this</span>
<a name="l00466"></a>00466         pkt-&gt;<a class="code" href="classPacket.html#af8986a05caa6c5b96b0b01bb6cf47772">busFirstWordDelay</a> = pkt-&gt;<a class="code" href="classPacket.html#a7bf8ae0a056329f751eda8b39ca4c268">busLastWordDelay</a> = 0;
<a name="l00467"></a>00467 
<a name="l00468"></a>00468         <span class="comment">// writes go in write buffer, reads use MSHR</span>
<a name="l00469"></a>00469         <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#ab699d2f0d186312531fd1c279fd27b73">isWrite</a>() &amp;&amp; !pkt-&gt;<a class="code" href="classPacket.html#adc47901747fc3c447db3abddaf01491a">isRead</a>()) {
<a name="l00470"></a>00470             <a class="code" href="classBaseCache.html#a3f81ca9ba6f7294f930eca229838edc6">allocateWriteBuffer</a>(pkt, time, <span class="keyword">true</span>);
<a name="l00471"></a>00471         } <span class="keywordflow">else</span> {
<a name="l00472"></a>00472             <a class="code" href="classBaseCache.html#a8dfb4bae0c201cd12ca22dd159740541">allocateUncachedReadBuffer</a>(pkt, time, <span class="keyword">true</span>);
<a name="l00473"></a>00473         }
<a name="l00474"></a>00474         assert(pkt-&gt;<a class="code" href="classPacket.html#a390c6cced05593f0a2c75a38a7a24fa9">needsResponse</a>()); <span class="comment">// else we should delete it here??</span>
<a name="l00475"></a>00475         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00476"></a>00476     }
<a name="l00477"></a>00477 
<a name="l00478"></a>00478     <a class="code" href="classCycles.html">Cycles</a> lat = <a class="code" href="classBaseCache.html#a4075fdc5720f8f0f57c379c396e74718">hitLatency</a>;
<a name="l00479"></a>00479     <a class="code" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *blk = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00480"></a>00480     <a class="code" href="classstd_1_1list.html">PacketList</a> <a class="code" href="group__CacheStatistics.html#gace2b37e760e47862f243e4b03c05ef5e">writebacks</a>;
<a name="l00481"></a>00481 
<a name="l00482"></a>00482     <span class="keywordtype">bool</span> satisfied = <a class="code" href="classCache.html#ae24e0e790eea2373d750eb6642007750">access</a>(pkt, blk, lat, writebacks);
<a name="l00483"></a>00483 
<a name="l00484"></a>00484 <span class="preprocessor">#if 0</span>
<a name="l00485"></a>00485 <span class="preprocessor"></span>
<a name="l00487"></a>00487     <span class="comment">// If this is a block size write/hint (WH64) allocate the block here</span>
<a name="l00488"></a>00488     <span class="comment">// if the coherence protocol allows it.</span>
<a name="l00489"></a>00489     <span class="keywordflow">if</span> (!blk &amp;&amp; pkt-&gt;<a class="code" href="classPacket.html#a1d18ba49c7be427da1f4a42d53e35f48">getSize</a>() &gt;= <a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a> &amp;&amp; coherence-&gt;allowFastWrites() &amp;&amp;
<a name="l00490"></a>00490         (pkt-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153aa5ec34a7e56b23ff12c9b819519d168a">MemCmd::WriteReq</a>
<a name="l00491"></a>00491          || pkt-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a8e7344b4258b2c0bff3ba4ee466d2e71">MemCmd::WriteInvalidateReq</a>) ) {
<a name="l00492"></a>00492         <span class="comment">// not outstanding misses, can do this</span>
<a name="l00493"></a>00493         <a class="code" href="classMSHR.html">MSHR</a> *outstanding_miss = <a class="code" href="classBaseCache.html#aa73933a75144caca7a7d3d77cf285c23">mshrQueue</a>.<a class="code" href="classMSHRQueue.html#aab842d63dcd254dfe655e16075f7e0fe">findMatch</a>(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(),
<a name="l00494"></a>00494                                                      pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>());
<a name="l00495"></a>00495         <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a8e7344b4258b2c0bff3ba4ee466d2e71">MemCmd::WriteInvalidateReq</a> || !outstanding_miss) {
<a name="l00496"></a>00496             <span class="keywordflow">if</span> (outstanding_miss) {
<a name="l00497"></a>00497                 <a class="code" href="base_2misc_8hh.html#a8224a361dddd2ad59b411982e5ea746f">warn</a>(<span class="stringliteral">&quot;WriteInv doing a fastallocate&quot;</span>
<a name="l00498"></a>00498                      <span class="stringliteral">&quot;with an outstanding miss to the same address\n&quot;</span>);
<a name="l00499"></a>00499             }
<a name="l00500"></a>00500             blk = <a class="code" href="classCache.html#a4943b9a8a4801f454a968416b456dc21">handleFill</a>(<a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>, pkt, <a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7acd687680ed8ee756c990233bd44ccc7a">BlkValid</a> | <a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7a202d95c1090db0082a7a954856ad5358">BlkWritable</a>,
<a name="l00501"></a>00501                                    writebacks);
<a name="l00502"></a>00502             ++<a class="code" href="group__CacheStatistics.html#gaaa4a7e9f5dcb48cc5a53ac2335e934b3">fastWrites</a>;
<a name="l00503"></a>00503         }
<a name="l00504"></a>00504     }
<a name="l00505"></a>00505 <span class="preprocessor">#endif</span>
<a name="l00506"></a>00506 <span class="preprocessor"></span>
<a name="l00507"></a>00507     <span class="comment">// track time of availability of next prefetch, if any</span>
<a name="l00508"></a>00508     <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> next_pf_time = 0;
<a name="l00509"></a>00509 
<a name="l00510"></a>00510     <span class="keywordtype">bool</span> needsResponse = pkt-&gt;<a class="code" href="classPacket.html#a390c6cced05593f0a2c75a38a7a24fa9">needsResponse</a>();
<a name="l00511"></a>00511 
<a name="l00512"></a>00512     <span class="keywordflow">if</span> (satisfied) {
<a name="l00513"></a>00513         <span class="keywordflow">if</span> (<a class="code" href="classCache.html#a320f5a2352104b9b633113f9045461a3">prefetcher</a> &amp;&amp; (<a class="code" href="classCache.html#a146f074bf7af4a70fc378862eab0b15a">prefetchOnAccess</a> || (blk &amp;&amp; blk-&gt;wasPrefetched()))) {
<a name="l00514"></a>00514             <span class="keywordflow">if</span> (blk)
<a name="l00515"></a>00515                 blk-&gt;status &amp;= ~<a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7aa64aeb976bf10b41a7c383f0035f753b">BlkHWPrefetched</a>;
<a name="l00516"></a>00516             next_pf_time = <a class="code" href="classCache.html#a320f5a2352104b9b633113f9045461a3">prefetcher</a>-&gt;<a class="code" href="classBasePrefetcher.html#a1d4199bee2a7f9e8f22bf9e84d5ceda4">notify</a>(pkt, time);
<a name="l00517"></a>00517         }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519         <span class="keywordflow">if</span> (needsResponse) {
<a name="l00520"></a>00520             pkt-&gt;<a class="code" href="classPacket.html#a325088bded521f69342b08a548811332">makeTimingResponse</a>();
<a name="l00521"></a>00521             <span class="comment">// @todo: Make someone pay for this</span>
<a name="l00522"></a>00522             pkt-&gt;<a class="code" href="classPacket.html#af8986a05caa6c5b96b0b01bb6cf47772">busFirstWordDelay</a> = pkt-&gt;<a class="code" href="classPacket.html#a7bf8ae0a056329f751eda8b39ca4c268">busLastWordDelay</a> = 0;
<a name="l00523"></a>00523             <a class="code" href="classBaseCache.html#a14913ffff181227d085f25a95e6ada42">cpuSidePort</a>-&gt;<a class="code" href="classQueuedSlavePort.html#a31c2fe79e7cbd7319eb327074e412675">schedTimingResp</a>(pkt, <a class="code" href="classClockedObject.html#a773956693f216cafb7d4cad92ad582e5">clockEdge</a>(lat));
<a name="l00524"></a>00524         } <span class="keywordflow">else</span> {
<a name="l00528"></a>00528             <a class="code" href="classCache.html#a21da4bea3554874b557428e4cce5d4a4">pendingDelete</a>.push_back(pkt);
<a name="l00529"></a>00529         }
<a name="l00530"></a>00530     } <span class="keywordflow">else</span> {
<a name="l00531"></a>00531         <span class="comment">// miss</span>
<a name="l00532"></a>00532 
<a name="l00533"></a>00533         <span class="comment">// @todo: Make someone pay for this</span>
<a name="l00534"></a>00534         pkt-&gt;<a class="code" href="classPacket.html#af8986a05caa6c5b96b0b01bb6cf47772">busFirstWordDelay</a> = pkt-&gt;<a class="code" href="classPacket.html#a7bf8ae0a056329f751eda8b39ca4c268">busLastWordDelay</a> = 0;
<a name="l00535"></a>00535 
<a name="l00536"></a>00536         <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> blk_addr = <a class="code" href="classBaseCache.html#a676df8321350e810fc857d99cdcebc22">blockAlign</a>(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>());
<a name="l00537"></a>00537         <a class="code" href="classMSHR.html">MSHR</a> *mshr = <a class="code" href="classBaseCache.html#aa73933a75144caca7a7d3d77cf285c23">mshrQueue</a>.<a class="code" href="classMSHRQueue.html#aab842d63dcd254dfe655e16075f7e0fe">findMatch</a>(blk_addr, pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>());
<a name="l00538"></a>00538 
<a name="l00539"></a>00539         <span class="keywordflow">if</span> (mshr) {
<a name="l00543"></a>00543 
<a name="l00544"></a>00544             <span class="comment">//@todo remove hw_pf here</span>
<a name="l00545"></a>00545             assert(pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a9b7d32db0521388c0953e531c79aab50">masterId</a>() &lt; <a class="code" href="classBaseCache.html#af27ccd765f13a4b7bd119dc7579e2746">system</a>-&gt;<a class="code" href="classSystem.html#a4cd916c36458ce47e9ba4ccbfc75a095">maxMasters</a>());
<a name="l00546"></a>00546             <a class="code" href="group__CacheStatistics.html#ga92faf658f75559bd75a8839d4de1f8a9">mshr_hits</a>[pkt-&gt;<a class="code" href="classPacket.html#a8db75870e65b9d86793f2805097c05a0" title="Return the index of this command.">cmdToIndex</a>()][pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a9b7d32db0521388c0953e531c79aab50">masterId</a>()]++;
<a name="l00547"></a>00547             <span class="keywordflow">if</span> (mshr-&gt;threadNum != 0<span class="comment">/*pkt-&gt;req-&gt;threadId()*/</span>) {
<a name="l00548"></a>00548                 mshr-&gt;threadNum = -1;
<a name="l00549"></a>00549             }
<a name="l00550"></a>00550             mshr-&gt;allocateTarget(pkt, time, <a class="code" href="classBaseCache.html#ab26c49bd3bef351f3658df29505d78dd">order</a>++);
<a name="l00551"></a>00551             <span class="keywordflow">if</span> (mshr-&gt;getNumTargets() == <a class="code" href="classBaseCache.html#a3c2d74d5455e7b8ccefd3edb38c291de">numTarget</a>) {
<a name="l00552"></a>00552                 <a class="code" href="classBaseCache.html#ae429d09cb5301f34a7eb7e6c765d4441">noTargetMSHR</a> = mshr;
<a name="l00553"></a>00553                 <a class="code" href="classBaseCache.html#a79de24f2f3eda2cc3ac13f600d171bc0">setBlocked</a>(<a class="code" href="classBaseCache.html#a98297f294858ead7eafd19af93e64c6da2e0db8e863cb5a0c10b73be89a535323">Blocked_NoTargets</a>);
<a name="l00554"></a>00554                 <span class="comment">// need to be careful with this... if this mshr isn&apos;t</span>
<a name="l00555"></a>00555                 <span class="comment">// ready yet (i.e. time &gt; curTick()_, we don&apos;t want to</span>
<a name="l00556"></a>00556                 <span class="comment">// move it ahead of mshrs that are ready</span>
<a name="l00557"></a>00557                 <span class="comment">// mshrQueue.moveToFront(mshr);</span>
<a name="l00558"></a>00558             }
<a name="l00559"></a>00559 
<a name="l00560"></a>00560             <span class="comment">// We should call the prefetcher reguardless if the request is</span>
<a name="l00561"></a>00561             <span class="comment">// satisfied or not, reguardless if the request is in the MSHR or</span>
<a name="l00562"></a>00562             <span class="comment">// not.  The request could be a ReadReq hit, but still not</span>
<a name="l00563"></a>00563             <span class="comment">// satisfied (potentially because of a prior write to the same</span>
<a name="l00564"></a>00564             <span class="comment">// cache line.  So, even when not satisfied, tehre is an MSHR</span>
<a name="l00565"></a>00565             <span class="comment">// already allocated for this, we need to let the prefetcher know</span>
<a name="l00566"></a>00566             <span class="comment">// about the request</span>
<a name="l00567"></a>00567             <span class="keywordflow">if</span> (<a class="code" href="classCache.html#a320f5a2352104b9b633113f9045461a3">prefetcher</a>) {
<a name="l00568"></a>00568                 next_pf_time = <a class="code" href="classCache.html#a320f5a2352104b9b633113f9045461a3">prefetcher</a>-&gt;<a class="code" href="classBasePrefetcher.html#a1d4199bee2a7f9e8f22bf9e84d5ceda4">notify</a>(pkt, time);
<a name="l00569"></a>00569             }
<a name="l00570"></a>00570         } <span class="keywordflow">else</span> {
<a name="l00571"></a>00571             <span class="comment">// no MSHR</span>
<a name="l00572"></a>00572             assert(pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a9b7d32db0521388c0953e531c79aab50">masterId</a>() &lt; <a class="code" href="classBaseCache.html#af27ccd765f13a4b7bd119dc7579e2746">system</a>-&gt;<a class="code" href="classSystem.html#a4cd916c36458ce47e9ba4ccbfc75a095">maxMasters</a>());
<a name="l00573"></a>00573             <a class="code" href="group__CacheStatistics.html#gaececf7d3c236db3a8f26999e5330a7f8">mshr_misses</a>[pkt-&gt;<a class="code" href="classPacket.html#a8db75870e65b9d86793f2805097c05a0" title="Return the index of this command.">cmdToIndex</a>()][pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a9b7d32db0521388c0953e531c79aab50">masterId</a>()]++;
<a name="l00574"></a>00574             <span class="comment">// always mark as cache fill for now... if we implement</span>
<a name="l00575"></a>00575             <span class="comment">// no-write-allocate or bypass accesses this will have to</span>
<a name="l00576"></a>00576             <span class="comment">// be changed.</span>
<a name="l00577"></a>00577             <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a89447e3db973b10c03f68d590c65e8e6">MemCmd::Writeback</a>) {
<a name="l00578"></a>00578                 <a class="code" href="classBaseCache.html#a3f81ca9ba6f7294f930eca229838edc6">allocateWriteBuffer</a>(pkt, time, <span class="keyword">true</span>);
<a name="l00579"></a>00579             } <span class="keywordflow">else</span> {
<a name="l00580"></a>00580                 <span class="keywordflow">if</span> (blk &amp;&amp; blk-&gt;isValid()) {
<a name="l00581"></a>00581                     <span class="comment">// If we have a write miss to a valid block, we</span>
<a name="l00582"></a>00582                     <span class="comment">// need to mark the block non-readable.  Otherwise</span>
<a name="l00583"></a>00583                     <span class="comment">// if we allow reads while there&apos;s an outstanding</span>
<a name="l00584"></a>00584                     <span class="comment">// write miss, the read could return stale data</span>
<a name="l00585"></a>00585                     <span class="comment">// out of the cache block... a more aggressive</span>
<a name="l00586"></a>00586                     <span class="comment">// system could detect the overlap (if any) and</span>
<a name="l00587"></a>00587                     <span class="comment">// forward data out of the MSHRs, but we don&apos;t do</span>
<a name="l00588"></a>00588                     <span class="comment">// that yet.  Note that we do need to leave the</span>
<a name="l00589"></a>00589                     <span class="comment">// block valid so that it stays in the cache, in</span>
<a name="l00590"></a>00590                     <span class="comment">// case we get an upgrade response (and hence no</span>
<a name="l00591"></a>00591                     <span class="comment">// new data) when the write miss completes.</span>
<a name="l00592"></a>00592                     <span class="comment">// As long as CPUs do proper store/load forwarding</span>
<a name="l00593"></a>00593                     <span class="comment">// internally, and have a sufficiently weak memory</span>
<a name="l00594"></a>00594                     <span class="comment">// model, this is probably unnecessary, but at some</span>
<a name="l00595"></a>00595                     <span class="comment">// point it must have seemed like we needed it...</span>
<a name="l00596"></a>00596                     assert(pkt-&gt;<a class="code" href="classPacket.html#aa8e449288b878ff3ff7f286eb4d28b6a">needsExclusive</a>() &amp;&amp; !blk-&gt;isWritable());
<a name="l00597"></a>00597                     blk-&gt;status &amp;= ~<a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7ac413eacf0a0c4c85665e24fc3138ad50">BlkReadable</a>;
<a name="l00598"></a>00598                 }
<a name="l00599"></a>00599 
<a name="l00600"></a>00600                 <a class="code" href="classBaseCache.html#ac37432bbe5fab7cdf422ee29acf155f2">allocateMissBuffer</a>(pkt, time, <span class="keyword">true</span>);
<a name="l00601"></a>00601             }
<a name="l00602"></a>00602 
<a name="l00603"></a>00603             <span class="keywordflow">if</span> (<a class="code" href="classCache.html#a320f5a2352104b9b633113f9045461a3">prefetcher</a>) {
<a name="l00604"></a>00604                 next_pf_time = <a class="code" href="classCache.html#a320f5a2352104b9b633113f9045461a3">prefetcher</a>-&gt;<a class="code" href="classBasePrefetcher.html#a1d4199bee2a7f9e8f22bf9e84d5ceda4">notify</a>(pkt, time);
<a name="l00605"></a>00605             }
<a name="l00606"></a>00606         }
<a name="l00607"></a>00607     }
<a name="l00608"></a>00608 
<a name="l00609"></a>00609     <span class="keywordflow">if</span> (next_pf_time != 0)
<a name="l00610"></a>00610         <a class="code" href="classBaseCache.html#af0bf3b9e90ffddfd7762af4c5fd5247b">requestMemSideBus</a>(<a class="code" href="classBaseCache.html#a8ca466a3028d5dd05a9f31798a0115b8ad591c96d60dbceaf75076c496d695d14">Request_PF</a>, std::max(time, next_pf_time));
<a name="l00611"></a>00611 
<a name="l00612"></a>00612     <span class="comment">// copy writebacks to write buffer</span>
<a name="l00613"></a>00613     <span class="keywordflow">while</span> (!writebacks.empty()) {
<a name="l00614"></a>00614         <a class="code" href="classPacket.html">PacketPtr</a> wbPkt = writebacks.front();
<a name="l00615"></a>00615         <a class="code" href="classBaseCache.html#a3f81ca9ba6f7294f930eca229838edc6">allocateWriteBuffer</a>(wbPkt, time, <span class="keyword">true</span>);
<a name="l00616"></a>00616         writebacks.pop_front();
<a name="l00617"></a>00617     }
<a name="l00618"></a>00618 
<a name="l00619"></a>00619     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00620"></a>00620 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a083c4da6cf866d660a126f4174bba7fc"></a><!-- doxytag: member="Cache::recvTimingResp" ref="a083c4da6cf866d660a126f4174bba7fc" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void recvTimingResp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handles a response (cache line fill/write ack) from the bus. </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td>The response packet </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00880"></a>00880 {
<a name="l00881"></a>00881     assert(pkt-&gt;<a class="code" href="classPacket.html#a5f89a108755a6cb3e8185d85c850a816">isResponse</a>());
<a name="l00882"></a>00882 
<a name="l00883"></a>00883     <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> time = <a class="code" href="classClockedObject.html#a773956693f216cafb7d4cad92ad582e5">clockEdge</a>(<a class="code" href="classBaseCache.html#a4075fdc5720f8f0f57c379c396e74718">hitLatency</a>);
<a name="l00884"></a>00884     <a class="code" href="classMSHR.html">MSHR</a> *mshr = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classMSHR.html">MSHR</a>*<span class="keyword">&gt;</span>(pkt-&gt;<a class="code" href="classPacket.html#a983ade0479f946c813284dcc65073367">senderState</a>);
<a name="l00885"></a>00885     <span class="keywordtype">bool</span> is_error = pkt-&gt;<a class="code" href="classPacket.html#a32759931a1b2d6380407c6a18abd46e3">isError</a>();
<a name="l00886"></a>00886 
<a name="l00887"></a>00887     assert(mshr);
<a name="l00888"></a>00888 
<a name="l00889"></a>00889     <span class="keywordflow">if</span> (is_error) {
<a name="l00890"></a>00890         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;Cache received packet with error for address %x (%s), &quot;</span>
<a name="l00891"></a>00891                 <span class="stringliteral">&quot;cmd: %s\n&quot;</span>, pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>() ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;ns&quot;</span>,
<a name="l00892"></a>00892                 pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>());
<a name="l00893"></a>00893     }
<a name="l00894"></a>00894 
<a name="l00895"></a>00895     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;Handling response to %s for address %x (%s)\n&quot;</span>,
<a name="l00896"></a>00896             pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(), pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>() ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;ns&quot;</span>);
<a name="l00897"></a>00897 
<a name="l00898"></a>00898     <a class="code" href="classMSHRQueue.html">MSHRQueue</a> *mq = mshr-&gt;<a class="code" href="classMSHR.html#a524ec1b0c7b11e23904171e42211679e">queue</a>;
<a name="l00899"></a>00899     <span class="keywordtype">bool</span> wasFull = mq-&gt;<a class="code" href="classMSHRQueue.html#a7ffe8a6212a0eb3fc7bbc8e9bc51dfcd">isFull</a>();
<a name="l00900"></a>00900 
<a name="l00901"></a>00901     <span class="keywordflow">if</span> (mshr == <a class="code" href="classBaseCache.html#ae429d09cb5301f34a7eb7e6c765d4441">noTargetMSHR</a>) {
<a name="l00902"></a>00902         <span class="comment">// we always clear at least one target</span>
<a name="l00903"></a>00903         <a class="code" href="classBaseCache.html#a78948a7bd2b849859bfc6fee2fc3d070">clearBlocked</a>(<a class="code" href="classBaseCache.html#a98297f294858ead7eafd19af93e64c6da2e0db8e863cb5a0c10b73be89a535323">Blocked_NoTargets</a>);
<a name="l00904"></a>00904         <a class="code" href="classBaseCache.html#ae429d09cb5301f34a7eb7e6c765d4441">noTargetMSHR</a> = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00905"></a>00905     }
<a name="l00906"></a>00906 
<a name="l00907"></a>00907     <span class="comment">// Initial target is used just for stats</span>
<a name="l00908"></a>00908     <a class="code" href="classMSHR_1_1Target.html">MSHR::Target</a> *initial_tgt = mshr-&gt;<a class="code" href="classMSHR.html#ae068bab5bed8991efdfcd7829d9ca5e3">getTarget</a>();
<a name="l00909"></a>00909     <a class="code" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *blk = <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;findBlock(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>());
<a name="l00910"></a>00910     <span class="keywordtype">int</span> stats_cmd_idx = initial_tgt-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#a8db75870e65b9d86793f2805097c05a0" title="Return the index of this command.">cmdToIndex</a>();
<a name="l00911"></a>00911     <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> miss_latency = <a class="code" href="statistics_8hh.html#a7acdccbf0d35ce0c159c0cdd36371b22" title="The universal simulation clock.">curTick</a>() - initial_tgt-&gt;<a class="code" href="classMSHR_1_1Target.html#afb564669ac735617979c31edf7f97e2a" title="Time when request was received (for stats).">recvTime</a>;
<a name="l00912"></a>00912     <a class="code" href="classstd_1_1list.html">PacketList</a> <a class="code" href="group__CacheStatistics.html#gace2b37e760e47862f243e4b03c05ef5e">writebacks</a>;
<a name="l00913"></a>00913 
<a name="l00914"></a>00914     <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a70c74b2809417ea8701dd6ba9e34312d">isUncacheable</a>()) {
<a name="l00915"></a>00915         assert(pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a9b7d32db0521388c0953e531c79aab50">masterId</a>() &lt; <a class="code" href="classBaseCache.html#af27ccd765f13a4b7bd119dc7579e2746">system</a>-&gt;<a class="code" href="classSystem.html#a4cd916c36458ce47e9ba4ccbfc75a095">maxMasters</a>());
<a name="l00916"></a>00916         <a class="code" href="group__CacheStatistics.html#ga7dd6d70b9cba9493a783a2aceadb23b1">mshr_uncacheable_lat</a>[stats_cmd_idx][pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a9b7d32db0521388c0953e531c79aab50">masterId</a>()] +=
<a name="l00917"></a>00917             miss_latency;
<a name="l00918"></a>00918     } <span class="keywordflow">else</span> {
<a name="l00919"></a>00919         assert(pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a9b7d32db0521388c0953e531c79aab50">masterId</a>() &lt; <a class="code" href="classBaseCache.html#af27ccd765f13a4b7bd119dc7579e2746">system</a>-&gt;<a class="code" href="classSystem.html#a4cd916c36458ce47e9ba4ccbfc75a095">maxMasters</a>());
<a name="l00920"></a>00920         <a class="code" href="group__CacheStatistics.html#gacfad5551221a8363918fd4b484112695">mshr_miss_latency</a>[stats_cmd_idx][pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a9b7d32db0521388c0953e531c79aab50">masterId</a>()] +=
<a name="l00921"></a>00921             miss_latency;
<a name="l00922"></a>00922     }
<a name="l00923"></a>00923 
<a name="l00924"></a>00924     <span class="keywordtype">bool</span> is_fill = !mshr-&gt;<a class="code" href="classMSHR.html#a9b36b981f171b10bc35fbd5f79c3bae1">isForward</a> &amp;&amp;
<a name="l00925"></a>00925         (pkt-&gt;<a class="code" href="classPacket.html#adc47901747fc3c447db3abddaf01491a">isRead</a>() || pkt-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153aff67b7f8eb8b6a17a896579c2dd6195c">MemCmd::UpgradeResp</a>);
<a name="l00926"></a>00926 
<a name="l00927"></a>00927     <span class="keywordflow">if</span> (is_fill &amp;&amp; !is_error) {
<a name="l00928"></a>00928         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;Block for addr %x being updated in Cache\n&quot;</span>,
<a name="l00929"></a>00929                 pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>());
<a name="l00930"></a>00930 
<a name="l00931"></a>00931         <span class="comment">// give mshr a chance to do some dirty work</span>
<a name="l00932"></a>00932         mshr-&gt;<a class="code" href="classMSHR.html#aff2dbaf9542ae841979f44a7af2fab0b">handleFill</a>(pkt, blk);
<a name="l00933"></a>00933 
<a name="l00934"></a>00934         blk = <a class="code" href="classCache.html#a4943b9a8a4801f454a968416b456dc21">handleFill</a>(pkt, blk, writebacks);
<a name="l00935"></a>00935         assert(blk != <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>);
<a name="l00936"></a>00936     }
<a name="l00937"></a>00937 
<a name="l00938"></a>00938     <span class="comment">// First offset for critical word first calculations</span>
<a name="l00939"></a>00939     <span class="keywordtype">int</span> initial_offset = 0;
<a name="l00940"></a>00940 
<a name="l00941"></a>00941     <span class="keywordflow">if</span> (mshr-&gt;<a class="code" href="classMSHR.html#a9b007d67bfb5a6ff382a6d78ec08b3af">hasTargets</a>()) {
<a name="l00942"></a>00942         initial_offset = mshr-&gt;<a class="code" href="classMSHR.html#ae068bab5bed8991efdfcd7829d9ca5e3">getTarget</a>()-&gt;pkt-&gt;getOffset(<a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a>);
<a name="l00943"></a>00943     }
<a name="l00944"></a>00944 
<a name="l00945"></a>00945     <span class="keywordflow">while</span> (mshr-&gt;<a class="code" href="classMSHR.html#a9b007d67bfb5a6ff382a6d78ec08b3af">hasTargets</a>()) {
<a name="l00946"></a>00946         <a class="code" href="classMSHR_1_1Target.html">MSHR::Target</a> *target = mshr-&gt;<a class="code" href="classMSHR.html#ae068bab5bed8991efdfcd7829d9ca5e3">getTarget</a>();
<a name="l00947"></a>00947 
<a name="l00948"></a>00948         <span class="keywordflow">switch</span> (target-&gt;<a class="code" href="classMSHR_1_1Target.html#a6bfef4fd519b1708e99617d59d9c62cd" title="Did request come from cpu, memory, or prefetcher?">source</a>) {
<a name="l00949"></a>00949           <span class="keywordflow">case</span> <a class="code" href="classMSHR_1_1Target.html#a176e1eca2d1e3d1c6a064340bc6a351ead87ddc653bf916825f87a824895e88f7">MSHR::Target::FromCPU</a>:
<a name="l00950"></a>00950             <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> completion_time;
<a name="l00951"></a>00951             <span class="keywordflow">if</span> (is_fill) {
<a name="l00952"></a>00952                 <a class="code" href="classCache.html#a5d5d5944479d29a7bfc183f4b2b6a4fa">satisfyCpuSideRequest</a>(target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>, blk,
<a name="l00953"></a>00953                                       <span class="keyword">true</span>, mshr-&gt;<a class="code" href="classMSHR.html#a74c74cd6091f9e3e1523d3044ae9e9b4">hasPostDowngrade</a>());
<a name="l00954"></a>00954                 <span class="comment">// How many bytes past the first request is this one</span>
<a name="l00955"></a>00955                 <span class="keywordtype">int</span> transfer_offset =
<a name="l00956"></a>00956                     target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#a8c497c6b3c41668562b2a2aa57ad098d">getOffset</a>(<a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a>) - initial_offset;
<a name="l00957"></a>00957                 <span class="keywordflow">if</span> (transfer_offset &lt; 0) {
<a name="l00958"></a>00958                     transfer_offset += <a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a>;
<a name="l00959"></a>00959                 }
<a name="l00960"></a>00960 
<a name="l00961"></a>00961                 <span class="comment">// If critical word (no offset) return first word time.</span>
<a name="l00962"></a>00962                 <span class="comment">// responseLatency is the latency of the return path</span>
<a name="l00963"></a>00963                 <span class="comment">// from lower level caches/memory to an upper level cache or</span>
<a name="l00964"></a>00964                 <span class="comment">// the core.</span>
<a name="l00965"></a>00965                 completion_time = <a class="code" href="classClockedObject.html#a773956693f216cafb7d4cad92ad582e5">clockEdge</a>(<a class="code" href="classBaseCache.html#ab3672589b3ea30e547b2a30f50d814eb">responseLatency</a>) +
<a name="l00966"></a>00966                     (transfer_offset ? pkt-&gt;<a class="code" href="classPacket.html#a7bf8ae0a056329f751eda8b39ca4c268">busLastWordDelay</a> :
<a name="l00967"></a>00967                      pkt-&gt;<a class="code" href="classPacket.html#af8986a05caa6c5b96b0b01bb6cf47772">busFirstWordDelay</a>);
<a name="l00968"></a>00968 
<a name="l00969"></a>00969                 assert(!target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a70c74b2809417ea8701dd6ba9e34312d">isUncacheable</a>());
<a name="l00970"></a>00970 
<a name="l00971"></a>00971                 assert(target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a9b7d32db0521388c0953e531c79aab50">masterId</a>() &lt; <a class="code" href="classBaseCache.html#af27ccd765f13a4b7bd119dc7579e2746">system</a>-&gt;<a class="code" href="classSystem.html#a4cd916c36458ce47e9ba4ccbfc75a095">maxMasters</a>());
<a name="l00972"></a>00972                 <a class="code" href="group__CacheStatistics.html#gaf96751c776ee651f3284e22686b8978a">missLatency</a>[target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#a8db75870e65b9d86793f2805097c05a0" title="Return the index of this command.">cmdToIndex</a>()][target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a9b7d32db0521388c0953e531c79aab50">masterId</a>()] +=
<a name="l00973"></a>00973                     completion_time - target-&gt;<a class="code" href="classMSHR_1_1Target.html#afb564669ac735617979c31edf7f97e2a" title="Time when request was received (for stats).">recvTime</a>;
<a name="l00974"></a>00974             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153acf35994719250044eeb50aa07d996ed6">MemCmd::UpgradeFailResp</a>) {
<a name="l00975"></a>00975                 <span class="comment">// failed StoreCond upgrade</span>
<a name="l00976"></a>00976                 assert(target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a10ce12df51611216e2e8c4cb9b5d4047">MemCmd::StoreCondReq</a> ||
<a name="l00977"></a>00977                        target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a74dd6ebac6e139815fdc22edbae3cce3">MemCmd::StoreCondFailReq</a> ||
<a name="l00978"></a>00978                        target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153ac6ef7b72a17dbdd8c061094bf7554753">MemCmd::SCUpgradeFailReq</a>);
<a name="l00979"></a>00979                 <span class="comment">// responseLatency is the latency of the return path</span>
<a name="l00980"></a>00980                 <span class="comment">// from lower level caches/memory to an upper level cache or</span>
<a name="l00981"></a>00981                 <span class="comment">// the core.</span>
<a name="l00982"></a>00982                 completion_time = <a class="code" href="classClockedObject.html#a773956693f216cafb7d4cad92ad582e5">clockEdge</a>(<a class="code" href="classBaseCache.html#ab3672589b3ea30e547b2a30f50d814eb">responseLatency</a>) +
<a name="l00983"></a>00983                     pkt-&gt;<a class="code" href="classPacket.html#a7bf8ae0a056329f751eda8b39ca4c268">busLastWordDelay</a>;
<a name="l00984"></a>00984                 target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#ac73800a0bae4776befb9d416e95ea6d9">setExtraData</a>(0);
<a name="l00985"></a>00985             } <span class="keywordflow">else</span> {
<a name="l00986"></a>00986                 <span class="comment">// not a cache fill, just forwarding response</span>
<a name="l00987"></a>00987                 <span class="comment">// responseLatency is the latency of the return path</span>
<a name="l00988"></a>00988                 <span class="comment">// from lower level cahces/memory to the core.</span>
<a name="l00989"></a>00989                 completion_time = <a class="code" href="classClockedObject.html#a773956693f216cafb7d4cad92ad582e5">clockEdge</a>(<a class="code" href="classBaseCache.html#ab3672589b3ea30e547b2a30f50d814eb">responseLatency</a>) +
<a name="l00990"></a>00990                     pkt-&gt;<a class="code" href="classPacket.html#a7bf8ae0a056329f751eda8b39ca4c268">busLastWordDelay</a>;
<a name="l00991"></a>00991                 <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#adc47901747fc3c447db3abddaf01491a">isRead</a>() &amp;&amp; !is_error) {
<a name="l00992"></a>00992                     target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#aaa0b1cd19807fc630d9331be9f5d1d36">setData</a>(pkt-&gt;<a class="code" href="classPacket.html#a5c451baf3f0a89084e79e69bb9061200">getPtr</a>&lt;uint8_t&gt;());
<a name="l00993"></a>00993                 }
<a name="l00994"></a>00994             }
<a name="l00995"></a>00995             target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#a325088bded521f69342b08a548811332">makeTimingResponse</a>();
<a name="l00996"></a>00996             <span class="comment">// if this packet is an error copy that to the new packet</span>
<a name="l00997"></a>00997             <span class="keywordflow">if</span> (is_error)
<a name="l00998"></a>00998                 target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#a838dc8f424eaa81aa7ee30fb4c5900a0">copyError</a>(pkt);
<a name="l00999"></a>00999             <span class="keywordflow">if</span> (target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153ab3b23336c0b9e51ce2b80101dc975aa2">MemCmd::ReadResp</a> &amp;&amp;
<a name="l01000"></a>01000                 (pkt-&gt;<a class="code" href="classPacket.html#a4a1a39b8ffab2d6266cd9d794ca332e3">isInvalidate</a>() || mshr-&gt;<a class="code" href="classMSHR.html#a492fb8bb0290ba36d8d05d9f86b8e754">hasPostInvalidate</a>())) {
<a name="l01001"></a>01001                 <span class="comment">// If intermediate cache got ReadRespWithInvalidate,</span>
<a name="l01002"></a>01002                 <span class="comment">// propagate that.  Response should not have</span>
<a name="l01003"></a>01003                 <span class="comment">// isInvalidate() set otherwise.</span>
<a name="l01004"></a>01004                 target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> = <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a2cea517c889453c5a51450f7ad62b9e6">MemCmd::ReadRespWithInvalidate</a>;
<a name="l01005"></a>01005                 <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;%s updated cmd to %s for address %x\n&quot;</span>,
<a name="l01006"></a>01006                         __func__, target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(),
<a name="l01007"></a>01007                         target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>());
<a name="l01008"></a>01008             }
<a name="l01009"></a>01009             <span class="comment">// reset the bus additional time as it is now accounted for</span>
<a name="l01010"></a>01010             target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#af8986a05caa6c5b96b0b01bb6cf47772">busFirstWordDelay</a> = target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#a7bf8ae0a056329f751eda8b39ca4c268">busLastWordDelay</a> = 0;
<a name="l01011"></a>01011             <a class="code" href="classBaseCache.html#a14913ffff181227d085f25a95e6ada42">cpuSidePort</a>-&gt;<a class="code" href="classQueuedSlavePort.html#a31c2fe79e7cbd7319eb327074e412675">schedTimingResp</a>(target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>, completion_time);
<a name="l01012"></a>01012             <span class="keywordflow">break</span>;
<a name="l01013"></a>01013 
<a name="l01014"></a>01014           <span class="keywordflow">case</span> <a class="code" href="classMSHR_1_1Target.html#a176e1eca2d1e3d1c6a064340bc6a351ea63c0c00defe35fdf63539ff5fff462c7">MSHR::Target::FromPrefetcher</a>:
<a name="l01015"></a>01015             assert(target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153af939e2f740d217d26e90546059593b39">MemCmd::HardPFReq</a>);
<a name="l01016"></a>01016             <span class="keywordflow">if</span> (blk)
<a name="l01017"></a>01017                 blk-&gt;status |= <a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7aa64aeb976bf10b41a7c383f0035f753b">BlkHWPrefetched</a>;
<a name="l01018"></a>01018             <span class="keyword">delete</span> target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>;
<a name="l01019"></a>01019             <span class="keyword">delete</span> target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>;
<a name="l01020"></a>01020             <span class="keywordflow">break</span>;
<a name="l01021"></a>01021 
<a name="l01022"></a>01022           <span class="keywordflow">case</span> <a class="code" href="classMSHR_1_1Target.html#a176e1eca2d1e3d1c6a064340bc6a351eaa3edd380596b2be1636c4a8b7f18611f">MSHR::Target::FromSnoop</a>:
<a name="l01023"></a>01023             <span class="comment">// I don&apos;t believe that a snoop can be in an error state</span>
<a name="l01024"></a>01024             assert(!is_error);
<a name="l01025"></a>01025             <span class="comment">// response to snoop request</span>
<a name="l01026"></a>01026             <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;processing deferred snoop...\n&quot;</span>);
<a name="l01027"></a>01027             assert(!(pkt-&gt;<a class="code" href="classPacket.html#a4a1a39b8ffab2d6266cd9d794ca332e3">isInvalidate</a>() &amp;&amp; !mshr-&gt;<a class="code" href="classMSHR.html#a492fb8bb0290ba36d8d05d9f86b8e754">hasPostInvalidate</a>()));
<a name="l01028"></a>01028             <a class="code" href="classCache.html#affa22df454ca8619381018b222c49c2d">handleSnoop</a>(target-&gt;<a class="code" href="classMSHR_1_1Target.html#a3a891bc2a0fcbe6be5297077d94e2df7" title="Pending request packet.">pkt</a>, blk, <span class="keyword">true</span>, <span class="keyword">true</span>,
<a name="l01029"></a>01029                         mshr-&gt;<a class="code" href="classMSHR.html#a492fb8bb0290ba36d8d05d9f86b8e754">hasPostInvalidate</a>());
<a name="l01030"></a>01030             <span class="keywordflow">break</span>;
<a name="l01031"></a>01031 
<a name="l01032"></a>01032           <span class="keywordflow">default</span>:
<a name="l01033"></a>01033             <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;Illegal target-&gt;source enum %d\n&quot;</span>, target-&gt;<a class="code" href="classMSHR_1_1Target.html#a6bfef4fd519b1708e99617d59d9c62cd" title="Did request come from cpu, memory, or prefetcher?">source</a>);
<a name="l01034"></a>01034         }
<a name="l01035"></a>01035 
<a name="l01036"></a>01036         mshr-&gt;<a class="code" href="classMSHR.html#a660e7beed1d7d25852a9bc63d1f314b3">popTarget</a>();
<a name="l01037"></a>01037     }
<a name="l01038"></a>01038 
<a name="l01039"></a>01039     <span class="keywordflow">if</span> (blk &amp;&amp; blk-&gt;isValid()) {
<a name="l01040"></a>01040         <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a4a1a39b8ffab2d6266cd9d794ca332e3">isInvalidate</a>() || mshr-&gt;<a class="code" href="classMSHR.html#a492fb8bb0290ba36d8d05d9f86b8e754">hasPostInvalidate</a>()) {
<a name="l01041"></a>01041             assert(blk != <a class="code" href="classCache.html#a0ca2086b66114357dd17032178adce17">tempBlock</a>);
<a name="l01042"></a>01042             <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;invalidate(blk);
<a name="l01043"></a>01043             blk-&gt;invalidate();
<a name="l01044"></a>01044         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mshr-&gt;<a class="code" href="classMSHR.html#a74c74cd6091f9e3e1523d3044ae9e9b4">hasPostDowngrade</a>()) {
<a name="l01045"></a>01045             blk-&gt;status &amp;= ~<a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7a202d95c1090db0082a7a954856ad5358">BlkWritable</a>;
<a name="l01046"></a>01046         }
<a name="l01047"></a>01047     }
<a name="l01048"></a>01048 
<a name="l01049"></a>01049     <span class="keywordflow">if</span> (mshr-&gt;<a class="code" href="classMSHR.html#a6b0d016d76a2a7570d1d51eaa3086845">promoteDeferredTargets</a>()) {
<a name="l01050"></a>01050         <span class="comment">// avoid later read getting stale data while write miss is</span>
<a name="l01051"></a>01051         <span class="comment">// outstanding.. see comment in timingAccess()</span>
<a name="l01052"></a>01052         <span class="keywordflow">if</span> (blk) {
<a name="l01053"></a>01053             blk-&gt;status &amp;= ~<a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7ac413eacf0a0c4c85665e24fc3138ad50">BlkReadable</a>;
<a name="l01054"></a>01054         }
<a name="l01055"></a>01055         mq = mshr-&gt;<a class="code" href="classMSHR.html#a524ec1b0c7b11e23904171e42211679e">queue</a>;
<a name="l01056"></a>01056         mq-&gt;<a class="code" href="classMSHRQueue.html#ab0f258b25fe50dc16d5e3e5890214c5c">markPending</a>(mshr);
<a name="l01057"></a>01057         <a class="code" href="classBaseCache.html#af0bf3b9e90ffddfd7762af4c5fd5247b">requestMemSideBus</a>((<a class="code" href="classBaseCache.html#a8ca466a3028d5dd05a9f31798a0115b8">RequestCause</a>)mq-&gt;index, <a class="code" href="classClockedObject.html#a773956693f216cafb7d4cad92ad582e5">clockEdge</a>() +
<a name="l01058"></a>01058                           pkt-&gt;<a class="code" href="classPacket.html#a7bf8ae0a056329f751eda8b39ca4c268">busLastWordDelay</a>);
<a name="l01059"></a>01059     } <span class="keywordflow">else</span> {
<a name="l01060"></a>01060         mq-&gt;deallocate(mshr);
<a name="l01061"></a>01061         <span class="keywordflow">if</span> (wasFull &amp;&amp; !mq-&gt;isFull()) {
<a name="l01062"></a>01062             <a class="code" href="classBaseCache.html#a78948a7bd2b849859bfc6fee2fc3d070">clearBlocked</a>((<a class="code" href="classBaseCache.html#a98297f294858ead7eafd19af93e64c6d">BlockedCause</a>)mq-&gt;index);
<a name="l01063"></a>01063         }
<a name="l01064"></a>01064     }
<a name="l01065"></a>01065 
<a name="l01066"></a>01066     <span class="comment">// copy writebacks to write buffer</span>
<a name="l01067"></a>01067     <span class="keywordflow">while</span> (!writebacks.empty()) {
<a name="l01068"></a>01068         <a class="code" href="classPacket.html">PacketPtr</a> wbPkt = writebacks.front();
<a name="l01069"></a>01069         <a class="code" href="classBaseCache.html#a3f81ca9ba6f7294f930eca229838edc6">allocateWriteBuffer</a>(wbPkt, time, <span class="keyword">true</span>);
<a name="l01070"></a>01070         writebacks.pop_front();
<a name="l01071"></a>01071     }
<a name="l01072"></a>01072     <span class="comment">// if we used temp block, clear it out</span>
<a name="l01073"></a>01073     <span class="keywordflow">if</span> (blk == <a class="code" href="classCache.html#a0ca2086b66114357dd17032178adce17">tempBlock</a>) {
<a name="l01074"></a>01074         <span class="keywordflow">if</span> (blk-&gt;isDirty()) {
<a name="l01075"></a>01075             <a class="code" href="classBaseCache.html#a3f81ca9ba6f7294f930eca229838edc6">allocateWriteBuffer</a>(<a class="code" href="classCache.html#a4451141787cceb771eec3ea4d4a4a8d4">writebackBlk</a>(blk), time, <span class="keyword">true</span>);
<a name="l01076"></a>01076         }
<a name="l01077"></a>01077         blk-&gt;invalidate();
<a name="l01078"></a>01078     }
<a name="l01079"></a>01079 
<a name="l01080"></a>01080     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;Leaving %s with %s for address %x\n&quot;</span>, __func__,
<a name="l01081"></a>01081             pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(), pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>());
<a name="l01082"></a>01082     <span class="keyword">delete</span> pkt;
<a name="l01083"></a>01083 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aff3031c56fc4947a19695c868bb8233e"></a><!-- doxytag: member="Cache::recvTimingSnoopReq" ref="aff3031c56fc4947a19695c868bb8233e" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void recvTimingSnoopReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Snoops bus transactions to maintain coherence. </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td>The current bus transaction. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01488"></a>01488 {
<a name="l01489"></a>01489     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;%s for %s address %x size %d\n&quot;</span>, __func__,
<a name="l01490"></a>01490             pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(), pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), pkt-&gt;<a class="code" href="classPacket.html#a1d18ba49c7be427da1f4a42d53e35f48">getSize</a>());
<a name="l01491"></a>01491 
<a name="l01492"></a>01492     <span class="comment">// Snoops shouldn&apos;t happen when bypassing caches</span>
<a name="l01493"></a>01493     assert(!<a class="code" href="classBaseCache.html#af27ccd765f13a4b7bd119dc7579e2746">system</a>-&gt;<a class="code" href="classSystem.html#a613d9d917b0e950cd322026de403d702">bypassCaches</a>());
<a name="l01494"></a>01494 
<a name="l01495"></a>01495     <span class="comment">// check if the packet is for an address range covered by this</span>
<a name="l01496"></a>01496     <span class="comment">// cache, partly to not waste time looking for it, but also to</span>
<a name="l01497"></a>01497     <span class="comment">// ensure that we only forward the snoop upwards if it is within</span>
<a name="l01498"></a>01498     <span class="comment">// our address ranges</span>
<a name="l01499"></a>01499     <span class="keywordtype">bool</span> in_range = <span class="keyword">false</span>;
<a name="l01500"></a>01500     <span class="keywordflow">for</span> (AddrRangeList::const_iterator <a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a> = <a class="code" href="classBaseCache.html#aad23e5e7311cbfb1189b674238254c39">addrRanges</a>.begin();
<a name="l01501"></a>01501          <a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a> != <a class="code" href="classBaseCache.html#aad23e5e7311cbfb1189b674238254c39">addrRanges</a>.end(); ++<a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a>) {
<a name="l01502"></a>01502         <span class="keywordflow">if</span> (<a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a>-&gt;contains(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>())) {
<a name="l01503"></a>01503             in_range = <span class="keyword">true</span>;
<a name="l01504"></a>01504             <span class="keywordflow">break</span>;
<a name="l01505"></a>01505         }
<a name="l01506"></a>01506     }
<a name="l01507"></a>01507 
<a name="l01508"></a>01508     <span class="comment">// Note that some deferred snoops don&apos;t have requests, since the</span>
<a name="l01509"></a>01509     <span class="comment">// original access may have already completed</span>
<a name="l01510"></a>01510     <span class="keywordflow">if</span> ((pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a> &amp;&amp; pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#a70c74b2809417ea8701dd6ba9e34312d">isUncacheable</a>()) ||
<a name="l01511"></a>01511         pkt-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a89447e3db973b10c03f68d590c65e8e6">MemCmd::Writeback</a> || !in_range) {
<a name="l01512"></a>01512         <span class="comment">//Can&apos;t get a hit on an uncacheable address</span>
<a name="l01513"></a>01513         <span class="comment">//Revisit this for multi level coherence</span>
<a name="l01514"></a>01514         <span class="keywordflow">return</span>;
<a name="l01515"></a>01515     }
<a name="l01516"></a>01516 
<a name="l01517"></a>01517     <span class="keywordtype">bool</span> is_secure = pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>();
<a name="l01518"></a>01518     <a class="code" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *blk = <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;findBlock(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), is_secure);
<a name="l01519"></a>01519 
<a name="l01520"></a>01520     <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> blk_addr = <a class="code" href="classBaseCache.html#a676df8321350e810fc857d99cdcebc22">blockAlign</a>(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>());
<a name="l01521"></a>01521     <a class="code" href="classMSHR.html">MSHR</a> *mshr = <a class="code" href="classBaseCache.html#aa73933a75144caca7a7d3d77cf285c23">mshrQueue</a>.<a class="code" href="classMSHRQueue.html#aab842d63dcd254dfe655e16075f7e0fe">findMatch</a>(blk_addr, is_secure);
<a name="l01522"></a>01522 
<a name="l01523"></a>01523     <span class="comment">// Squash any prefetch requests from below on MSHR hits</span>
<a name="l01524"></a>01524     <span class="keywordflow">if</span> (mshr &amp;&amp; pkt-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153af939e2f740d217d26e90546059593b39">MemCmd::HardPFReq</a>) {
<a name="l01525"></a>01525         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;Squashing prefetch from lower cache on mshr hit %#x\n&quot;</span>,
<a name="l01526"></a>01526                 pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>());
<a name="l01527"></a>01527         pkt-&gt;<a class="code" href="classPacket.html#a49108ef8d9510ea6b9982e9e97ca971b">setPrefetchSquashed</a>();
<a name="l01528"></a>01528         <span class="keywordflow">return</span>;
<a name="l01529"></a>01529     }
<a name="l01530"></a>01530 
<a name="l01531"></a>01531     <span class="comment">// Let the MSHR itself track the snoop and decide whether we want</span>
<a name="l01532"></a>01532     <span class="comment">// to go ahead and do the regular cache snoop</span>
<a name="l01533"></a>01533     <span class="keywordflow">if</span> (mshr &amp;&amp; mshr-&gt;handleSnoop(pkt, <a class="code" href="classBaseCache.html#ab26c49bd3bef351f3658df29505d78dd">order</a>++)) {
<a name="l01534"></a>01534         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;Deferring snoop on in-service MSHR to blk %x (%s).&quot;</span>
<a name="l01535"></a>01535                 <span class="stringliteral">&quot;mshrs: %s\n&quot;</span>, blk_addr, is_secure ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;ns&quot;</span>,
<a name="l01536"></a>01536                 mshr-&gt;print());
<a name="l01537"></a>01537 
<a name="l01538"></a>01538         <span class="keywordflow">if</span> (mshr-&gt;getNumTargets() &gt; <a class="code" href="classBaseCache.html#a3c2d74d5455e7b8ccefd3edb38c291de">numTarget</a>)
<a name="l01539"></a>01539             <a class="code" href="base_2misc_8hh.html#a8224a361dddd2ad59b411982e5ea746f">warn</a>(<span class="stringliteral">&quot;allocating bonus target for snoop&quot;</span>); <span class="comment">//handle later</span>
<a name="l01540"></a>01540         <span class="keywordflow">return</span>;
<a name="l01541"></a>01541     }
<a name="l01542"></a>01542 
<a name="l01543"></a>01543     <span class="comment">//We also need to check the writeback buffers and handle those</span>
<a name="l01544"></a>01544     <a class="code" href="classstd_1_1vector.html">std::vector&lt;MSHR *&gt;</a> <a class="code" href="group__CacheStatistics.html#gace2b37e760e47862f243e4b03c05ef5e">writebacks</a>;
<a name="l01545"></a>01545     <span class="keywordflow">if</span> (<a class="code" href="classBaseCache.html#ad44ec41bd8517224df8584b5e7fbe372">writeBuffer</a>.<a class="code" href="classMSHRQueue.html#a020dd5bb628863baf3800f816cfba197">findMatches</a>(blk_addr, is_secure, writebacks)) {
<a name="l01546"></a>01546         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;Snoop hit in writeback to addr: %x (%s)\n&quot;</span>,
<a name="l01547"></a>01547                 pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), is_secure ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;ns&quot;</span>);
<a name="l01548"></a>01548 
<a name="l01549"></a>01549         <span class="comment">//Look through writebacks for any non-uncachable writes, use that</span>
<a name="l01550"></a>01550         <span class="keywordflow">if</span> (writebacks.size()) {
<a name="l01551"></a>01551             <span class="comment">// We should only ever find a single match</span>
<a name="l01552"></a>01552             assert(writebacks.size() == 1);
<a name="l01553"></a>01553             mshr = writebacks[0];
<a name="l01554"></a>01554             assert(!mshr-&gt;isUncacheable());
<a name="l01555"></a>01555             assert(mshr-&gt;getNumTargets() == 1);
<a name="l01556"></a>01556             <a class="code" href="classPacket.html">PacketPtr</a> wb_pkt = mshr-&gt;getTarget()-&gt;pkt;
<a name="l01557"></a>01557             assert(wb_pkt-&gt;cmd == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a89447e3db973b10c03f68d590c65e8e6">MemCmd::Writeback</a>);
<a name="l01558"></a>01558 
<a name="l01559"></a>01559             assert(!pkt-&gt;<a class="code" href="classPacket.html#a9693a1ffeda326646443ab2a2a92be41">memInhibitAsserted</a>());
<a name="l01560"></a>01560             pkt-&gt;<a class="code" href="classPacket.html#a159497b4ab2144a0c1c36d2266df17d1">assertMemInhibit</a>();
<a name="l01561"></a>01561             <span class="keywordflow">if</span> (!pkt-&gt;<a class="code" href="classPacket.html#aa8e449288b878ff3ff7f286eb4d28b6a">needsExclusive</a>()) {
<a name="l01562"></a>01562                 pkt-&gt;<a class="code" href="classPacket.html#a40d9a7952a041e62ac388a0f523dee41">assertShared</a>();
<a name="l01563"></a>01563                 <span class="comment">// the writeback is no longer the exclusive copy in the system</span>
<a name="l01564"></a>01564                 wb_pkt-&gt;clearSupplyExclusive();
<a name="l01565"></a>01565             } <span class="keywordflow">else</span> {
<a name="l01566"></a>01566                 <span class="comment">// if we&apos;re not asserting the shared line, we need to</span>
<a name="l01567"></a>01567                 <span class="comment">// invalidate our copy.  we&apos;ll do that below as long as</span>
<a name="l01568"></a>01568                 <span class="comment">// the packet&apos;s invalidate flag is set...</span>
<a name="l01569"></a>01569                 assert(pkt-&gt;<a class="code" href="classPacket.html#a4a1a39b8ffab2d6266cd9d794ca332e3">isInvalidate</a>());
<a name="l01570"></a>01570             }
<a name="l01571"></a>01571             <a class="code" href="classCache.html#a87256886a1eea4638abe1b437f4fe226">doTimingSupplyResponse</a>(pkt, wb_pkt-&gt;<a class="code" href="classPacket.html#a5c451baf3f0a89084e79e69bb9061200">getPtr</a>&lt;uint8_t&gt;(),
<a name="l01572"></a>01572                                    <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l01573"></a>01573 
<a name="l01574"></a>01574             <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a4a1a39b8ffab2d6266cd9d794ca332e3">isInvalidate</a>()) {
<a name="l01575"></a>01575                 <span class="comment">// Invalidation trumps our writeback... discard here</span>
<a name="l01576"></a>01576                 <a class="code" href="classCache.html#ac7fb6ca824d25de54878584fd9dd8162">markInService</a>(mshr);
<a name="l01577"></a>01577                 <span class="keyword">delete</span> wb_pkt;
<a name="l01578"></a>01578             }
<a name="l01579"></a>01579         } <span class="comment">// writebacks.size()</span>
<a name="l01580"></a>01580     }
<a name="l01581"></a>01581 
<a name="l01582"></a>01582     <span class="comment">// If this was a shared writeback, there may still be</span>
<a name="l01583"></a>01583     <span class="comment">// other shared copies above that require invalidation.</span>
<a name="l01584"></a>01584     <span class="comment">// We could be more selective and return here if the</span>
<a name="l01585"></a>01585     <span class="comment">// request is non-exclusive or if the writeback is</span>
<a name="l01586"></a>01586     <span class="comment">// exclusive.</span>
<a name="l01587"></a>01587     <a class="code" href="classCache.html#affa22df454ca8619381018b222c49c2d">handleSnoop</a>(pkt, blk, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l01588"></a>01588 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a55143a3333ff75d0df66bd6e4eb50fb7"></a><!-- doxytag: member="Cache::recvTimingSnoopResp" ref="a55143a3333ff75d0df66bd6e4eb50fb7" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void recvTimingSnoopResp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handle a snoop response. </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td>Snoop response packet </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00378"></a>00378 {
<a name="l00379"></a>00379     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;%s for %s address %x size %d\n&quot;</span>, __func__,
<a name="l00380"></a>00380             pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(), pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), pkt-&gt;<a class="code" href="classPacket.html#a1d18ba49c7be427da1f4a42d53e35f48">getSize</a>());
<a name="l00381"></a>00381     <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> time = <a class="code" href="classClockedObject.html#a773956693f216cafb7d4cad92ad582e5">clockEdge</a>(<a class="code" href="classBaseCache.html#a4075fdc5720f8f0f57c379c396e74718">hitLatency</a>);
<a name="l00382"></a>00382 
<a name="l00383"></a>00383     assert(pkt-&gt;<a class="code" href="classPacket.html#a5f89a108755a6cb3e8185d85c850a816">isResponse</a>());
<a name="l00384"></a>00384 
<a name="l00385"></a>00385     <span class="comment">// must be cache-to-cache response from upper to lower level</span>
<a name="l00386"></a>00386     <a class="code" href="classForwardResponseRecord.html">ForwardResponseRecord</a> *rec =
<a name="l00387"></a>00387         <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classForwardResponseRecord.html">ForwardResponseRecord</a> *<span class="keyword">&gt;</span>(pkt-&gt;<a class="code" href="classPacket.html#a983ade0479f946c813284dcc65073367">senderState</a>);
<a name="l00388"></a>00388     assert(!<a class="code" href="classBaseCache.html#af27ccd765f13a4b7bd119dc7579e2746">system</a>-&gt;<a class="code" href="classSystem.html#a613d9d917b0e950cd322026de403d702">bypassCaches</a>());
<a name="l00389"></a>00389 
<a name="l00390"></a>00390     <span class="keywordflow">if</span> (rec == <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>) {
<a name="l00391"></a>00391         assert(pkt-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a11fb71a7824e3331bcee61ee9b4078dc">MemCmd::HardPFResp</a>);
<a name="l00392"></a>00392         <span class="comment">// Check if it&apos;s a prefetch response and handle it. We shouldn&apos;t</span>
<a name="l00393"></a>00393         <span class="comment">// get any other kinds of responses without FRRs.</span>
<a name="l00394"></a>00394         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;Got prefetch response from above for addr %#x (%s)\n&quot;</span>,
<a name="l00395"></a>00395                 pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>() ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;ns&quot;</span>);
<a name="l00396"></a>00396         <a class="code" href="classCache.html#a083c4da6cf866d660a126f4174bba7fc">recvTimingResp</a>(pkt);
<a name="l00397"></a>00397         <span class="keywordflow">return</span>;
<a name="l00398"></a>00398     }
<a name="l00399"></a>00399 
<a name="l00400"></a>00400     pkt-&gt;<a class="code" href="classPacket.html#a6f73d3ef605e592952b5586975161bfd">popSenderState</a>();
<a name="l00401"></a>00401     pkt-&gt;<a class="code" href="classPacket.html#a20739d8f669d352681830025686158ce" title="Accessor function to set the destination index of the packet.">setDest</a>(rec-&gt;prevSrc);
<a name="l00402"></a>00402     <span class="keyword">delete</span> rec;
<a name="l00403"></a>00403     <span class="comment">// @todo someone should pay for this</span>
<a name="l00404"></a>00404     pkt-&gt;<a class="code" href="classPacket.html#af8986a05caa6c5b96b0b01bb6cf47772">busFirstWordDelay</a> = pkt-&gt;<a class="code" href="classPacket.html#a7bf8ae0a056329f751eda8b39ca4c268">busLastWordDelay</a> = 0;
<a name="l00405"></a>00405     <a class="code" href="classBaseCache.html#af29f0c640654a651bf26558b4b39623b">memSidePort</a>-&gt;<a class="code" href="classQueuedMasterPort.html#aedc38469f895c00a0ffcb993598b7a53">schedTimingSnoopResp</a>(pkt, time);
<a name="l00406"></a>00406 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4dc637449366fcdfc4e764cdf12d9b11"></a><!-- doxytag: member="Cache::regStats" ref="a4dc637449366fcdfc4e764cdf12d9b11" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regStats </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classRegister.html">Register</a> stats for this object. </p>

<p><a class="el" href="classBaseCache.html#a4dc637449366fcdfc4e764cdf12d9b11">BaseCache</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00102"></a>00102 {
<a name="l00103"></a>00103     <a class="code" href="classSimObject.html#a4dc637449366fcdfc4e764cdf12d9b11">BaseCache::regStats</a>();
<a name="l00104"></a>00104 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5d5d5944479d29a7bfc183f4b2b6a4fa"></a><!-- doxytag: member="Cache::satisfyCpuSideRequest" ref="a5d5d5944479d29a7bfc183f4b2b6a4fa" args="(PacketPtr pkt, BlkType *blk, bool deferred_response=false, bool pending_downgrade=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void satisfyCpuSideRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *&nbsp;</td>
          <td class="paramname"> <em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>deferred_response</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pending_downgrade</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00151"></a>00151 {
<a name="l00152"></a>00152     assert(blk &amp;&amp; blk-&gt;isValid());
<a name="l00153"></a>00153     <span class="comment">// Occasionally this is not true... if we are a lower-level cache</span>
<a name="l00154"></a>00154     <span class="comment">// satisfying a string of Read and ReadEx requests from</span>
<a name="l00155"></a>00155     <span class="comment">// upper-level caches, a Read will mark the block as shared but we</span>
<a name="l00156"></a>00156     <span class="comment">// can satisfy a following ReadEx anyway since we can rely on the</span>
<a name="l00157"></a>00157     <span class="comment">// Read requester(s) to have buffered the ReadEx snoop and to</span>
<a name="l00158"></a>00158     <span class="comment">// invalidate their blocks after receiving them.</span>
<a name="l00159"></a>00159     <span class="comment">// assert(!pkt-&gt;needsExclusive() || blk-&gt;isWritable());</span>
<a name="l00160"></a>00160     assert(pkt-&gt;<a class="code" href="classPacket.html#a8c497c6b3c41668562b2a2aa57ad098d">getOffset</a>(<a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a>) + pkt-&gt;<a class="code" href="classPacket.html#a1d18ba49c7be427da1f4a42d53e35f48">getSize</a>() &lt;= <a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a>);
<a name="l00161"></a>00161 
<a name="l00162"></a>00162     <span class="comment">// Check RMW operations first since both isRead() and</span>
<a name="l00163"></a>00163     <span class="comment">// isWrite() will be true for them</span>
<a name="l00164"></a>00164     <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#af88eb56d484b750933cd2ea86594f001" title="The command field of the packet.">cmd</a> == <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a544e456dc06d65a6998a7df182d247d3">MemCmd::SwapReq</a>) {
<a name="l00165"></a>00165         <a class="code" href="classCache.html#a911af8215907296fb2453c696cb89a02">cmpAndSwap</a>(blk, pkt);
<a name="l00166"></a>00166     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#ab699d2f0d186312531fd1c279fd27b73">isWrite</a>()) {
<a name="l00167"></a>00167         <span class="keywordflow">if</span> (blk-&gt;checkWrite(pkt)) {
<a name="l00168"></a>00168             pkt-&gt;<a class="code" href="classPacket.html#ac14ab45b04f07f4aca586b773f2252db">writeDataToBlock</a>(blk-&gt;data, <a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a>);
<a name="l00169"></a>00169             blk-&gt;status |= <a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7a87715983fd384f5ee41ec0608f5c6e5f">BlkDirty</a>;
<a name="l00170"></a>00170         }
<a name="l00171"></a>00171     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#adc47901747fc3c447db3abddaf01491a">isRead</a>()) {
<a name="l00172"></a>00172         <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a8965874e960faf91ad4b6af8dbf31875">isLLSC</a>()) {
<a name="l00173"></a>00173             blk-&gt;trackLoadLocked(pkt);
<a name="l00174"></a>00174         }
<a name="l00175"></a>00175         pkt-&gt;<a class="code" href="classPacket.html#a0001ad64c160390fba5d1351862195ff">setDataFromBlock</a>(blk-&gt;data, <a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a>);
<a name="l00176"></a>00176         <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a1d18ba49c7be427da1f4a42d53e35f48">getSize</a>() == <a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a>) {
<a name="l00177"></a>00177             <span class="comment">// special handling for coherent block requests from</span>
<a name="l00178"></a>00178             <span class="comment">// upper-level caches</span>
<a name="l00179"></a>00179             <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#aa8e449288b878ff3ff7f286eb4d28b6a">needsExclusive</a>()) {
<a name="l00180"></a>00180                 <span class="comment">// if we have a dirty copy, make sure the recipient</span>
<a name="l00181"></a>00181                 <span class="comment">// keeps it marked dirty</span>
<a name="l00182"></a>00182                 <span class="keywordflow">if</span> (blk-&gt;isDirty()) {
<a name="l00183"></a>00183                     pkt-&gt;<a class="code" href="classPacket.html#a159497b4ab2144a0c1c36d2266df17d1">assertMemInhibit</a>();
<a name="l00184"></a>00184                 }
<a name="l00185"></a>00185                 <span class="comment">// on ReadExReq we give up our copy unconditionally</span>
<a name="l00186"></a>00186                 <span class="keywordflow">if</span> (blk != <a class="code" href="classCache.html#a0ca2086b66114357dd17032178adce17">tempBlock</a>)
<a name="l00187"></a>00187                     <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;invalidate(blk);
<a name="l00188"></a>00188                 blk-&gt;invalidate();
<a name="l00189"></a>00189             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (blk-&gt;isWritable() &amp;&amp; !pending_downgrade
<a name="l00190"></a>00190                       &amp;&amp; !pkt-&gt;<a class="code" href="classPacket.html#a298938bfa2613955b13f630ce2b591e4">sharedAsserted</a>() &amp;&amp; !pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#ae742b8e8aaa2e18506dc64c7b7f3fc0a">isInstFetch</a>()) {
<a name="l00191"></a>00191                 <span class="comment">// we can give the requester an exclusive copy (by not</span>
<a name="l00192"></a>00192                 <span class="comment">// asserting shared line) on a read request if:</span>
<a name="l00193"></a>00193                 <span class="comment">// - we have an exclusive copy at this level (&amp; below)</span>
<a name="l00194"></a>00194                 <span class="comment">// - we don&apos;t have a pending snoop from below</span>
<a name="l00195"></a>00195                 <span class="comment">//   signaling another read request</span>
<a name="l00196"></a>00196                 <span class="comment">// - no other cache above has a copy (otherwise it</span>
<a name="l00197"></a>00197                 <span class="comment">//   would have asseretd shared line on request)</span>
<a name="l00198"></a>00198                 <span class="comment">// - we are not satisfying an instruction fetch (this</span>
<a name="l00199"></a>00199                 <span class="comment">//   prevents dirty data in the i-cache)</span>
<a name="l00200"></a>00200 
<a name="l00201"></a>00201                 <span class="keywordflow">if</span> (blk-&gt;isDirty()) {
<a name="l00202"></a>00202                     <span class="comment">// special considerations if we&apos;re owner:</span>
<a name="l00203"></a>00203                     <span class="keywordflow">if</span> (!deferred_response &amp;&amp; !<a class="code" href="classBaseCache.html#a9d8582d06c3d2f59711d1bbf7d383df3">isTopLevel</a>) {
<a name="l00204"></a>00204                         <span class="comment">// if we are responding immediately and can</span>
<a name="l00205"></a>00205                         <span class="comment">// signal that we&apos;re transferring ownership</span>
<a name="l00206"></a>00206                         <span class="comment">// along with exclusivity, do so</span>
<a name="l00207"></a>00207                         pkt-&gt;<a class="code" href="classPacket.html#a159497b4ab2144a0c1c36d2266df17d1">assertMemInhibit</a>();
<a name="l00208"></a>00208                         blk-&gt;status &amp;= ~<a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7a87715983fd384f5ee41ec0608f5c6e5f">BlkDirty</a>;
<a name="l00209"></a>00209                     } <span class="keywordflow">else</span> {
<a name="l00210"></a>00210                         <span class="comment">// if we&apos;re responding after our own miss,</span>
<a name="l00211"></a>00211                         <span class="comment">// there&apos;s a window where the recipient didn&apos;t</span>
<a name="l00212"></a>00212                         <span class="comment">// know it was getting ownership and may not</span>
<a name="l00213"></a>00213                         <span class="comment">// have responded to snoops correctly, so we</span>
<a name="l00214"></a>00214                         <span class="comment">// can&apos;t pass off ownership *or* exclusivity</span>
<a name="l00215"></a>00215                         pkt-&gt;<a class="code" href="classPacket.html#a40d9a7952a041e62ac388a0f523dee41">assertShared</a>();
<a name="l00216"></a>00216                     }
<a name="l00217"></a>00217                 }
<a name="l00218"></a>00218             } <span class="keywordflow">else</span> {
<a name="l00219"></a>00219                 <span class="comment">// otherwise only respond with a shared copy</span>
<a name="l00220"></a>00220                 pkt-&gt;<a class="code" href="classPacket.html#a40d9a7952a041e62ac388a0f523dee41">assertShared</a>();
<a name="l00221"></a>00221             }
<a name="l00222"></a>00222         }
<a name="l00223"></a>00223     } <span class="keywordflow">else</span> {
<a name="l00224"></a>00224         <span class="comment">// Not a read or write... must be an upgrade.  it&apos;s OK</span>
<a name="l00225"></a>00225         <span class="comment">// to just ack those as long as we have an exclusive</span>
<a name="l00226"></a>00226         <span class="comment">// copy at this level.</span>
<a name="l00227"></a>00227         assert(pkt-&gt;<a class="code" href="classPacket.html#aadb2fde0aba4a65b45d591e9ef5b6a63">isUpgrade</a>());
<a name="l00228"></a>00228         assert(blk != <a class="code" href="classCache.html#a0ca2086b66114357dd17032178adce17">tempBlock</a>);
<a name="l00229"></a>00229         <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;invalidate(blk);
<a name="l00230"></a>00230         blk-&gt;invalidate();
<a name="l00231"></a>00231     }
<a name="l00232"></a>00232 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a65c1c67b81573ca17c8ad40e0e6d85d8"></a><!-- doxytag: member="Cache::satisfyMSHR" ref="a65c1c67b81573ca17c8ad40e0e6d85d8" args="(MSHR *mshr, PacketPtr pkt, BlkType *blk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool satisfyMSHR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMSHR.html">MSHR</a> *&nbsp;</td>
          <td class="paramname"> <em>mshr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *&nbsp;</td>
          <td class="paramname"> <em>blk</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a53e036786d17361be4c7320d39c99b84"></a><!-- doxytag: member="Cache::serialize" ref="a53e036786d17361be4c7320d39c99b84" args="(std::ostream &amp;os)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serialize </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>serialize the state of the caches We currently don't support checkpointing cache state, so this panics. </p>

<p><a class="el" href="classSerializable.html#ad6272f80ae37e8331e3969b3f072a801">Serializable</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l01821"></a>01821 {
<a name="l01822"></a>01822     <span class="keywordtype">bool</span> dirty(<a class="code" href="classCache.html#ad66f409af3c387e166ff7ee95169b7b6">isDirty</a>());
<a name="l01823"></a>01823 
<a name="l01824"></a>01824     <span class="keywordflow">if</span> (dirty) {
<a name="l01825"></a>01825         <a class="code" href="base_2misc_8hh.html#a8224a361dddd2ad59b411982e5ea746f">warn</a>(<span class="stringliteral">&quot;*** The cache still contains dirty data. ***\n&quot;</span>);
<a name="l01826"></a>01826         <a class="code" href="base_2misc_8hh.html#a8224a361dddd2ad59b411982e5ea746f">warn</a>(<span class="stringliteral">&quot;    Make sure to drain the system using the correct flags.\n&quot;</span>);
<a name="l01827"></a>01827         <a class="code" href="base_2misc_8hh.html#a8224a361dddd2ad59b411982e5ea746f">warn</a>(<span class="stringliteral">&quot;    This checkpoint will not restore correctly and dirty data in &quot;</span>
<a name="l01828"></a>01828              <span class="stringliteral">&quot;the cache will be lost!\n&quot;</span>);
<a name="l01829"></a>01829     }
<a name="l01830"></a>01830 
<a name="l01831"></a>01831     <span class="comment">// Since we don&apos;t checkpoint the data in the cache, any dirty data</span>
<a name="l01832"></a>01832     <span class="comment">// will be lost when restoring from a checkpoint of a system that</span>
<a name="l01833"></a>01833     <span class="comment">// wasn&apos;t drained properly. Flag the checkpoint as invalid if the</span>
<a name="l01834"></a>01834     <span class="comment">// cache contains dirty data.</span>
<a name="l01835"></a>01835     <span class="keywordtype">bool</span> bad_checkpoint(dirty);
<a name="l01836"></a>01836     <a class="code" href="serialize_8hh.html#a49163149ec656ffecff0e46aee418e29">SERIALIZE_SCALAR</a>(bad_checkpoint);
<a name="l01837"></a>01837 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a94c2c174856cbab1e3478cb02ae8ed80"></a><!-- doxytag: member="Cache::squash" ref="a94c2c174856cbab1e3478cb02ae8ed80" args="(int threadNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void squash </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threadNum</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Squash all requests associated with specified thread. intended for use by I-cache. </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadNum</em>&nbsp;</td><td>The thread to squash. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00264"></a>00264 {
<a name="l00265"></a>00265     <span class="keywordtype">bool</span> unblock = <span class="keyword">false</span>;
<a name="l00266"></a>00266     <a class="code" href="classBaseCache.html#a98297f294858ead7eafd19af93e64c6d">BlockedCause</a> cause = <a class="code" href="classBaseCache.html#a98297f294858ead7eafd19af93e64c6da444545819cad907e5fafbf1c940a3f3f">NUM_BLOCKED_CAUSES</a>;
<a name="l00267"></a>00267 
<a name="l00268"></a>00268     <span class="keywordflow">if</span> (<a class="code" href="classBaseCache.html#ae429d09cb5301f34a7eb7e6c765d4441">noTargetMSHR</a> &amp;&amp; <a class="code" href="classBaseCache.html#ae429d09cb5301f34a7eb7e6c765d4441">noTargetMSHR</a>-&gt;<a class="code" href="classMSHR.html#a7ec985ceacc8f2c379dbccca0b2e0f44">threadNum</a> == threadNum) {
<a name="l00269"></a>00269         <a class="code" href="classBaseCache.html#ae429d09cb5301f34a7eb7e6c765d4441">noTargetMSHR</a> = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00270"></a>00270         unblock = <span class="keyword">true</span>;
<a name="l00271"></a>00271         cause = <a class="code" href="classBaseCache.html#a98297f294858ead7eafd19af93e64c6da2e0db8e863cb5a0c10b73be89a535323">Blocked_NoTargets</a>;
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273     <span class="keywordflow">if</span> (<a class="code" href="classBaseCache.html#aa73933a75144caca7a7d3d77cf285c23">mshrQueue</a>.<a class="code" href="classMSHRQueue.html#a7ffe8a6212a0eb3fc7bbc8e9bc51dfcd">isFull</a>()) {
<a name="l00274"></a>00274         unblock = <span class="keyword">true</span>;
<a name="l00275"></a>00275         cause = <a class="code" href="classBaseCache.html#a98297f294858ead7eafd19af93e64c6dab669a177c35c6b5166465c9e93eb71e7">Blocked_NoMSHRs</a>;
<a name="l00276"></a>00276     }
<a name="l00277"></a>00277     <a class="code" href="classBaseCache.html#aa73933a75144caca7a7d3d77cf285c23">mshrQueue</a>.<a class="code" href="classMSHRQueue.html#a94c2c174856cbab1e3478cb02ae8ed80">squash</a>(threadNum);
<a name="l00278"></a>00278     <span class="keywordflow">if</span> (unblock &amp;&amp; !<a class="code" href="classBaseCache.html#aa73933a75144caca7a7d3d77cf285c23">mshrQueue</a>.<a class="code" href="classMSHRQueue.html#a7ffe8a6212a0eb3fc7bbc8e9bc51dfcd">isFull</a>()) {
<a name="l00279"></a>00279         <a class="code" href="classBaseCache.html#a78948a7bd2b849859bfc6fee2fc3d070">clearBlocked</a>(cause);
<a name="l00280"></a>00280     }
<a name="l00281"></a>00281 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af5dfa0f9fd3542f24b728e25a1d658b2"></a><!-- doxytag: member="Cache::uncacheableFlush" ref="af5dfa0f9fd3542f24b728e25a1d658b2" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uncacheableFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flush a cache line due to an uncacheable memory access to the line.</p>
<dl class="note"><dt><b>覚え書き:</b></dt><dd>This shouldn't normally happen, but we need to handle it since some architecture models don't implement cache maintenance operations. We won't even try to get a decent timing here since the line should have been flushed earlier by a cache maintenance operation. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01185"></a>01185 {
<a name="l01186"></a>01186     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCache.html">Cache</a>, <span class="stringliteral">&quot;%s%s %x uncacheable\n&quot;</span>, pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(),
<a name="l01187"></a>01187             pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#ae742b8e8aaa2e18506dc64c7b7f3fc0a">isInstFetch</a>() ? <span class="stringliteral">&quot; (ifetch)&quot;</span> : <span class="stringliteral">&quot;&quot;</span>,
<a name="l01188"></a>01188             pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>());
<a name="l01189"></a>01189 
<a name="l01190"></a>01190     <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#ab212f26b531d63897c5458251027c37e">isClearLL</a>())
<a name="l01191"></a>01191         <a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;clearLocks();
<a name="l01192"></a>01192 
<a name="l01193"></a>01193     <a class="code" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *blk(<a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;findBlock(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), pkt-&gt;<a class="code" href="classPacket.html#a3110ebf17828782ae5aeced7396cfff2">isSecure</a>()));
<a name="l01194"></a>01194     <span class="keywordflow">if</span> (blk) {
<a name="l01195"></a>01195         <a class="code" href="classCache.html#a0f9ea802ec68e58830a83fdf795a9b9f">writebackVisitor</a>(*blk);
<a name="l01196"></a>01196         <a class="code" href="classCache.html#a0a830cf4879a74de1790653f861c7d93">invalidateVisitor</a>(*blk);
<a name="l01197"></a>01197     }
<a name="l01198"></a>01198 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af22e5d6d660b97db37003ac61ac4ee49"></a><!-- doxytag: member="Cache::unserialize" ref="af22e5d6d660b97db37003ac61ac4ee49" args="(Checkpoint *cp, const std::string &amp;section)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unserialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCheckpoint.html">Checkpoint</a> *&nbsp;</td>
          <td class="paramname"> <em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>section</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classSerializable.html#af100c4e9feabf3cd918619c88c718387">Serializable</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l01842"></a>01842 {
<a name="l01843"></a>01843     <span class="keywordtype">bool</span> bad_checkpoint;
<a name="l01844"></a>01844     <a class="code" href="serialize_8hh.html#a13d18ccba3d8bcbcd5aab2e37c380bff">UNSERIALIZE_SCALAR</a>(bad_checkpoint);
<a name="l01845"></a>01845     <span class="keywordflow">if</span> (bad_checkpoint) {
<a name="l01846"></a>01846         <a class="code" href="base_2misc_8hh.html#acad519418dbfdd70c1208711e609c80e">fatal</a>(<span class="stringliteral">&quot;Restoring from checkpoints with dirty caches is not supported &quot;</span>
<a name="l01847"></a>01847               <span class="stringliteral">&quot;in the classic memory system. Please remove any caches or &quot;</span>
<a name="l01848"></a>01848               <span class="stringliteral">&quot; drain them properly before taking checkpoints.\n&quot;</span>);
<a name="l01849"></a>01849     }
<a name="l01850"></a>01850 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4451141787cceb771eec3ea4d4a4a8d4"></a><!-- doxytag: member="Cache::writebackBlk" ref="a4451141787cceb771eec3ea4d4a4a8d4" args="(BlkType *blk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPacket.html">PacketPtr</a> writebackBlk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> *&nbsp;</td>
          <td class="paramname"> <em>blk</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a writeback request for the given block. </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blk</em>&nbsp;</td><td>The block to writeback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>The writeback request for the block. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01091"></a>01091 {
<a name="l01092"></a>01092     assert(blk &amp;&amp; blk-&gt;isValid() &amp;&amp; blk-&gt;isDirty());
<a name="l01093"></a>01093 
<a name="l01094"></a>01094     <a class="code" href="group__CacheStatistics.html#gace2b37e760e47862f243e4b03c05ef5e">writebacks</a>[<a class="code" href="classRequest.html#abdfbeedab7040f62557e767ff4e79063">Request::wbMasterId</a>]++;
<a name="l01095"></a>01095 
<a name="l01096"></a>01096     <a class="code" href="classRequest.html">Request</a> *writebackReq =
<a name="l01097"></a>01097         <span class="keyword">new</span> <a class="code" href="classRequest.html">Request</a>(<a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;regenerateBlkAddr(blk-&gt;tag, blk-&gt;set), <a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a>, 0,
<a name="l01098"></a>01098                 <a class="code" href="classRequest.html#abdfbeedab7040f62557e767ff4e79063">Request::wbMasterId</a>);
<a name="l01099"></a>01099     <span class="keywordflow">if</span> (blk-&gt;isSecure())
<a name="l01100"></a>01100         writebackReq-&gt;<a class="code" href="classRequest.html#a33971d22712c9c80177e4362dffd5580">setFlags</a>(<a class="code" href="classRequest.html#a096bc7521755b6680d9a1988a6c9b109">Request::SECURE</a>);
<a name="l01101"></a>01101 
<a name="l01102"></a>01102     writebackReq-&gt;<a class="code" href="classRequest.html#a7abf15d67b3fbd53236fde58eecb3f34">taskId</a>(blk-&gt;task_id);
<a name="l01103"></a>01103     blk-&gt;task_id= <a class="code" href="namespaceContextSwitchTaskId.html#aa8dd388981e62e592eb420a58ab290b7a4e81c184ac3ad48a389cd4454c4a05bb">ContextSwitchTaskId::Unknown</a>;
<a name="l01104"></a>01104     blk-&gt;tickInserted = <a class="code" href="statistics_8hh.html#a7acdccbf0d35ce0c159c0cdd36371b22" title="The universal simulation clock.">curTick</a>();
<a name="l01105"></a>01105 
<a name="l01106"></a>01106     <a class="code" href="classPacket.html">PacketPtr</a> <a class="code" href="namespaceArmISA.html#a8143fa40e9030da2e8b93ba9990a7bb1">writeback</a> = <span class="keyword">new</span> <a class="code" href="classPacket.html">Packet</a>(writebackReq, <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a89447e3db973b10c03f68d590c65e8e6">MemCmd::Writeback</a>);
<a name="l01107"></a>01107     <span class="keywordflow">if</span> (blk-&gt;isWritable()) {
<a name="l01108"></a>01108         writeback-&gt;<a class="code" href="classPacket.html#ad0e298222c7b6801ea282a177fac7c39">setSupplyExclusive</a>();
<a name="l01109"></a>01109     }
<a name="l01110"></a>01110     writeback-&gt;<a class="code" href="classPacket.html#acaefe811b78a2fdc4a0dba0c4029c3ef">allocate</a>();
<a name="l01111"></a>01111     std::memcpy(writeback-&gt;<a class="code" href="classPacket.html#a5c451baf3f0a89084e79e69bb9061200">getPtr</a>&lt;uint8_t&gt;(), blk-&gt;data, <a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a>);
<a name="l01112"></a>01112 
<a name="l01113"></a>01113     blk-&gt;status &amp;= ~<a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7a87715983fd384f5ee41ec0608f5c6e5f">BlkDirty</a>;
<a name="l01114"></a>01114     <span class="keywordflow">return</span> writeback;
<a name="l01115"></a>01115 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0f9ea802ec68e58830a83fdf795a9b9f"></a><!-- doxytag: member="Cache::writebackVisitor" ref="a0f9ea802ec68e58830a83fdf795a9b9f" args="(BlkType &amp;blk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool writebackVisitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>blk</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classCache.html">Cache</a> block visitor that writes back dirty cache blocks using functional writes.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Always returns true. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01146"></a>01146 {
<a name="l01147"></a>01147     <span class="keywordflow">if</span> (blk.isDirty()) {
<a name="l01148"></a>01148         assert(blk.isValid());
<a name="l01149"></a>01149 
<a name="l01150"></a>01150         <a class="code" href="classRequest.html">Request</a> request(<a class="code" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a>-&gt;regenerateBlkAddr(blk.tag, blk.set),
<a name="l01151"></a>01151                         <a class="code" href="classBaseCache.html#a87b03496724866a3daf3e8ebeb831290">blkSize</a>, 0, <a class="code" href="classRequest.html#a2d69ed2b2928ccd91cc225b403200c4e">Request::funcMasterId</a>);
<a name="l01152"></a>01152         request.taskId(blk.task_id);
<a name="l01153"></a>01153 
<a name="l01154"></a>01154         <a class="code" href="classPacket.html">Packet</a> packet(&amp;request, <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153aa5ec34a7e56b23ff12c9b819519d168a">MemCmd::WriteReq</a>);
<a name="l01155"></a>01155         packet.dataStatic(blk.data);
<a name="l01156"></a>01156 
<a name="l01157"></a>01157         <a class="code" href="classBaseCache.html#af29f0c640654a651bf26558b4b39623b">memSidePort</a>-&gt;<a class="code" href="classMasterPort.html#aef8a57d30c0da6a2d2a599a14a9b8751">sendFunctional</a>(&amp;packet);
<a name="l01158"></a>01158 
<a name="l01159"></a>01159         blk.status &amp;= ~<a class="code" href="blk_8hh.html#aba0f973471df5d3edb783ecd63fe51f7a87715983fd384f5ee41ec0608f5c6e5f">BlkDirty</a>;
<a name="l01160"></a>01160     }
<a name="l01161"></a>01161 
<a name="l01162"></a>01162     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01163"></a>01163 }
</pre></div></p>

</div>
</div>
<hr/><h2>変数</h2>
<a class="anchor" id="a9b589ab6323a2796b7ae762dc7236bb5"></a><!-- doxytag: member="Cache::doFastWrites" ref="a9b589ab6323a2796b7ae762dc7236bb5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classCache.html#a9b589ab6323a2796b7ae762dc7236bb5">doFastWrites</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This cache should allocate a block on a line-sized write miss. </p>

</div>
</div>
<a class="anchor" id="a21da4bea3554874b557428e4cce5d4a4"></a><!-- doxytag: member="Cache::pendingDelete" ref="a21da4bea3554874b557428e4cce5d4a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="classPacket.html">PacketPtr</a>&gt; <a class="el" href="classCache.html#a21da4bea3554874b557428e4cce5d4a4">pendingDelete</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000074">TODO:</a></b></dt><dd>this is a temporary workaround until the 4-phase code is committed. upstream caches need this packet until true is returned, so hold it for deletion until a subsequent call </dd></dl>

</div>
</div>
<a class="anchor" id="a320f5a2352104b9b633113f9045461a3"></a><!-- doxytag: member="Cache::prefetcher" ref="a320f5a2352104b9b633113f9045461a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBasePrefetcher.html">BasePrefetcher</a>* <a class="el" href="classCache.html#a320f5a2352104b9b633113f9045461a3">prefetcher</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classPrefetcher.html">Prefetcher</a> </p>

</div>
</div>
<a class="anchor" id="a146f074bf7af4a70fc378862eab0b15a"></a><!-- doxytag: member="Cache::prefetchOnAccess" ref="a146f074bf7af4a70fc378862eab0b15a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classCache.html#a146f074bf7af4a70fc378862eab0b15a">prefetchOnAccess</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Notify the prefetcher on every access, not just misses. </p>

</div>
</div>
<a class="anchor" id="adb086ae267638f3864a6b3199f1d01e9"></a><!-- doxytag: member="Cache::tags" ref="adb086ae267638f3864a6b3199f1d01e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagStore* <a class="el" href="classCache.html#adb086ae267638f3864a6b3199f1d01e9">tags</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tag and data Storage </p>

</div>
</div>
<a class="anchor" id="a0ca2086b66114357dd17032178adce17"></a><!-- doxytag: member="Cache::tempBlock" ref="a0ca2086b66114357dd17032178adce17" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCache.html#a10db52a1c10bfd238e0e3d37c4560495">BlkType</a>* <a class="el" href="classCache.html#a0ca2086b66114357dd17032178adce17">tempBlock</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Temporary cache block for occasional transitory use </p>

</div>
</div>
<hr/>このクラスの説明は次のファイルから生成されました:<ul>
<li>mem/cache/<a class="el" href="cache_8hh_source.html">cache.hh</a></li>
<li>mem/cache/<a class="el" href="cache__impl_8hh_source.html">cache_impl.hh</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>File&nbsp;GEM5&nbsp;Wrapperに対して25 May 2015に生成されました。&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
