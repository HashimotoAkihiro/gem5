<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>File&nbsp;GEM5&nbsp;Wrapper: クラス MemSlavePort</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- 作成： Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>メインページ</span></a></li>
      <li><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>構成</span></a></li>
      <li><a href="classes.html"><span>構成索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>構成メンバ</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="classRubyPort.html">RubyPort</a>::<a class="el" href="classRubyPort_1_1MemSlavePort.html">MemSlavePort</a>
  </div>
</div>
<div class="contents">
<h1>クラス MemSlavePort</h1><!-- doxytag: class="RubyPort::MemSlavePort" --><!-- doxytag: inherits="QueuedSlavePort" -->
<p><code>#include &lt;<a class="el" href="RubyPort_8hh_source.html">RubyPort.hh</a>&gt;</code></p>
<div class="dynheader">
MemSlavePortに対する継承グラフ</div>
<div class="dynsection">
 <div class="center">
  <img src="classRubyPort_1_1MemSlavePort.gif" usemap="#MemSlavePort_map" alt=""/>
  <map id="MemSlavePort_map" name="MemSlavePort_map">
<area href="classQueuedSlavePort.html" alt="QueuedSlavePort" shape="rect" coords="0,168,112,192"/>
<area href="classSlavePort.html" alt="SlavePort" shape="rect" coords="0,112,112,136"/>
<area href="classBaseSlavePort.html" alt="BaseSlavePort" shape="rect" coords="0,56,112,80"/>
<area href="classPort.html" alt="Port" shape="rect" coords="0,0,112,24"/>
</map>
 </div>
</div>

<p><a href="classRubyPort_1_1MemSlavePort-members.html">すべてのメンバ一覧</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort_1_1MemSlavePort.html#a898fd995c2b8563d692931dc72e50010">MemSlavePort</a> (const std::string &amp;_name, <a class="el" href="classRubyPort.html">RubyPort</a> *_port, <a class="el" href="classRubySystem.html">RubySystem</a> *_system, bool _access_phys_mem, <a class="el" href="base_2types_8hh.html#acef4d7d41cb21fdc252e20c04cd7bb8e">PortID</a> <a class="el" href="classPort.html#a0a67444fc1c33a60fe4a92bfff05d0cb">id</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort_1_1MemSlavePort.html#a24a8f9c1806a15d53eddd6a70d9b3e31">hitCallback</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort_1_1MemSlavePort.html#a3af79aeefd596a230ebc3a579fcc3fb1">evictionCallback</a> (const <a class="el" href="classAddress.html">Address</a> &amp;address)</td></tr>
<tr><td colspan="2"><h2>Protected メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort_1_1MemSlavePort.html#a3344d9dd0f83257feab5424e761f31c6">recvTimingReq</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort_1_1MemSlavePort.html#a5f0b4c4a94f6b0053f9d7a4eb9c2518a">recvAtomic</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort_1_1MemSlavePort.html#aeefa907fb6d6a787e6dab90e8138ea90">recvFunctional</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1list.html">AddrRangeList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort_1_1MemSlavePort.html#a36cf113d5e5e091ebddb32306c098fae">getAddrRanges</a> () const </td></tr>
<tr><td colspan="2"><h2>Private メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort_1_1MemSlavePort.html#aa1da2f433965694958a83f76fcf4adc2">isPhysMemAddress</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> addr) const </td></tr>
<tr><td colspan="2"><h2>Private 変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSlavePacketQueue.html">SlavePacketQueue</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort_1_1MemSlavePort.html#a3055168363a9ed42f38173363b6c1975">queue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRubySystem.html">RubySystem</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort_1_1MemSlavePort.html#a88928242e9a532cb6f4abe42dd8240a7">ruby_system</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort_1_1MemSlavePort.html#a5925f629d4ec58811bba7c4fa6b4d64d">access_phys_mem</a></td></tr>
</table>
<hr/><h2>コンストラクタとデストラクタ</h2>
<a class="anchor" id="a898fd995c2b8563d692931dc72e50010"></a><!-- doxytag: member="RubyPort::MemSlavePort::MemSlavePort" ref="a898fd995c2b8563d692931dc72e50010" args="(const std::string &amp;_name, RubyPort *_port, RubySystem *_system, bool _access_phys_mem, PortID id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRubyPort_1_1MemSlavePort.html">MemSlavePort</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRubyPort.html">RubyPort</a> *&nbsp;</td>
          <td class="paramname"> <em>_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRubySystem.html">RubySystem</a> *&nbsp;</td>
          <td class="paramname"> <em>_system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>_access_phys_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#acef4d7d41cb21fdc252e20c04cd7bb8e">PortID</a>&nbsp;</td>
          <td class="paramname"> <em>id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00158"></a>00158     : <a class="code" href="classQueuedSlavePort.html#a150e71ad6ae4ad6eb65adc52ca8ff294">QueuedSlavePort</a>(_name, _port, <a class="code" href="classRubyPort_1_1MemSlavePort.html#a3055168363a9ed42f38173363b6c1975">queue</a>, <span class="keywordtype">id</span>), <a class="code" href="classRubyPort_1_1MemSlavePort.html#a3055168363a9ed42f38173363b6c1975">queue</a>(*_port, *<span class="keyword">this</span>),
<a name="l00159"></a>00159       <a class="code" href="classRubyPort_1_1MemSlavePort.html#a88928242e9a532cb6f4abe42dd8240a7">ruby_system</a>(_system), <a class="code" href="classRubyPort_1_1MemSlavePort.html#a5925f629d4ec58811bba7c4fa6b4d64d">access_phys_mem</a>(_access_phys_mem)
<a name="l00160"></a>00160 {
<a name="l00161"></a>00161     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classRubyPort.html">RubyPort</a>, <span class="stringliteral">&quot;Created slave memport on ruby sequencer %s\n&quot;</span>, _name);
<a name="l00162"></a>00162 }
</pre></div></p>

</div>
</div>
<hr/><h2>関数</h2>
<a class="anchor" id="a3af79aeefd596a230ebc3a579fcc3fb1"></a><!-- doxytag: member="RubyPort::MemSlavePort::evictionCallback" ref="a3af79aeefd596a230ebc3a579fcc3fb1" args="(const Address &amp;address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evictionCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a36cf113d5e5e091ebddb32306c098fae"></a><!-- doxytag: member="RubyPort::MemSlavePort::getAddrRanges" ref="a36cf113d5e5e091ebddb32306c098fae" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1list.html">AddrRangeList</a> getAddrRanges </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a list of the non-overlapping address ranges the owner is responsible for. All slave ports must override this function and return a populated list with at least one item.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>a list of ranges responded to </dd></dl>

<p><a class="el" href="classSlavePort.html#a6e967f8921e80748eb2be35b6b481a7e">SlavePort</a>を実装しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00096"></a>00096         { <a class="code" href="classstd_1_1list.html">AddrRangeList</a> ranges; <span class="keywordflow">return</span> ranges; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a24a8f9c1806a15d53eddd6a70d9b3e31"></a><!-- doxytag: member="RubyPort::MemSlavePort::hitCallback" ref="a24a8f9c1806a15d53eddd6a70d9b3e31" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hitCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00454"></a>00454 {
<a name="l00455"></a>00455     <span class="keywordtype">bool</span> needsResponse = pkt-&gt;<a class="code" href="classPacket.html#a390c6cced05593f0a2c75a38a7a24fa9">needsResponse</a>();
<a name="l00456"></a>00456 
<a name="l00457"></a>00457     <span class="comment">//</span>
<a name="l00458"></a>00458     <span class="comment">// Unless specified at configuraiton, all responses except failed SC </span>
<a name="l00459"></a>00459     <span class="comment">// and Flush operations access M5 physical memory.</span>
<a name="l00460"></a>00460     <span class="comment">//</span>
<a name="l00461"></a>00461     <span class="keywordtype">bool</span> accessPhysMem = <a class="code" href="classRubyPort_1_1MemSlavePort.html#a5925f629d4ec58811bba7c4fa6b4d64d">access_phys_mem</a>;
<a name="l00462"></a>00462 
<a name="l00463"></a>00463     <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a8965874e960faf91ad4b6af8dbf31875">isLLSC</a>()) {
<a name="l00464"></a>00464         <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#ab699d2f0d186312531fd1c279fd27b73">isWrite</a>()) {
<a name="l00465"></a>00465             <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a956cd41d82347558b9c0a5b0474903f2" title="A pointer to the original request.">req</a>-&gt;<a class="code" href="classRequest.html#af848a06a731668855b203d679077623d">getExtraData</a>() != 0) {
<a name="l00466"></a>00466                 <span class="comment">//</span>
<a name="l00467"></a>00467                 <span class="comment">// Successful SC packets convert to normal writes</span>
<a name="l00468"></a>00468                 <span class="comment">//</span>
<a name="l00469"></a>00469                 pkt-&gt;<a class="code" href="classPacket.html#ac4dec10b288f4bdc07dd66688b81f832">convertScToWrite</a>();
<a name="l00470"></a>00470             } <span class="keywordflow">else</span> {
<a name="l00471"></a>00471                 <span class="comment">//</span>
<a name="l00472"></a>00472                 <span class="comment">// Failed SC packets don&apos;t access physical memory and thus</span>
<a name="l00473"></a>00473                 <span class="comment">// the RubyPort itself must convert it to a response.</span>
<a name="l00474"></a>00474                 <span class="comment">//</span>
<a name="l00475"></a>00475                 accessPhysMem = <span class="keyword">false</span>;
<a name="l00476"></a>00476             }
<a name="l00477"></a>00477         } <span class="keywordflow">else</span> {
<a name="l00478"></a>00478             <span class="comment">//</span>
<a name="l00479"></a>00479             <span class="comment">// All LL packets convert to normal loads so that M5 PhysMem does</span>
<a name="l00480"></a>00480             <span class="comment">// not lock the blocks.</span>
<a name="l00481"></a>00481             <span class="comment">//</span>
<a name="l00482"></a>00482             pkt-&gt;<a class="code" href="classPacket.html#a4d3d1abff83d841c66d318d026a5d58e">convertLlToRead</a>();
<a name="l00483"></a>00483         }
<a name="l00484"></a>00484     }
<a name="l00485"></a>00485 
<a name="l00486"></a>00486     <span class="comment">//</span>
<a name="l00487"></a>00487     <span class="comment">// Flush requests don&apos;t access physical memory</span>
<a name="l00488"></a>00488     <span class="comment">//</span>
<a name="l00489"></a>00489     <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a5e6baaa42eabbb07af2d1769e3c0499b">isFlush</a>()) {
<a name="l00490"></a>00490         accessPhysMem = <span class="keyword">false</span>;
<a name="l00491"></a>00491     }
<a name="l00492"></a>00492 
<a name="l00493"></a>00493     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classRubyPort.html">RubyPort</a>, <span class="stringliteral">&quot;Hit callback needs response %d\n&quot;</span>, needsResponse);
<a name="l00494"></a>00494 
<a name="l00495"></a>00495     <span class="keywordflow">if</span> (accessPhysMem) {
<a name="l00496"></a>00496         <a class="code" href="classRubyPort.html">RubyPort</a> *ruby_port = <span class="keyword">static_cast&lt;</span><a class="code" href="classRubyPort.html">RubyPort</a> *<span class="keyword">&gt;</span>(&amp;<a class="code" href="classPort.html#aba966efb6c1df4b015be3a396df6c318">owner</a>);
<a name="l00497"></a>00497         ruby_port-&gt;<a class="code" href="classRubyPort.html#af27ccd765f13a4b7bd119dc7579e2746">system</a>-&gt;<a class="code" href="classSystem.html#af828d179222e0a3764213c270bfa4097">getPhysMem</a>().<a class="code" href="classPhysicalMemory.html#aac5d96736802cb79fb2287135bcc1dff">access</a>(pkt);
<a name="l00498"></a>00498     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (needsResponse) {
<a name="l00499"></a>00499         pkt-&gt;<a class="code" href="classPacket.html#a9330bf4cbbc7e25bbfc9626182df27e5">makeResponse</a>();
<a name="l00500"></a>00500     }
<a name="l00501"></a>00501 
<a name="l00502"></a>00502     <span class="comment">// turn packet around to go back to requester if response expected</span>
<a name="l00503"></a>00503     <span class="keywordflow">if</span> (needsResponse) {
<a name="l00504"></a>00504         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classRubyPort.html">RubyPort</a>, <span class="stringliteral">&quot;Sending packet back over port\n&quot;</span>);
<a name="l00505"></a>00505         <span class="comment">// send next cycle</span>
<a name="l00506"></a>00506         <a class="code" href="classQueuedSlavePort.html#a31c2fe79e7cbd7319eb327074e412675">schedTimingResp</a>(pkt, <a class="code" href="statistics_8hh.html#a7acdccbf0d35ce0c159c0cdd36371b22" title="The universal simulation clock.">curTick</a>() + <a class="code" href="Global_8cc.html#ac7631ed7c7cc138c40a9e88e38d0ecb1">g_system_ptr</a>-&gt;<a class="code" href="classClockedObject.html#a78c89cef17196c60470c4f2f76d43d8a">clockPeriod</a>());
<a name="l00507"></a>00507     } <span class="keywordflow">else</span> {
<a name="l00508"></a>00508         <span class="keyword">delete</span> pkt;
<a name="l00509"></a>00509     }
<a name="l00510"></a>00510     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classRubyPort.html">RubyPort</a>, <span class="stringliteral">&quot;Hit callback done!\n&quot;</span>);
<a name="l00511"></a>00511 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa1da2f433965694958a83f76fcf4adc2"></a><!-- doxytag: member="RubyPort::MemSlavePort::isPhysMemAddress" ref="aa1da2f433965694958a83f76fcf4adc2" args="(Addr addr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isPhysMemAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00531"></a>00531 {
<a name="l00532"></a>00532     <a class="code" href="classRubyPort.html">RubyPort</a> *ruby_port = <span class="keyword">static_cast&lt;</span><a class="code" href="classRubyPort.html">RubyPort</a> *<span class="keyword">&gt;</span>(&amp;<a class="code" href="classPort.html#aba966efb6c1df4b015be3a396df6c318">owner</a>);
<a name="l00533"></a>00533     <span class="keywordflow">return</span> ruby_port-&gt;<a class="code" href="classRubyPort.html#af27ccd765f13a4b7bd119dc7579e2746">system</a>-&gt;<a class="code" href="classSystem.html#a0faeadf06436f8123c7bda01087bb222">isMemAddr</a>(<a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a>);
<a name="l00534"></a>00534 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5f0b4c4a94f6b0053f9d7a4eb9c2518a"></a><!-- doxytag: member="RubyPort::MemSlavePort::recvAtomic" ref="a5f0b4c4a94f6b0053f9d7a4eb9c2518a" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> recvAtomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive an atomic request packet from the master port. </p>

<p><a class="el" href="classSlavePort.html#a428ab07671bc9372dc44a2487b12a726">SlavePort</a>を実装しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00091"></a>00091         { <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;RubyPort::MemSlavePort::recvAtomic() not implemented!\n&quot;</span>); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aeefa907fb6d6a787e6dab90e8138ea90"></a><!-- doxytag: member="RubyPort::MemSlavePort::recvFunctional" ref="aeefa907fb6d6a787e6dab90e8138ea90" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void recvFunctional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive a functional request packet from the master port. </p>

<p><a class="el" href="classSlavePort.html#a6a3d6f2e5dab6bed16d53d9e7c17378d">SlavePort</a>を実装しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00277"></a>00277 {
<a name="l00278"></a>00278     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classRubyPort.html">RubyPort</a>, <span class="stringliteral">&quot;Functional access for address: %#x\n&quot;</span>, pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>());
<a name="l00279"></a>00279     <a class="code" href="classRubyPort.html">RubyPort</a> *ruby_port = <span class="keyword">static_cast&lt;</span><a class="code" href="classRubyPort.html">RubyPort</a> *<span class="keyword">&gt;</span>(&amp;<a class="code" href="classPort.html#aba966efb6c1df4b015be3a396df6c318">owner</a>);
<a name="l00280"></a>00280 
<a name="l00281"></a>00281     <span class="comment">// Check for pio requests and directly send them to the dedicated</span>
<a name="l00282"></a>00282     <span class="comment">// pio port.</span>
<a name="l00283"></a>00283     <span class="keywordflow">if</span> (!<a class="code" href="classRubyPort_1_1MemSlavePort.html#aa1da2f433965694958a83f76fcf4adc2">isPhysMemAddress</a>(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>())) {
<a name="l00284"></a>00284         assert(ruby_port-&gt;memMasterPort.isConnected());
<a name="l00285"></a>00285         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classRubyPort.html">RubyPort</a>, <span class="stringliteral">&quot;Pio Request for address: 0x%#x\n&quot;</span>, pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>());
<a name="l00286"></a>00286         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;RubyPort::PioMasterPort::recvFunctional() not implemented!\n&quot;</span>);
<a name="l00287"></a>00287     }
<a name="l00288"></a>00288 
<a name="l00289"></a>00289     assert(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>() + pkt-&gt;<a class="code" href="classPacket.html#a1d18ba49c7be427da1f4a42d53e35f48">getSize</a>() &lt;=
<a name="l00290"></a>00290                 <a class="code" href="Address_8hh.html#abe46a2cc64664e1a3a02d0a501e4f21d">line_address</a>(<a class="code" href="classAddress.html">Address</a>(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>())).<a class="code" href="classAddress.html#aa5c44fe637d09a708d70c4a689840cd0">getAddress</a>() +
<a name="l00291"></a>00291                 <a class="code" href="classRubySystem.html#ad5726e8c9283b1447b75c3a8c67ffa75">RubySystem::getBlockSizeBytes</a>());
<a name="l00292"></a>00292 
<a name="l00293"></a>00293     <span class="keywordtype">bool</span> accessSucceeded = <span class="keyword">false</span>;
<a name="l00294"></a>00294     <span class="keywordtype">bool</span> needsResponse = pkt-&gt;<a class="code" href="classPacket.html#a390c6cced05593f0a2c75a38a7a24fa9">needsResponse</a>();
<a name="l00295"></a>00295 
<a name="l00296"></a>00296     <span class="comment">// Do the functional access on ruby memory</span>
<a name="l00297"></a>00297     <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#adc47901747fc3c447db3abddaf01491a">isRead</a>()) {
<a name="l00298"></a>00298         accessSucceeded = <a class="code" href="classRubyPort_1_1MemSlavePort.html#a88928242e9a532cb6f4abe42dd8240a7">ruby_system</a>-&gt;<a class="code" href="classRubySystem.html#a9fece07bc06f16d7c5190f08e42f5359">functionalRead</a>(pkt);
<a name="l00299"></a>00299     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#ab699d2f0d186312531fd1c279fd27b73">isWrite</a>()) {
<a name="l00300"></a>00300         accessSucceeded = <a class="code" href="classRubyPort_1_1MemSlavePort.html#a88928242e9a532cb6f4abe42dd8240a7">ruby_system</a>-&gt;<a class="code" href="classRubySystem.html#af751326b50cd1150f91ec688d9336ffc">functionalWrite</a>(pkt);
<a name="l00301"></a>00301     } <span class="keywordflow">else</span> {
<a name="l00302"></a>00302         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;Unsupported functional command %s\n&quot;</span>, pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>());
<a name="l00303"></a>00303     }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305     <span class="comment">// Unless the requester explicitly said otherwise, generate an error if</span>
<a name="l00306"></a>00306     <span class="comment">// the functional request failed</span>
<a name="l00307"></a>00307     <span class="keywordflow">if</span> (!accessSucceeded &amp;&amp; !pkt-&gt;<a class="code" href="classPacket.html#a181cb46d55a9f0f933fe649c6937d037">suppressFuncError</a>()) {
<a name="l00308"></a>00308         <a class="code" href="base_2misc_8hh.html#acad519418dbfdd70c1208711e609c80e">fatal</a>(<span class="stringliteral">&quot;Ruby functional %s failed for address %#x\n&quot;</span>,
<a name="l00309"></a>00309               pkt-&gt;<a class="code" href="classPacket.html#ab699d2f0d186312531fd1c279fd27b73">isWrite</a>() ? <span class="stringliteral">&quot;write&quot;</span> : <span class="stringliteral">&quot;read&quot;</span>, pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>());
<a name="l00310"></a>00310     }
<a name="l00311"></a>00311 
<a name="l00312"></a>00312     <span class="keywordflow">if</span> (<a class="code" href="classRubyPort_1_1MemSlavePort.html#a5925f629d4ec58811bba7c4fa6b4d64d">access_phys_mem</a>) {
<a name="l00313"></a>00313         <span class="comment">// The attached physmem contains the official version of data.</span>
<a name="l00314"></a>00314         <span class="comment">// The following command performs the real functional access.</span>
<a name="l00315"></a>00315         <span class="comment">// This line should be removed once Ruby supplies the official version</span>
<a name="l00316"></a>00316         <span class="comment">// of data.</span>
<a name="l00317"></a>00317         ruby_port-&gt;system-&gt;getPhysMem().functionalAccess(pkt);
<a name="l00318"></a>00318     }
<a name="l00319"></a>00319 
<a name="l00320"></a>00320     <span class="comment">// turn packet around to go back to requester if response expected</span>
<a name="l00321"></a>00321     <span class="keywordflow">if</span> (needsResponse) {
<a name="l00322"></a>00322         pkt-&gt;<a class="code" href="classPacket.html#a61715904f754e7788941e838fca1dcb9">setFunctionalResponseStatus</a>(accessSucceeded);
<a name="l00323"></a>00323 
<a name="l00324"></a>00324         <span class="comment">// @todo There should not be a reverse call since the response is</span>
<a name="l00325"></a>00325         <span class="comment">// communicated through the packet pointer</span>
<a name="l00326"></a>00326         <span class="comment">// DPRINTF(RubyPort, &quot;Sending packet back over port\n&quot;);</span>
<a name="l00327"></a>00327         <span class="comment">// sendFunctional(pkt);</span>
<a name="l00328"></a>00328     }
<a name="l00329"></a>00329     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classRubyPort.html">RubyPort</a>, <span class="stringliteral">&quot;Functional access %s!\n&quot;</span>,
<a name="l00330"></a>00330             accessSucceeded ? <span class="stringliteral">&quot;successful&quot;</span>:<span class="stringliteral">&quot;failed&quot;</span>);
<a name="l00331"></a>00331 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3344d9dd0f83257feab5424e761f31c6"></a><!-- doxytag: member="RubyPort::MemSlavePort::recvTimingReq" ref="a3344d9dd0f83257feab5424e761f31c6" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool recvTimingReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive a timing request from the master port. </p>

<p><a class="el" href="classSlavePort.html#abcece77e42f88ee41af8d3d01bb48253">SlavePort</a>を実装しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00218"></a>00218 {
<a name="l00219"></a>00219     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classRubyPort.html">RubyPort</a>, <span class="stringliteral">&quot;Timing request for address %#x on port %d\n&quot;</span>,
<a name="l00220"></a>00220             pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), <a class="code" href="classPort.html#a0a67444fc1c33a60fe4a92bfff05d0cb">id</a>);
<a name="l00221"></a>00221     <a class="code" href="classRubyPort.html">RubyPort</a> *ruby_port = <span class="keyword">static_cast&lt;</span><a class="code" href="classRubyPort.html">RubyPort</a> *<span class="keyword">&gt;</span>(&amp;<a class="code" href="classPort.html#aba966efb6c1df4b015be3a396df6c318">owner</a>);
<a name="l00222"></a>00222 
<a name="l00223"></a>00223     <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a9693a1ffeda326646443ab2a2a92be41">memInhibitAsserted</a>())
<a name="l00224"></a>00224         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;RubyPort should never see an inhibited request\n&quot;</span>);
<a name="l00225"></a>00225 
<a name="l00226"></a>00226     <span class="comment">// Check for pio requests and directly send them to the dedicated</span>
<a name="l00227"></a>00227     <span class="comment">// pio port.</span>
<a name="l00228"></a>00228     <span class="keywordflow">if</span> (!<a class="code" href="classRubyPort_1_1MemSlavePort.html#aa1da2f433965694958a83f76fcf4adc2">isPhysMemAddress</a>(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>())) {
<a name="l00229"></a>00229         assert(ruby_port-&gt;memMasterPort.isConnected());
<a name="l00230"></a>00230         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classRubyPort.html">RubyPort</a>, <span class="stringliteral">&quot;Request address %#x assumed to be a pio address\n&quot;</span>,
<a name="l00231"></a>00231                 pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>());
<a name="l00232"></a>00232 
<a name="l00233"></a>00233         <span class="comment">// Save the port in the sender state object to be used later to</span>
<a name="l00234"></a>00234         <span class="comment">// route the response</span>
<a name="l00235"></a>00235         pkt-&gt;<a class="code" href="classPacket.html#a6a6aa11d6c2aec2df5aafeefe2847d8e">pushSenderState</a>(<span class="keyword">new</span> <a class="code" href="Check_8cc.html#a9aa5a48148172c2e3c2da1b0393bdd48">SenderState</a>(<span class="keyword">this</span>));
<a name="l00236"></a>00236 
<a name="l00237"></a>00237         <span class="comment">// send next cycle</span>
<a name="l00238"></a>00238         ruby_port-&gt;memMasterPort.schedTimingReq(pkt,
<a name="l00239"></a>00239             <a class="code" href="statistics_8hh.html#a7acdccbf0d35ce0c159c0cdd36371b22" title="The universal simulation clock.">curTick</a>() + <a class="code" href="Global_8cc.html#ac7631ed7c7cc138c40a9e88e38d0ecb1">g_system_ptr</a>-&gt;<a class="code" href="classClockedObject.html#a78c89cef17196c60470c4f2f76d43d8a">clockPeriod</a>());
<a name="l00240"></a>00240         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00241"></a>00241     }
<a name="l00242"></a>00242 
<a name="l00243"></a>00243     <span class="comment">// Save the port id to be used later to route the response</span>
<a name="l00244"></a>00244     pkt-&gt;<a class="code" href="classPacket.html#a6e173cf473a751a0e969c1561a4184cc" title="Accessor function to set the source index of the packet.">setSrc</a>(<span class="keywordtype">id</span>);
<a name="l00245"></a>00245 
<a name="l00246"></a>00246     assert(<a class="code" href="classAddress.html">Address</a>(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>()).getOffset() + pkt-&gt;<a class="code" href="classPacket.html#a1d18ba49c7be427da1f4a42d53e35f48">getSize</a>() &lt;=
<a name="l00247"></a>00247            <a class="code" href="classRubySystem.html#ad5726e8c9283b1447b75c3a8c67ffa75">RubySystem::getBlockSizeBytes</a>());
<a name="l00248"></a>00248 
<a name="l00249"></a>00249     <span class="comment">// Submit the ruby request</span>
<a name="l00250"></a>00250     RequestStatus requestStatus = ruby_port-&gt;makeRequest(pkt);
<a name="l00251"></a>00251 
<a name="l00252"></a>00252     <span class="comment">// If the request successfully issued then we should return true.</span>
<a name="l00253"></a>00253     <span class="comment">// Otherwise, we need to tell the port to retry at a later point</span>
<a name="l00254"></a>00254     <span class="comment">// and return false.</span>
<a name="l00255"></a>00255     <span class="keywordflow">if</span> (requestStatus == RequestStatus_Issued) {
<a name="l00256"></a>00256         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classRubyPort.html">RubyPort</a>, <span class="stringliteral">&quot;Request %s 0x%x issued\n&quot;</span>, pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(),
<a name="l00257"></a>00257                 pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>());
<a name="l00258"></a>00258         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00259"></a>00259     }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261     <span class="comment">//</span>
<a name="l00262"></a>00262     <span class="comment">// Unless one is using the ruby tester, record the stalled M5 port for </span>
<a name="l00263"></a>00263     <span class="comment">// later retry when the sequencer becomes free.</span>
<a name="l00264"></a>00264     <span class="comment">//</span>
<a name="l00265"></a>00265     <span class="keywordflow">if</span> (!ruby_port-&gt;m_usingRubyTester) {
<a name="l00266"></a>00266         ruby_port-&gt;addToRetryList(<span class="keyword">this</span>);
<a name="l00267"></a>00267     }
<a name="l00268"></a>00268 
<a name="l00269"></a>00269     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classRubyPort.html">RubyPort</a>, <span class="stringliteral">&quot;Request for address %#x did not issued because %s\n&quot;</span>,
<a name="l00270"></a>00270             pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>(), RequestStatus_to_string(requestStatus));
<a name="l00271"></a>00271 
<a name="l00272"></a>00272     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00273"></a>00273 }
</pre></div></p>

</div>
</div>
<hr/><h2>変数</h2>
<a class="anchor" id="a5925f629d4ec58811bba7c4fa6b4d64d"></a><!-- doxytag: member="RubyPort::MemSlavePort::access_phys_mem" ref="a5925f629d4ec58811bba7c4fa6b4d64d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRubyPort_1_1MemSlavePort.html#a5925f629d4ec58811bba7c4fa6b4d64d">access_phys_mem</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3055168363a9ed42f38173363b6c1975"></a><!-- doxytag: member="RubyPort::MemSlavePort::queue" ref="a3055168363a9ed42f38173363b6c1975" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSlavePacketQueue.html">SlavePacketQueue</a> <a class="el" href="classRubyPort_1_1MemSlavePort.html#a3055168363a9ed42f38173363b6c1975">queue</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classPacket.html">Packet</a> queue used to store outgoing requests and responses. </p>

<p><a class="el" href="classQueuedSlavePort.html#a89fcdbe2ab63d24f2112bc7e05bf2413">QueuedSlavePort</a>を再定義しています。</p>

</div>
</div>
<a class="anchor" id="a88928242e9a532cb6f4abe42dd8240a7"></a><!-- doxytag: member="RubyPort::MemSlavePort::ruby_system" ref="a88928242e9a532cb6f4abe42dd8240a7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRubySystem.html">RubySystem</a>* <a class="el" href="classRubyPort_1_1MemSlavePort.html#a88928242e9a532cb6f4abe42dd8240a7">ruby_system</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>このクラスの説明は次のファイルから生成されました:<ul>
<li>mem/ruby/system/<a class="el" href="RubyPort_8hh_source.html">RubyPort.hh</a></li>
<li>mem/ruby/system/<a class="el" href="RubyPort_8cc.html">RubyPort.cc</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>File&nbsp;GEM5&nbsp;Wrapperに対して25 May 2015に生成されました。&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
