\hypertarget{classX86ISA_1_1Decoder}{
\section{クラス Decoder}
\label{classX86ISA_1_1Decoder}\index{X86ISA::Decoder@{X86ISA::Decoder}}
}


{\ttfamily \#include $<$decoder.hh$>$}\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structX86ISA_1_1Decoder_1_1InstBytes}{InstBytes}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classX86ISA_1_1Decoder_aedfa2b7d97ed17b14903ed75d6214c78}{Decoder} ()
\item 
void \hyperlink{classX86ISA_1_1Decoder_a9b8f4112d3bbb779584ef8aaee237b25}{setM5Reg} (HandyM5Reg m5Reg)
\item 
void \hyperlink{classX86ISA_1_1Decoder_a83393f90e7cbd98eda9721ba6022d0e0}{takeOverFrom} (\hyperlink{classX86ISA_1_1Decoder}{Decoder} $\ast$old)
\item 
void \hyperlink{classX86ISA_1_1Decoder_ad20897c5c8bd47f5d4005989bead0e55}{reset} ()
\item 
void \hyperlink{classX86ISA_1_1Decoder_a2e9c5136d19b1a95fc427e0852deab5c}{process} ()
\item 
void \hyperlink{classX86ISA_1_1Decoder_a1345d078b309b7d115c57be1ed13ae38}{moreBytes} (const \hyperlink{classX86ISA_1_1PCState}{PCState} \&\hyperlink{namespaceX86ISA_aecb63c74e066ecd98e04d057e39028c9}{pc}, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} fetchPC, \hyperlink{namespaceX86ISA_a7ceadb544bf9b4a10579b7466b0ac008}{MachInst} data)
\item 
bool \hyperlink{classX86ISA_1_1Decoder_a35631c47fc45b69ca30e6551f9f5d1d1}{needMoreBytes} ()
\item 
bool \hyperlink{classX86ISA_1_1Decoder_a9f6a0bc8946ca58d5d59a5dbc6a3181f}{instReady} ()
\item 
void \hyperlink{classX86ISA_1_1Decoder_aab3a5fb7c37867f52f6fa72cc56ceb5e}{updateNPC} (\hyperlink{classX86ISA_1_1PCState}{X86ISA::PCState} \&nextPC)
\item 
\hyperlink{classRefCountingPtr}{StaticInstPtr} \hyperlink{classX86ISA_1_1Decoder_a148768e0e9062eb41f604040d0ea86e6}{decodeInst} (\hyperlink{structX86ISA_1_1ExtMachInst}{ExtMachInst} mach\_\-inst)
\item 
\hyperlink{classRefCountingPtr}{StaticInstPtr} \hyperlink{classX86ISA_1_1Decoder_a4ed948f8d08575cc2916fe32154ea69d}{decode} (\hyperlink{structX86ISA_1_1ExtMachInst}{ExtMachInst} mach\_\-inst, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{namespaceX86ISA_ab705917f60c5566f9ce56a93f798b2e2}{addr})
\item 
\hyperlink{classRefCountingPtr}{StaticInstPtr} \hyperlink{classX86ISA_1_1Decoder_a2aa7b25617e9f15447ee6e934f4a3529}{decode} (\hyperlink{classX86ISA_1_1PCState}{X86ISA::PCState} \&nextPC)
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8}{State} \{ \par
\hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8aff67699080f325de2a7ddc37e246c9a8}{ResetState}, 
\hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8abfa48baddbd48c27b1459423efa4bdd8}{FromCacheState}, 
\hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8a2991411af91f1d4a5045fff0a9a3be9f}{PrefixState}, 
\hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8a5dafe6854fcb6b0807bea9ce23744e64}{OpcodeState}, 
\par
\hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8a1b1909a7067c96c6fa9205417b64bb29}{ModRMState}, 
\hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8add2ba2a6d04fb8829afac6fcb5a57283}{SIBState}, 
\hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8a6914e5c19cf114014f9ab8d94169c880}{DisplacementState}, 
\hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8ae16af2d7c02e47eb62cd45a6fe42f48f}{ImmediateState}, 
\par
\hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8ade97a2665a1361faea090134062c17b4}{ErrorState}
 \}
\item 
typedef \hyperlink{namespaceX86ISA_aa16539aa6584fd12f7d6fa868f75b4de}{MiscReg} \hyperlink{classX86ISA_1_1Decoder_af5cdf239a38ca71d83ddcf2b9a657cbe}{CacheKey}
\begin{DoxyCompactList}\small\item\em Caching for decoded instruction objects. \item\end{DoxyCompactList}\item 
typedef \hyperlink{classDecodeCache_1_1AddrMap}{DecodeCache::AddrMap}$<$ \hyperlink{structX86ISA_1_1Decoder_1_1InstBytes}{Decoder::InstBytes} $>$ \hyperlink{classX86ISA_1_1Decoder_aaeb98acb07222e8d393baae60333dd32}{DecodePages}
\item 
typedef m5::hash\_\-map$<$ \hyperlink{classX86ISA_1_1Decoder_af5cdf239a38ca71d83ddcf2b9a657cbe}{CacheKey}, \hyperlink{classDecodeCache_1_1AddrMap}{DecodePages} $\ast$ $>$ \hyperlink{classX86ISA_1_1Decoder_a17e66c491b538e223da13acf9d77d5f2}{AddrCacheMap}
\item 
typedef m5::hash\_\-map$<$ \hyperlink{classX86ISA_1_1Decoder_af5cdf239a38ca71d83ddcf2b9a657cbe}{CacheKey}, \hyperlink{namespaceDecodeCache_ac4aa7140c72815d25936c8dcf04191f1}{DecodeCache::InstMap} $\ast$ $>$ \hyperlink{classX86ISA_1_1Decoder_accbfac5b46e737fd6326272fba1a8bb2}{InstCacheMap}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
uint8\_\-t \hyperlink{classX86ISA_1_1Decoder_a8f47335339a66b8928a59b6e450ba23e}{getNextByte} ()
\item 
void \hyperlink{classX86ISA_1_1Decoder_aca8cee2ca4f61924adea583f466e5c27}{getImmediate} (int \&collected, uint64\_\-t \&current, int size)
\item 
void \hyperlink{classX86ISA_1_1Decoder_a9b25276214b33147c8d3bf84e1aa778c}{updateOffsetState} ()
\item 
void \hyperlink{classX86ISA_1_1Decoder_ac0b7514336823f27e26271bcad4563a8}{consumeByte} ()
\item 
void \hyperlink{classX86ISA_1_1Decoder_a34f1e4d13220afca8ec5c23596daba7e}{consumeBytes} (int numBytes)
\item 
\hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8}{State} \hyperlink{classX86ISA_1_1Decoder_a3e359a01a10d324b1a5f5931b6aafb41}{doResetState} ()
\item 
\hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8}{State} \hyperlink{classX86ISA_1_1Decoder_a8db8642a115e086e090c7aabf61b8b8d}{doFromCacheState} ()
\item 
\hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8}{State} \hyperlink{classX86ISA_1_1Decoder_a34e20e41a8a8172e08cbf7f09ef390a1}{doPrefixState} (uint8\_\-t)
\item 
\hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8}{State} \hyperlink{classX86ISA_1_1Decoder_af4ad421adb9b081935801bf19bf0d563}{doOpcodeState} (uint8\_\-t)
\item 
\hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8}{State} \hyperlink{classX86ISA_1_1Decoder_af92cd28d02e33555be9f257fa37e988b}{doModRMState} (uint8\_\-t)
\item 
\hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8}{State} \hyperlink{classX86ISA_1_1Decoder_a429d36cbff305b40608c013c0c6a15b1}{doSIBState} (uint8\_\-t)
\item 
\hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8}{State} \hyperlink{classX86ISA_1_1Decoder_a159a4726e8800be2876f6d3100193d4d}{doDisplacementState} ()
\item 
\hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8}{State} \hyperlink{classX86ISA_1_1Decoder_ad402df3f8c4d1f4fb2b7a29d72ba00ec}{doImmediateState} ()
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{namespaceX86ISA_a7ceadb544bf9b4a10579b7466b0ac008}{MachInst} \hyperlink{classX86ISA_1_1Decoder_a273336b914b5b7edc5433d52385d932e}{fetchChunk}
\item 
\hyperlink{structX86ISA_1_1Decoder_1_1InstBytes}{InstBytes} $\ast$ \hyperlink{classX86ISA_1_1Decoder_a393f7387727acc3ec0188fe976c52ff3}{instBytes}
\item 
int \hyperlink{classX86ISA_1_1Decoder_a37ce03861bdaf0bdc992ddd28a8a08e0}{chunkIdx}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classX86ISA_1_1Decoder_a54317b5e28be49c4013e535159defb35}{basePC}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classX86ISA_1_1Decoder_ad199f4799f06d6be603a02e3a05ea918}{origPC}
\item 
int \hyperlink{classX86ISA_1_1Decoder_aed7ea92f45bd273dde380a45ddced592}{offset}
\item 
\hyperlink{structX86ISA_1_1ExtMachInst}{ExtMachInst} \hyperlink{classX86ISA_1_1Decoder_abf211faf305b89c9093b00b6b82b0bd1}{emi}
\item 
X86Mode \hyperlink{classX86ISA_1_1Decoder_ab3eab3edfcd7cfbe98f3d00c7e75048b}{mode}
\item 
\hyperlink{namespaceX86ISA_a88701044b173f3a3f9c0d8b09e63eb1b}{X86SubMode} \hyperlink{classX86ISA_1_1Decoder_a476c8dbd8e30b9067e6c2f0b7274be73}{submode}
\item 
uint8\_\-t \hyperlink{classX86ISA_1_1Decoder_ae1027509430cd109ced841df18ec4790}{altOp}
\item 
uint8\_\-t \hyperlink{classX86ISA_1_1Decoder_adf82151c683017bc9ab9fb7b70ff72fb}{defOp}
\item 
uint8\_\-t \hyperlink{classX86ISA_1_1Decoder_a3f6baec3f8d9a651a37a3c5f9bfba2a4}{altAddr}
\item 
uint8\_\-t \hyperlink{classX86ISA_1_1Decoder_a63bbec903362b7e01fbf028a0afbfeb1}{defAddr}
\item 
uint8\_\-t \hyperlink{classX86ISA_1_1Decoder_aef01e995775f4a7ba2367414f311dc73}{stack}
\item 
bool \hyperlink{classX86ISA_1_1Decoder_a281c9bc4944bdbf837d5432478d43273}{outOfBytes}
\item 
bool \hyperlink{classX86ISA_1_1Decoder_a37c5d55785204b8fd00a8ebf62e1fc33}{instDone}
\item 
int \hyperlink{classX86ISA_1_1Decoder_a494ae21b1676198853f989b5003e0c06}{displacementSize}
\item 
int \hyperlink{classX86ISA_1_1Decoder_a61f77f04393db6b7fe844adc3f78b644}{immediateSize}
\item 
int \hyperlink{classX86ISA_1_1Decoder_a9923210a91a1b233397e87d09325cfac}{immediateCollected}
\item 
\hyperlink{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8}{State} \hyperlink{classX86ISA_1_1Decoder_a876b486d3a5241a126bd5751c5f70f79}{state}
\item 
\hyperlink{classDecodeCache_1_1AddrMap}{DecodePages} $\ast$ \hyperlink{classX86ISA_1_1Decoder_a259ba942ab7ed4dcb7661396959966be}{decodePages}
\item 
\hyperlink{classX86ISA_1_1Decoder_a17e66c491b538e223da13acf9d77d5f2}{AddrCacheMap} \hyperlink{classX86ISA_1_1Decoder_aa5687d2256dc3674692589549cd833da}{addrCacheMap}
\item 
\hyperlink{namespaceDecodeCache_ac4aa7140c72815d25936c8dcf04191f1}{DecodeCache::InstMap} $\ast$ \hyperlink{classX86ISA_1_1Decoder_a4c63c65e342dd96985ba874deb29db03}{instMap}
\end{DoxyCompactItemize}
\subsection*{Static Protected 変数}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{structX86ISA_1_1Decoder_1_1InstBytes}{InstBytes} \hyperlink{classX86ISA_1_1Decoder_ab36b2d3338c466d225603823b5e4f9a4}{dummy}
\item 
static \hyperlink{classX86ISA_1_1Decoder_accbfac5b46e737fd6326272fba1a8bb2}{InstCacheMap} \hyperlink{classX86ISA_1_1Decoder_a2f55fd436a83562102f84954df9f5ed0}{instCacheMap}
\end{DoxyCompactItemize}
\subsection*{Static Private 変数}
\begin{DoxyCompactItemize}
\item 
static const uint8\_\-t \hyperlink{classX86ISA_1_1Decoder_a4790fc37f276d111825695679818d082}{Prefixes} \mbox{[}256\mbox{]}
\item 
static const uint8\_\-t \hyperlink{classX86ISA_1_1Decoder_a6e9f1359a8e815c5bdd0efc306f5bf32}{UsesModRM} \mbox{[}2\mbox{]}\mbox{[}256\mbox{]}
\item 
static const uint8\_\-t \hyperlink{classX86ISA_1_1Decoder_a3f9cce9eaf915705c0fd4d90d9bcf8f8}{ImmediateType} \mbox{[}2\mbox{]}\mbox{[}256\mbox{]}
\item 
static const uint8\_\-t \hyperlink{classX86ISA_1_1Decoder_a30eeeb2cd279f8cfcbafbd9873691d2f}{SizeTypeToSize} \mbox{[}3\mbox{]}\mbox{[}10\mbox{]}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classX86ISA_1_1Decoder_a17e66c491b538e223da13acf9d77d5f2}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!AddrCacheMap@{AddrCacheMap}}
\index{AddrCacheMap@{AddrCacheMap}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{AddrCacheMap}]{\setlength{\rightskip}{0pt plus 5cm}typedef m5::hash\_\-map$<${\bf CacheKey}, {\bf DecodePages} $\ast$$>$ {\bf AddrCacheMap}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a17e66c491b538e223da13acf9d77d5f2}
\hypertarget{classX86ISA_1_1Decoder_af5cdf239a38ca71d83ddcf2b9a657cbe}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!CacheKey@{CacheKey}}
\index{CacheKey@{CacheKey}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{CacheKey}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf MiscReg} {\bf CacheKey}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_af5cdf239a38ca71d83ddcf2b9a657cbe}


Caching for decoded instruction objects. \hypertarget{classX86ISA_1_1Decoder_aaeb98acb07222e8d393baae60333dd32}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!DecodePages@{DecodePages}}
\index{DecodePages@{DecodePages}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{DecodePages}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf DecodeCache::AddrMap}$<${\bf Decoder::InstBytes}$>$ {\bf DecodePages}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_aaeb98acb07222e8d393baae60333dd32}
\hypertarget{classX86ISA_1_1Decoder_accbfac5b46e737fd6326272fba1a8bb2}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!InstCacheMap@{InstCacheMap}}
\index{InstCacheMap@{InstCacheMap}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{InstCacheMap}]{\setlength{\rightskip}{0pt plus 5cm}typedef m5::hash\_\-map$<${\bf CacheKey}, {\bf DecodeCache::InstMap} $\ast$$>$ {\bf InstCacheMap}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_accbfac5b46e737fd6326272fba1a8bb2}


\subsection{列挙型}
\hypertarget{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!State@{State}}
\index{State@{State}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{State}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf State}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{ResetState@{ResetState}!X86ISA::Decoder@{X86ISA::Decoder}}\index{X86ISA::Decoder@{X86ISA::Decoder}!ResetState@{ResetState}}\item[{\em 
\hypertarget{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8aff67699080f325de2a7ddc37e246c9a8}{
ResetState}
\label{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8aff67699080f325de2a7ddc37e246c9a8}
}]\index{FromCacheState@{FromCacheState}!X86ISA::Decoder@{X86ISA::Decoder}}\index{X86ISA::Decoder@{X86ISA::Decoder}!FromCacheState@{FromCacheState}}\item[{\em 
\hypertarget{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8abfa48baddbd48c27b1459423efa4bdd8}{
FromCacheState}
\label{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8abfa48baddbd48c27b1459423efa4bdd8}
}]\index{PrefixState@{PrefixState}!X86ISA::Decoder@{X86ISA::Decoder}}\index{X86ISA::Decoder@{X86ISA::Decoder}!PrefixState@{PrefixState}}\item[{\em 
\hypertarget{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8a2991411af91f1d4a5045fff0a9a3be9f}{
PrefixState}
\label{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8a2991411af91f1d4a5045fff0a9a3be9f}
}]\index{OpcodeState@{OpcodeState}!X86ISA::Decoder@{X86ISA::Decoder}}\index{X86ISA::Decoder@{X86ISA::Decoder}!OpcodeState@{OpcodeState}}\item[{\em 
\hypertarget{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8a5dafe6854fcb6b0807bea9ce23744e64}{
OpcodeState}
\label{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8a5dafe6854fcb6b0807bea9ce23744e64}
}]\index{ModRMState@{ModRMState}!X86ISA::Decoder@{X86ISA::Decoder}}\index{X86ISA::Decoder@{X86ISA::Decoder}!ModRMState@{ModRMState}}\item[{\em 
\hypertarget{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8a1b1909a7067c96c6fa9205417b64bb29}{
ModRMState}
\label{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8a1b1909a7067c96c6fa9205417b64bb29}
}]\index{SIBState@{SIBState}!X86ISA::Decoder@{X86ISA::Decoder}}\index{X86ISA::Decoder@{X86ISA::Decoder}!SIBState@{SIBState}}\item[{\em 
\hypertarget{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8add2ba2a6d04fb8829afac6fcb5a57283}{
SIBState}
\label{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8add2ba2a6d04fb8829afac6fcb5a57283}
}]\index{DisplacementState@{DisplacementState}!X86ISA::Decoder@{X86ISA::Decoder}}\index{X86ISA::Decoder@{X86ISA::Decoder}!DisplacementState@{DisplacementState}}\item[{\em 
\hypertarget{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8a6914e5c19cf114014f9ab8d94169c880}{
DisplacementState}
\label{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8a6914e5c19cf114014f9ab8d94169c880}
}]\index{ImmediateState@{ImmediateState}!X86ISA::Decoder@{X86ISA::Decoder}}\index{X86ISA::Decoder@{X86ISA::Decoder}!ImmediateState@{ImmediateState}}\item[{\em 
\hypertarget{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8ae16af2d7c02e47eb62cd45a6fe42f48f}{
ImmediateState}
\label{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8ae16af2d7c02e47eb62cd45a6fe42f48f}
}]\index{ErrorState@{ErrorState}!X86ISA::Decoder@{X86ISA::Decoder}}\index{X86ISA::Decoder@{X86ISA::Decoder}!ErrorState@{ErrorState}}\item[{\em 
\hypertarget{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8ade97a2665a1361faea090134062c17b4}{
ErrorState}
\label{classX86ISA_1_1Decoder_a5d74787dedbc4e11c1ab15bf487e61f8ade97a2665a1361faea090134062c17b4}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
165                {
166         ResetState,
167         FromCacheState,
168         PrefixState,
169         OpcodeState,
170         ModRMState,
171         SIBState,
172         DisplacementState,
173         ImmediateState,
174         //We should never get to this state. Getting here is an error.
175         ErrorState
176     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classX86ISA_1_1Decoder_aedfa2b7d97ed17b14903ed75d6214c78}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!Decoder@{Decoder}}
\index{Decoder@{Decoder}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{Decoder}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decoder} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Decoder_aedfa2b7d97ed17b14903ed75d6214c78}



\begin{DoxyCode}
205               : basePC(0), origPC(0), offset(0),
206         outOfBytes(true), instDone(false),
207         state(ResetState)
208     {
209         memset(&emi, 0, sizeof(emi));
210         mode = LongMode;
211         submode = SixtyFourBitMode;
212         emi.mode.mode = mode;
213         emi.mode.submode = submode;
214         altOp = 0;
215         defOp = 0;
216         altAddr = 0;
217         defAddr = 0;
218         stack = 0;
219         instBytes = &dummy;
220         decodePages = NULL;
221         instMap = NULL;
222     }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classX86ISA_1_1Decoder_ac0b7514336823f27e26271bcad4563a8}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!consumeByte@{consumeByte}}
\index{consumeByte@{consumeByte}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{consumeByte}]{\setlength{\rightskip}{0pt plus 5cm}void consumeByte ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_ac0b7514336823f27e26271bcad4563a8}



\begin{DoxyCode}
140     {
141         offset++;
142         updateOffsetState();
143     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_a34f1e4d13220afca8ec5c23596daba7e}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!consumeBytes@{consumeBytes}}
\index{consumeBytes@{consumeBytes}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{consumeBytes}]{\setlength{\rightskip}{0pt plus 5cm}void consumeBytes (int {\em numBytes})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a34f1e4d13220afca8ec5c23596daba7e}



\begin{DoxyCode}
146     {
147         offset += numBytes;
148         updateOffsetState();
149     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_a2aa7b25617e9f15447ee6e934f4a3529}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!decode@{decode}}
\index{decode@{decode}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{decode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StaticInstPtr} decode ({\bf X86ISA::PCState} \& {\em nextPC})}}
\label{classX86ISA_1_1Decoder_a2aa7b25617e9f15447ee6e934f4a3529}



\begin{DoxyCode}
478 {
479     if (!instDone)
480         return NULL;
481     instDone = false;
482     updateNPC(nextPC);
483 
484     StaticInstPtr &si = instBytes->si;
485     if (si)
486         return si;
487 
488     // We didn't match in the AddrMap, but we still populated an entry. Fix
489     // up its byte masks.
490     const int chunkSize = sizeof(MachInst);
491 
492     instBytes->lastOffset = offset;
493 
494     Addr firstBasePC = basePC - (instBytes->chunks.size() - 1) * chunkSize;
495     Addr firstOffset = origPC - firstBasePC;
496     Addr totalSize = instBytes->lastOffset - firstOffset +
497         (instBytes->chunks.size() - 1) * chunkSize;
498     int start = firstOffset;
499     instBytes->masks.clear();
500 
501     while (totalSize) {
502         int end = start + totalSize;
503         end = (chunkSize < end) ? chunkSize : end;
504         int size = end - start;
505         int idx = instBytes->masks.size();
506 
507         MachInst maskVal = mask(size * 8) << (start * 8);
508         assert(maskVal);
509 
510         instBytes->masks.push_back(maskVal);
511         instBytes->chunks[idx] &= instBytes->masks[idx];
512         totalSize -= size;
513         start = 0;
514     }
515 
516     si = decode(emi, origPC);
517     return si;
518 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_a4ed948f8d08575cc2916fe32154ea69d}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!decode@{decode}}
\index{decode@{decode}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{decode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StaticInstPtr} decode ({\bf ExtMachInst} {\em mach\_\-inst}, \/  {\bf Addr} {\em addr})}}
\label{classX86ISA_1_1Decoder_a4ed948f8d08575cc2916fe32154ea69d}
Decode a machine instruction. 
\begin{DoxyParams}{引数}
\item[{\em mach\_\-inst}]The binary instruction to decode. \end{DoxyParams}

\begin{DoxyRetVals}{戻り値}
\item[{\em A}]pointer to the corresponding \hyperlink{classStaticInst}{StaticInst} object. \end{DoxyRetVals}



\begin{DoxyCode}
466 {
467     DecodeCache::InstMap::iterator iter = instMap->find(mach_inst);
468     if (iter != instMap->end())
469         return iter->second;
470 
471     StaticInstPtr si = decodeInst(mach_inst);
472     (*instMap)[mach_inst] = si;
473     return si;
474 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_a148768e0e9062eb41f604040d0ea86e6}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!decodeInst@{decodeInst}}
\index{decodeInst@{decodeInst}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{decodeInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StaticInstPtr} decodeInst ({\bf ExtMachInst} {\em mach\_\-inst})}}
\label{classX86ISA_1_1Decoder_a148768e0e9062eb41f604040d0ea86e6}
\hypertarget{classX86ISA_1_1Decoder_a159a4726e8800be2876f6d3100193d4d}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!doDisplacementState@{doDisplacementState}}
\index{doDisplacementState@{doDisplacementState}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{doDisplacementState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decoder::State} doDisplacementState ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a159a4726e8800be2876f6d3100193d4d}



\begin{DoxyCode}
371 {
372     State nextState = ErrorState;
373 
374     getImmediate(immediateCollected,
375             emi.displacement,
376             displacementSize);
377 
378     DPRINTF(Decoder, "Collecting %d byte displacement, got %d bytes.\n",
379             displacementSize, immediateCollected);
380 
381     if(displacementSize == immediateCollected) {
382         //Reset this for other immediates.
383         immediateCollected = 0;
384         //Sign extend the displacement
385         switch(displacementSize)
386         {
387           case 1:
388             emi.displacement = sext<8>(emi.displacement);
389             break;
390           case 2:
391             emi.displacement = sext<16>(emi.displacement);
392             break;
393           case 4:
394             emi.displacement = sext<32>(emi.displacement);
395             break;
396           default:
397             panic("Undefined displacement size!\n");
398         }
399         DPRINTF(Decoder, "Collected displacement %#x.\n",
400                 emi.displacement);
401         if(immediateSize) {
402             nextState = ImmediateState;
403         } else {
404             instDone = true;
405             nextState = ResetState;
406         }
407 
408         emi.dispSize = displacementSize;
409     }
410     else
411         nextState = DisplacementState;
412     return nextState;
413 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_a8db8642a115e086e090c7aabf61b8b8d}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!doFromCacheState@{doFromCacheState}}
\index{doFromCacheState@{doFromCacheState}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{doFromCacheState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decoder::State} doFromCacheState ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a8db8642a115e086e090c7aabf61b8b8d}



\begin{DoxyCode}
122 {
123     DPRINTF(Decoder, "Looking at cache state.\n");
124     if ((fetchChunk & instBytes->masks[chunkIdx]) !=
125             instBytes->chunks[chunkIdx]) {
126         DPRINTF(Decoder, "Decode cache miss.\n");
127         // The chached chunks didn't match what was fetched. Fall back to the
128         // predecoder.
129         instBytes->chunks[chunkIdx] = fetchChunk;
130         instBytes->chunks.resize(chunkIdx + 1);
131         instBytes->si = NULL;
132         chunkIdx = 0;
133         fetchChunk = instBytes->chunks[0];
134         offset = origPC % sizeof(MachInst);
135         basePC = origPC - offset;
136         return PrefixState;
137     } else if (chunkIdx == instBytes->chunks.size() - 1) {
138         // We matched the cache, so use its value.
139         instDone = true;
140         offset = instBytes->lastOffset;
141         if (offset == sizeof(MachInst))
142             outOfBytes = true;
143         return ResetState;
144     } else {
145         // We matched so far, but need to check more chunks.
146         chunkIdx++;
147         outOfBytes = true;
148         return FromCacheState;
149     }
150 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_ad402df3f8c4d1f4fb2b7a29d72ba00ec}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!doImmediateState@{doImmediateState}}
\index{doImmediateState@{doImmediateState}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{doImmediateState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decoder::State} doImmediateState ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_ad402df3f8c4d1f4fb2b7a29d72ba00ec}



\begin{DoxyCode}
419 {
420     State nextState = ErrorState;
421 
422     getImmediate(immediateCollected,
423             emi.immediate,
424             immediateSize);
425 
426     DPRINTF(Decoder, "Collecting %d byte immediate, got %d bytes.\n",
427             immediateSize, immediateCollected);
428 
429     if(immediateSize == immediateCollected)
430     {
431         //Reset this for other immediates.
432         immediateCollected = 0;
433 
434         //XXX Warning! The following is an observed pattern and might
435         //not always be true!
436 
437         //Instructions which use 64 bit operands but 32 bit immediates
438         //need to have the immediate sign extended to 64 bits.
439         //Instructions which use true 64 bit immediates won't be
440         //affected, and instructions that use true 32 bit immediates
441         //won't notice.
442         switch(immediateSize)
443         {
444           case 4:
445             emi.immediate = sext<32>(emi.immediate);
446             break;
447           case 1:
448             emi.immediate = sext<8>(emi.immediate);
449         }
450 
451         DPRINTF(Decoder, "Collected immediate %#x.\n",
452                 emi.immediate);
453         instDone = true;
454         nextState = ResetState;
455     }
456     else
457         nextState = ImmediateState;
458     return nextState;
459 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_af92cd28d02e33555be9f257fa37e988b}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!doModRMState@{doModRMState}}
\index{doModRMState@{doModRMState}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{doModRMState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decoder::State} doModRMState (uint8\_\-t {\em nextByte})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_af92cd28d02e33555be9f257fa37e988b}



\begin{DoxyCode}
293 {
294     State nextState = ErrorState;
295     ModRM modRM;
296     modRM = nextByte;
297     DPRINTF(Decoder, "Found modrm byte %#x.\n", nextByte);
298     if (defOp == 1) {
299         //figure out 16 bit displacement size
300         if ((modRM.mod == 0 && modRM.rm == 6) || modRM.mod == 2)
301             displacementSize = 2;
302         else if (modRM.mod == 1)
303             displacementSize = 1;
304         else
305             displacementSize = 0;
306     } else {
307         //figure out 32/64 bit displacement size
308         if ((modRM.mod == 0 && modRM.rm == 5) || modRM.mod == 2)
309             displacementSize = 4;
310         else if (modRM.mod == 1)
311             displacementSize = 1;
312         else
313             displacementSize = 0;
314     }
315 
316     // The "test" instruction in group 3 needs an immediate, even though
317     // the other instructions with the same actual opcode don't.
318     if (emi.opcode.num == 1 && (modRM.reg & 0x6) == 0) {
319        if (emi.opcode.op == 0xF6)
320            immediateSize = 1;
321        else if (emi.opcode.op == 0xF7)
322            immediateSize = (emi.opSize == 8) ? 4 : emi.opSize;
323     }
324 
325     //If there's an SIB, get that next.
326     //There is no SIB in 16 bit mode.
327     if (modRM.rm == 4 && modRM.mod != 3) {
328             // && in 32/64 bit mode)
329         nextState = SIBState;
330     } else if(displacementSize) {
331         nextState = DisplacementState;
332     } else if(immediateSize) {
333         nextState = ImmediateState;
334     } else {
335         instDone = true;
336         nextState = ResetState;
337     }
338     //The ModRM byte is consumed no matter what
339     consumeByte();
340     emi.modRM = modRM;
341     return nextState;
342 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_af4ad421adb9b081935801bf19bf0d563}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!doOpcodeState@{doOpcodeState}}
\index{doOpcodeState@{doOpcodeState}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{doOpcodeState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decoder::State} doOpcodeState (uint8\_\-t {\em nextByte})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_af4ad421adb9b081935801bf19bf0d563}



\begin{DoxyCode}
214 {
215     State nextState = ErrorState;
216     emi.opcode.num++;
217     //We can't handle 3+ byte opcodes right now
218     assert(emi.opcode.num < 4);
219     consumeByte();
220     if(emi.opcode.num == 1 && nextByte == 0x0f)
221     {
222         nextState = OpcodeState;
223         DPRINTF(Decoder, "Found two byte opcode.\n");
224         emi.opcode.prefixA = nextByte;
225     }
226     else if(emi.opcode.num == 2 && (nextByte == 0x38 || nextByte == 0x3A))
227     {
228         nextState = OpcodeState;
229         DPRINTF(Decoder, "Found three byte opcode.\n");
230         emi.opcode.prefixB = nextByte;
231     }
232     else
233     {
234         DPRINTF(Decoder, "Found opcode %#x.\n", nextByte);
235         emi.opcode.op = nextByte;
236 
237         //Figure out the effective operand size. This can be overriden to
238         //a fixed value at the decoder level.
239         int logOpSize;
240         if (emi.rex.w)
241             logOpSize = 3; // 64 bit operand size
242         else if (emi.legacy.op)
243             logOpSize = altOp;
244         else
245             logOpSize = defOp;
246 
247         //Set the actual op size
248         emi.opSize = 1 << logOpSize;
249 
250         //Figure out the effective address size. This can be overriden to
251         //a fixed value at the decoder level.
252         int logAddrSize;
253         if(emi.legacy.addr)
254             logAddrSize = altAddr;
255         else
256             logAddrSize = defAddr;
257 
258         //Set the actual address size
259         emi.addrSize = 1 << logAddrSize;
260 
261         //Figure out the effective stack width. This can be overriden to
262         //a fixed value at the decoder level.
263         emi.stackSize = 1 << stack;
264 
265         //Figure out how big of an immediate we'll retreive based
266         //on the opcode.
267         int immType = ImmediateType[emi.opcode.num - 1][nextByte];
268         if (emi.opcode.num == 1 && nextByte >= 0xA0 && nextByte <= 0xA3)
269             immediateSize = SizeTypeToSize[logAddrSize - 1][immType];
270         else
271             immediateSize = SizeTypeToSize[logOpSize - 1][immType];
272 
273         //Determine what to expect next
274         if (UsesModRM[emi.opcode.num - 1][nextByte]) {
275             nextState = ModRMState;
276         } else {
277             if(immediateSize) {
278                 nextState = ImmediateState;
279             } else {
280                 instDone = true;
281                 nextState = ResetState;
282             }
283         }
284     }
285     return nextState;
286 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_a34e20e41a8a8172e08cbf7f09ef390a1}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!doPrefixState@{doPrefixState}}
\index{doPrefixState@{doPrefixState}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{doPrefixState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decoder::State} doPrefixState (uint8\_\-t {\em nextByte})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a34e20e41a8a8172e08cbf7f09ef390a1}



\begin{DoxyCode}
156 {
157     uint8_t prefix = Prefixes[nextByte];
158     State nextState = PrefixState;
159     // REX prefixes are only recognized in 64 bit mode.
160     if (prefix == RexPrefix && emi.mode.submode != SixtyFourBitMode)
161         prefix = 0;
162     if (prefix)
163         consumeByte();
164     switch(prefix)
165     {
166         //Operand size override prefixes
167       case OperandSizeOverride:
168         DPRINTF(Decoder, "Found operand size override prefix.\n");
169         emi.legacy.op = true;
170         break;
171       case AddressSizeOverride:
172         DPRINTF(Decoder, "Found address size override prefix.\n");
173         emi.legacy.addr = true;
174         break;
175         //Segment override prefixes
176       case CSOverride:
177       case DSOverride:
178       case ESOverride:
179       case FSOverride:
180       case GSOverride:
181       case SSOverride:
182         DPRINTF(Decoder, "Found segment override.\n");
183         emi.legacy.seg = prefix;
184         break;
185       case Lock:
186         DPRINTF(Decoder, "Found lock prefix.\n");
187         emi.legacy.lock = true;
188         break;
189       case Rep:
190         DPRINTF(Decoder, "Found rep prefix.\n");
191         emi.legacy.rep = true;
192         break;
193       case Repne:
194         DPRINTF(Decoder, "Found repne prefix.\n");
195         emi.legacy.repne = true;
196         break;
197       case RexPrefix:
198         DPRINTF(Decoder, "Found Rex prefix %#x.\n", nextByte);
199         emi.rex = nextByte;
200         break;
201       case 0:
202         nextState = OpcodeState;
203         break;
204       default:
205         panic("Unrecognized prefix %#x\n", nextByte);
206     }
207     return nextState;
208 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_a3e359a01a10d324b1a5f5931b6aafb41}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!doResetState@{doResetState}}
\index{doResetState@{doResetState}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{doResetState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decoder::State} doResetState ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a3e359a01a10d324b1a5f5931b6aafb41}



\begin{DoxyCode}
43 {
44     origPC = basePC + offset;
45     DPRINTF(Decoder, "Setting origPC to %#x\n", origPC);
46     instBytes = &decodePages->lookup(origPC);
47     chunkIdx = 0;
48 
49     emi.rex = 0;
50     emi.legacy = 0;
51     emi.opcode.num = 0;
52     emi.opcode.op = 0;
53     emi.opcode.prefixA = emi.opcode.prefixB = 0;
54 
55     immediateCollected = 0;
56     emi.immediate = 0;
57     emi.displacement = 0;
58     emi.dispSize = 0;
59 
60     emi.modRM = 0;
61     emi.sib = 0;
62 
63     if (instBytes->si) {
64         return FromCacheState;
65     } else {
66         instBytes->chunks.clear();
67         return PrefixState;
68     }
69 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_a429d36cbff305b40608c013c0c6a15b1}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!doSIBState@{doSIBState}}
\index{doSIBState@{doSIBState}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{doSIBState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decoder::State} doSIBState (uint8\_\-t {\em nextByte})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a429d36cbff305b40608c013c0c6a15b1}



\begin{DoxyCode}
349 {
350     State nextState = ErrorState;
351     emi.sib = nextByte;
352     DPRINTF(Decoder, "Found SIB byte %#x.\n", nextByte);
353     consumeByte();
354     if (emi.modRM.mod == 0 && emi.sib.base == 5)
355         displacementSize = 4;
356     if (displacementSize) {
357         nextState = DisplacementState;
358     } else if(immediateSize) {
359         nextState = ImmediateState;
360     } else {
361         instDone = true;
362         nextState = ResetState;
363     }
364     return nextState;
365 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_aca8cee2ca4f61924adea583f466e5c27}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!getImmediate@{getImmediate}}
\index{getImmediate@{getImmediate}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{getImmediate}]{\setlength{\rightskip}{0pt plus 5cm}void getImmediate (int \& {\em collected}, \/  uint64\_\-t \& {\em current}, \/  int {\em size})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_aca8cee2ca4f61924adea583f466e5c27}



\begin{DoxyCode}
100     {
101         //Figure out how many bytes we still need to get for the
102         //immediate.
103         int toGet = size - collected;
104         //Figure out how many bytes are left in our "buffer"
105         int remaining = sizeof(MachInst) - offset;
106         //Get as much as we need, up to the amount available.
107         toGet = toGet > remaining ? remaining : toGet;
108 
109         //Shift the bytes we want to be all the way to the right
110         uint64_t partialImm = fetchChunk >> (offset * 8);
111         //Mask off what we don't want
112         partialImm &= mask(toGet * 8);
113         //Shift it over to overlay with our displacement.
114         partialImm <<= (immediateCollected * 8);
115         //Put it into our displacement
116         current |= partialImm;
117         //Update how many bytes we've collected.
118         collected += toGet;
119         consumeBytes(toGet);
120     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_a8f47335339a66b8928a59b6e450ba23e}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!getNextByte@{getNextByte}}
\index{getNextByte@{getNextByte}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{getNextByte}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t getNextByte ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a8f47335339a66b8928a59b6e450ba23e}



\begin{DoxyCode}
95     {
96         return ((uint8_t *)&fetchChunk)[offset];
97     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_a9f6a0bc8946ca58d5d59a5dbc6a3181f}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!instReady@{instReady}}
\index{instReady@{instReady}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{instReady}]{\setlength{\rightskip}{0pt plus 5cm}bool instReady ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a9f6a0bc8946ca58d5d59a5dbc6a3181f}



\begin{DoxyCode}
291     {
292         return instDone;
293     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_a1345d078b309b7d115c57be1ed13ae38}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!moreBytes@{moreBytes}}
\index{moreBytes@{moreBytes}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{moreBytes}]{\setlength{\rightskip}{0pt plus 5cm}void moreBytes (const {\bf PCState} \& {\em pc}, \/  {\bf Addr} {\em fetchPC}, \/  {\bf MachInst} {\em data})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a1345d078b309b7d115c57be1ed13ae38}



\begin{DoxyCode}
276     {
277         DPRINTF(Decoder, "Getting more bytes.\n");
278         basePC = fetchPC;
279         offset = (fetchPC >= pc.instAddr()) ? 0 : pc.instAddr() - fetchPC;
280         fetchChunk = data;
281         outOfBytes = false;
282         process();
283     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_a35631c47fc45b69ca30e6551f9f5d1d1}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!needMoreBytes@{needMoreBytes}}
\index{needMoreBytes@{needMoreBytes}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{needMoreBytes}]{\setlength{\rightskip}{0pt plus 5cm}bool needMoreBytes ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a35631c47fc45b69ca30e6551f9f5d1d1}



\begin{DoxyCode}
286     {
287         return outOfBytes;
288     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_a2e9c5136d19b1a95fc427e0852deab5c}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!process@{process}}
\index{process@{process}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{process}]{\setlength{\rightskip}{0pt plus 5cm}void process ()}}
\label{classX86ISA_1_1Decoder_a2e9c5136d19b1a95fc427e0852deab5c}



\begin{DoxyCode}
73 {
74     //This function drives the decoder state machine.
75 
76     //Some sanity checks. You shouldn't try to process more bytes if
77     //there aren't any, and you shouldn't overwrite an already
78     //decoder ExtMachInst.
79     assert(!outOfBytes);
80     assert(!instDone);
81 
82     if (state == ResetState)
83         state = doResetState();
84     if (state == FromCacheState) {
85         state = doFromCacheState();
86     } else {
87         instBytes->chunks.push_back(fetchChunk);
88     }
89 
90     //While there's still something to do...
91     while (!instDone && !outOfBytes) {
92         uint8_t nextByte = getNextByte();
93         switch (state) {
94           case PrefixState:
95             state = doPrefixState(nextByte);
96             break;
97           case OpcodeState:
98             state = doOpcodeState(nextByte);
99             break;
100           case ModRMState:
101             state = doModRMState(nextByte);
102             break;
103           case SIBState:
104             state = doSIBState(nextByte);
105             break;
106           case DisplacementState:
107             state = doDisplacementState();
108             break;
109           case ImmediateState:
110             state = doImmediateState();
111             break;
112           case ErrorState:
113             panic("Went to the error state in the decoder.\n");
114           default:
115             panic("Unrecognized state! %d\n", state);
116         }
117     }
118 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_ad20897c5c8bd47f5d4005989bead0e55}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!reset@{reset}}
\index{reset@{reset}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{reset}]{\setlength{\rightskip}{0pt plus 5cm}void reset ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Decoder_ad20897c5c8bd47f5d4005989bead0e55}



\begin{DoxyCode}
267     {
268         state = ResetState;
269     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_a9b8f4112d3bbb779584ef8aaee237b25}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!setM5Reg@{setM5Reg}}
\index{setM5Reg@{setM5Reg}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{setM5Reg}]{\setlength{\rightskip}{0pt plus 5cm}void setM5Reg (HandyM5Reg {\em m5Reg})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a9b8f4112d3bbb779584ef8aaee237b25}



\begin{DoxyCode}
225     {
226         mode = (X86Mode)(uint64_t)m5Reg.mode;
227         submode = (X86SubMode)(uint64_t)m5Reg.submode;
228         emi.mode.mode = mode;
229         emi.mode.submode = submode;
230         altOp = m5Reg.altOp;
231         defOp = m5Reg.defOp;
232         altAddr = m5Reg.altAddr;
233         defAddr = m5Reg.defAddr;
234         stack = m5Reg.stack;
235 
236         AddrCacheMap::iterator amIter = addrCacheMap.find(m5Reg);
237         if (amIter != addrCacheMap.end()) {
238             decodePages = amIter->second;
239         } else {
240             decodePages = new DecodePages;
241             addrCacheMap[m5Reg] = decodePages;
242         }
243 
244         InstCacheMap::iterator imIter = instCacheMap.find(m5Reg);
245         if (imIter != instCacheMap.end()) {
246             instMap = imIter->second;
247         } else {
248             instMap = new DecodeCache::InstMap;
249             instCacheMap[m5Reg] = instMap;
250         }
251     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_a83393f90e7cbd98eda9721ba6022d0e0}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ({\bf Decoder} $\ast$ {\em old})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a83393f90e7cbd98eda9721ba6022d0e0}



\begin{DoxyCode}
254     {
255         mode = old->mode;
256         submode = old->submode;
257         emi.mode.mode = mode;
258         emi.mode.submode = submode;
259         altOp = old->altOp;
260         defOp = old->defOp;
261         altAddr = old->altAddr;
262         defAddr = old->defAddr;
263         stack = old->stack;
264     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_aab3a5fb7c37867f52f6fa72cc56ceb5e}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!updateNPC@{updateNPC}}
\index{updateNPC@{updateNPC}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{updateNPC}]{\setlength{\rightskip}{0pt plus 5cm}void updateNPC ({\bf X86ISA::PCState} \& {\em nextPC})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Decoder_aab3a5fb7c37867f52f6fa72cc56ceb5e}



\begin{DoxyCode}
297     {
298         if (!nextPC.size()) {
299             int size = basePC + offset - origPC;
300             DPRINTF(Decoder,
301                     "Calculating the instruction size: "
302                     "basePC: %#x offset: %#x origPC: %#x size: %d\n",
303                     basePC, offset, origPC, size);
304             nextPC.size(size);
305             nextPC.npc(nextPC.pc() + size);
306         }
307     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_a9b25276214b33147c8d3bf84e1aa778c}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!updateOffsetState@{updateOffsetState}}
\index{updateOffsetState@{updateOffsetState}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{updateOffsetState}]{\setlength{\rightskip}{0pt plus 5cm}void updateOffsetState ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a9b25276214b33147c8d3bf84e1aa778c}



\begin{DoxyCode}
123     {
124         assert(offset <= sizeof(MachInst));
125         if (offset == sizeof(MachInst)) {
126             DPRINTF(Decoder, "At the end of a chunk, idx = %d, chunks = %d.\n",
127                     chunkIdx, instBytes->chunks.size());
128             chunkIdx++;
129             if (chunkIdx == instBytes->chunks.size()) {
130                 outOfBytes = true;
131             } else {
132                 offset = 0;
133                 fetchChunk = instBytes->chunks[chunkIdx];
134                 basePC += sizeof(MachInst);
135             }
136         }
137     }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classX86ISA_1_1Decoder_aa5687d2256dc3674692589549cd833da}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!addrCacheMap@{addrCacheMap}}
\index{addrCacheMap@{addrCacheMap}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{addrCacheMap}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrCacheMap} {\bf addrCacheMap}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_aa5687d2256dc3674692589549cd833da}
\hypertarget{classX86ISA_1_1Decoder_a3f6baec3f8d9a651a37a3c5f9bfba2a4}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!altAddr@{altAddr}}
\index{altAddr@{altAddr}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{altAddr}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf altAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a3f6baec3f8d9a651a37a3c5f9bfba2a4}
\hypertarget{classX86ISA_1_1Decoder_ae1027509430cd109ced841df18ec4790}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!altOp@{altOp}}
\index{altOp@{altOp}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{altOp}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf altOp}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_ae1027509430cd109ced841df18ec4790}
\hypertarget{classX86ISA_1_1Decoder_a54317b5e28be49c4013e535159defb35}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!basePC@{basePC}}
\index{basePC@{basePC}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{basePC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf basePC}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a54317b5e28be49c4013e535159defb35}
\hypertarget{classX86ISA_1_1Decoder_a37ce03861bdaf0bdc992ddd28a8a08e0}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!chunkIdx@{chunkIdx}}
\index{chunkIdx@{chunkIdx}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{chunkIdx}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf chunkIdx}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a37ce03861bdaf0bdc992ddd28a8a08e0}
\hypertarget{classX86ISA_1_1Decoder_a259ba942ab7ed4dcb7661396959966be}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!decodePages@{decodePages}}
\index{decodePages@{decodePages}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{decodePages}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DecodePages}$\ast$ {\bf decodePages}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a259ba942ab7ed4dcb7661396959966be}
\hypertarget{classX86ISA_1_1Decoder_a63bbec903362b7e01fbf028a0afbfeb1}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!defAddr@{defAddr}}
\index{defAddr@{defAddr}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{defAddr}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf defAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a63bbec903362b7e01fbf028a0afbfeb1}
\hypertarget{classX86ISA_1_1Decoder_adf82151c683017bc9ab9fb7b70ff72fb}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!defOp@{defOp}}
\index{defOp@{defOp}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{defOp}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf defOp}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_adf82151c683017bc9ab9fb7b70ff72fb}
\hypertarget{classX86ISA_1_1Decoder_a494ae21b1676198853f989b5003e0c06}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!displacementSize@{displacementSize}}
\index{displacementSize@{displacementSize}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{displacementSize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf displacementSize}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a494ae21b1676198853f989b5003e0c06}
\hypertarget{classX86ISA_1_1Decoder_ab36b2d3338c466d225603823b5e4f9a4}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!dummy@{dummy}}
\index{dummy@{dummy}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{dummy}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decoder::InstBytes} {\bf dummy}\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_ab36b2d3338c466d225603823b5e4f9a4}
\hypertarget{classX86ISA_1_1Decoder_abf211faf305b89c9093b00b6b82b0bd1}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!emi@{emi}}
\index{emi@{emi}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{emi}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ExtMachInst} {\bf emi}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_abf211faf305b89c9093b00b6b82b0bd1}
\hypertarget{classX86ISA_1_1Decoder_a273336b914b5b7edc5433d52385d932e}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!fetchChunk@{fetchChunk}}
\index{fetchChunk@{fetchChunk}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{fetchChunk}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MachInst} {\bf fetchChunk}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a273336b914b5b7edc5433d52385d932e}
\hypertarget{classX86ISA_1_1Decoder_a9923210a91a1b233397e87d09325cfac}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!immediateCollected@{immediateCollected}}
\index{immediateCollected@{immediateCollected}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{immediateCollected}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf immediateCollected}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a9923210a91a1b233397e87d09325cfac}
\hypertarget{classX86ISA_1_1Decoder_a61f77f04393db6b7fe844adc3f78b644}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!immediateSize@{immediateSize}}
\index{immediateSize@{immediateSize}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{immediateSize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf immediateSize}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a61f77f04393db6b7fe844adc3f78b644}
\hypertarget{classX86ISA_1_1Decoder_a3f9cce9eaf915705c0fd4d90d9bcf8f8}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!ImmediateType@{ImmediateType}}
\index{ImmediateType@{ImmediateType}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{ImmediateType}]{\setlength{\rightskip}{0pt plus 5cm}const uint8\_\-t {\bf ImmediateType}\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a3f9cce9eaf915705c0fd4d90d9bcf8f8}
\hypertarget{classX86ISA_1_1Decoder_a393f7387727acc3ec0188fe976c52ff3}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!instBytes@{instBytes}}
\index{instBytes@{instBytes}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{instBytes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstBytes}$\ast$ {\bf instBytes}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a393f7387727acc3ec0188fe976c52ff3}
\hypertarget{classX86ISA_1_1Decoder_a2f55fd436a83562102f84954df9f5ed0}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!instCacheMap@{instCacheMap}}
\index{instCacheMap@{instCacheMap}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{instCacheMap}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decoder::InstCacheMap} {\bf instCacheMap}\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a2f55fd436a83562102f84954df9f5ed0}
\hypertarget{classX86ISA_1_1Decoder_a37c5d55785204b8fd00a8ebf62e1fc33}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!instDone@{instDone}}
\index{instDone@{instDone}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{instDone}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf instDone}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a37c5d55785204b8fd00a8ebf62e1fc33}
\hypertarget{classX86ISA_1_1Decoder_a4c63c65e342dd96985ba874deb29db03}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!instMap@{instMap}}
\index{instMap@{instMap}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{instMap}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DecodeCache::InstMap}$\ast$ {\bf instMap}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a4c63c65e342dd96985ba874deb29db03}
\hypertarget{classX86ISA_1_1Decoder_ab3eab3edfcd7cfbe98f3d00c7e75048b}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!mode@{mode}}
\index{mode@{mode}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{mode}]{\setlength{\rightskip}{0pt plus 5cm}X86Mode {\bf mode}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_ab3eab3edfcd7cfbe98f3d00c7e75048b}
\hypertarget{classX86ISA_1_1Decoder_aed7ea92f45bd273dde380a45ddced592}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!offset@{offset}}
\index{offset@{offset}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{offset}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf offset}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_aed7ea92f45bd273dde380a45ddced592}
\hypertarget{classX86ISA_1_1Decoder_ad199f4799f06d6be603a02e3a05ea918}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!origPC@{origPC}}
\index{origPC@{origPC}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{origPC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf origPC}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_ad199f4799f06d6be603a02e3a05ea918}
\hypertarget{classX86ISA_1_1Decoder_a281c9bc4944bdbf837d5432478d43273}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!outOfBytes@{outOfBytes}}
\index{outOfBytes@{outOfBytes}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{outOfBytes}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf outOfBytes}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a281c9bc4944bdbf837d5432478d43273}
\hypertarget{classX86ISA_1_1Decoder_a4790fc37f276d111825695679818d082}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!Prefixes@{Prefixes}}
\index{Prefixes@{Prefixes}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{Prefixes}]{\setlength{\rightskip}{0pt plus 5cm}const uint8\_\-t {\bf Prefixes}\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a4790fc37f276d111825695679818d082}
{\bfseries 初期値:}
\begin{DoxyCode}

    {    

 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 0 , 0 , 0 , 0 , 0 , 0 , ES, 0 , 0 , 0 , 0 , 0 , 0 , 0 , CS, 0,
 0 , 0 , 0 , 0 , 0 , 0 , SS, 0 , 0 , 0 , 0 , 0 , 0 , 0 , DS, 0,
 RX, RX, RX, RX, RX, RX, RX, RX, RX, RX, RX, RX, RX, RX, RX, RX,
 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 0 , 0 , 0 , 0 , FS, GS, OO, AO, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
 LO, 0 , RN, RE, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0
    }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_a30eeeb2cd279f8cfcbafbd9873691d2f}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!SizeTypeToSize@{SizeTypeToSize}}
\index{SizeTypeToSize@{SizeTypeToSize}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{SizeTypeToSize}]{\setlength{\rightskip}{0pt plus 5cm}const uint8\_\-t {\bf SizeTypeToSize}\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a30eeeb2cd279f8cfcbafbd9873691d2f}
{\bfseries 初期値:}
\begin{DoxyCode}

    {

        {0,    1,   2,   4,    8,    16,   2,    2,    3,    4      }, 
        {0,    1,   2,   4,    8,    16,   4,    4,    3,    6      }, 
        {0,    1,   2,   4,    8,    16,   8,    4,    3,    0      }  
    }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Decoder_aef01e995775f4a7ba2367414f311dc73}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!stack@{stack}}
\index{stack@{stack}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{stack}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf stack}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_aef01e995775f4a7ba2367414f311dc73}
\hypertarget{classX86ISA_1_1Decoder_a876b486d3a5241a126bd5751c5f70f79}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!state@{state}}
\index{state@{state}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{state}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} {\bf state}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a876b486d3a5241a126bd5751c5f70f79}
\hypertarget{classX86ISA_1_1Decoder_a476c8dbd8e30b9067e6c2f0b7274be73}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!submode@{submode}}
\index{submode@{submode}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{submode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf X86SubMode} {\bf submode}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a476c8dbd8e30b9067e6c2f0b7274be73}
\hypertarget{classX86ISA_1_1Decoder_a6e9f1359a8e815c5bdd0efc306f5bf32}{
\index{X86ISA::Decoder@{X86ISA::Decoder}!UsesModRM@{UsesModRM}}
\index{UsesModRM@{UsesModRM}!X86ISA::Decoder@{X86ISA::Decoder}}
\subsubsection[{UsesModRM}]{\setlength{\rightskip}{0pt plus 5cm}const uint8\_\-t {\bf UsesModRM}\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classX86ISA_1_1Decoder_a6e9f1359a8e815c5bdd0efc306f5bf32}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/x86/\hyperlink{x86_2decoder_8hh}{decoder.hh}\item 
arch/x86/\hyperlink{x86_2decoder_8cc}{decoder.cc}\item 
arch/x86/\hyperlink{decoder__tables_8cc}{decoder\_\-tables.cc}\end{DoxyCompactItemize}
