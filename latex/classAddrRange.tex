\hypertarget{classAddrRange}{
\section{クラス AddrRange}
\label{classAddrRange}\index{AddrRange@{AddrRange}}
}


{\ttfamily \#include $<$addr\_\-range.hh$>$}\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classAddrRange_a44912ab62e2b99d5550e4580da4f0bb6}{AddrRange} ()
\item 
\hyperlink{classAddrRange_a76f19b26f65154f49d9316dbe37dbde6}{AddrRange} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classAddrRange_a8ae30d144fb49dec55c70ef1274df68a}{\_\-start}, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classAddrRange_a945d5a5b811e52aaf2aa2ca0b1aff5c5}{\_\-end}, uint8\_\-t \_\-intlv\_\-high\_\-bit, uint8\_\-t \_\-intlv\_\-bits, uint8\_\-t \_\-intlv\_\-match)
\item 
\hyperlink{classAddrRange_ae9e275cc2d13224e46507e52869d9fa0}{AddrRange} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classAddrRange_a8ae30d144fb49dec55c70ef1274df68a}{\_\-start}, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classAddrRange_a945d5a5b811e52aaf2aa2ca0b1aff5c5}{\_\-end})
\item 
\hyperlink{classAddrRange_a3f7bd25bb87bb07a17105ecfe3a41804}{AddrRange} (const \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classAddrRange}{AddrRange} $>$ \&ranges)
\item 
bool \hyperlink{classAddrRange_a5d52a3406dc6afea475c78ce06508afa}{interleaved} () const 
\item 
uint64\_\-t \hyperlink{classAddrRange_a2eca79b1c6faa6be9254f65e6e886355}{granularity} () const 
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classAddrRange_a922914e9ba305472e1643f0be3b6ab01}{stripes} () const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classAddrRange_ade0faa4f478bf244b35fb208d640c648}{size} () const 
\item 
bool \hyperlink{classAddrRange_a8d985300b138b6c5556ab17ed4df3b38}{valid} () const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classAddrRange_a85325674b7aed05d6b4e40a48563189b}{start} () const 
\item 
std::string \hyperlink{classAddrRange_aa48c39f92bc04eded742f5310c74aafe}{to\_\-string} () const 
\item 
bool \hyperlink{classAddrRange_aa1196b9847a4edf3e67f40a7e4bf63e8}{mergesWith} (const \hyperlink{classAddrRange}{AddrRange} \&r) const 
\item 
bool \hyperlink{classAddrRange_af078c7e4b8ad8c7f3666ebb2fef613da}{intersects} (const \hyperlink{classAddrRange}{AddrRange} \&r) const 
\item 
bool \hyperlink{classAddrRange_a3d9821127a28a036fbcc96d1ba20b8e2}{isSubset} (const \hyperlink{classAddrRange}{AddrRange} \&r) const 
\item 
bool \hyperlink{classAddrRange_aa839dbf0ffc0e871a3f08f1d23d78a18}{contains} (const \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \&a) const 
\item 
bool \hyperlink{classAddrRange_a9f850195d97cc5f161ba7e5c880facc8}{operator$<$} (const \hyperlink{classAddrRange}{AddrRange} \&r) const 
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classAddrRange_a8ae30d144fb49dec55c70ef1274df68a}{\_\-start}
\begin{DoxyCompactList}\small\item\em Private fields for the start and end of the range. \item\end{DoxyCompactList}\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classAddrRange_a945d5a5b811e52aaf2aa2ca0b1aff5c5}{\_\-end}
\item 
uint8\_\-t \hyperlink{classAddrRange_a4160474d6dec766ee20330ae309e3998}{intlvHighBit}
\begin{DoxyCompactList}\small\item\em The high bit of the slice that is used for interleaving. \item\end{DoxyCompactList}\item 
uint8\_\-t \hyperlink{classAddrRange_a02537b213a36c9f9d57d8c79a0dfb198}{intlvBits}
\begin{DoxyCompactList}\small\item\em The number of bits used for interleaving, set to 0 to disable. \item\end{DoxyCompactList}\item 
uint8\_\-t \hyperlink{classAddrRange_a0d9068b55e0d449e9b8ec483536394a9}{intlvMatch}
\end{DoxyCompactItemize}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classAddrRange_a44912ab62e2b99d5550e4580da4f0bb6}{
\index{AddrRange@{AddrRange}!AddrRange@{AddrRange}}
\index{AddrRange@{AddrRange}!AddrRange@{AddrRange}}
\subsubsection[{AddrRange}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRange} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddrRange_a44912ab62e2b99d5550e4580da4f0bb6}



\begin{DoxyCode}
77         : _start(1), _end(0), intlvHighBit(0), intlvBits(0), intlvMatch(0)
78     {}
\end{DoxyCode}
\hypertarget{classAddrRange_a76f19b26f65154f49d9316dbe37dbde6}{
\index{AddrRange@{AddrRange}!AddrRange@{AddrRange}}
\index{AddrRange@{AddrRange}!AddrRange@{AddrRange}}
\subsubsection[{AddrRange}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRange} ({\bf Addr} {\em \_\-start}, \/  {\bf Addr} {\em \_\-end}, \/  uint8\_\-t {\em \_\-intlv\_\-high\_\-bit}, \/  uint8\_\-t {\em \_\-intlv\_\-bits}, \/  uint8\_\-t {\em \_\-intlv\_\-match})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddrRange_a76f19b26f65154f49d9316dbe37dbde6}



\begin{DoxyCode}
82         : _start(_start), _end(_end), intlvHighBit(_intlv_high_bit),
83           intlvBits(_intlv_bits), intlvMatch(_intlv_match)
84     {}
\end{DoxyCode}
\hypertarget{classAddrRange_ae9e275cc2d13224e46507e52869d9fa0}{
\index{AddrRange@{AddrRange}!AddrRange@{AddrRange}}
\index{AddrRange@{AddrRange}!AddrRange@{AddrRange}}
\subsubsection[{AddrRange}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRange} ({\bf Addr} {\em \_\-start}, \/  {\bf Addr} {\em \_\-end})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddrRange_ae9e275cc2d13224e46507e52869d9fa0}



\begin{DoxyCode}
87         : _start(_start), _end(_end), intlvHighBit(0), intlvBits(0),
88           intlvMatch(0)
89     {}
\end{DoxyCode}
\hypertarget{classAddrRange_a3f7bd25bb87bb07a17105ecfe3a41804}{
\index{AddrRange@{AddrRange}!AddrRange@{AddrRange}}
\index{AddrRange@{AddrRange}!AddrRange@{AddrRange}}
\subsubsection[{AddrRange}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRange} (const {\bf std::vector}$<$ {\bf AddrRange} $>$ \& {\em ranges})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddrRange_a3f7bd25bb87bb07a17105ecfe3a41804}
Create an address range by merging a collection of interleaved ranges.


\begin{DoxyParams}{引数}
\item[{\em ranges}]Interleaved ranges to be merged \end{DoxyParams}



\begin{DoxyCode}
98         : _start(1), _end(0), intlvHighBit(0), intlvBits(0), intlvMatch(0)
99     {
100         if (!ranges.empty()) {
101             // get the values from the first one and check the others
102             _start = ranges.front()._start;
103             _end = ranges.front()._end;
104             intlvHighBit = ranges.front().intlvHighBit;
105             intlvBits = ranges.front().intlvBits;
106 
107             if (ranges.size() != (ULL(1) << intlvBits))
108                 fatal("Got %d ranges spanning %d interleaving bits\n",
109                       ranges.size(), intlvBits);
110 
111             uint8_t match = 0;
112             for (std::vector<AddrRange>::const_iterator r = ranges.begin();
113                  r != ranges.end(); ++r) {
114                 if (!mergesWith(*r))
115                     fatal("Can only merge ranges with the same start, end "
116                           "and interleaving bits\n");
117 
118                 if (r->intlvMatch != match)
119                     fatal("Expected interleave match %d but got %d when "
120                           "merging\n", match, r->intlvMatch);
121                 ++match;
122             }
123 
124             // our range is complete and we can turn this into a
125             // non-interleaved range
126             intlvHighBit = 0;
127             intlvBits = 0;
128         }
129     }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classAddrRange_aa839dbf0ffc0e871a3f08f1d23d78a18}{
\index{AddrRange@{AddrRange}!contains@{contains}}
\index{contains@{contains}!AddrRange@{AddrRange}}
\subsubsection[{contains}]{\setlength{\rightskip}{0pt plus 5cm}bool contains (const {\bf Addr} \& {\em a}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddrRange_aa839dbf0ffc0e871a3f08f1d23d78a18}
Determine if the range contains an address.


\begin{DoxyParams}{引数}
\item[{\em a}]\hyperlink{classAddress}{Address} to compare with \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
true if the address is in the range 
\end{DoxyReturn}



\begin{DoxyCode}
260     {
261         // check if the address is in the range and if there is either
262         // no interleaving, or with interleaving also if the selected
263         // bits from the address match the interleaving value
264         return a >= _start && a <= _end &&
265             (!interleaved() ||
266              (bits(a, intlvHighBit, intlvHighBit - intlvBits + 1) ==
267               intlvMatch));
268     }
\end{DoxyCode}
\hypertarget{classAddrRange_a2eca79b1c6faa6be9254f65e6e886355}{
\index{AddrRange@{AddrRange}!granularity@{granularity}}
\index{granularity@{granularity}!AddrRange@{AddrRange}}
\subsubsection[{granularity}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t granularity () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddrRange_a2eca79b1c6faa6be9254f65e6e886355}
Determing the interleaving granularity of the range.

\begin{DoxyReturn}{戻り値}
The size of the regions created by the interleaving bits 
\end{DoxyReturn}



\begin{DoxyCode}
144     {
145         return ULL(1) << (intlvHighBit - intlvBits + 1);
146     }
\end{DoxyCode}
\hypertarget{classAddrRange_a5d52a3406dc6afea475c78ce06508afa}{
\index{AddrRange@{AddrRange}!interleaved@{interleaved}}
\index{interleaved@{interleaved}!AddrRange@{AddrRange}}
\subsubsection[{interleaved}]{\setlength{\rightskip}{0pt plus 5cm}bool interleaved () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddrRange_a5d52a3406dc6afea475c78ce06508afa}
Determine if the range is interleaved or not.

\begin{DoxyReturn}{戻り値}
true if interleaved 
\end{DoxyReturn}



\begin{DoxyCode}
136 { return intlvBits != 0; }
\end{DoxyCode}
\hypertarget{classAddrRange_af078c7e4b8ad8c7f3666ebb2fef613da}{
\index{AddrRange@{AddrRange}!intersects@{intersects}}
\index{intersects@{intersects}!AddrRange@{AddrRange}}
\subsubsection[{intersects}]{\setlength{\rightskip}{0pt plus 5cm}bool intersects (const {\bf AddrRange} \& {\em r}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddrRange_af078c7e4b8ad8c7f3666ebb2fef613da}
Determine if another range intersects this one, i.e. if there is an address that is both in this range and the other range. No check is made to ensure either range is valid.


\begin{DoxyParams}{引数}
\item[{\em r}]Range to intersect with \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
true if the intersection of the two ranges is not empty 
\end{DoxyReturn}



\begin{DoxyCode}
215     {
216         if (!interleaved()) {
217             return _start <= r._end && _end >= r._start;
218         }
219 
220         // the current range is interleaved, split the check up in
221         // three cases
222         if (r.size() == 1)
223             // keep it simple and check if the address is within
224             // this range
225             return contains(r.start());
226         else if (!r.interleaved())
227             // be conservative and ignore the interleaving
228             return _start <= r._end && _end >= r._start;
229         else if (mergesWith(r))
230             // restrict the check to ranges that belong to the
231             // same chunk
232             return intlvMatch == r.intlvMatch;
233         else
234             panic("Cannot test intersection of interleaved range %s\n",
235                   to_string());
236     }
\end{DoxyCode}
\hypertarget{classAddrRange_a3d9821127a28a036fbcc96d1ba20b8e2}{
\index{AddrRange@{AddrRange}!isSubset@{isSubset}}
\index{isSubset@{isSubset}!AddrRange@{AddrRange}}
\subsubsection[{isSubset}]{\setlength{\rightskip}{0pt plus 5cm}bool isSubset (const {\bf AddrRange} \& {\em r}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddrRange_a3d9821127a28a036fbcc96d1ba20b8e2}
Determine if this range is a subset of another range, i.e. if every address in this range is also in the other range. No check is made to ensure either range is valid.


\begin{DoxyParams}{引数}
\item[{\em r}]Range to compare with \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
true if the this range is a subset of the other one 
\end{DoxyReturn}



\begin{DoxyCode}
247     {
248         if (interleaved())
249             panic("Cannot test subset of interleaved range %s\n", to_string());
250         return _start >= r._start && _end <= r._end;
251     }
\end{DoxyCode}
\hypertarget{classAddrRange_aa1196b9847a4edf3e67f40a7e4bf63e8}{
\index{AddrRange@{AddrRange}!mergesWith@{mergesWith}}
\index{mergesWith@{mergesWith}!AddrRange@{AddrRange}}
\subsubsection[{mergesWith}]{\setlength{\rightskip}{0pt plus 5cm}bool mergesWith (const {\bf AddrRange} \& {\em r}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddrRange_aa1196b9847a4edf3e67f40a7e4bf63e8}
Determine if another range merges with the current one, i.e. if they are part of the same contigous range and have the same interleaving bits.


\begin{DoxyParams}{引数}
\item[{\em r}]Range to evaluate merging with \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
true if the two ranges would merge 
\end{DoxyReturn}



\begin{DoxyCode}
200     {
201         return r._start == _start && r._end == _end &&
202             r.intlvHighBit == intlvHighBit &&
203             r.intlvBits == intlvBits;
204     }
\end{DoxyCode}
\hypertarget{classAddrRange_a9f850195d97cc5f161ba7e5c880facc8}{
\index{AddrRange@{AddrRange}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!AddrRange@{AddrRange}}
\subsubsection[{operator$<$}]{\setlength{\rightskip}{0pt plus 5cm}bool operator$<$ (const {\bf AddrRange} \& {\em r}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddrRange_a9f850195d97cc5f161ba7e5c880facc8}
Keep the operators away from SWIG. Less-\/than operator used to turn an STL map into a binary search tree of non-\/overlapping address ranges.


\begin{DoxyParams}{引数}
\item[{\em r}]Range to compare with \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
true if the start address is less than that of the other range 
\end{DoxyReturn}



\begin{DoxyCode}
283     {
284         if (_start != r._start)
285             return _start < r._start;
286         else
287             // for now assume that the end is also the same, and that
288             // we are looking at the same interleaving bits
289             return intlvMatch < r.intlvMatch;
290     }
\end{DoxyCode}
\hypertarget{classAddrRange_ade0faa4f478bf244b35fb208d640c648}{
\index{AddrRange@{AddrRange}!size@{size}}
\index{size@{size}!AddrRange@{AddrRange}}
\subsubsection[{size}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} size () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddrRange_ade0faa4f478bf244b35fb208d640c648}
Get the size of the address range. For a case where interleaving is used we make the simplifying assumption that the size is a divisible by the size of the interleaving slice. 


\begin{DoxyCode}
162     {
163         return (_end - _start + 1) >> intlvBits;
164     }
\end{DoxyCode}
\hypertarget{classAddrRange_a85325674b7aed05d6b4e40a48563189b}{
\index{AddrRange@{AddrRange}!start@{start}}
\index{start@{start}!AddrRange@{AddrRange}}
\subsubsection[{start}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} start () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddrRange_a85325674b7aed05d6b4e40a48563189b}
Get the start address of the range. 


\begin{DoxyCode}
174 { return _start; }
\end{DoxyCode}
\hypertarget{classAddrRange_a922914e9ba305472e1643f0be3b6ab01}{
\index{AddrRange@{AddrRange}!stripes@{stripes}}
\index{stripes@{stripes}!AddrRange@{AddrRange}}
\subsubsection[{stripes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} stripes () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddrRange_a922914e9ba305472e1643f0be3b6ab01}
Determine the number of interleaved address stripes this range is part of.

\begin{DoxyReturn}{戻り値}
The number of stripes spanned by the interleaving bits 
\end{DoxyReturn}



\begin{DoxyCode}
154 { return ULL(1) << intlvBits; }
\end{DoxyCode}
\hypertarget{classAddrRange_aa48c39f92bc04eded742f5310c74aafe}{
\index{AddrRange@{AddrRange}!to\_\-string@{to\_\-string}}
\index{to\_\-string@{to\_\-string}!AddrRange@{AddrRange}}
\subsubsection[{to\_\-string}]{\setlength{\rightskip}{0pt plus 5cm}std::string to\_\-string () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddrRange_aa48c39f92bc04eded742f5310c74aafe}
Get a string representation of the range. This could alternatively be implemented as a operator$<$$<$, but at the moment that seems like overkill. 


\begin{DoxyCode}
182     {
183         if (interleaved())
184             return csprintf("[%#llx : %#llx], [%d : %d] = %d", _start, _end,
185                             intlvHighBit, intlvHighBit - intlvBits + 1,
186                             intlvMatch);
187         else
188             return csprintf("[%#llx : %#llx]", _start, _end);
189     }
\end{DoxyCode}
\hypertarget{classAddrRange_a8d985300b138b6c5556ab17ed4df3b38}{
\index{AddrRange@{AddrRange}!valid@{valid}}
\index{valid@{valid}!AddrRange@{AddrRange}}
\subsubsection[{valid}]{\setlength{\rightskip}{0pt plus 5cm}bool valid () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddrRange_a8d985300b138b6c5556ab17ed4df3b38}
Determine if the range is valid. 


\begin{DoxyCode}
169 { return _start < _end; }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classAddrRange_a945d5a5b811e52aaf2aa2ca0b1aff5c5}{
\index{AddrRange@{AddrRange}!\_\-end@{\_\-end}}
\index{\_\-end@{\_\-end}!AddrRange@{AddrRange}}
\subsubsection[{\_\-end}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf \_\-end}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAddrRange_a945d5a5b811e52aaf2aa2ca0b1aff5c5}
\hypertarget{classAddrRange_a8ae30d144fb49dec55c70ef1274df68a}{
\index{AddrRange@{AddrRange}!\_\-start@{\_\-start}}
\index{\_\-start@{\_\-start}!AddrRange@{AddrRange}}
\subsubsection[{\_\-start}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf \_\-start}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAddrRange_a8ae30d144fb49dec55c70ef1274df68a}


Private fields for the start and end of the range. \hypertarget{classAddrRange_a02537b213a36c9f9d57d8c79a0dfb198}{
\index{AddrRange@{AddrRange}!intlvBits@{intlvBits}}
\index{intlvBits@{intlvBits}!AddrRange@{AddrRange}}
\subsubsection[{intlvBits}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf intlvBits}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAddrRange_a02537b213a36c9f9d57d8c79a0dfb198}


The number of bits used for interleaving, set to 0 to disable. \hypertarget{classAddrRange_a4160474d6dec766ee20330ae309e3998}{
\index{AddrRange@{AddrRange}!intlvHighBit@{intlvHighBit}}
\index{intlvHighBit@{intlvHighBit}!AddrRange@{AddrRange}}
\subsubsection[{intlvHighBit}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf intlvHighBit}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAddrRange_a4160474d6dec766ee20330ae309e3998}


The high bit of the slice that is used for interleaving. \hypertarget{classAddrRange_a0d9068b55e0d449e9b8ec483536394a9}{
\index{AddrRange@{AddrRange}!intlvMatch@{intlvMatch}}
\index{intlvMatch@{intlvMatch}!AddrRange@{AddrRange}}
\subsubsection[{intlvMatch}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf intlvMatch}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAddrRange_a0d9068b55e0d449e9b8ec483536394a9}
The value to compare the slice addr\mbox{[}high:(high -\/ bits + 1)\mbox{]} with. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
base/\hyperlink{addr__range_8hh}{addr\_\-range.hh}\end{DoxyCompactItemize}
