\hypertarget{classKvmVM}{
\section{クラス KvmVM}
\label{classKvmVM}\index{KvmVM@{KvmVM}}
}


{\ttfamily \#include $<$vm.hh$>$}KvmVMに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classKvmVM}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classKvmVM_affe776b6ed46258acb05e93d1e3ea060}{KvmVM} (KvmVMParams $\ast$params)
\item 
virtual \hyperlink{classKvmVM_a57e34345c5d7c563ce7bdddcd0fb6017}{$\sim$KvmVM} ()
\item 
void \hyperlink{classKvmVM_a04e3bed0038549a704fe5c04015ce46d}{setTSSAddress} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} tss\_\-address)
\item 
void \hyperlink{group__KvmInterrupts_ga75f1140369bf3942bb93a75d1b3de2c9}{createIRQChip} ()
\item 
void \hyperlink{group__KvmInterrupts_ga5037b917c47fff611ecdd5b547655284}{setIRQLine} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} irq, bool high)
\item 
bool \hyperlink{group__KvmInterrupts_ga4e9371a3b5e598c4cde8ebef65be940f}{hasKernelIRQChip} () const 
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classKvm}{Kvm} \hyperlink{classKvmVM_a4169de9bdb8aa1afbeed2acc231dbb7f}{kvm}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classKvmVM_a0161816a71e88927cba137fb4dde7298}{cpuStartup} ()
\item 
void \hyperlink{classKvmVM_a508d2bd176120153c08b1fe4c7e2bc2c}{delayedStartup} ()
\item 
int \hyperlink{classKvmVM_a3841d0c536bfa3b8f3b4e8ef5a46039b}{createVCPU} (long vcpuID)
\item 
long \hyperlink{classKvmVM_a78b0d1b84b25d38fca24a596ebdbcea6}{allocVCPUID} ()
\item 
int \hyperlink{group__KvmIoctl_ga106fe09b5e87d6c14884f8ffff7b338a}{ioctl} (int request, long p1) const 
\item 
int \hyperlink{group__KvmIoctl_ga89db87cb31fe2ba732de8fa68c8bd1f1}{ioctl} (int request, void $\ast$p1) const 
\item 
int \hyperlink{group__KvmIoctl_ga32cd3b0742689c29c9ab9e3e03feb5f2}{ioctl} (int request) const 
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classKvmVM_a93d7cb38823ea4730a0c04893301c80a}{KvmVM} (const \hyperlink{classKvmVM}{KvmVM} \&vm)
\item 
\hyperlink{classKvmVM}{KvmVM} \& \hyperlink{classKvmVM_a4618bd58dd0f40bb2ab57327f7223310}{operator=} (const \hyperlink{classKvmVM}{KvmVM} \&vm)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSystem}{System} $\ast$ \hyperlink{classKvmVM_af27ccd765f13a4b7bd119dc7579e2746}{system}
\item 
const int \hyperlink{classKvmVM_ad268d2f789e668c440ed8fe37f115860}{vmFD}
\item 
bool \hyperlink{classKvmVM_a43c08d193d555a2b2a61c53d2a4e5a63}{started}
\item 
bool \hyperlink{classKvmVM_a7256488cd8c3b1c41c2417ade40cde88}{\_\-hasKernelIRQChip}
\item 
long \hyperlink{classKvmVM_a1739363b740f33ceef9f8187dd2078f1}{nextVCPUID}
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classKvmVM_a61d1fc6581a443ce7c1106a1b6922d40}{BaseKvmCPU}
\end{DoxyCompactItemize}
\label{_amgrpd41d8cd98f00b204e9800998ecf8427e}
 \begin{DoxyCompactItemize}
\item 
void \hyperlink{classKvmVM_a438f7ca24f2e320af449cd86d2a70990}{coalesceMMIO} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} start, int size)
\item 
void \hyperlink{classKvmVM_a4584fab486daeedc3dd9cb932ff55917}{coalesceMMIO} (const \hyperlink{classAddrRange}{AddrRange} \&range)
\item 
void \hyperlink{classKvmVM_a2d2ed492c91fc674db226f86fae39127}{setUserMemoryRegion} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} slot, void $\ast$host\_\-addr, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} guest\_\-addr, uint64\_\-t len, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} flags)
\item 
void \hyperlink{classKvmVM_a2ec4864d5df313708eff4cda418d8d01}{setUserMemoryRegion} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} slot, void $\ast$host\_\-addr, \hyperlink{classAddrRange}{AddrRange} guest\_\-range, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} flags)
\end{DoxyCompactItemize}


\subsection{説明}
KVM VM container

A KVM VM container normally contains all the CPUs in a shared memory machine. The VM container handles things like physical memory and to some extent interrupts. Normally, the VM API is only used for interrupts when the PIC is emulated by the kernel, which is a feature we do not use. However, some architectures (notably ARM) use the VM interface to deliver interrupts to specific CPUs as well.

VM initialization is a bit different from that of other SimObjects. When we initialize the VM, we discover all physical memory mappings in the system. Since \hyperlink{thread__context_8hh_aab2bbbf3710db70a2886ed6c49038af7}{AbstractMem::unserialize} re-\/maps the guests memory, we need to make sure that this is done after the memory has been re-\/mapped, but before the vCPUs are initialized (KVM requires memory mappings to be setup before CPUs can be created). Normally, we would just initialize the VM in \hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} or \hyperlink{classSimObject_aecc7d8debf54990ffeaaed5bac7d7d81}{startup()}, however, we can not use \hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} since this is called before \hyperlink{thread__context_8cc_aab2bbbf3710db70a2886ed6c49038af7}{AbstractMem::unserialize()} and we can not use \hyperlink{classSimObject_aecc7d8debf54990ffeaaed5bac7d7d81}{startup()} since it must be called before \hyperlink{classBaseKvmCPU_aecc7d8debf54990ffeaaed5bac7d7d81}{BaseKvmCPU::startup()} and the simulator framework does not guarantee call order. We therefore call \hyperlink{classKvmVM_a0161816a71e88927cba137fb4dde7298}{cpuStartup()} from \hyperlink{classBaseKvmCPU_aecc7d8debf54990ffeaaed5bac7d7d81}{BaseKvmCPU::startup()} instead and execute the initialization code once when the first CPU in the VM is starting. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classKvmVM_affe776b6ed46258acb05e93d1e3ea060}{
\index{KvmVM@{KvmVM}!KvmVM@{KvmVM}}
\index{KvmVM@{KvmVM}!KvmVM@{KvmVM}}
\subsubsection[{KvmVM}]{\setlength{\rightskip}{0pt plus 5cm}{\bf KvmVM} (KvmVMParams $\ast$ {\em params})}}
\label{classKvmVM_affe776b6ed46258acb05e93d1e3ea060}



\begin{DoxyCode}
285     : SimObject(params),
286       kvm(), system(params->system),
287       vmFD(kvm.createVM()),
288       started(false),
289       nextVCPUID(0)
290 {
291     /* Setup the coalesced MMIO regions */
292     for (int i = 0; i < params->coalescedMMIO.size(); ++i)
293         coalesceMMIO(params->coalescedMMIO[i]);
294 }
\end{DoxyCode}
\hypertarget{classKvmVM_a57e34345c5d7c563ce7bdddcd0fb6017}{
\index{KvmVM@{KvmVM}!$\sim$KvmVM@{$\sim$KvmVM}}
\index{$\sim$KvmVM@{$\sim$KvmVM}!KvmVM@{KvmVM}}
\subsubsection[{$\sim$KvmVM}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf KvmVM} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classKvmVM_a57e34345c5d7c563ce7bdddcd0fb6017}



\begin{DoxyCode}
297 {
298     close(vmFD);
299 }
\end{DoxyCode}
\hypertarget{classKvmVM_a93d7cb38823ea4730a0c04893301c80a}{
\index{KvmVM@{KvmVM}!KvmVM@{KvmVM}}
\index{KvmVM@{KvmVM}!KvmVM@{KvmVM}}
\subsubsection[{KvmVM}]{\setlength{\rightskip}{0pt plus 5cm}{\bf KvmVM} (const {\bf KvmVM} \& {\em vm})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classKvmVM_a93d7cb38823ea4730a0c04893301c80a}


\subsection{関数}
\hypertarget{classKvmVM_a78b0d1b84b25d38fca24a596ebdbcea6}{
\index{KvmVM@{KvmVM}!allocVCPUID@{allocVCPUID}}
\index{allocVCPUID@{allocVCPUID}!KvmVM@{KvmVM}}
\subsubsection[{allocVCPUID}]{\setlength{\rightskip}{0pt plus 5cm}long allocVCPUID ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classKvmVM_a78b0d1b84b25d38fca24a596ebdbcea6}
Allocate a new vCPU ID within the VM.

The returned vCPU ID is guaranteed to be unique within the VM. New IDs are allocated sequentially starting from 0.

\begin{DoxyReturn}{戻り値}
ID of the new vCPU 
\end{DoxyReturn}



\begin{DoxyCode}
443 {
444     return nextVCPUID++;
445 }
\end{DoxyCode}
\hypertarget{classKvmVM_a4584fab486daeedc3dd9cb932ff55917}{
\index{KvmVM@{KvmVM}!coalesceMMIO@{coalesceMMIO}}
\index{coalesceMMIO@{coalesceMMIO}!KvmVM@{KvmVM}}
\subsubsection[{coalesceMMIO}]{\setlength{\rightskip}{0pt plus 5cm}void coalesceMMIO (const {\bf AddrRange} \& {\em range})}}
\label{classKvmVM_a4584fab486daeedc3dd9cb932ff55917}
\hyperlink{classRequest}{Request} coalescing MMIO for a memory range.


\begin{DoxyParams}{引数}
\item[{\em range}]Coalesced MMIO range \end{DoxyParams}



\begin{DoxyCode}
374 {
375     coalesceMMIO(range.start(), range.size());
376 }
\end{DoxyCode}
\hypertarget{classKvmVM_a438f7ca24f2e320af449cd86d2a70990}{
\index{KvmVM@{KvmVM}!coalesceMMIO@{coalesceMMIO}}
\index{coalesceMMIO@{coalesceMMIO}!KvmVM@{KvmVM}}
\subsubsection[{coalesceMMIO}]{\setlength{\rightskip}{0pt plus 5cm}void coalesceMMIO ({\bf Addr} {\em start}, \/  int {\em size})}}
\label{classKvmVM_a438f7ca24f2e320af449cd86d2a70990}
\hyperlink{classRequest}{Request} coalescing MMIO for a memory range.


\begin{DoxyParams}{引数}
\item[{\em start}]Physical start address in guest \item[{\em size}]Size of the MMIO region \end{DoxyParams}



\begin{DoxyCode}
380 {
381     struct kvm_coalesced_mmio_zone zone;
382 
383     zone.addr = start;
384     zone.size = size;
385     zone.pad = 0;
386 
387     DPRINTF(Kvm, "KVM: Registering coalesced MMIO region [0x%x, 0x%x]\n",
388             zone.addr, zone.addr + zone.size - 1);
389     if (ioctl(KVM_REGISTER_COALESCED_MMIO, (void *)&zone) == -1)
390         panic("KVM: Failed to register coalesced MMIO region (%i)\n",
391               errno);
392 }
\end{DoxyCode}
\hypertarget{classKvmVM_a0161816a71e88927cba137fb4dde7298}{
\index{KvmVM@{KvmVM}!cpuStartup@{cpuStartup}}
\index{cpuStartup@{cpuStartup}!KvmVM@{KvmVM}}
\subsubsection[{cpuStartup}]{\setlength{\rightskip}{0pt plus 5cm}void cpuStartup ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classKvmVM_a0161816a71e88927cba137fb4dde7298}
VM CPU initialization code.

This method is called from \hyperlink{classBaseKvmCPU_aecc7d8debf54990ffeaaed5bac7d7d81}{BaseKvmCPU::startup()} when a CPU in the VM executes its \hyperlink{classBaseKvmCPU_aecc7d8debf54990ffeaaed5bac7d7d81}{BaseKvmCPU::startup()} method. The first time method is executed on a VM, it calls the \hyperlink{classKvmVM_a508d2bd176120153c08b1fe4c7e2bc2c}{delayedStartup()} method. 


\begin{DoxyCode}
303 {
304     if (started)
305         return;
306     started = true;
307 
308     delayedStartup();
309 }
\end{DoxyCode}
\hypertarget{classKvmVM_a3841d0c536bfa3b8f3b4e8ef5a46039b}{
\index{KvmVM@{KvmVM}!createVCPU@{createVCPU}}
\index{createVCPU@{createVCPU}!KvmVM@{KvmVM}}
\subsubsection[{createVCPU}]{\setlength{\rightskip}{0pt plus 5cm}int createVCPU (long {\em vcpuID})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classKvmVM_a3841d0c536bfa3b8f3b4e8ef5a46039b}
Create a new vCPU within a VM.


\begin{DoxyParams}{引数}
\item[{\em vcpuID}]ID of the new CPU within the VM. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
File descriptor referencing the CPU. 
\end{DoxyReturn}



\begin{DoxyCode}
431 {
432     int fd;
433 
434     fd = ioctl(KVM_CREATE_VCPU, vcpuID);
435     if (fd == -1)
436         panic("KVM: Failed to create virtual CPU");
437 
438     return fd;
439 }
\end{DoxyCode}
\hypertarget{classKvmVM_a508d2bd176120153c08b1fe4c7e2bc2c}{
\index{KvmVM@{KvmVM}!delayedStartup@{delayedStartup}}
\index{delayedStartup@{delayedStartup}!KvmVM@{KvmVM}}
\subsubsection[{delayedStartup}]{\setlength{\rightskip}{0pt plus 5cm}void delayedStartup ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classKvmVM_a508d2bd176120153c08b1fe4c7e2bc2c}
Delayed initialization, executed once before the first CPU starts.

This method provides a way to do VM initialization once before the first CPU in a VM starts. It is needed since some resources (e.g., memory mappings) can change in the normal \hyperlink{classSimObject_aecc7d8debf54990ffeaaed5bac7d7d81}{SimObject::startup()} path. Since the call order of \hyperlink{classSimObject_aecc7d8debf54990ffeaaed5bac7d7d81}{SimObject::startup()} is not guaranteed, we simply defer some initialization until a CPU is about to start. 


\begin{DoxyCode}
313 {
314     const std::vector<std::pair<AddrRange, uint8_t*> >&memories(
315         system->getPhysMem().getBackingStore());
316 
317     DPRINTF(Kvm, "Mapping %i memory region(s)\n", memories.size());
318     for (int slot(0); slot < memories.size(); ++slot) {
319         const AddrRange &range(memories[slot].first);
320         void *pmem(memories[slot].second);
321 
322         if (pmem) {
323             DPRINTF(Kvm, "Mapping region: 0x%p -> 0x%llx [size: 0x%llx]\n",
324                     pmem, range.start(), range.size());
325 
326             setUserMemoryRegion(slot, pmem, range, 0 /* flags */);
327         } else {
328             DPRINTF(Kvm, "Zero-region not mapped: [0x%llx]\n", range.start());
329             hack("KVM: Zero memory handled as IO\n");
330         }
331     }
332 }
\end{DoxyCode}
\hypertarget{classKvmVM_a4618bd58dd0f40bb2ab57327f7223310}{
\index{KvmVM@{KvmVM}!operator=@{operator=}}
\index{operator=@{operator=}!KvmVM@{KvmVM}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf KvmVM}\& operator= (const {\bf KvmVM} \& {\em vm})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classKvmVM_a4618bd58dd0f40bb2ab57327f7223310}
\hypertarget{classKvmVM_a04e3bed0038549a704fe5c04015ce46d}{
\index{KvmVM@{KvmVM}!setTSSAddress@{setTSSAddress}}
\index{setTSSAddress@{setTSSAddress}!KvmVM@{KvmVM}}
\subsubsection[{setTSSAddress}]{\setlength{\rightskip}{0pt plus 5cm}void setTSSAddress ({\bf Addr} {\em tss\_\-address})}}
\label{classKvmVM_a04e3bed0038549a704fe5c04015ce46d}
Setup a shared three-\/page memory region used by the internals of KVM. This is currently only needed by x86 implementations.


\begin{DoxyParams}{引数}
\item[{\em tss\_\-address}]Physical address of the start of the TSS \end{DoxyParams}



\begin{DoxyCode}
396 {
397     if (ioctl(KVM_SET_TSS_ADDR, (unsigned long)tss_address) == -1)
398         panic("KVM: Failed to set VM TSS address\n");
399 }
\end{DoxyCode}
\hypertarget{classKvmVM_a2ec4864d5df313708eff4cda418d8d01}{
\index{KvmVM@{KvmVM}!setUserMemoryRegion@{setUserMemoryRegion}}
\index{setUserMemoryRegion@{setUserMemoryRegion}!KvmVM@{KvmVM}}
\subsubsection[{setUserMemoryRegion}]{\setlength{\rightskip}{0pt plus 5cm}void setUserMemoryRegion ({\bf uint32\_\-t} {\em slot}, \/  void $\ast$ {\em host\_\-addr}, \/  {\bf AddrRange} {\em guest\_\-range}, \/  {\bf uint32\_\-t} {\em flags})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classKvmVM_a2ec4864d5df313708eff4cda418d8d01}



\begin{DoxyCode}
338 {
339     if (guest_range.interleaved())
340         panic("Tried to map an interleaved memory range into a KVM VM.\n");
341 
342     setUserMemoryRegion(slot, host_addr,
343                         guest_range.start(), guest_range.size(),
344                         flags);
345 }
\end{DoxyCode}
\hypertarget{classKvmVM_a2d2ed492c91fc674db226f86fae39127}{
\index{KvmVM@{KvmVM}!setUserMemoryRegion@{setUserMemoryRegion}}
\index{setUserMemoryRegion@{setUserMemoryRegion}!KvmVM@{KvmVM}}
\subsubsection[{setUserMemoryRegion}]{\setlength{\rightskip}{0pt plus 5cm}void setUserMemoryRegion ({\bf uint32\_\-t} {\em slot}, \/  void $\ast$ {\em host\_\-addr}, \/  {\bf Addr} {\em guest\_\-addr}, \/  uint64\_\-t {\em len}, \/  {\bf uint32\_\-t} {\em flags})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classKvmVM_a2d2ed492c91fc674db226f86fae39127}
Setup a region of physical memory in the guest


\begin{DoxyParams}{引数}
\item[{\em slot}]KVM memory slot ID (must be unique) \item[{\em host\_\-addr}]Memory allocation backing the memory \item[{\em guest\_\-addr}]\hyperlink{classAddress}{Address} in the guest \item[{\em guest\_\-range}]\hyperlink{classAddress}{Address} range used by guest. \item[{\em len}]Size of the allocation in bytes \item[{\em flags}]\hyperlink{classFlags}{Flags} (see the KVM API documentation) \end{DoxyParams}



\begin{DoxyCode}
351 {
352     struct kvm_userspace_memory_region m;
353 
354     memset(&m, 0, sizeof(m));
355     m.slot = slot;
356     m.flags = flags;
357     m.guest_phys_addr = (uint64_t)guest_addr;
358     m.memory_size = len;
359     m.userspace_addr = (__u64)host_addr;
360 
361     if (ioctl(KVM_SET_USER_MEMORY_REGION, (void *)&m) == -1) {
362         panic("Failed to setup KVM memory region:\n"
363               "\tHost Address: 0x%p\n"
364               "\tGuest Address: 0x%llx\n",
365               "\tSize: %ll\n",
366               "\tFlags: 0x%x\n",
367               m.userspace_addr, m.guest_phys_addr,
368               m.memory_size, m.flags);
369     }
370 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classKvmVM_a61d1fc6581a443ce7c1106a1b6922d40}{
\index{KvmVM@{KvmVM}!BaseKvmCPU@{BaseKvmCPU}}
\index{BaseKvmCPU@{BaseKvmCPU}!KvmVM@{KvmVM}}
\subsubsection[{BaseKvmCPU}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf BaseKvmCPU}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classKvmVM_a61d1fc6581a443ce7c1106a1b6922d40}


\subsection{変数}
\hypertarget{classKvmVM_a7256488cd8c3b1c41c2417ade40cde88}{
\index{KvmVM@{KvmVM}!\_\-hasKernelIRQChip@{\_\-hasKernelIRQChip}}
\index{\_\-hasKernelIRQChip@{\_\-hasKernelIRQChip}!KvmVM@{KvmVM}}
\subsubsection[{\_\-hasKernelIRQChip}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \_\-hasKernelIRQChip}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classKvmVM_a7256488cd8c3b1c41c2417ade40cde88}
Do we have in-\/kernel IRQ-\/chip emulation enabled? \hypertarget{classKvmVM_a4169de9bdb8aa1afbeed2acc231dbb7f}{
\index{KvmVM@{KvmVM}!kvm@{kvm}}
\index{kvm@{kvm}!KvmVM@{KvmVM}}
\subsubsection[{kvm}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Kvm} {\bf kvm}}}
\label{classKvmVM_a4169de9bdb8aa1afbeed2acc231dbb7f}
Global KVM interface \hypertarget{classKvmVM_a1739363b740f33ceef9f8187dd2078f1}{
\index{KvmVM@{KvmVM}!nextVCPUID@{nextVCPUID}}
\index{nextVCPUID@{nextVCPUID}!KvmVM@{KvmVM}}
\subsubsection[{nextVCPUID}]{\setlength{\rightskip}{0pt plus 5cm}long {\bf nextVCPUID}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classKvmVM_a1739363b740f33ceef9f8187dd2078f1}
Next unallocated vCPU ID \hypertarget{classKvmVM_a43c08d193d555a2b2a61c53d2a4e5a63}{
\index{KvmVM@{KvmVM}!started@{started}}
\index{started@{started}!KvmVM@{KvmVM}}
\subsubsection[{started}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf started}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classKvmVM_a43c08d193d555a2b2a61c53d2a4e5a63}
Has \hyperlink{classKvmVM_a508d2bd176120153c08b1fe4c7e2bc2c}{delayedStartup()} already been called? \hypertarget{classKvmVM_af27ccd765f13a4b7bd119dc7579e2746}{
\index{KvmVM@{KvmVM}!system@{system}}
\index{system@{system}!KvmVM@{KvmVM}}
\subsubsection[{system}]{\setlength{\rightskip}{0pt plus 5cm}{\bf System}$\ast$ {\bf system}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classKvmVM_af27ccd765f13a4b7bd119dc7579e2746}
\hypertarget{classKvmVM_ad268d2f789e668c440ed8fe37f115860}{
\index{KvmVM@{KvmVM}!vmFD@{vmFD}}
\index{vmFD@{vmFD}!KvmVM@{KvmVM}}
\subsubsection[{vmFD}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf vmFD}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classKvmVM_ad268d2f789e668c440ed8fe37f115860}
KVM VM file descriptor 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/kvm/\hyperlink{vm_8hh}{vm.hh}\item 
cpu/kvm/\hyperlink{vm_8cc}{vm.cc}\end{DoxyCompactItemize}
