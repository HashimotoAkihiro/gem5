<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>File&nbsp;GEM5&nbsp;Wrapper: クラス RubyPort</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- 作成： Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>メインページ</span></a></li>
      <li><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>構成</span></a></li>
      <li><a href="classes.html"><span>構成索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>構成メンバ</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>クラス RubyPort</h1><!-- doxytag: class="RubyPort" --><!-- doxytag: inherits="MemObject" -->
<p><code>#include &lt;<a class="el" href="RubyPort_8hh_source.html">RubyPort.hh</a>&gt;</code></p>
<div class="dynheader">
RubyPortに対する継承グラフ</div>
<div class="dynsection">
 <div class="center">
  <img src="classRubyPort.gif" usemap="#RubyPort_map" alt=""/>
  <map id="RubyPort_map" name="RubyPort_map">
<area href="classMemObject.html" alt="MemObject" shape="rect" coords="112,168,214,192"/>
<area href="classClockedObject.html" alt="ClockedObject" shape="rect" coords="112,112,214,136"/>
<area href="classSimObject.html" alt="SimObject" shape="rect" coords="112,56,214,80"/>
<area href="classEventManager.html" alt="EventManager" shape="rect" coords="0,0,102,24"/>
<area href="classSerializable.html" alt="Serializable" shape="rect" coords="112,0,214,24"/>
<area href="classDrainable.html" alt="Drainable" shape="rect" coords="224,0,326,24"/>
<area href="classDMASequencer.html" alt="DMASequencer" shape="rect" coords="56,280,158,304"/>
<area href="classRubyPortProxy.html" alt="RubyPortProxy" shape="rect" coords="168,280,270,304"/>
</map>
 </div>
</div>

<p><a href="classRubyPort-members.html">すべてのメンバ一覧</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>構成</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort_1_1MemMasterPort.html">MemMasterPort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort_1_1MemSlavePort.html">MemSlavePort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort_1_1PioMasterPort.html">PioMasterPort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort_1_1PioSlavePort.html">PioSlavePort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRubyPort_1_1SenderState.html">SenderState</a></td></tr>
<tr><td colspan="2"><h2>Public 型</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef RubyPortParams&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a73ffda3b6b10849321fd359baf61eb3c">Params</a></td></tr>
<tr><td colspan="2"><h2>Public メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a48daea2300eda2ed192847716fe85997">RubyPort</a> (const <a class="el" href="classRubyPort.html#a73ffda3b6b10849321fd359baf61eb3c">Params</a> *p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#ab94ca27fbdf091331d2703af1e73d8dc">~RubyPort</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBaseMasterPort.html">BaseMasterPort</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#adc4e675e51defbdd1e354dac729d0703">getMasterPort</a> (const std::string &amp;if_name, <a class="el" href="base_2types_8hh.html#acef4d7d41cb21fdc252e20c04cd7bb8e">PortID</a> idx=<a class="el" href="base_2types_8hh.html#a65bf40f138cf863f0c5e2d8ca1144126">InvalidPortID</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBaseSlavePort.html">BaseSlavePort</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#ac918a145092d7514ebc6dbd952dceafb">getSlavePort</a> (const std::string &amp;if_name, <a class="el" href="base_2types_8hh.html#acef4d7d41cb21fdc252e20c04cd7bb8e">PortID</a> idx=<a class="el" href="base_2types_8hh.html#a65bf40f138cf863f0c5e2d8ca1144126">InvalidPortID</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual RequestStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a596adbddbc1059f06e3989f743f2ed3e">makeRequest</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a366b0b3d8b8a08b7066f1b98c1b40b85">outstandingCount</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a24d37c70faaaf126b544c2d46ea70ce2">isDeadlockEventScheduled</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#ae635736b1bd64144a8f1fc5f42948b21">descheduleDeadlockEvent</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a0768dd0d813b0d71fd45a5deb1bd0294">setController</a> (<a class="el" href="classAbstractController.html">AbstractController</a> *_cntrl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a0394d0753edf9da729ce700f110f650c">getId</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#aa8a18d230dba7a674ac8a0b4f35bc36a">drain</a> (<a class="el" href="classDrainManager.html">DrainManager</a> *dm)</td></tr>
<tr><td colspan="2"><h2>Protected メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#aa8ad1a5d600c338dcd76fcf434f3169e">ruby_hit_callback</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#ada43967d9f25e87e20fa808ff7d88a89">testDrainComplete</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#ac3858f72631784d3e09bba9070f96349">ruby_eviction_callback</a> (const <a class="el" href="classAddress.html">Address</a> &amp;address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a47ba09f9a3b3998cac9c14ab596a7515">recvTimingResp</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt, <a class="el" href="base_2types_8hh.html#acef4d7d41cb21fdc252e20c04cd7bb8e">PortID</a> master_port_id)</td></tr>
<tr><td colspan="2"><h2>Protected 変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a0d6124b18fa39209bf51ec6407fa7c0f">m_version</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAbstractController.html">AbstractController</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a1e7049f2cd244dc3944af370eb3e979a">m_controller</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMessageBuffer.html">MessageBuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a5bd71d4fde9408a3740efa5d95532c15">m_mandatory_q_ptr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#aad291d9ca2fd5321994e6553b21c530a">m_usingRubyTester</a></td></tr>
<tr><td colspan="2"><h2>Private 型</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classstd_1_1vector.html">std::vector</a><br class="typebreak"/>
&lt; <a class="el" href="classRubyPort_1_1MemSlavePort.html">MemSlavePort</a> * &gt;::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a0479a75b096e758f414b419c517de782">CpuPortIter</a></td></tr>
<tr><td colspan="2"><h2>Private メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#ad473637152492944180673282ebe71a3">addToRetryList</a> (<a class="el" href="classRubyPort_1_1MemSlavePort.html">MemSlavePort</a> *port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a6497fe5e5b0476effb15db9118962e93">getChildDrainCount</a> (<a class="el" href="classDrainManager.html">DrainManager</a> *dm)</td></tr>
<tr><td colspan="2"><h2>Private 変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRubyPort_1_1PioMasterPort.html">PioMasterPort</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#ae1618ee13262dd22f26a87a3bcb2dca2">pioMasterPort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRubyPort_1_1PioSlavePort.html">PioSlavePort</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a294b27c7011440b7e24e12afddd75eab">pioSlavePort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRubyPort_1_1MemMasterPort.html">MemMasterPort</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#ac2c1831a0923d1c83c01f7854d1d707e">memMasterPort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRubyPort_1_1MemSlavePort.html">MemSlavePort</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a5b8a0b35186f04ce4aeae758f4f0a698">memSlavePort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a7194bb8c21c2c460cc31ecea9f08b1db">gotAddrRanges</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classRubyPort_1_1MemSlavePort.html">MemSlavePort</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#ac00171ae3169a04dcc3119647b11711f">slave_ports</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classRubyPort_1_1PioMasterPort.html">PioMasterPort</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#ac95349e84e36b96125370f0ff8196196">master_ports</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDrainManager.html">DrainManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSystem.html">System</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#af27ccd765f13a4b7bd119dc7579e2746">system</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classRubyPort_1_1MemSlavePort.html">MemSlavePort</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a90d108bebdfeb2310e9a40b66b22f429">retryList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRubyPort.html#a5925f629d4ec58811bba7c4fa6b4d64d">access_phys_mem</a></td></tr>
</table>
<hr/><h2>型定義</h2>
<a class="anchor" id="a0479a75b096e758f414b419c517de782"></a><!-- doxytag: member="RubyPort::CpuPortIter" ref="a0479a75b096e758f414b419c517de782" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="classRubyPort_1_1MemSlavePort.html">MemSlavePort</a> *&gt;::iterator <a class="el" href="classRubyPort.html#a0479a75b096e758f414b419c517de782">CpuPortIter</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Vector of M5 Ports attached to this Ruby port. </p>

</div>
</div>
<a class="anchor" id="a73ffda3b6b10849321fd359baf61eb3c"></a><!-- doxytag: member="RubyPort::Params" ref="a73ffda3b6b10849321fd359baf61eb3c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef RubyPortParams <a class="el" href="classRubyPort.html#a73ffda3b6b10849321fd359baf61eb3c">Params</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classMemObject.html#a905bbc621eeec0ed08859e21c8c95412">MemObject</a>を再定義しています。</p>

<p><a class="el" href="classDMASequencer.html#a9827bc75ea7fc70f8a78d2545226f251">DMASequencer</a>で再定義されています。</p>

</div>
</div>
<hr/><h2>コンストラクタとデストラクタ</h2>
<a class="anchor" id="a48daea2300eda2ed192847716fe85997"></a><!-- doxytag: member="RubyPort::RubyPort" ref="a48daea2300eda2ed192847716fe85997" args="(const Params *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRubyPort.html">RubyPort</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRubyPort.html#a73ffda3b6b10849321fd359baf61eb3c">Params</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00053"></a>00053     : <a class="code" href="classMemObject.html#a0390aa3eb5acd29074fac67b8d6472bd">MemObject</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>), <a class="code" href="classRubyPort.html#a0d6124b18fa39209bf51ec6407fa7c0f">m_version</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;version), <a class="code" href="classRubyPort.html#a1e7049f2cd244dc3944af370eb3e979a">m_controller</a>(<a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>),
<a name="l00054"></a>00054       <a class="code" href="classRubyPort.html#a5bd71d4fde9408a3740efa5d95532c15">m_mandatory_q_ptr</a>(<a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>), <a class="code" href="classRubyPort.html#aad291d9ca2fd5321994e6553b21c530a">m_usingRubyTester</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;using_ruby_tester),
<a name="l00055"></a>00055       <a class="code" href="classRubyPort.html#ae1618ee13262dd22f26a87a3bcb2dca2">pioMasterPort</a>(<a class="code" href="cprintf_8hh.html#ace22d1c39f2df58e593bc49d1613eca2">csprintf</a>(<span class="stringliteral">&quot;%s.pio-master-port&quot;</span>, <a class="code" href="classSimObject.html#adbcff144e5e199d332a1352af1798148">name</a>()), <span class="keyword">this</span>),
<a name="l00056"></a>00056       <a class="code" href="classRubyPort.html#a294b27c7011440b7e24e12afddd75eab">pioSlavePort</a>(<a class="code" href="cprintf_8hh.html#ace22d1c39f2df58e593bc49d1613eca2">csprintf</a>(<span class="stringliteral">&quot;%s.pio-slave-port&quot;</span>, <a class="code" href="classSimObject.html#adbcff144e5e199d332a1352af1798148">name</a>()), <span class="keyword">this</span>),
<a name="l00057"></a>00057       <a class="code" href="classRubyPort.html#ac2c1831a0923d1c83c01f7854d1d707e">memMasterPort</a>(<a class="code" href="cprintf_8hh.html#ace22d1c39f2df58e593bc49d1613eca2">csprintf</a>(<span class="stringliteral">&quot;%s.mem-master-port&quot;</span>, <a class="code" href="classSimObject.html#adbcff144e5e199d332a1352af1798148">name</a>()), <span class="keyword">this</span>),
<a name="l00058"></a>00058       <a class="code" href="classRubyPort.html#a5b8a0b35186f04ce4aeae758f4f0a698">memSlavePort</a>(<a class="code" href="cprintf_8hh.html#ace22d1c39f2df58e593bc49d1613eca2">csprintf</a>(<span class="stringliteral">&quot;%s-mem-slave-port&quot;</span>, <a class="code" href="classSimObject.html#adbcff144e5e199d332a1352af1798148">name</a>()), <span class="keyword">this</span>,
<a name="l00059"></a>00059           <a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;ruby_system, <a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;access_phys_mem, -1),
<a name="l00060"></a>00060       <a class="code" href="classRubyPort.html#a7194bb8c21c2c460cc31ecea9f08b1db">gotAddrRanges</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;port_master_connection_count), <a class="code" href="classRubyPort.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a>(<a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>),
<a name="l00061"></a>00061       <a class="code" href="classRubyPort.html#af27ccd765f13a4b7bd119dc7579e2746">system</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;system), <a class="code" href="classRubyPort.html#a5925f629d4ec58811bba7c4fa6b4d64d">access_phys_mem</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;access_phys_mem)
<a name="l00062"></a>00062 {
<a name="l00063"></a>00063     assert(<a class="code" href="classRubyPort.html#a0d6124b18fa39209bf51ec6407fa7c0f">m_version</a> != -1);
<a name="l00064"></a>00064 
<a name="l00065"></a>00065     <span class="comment">// create the slave ports based on the number of connected ports</span>
<a name="l00066"></a>00066     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> = 0; <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> &lt; <a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;port_slave_connection_count; ++<a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>) {
<a name="l00067"></a>00067         <a class="code" href="classRubyPort.html#ac00171ae3169a04dcc3119647b11711f">slave_ports</a>.push_back(<span class="keyword">new</span> MemSlavePort(<a class="code" href="cprintf_8hh.html#ace22d1c39f2df58e593bc49d1613eca2">csprintf</a>(<span class="stringliteral">&quot;%s.slave%d&quot;</span>, <a class="code" href="classSimObject.html#adbcff144e5e199d332a1352af1798148">name</a>(),
<a name="l00068"></a>00068             <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>), <span class="keyword">this</span>, <a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;ruby_system, <a class="code" href="classRubyPort.html#a5925f629d4ec58811bba7c4fa6b4d64d">access_phys_mem</a>, <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>));
<a name="l00069"></a>00069     }
<a name="l00070"></a>00070 
<a name="l00071"></a>00071     <span class="comment">// create the master ports based on the number of connected ports</span>
<a name="l00072"></a>00072     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> = 0; <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> &lt; <a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;port_master_connection_count; ++<a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>) {
<a name="l00073"></a>00073         <a class="code" href="classRubyPort.html#ac95349e84e36b96125370f0ff8196196">master_ports</a>.push_back(<span class="keyword">new</span> PioMasterPort(<a class="code" href="cprintf_8hh.html#ace22d1c39f2df58e593bc49d1613eca2">csprintf</a>(<span class="stringliteral">&quot;%s.master%d&quot;</span>,
<a name="l00074"></a>00074             <a class="code" href="classSimObject.html#adbcff144e5e199d332a1352af1798148">name</a>(), <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>), <span class="keyword">this</span>));
<a name="l00075"></a>00075     }
<a name="l00076"></a>00076 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab94ca27fbdf091331d2703af1e73d8dc"></a><!-- doxytag: member="RubyPort::~RubyPort" ref="ab94ca27fbdf091331d2703af1e73d8dc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classRubyPort.html">RubyPort</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00144"></a>00144 {}
</pre></div></p>

</div>
</div>
<hr/><h2>関数</h2>
<a class="anchor" id="ad473637152492944180673282ebe71a3"></a><!-- doxytag: member="RubyPort::addToRetryList" ref="ad473637152492944180673282ebe71a3" args="(MemSlavePort *port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addToRetryList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRubyPort_1_1MemSlavePort.html">MemSlavePort</a> *&nbsp;</td>
          <td class="paramname"> <em>port</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00188"></a>00188     {
<a name="l00189"></a>00189         assert(std::find(<a class="code" href="classRubyPort.html#a90d108bebdfeb2310e9a40b66b22f429">retryList</a>.begin(), <a class="code" href="classRubyPort.html#a90d108bebdfeb2310e9a40b66b22f429">retryList</a>.end(), port) ==
<a name="l00190"></a>00190                <a class="code" href="classRubyPort.html#a90d108bebdfeb2310e9a40b66b22f429">retryList</a>.end());
<a name="l00191"></a>00191         <a class="code" href="classRubyPort.html#a90d108bebdfeb2310e9a40b66b22f429">retryList</a>.push_back(port);
<a name="l00192"></a>00192     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae635736b1bd64144a8f1fc5f42948b21"></a><!-- doxytag: member="RubyPort::descheduleDeadlockEvent" ref="ae635736b1bd64144a8f1fc5f42948b21" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void descheduleDeadlockEvent </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classDMASequencer.html#a7c9a8861621a62055761f47310814762">DMASequencer</a>, と <a class="el" href="classRubyPortProxy.html#a7c9a8861621a62055761f47310814762">RubyPortProxy</a>で実装されています。</p>

</div>
</div>
<a class="anchor" id="aa8a18d230dba7a674ac8a0b4f35bc36a"></a><!-- doxytag: member="RubyPort::drain" ref="aa8a18d230dba7a674ac8a0b4f35bc36a" args="(DrainManager *dm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int drain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDrainManager.html">DrainManager</a> *&nbsp;</td>
          <td class="paramname"> <em>drainManger</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Provide a default implementation of the drain interface that simply returns 0 (draining completed) and sets the drain state to Drained. </p>

<p><a class="el" href="classSimObject.html#a6bf479c521c7c3eb473822d953275b26">SimObject</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00420"></a>00420 {
<a name="l00421"></a>00421     <span class="keywordflow">if</span> (<a class="code" href="classRubyPort.html#a24d37c70faaaf126b544c2d46ea70ce2">isDeadlockEventScheduled</a>()) {
<a name="l00422"></a>00422         <a class="code" href="classRubyPort.html#ae635736b1bd64144a8f1fc5f42948b21">descheduleDeadlockEvent</a>();
<a name="l00423"></a>00423     }
<a name="l00424"></a>00424 
<a name="l00425"></a>00425     <span class="comment">//</span>
<a name="l00426"></a>00426     <span class="comment">// If the RubyPort is not empty, then it needs to clear all outstanding</span>
<a name="l00427"></a>00427     <span class="comment">// requests before it should call drainManager-&gt;signalDrainDone()</span>
<a name="l00428"></a>00428     <span class="comment">//</span>
<a name="l00429"></a>00429     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Config, <span class="stringliteral">&quot;outstanding count %d\n&quot;</span>, <a class="code" href="classRubyPort.html#a366b0b3d8b8a08b7066f1b98c1b40b85">outstandingCount</a>());
<a name="l00430"></a>00430     <span class="keywordtype">bool</span> need_drain = <a class="code" href="classRubyPort.html#a366b0b3d8b8a08b7066f1b98c1b40b85">outstandingCount</a>() &gt; 0;
<a name="l00431"></a>00431 
<a name="l00432"></a>00432     <span class="comment">//</span>
<a name="l00433"></a>00433     <span class="comment">// Also, get the number of child ports that will also need to clear</span>
<a name="l00434"></a>00434     <span class="comment">// their buffered requests before they call drainManager-&gt;signalDrainDone()</span>
<a name="l00435"></a>00435     <span class="comment">//</span>
<a name="l00436"></a>00436     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> child_drain_count = <a class="code" href="classRubyPort.html#a6497fe5e5b0476effb15db9118962e93">getChildDrainCount</a>(<a class="code" href="namespaceMipsISA.html#a2575c29e7f4617b6076486f340b6fe19">dm</a>);
<a name="l00437"></a>00437 
<a name="l00438"></a>00438     <span class="comment">// Set status</span>
<a name="l00439"></a>00439     <span class="keywordflow">if</span> (need_drain) {
<a name="l00440"></a>00440         <a class="code" href="classRubyPort.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a> = <a class="code" href="namespaceMipsISA.html#a2575c29e7f4617b6076486f340b6fe19">dm</a>;
<a name="l00441"></a>00441 
<a name="l00442"></a>00442         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;RubyPort not drained\n&quot;</span>);
<a name="l00443"></a>00443         <a class="code" href="classDrainable.html#ad800905390fe03e850cf996e914038f9">setDrainState</a>(<a class="code" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8a929d17847bfad0d4689c9ab8540d5134">Drainable::Draining</a>);
<a name="l00444"></a>00444         <span class="keywordflow">return</span> child_drain_count + 1;
<a name="l00445"></a>00445     }
<a name="l00446"></a>00446 
<a name="l00447"></a>00447     <a class="code" href="classRubyPort.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a> = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00448"></a>00448     <a class="code" href="classDrainable.html#ad800905390fe03e850cf996e914038f9">setDrainState</a>(<a class="code" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8a5656955cb808502a2ec75b367e2c1e82">Drainable::Drained</a>);
<a name="l00449"></a>00449     <span class="keywordflow">return</span> child_drain_count;
<a name="l00450"></a>00450 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6497fe5e5b0476effb15db9118962e93"></a><!-- doxytag: member="RubyPort::getChildDrainCount" ref="a6497fe5e5b0476effb15db9118962e93" args="(DrainManager *dm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int getChildDrainCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDrainManager.html">DrainManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dm</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00395"></a>00395 {
<a name="l00396"></a>00396     <span class="keywordtype">int</span> <a class="code" href="namespaceX86ISA.html#a668f84c330035fdb72824eb18e09cd09">count</a> = 0;
<a name="l00397"></a>00397 
<a name="l00398"></a>00398     <span class="keywordflow">if</span> (<a class="code" href="classRubyPort.html#ac2c1831a0923d1c83c01f7854d1d707e">memMasterPort</a>.<a class="code" href="classBaseMasterPort.html#a180fa55a4bf36580963bed9e3e09c227">isConnected</a>()) {
<a name="l00399"></a>00399         count += <a class="code" href="classRubyPort.html#ac2c1831a0923d1c83c01f7854d1d707e">memMasterPort</a>.<a class="code" href="classQueuedMasterPort.html#aa8a18d230dba7a674ac8a0b4f35bc36a">drain</a>(dm);
<a name="l00400"></a>00400         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Config, <span class="stringliteral">&quot;count after pio check %d\n&quot;</span>, count);
<a name="l00401"></a>00401     }
<a name="l00402"></a>00402 
<a name="l00403"></a>00403     <span class="keywordflow">for</span> (<a class="code" href="classRubyPort.html#a0479a75b096e758f414b419c517de782">CpuPortIter</a> <a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a> = <a class="code" href="classRubyPort.html#ac00171ae3169a04dcc3119647b11711f">slave_ports</a>.begin(); <a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a> != <a class="code" href="classRubyPort.html#ac00171ae3169a04dcc3119647b11711f">slave_ports</a>.end(); ++<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>) {
<a name="l00404"></a>00404         count += (*p)-&gt;drain(dm);
<a name="l00405"></a>00405         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Config, <span class="stringliteral">&quot;count after slave port check %d\n&quot;</span>, count);
<a name="l00406"></a>00406     }
<a name="l00407"></a>00407 
<a name="l00408"></a>00408     <span class="keywordflow">for</span> (<a class="code" href="classstd_1_1vector.html">std::vector&lt;PioMasterPort *&gt;::iterator</a> <a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a> = <a class="code" href="classRubyPort.html#ac95349e84e36b96125370f0ff8196196">master_ports</a>.begin();
<a name="l00409"></a>00409          <a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a> != <a class="code" href="classRubyPort.html#ac95349e84e36b96125370f0ff8196196">master_ports</a>.end(); ++<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>) {
<a name="l00410"></a>00410         count += (*p)-&gt;drain(dm);
<a name="l00411"></a>00411         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Config, <span class="stringliteral">&quot;count after master port check %d\n&quot;</span>, count);
<a name="l00412"></a>00412     }
<a name="l00413"></a>00413 
<a name="l00414"></a>00414     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Config, <span class="stringliteral">&quot;final count %d\n&quot;</span>, count);
<a name="l00415"></a>00415     <span class="keywordflow">return</span> count;
<a name="l00416"></a>00416 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0394d0753edf9da729ce700f110f650c"></a><!-- doxytag: member="RubyPort::getId" ref="a0394d0753edf9da729ce700f110f650c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> getId </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00163"></a>00163 { <span class="keywordflow">return</span> <a class="code" href="classRubyPort.html#a0d6124b18fa39209bf51ec6407fa7c0f">m_version</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="adc4e675e51defbdd1e354dac729d0703"></a><!-- doxytag: member="RubyPort::getMasterPort" ref="adc4e675e51defbdd1e354dac729d0703" args="(const std::string &amp;if_name, PortID idx=InvalidPortID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBaseMasterPort.html">BaseMasterPort</a> &amp; getMasterPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>if_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#acef4d7d41cb21fdc252e20c04cd7bb8e">PortID</a>&nbsp;</td>
          <td class="paramname"> <em>idx</em> = <code><a class="el" href="base_2types_8hh.html#a65bf40f138cf863f0c5e2d8ca1144126">InvalidPortID</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a master port with a given name and index. This is used at binding time and returns a reference to a protocol-agnostic base master port.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>if_name</em>&nbsp;</td><td><a class="el" href="classPort.html">Port</a> name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idx</em>&nbsp;</td><td>Index in the case of a VectorPort</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>A reference to the given port </dd></dl>

<p><a class="el" href="classMemObject.html#adc4e675e51defbdd1e354dac729d0703">MemObject</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00088"></a>00088 {
<a name="l00089"></a>00089     <span class="keywordflow">if</span> (if_name == <span class="stringliteral">&quot;mem_master_port&quot;</span>) {
<a name="l00090"></a>00090         <span class="keywordflow">return</span> <a class="code" href="classRubyPort.html#ac2c1831a0923d1c83c01f7854d1d707e">memMasterPort</a>;
<a name="l00091"></a>00091     }
<a name="l00092"></a>00092 
<a name="l00093"></a>00093     <span class="keywordflow">if</span> (if_name == <span class="stringliteral">&quot;pio_master_port&quot;</span>) {
<a name="l00094"></a>00094         <span class="keywordflow">return</span> <a class="code" href="classRubyPort.html#ae1618ee13262dd22f26a87a3bcb2dca2">pioMasterPort</a>;
<a name="l00095"></a>00095     }
<a name="l00096"></a>00096 
<a name="l00097"></a>00097     <span class="comment">// used by the x86 CPUs to connect the interrupt PIO and interrupt slave</span>
<a name="l00098"></a>00098     <span class="comment">// port</span>
<a name="l00099"></a>00099     <span class="keywordflow">if</span> (if_name != <span class="stringliteral">&quot;master&quot;</span>) {
<a name="l00100"></a>00100         <span class="comment">// pass it along to our super class</span>
<a name="l00101"></a>00101         <span class="keywordflow">return</span> <a class="code" href="classRubyPort.html#adc4e675e51defbdd1e354dac729d0703">MemObject::getMasterPort</a>(if_name, idx);
<a name="l00102"></a>00102     } <span class="keywordflow">else</span> {
<a name="l00103"></a>00103         <span class="keywordflow">if</span> (idx &gt;= static_cast&lt;PortID&gt;(<a class="code" href="classRubyPort.html#ac95349e84e36b96125370f0ff8196196">master_ports</a>.size())) {
<a name="l00104"></a>00104             <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;RubyPort::getMasterPort: unknown index %d\n&quot;</span>, idx);
<a name="l00105"></a>00105         }
<a name="l00106"></a>00106 
<a name="l00107"></a>00107         <span class="keywordflow">return</span> *<a class="code" href="classRubyPort.html#ac95349e84e36b96125370f0ff8196196">master_ports</a>[idx];
<a name="l00108"></a>00108     }
<a name="l00109"></a>00109 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac918a145092d7514ebc6dbd952dceafb"></a><!-- doxytag: member="RubyPort::getSlavePort" ref="ac918a145092d7514ebc6dbd952dceafb" args="(const std::string &amp;if_name, PortID idx=InvalidPortID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBaseSlavePort.html">BaseSlavePort</a> &amp; getSlavePort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>if_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#acef4d7d41cb21fdc252e20c04cd7bb8e">PortID</a>&nbsp;</td>
          <td class="paramname"> <em>idx</em> = <code><a class="el" href="base_2types_8hh.html#a65bf40f138cf863f0c5e2d8ca1144126">InvalidPortID</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a slave port with a given name and index. This is used at binding time and returns a reference to a protocol-agnostic base master port.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>if_name</em>&nbsp;</td><td><a class="el" href="classPort.html">Port</a> name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idx</em>&nbsp;</td><td>Index in the case of a VectorPort</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>A reference to the given port </dd></dl>

<p><a class="el" href="classMemObject.html#ac918a145092d7514ebc6dbd952dceafb">MemObject</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00113"></a>00113 {
<a name="l00114"></a>00114     <span class="keywordflow">if</span> (if_name == <span class="stringliteral">&quot;mem_slave_port&quot;</span>) {
<a name="l00115"></a>00115         <span class="keywordflow">return</span> <a class="code" href="classRubyPort.html#a5b8a0b35186f04ce4aeae758f4f0a698">memSlavePort</a>;
<a name="l00116"></a>00116     }
<a name="l00117"></a>00117 
<a name="l00118"></a>00118     <span class="keywordflow">if</span> (if_name == <span class="stringliteral">&quot;pio_slave_port&quot;</span>)
<a name="l00119"></a>00119         <span class="keywordflow">return</span> <a class="code" href="classRubyPort.html#a294b27c7011440b7e24e12afddd75eab">pioSlavePort</a>;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121     <span class="comment">// used by the CPUs to connect the caches to the interconnect, and</span>
<a name="l00122"></a>00122     <span class="comment">// for the x86 case also the interrupt master</span>
<a name="l00123"></a>00123     <span class="keywordflow">if</span> (if_name != <span class="stringliteral">&quot;slave&quot;</span>) {
<a name="l00124"></a>00124         <span class="comment">// pass it along to our super class</span>
<a name="l00125"></a>00125         <span class="keywordflow">return</span> <a class="code" href="classRubyPort.html#ac918a145092d7514ebc6dbd952dceafb">MemObject::getSlavePort</a>(if_name, idx);
<a name="l00126"></a>00126     } <span class="keywordflow">else</span> {
<a name="l00127"></a>00127         <span class="keywordflow">if</span> (idx &gt;= static_cast&lt;PortID&gt;(<a class="code" href="classRubyPort.html#ac00171ae3169a04dcc3119647b11711f">slave_ports</a>.size())) {
<a name="l00128"></a>00128             <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;RubyPort::getSlavePort: unknown index %d\n&quot;</span>, idx);
<a name="l00129"></a>00129         }
<a name="l00130"></a>00130 
<a name="l00131"></a>00131         <span class="keywordflow">return</span> *<a class="code" href="classRubyPort.html#ac00171ae3169a04dcc3119647b11711f">slave_ports</a>[idx];
<a name="l00132"></a>00132     }
<a name="l00133"></a>00133 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a02fd73d861ef2e4aabb38c0c9ff82947"></a><!-- doxytag: member="RubyPort::init" ref="a02fd73d861ef2e4aabb38c0c9ff82947" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classRubyPort.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected <a class="el" href="classSimObject.html">SimObject</a> graph should be done here. </p>

<p><a class="el" href="classSimObject.html#a02fd73d861ef2e4aabb38c0c9ff82947">SimObject</a>を再定義しています。</p>

<p><a class="el" href="classDMASequencer.html#a02fd73d861ef2e4aabb38c0c9ff82947">DMASequencer</a>, と <a class="el" href="classRubyPortProxy.html#a02fd73d861ef2e4aabb38c0c9ff82947">RubyPortProxy</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00080"></a>00080 {
<a name="l00081"></a>00081     assert(<a class="code" href="classRubyPort.html#a1e7049f2cd244dc3944af370eb3e979a">m_controller</a> != <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>);
<a name="l00082"></a>00082     <a class="code" href="classRubyPort.html#a5bd71d4fde9408a3740efa5d95532c15">m_mandatory_q_ptr</a> = <a class="code" href="classRubyPort.html#a1e7049f2cd244dc3944af370eb3e979a">m_controller</a>-&gt;<a class="code" href="classAbstractController.html#a80b4b6fca935f6914fd15ea5715e2170">getMandatoryQueue</a>();
<a name="l00083"></a>00083     <a class="code" href="classRubyPort.html#a5bd71d4fde9408a3740efa5d95532c15">m_mandatory_q_ptr</a>-&gt;<a class="code" href="classMessageBuffer.html#a0a949993188bb0d51b80b714be944447">setSender</a>(<span class="keyword">this</span>);
<a name="l00084"></a>00084 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a24d37c70faaaf126b544c2d46ea70ce2"></a><!-- doxytag: member="RubyPort::isDeadlockEventScheduled" ref="a24d37c70faaaf126b544c2d46ea70ce2" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool isDeadlockEventScheduled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classDMASequencer.html#a11ce018fbd3aa89624b06dbdafbd4ef9">DMASequencer</a>, と <a class="el" href="classRubyPortProxy.html#a11ce018fbd3aa89624b06dbdafbd4ef9">RubyPortProxy</a>で実装されています。</p>

</div>
</div>
<a class="anchor" id="a596adbddbc1059f06e3989f743f2ed3e"></a><!-- doxytag: member="RubyPort::makeRequest" ref="a596adbddbc1059f06e3989f743f2ed3e" args="(PacketPtr pkt)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual RequestStatus makeRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classDMASequencer.html#a23de6e3fbb2362f4410d435e3600d0f7">DMASequencer</a>, と <a class="el" href="classRubyPortProxy.html#a23de6e3fbb2362f4410d435e3600d0f7">RubyPortProxy</a>で実装されています。</p>

</div>
</div>
<a class="anchor" id="a366b0b3d8b8a08b7066f1b98c1b40b85"></a><!-- doxytag: member="RubyPort::outstandingCount" ref="a366b0b3d8b8a08b7066f1b98c1b40b85" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int outstandingCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classDMASequencer.html#ae47593dc86baa86bf047ad1fbcdcceed">DMASequencer</a>, と <a class="el" href="classRubyPortProxy.html#ae47593dc86baa86bf047ad1fbcdcceed">RubyPortProxy</a>で実装されています。</p>

</div>
</div>
<a class="anchor" id="a47ba09f9a3b3998cac9c14ab596a7515"></a><!-- doxytag: member="RubyPort::recvTimingResp" ref="a47ba09f9a3b3998cac9c14ab596a7515" args="(PacketPtr pkt, PortID master_port_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool recvTimingResp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#acef4d7d41cb21fdc252e20c04cd7bb8e">PortID</a>&nbsp;</td>
          <td class="paramname"> <em>master_port_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called by the PIO port when receiving a timing response.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td>Response packet </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>master_port_id</em>&nbsp;</td><td><a class="el" href="classPort.html">Port</a> id of the PIO port</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Whether successfully sent </dd></dl>

</div>
</div>
<a class="anchor" id="ac3858f72631784d3e09bba9070f96349"></a><!-- doxytag: member="RubyPort::ruby_eviction_callback" ref="ac3858f72631784d3e09bba9070f96349" args="(const Address &amp;address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ruby_eviction_callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00538"></a>00538 {
<a name="l00539"></a>00539     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classRubyPort.html">RubyPort</a>, <span class="stringliteral">&quot;Sending invalidations.\n&quot;</span>);
<a name="l00540"></a>00540     <span class="comment">// This request is deleted in the stack-allocated packet destructor</span>
<a name="l00541"></a>00541     <span class="comment">// when this function exits</span>
<a name="l00542"></a>00542     <span class="comment">// TODO: should this really be using funcMasterId?</span>
<a name="l00543"></a>00543     <a class="code" href="classRequest.html">RequestPtr</a> req =
<a name="l00544"></a>00544             <span class="keyword">new</span> <a class="code" href="classRequest.html">Request</a>(address.<a class="code" href="classAddress.html#aa5c44fe637d09a708d70c4a689840cd0">getAddress</a>(), 0, 0, <a class="code" href="classRequest.html#a2d69ed2b2928ccd91cc225b403200c4e">Request::funcMasterId</a>);
<a name="l00545"></a>00545     <span class="comment">// Use a single packet to signal all snooping ports of the invalidation.</span>
<a name="l00546"></a>00546     <span class="comment">// This assumes that snooping ports do NOT modify the packet/request</span>
<a name="l00547"></a>00547     <a class="code" href="classPacket.html">Packet</a> pkt(req, <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153ab11e33949db36f4cccb8949d7a971a76">MemCmd::InvalidationReq</a>);
<a name="l00548"></a>00548     <span class="keywordflow">for</span> (<a class="code" href="classRubyPort.html#a0479a75b096e758f414b419c517de782">CpuPortIter</a> <a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a> = <a class="code" href="classRubyPort.html#ac00171ae3169a04dcc3119647b11711f">slave_ports</a>.begin(); <a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a> != <a class="code" href="classRubyPort.html#ac00171ae3169a04dcc3119647b11711f">slave_ports</a>.end(); ++<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>) {
<a name="l00549"></a>00549         <span class="comment">// check if the connected master port is snooping</span>
<a name="l00550"></a>00550         <span class="keywordflow">if</span> ((*p)-&gt;isSnooping()) {
<a name="l00551"></a>00551             <span class="comment">// send as a snoop request</span>
<a name="l00552"></a>00552             (*p)-&gt;sendTimingSnoopReq(&amp;pkt);
<a name="l00553"></a>00553         }
<a name="l00554"></a>00554     }
<a name="l00555"></a>00555 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa8ad1a5d600c338dcd76fcf434f3169e"></a><!-- doxytag: member="RubyPort::ruby_hit_callback" ref="aa8ad1a5d600c338dcd76fcf434f3169e" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ruby_hit_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00335"></a>00335 {
<a name="l00336"></a>00336     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classRubyPort.html">RubyPort</a>, <span class="stringliteral">&quot;Hit callback for %s 0x%x\n&quot;</span>, pkt-&gt;<a class="code" href="classPacket.html#a863af57e28a01258236ea303155fc7ff">cmdString</a>(),
<a name="l00337"></a>00337             pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>());
<a name="l00338"></a>00338 
<a name="l00339"></a>00339     <span class="comment">// The packet was destined for memory and has not yet been turned</span>
<a name="l00340"></a>00340     <span class="comment">// into a response</span>
<a name="l00341"></a>00341     assert(<a class="code" href="classRubyPort.html#af27ccd765f13a4b7bd119dc7579e2746">system</a>-&gt;<a class="code" href="classSystem.html#a0faeadf06436f8123c7bda01087bb222">isMemAddr</a>(pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>()));
<a name="l00342"></a>00342     assert(pkt-&gt;<a class="code" href="classPacket.html#af21986d725d75fa8e1b6c83457cd4501">isRequest</a>());
<a name="l00343"></a>00343 
<a name="l00344"></a>00344     <span class="comment">// As it has not yet been turned around, the source field tells us</span>
<a name="l00345"></a>00345     <span class="comment">// which port it came from.</span>
<a name="l00346"></a>00346     assert(pkt-&gt;<a class="code" href="classPacket.html#a6ac1bab8f0db56da42ee3359c3aef5dc" title="Accessor function to get the source index of the packet.">getSrc</a>() &lt; <a class="code" href="classRubyPort.html#ac00171ae3169a04dcc3119647b11711f">slave_ports</a>.size());
<a name="l00347"></a>00347 
<a name="l00348"></a>00348     <a class="code" href="classRubyPort.html#ac00171ae3169a04dcc3119647b11711f">slave_ports</a>[pkt-&gt;<a class="code" href="classPacket.html#a6ac1bab8f0db56da42ee3359c3aef5dc" title="Accessor function to get the source index of the packet.">getSrc</a>()]-&gt;hitCallback(pkt);
<a name="l00349"></a>00349 
<a name="l00350"></a>00350     <span class="comment">//</span>
<a name="l00351"></a>00351     <span class="comment">// If we had to stall the MemSlavePorts, wake them up because the sequencer</span>
<a name="l00352"></a>00352     <span class="comment">// likely has free resources now.</span>
<a name="l00353"></a>00353     <span class="comment">//</span>
<a name="l00354"></a>00354     <span class="keywordflow">if</span> (!<a class="code" href="classRubyPort.html#a90d108bebdfeb2310e9a40b66b22f429">retryList</a>.empty()) {
<a name="l00355"></a>00355         <span class="comment">//</span>
<a name="l00356"></a>00356         <span class="comment">// Record the current list of ports to retry on a temporary list before</span>
<a name="l00357"></a>00357         <span class="comment">// calling sendRetry on those ports.  sendRetry will cause an </span>
<a name="l00358"></a>00358         <span class="comment">// immediate retry, which may result in the ports being put back on the</span>
<a name="l00359"></a>00359         <span class="comment">// list. Therefore we want to clear the retryList before calling</span>
<a name="l00360"></a>00360         <span class="comment">// sendRetry.</span>
<a name="l00361"></a>00361         <span class="comment">//</span>
<a name="l00362"></a>00362         <a class="code" href="classstd_1_1vector.html">std::vector&lt;MemSlavePort *&gt;</a> curRetryList(<a class="code" href="classRubyPort.html#a90d108bebdfeb2310e9a40b66b22f429">retryList</a>);
<a name="l00363"></a>00363 
<a name="l00364"></a>00364         <a class="code" href="classRubyPort.html#a90d108bebdfeb2310e9a40b66b22f429">retryList</a>.clear();
<a name="l00365"></a>00365 
<a name="l00366"></a>00366         <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> = curRetryList.begin(); <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> != curRetryList.end(); ++<a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>) {
<a name="l00367"></a>00367             <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classRubyPort.html">RubyPort</a>,
<a name="l00368"></a>00368                     <span class="stringliteral">&quot;Sequencer may now be free.  SendRetry to port %s\n&quot;</span>,
<a name="l00369"></a>00369                     (*i)-&gt;name());
<a name="l00370"></a>00370             (*i)-&gt;sendRetry();
<a name="l00371"></a>00371         }
<a name="l00372"></a>00372     }
<a name="l00373"></a>00373 
<a name="l00374"></a>00374     <a class="code" href="classRubyPort.html#ada43967d9f25e87e20fa808ff7d88a89">testDrainComplete</a>();
<a name="l00375"></a>00375 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0768dd0d813b0d71fd45a5deb1bd0294"></a><!-- doxytag: member="RubyPort::setController" ref="a0768dd0d813b0d71fd45a5deb1bd0294" args="(AbstractController *_cntrl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setController </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAbstractController.html">AbstractController</a> *&nbsp;</td>
          <td class="paramname"> <em>_cntrl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00162"></a>00162 { <a class="code" href="classRubyPort.html#a1e7049f2cd244dc3944af370eb3e979a">m_controller</a> = _cntrl; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ada43967d9f25e87e20fa808ff7d88a89"></a><!-- doxytag: member="RubyPort::testDrainComplete" ref="ada43967d9f25e87e20fa808ff7d88a89" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void testDrainComplete </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00379"></a>00379 {
<a name="l00380"></a>00380     <span class="comment">//If we weren&apos;t able to drain before, we might be able to now.</span>
<a name="l00381"></a>00381     <span class="keywordflow">if</span> (<a class="code" href="classRubyPort.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a> != <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>) {
<a name="l00382"></a>00382         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> drainCount = <a class="code" href="classRubyPort.html#a366b0b3d8b8a08b7066f1b98c1b40b85">outstandingCount</a>();
<a name="l00383"></a>00383         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;Drain count: %u\n&quot;</span>, drainCount);
<a name="l00384"></a>00384         <span class="keywordflow">if</span> (drainCount == 0) {
<a name="l00385"></a>00385             <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;RubyPort done draining, signaling drain done\n&quot;</span>);
<a name="l00386"></a>00386             <a class="code" href="classRubyPort.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a>-&gt;<a class="code" href="classDrainManager.html#ab89d10e368d2e82061eddb9e40022382">signalDrainDone</a>();
<a name="l00387"></a>00387             <span class="comment">// Clear the drain manager once we&apos;re done with it.</span>
<a name="l00388"></a>00388             <a class="code" href="classRubyPort.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a> = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00389"></a>00389         }
<a name="l00390"></a>00390     }
<a name="l00391"></a>00391 }
</pre></div></p>

</div>
</div>
<hr/><h2>変数</h2>
<a class="anchor" id="a5925f629d4ec58811bba7c4fa6b4d64d"></a><!-- doxytag: member="RubyPort::access_phys_mem" ref="a5925f629d4ec58811bba7c4fa6b4d64d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRubyPort.html#a5925f629d4ec58811bba7c4fa6b4d64d">access_phys_mem</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a329b71fb934a93312ca0aacbf5a3f982"></a><!-- doxytag: member="RubyPort::drainManager" ref="a329b71fb934a93312ca0aacbf5a3f982" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDrainManager.html">DrainManager</a>* <a class="el" href="classRubyPort.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7194bb8c21c2c460cc31ecea9f08b1db"></a><!-- doxytag: member="RubyPort::gotAddrRanges" ref="a7194bb8c21c2c460cc31ecea9f08b1db" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classRubyPort.html#a7194bb8c21c2c460cc31ecea9f08b1db">gotAddrRanges</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1e7049f2cd244dc3944af370eb3e979a"></a><!-- doxytag: member="RubyPort::m_controller" ref="a1e7049f2cd244dc3944af370eb3e979a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAbstractController.html">AbstractController</a>* <a class="el" href="classRubyPort.html#a1e7049f2cd244dc3944af370eb3e979a">m_controller</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5bd71d4fde9408a3740efa5d95532c15"></a><!-- doxytag: member="RubyPort::m_mandatory_q_ptr" ref="a5bd71d4fde9408a3740efa5d95532c15" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMessageBuffer.html">MessageBuffer</a>* <a class="el" href="classRubyPort.html#a5bd71d4fde9408a3740efa5d95532c15">m_mandatory_q_ptr</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aad291d9ca2fd5321994e6553b21c530a"></a><!-- doxytag: member="RubyPort::m_usingRubyTester" ref="aad291d9ca2fd5321994e6553b21c530a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRubyPort.html#aad291d9ca2fd5321994e6553b21c530a">m_usingRubyTester</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0d6124b18fa39209bf51ec6407fa7c0f"></a><!-- doxytag: member="RubyPort::m_version" ref="a0d6124b18fa39209bf51ec6407fa7c0f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> <a class="el" href="classRubyPort.html#a0d6124b18fa39209bf51ec6407fa7c0f">m_version</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac95349e84e36b96125370f0ff8196196"></a><!-- doxytag: member="RubyPort::master_ports" ref="ac95349e84e36b96125370f0ff8196196" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="classRubyPort_1_1PioMasterPort.html">PioMasterPort</a> *&gt; <a class="el" href="classRubyPort.html#ac95349e84e36b96125370f0ff8196196">master_ports</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac2c1831a0923d1c83c01f7854d1d707e"></a><!-- doxytag: member="RubyPort::memMasterPort" ref="ac2c1831a0923d1c83c01f7854d1d707e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRubyPort_1_1MemMasterPort.html">MemMasterPort</a> <a class="el" href="classRubyPort.html#ac2c1831a0923d1c83c01f7854d1d707e">memMasterPort</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5b8a0b35186f04ce4aeae758f4f0a698"></a><!-- doxytag: member="RubyPort::memSlavePort" ref="a5b8a0b35186f04ce4aeae758f4f0a698" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRubyPort_1_1MemSlavePort.html">MemSlavePort</a> <a class="el" href="classRubyPort.html#a5b8a0b35186f04ce4aeae758f4f0a698">memSlavePort</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae1618ee13262dd22f26a87a3bcb2dca2"></a><!-- doxytag: member="RubyPort::pioMasterPort" ref="ae1618ee13262dd22f26a87a3bcb2dca2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRubyPort_1_1PioMasterPort.html">PioMasterPort</a> <a class="el" href="classRubyPort.html#ae1618ee13262dd22f26a87a3bcb2dca2">pioMasterPort</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a294b27c7011440b7e24e12afddd75eab"></a><!-- doxytag: member="RubyPort::pioSlavePort" ref="a294b27c7011440b7e24e12afddd75eab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRubyPort_1_1PioSlavePort.html">PioSlavePort</a> <a class="el" href="classRubyPort.html#a294b27c7011440b7e24e12afddd75eab">pioSlavePort</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a90d108bebdfeb2310e9a40b66b22f429"></a><!-- doxytag: member="RubyPort::retryList" ref="a90d108bebdfeb2310e9a40b66b22f429" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="classRubyPort_1_1MemSlavePort.html">MemSlavePort</a> *&gt; <a class="el" href="classRubyPort.html#a90d108bebdfeb2310e9a40b66b22f429">retryList</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac00171ae3169a04dcc3119647b11711f"></a><!-- doxytag: member="RubyPort::slave_ports" ref="ac00171ae3169a04dcc3119647b11711f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="classRubyPort_1_1MemSlavePort.html">MemSlavePort</a> *&gt; <a class="el" href="classRubyPort.html#ac00171ae3169a04dcc3119647b11711f">slave_ports</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af27ccd765f13a4b7bd119dc7579e2746"></a><!-- doxytag: member="RubyPort::system" ref="af27ccd765f13a4b7bd119dc7579e2746" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSystem.html">System</a>* <a class="el" href="classRubyPort.html#af27ccd765f13a4b7bd119dc7579e2746">system</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>このクラスの説明は次のファイルから生成されました:<ul>
<li>mem/ruby/system/<a class="el" href="RubyPort_8hh_source.html">RubyPort.hh</a></li>
<li>mem/ruby/system/<a class="el" href="RubyPort_8cc.html">RubyPort.cc</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>File&nbsp;GEM5&nbsp;Wrapperに対して25 May 2015に生成されました。&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
