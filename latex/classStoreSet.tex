\hypertarget{classStoreSet}{
\section{クラス StoreSet}
\label{classStoreSet}\index{StoreSet@{StoreSet}}
}


{\ttfamily \#include $<$store\_\-set.hh$>$}\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef unsigned \hyperlink{classStoreSet_a3cffbd955ca25d7d74d98168c6ea2404}{SSID}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classStoreSet_ab4658accf641bb529cfd0d8a86ac1985}{StoreSet} ()
\item 
\hyperlink{classStoreSet_a31e067a1c435ba8158c230dfe3348839}{StoreSet} (uint64\_\-t clear\_\-period, int SSIT\_\-size, int LFST\_\-size)
\item 
\hyperlink{classStoreSet_a7e8dc54e3df2141367927871901e6152}{$\sim$StoreSet} ()
\item 
void \hyperlink{classStoreSet_a4976b4794b30eada21534d7238044c68}{init} (uint64\_\-t clear\_\-period, int SSIT\_\-size, int LFST\_\-size)
\item 
void \hyperlink{classStoreSet_a28e9d2d8a7a8df645736800101f56517}{violation} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} store\_\-PC, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} load\_\-PC)
\item 
void \hyperlink{classStoreSet_a4dab67311167cad2367beac85376a3bc}{checkClear} ()
\item 
void \hyperlink{classStoreSet_a205cc846bfa1f976cf2ca9f4bd0fd226}{insertLoad} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} load\_\-PC, \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} load\_\-seq\_\-num)
\item 
void \hyperlink{classStoreSet_ab879063d4bfe2e1c91025715007bfecb}{insertStore} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} store\_\-PC, \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} store\_\-seq\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classStoreSet_ae8d309615668a58409f29cc73457c7c9}{checkInst} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} PC)
\item 
void \hyperlink{classStoreSet_a2c9204930bc1f40dfe7451a29a6b8d8d}{issued} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} issued\_\-PC, \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} issued\_\-seq\_\-num, bool is\_\-store)
\item 
void \hyperlink{classStoreSet_a7ff20e53cb9b14b1794a656def08f910}{squash} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} squashed\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classStoreSet_ac8bb3912a3ce86b15842e79d0b421204}{clear} ()
\item 
void \hyperlink{classStoreSet_accd2600060dbaee3a3b41aed4034c63c}{dump} ()
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef std::map$<$ \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum}, int, \hyperlink{structltseqnum}{ltseqnum} $>$::iterator \hyperlink{classStoreSet_afaca5122d48a680d2adb3b6f841528eb}{SeqNumMapIt}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classStoreSet_aeabab6ef1f2a8e942739203158d70041}{calcIndex} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} PC)
\item 
\hyperlink{classStoreSet_a3cffbd955ca25d7d74d98168c6ea2404}{SSID} \hyperlink{classStoreSet_a6b9767a09067554b634a93c4454fa136}{calcSSID} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} PC)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classStoreSet_a3cffbd955ca25d7d74d98168c6ea2404}{SSID} $>$ \hyperlink{classStoreSet_a5c8ed73b9517db1737e7164d1db20154}{SSIT}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ bool $>$ \hyperlink{classStoreSet_ae026c336a6a2761ace6e098304dda75f}{validSSIT}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} $>$ \hyperlink{classStoreSet_a8f418b57f9abc868817afd8026effc89}{LFST}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ bool $>$ \hyperlink{classStoreSet_aa0bec890135b0b249993f12f80634c07}{validLFST}
\item 
std::map$<$ \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum}, int, \hyperlink{structltseqnum}{ltseqnum} $>$ \hyperlink{classStoreSet_a641f6adef35ba24d36e194842e0650b2}{storeList}
\item 
uint64\_\-t \hyperlink{classStoreSet_a9ae4231099a7cc00dcbf234aa174af44}{clearPeriod}
\item 
int \hyperlink{classStoreSet_acd4dabf4d426240afbd79129f8484945}{SSITSize}
\item 
int \hyperlink{classStoreSet_a8ff9a6f977f155a663ce56418b68e9cd}{LFSTSize}
\item 
int \hyperlink{classStoreSet_a33e6f6648561ce74ee753dd190356fd0}{indexMask}
\item 
int \hyperlink{classStoreSet_a44788461daa83a3b9b3da3fd39d54f31}{offsetBits}
\item 
int \hyperlink{classStoreSet_aa51123e118112a84b5139b216be38d8f}{memOpsPred}
\end{DoxyCompactItemize}


\subsection{説明}
Implements a store set predictor for determining if memory instructions are dependent upon each other. See paper \char`\"{}Memory
 Dependence Prediction using Store Sets\char`\"{} by Chrysos and Emer. SSID stands for Store \hyperlink{classSet}{Set} ID, SSIT stands for Store \hyperlink{classSet}{Set} ID Table, and LFST is Last Fetched Store Table. 

\subsection{型定義}
\hypertarget{classStoreSet_afaca5122d48a680d2adb3b6f841528eb}{
\index{StoreSet@{StoreSet}!SeqNumMapIt@{SeqNumMapIt}}
\index{SeqNumMapIt@{SeqNumMapIt}!StoreSet@{StoreSet}}
\subsubsection[{SeqNumMapIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef std::map$<${\bf InstSeqNum}, int, {\bf ltseqnum}$>$::iterator {\bf SeqNumMapIt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classStoreSet_afaca5122d48a680d2adb3b6f841528eb}
\hypertarget{classStoreSet_a3cffbd955ca25d7d74d98168c6ea2404}{
\index{StoreSet@{StoreSet}!SSID@{SSID}}
\index{SSID@{SSID}!StoreSet@{StoreSet}}
\subsubsection[{SSID}]{\setlength{\rightskip}{0pt plus 5cm}typedef unsigned {\bf SSID}}}
\label{classStoreSet_a3cffbd955ca25d7d74d98168c6ea2404}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classStoreSet_ab4658accf641bb529cfd0d8a86ac1985}{
\index{StoreSet@{StoreSet}!StoreSet@{StoreSet}}
\index{StoreSet@{StoreSet}!StoreSet@{StoreSet}}
\subsubsection[{StoreSet}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StoreSet} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classStoreSet_ab4658accf641bb529cfd0d8a86ac1985}
Default constructor. \hyperlink{classStoreSet_a4976b4794b30eada21534d7238044c68}{init()} must be called prior to use. 


\begin{DoxyCode}
63 { };
\end{DoxyCode}
\hypertarget{classStoreSet_a31e067a1c435ba8158c230dfe3348839}{
\index{StoreSet@{StoreSet}!StoreSet@{StoreSet}}
\index{StoreSet@{StoreSet}!StoreSet@{StoreSet}}
\subsubsection[{StoreSet}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StoreSet} (uint64\_\-t {\em clear\_\-period}, \/  int {\em SSIT\_\-size}, \/  int {\em LFST\_\-size})}}
\label{classStoreSet_a31e067a1c435ba8158c230dfe3348839}
Creates store set predictor with given table sizes. 


\begin{DoxyCode}
38     : clearPeriod(clear_period), SSITSize(_SSIT_size), LFSTSize(_LFST_size)
39 {
40     DPRINTF(StoreSet, "StoreSet: Creating store set object.\n");
41     DPRINTF(StoreSet, "StoreSet: SSIT size: %i, LFST size: %i.\n",
42             SSITSize, LFSTSize);
43 
44     if (!isPowerOf2(SSITSize)) {
45         fatal("Invalid SSIT size!\n");
46     }
47 
48     SSIT.resize(SSITSize);
49 
50     validSSIT.resize(SSITSize);
51 
52     for (int i = 0; i < SSITSize; ++i)
53         validSSIT[i] = false;
54 
55     if (!isPowerOf2(LFSTSize)) {
56         fatal("Invalid LFST size!\n");
57     }
58 
59     LFST.resize(LFSTSize);
60 
61     validLFST.resize(LFSTSize);
62 
63     for (int i = 0; i < LFSTSize; ++i) {
64         validLFST[i] = false;
65         LFST[i] = 0;
66     }
67 
68     indexMask = SSITSize - 1;
69 
70     offsetBits = 2;
71 
72     memOpsPred = 0;
73 }
\end{DoxyCode}
\hypertarget{classStoreSet_a7e8dc54e3df2141367927871901e6152}{
\index{StoreSet@{StoreSet}!$\sim$StoreSet@{$\sim$StoreSet}}
\index{$\sim$StoreSet@{$\sim$StoreSet}!StoreSet@{StoreSet}}
\subsubsection[{$\sim$StoreSet}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf StoreSet} ()}}
\label{classStoreSet_a7e8dc54e3df2141367927871901e6152}
Default destructor. 


\begin{DoxyCode}
76 {
77 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classStoreSet_aeabab6ef1f2a8e942739203158d70041}{
\index{StoreSet@{StoreSet}!calcIndex@{calcIndex}}
\index{calcIndex@{calcIndex}!StoreSet@{StoreSet}}
\subsubsection[{calcIndex}]{\setlength{\rightskip}{0pt plus 5cm}int calcIndex ({\bf Addr} {\em PC})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classStoreSet_aeabab6ef1f2a8e942739203158d70041}
Calculates the index into the SSIT based on the PC. 


\begin{DoxyCode}
114     { return (PC >> offsetBits) & indexMask; }
\end{DoxyCode}
\hypertarget{classStoreSet_a6b9767a09067554b634a93c4454fa136}{
\index{StoreSet@{StoreSet}!calcSSID@{calcSSID}}
\index{calcSSID@{calcSSID}!StoreSet@{StoreSet}}
\subsubsection[{calcSSID}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SSID} calcSSID ({\bf Addr} {\em PC})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classStoreSet_a6b9767a09067554b634a93c4454fa136}
Calculates a Store \hyperlink{classSet}{Set} ID based on the PC. 


\begin{DoxyCode}
118     { return ((PC ^ (PC >> 10)) % LFSTSize); }
\end{DoxyCode}
\hypertarget{classStoreSet_a4dab67311167cad2367beac85376a3bc}{
\index{StoreSet@{StoreSet}!checkClear@{checkClear}}
\index{checkClear@{checkClear}!StoreSet@{StoreSet}}
\subsubsection[{checkClear}]{\setlength{\rightskip}{0pt plus 5cm}void checkClear ()}}
\label{classStoreSet_a4dab67311167cad2367beac85376a3bc}
Clears the store set predictor every so often so that all the entries aren't used and stores are constantly predicted as conflicting. 


\begin{DoxyCode}
189 {
190     memOpsPred++;
191     if (memOpsPred > clearPeriod) {
192         DPRINTF(StoreSet, "Wiping predictor state beacuse %d ld/st executed\n",
193                 clearPeriod);
194         memOpsPred = 0;
195         clear();
196     }
197 }
\end{DoxyCode}
\hypertarget{classStoreSet_ae8d309615668a58409f29cc73457c7c9}{
\index{StoreSet@{StoreSet}!checkInst@{checkInst}}
\index{checkInst@{checkInst}!StoreSet@{StoreSet}}
\subsubsection[{checkInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} checkInst ({\bf Addr} {\em PC})}}
\label{classStoreSet_ae8d309615668a58409f29cc73457c7c9}
Checks if the instruction with the given PC is dependent upon any store. \begin{DoxyReturn}{戻り値}
Returns the sequence number of the store instruction this PC is dependent upon. Returns 0 if none. 
\end{DoxyReturn}



\begin{DoxyCode}
239 {
240     int index = calcIndex(PC);
241 
242     int inst_SSID;
243 
244     assert(index < SSITSize);
245 
246     if (!validSSIT[index]) {
247         DPRINTF(StoreSet, "Inst %#x with index %i had no SSID\n",
248                 PC, index);
249 
250         // Return 0 if there's no valid entry.
251         return 0;
252     } else {
253         inst_SSID = SSIT[index];
254 
255         assert(inst_SSID < LFSTSize);
256 
257         if (!validLFST[inst_SSID]) {
258 
259             DPRINTF(StoreSet, "Inst %#x with index %i and SSID %i had no "
260                     "dependency\n", PC, index, inst_SSID);
261 
262             return 0;
263         } else {
264             DPRINTF(StoreSet, "Inst %#x with index %i and SSID %i had LFST "
265                     "inum of %i\n", PC, index, inst_SSID, LFST[inst_SSID]);
266 
267             return LFST[inst_SSID];
268         }
269     }
270 }
\end{DoxyCode}
\hypertarget{classStoreSet_ac8bb3912a3ce86b15842e79d0b421204}{
\index{StoreSet@{StoreSet}!clear@{clear}}
\index{clear@{clear}!StoreSet@{StoreSet}}
\subsubsection[{clear}]{\setlength{\rightskip}{0pt plus 5cm}void clear ()}}
\label{classStoreSet_ac8bb3912a3ce86b15842e79d0b421204}
Resets all tables. 


\begin{DoxyCode}
341 {
342     for (int i = 0; i < SSITSize; ++i) {
343         validSSIT[i] = false;
344     }
345 
346     for (int i = 0; i < LFSTSize; ++i) {
347         validLFST[i] = false;
348     }
349 
350     storeList.clear();
351 }
\end{DoxyCode}
\hypertarget{classStoreSet_accd2600060dbaee3a3b41aed4034c63c}{
\index{StoreSet@{StoreSet}!dump@{dump}}
\index{dump@{dump}!StoreSet@{StoreSet}}
\subsubsection[{dump}]{\setlength{\rightskip}{0pt plus 5cm}void dump ()}}
\label{classStoreSet_accd2600060dbaee3a3b41aed4034c63c}
\hyperlink{namespaceDebug}{Debug} function to dump the contents of the store list. 


\begin{DoxyCode}
355 {
356     cprintf("storeList.size(): %i\n", storeList.size());
357     SeqNumMapIt store_list_it = storeList.begin();
358 
359     int num = 0;
360 
361     while (store_list_it != storeList.end()) {
362         cprintf("%i: [sn:%lli] SSID:%i\n",
363                 num, (*store_list_it).first, (*store_list_it).second);
364         num++;
365         store_list_it++;
366     }
367 }
\end{DoxyCode}
\hypertarget{classStoreSet_a4976b4794b30eada21534d7238044c68}{
\index{StoreSet@{StoreSet}!init@{init}}
\index{init@{init}!StoreSet@{StoreSet}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init (uint64\_\-t {\em clear\_\-period}, \/  int {\em SSIT\_\-size}, \/  int {\em LFST\_\-size})}}
\label{classStoreSet_a4976b4794b30eada21534d7238044c68}
Initializes the store set predictor with the given table sizes. 


\begin{DoxyCode}
81 {
82     SSITSize = _SSIT_size;
83     LFSTSize = _LFST_size;
84     clearPeriod = clear_period;
85 
86     DPRINTF(StoreSet, "StoreSet: Creating store set object.\n");
87     DPRINTF(StoreSet, "StoreSet: SSIT size: %i, LFST size: %i.\n",
88             SSITSize, LFSTSize);
89 
90     SSIT.resize(SSITSize);
91 
92     validSSIT.resize(SSITSize);
93 
94     for (int i = 0; i < SSITSize; ++i)
95         validSSIT[i] = false;
96 
97     LFST.resize(LFSTSize);
98 
99     validLFST.resize(LFSTSize);
100 
101     for (int i = 0; i < LFSTSize; ++i) {
102         validLFST[i] = false;
103         LFST[i] = 0;
104     }
105 
106     indexMask = SSITSize - 1;
107 
108     offsetBits = 2;
109 
110     memOpsPred = 0;
111 }
\end{DoxyCode}
\hypertarget{classStoreSet_a205cc846bfa1f976cf2ca9f4bd0fd226}{
\index{StoreSet@{StoreSet}!insertLoad@{insertLoad}}
\index{insertLoad@{insertLoad}!StoreSet@{StoreSet}}
\subsubsection[{insertLoad}]{\setlength{\rightskip}{0pt plus 5cm}void insertLoad ({\bf Addr} {\em load\_\-PC}, \/  {\bf InstSeqNum} {\em load\_\-seq\_\-num})}}
\label{classStoreSet_a205cc846bfa1f976cf2ca9f4bd0fd226}
Inserts a load into the store set predictor. This does nothing but is included in case other predictors require a similar function. 


\begin{DoxyCode}
201 {
202     checkClear();
203     // Does nothing.
204     return;
205 }
\end{DoxyCode}
\hypertarget{classStoreSet_ab879063d4bfe2e1c91025715007bfecb}{
\index{StoreSet@{StoreSet}!insertStore@{insertStore}}
\index{insertStore@{insertStore}!StoreSet@{StoreSet}}
\subsubsection[{insertStore}]{\setlength{\rightskip}{0pt plus 5cm}void insertStore ({\bf Addr} {\em store\_\-PC}, \/  {\bf InstSeqNum} {\em store\_\-seq\_\-num}, \/  {\bf ThreadID} {\em tid})}}
\label{classStoreSet_ab879063d4bfe2e1c91025715007bfecb}
Inserts a store into the store set predictor. Updates the LFST if the store has a valid SSID. 


\begin{DoxyCode}
209 {
210     int index = calcIndex(store_PC);
211 
212     int store_SSID;
213 
214     checkClear();
215     assert(index < SSITSize);
216 
217     if (!validSSIT[index]) {
218         // Do nothing if there's no valid entry.
219         return;
220     } else {
221         store_SSID = SSIT[index];
222 
223         assert(store_SSID < LFSTSize);
224 
225         // Update the last store that was fetched with the current one.
226         LFST[store_SSID] = store_seq_num;
227 
228         validLFST[store_SSID] = 1;
229 
230         storeList[store_seq_num] = store_SSID;
231 
232         DPRINTF(StoreSet, "Store %#x updated the LFST, SSID: %i\n",
233                 store_PC, store_SSID);
234     }
235 }
\end{DoxyCode}
\hypertarget{classStoreSet_a2c9204930bc1f40dfe7451a29a6b8d8d}{
\index{StoreSet@{StoreSet}!issued@{issued}}
\index{issued@{issued}!StoreSet@{StoreSet}}
\subsubsection[{issued}]{\setlength{\rightskip}{0pt plus 5cm}void issued ({\bf Addr} {\em issued\_\-PC}, \/  {\bf InstSeqNum} {\em issued\_\-seq\_\-num}, \/  bool {\em is\_\-store})}}
\label{classStoreSet_a2c9204930bc1f40dfe7451a29a6b8d8d}
Records this PC/sequence number as issued. 


\begin{DoxyCode}
274 {
275     // This only is updated upon a store being issued.
276     if (!is_store) {
277         return;
278     }
279 
280     int index = calcIndex(issued_PC);
281 
282     int store_SSID;
283 
284     assert(index < SSITSize);
285 
286     SeqNumMapIt store_list_it = storeList.find(issued_seq_num);
287 
288     if (store_list_it != storeList.end()) {
289         storeList.erase(store_list_it);
290     }
291 
292     // Make sure the SSIT still has a valid entry for the issued store.
293     if (!validSSIT[index]) {
294         return;
295     }
296 
297     store_SSID = SSIT[index];
298 
299     assert(store_SSID < LFSTSize);
300 
301     // If the last fetched store in the store set refers to the store that
302     // was just issued, then invalidate the entry.
303     if (validLFST[store_SSID] && LFST[store_SSID] == issued_seq_num) {
304         DPRINTF(StoreSet, "StoreSet: store invalidated itself in LFST.\n");
305         validLFST[store_SSID] = false;
306     }
307 }
\end{DoxyCode}
\hypertarget{classStoreSet_a7ff20e53cb9b14b1794a656def08f910}{
\index{StoreSet@{StoreSet}!squash@{squash}}
\index{squash@{squash}!StoreSet@{StoreSet}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash ({\bf InstSeqNum} {\em squashed\_\-num}, \/  {\bf ThreadID} {\em tid})}}
\label{classStoreSet_a7ff20e53cb9b14b1794a656def08f910}
Squashes for a specific thread until the given sequence number. 


\begin{DoxyCode}
311 {
312     DPRINTF(StoreSet, "StoreSet: Squashing until inum %i\n",
313             squashed_num);
314 
315     int idx;
316     SeqNumMapIt store_list_it = storeList.begin();
317 
318     //@todo:Fix to only delete from correct thread
319     while (!storeList.empty()) {
320         idx = (*store_list_it).second;
321 
322         if ((*store_list_it).first <= squashed_num) {
323             break;
324         }
325 
326         bool younger = LFST[idx] > squashed_num;
327 
328         if (validLFST[idx] && younger) {
329             DPRINTF(StoreSet, "Squashed [sn:%lli]\n", LFST[idx]);
330             validLFST[idx] = false;
331 
332             storeList.erase(store_list_it++);
333         } else if (!validLFST[idx] && younger) {
334             storeList.erase(store_list_it++);
335         }
336     }
337 }
\end{DoxyCode}
\hypertarget{classStoreSet_a28e9d2d8a7a8df645736800101f56517}{
\index{StoreSet@{StoreSet}!violation@{violation}}
\index{violation@{violation}!StoreSet@{StoreSet}}
\subsubsection[{violation}]{\setlength{\rightskip}{0pt plus 5cm}void violation ({\bf Addr} {\em store\_\-PC}, \/  {\bf Addr} {\em load\_\-PC})}}
\label{classStoreSet_a28e9d2d8a7a8df645736800101f56517}
Records a memory ordering violation between the younger load and the older store. 


\begin{DoxyCode}
116 {
117     int load_index = calcIndex(load_PC);
118     int store_index = calcIndex(store_PC);
119 
120     assert(load_index < SSITSize && store_index < SSITSize);
121 
122     bool valid_load_SSID = validSSIT[load_index];
123     bool valid_store_SSID = validSSIT[store_index];
124 
125     if (!valid_load_SSID && !valid_store_SSID) {
126         // Calculate a new SSID here.
127         SSID new_set = calcSSID(load_PC);
128 
129         validSSIT[load_index] = true;
130 
131         SSIT[load_index] = new_set;
132 
133         validSSIT[store_index] = true;
134 
135         SSIT[store_index] = new_set;
136 
137         assert(new_set < LFSTSize);
138 
139         DPRINTF(StoreSet, "StoreSet: Neither load nor store had a valid "
140                 "storeset, creating a new one: %i for load %#x, store %#x\n",
141                 new_set, load_PC, store_PC);
142     } else if (valid_load_SSID && !valid_store_SSID) {
143         SSID load_SSID = SSIT[load_index];
144 
145         validSSIT[store_index] = true;
146 
147         SSIT[store_index] = load_SSID;
148 
149         assert(load_SSID < LFSTSize);
150 
151         DPRINTF(StoreSet, "StoreSet: Load had a valid store set.  Adding "
152                 "store to that set: %i for load %#x, store %#x\n",
153                 load_SSID, load_PC, store_PC);
154     } else if (!valid_load_SSID && valid_store_SSID) {
155         SSID store_SSID = SSIT[store_index];
156 
157         validSSIT[load_index] = true;
158 
159         SSIT[load_index] = store_SSID;
160 
161         DPRINTF(StoreSet, "StoreSet: Store had a valid store set: %i for "
162                 "load %#x, store %#x\n",
163                 store_SSID, load_PC, store_PC);
164     } else {
165         SSID load_SSID = SSIT[load_index];
166         SSID store_SSID = SSIT[store_index];
167 
168         assert(load_SSID < LFSTSize && store_SSID < LFSTSize);
169 
170         // The store set with the lower number wins
171         if (store_SSID > load_SSID) {
172             SSIT[store_index] = load_SSID;
173 
174             DPRINTF(StoreSet, "StoreSet: Load had smaller store set: %i; "
175                     "for load %#x, store %#x\n",
176                     load_SSID, load_PC, store_PC);
177         } else {
178             SSIT[load_index] = store_SSID;
179 
180             DPRINTF(StoreSet, "StoreSet: Store had smaller store set: %i; "
181                     "for load %#x, store %#x\n",
182                     store_SSID, load_PC, store_PC);
183         }
184     }
185 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classStoreSet_a9ae4231099a7cc00dcbf234aa174af44}{
\index{StoreSet@{StoreSet}!clearPeriod@{clearPeriod}}
\index{clearPeriod@{clearPeriod}!StoreSet@{StoreSet}}
\subsubsection[{clearPeriod}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf clearPeriod}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classStoreSet_a9ae4231099a7cc00dcbf234aa174af44}
Number of loads/stores to process before wiping predictor so all entries don't get saturated \hypertarget{classStoreSet_a33e6f6648561ce74ee753dd190356fd0}{
\index{StoreSet@{StoreSet}!indexMask@{indexMask}}
\index{indexMask@{indexMask}!StoreSet@{StoreSet}}
\subsubsection[{indexMask}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf indexMask}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classStoreSet_a33e6f6648561ce74ee753dd190356fd0}
Mask to obtain the index. \hypertarget{classStoreSet_a8f418b57f9abc868817afd8026effc89}{
\index{StoreSet@{StoreSet}!LFST@{LFST}}
\index{LFST@{LFST}!StoreSet@{StoreSet}}
\subsubsection[{LFST}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf InstSeqNum}$>$ {\bf LFST}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classStoreSet_a8f418b57f9abc868817afd8026effc89}
Last Fetched Store Table. \hypertarget{classStoreSet_a8ff9a6f977f155a663ce56418b68e9cd}{
\index{StoreSet@{StoreSet}!LFSTSize@{LFSTSize}}
\index{LFSTSize@{LFSTSize}!StoreSet@{StoreSet}}
\subsubsection[{LFSTSize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf LFSTSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classStoreSet_a8ff9a6f977f155a663ce56418b68e9cd}
Last Fetched Store Table size, in entries. \hypertarget{classStoreSet_aa51123e118112a84b5139b216be38d8f}{
\index{StoreSet@{StoreSet}!memOpsPred@{memOpsPred}}
\index{memOpsPred@{memOpsPred}!StoreSet@{StoreSet}}
\subsubsection[{memOpsPred}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf memOpsPred}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classStoreSet_aa51123e118112a84b5139b216be38d8f}
Number of memory operations predicted since last clear of predictor \hypertarget{classStoreSet_a44788461daa83a3b9b3da3fd39d54f31}{
\index{StoreSet@{StoreSet}!offsetBits@{offsetBits}}
\index{offsetBits@{offsetBits}!StoreSet@{StoreSet}}
\subsubsection[{offsetBits}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf offsetBits}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classStoreSet_a44788461daa83a3b9b3da3fd39d54f31}
\hypertarget{classStoreSet_a5c8ed73b9517db1737e7164d1db20154}{
\index{StoreSet@{StoreSet}!SSIT@{SSIT}}
\index{SSIT@{SSIT}!StoreSet@{StoreSet}}
\subsubsection[{SSIT}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf SSID}$>$ {\bf SSIT}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classStoreSet_a5c8ed73b9517db1737e7164d1db20154}
The Store \hyperlink{classSet}{Set} ID Table. \hypertarget{classStoreSet_acd4dabf4d426240afbd79129f8484945}{
\index{StoreSet@{StoreSet}!SSITSize@{SSITSize}}
\index{SSITSize@{SSITSize}!StoreSet@{StoreSet}}
\subsubsection[{SSITSize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf SSITSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classStoreSet_acd4dabf4d426240afbd79129f8484945}
Store \hyperlink{classSet}{Set} ID Table size, in entries. \hypertarget{classStoreSet_a641f6adef35ba24d36e194842e0650b2}{
\index{StoreSet@{StoreSet}!storeList@{storeList}}
\index{storeList@{storeList}!StoreSet@{StoreSet}}
\subsubsection[{storeList}]{\setlength{\rightskip}{0pt plus 5cm}std::map$<${\bf InstSeqNum}, int, {\bf ltseqnum}$>$ {\bf storeList}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classStoreSet_a641f6adef35ba24d36e194842e0650b2}
Map of stores that have been inserted into the store set, but not yet issued or squashed. \hypertarget{classStoreSet_aa0bec890135b0b249993f12f80634c07}{
\index{StoreSet@{StoreSet}!validLFST@{validLFST}}
\index{validLFST@{validLFST}!StoreSet@{StoreSet}}
\subsubsection[{validLFST}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<$bool$>$ {\bf validLFST}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classStoreSet_aa0bec890135b0b249993f12f80634c07}
Bit vector to tell if the LFST has a valid entry. \hypertarget{classStoreSet_ae026c336a6a2761ace6e098304dda75f}{
\index{StoreSet@{StoreSet}!validSSIT@{validSSIT}}
\index{validSSIT@{validSSIT}!StoreSet@{StoreSet}}
\subsubsection[{validSSIT}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<$bool$>$ {\bf validSSIT}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classStoreSet_ae026c336a6a2761ace6e098304dda75f}
Bit vector to tell if the SSIT has a valid entry. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/o3/\hyperlink{store__set_8hh}{store\_\-set.hh}\item 
cpu/o3/\hyperlink{store__set_8cc}{store\_\-set.cc}\end{DoxyCompactItemize}
