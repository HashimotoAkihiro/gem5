\hypertarget{classFrontEnd_1_1IcachePort}{
\section{クラス IcachePort}
\label{classFrontEnd_1_1IcachePort}\index{FrontEnd::IcachePort@{FrontEnd::IcachePort}}
}


{\ttfamily \#include $<$front\_\-end.hh$>$}IcachePortに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4cm]{classFrontEnd_1_1IcachePort}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classFrontEnd_1_1IcachePort_abd888d3a6cea286340ce6aded692b1cc}{IcachePort} (\hyperlink{classFrontEnd}{FrontEnd}$<$ Impl $>$ $\ast$\_\-fe)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classFrontEnd_1_1IcachePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{recvAtomic} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual void \hyperlink{classFrontEnd_1_1IcachePort_aeefa907fb6d6a787e6dab90e8138ea90}{recvFunctional} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual bool \hyperlink{classFrontEnd_1_1IcachePort_aaeef0f6f81d00988bb7b8ba8fe56049e}{recvTiming} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual void \hyperlink{classFrontEnd_1_1IcachePort_a29cb5a4f98063ce6e9210eacbdb35298}{recvRetry} ()
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classFrontEnd}{FrontEnd}$<$ Impl $>$ $\ast$ \hyperlink{classFrontEnd_1_1IcachePort_a639e39cd16b0e1d657b223db6f848764}{fe}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$class Impl$>$ class FrontEnd$<$ Impl $>$::IcachePort}

\hyperlink{classFrontEnd_1_1IcachePort}{IcachePort} class. Handles doing the communication with the cache/memory. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classFrontEnd_1_1IcachePort_abd888d3a6cea286340ce6aded692b1cc}{
\index{FrontEnd::IcachePort@{FrontEnd::IcachePort}!IcachePort@{IcachePort}}
\index{IcachePort@{IcachePort}!FrontEnd::IcachePort@{FrontEnd::IcachePort}}
\subsubsection[{IcachePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IcachePort} ({\bf FrontEnd}$<$ Impl $>$ $\ast$ {\em \_\-fe})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_1_1IcachePort_abd888d3a6cea286340ce6aded692b1cc}
Default constructor. 


\begin{DoxyCode}
80             : fe(_fe)
81         { }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classFrontEnd_1_1IcachePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{
\index{FrontEnd::IcachePort@{FrontEnd::IcachePort}!recvAtomic@{recvAtomic}}
\index{recvAtomic@{recvAtomic}!FrontEnd::IcachePort@{FrontEnd::IcachePort}}
\subsubsection[{recvAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvAtomic ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classFrontEnd_1_1IcachePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}
Atomic version of receive. Panics. 


\begin{DoxyCode}
51 {
52     panic("FrontEnd doesn't expect recvAtomic callback!");
53     return curTick();
54 }
\end{DoxyCode}
\hypertarget{classFrontEnd_1_1IcachePort_aeefa907fb6d6a787e6dab90e8138ea90}{
\index{FrontEnd::IcachePort@{FrontEnd::IcachePort}!recvFunctional@{recvFunctional}}
\index{recvFunctional@{recvFunctional}!FrontEnd::IcachePort@{FrontEnd::IcachePort}}
\subsubsection[{recvFunctional}]{\setlength{\rightskip}{0pt plus 5cm}void recvFunctional ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classFrontEnd_1_1IcachePort_aeefa907fb6d6a787e6dab90e8138ea90}
Functional version of receive. Panics. 


\begin{DoxyCode}
59 {
60     warn("FrontEnd doesn't update state from functional calls");
61 }
\end{DoxyCode}
\hypertarget{classFrontEnd_1_1IcachePort_a29cb5a4f98063ce6e9210eacbdb35298}{
\index{FrontEnd::IcachePort@{FrontEnd::IcachePort}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!FrontEnd::IcachePort@{FrontEnd::IcachePort}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetry ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classFrontEnd_1_1IcachePort_a29cb5a4f98063ce6e9210eacbdb35298}
Handles doing a retry of a failed fetch. 

\hyperlink{classMasterPort_ac1ccc3bcf7ebabb20b57fab99b2be5b0}{MasterPort}を実装しています。


\begin{DoxyCode}
74 {
75     fe->recvRetry();
76 }
\end{DoxyCode}
\hypertarget{classFrontEnd_1_1IcachePort_aaeef0f6f81d00988bb7b8ba8fe56049e}{
\index{FrontEnd::IcachePort@{FrontEnd::IcachePort}!recvTiming@{recvTiming}}
\index{recvTiming@{recvTiming}!FrontEnd::IcachePort@{FrontEnd::IcachePort}}
\subsubsection[{recvTiming}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTiming ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classFrontEnd_1_1IcachePort_aaeef0f6f81d00988bb7b8ba8fe56049e}
Timing version of receive. Handles setting fetch to the proper status to start fetching. 


\begin{DoxyCode}
66 {
67     fe->processCacheCompletion(pkt);
68     return true;
69 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classFrontEnd_1_1IcachePort_a639e39cd16b0e1d657b223db6f848764}{
\index{FrontEnd::IcachePort@{FrontEnd::IcachePort}!fe@{fe}}
\index{fe@{fe}!FrontEnd::IcachePort@{FrontEnd::IcachePort}}
\subsubsection[{fe}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FrontEnd}$<$Impl$>$$\ast$ {\bf fe}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFrontEnd_1_1IcachePort_a639e39cd16b0e1d657b223db6f848764}
Pointer to FE. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/ozone/\hyperlink{front__end_8hh}{front\_\-end.hh}\item 
cpu/ozone/\hyperlink{front__end__impl_8hh}{front\_\-end\_\-impl.hh}\end{DoxyCompactItemize}
