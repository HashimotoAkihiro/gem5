\hypertarget{classAlphaISA_1_1TLB}{
\section{クラス TLB}
\label{classAlphaISA_1_1TLB}\index{AlphaISA::TLB@{AlphaISA::TLB}}
}


{\ttfamily \#include $<$tlb.hh$>$}TLBに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4cm]{classAlphaISA_1_1TLB}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef AlphaTLBParams \hyperlink{classAlphaISA_1_1TLB_a9c268a4095d94dfb9eafa97cb58fcc5b}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classAlphaISA_1_1TLB_acb886bd3c59f00c21be9ceaaf25dab97}{TLB} (const \hyperlink{classAlphaISA_1_1TLB_a9c268a4095d94dfb9eafa97cb58fcc5b}{Params} $\ast$p)
\item 
virtual \hyperlink{classAlphaISA_1_1TLB_a18a1722ab7889997b15fd7b9fc33c7ff}{$\sim$TLB} ()
\item 
void \hyperlink{classAlphaISA_1_1TLB_a15b6c15c1be2ca4de3e65772a02aa29f}{takeOverFrom} (\hyperlink{classBaseTLB}{BaseTLB} $\ast$otlb)
\item 
virtual void \hyperlink{classAlphaISA_1_1TLB_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
int \hyperlink{classAlphaISA_1_1TLB_ae121404a6cfcf714e05fe2231ce4c7fc}{getsize} () const 
\item 
\hyperlink{structAlphaISA_1_1TlbEntry}{TlbEntry} \& \hyperlink{classAlphaISA_1_1TLB_ab208f0d14ee1cc1eb06a1b6e6f1bd1b9}{index} (bool advance=true)
\item 
void \hyperlink{classAlphaISA_1_1TLB_a47905393ad1ab88c483d3f512327aedc}{insert} (\hyperlink{classm5_1_1params_1_1Addr}{Addr} vaddr, \hyperlink{structAlphaISA_1_1TlbEntry}{TlbEntry} \&entry)
\item 
void \hyperlink{classAlphaISA_1_1TLB_aca1483a67aee5a91e442f7131d66bcbd}{flushAll} ()
\item 
void \hyperlink{classAlphaISA_1_1TLB_a1d200c761e7041c940eb452220c466d7}{flushProcesses} ()
\item 
void \hyperlink{classAlphaISA_1_1TLB_acac93fcf5aeb0db9145137bd198cb417}{flushAddr} (\hyperlink{classm5_1_1params_1_1Addr}{Addr} addr, uint8\_\-t asn)
\item 
void \hyperlink{classAlphaISA_1_1TLB_a2d698ff909513b48a1263f8a5440e067}{demapPage} (\hyperlink{classm5_1_1params_1_1Addr}{Addr} vaddr, uint64\_\-t asn)
\item 
virtual void \hyperlink{classAlphaISA_1_1TLB_ad6272f80ae37e8331e3969b3f072a801}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classAlphaISA_1_1TLB_af100c4e9feabf3cd918619c88c718387}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\item 
void \hyperlink{classAlphaISA_1_1TLB_ab93a13c29b6326413ba76bdd7e54ad41}{flushCache} ()
\item 
\hyperlink{structAlphaISA_1_1TlbEntry}{TlbEntry} $\ast$ \hyperlink{classAlphaISA_1_1TLB_a5d6ff82bfde528ed0663afc4a718a5a1}{updateCache} (\hyperlink{structAlphaISA_1_1TlbEntry}{TlbEntry} $\ast$entry)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classAlphaISA_1_1TLB_ad54e01e3c0a1613098a76b7f92e5be93}{translateAtomic} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} mode)
\item 
void \hyperlink{classAlphaISA_1_1TLB_ae52f7e465748883695d2b4f432a13652}{translateTiming} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{classBaseTLB_1_1Translation}{Translation} $\ast$translation, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} mode)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classAlphaISA_1_1TLB_a26658814c6c9034665aae19cf25545bb}{translateFunctional} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} mode)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classAlphaISA_1_1TLB_ae199d95c42e036851a8a0543c6d6d2e3}{finalizePhysical} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} mode) const 
\end{DoxyCompactItemize}
\subsection*{Static Public メソッド}
\begin{DoxyCompactItemize}
\item 
static bool \hyperlink{classAlphaISA_1_1TLB_a3e576c3e0d39dfca708baea44ebf0617}{validVirtualAddress} (\hyperlink{classm5_1_1params_1_1Addr}{Addr} vaddr)
\item 
static \hyperlink{classRefCountingPtr}{Fault} \hyperlink{classAlphaISA_1_1TLB_ae6e8469121a70e90e8213987b19eb83d}{checkCacheability} (\hyperlink{classRequest}{RequestPtr} \&req, bool itb=false)
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structAlphaISA_1_1TlbEntry}{TlbEntry} $\ast$ \hyperlink{classAlphaISA_1_1TLB_a82eefd07de8b39b6a974a2b03174999a}{EntryCache} \mbox{[}3\mbox{]}
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
typedef std::multimap$<$ \hyperlink{classm5_1_1params_1_1Addr}{Addr}, int $>$ \hyperlink{classAlphaISA_1_1TLB_a18f97eb978c56b976c0eadbf9212d206}{PageTable}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classAlphaISA_1_1TLB_aeb5ba263cf2621ed26767046ab78a1dc}{nextnlu} ()
\item 
\hyperlink{structAlphaISA_1_1TlbEntry}{TlbEntry} $\ast$ \hyperlink{classAlphaISA_1_1TLB_af2081108994a71d701fc459ad161790e}{lookup} (\hyperlink{classm5_1_1params_1_1Addr}{Addr} vpn, uint8\_\-t asn)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classAlphaISA_1_1TLB_ad54aef66412f77e2a15a621a126dfb52}{translateData} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc, bool write)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classAlphaISA_1_1TLB_a072afd8ed455dade4c25a85510e5a4da}{translateInst} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classAlphaISA_1_1TLB_a41b41877cc14c93d0663a37014aaa605}{fetch\_\-hits}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classAlphaISA_1_1TLB_a5801332ce26351763f996ea8aa050a96}{fetch\_\-misses}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classAlphaISA_1_1TLB_a91197c087b25a1ccf96a6c15523b6d1a}{fetch\_\-acv}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classAlphaISA_1_1TLB_ae73b1ec9b8b461b5c5b0f1f903692418}{fetch\_\-accesses}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classAlphaISA_1_1TLB_a766fdbd2ab7d588c3c9fa426ce395ed6}{read\_\-hits}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classAlphaISA_1_1TLB_a6fb393c9489d735739552c2a351f07f4}{read\_\-misses}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classAlphaISA_1_1TLB_af50813bd757bd59aa3618aa99377760a}{read\_\-acv}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classAlphaISA_1_1TLB_a2c9dc5a6baf7fbd1ae7fc00b0a57fe56}{read\_\-accesses}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classAlphaISA_1_1TLB_ab3172bfd014e75dcad1b0a2a91de59dd}{write\_\-hits}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classAlphaISA_1_1TLB_af8519a07f8f1f76c8fff9c9a1aaa4638}{write\_\-misses}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classAlphaISA_1_1TLB_a764f5ef97bfcb1ba3ad05704de5a3a32}{write\_\-acv}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classAlphaISA_1_1TLB_af3301e9dd0bb91de161b7bafefade7f3}{write\_\-accesses}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classAlphaISA_1_1TLB_a2252d249bb340d0061f5e3b7cf2bfe5b}{data\_\-hits}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classAlphaISA_1_1TLB_a426c830a47b60eed9fbd6dcb99433a48}{data\_\-misses}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classAlphaISA_1_1TLB_acf5209d104ddafaa697af923c7a3c750}{data\_\-acv}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classAlphaISA_1_1TLB_a66b0bcc2ec4a983bb2a31a9306157551}{data\_\-accesses}
\item 
\hyperlink{classPageTable}{PageTable} \hyperlink{classAlphaISA_1_1TLB_a4d5c35d797dc31aad758dee75916238f}{lookupTable}
\item 
\hyperlink{structAlphaISA_1_1TlbEntry}{TlbEntry} $\ast$ \hyperlink{classAlphaISA_1_1TLB_a434ae74dec9e8168e4f338aeb18d5931}{table}
\item 
int \hyperlink{classAlphaISA_1_1TLB_a439227feff9d7f55384e8780cfc2eb82}{size}
\item 
int \hyperlink{classAlphaISA_1_1TLB_a4a3ee7780f871ead437ece349ddc2147}{nlu}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classAlphaISA_1_1TLB_a18f97eb978c56b976c0eadbf9212d206}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!PageTable@{PageTable}}
\index{PageTable@{PageTable}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{PageTable}]{\setlength{\rightskip}{0pt plus 5cm}typedef std::multimap$<${\bf Addr}, int$>$ {\bf PageTable}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a18f97eb978c56b976c0eadbf9212d206}
\hypertarget{classAlphaISA_1_1TLB_a9c268a4095d94dfb9eafa97cb58fcc5b}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!Params@{Params}}
\index{Params@{Params}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef AlphaTLBParams {\bf Params}}}
\label{classAlphaISA_1_1TLB_a9c268a4095d94dfb9eafa97cb58fcc5b}


\hyperlink{classSimObject_a0f0761d2db586a23bb2a2880b8f387bb}{SimObject}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classAlphaISA_1_1TLB_acb886bd3c59f00c21be9ceaaf25dab97}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!TLB@{TLB}}
\index{TLB@{TLB}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{TLB}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TLB} (const {\bf Params} $\ast$ {\em p})}}
\label{classAlphaISA_1_1TLB_acb886bd3c59f00c21be9ceaaf25dab97}



\begin{DoxyCode}
64     : BaseTLB(p), size(p->size), nlu(0)
65 {
66     table = new TlbEntry[size];
67     memset(table, 0, sizeof(TlbEntry) * size);
68     flushCache();
69 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_a18a1722ab7889997b15fd7b9fc33c7ff}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!$\sim$TLB@{$\sim$TLB}}
\index{$\sim$TLB@{$\sim$TLB}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{$\sim$TLB}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf TLB} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a18a1722ab7889997b15fd7b9fc33c7ff}



\begin{DoxyCode}
72 {
73     if (table)
74         delete [] table;
75 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classAlphaISA_1_1TLB_ae6e8469121a70e90e8213987b19eb83d}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!checkCacheability@{checkCacheability}}
\index{checkCacheability@{checkCacheability}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{checkCacheability}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} checkCacheability ({\bf RequestPtr} \& {\em req}, \/  bool {\em itb} = {\ttfamily false})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classAlphaISA_1_1TLB_ae6e8469121a70e90e8213987b19eb83d}



\begin{DoxyCode}
206 {
207     // in Alpha, cacheability is controlled by upper-level bits of the
208     // physical address
209 
210     /*
211      * We support having the uncacheable bit in either bit 39 or bit
212      * 40.  The Turbolaser platform (and EV5) support having the bit
213      * in 39, but Tsunami (which Linux assumes uses an EV6) generates
214      * accesses with the bit in 40.  So we must check for both, but we
215      * have debug flags to catch a weird case where both are used,
216      * which shouldn't happen.
217      */
218 
219 
220     if (req->getPaddr() & PAddrUncachedBit43) {
221         // IPR memory space not implemented
222         if (PAddrIprSpace(req->getPaddr())) {
223             return new UnimpFault("IPR memory space not implemented!");
224         } else {
225             // mark request as uncacheable
226             req->setFlags(Request::UNCACHEABLE);
227 
228             // Clear bits 42:35 of the physical address (10-2 in
229             // Tsunami manual)
230             req->setPaddr(req->getPaddr() & PAddrUncachedMask);
231         }
232         // We shouldn't be able to read from an uncachable address in Alpha as
233         // we don't have a ROM and we don't want to try to fetch from a device 
234         // register as we destroy any data that is clear-on-read. 
235         if (req->isUncacheable() && itb) 
236             return new UnimpFault("CPU trying to fetch from uncached I/O");
237 
238     }
239     return NoFault;
240 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_a2d698ff909513b48a1263f8a5440e067}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!demapPage@{demapPage}}
\index{demapPage@{demapPage}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{demapPage}]{\setlength{\rightskip}{0pt plus 5cm}void demapPage ({\bf Addr} {\em vaddr}, \/  uint64\_\-t {\em asn})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a2d698ff909513b48a1263f8a5440e067}



\begin{DoxyCode}
105     {
106         assert(asn < (1 << 8));
107         flushAddr(vaddr, asn);
108     }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_ae199d95c42e036851a8a0543c6d6d2e3}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!finalizePhysical@{finalizePhysical}}
\index{finalizePhysical@{finalizePhysical}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{finalizePhysical}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} finalizePhysical ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Mode} {\em mode}) const}}
\label{classAlphaISA_1_1TLB_ae199d95c42e036851a8a0543c6d6d2e3}



\begin{DoxyCode}
612 {
613     return NoFault;
614 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_acac93fcf5aeb0db9145137bd198cb417}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!flushAddr@{flushAddr}}
\index{flushAddr@{flushAddr}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{flushAddr}]{\setlength{\rightskip}{0pt plus 5cm}void flushAddr ({\bf Addr} {\em addr}, \/  uint8\_\-t {\em asn})}}
\label{classAlphaISA_1_1TLB_acac93fcf5aeb0db9145137bd198cb417}



\begin{DoxyCode}
316 {
317     flushCache();
318     VAddr vaddr = addr;
319 
320     PageTable::iterator i = lookupTable.find(vaddr.vpn());
321     if (i == lookupTable.end())
322         return;
323 
324     while (i != lookupTable.end() && i->first == vaddr.vpn()) {
325         int index = i->second;
326         TlbEntry *entry = &table[index];
327         assert(entry->valid);
328 
329         if (vaddr.vpn() == entry->tag && (entry->asma || entry->asn == asn)) {
330             DPRINTF(TLB, "flushaddr @%d: %#x -> %#x\n", index, vaddr.vpn(),
331                     entry->ppn);
332 
333             // invalidate this entry
334             entry->valid = false;
335 
336             lookupTable.erase(i++);
337         } else {
338             ++i;
339         }
340     }
341 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_aca1483a67aee5a91e442f7131d66bcbd}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!flushAll@{flushAll}}
\index{flushAll@{flushAll}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{flushAll}]{\setlength{\rightskip}{0pt plus 5cm}void flushAll ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classAlphaISA_1_1TLB_aca1483a67aee5a91e442f7131d66bcbd}
Remove all entries from the \hyperlink{classAlphaISA_1_1TLB}{TLB} 

\hyperlink{classBaseTLB_a5958bc92949a47d1be1088468abdc006}{BaseTLB}を実装しています。


\begin{DoxyCode}
281 {
282     DPRINTF(TLB, "flushAll\n");
283     memset(table, 0, sizeof(TlbEntry) * size);
284     flushCache();
285     lookupTable.clear();
286     nlu = 0;
287 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_ab93a13c29b6326413ba76bdd7e54ad41}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!flushCache@{flushCache}}
\index{flushCache@{flushCache}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{flushCache}]{\setlength{\rightskip}{0pt plus 5cm}void flushCache ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAlphaISA_1_1TLB_ab93a13c29b6326413ba76bdd7e54ad41}



\begin{DoxyCode}
129     {
130         memset(EntryCache, 0, 3 * sizeof(TlbEntry*));
131     }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_a1d200c761e7041c940eb452220c466d7}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!flushProcesses@{flushProcesses}}
\index{flushProcesses@{flushProcesses}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{flushProcesses}]{\setlength{\rightskip}{0pt plus 5cm}void flushProcesses ()}}
\label{classAlphaISA_1_1TLB_a1d200c761e7041c940eb452220c466d7}



\begin{DoxyCode}
291 {
292     flushCache();
293     PageTable::iterator i = lookupTable.begin();
294     PageTable::iterator end = lookupTable.end();
295     while (i != end) {
296         int index = i->second;
297         TlbEntry *entry = &table[index];
298         assert(entry->valid);
299 
300         // we can't increment i after we erase it, so save a copy and
301         // increment it to get the next entry now
302         PageTable::iterator cur = i;
303         ++i;
304 
305         if (!entry->asma) {
306             DPRINTF(TLB, "flush @%d: %#x -> %#x\n", index,
307                     entry->tag, entry->ppn);
308             entry->valid = false;
309             lookupTable.erase(cur);
310         }
311     }
312 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_ae121404a6cfcf714e05fe2231ce4c7fc}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!getsize@{getsize}}
\index{getsize@{getsize}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{getsize}]{\setlength{\rightskip}{0pt plus 5cm}int getsize () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAlphaISA_1_1TLB_ae121404a6cfcf714e05fe2231ce4c7fc}



\begin{DoxyCode}
94 { return size; }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_ab208f0d14ee1cc1eb06a1b6e6f1bd1b9}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!index@{index}}
\index{index@{index}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{index}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TlbEntry} \& index (bool {\em advance} = {\ttfamily true})}}
\label{classAlphaISA_1_1TLB_ab208f0d14ee1cc1eb06a1b6e6f1bd1b9}



\begin{DoxyCode}
577 {
578     TlbEntry *entry = &table[nlu];
579 
580     if (advance)
581         nextnlu();
582 
583     return *entry;
584 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_a47905393ad1ab88c483d3f512327aedc}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!insert@{insert}}
\index{insert@{insert}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{insert}]{\setlength{\rightskip}{0pt plus 5cm}void insert ({\bf Addr} {\em vaddr}, \/  {\bf TlbEntry} \& {\em entry})}}
\label{classAlphaISA_1_1TLB_a47905393ad1ab88c483d3f512327aedc}



\begin{DoxyCode}
246 {
247     flushCache();
248     VAddr vaddr = addr;
249     if (table[nlu].valid) {
250         Addr oldvpn = table[nlu].tag;
251         PageTable::iterator i = lookupTable.find(oldvpn);
252 
253         if (i == lookupTable.end())
254             panic("TLB entry not found in lookupTable");
255 
256         int index;
257         while ((index = i->second) != nlu) {
258             if (table[index].tag != oldvpn)
259                 panic("TLB entry not found in lookupTable");
260 
261             ++i;
262         }
263 
264         DPRINTF(TLB, "remove @%d: %#x -> %#x\n", nlu, oldvpn, table[nlu].ppn);
265 
266         lookupTable.erase(i);
267     }
268 
269     DPRINTF(TLB, "insert @%d: %#x -> %#x\n", nlu, vaddr.vpn(), entry.ppn);
270 
271     table[nlu] = entry;
272     table[nlu].tag = vaddr.vpn();
273     table[nlu].valid = true;
274 
275     lookupTable.insert(make_pair(vaddr.vpn(), nlu));
276     nextnlu();
277 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_af2081108994a71d701fc459ad161790e}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!lookup@{lookup}}
\index{lookup@{lookup}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{lookup}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TlbEntry} $\ast$ lookup ({\bf Addr} {\em vpn}, \/  uint8\_\-t {\em asn})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_af2081108994a71d701fc459ad161790e}



\begin{DoxyCode}
164 {
165     // assume not found...
166     TlbEntry *retval = NULL;
167 
168     if (EntryCache[0]) {
169         if (vpn == EntryCache[0]->tag &&
170             (EntryCache[0]->asma || EntryCache[0]->asn == asn))
171             retval = EntryCache[0];
172         else if (EntryCache[1]) {
173             if (vpn == EntryCache[1]->tag &&
174                 (EntryCache[1]->asma || EntryCache[1]->asn == asn))
175                 retval = EntryCache[1];
176             else if (EntryCache[2] && vpn == EntryCache[2]->tag &&
177                      (EntryCache[2]->asma || EntryCache[2]->asn == asn))
178                 retval = EntryCache[2];
179         }
180     }
181 
182     if (retval == NULL) {
183         PageTable::const_iterator i = lookupTable.find(vpn);
184         if (i != lookupTable.end()) {
185             while (i->first == vpn) {
186                 int index = i->second;
187                 TlbEntry *entry = &table[index];
188                 assert(entry->valid);
189                 if (vpn == entry->tag && (entry->asma || entry->asn == asn)) {
190                     retval = updateCache(entry);
191                     break;
192                 }
193 
194                 ++i;
195             }
196         }
197     }
198 
199     DPRINTF(TLB, "lookup %#x, asn %#x -> %s ppn %#x\n", vpn, (int)asn,
200             retval ? "hit" : "miss", retval ? retval->ppn : 0);
201     return retval;
202 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_aeb5ba263cf2621ed26767046ab78a1dc}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!nextnlu@{nextnlu}}
\index{nextnlu@{nextnlu}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{nextnlu}]{\setlength{\rightskip}{0pt plus 5cm}void nextnlu ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_aeb5ba263cf2621ed26767046ab78a1dc}



\begin{DoxyCode}
82 { if (++nlu >= size) nlu = 0; }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!regStats@{regStats}}
\index{regStats@{regStats}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} statistics for this object. 

\hyperlink{classSimObject_a4dc637449366fcdfc4e764cdf12d9b11}{SimObject}を再定義しています。


\begin{DoxyCode}
79 {
80     fetch_hits
81         .name(name() + ".fetch_hits")
82         .desc("ITB hits");
83     fetch_misses
84         .name(name() + ".fetch_misses")
85         .desc("ITB misses");
86     fetch_acv
87         .name(name() + ".fetch_acv")
88         .desc("ITB acv");
89     fetch_accesses
90         .name(name() + ".fetch_accesses")
91         .desc("ITB accesses");
92 
93     fetch_accesses = fetch_hits + fetch_misses;
94 
95     read_hits
96         .name(name() + ".read_hits")
97         .desc("DTB read hits")
98         ;
99 
100     read_misses
101         .name(name() + ".read_misses")
102         .desc("DTB read misses")
103         ;
104 
105     read_acv
106         .name(name() + ".read_acv")
107         .desc("DTB read access violations")
108         ;
109 
110     read_accesses
111         .name(name() + ".read_accesses")
112         .desc("DTB read accesses")
113         ;
114 
115     write_hits
116         .name(name() + ".write_hits")
117         .desc("DTB write hits")
118         ;
119 
120     write_misses
121         .name(name() + ".write_misses")
122         .desc("DTB write misses")
123         ;
124 
125     write_acv
126         .name(name() + ".write_acv")
127         .desc("DTB write access violations")
128         ;
129 
130     write_accesses
131         .name(name() + ".write_accesses")
132         .desc("DTB write accesses")
133         ;
134 
135     data_hits
136         .name(name() + ".data_hits")
137         .desc("DTB hits")
138         ;
139 
140     data_misses
141         .name(name() + ".data_misses")
142         .desc("DTB misses")
143         ;
144 
145     data_acv
146         .name(name() + ".data_acv")
147         .desc("DTB access violations")
148         ;
149 
150     data_accesses
151         .name(name() + ".data_accesses")
152         .desc("DTB accesses")
153         ;
154 
155     data_hits = read_hits + write_hits;
156     data_misses = read_misses + write_misses;
157     data_acv = read_acv + write_acv;
158     data_accesses = read_accesses + write_accesses;
159 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_ad6272f80ae37e8331e3969b3f072a801}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!serialize@{serialize}}
\index{serialize@{serialize}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}virtual void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classAlphaISA_1_1TLB_ad6272f80ae37e8331e3969b3f072a801}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。\hypertarget{classAlphaISA_1_1TLB_a15b6c15c1be2ca4de3e65772a02aa29f}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ({\bf BaseTLB} $\ast$ {\em otlb})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a15b6c15c1be2ca4de3e65772a02aa29f}



\begin{DoxyCode}
90 {}
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_ad54e01e3c0a1613098a76b7f92e5be93}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!translateAtomic@{translateAtomic}}
\index{translateAtomic@{translateAtomic}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{translateAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translateAtomic ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Mode} {\em mode})}}
\label{classAlphaISA_1_1TLB_ad54e01e3c0a1613098a76b7f92e5be93}



\begin{DoxyCode}
588 {
589     if (mode == Execute)
590         return translateInst(req, tc);
591     else
592         return translateData(req, tc, mode == Write);
593 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_ad54aef66412f77e2a15a621a126dfb52}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!translateData@{translateData}}
\index{translateData@{translateData}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{translateData}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translateData ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  bool {\em write})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_ad54aef66412f77e2a15a621a126dfb52}


\hyperlink{classCheck}{Check} for alignment faults


\begin{DoxyCode}
449 {
450     mode_type mode =
451         (mode_type)DTB_CM_CM(tc->readMiscRegNoEffect(IPR_DTB_CM));
452 
456     if (req->getVaddr() & (req->getSize() - 1)) {
457         DPRINTF(TLB, "Alignment Fault on %#x, size = %d\n", req->getVaddr(),
458                 req->getSize());
459         uint64_t flags = write ? MM_STAT_WR_MASK : 0;
460         return new DtbAlignmentFault(req->getVaddr(), req->getFlags(), flags);
461     }
462 
463     if (PcPAL(req->getPC())) {
464         mode = (req->getFlags() & Request::ALTMODE) ?
465             (mode_type)ALT_MODE_AM(
466                 tc->readMiscRegNoEffect(IPR_ALT_MODE))
467             : mode_kernel;
468     }
469 
470     if (req->getFlags() & Request::PHYSICAL) {
471         req->setPaddr(req->getVaddr());
472     } else {
473         // verify that this is a good virtual address
474         if (!validVirtualAddress(req->getVaddr())) {
475             if (write) { write_acv++; } else { read_acv++; }
476             uint64_t flags = (write ? MM_STAT_WR_MASK : 0) |
477                 MM_STAT_BAD_VA_MASK |
478                 MM_STAT_ACV_MASK;
479             return new DtbPageFault(req->getVaddr(), req->getFlags(), flags);
480         }
481 
482         // Check for "superpage" mapping
483         if (VAddrSpaceEV6(req->getVaddr()) == 0x7e) {
484             // only valid in kernel mode
485             if (DTB_CM_CM(tc->readMiscRegNoEffect(IPR_DTB_CM)) !=
486                 mode_kernel) {
487                 if (write) { write_acv++; } else { read_acv++; }
488                 uint64_t flags = ((write ? MM_STAT_WR_MASK : 0) |
489                                   MM_STAT_ACV_MASK);
490 
491                 return new DtbAcvFault(req->getVaddr(), req->getFlags(),
492                                        flags);
493             }
494 
495             req->setPaddr(req->getVaddr() & PAddrImplMask);
496 
497             // sign extend the physical address properly
498             if (req->getPaddr() & PAddrUncachedBit40)
499                 req->setPaddr(req->getPaddr() | ULL(0xf0000000000));
500             else
501                 req->setPaddr(req->getPaddr() & ULL(0xffffffffff));
502         } else {
503             if (write)
504                 write_accesses++;
505             else
506                 read_accesses++;
507 
508             int asn = DTB_ASN_ASN(tc->readMiscRegNoEffect(IPR_DTB_ASN));
509 
510             // not a physical address: need to look up pte
511             TlbEntry *entry = lookup(VAddr(req->getVaddr()).vpn(), asn);
512 
513             if (!entry) {
514                 // page fault
515                 if (write) { write_misses++; } else { read_misses++; }
516                 uint64_t flags = (write ? MM_STAT_WR_MASK : 0) |
517                     MM_STAT_DTB_MISS_MASK;
518                 return (req->getFlags() & Request::VPTE) ?
519                     (Fault)(new PDtbMissFault(req->getVaddr(), req->getFlags(),
520                                               flags)) :
521                     (Fault)(new NDtbMissFault(req->getVaddr(), req->getFlags(),
522                                               flags));
523             }
524 
525             req->setPaddr((entry->ppn << PageShift) +
526                           VAddr(req->getVaddr()).offset());
527 
528             if (write) {
529                 if (!(entry->xwe & MODE2MASK(mode))) {
530                     // declare the instruction access fault
531                     write_acv++;
532                     uint64_t flags = MM_STAT_WR_MASK |
533                         MM_STAT_ACV_MASK |
534                         (entry->fonw ? MM_STAT_FONW_MASK : 0);
535                     return new DtbPageFault(req->getVaddr(), req->getFlags(),
536                                             flags);
537                 }
538                 if (entry->fonw) {
539                     write_acv++;
540                     uint64_t flags = MM_STAT_WR_MASK | MM_STAT_FONW_MASK;
541                     return new DtbPageFault(req->getVaddr(), req->getFlags(),
542                                             flags);
543                 }
544             } else {
545                 if (!(entry->xre & MODE2MASK(mode))) {
546                     read_acv++;
547                     uint64_t flags = MM_STAT_ACV_MASK |
548                         (entry->fonr ? MM_STAT_FONR_MASK : 0);
549                     return new DtbAcvFault(req->getVaddr(), req->getFlags(),
550                                            flags);
551                 }
552                 if (entry->fonr) {
553                     read_acv++;
554                     uint64_t flags = MM_STAT_FONR_MASK;
555                     return new DtbPageFault(req->getVaddr(), req->getFlags(),
556                                             flags);
557                 }
558             }
559         }
560 
561         if (write)
562             write_hits++;
563         else
564             read_hits++;
565     }
566 
567     // check that the physical address is ok (catch bad physical addresses)
568     if (req->getPaddr() & ~PAddrImplMask) {
569         return new MachineCheckFault();
570     }
571 
572     return checkCacheability(req);
573 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_a26658814c6c9034665aae19cf25545bb}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!translateFunctional@{translateFunctional}}
\index{translateFunctional@{translateFunctional}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{translateFunctional}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translateFunctional ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Mode} {\em mode})}}
\label{classAlphaISA_1_1TLB_a26658814c6c9034665aae19cf25545bb}
translateFunctional stub function for future \hyperlink{classCheckerCPU}{CheckerCPU} support 


\begin{DoxyCode}
605 {
606     panic("Not implemented\n");
607     return NoFault;
608 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_a072afd8ed455dade4c25a85510e5a4da}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!translateInst@{translateInst}}
\index{translateInst@{translateInst}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{translateInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translateInst ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a072afd8ed455dade4c25a85510e5a4da}



\begin{DoxyCode}
372 {
373     //If this is a pal pc, then set PHYSICAL
374     if (FullSystem && PcPAL(req->getPC()))
375         req->setFlags(Request::PHYSICAL);
376 
377     if (PcPAL(req->getPC())) {
378         // strip off PAL PC marker (lsb is 1)
379         req->setPaddr((req->getVaddr() & ~3) & PAddrImplMask);
380         fetch_hits++;
381         return NoFault;
382     }
383 
384     if (req->getFlags() & Request::PHYSICAL) {
385         req->setPaddr(req->getVaddr());
386     } else {
387         // verify that this is a good virtual address
388         if (!validVirtualAddress(req->getVaddr())) {
389             fetch_acv++;
390             return new ItbAcvFault(req->getVaddr());
391         }
392 
393 
394         // VA<42:41> == 2, VA<39:13> maps directly to PA<39:13> for EV5
395         // VA<47:41> == 0x7e, VA<40:13> maps directly to PA<40:13> for EV6
396         if (VAddrSpaceEV6(req->getVaddr()) == 0x7e) {
397             // only valid in kernel mode
398             if (ICM_CM(tc->readMiscRegNoEffect(IPR_ICM)) !=
399                 mode_kernel) {
400                 fetch_acv++;
401                 return new ItbAcvFault(req->getVaddr());
402             }
403 
404             req->setPaddr(req->getVaddr() & PAddrImplMask);
405 
406             // sign extend the physical address properly
407             if (req->getPaddr() & PAddrUncachedBit40)
408                 req->setPaddr(req->getPaddr() | ULL(0xf0000000000));
409             else
410                 req->setPaddr(req->getPaddr() & ULL(0xffffffffff));
411         } else {
412             // not a physical address: need to look up pte
413             int asn = DTB_ASN_ASN(tc->readMiscRegNoEffect(IPR_DTB_ASN));
414             TlbEntry *entry = lookup(VAddr(req->getVaddr()).vpn(),
415                               asn);
416 
417             if (!entry) {
418                 fetch_misses++;
419                 return new ItbPageFault(req->getVaddr());
420             }
421 
422             req->setPaddr((entry->ppn << PageShift) +
423                           (VAddr(req->getVaddr()).offset()
424                            & ~3));
425 
426             // check permissions for this access
427             if (!(entry->xre &
428                   (1 << ICM_CM(tc->readMiscRegNoEffect(IPR_ICM))))) {
429                 // instruction access fault
430                 fetch_acv++;
431                 return new ItbAcvFault(req->getVaddr());
432             }
433 
434             fetch_hits++;
435         }
436     }
437 
438     // check that the physical address is ok (catch bad physical addresses)
439     if (req->getPaddr() & ~PAddrImplMask) {
440         return new MachineCheckFault();
441     }
442 
443     return checkCacheability(req, true);
444 
445 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_ae52f7e465748883695d2b4f432a13652}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!translateTiming@{translateTiming}}
\index{translateTiming@{translateTiming}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{translateTiming}]{\setlength{\rightskip}{0pt plus 5cm}void translateTiming ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Translation} $\ast$ {\em translation}, \/  {\bf Mode} {\em mode})}}
\label{classAlphaISA_1_1TLB_ae52f7e465748883695d2b4f432a13652}



\begin{DoxyCode}
598 {
599     assert(translation);
600     translation->finish(translateAtomic(req, tc, mode), req, tc, mode);
601 }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_af100c4e9feabf3cd918619c88c718387}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}virtual void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classAlphaISA_1_1TLB_af100c4e9feabf3cd918619c88c718387}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。\hypertarget{classAlphaISA_1_1TLB_a5d6ff82bfde528ed0663afc4a718a5a1}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!updateCache@{updateCache}}
\index{updateCache@{updateCache}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{updateCache}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TlbEntry}$\ast$ updateCache ({\bf TlbEntry} $\ast$ {\em entry})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a5d6ff82bfde528ed0663afc4a718a5a1}



\begin{DoxyCode}
134                                  {
135         EntryCache[2] = EntryCache[1];
136         EntryCache[1] = EntryCache[0];
137         EntryCache[0] = entry;
138         return entry;
139     }
\end{DoxyCode}
\hypertarget{classAlphaISA_1_1TLB_a3e576c3e0d39dfca708baea44ebf0617}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!validVirtualAddress@{validVirtualAddress}}
\index{validVirtualAddress@{validVirtualAddress}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{validVirtualAddress}]{\setlength{\rightskip}{0pt plus 5cm}static bool validVirtualAddress ({\bf Addr} {\em vaddr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a3e576c3e0d39dfca708baea44ebf0617}



\begin{DoxyCode}
113     {
114         // unimplemented bits must be all 0 or all 1
115         Addr unimplBits = vaddr & VAddrUnImplMask;
116         return unimplBits == 0 || unimplBits == VAddrUnImplMask;
117     }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classAlphaISA_1_1TLB_a66b0bcc2ec4a983bb2a31a9306157551}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!data\_\-accesses@{data\_\-accesses}}
\index{data\_\-accesses@{data\_\-accesses}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{data\_\-accesses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf data\_\-accesses}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a66b0bcc2ec4a983bb2a31a9306157551}
\hypertarget{classAlphaISA_1_1TLB_acf5209d104ddafaa697af923c7a3c750}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!data\_\-acv@{data\_\-acv}}
\index{data\_\-acv@{data\_\-acv}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{data\_\-acv}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf data\_\-acv}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_acf5209d104ddafaa697af923c7a3c750}
\hypertarget{classAlphaISA_1_1TLB_a2252d249bb340d0061f5e3b7cf2bfe5b}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!data\_\-hits@{data\_\-hits}}
\index{data\_\-hits@{data\_\-hits}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{data\_\-hits}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf data\_\-hits}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a2252d249bb340d0061f5e3b7cf2bfe5b}
\hypertarget{classAlphaISA_1_1TLB_a426c830a47b60eed9fbd6dcb99433a48}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!data\_\-misses@{data\_\-misses}}
\index{data\_\-misses@{data\_\-misses}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{data\_\-misses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf data\_\-misses}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a426c830a47b60eed9fbd6dcb99433a48}
\hypertarget{classAlphaISA_1_1TLB_a82eefd07de8b39b6a974a2b03174999a}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!EntryCache@{EntryCache}}
\index{EntryCache@{EntryCache}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{EntryCache}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TlbEntry}$\ast$ {\bf EntryCache}\mbox{[}3\mbox{]}}}
\label{classAlphaISA_1_1TLB_a82eefd07de8b39b6a974a2b03174999a}
\hypertarget{classAlphaISA_1_1TLB_ae73b1ec9b8b461b5c5b0f1f903692418}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!fetch\_\-accesses@{fetch\_\-accesses}}
\index{fetch\_\-accesses@{fetch\_\-accesses}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{fetch\_\-accesses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf fetch\_\-accesses}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_ae73b1ec9b8b461b5c5b0f1f903692418}
\hypertarget{classAlphaISA_1_1TLB_a91197c087b25a1ccf96a6c15523b6d1a}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!fetch\_\-acv@{fetch\_\-acv}}
\index{fetch\_\-acv@{fetch\_\-acv}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{fetch\_\-acv}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetch\_\-acv}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a91197c087b25a1ccf96a6c15523b6d1a}
\hypertarget{classAlphaISA_1_1TLB_a41b41877cc14c93d0663a37014aaa605}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!fetch\_\-hits@{fetch\_\-hits}}
\index{fetch\_\-hits@{fetch\_\-hits}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{fetch\_\-hits}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetch\_\-hits}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a41b41877cc14c93d0663a37014aaa605}
\hypertarget{classAlphaISA_1_1TLB_a5801332ce26351763f996ea8aa050a96}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!fetch\_\-misses@{fetch\_\-misses}}
\index{fetch\_\-misses@{fetch\_\-misses}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{fetch\_\-misses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetch\_\-misses}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a5801332ce26351763f996ea8aa050a96}
\hypertarget{classAlphaISA_1_1TLB_a4d5c35d797dc31aad758dee75916238f}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!lookupTable@{lookupTable}}
\index{lookupTable@{lookupTable}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{lookupTable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PageTable} {\bf lookupTable}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a4d5c35d797dc31aad758dee75916238f}
\hypertarget{classAlphaISA_1_1TLB_a4a3ee7780f871ead437ece349ddc2147}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!nlu@{nlu}}
\index{nlu@{nlu}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{nlu}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf nlu}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a4a3ee7780f871ead437ece349ddc2147}
\hypertarget{classAlphaISA_1_1TLB_a2c9dc5a6baf7fbd1ae7fc00b0a57fe56}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!read\_\-accesses@{read\_\-accesses}}
\index{read\_\-accesses@{read\_\-accesses}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{read\_\-accesses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf read\_\-accesses}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a2c9dc5a6baf7fbd1ae7fc00b0a57fe56}
\hypertarget{classAlphaISA_1_1TLB_af50813bd757bd59aa3618aa99377760a}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!read\_\-acv@{read\_\-acv}}
\index{read\_\-acv@{read\_\-acv}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{read\_\-acv}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf read\_\-acv}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_af50813bd757bd59aa3618aa99377760a}
\hypertarget{classAlphaISA_1_1TLB_a766fdbd2ab7d588c3c9fa426ce395ed6}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!read\_\-hits@{read\_\-hits}}
\index{read\_\-hits@{read\_\-hits}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{read\_\-hits}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf read\_\-hits}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a766fdbd2ab7d588c3c9fa426ce395ed6}
\hypertarget{classAlphaISA_1_1TLB_a6fb393c9489d735739552c2a351f07f4}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!read\_\-misses@{read\_\-misses}}
\index{read\_\-misses@{read\_\-misses}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{read\_\-misses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf read\_\-misses}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a6fb393c9489d735739552c2a351f07f4}
\hypertarget{classAlphaISA_1_1TLB_a439227feff9d7f55384e8780cfc2eb82}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!size@{size}}
\index{size@{size}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{size}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf size}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a439227feff9d7f55384e8780cfc2eb82}
\hypertarget{classAlphaISA_1_1TLB_a434ae74dec9e8168e4f338aeb18d5931}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!table@{table}}
\index{table@{table}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{table}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TlbEntry}$\ast$ {\bf table}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a434ae74dec9e8168e4f338aeb18d5931}
\hypertarget{classAlphaISA_1_1TLB_af3301e9dd0bb91de161b7bafefade7f3}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!write\_\-accesses@{write\_\-accesses}}
\index{write\_\-accesses@{write\_\-accesses}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{write\_\-accesses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf write\_\-accesses}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_af3301e9dd0bb91de161b7bafefade7f3}
\hypertarget{classAlphaISA_1_1TLB_a764f5ef97bfcb1ba3ad05704de5a3a32}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!write\_\-acv@{write\_\-acv}}
\index{write\_\-acv@{write\_\-acv}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{write\_\-acv}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf write\_\-acv}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_a764f5ef97bfcb1ba3ad05704de5a3a32}
\hypertarget{classAlphaISA_1_1TLB_ab3172bfd014e75dcad1b0a2a91de59dd}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!write\_\-hits@{write\_\-hits}}
\index{write\_\-hits@{write\_\-hits}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{write\_\-hits}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf write\_\-hits}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_ab3172bfd014e75dcad1b0a2a91de59dd}
\hypertarget{classAlphaISA_1_1TLB_af8519a07f8f1f76c8fff9c9a1aaa4638}{
\index{AlphaISA::TLB@{AlphaISA::TLB}!write\_\-misses@{write\_\-misses}}
\index{write\_\-misses@{write\_\-misses}!AlphaISA::TLB@{AlphaISA::TLB}}
\subsubsection[{write\_\-misses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf write\_\-misses}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}
\label{classAlphaISA_1_1TLB_af8519a07f8f1f76c8fff9c9a1aaa4638}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/alpha/\hyperlink{arch_2alpha_2tlb_8hh}{tlb.hh}\item 
arch/alpha/\hyperlink{arch_2alpha_2tlb_8cc}{tlb.cc}\end{DoxyCompactItemize}
