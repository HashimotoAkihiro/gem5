\hypertarget{classX86ISA_1_1I8259}{
\section{クラス I8259}
\label{classX86ISA_1_1I8259}\index{X86ISA::I8259@{X86ISA::I8259}}
}


{\ttfamily \#include $<$i8259.hh$>$}I8259に対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=7cm]{classX86ISA_1_1I8259}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef I8259Params \hyperlink{classX86ISA_1_1I8259_a370f3ee3a425cd3262c46d09b80327fe}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
const \hyperlink{classX86ISA_1_1I8259_a370f3ee3a425cd3262c46d09b80327fe}{Params} $\ast$ \hyperlink{classX86ISA_1_1I8259_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{classX86ISA_1_1I8259_aa1c12bc35b1690e4820a82dedc82a062}{I8259} (\hyperlink{classX86ISA_1_1I8259_a370f3ee3a425cd3262c46d09b80327fe}{Params} $\ast$\hyperlink{namespaceX86ISA_af675c1d542a25b96e11164b80809a856}{p})
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classX86ISA_1_1I8259_a613ec7d5e1ec64f8d21fec78ae8e568e}{read} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classX86ISA_1_1I8259_a4cefab464e72b5dd42c003a0a4341802}{write} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classX86ISA_1_1I8259_ae0783eb10ff8764efd2be0ef4adac66b}{maskAll} ()
\item 
void \hyperlink{classX86ISA_1_1I8259_a08091cbfeb72a8155e4a7fc5b93defa8}{unmaskAll} ()
\item 
void \hyperlink{classX86ISA_1_1I8259_a9d80b13f2832340962ab374bc9a14c4f}{signalInterrupt} (int line)
\item 
void \hyperlink{classX86ISA_1_1I8259_ac26dfa4264d910f3ef50015beafea211}{raiseInterruptPin} (int number)
\item 
void \hyperlink{classX86ISA_1_1I8259_a41406df644356ee1578b77b1acd18042}{lowerInterruptPin} (int number)
\item 
int \hyperlink{classX86ISA_1_1I8259_a26bce2cbf4beafc63b23e5d0fbf140b8}{getVector} ()
\item 
virtual void \hyperlink{classX86ISA_1_1I8259_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&\hyperlink{namespaceX86ISA_a6b6e6ba763e7eaf46ac5b6372ca98d30}{os})
\item 
virtual void \hyperlink{classX86ISA_1_1I8259_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classX86ISA_1_1I8259_a432db50d8e5302081e6d1dec35a7a963}{requestInterrupt} (int line)
\item 
void \hyperlink{classX86ISA_1_1I8259_a98fd3afbe3f7046e1b5d9d9f928b8482}{handleEOI} (int line)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classX86ISA_1_1I8259_a0cfba6b99782832feb54152b679f416b}{pinStates} \mbox{[}\hyperlink{classX86ISA_1_1I8259_a394ed08d7eedb814e519387710d14243}{NumLines}\mbox{]}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classX86ISA_1_1I8259_ac8d8966078cc047949fd1bca8feb21b6}{latency}
\item 
\hyperlink{classX86ISA_1_1IntSourcePin}{IntSourcePin} $\ast$ \hyperlink{classX86ISA_1_1I8259_a4a4fd7b72e62a3c4ab95cb11fc722c39}{output}
\item 
Enums::X86I8259CascadeMode \hyperlink{classX86ISA_1_1I8259_a7a104649c5cfddf388e2176ea01ee60a}{mode}
\item 
\hyperlink{classX86ISA_1_1I8259}{I8259} $\ast$ \hyperlink{classX86ISA_1_1I8259_a8c6f2e957037d32e002591662762b0b9}{slave}
\item 
uint8\_\-t \hyperlink{classX86ISA_1_1I8259_a3a6aa8a662aa901296e6ee90e345354b}{IRR}
\item 
uint8\_\-t \hyperlink{classX86ISA_1_1I8259_ac8961b62ac66b7dc8dea1d7285864393}{ISR}
\item 
uint8\_\-t \hyperlink{classX86ISA_1_1I8259_a08462597fc835560f5d4103a0c7684ce}{IMR}
\item 
uint8\_\-t \hyperlink{classX86ISA_1_1I8259_a0dab9c49a4355dabc77b494a0f2ee7af}{vectorOffset}
\item 
bool \hyperlink{classX86ISA_1_1I8259_a9d88ee8939dbad3f6bc3fd19a7ab5cbf}{cascadeMode}
\item 
uint8\_\-t \hyperlink{classX86ISA_1_1I8259_a452774b3f7a251c0ab94933cdd9cf850}{cascadeBits}
\item 
bool \hyperlink{classX86ISA_1_1I8259_a60290bd6fbff9031bf6c9ee4fd498f1d}{edgeTriggered}
\item 
bool \hyperlink{classX86ISA_1_1I8259_a6e286ff90731d05a67b6e48701b35cb8}{readIRR}
\item 
bool \hyperlink{classX86ISA_1_1I8259_ae6e7ac9619987193c010dc534cdbcac0}{expectICW4}
\item 
int \hyperlink{classX86ISA_1_1I8259_a73a298dcdb4f7e881c60561a06b9d0c1}{initControlWord}
\item 
bool \hyperlink{classX86ISA_1_1I8259_ae34d3675f724192acf53ead552d94230}{autoEOI}
\end{DoxyCompactItemize}
\subsection*{Static Protected 変数}
\begin{DoxyCompactItemize}
\item 
static const int \hyperlink{classX86ISA_1_1I8259_a394ed08d7eedb814e519387710d14243}{NumLines} = 8
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classX86ISA_1_1I8259_a370f3ee3a425cd3262c46d09b80327fe}{
\index{X86ISA::I8259@{X86ISA::I8259}!Params@{Params}}
\index{Params@{Params}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef I8259Params {\bf Params}}}
\label{classX86ISA_1_1I8259_a370f3ee3a425cd3262c46d09b80327fe}


\hyperlink{classBasicPioDevice_a2845515ac6467f10540747053c8a0449}{BasicPioDevice}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classX86ISA_1_1I8259_aa1c12bc35b1690e4820a82dedc82a062}{
\index{X86ISA::I8259@{X86ISA::I8259}!I8259@{I8259}}
\index{I8259@{I8259}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{I8259}]{\setlength{\rightskip}{0pt plus 5cm}{\bf I8259} ({\bf Params} $\ast$ {\em p})}}
\label{classX86ISA_1_1I8259_aa1c12bc35b1690e4820a82dedc82a062}



\begin{DoxyCode}
39     : BasicPioDevice(p, 2), IntDevice(this),
40       latency(p->pio_latency), output(p->output),
41       mode(p->mode), slave(p->slave),
42       IRR(0), ISR(0), IMR(0),
43       readIRR(true), initControlWord(0), autoEOI(false)
44 {
45     for (int i = 0; i < NumLines; i++)
46         pinStates[i] = false;
47 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classX86ISA_1_1I8259_a26bce2cbf4beafc63b23e5d0fbf140b8}{
\index{X86ISA::I8259@{X86ISA::I8259}!getVector@{getVector}}
\index{getVector@{getVector}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{getVector}]{\setlength{\rightskip}{0pt plus 5cm}int getVector ()}}
\label{classX86ISA_1_1I8259_a26bce2cbf4beafc63b23e5d0fbf140b8}



\begin{DoxyCode}
284 {
285     /*
286      * This code only handles one slave. Since that's how the PC platform
287      * always uses the 8259 PIC, there shouldn't be any need for more. If
288      * there -is- a need for more for some reason, "slave" can become a
289      * vector of slaves.
290      */
291     int line = findMsbSet(IRR);
292     IRR &= ~(1 << line);
293     DPRINTF(I8259, "Interrupt %d was accepted.\n", line);
294     if (autoEOI) {
295         handleEOI(line);
296     } else {
297         ISR |= 1 << line;
298     }
299     if (slave && bits(cascadeBits, line)) {
300         DPRINTF(I8259, "Interrupt was from slave who will "
301                 "provide the vector.\n");
302         return slave->getVector();
303     }
304     return line | vectorOffset;
305 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1I8259_a98fd3afbe3f7046e1b5d9d9f928b8482}{
\index{X86ISA::I8259@{X86ISA::I8259}!handleEOI@{handleEOI}}
\index{handleEOI@{handleEOI}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{handleEOI}]{\setlength{\rightskip}{0pt plus 5cm}void handleEOI (int {\em line})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_a98fd3afbe3f7046e1b5d9d9f928b8482}



\begin{DoxyCode}
221 {
222     ISR &= ~(1 << line);
223     // There may be an interrupt that was waiting which can
224     // now be sent.
225     if (IRR)
226         requestInterrupt(findMsbSet(IRR));
227 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1I8259_a41406df644356ee1578b77b1acd18042}{
\index{X86ISA::I8259@{X86ISA::I8259}!lowerInterruptPin@{lowerInterruptPin}}
\index{lowerInterruptPin@{lowerInterruptPin}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{lowerInterruptPin}]{\setlength{\rightskip}{0pt plus 5cm}void lowerInterruptPin (int {\em number})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1I8259_a41406df644356ee1578b77b1acd18042}


\hyperlink{classX86ISA_1_1IntDevice_a1909001c0927e6a93d8bebf9d30bc11c}{IntDevice}を再定義しています。


\begin{DoxyCode}
274 {
275     DPRINTF(I8259, "Interrupt signal lowered for pin %d.\n", number);
276     if (number >= NumLines)
277         fatal("Line number %d doesn't exist. The max is %d.\n",
278                 number, NumLines - 1);
279     pinStates[number] = false;
280 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1I8259_ae0783eb10ff8764efd2be0ef4adac66b}{
\index{X86ISA::I8259@{X86ISA::I8259}!maskAll@{maskAll}}
\index{maskAll@{maskAll}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{maskAll}]{\setlength{\rightskip}{0pt plus 5cm}void maskAll ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1I8259_ae0783eb10ff8764efd2be0ef4adac66b}



\begin{DoxyCode}
97     {
98         IMR = 0xFF;
99     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1I8259_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{X86ISA::I8259@{X86ISA::I8259}!params@{params}}
\index{params@{params}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1I8259_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classBasicPioDevice_acd3c3feb78ae7a8f88fe0f110a718dff}{BasicPioDevice}を再定義しています。


\begin{DoxyCode}
86     {
87         return dynamic_cast<const Params *>(_params);
88     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1I8259_ac26dfa4264d910f3ef50015beafea211}{
\index{X86ISA::I8259@{X86ISA::I8259}!raiseInterruptPin@{raiseInterruptPin}}
\index{raiseInterruptPin@{raiseInterruptPin}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{raiseInterruptPin}]{\setlength{\rightskip}{0pt plus 5cm}void raiseInterruptPin (int {\em number})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1I8259_ac26dfa4264d910f3ef50015beafea211}


\hyperlink{classX86ISA_1_1IntDevice_a4bafbbd02159d7bdc6eae7f4197db84f}{IntDevice}を再定義しています。


\begin{DoxyCode}
262 {
263     DPRINTF(I8259, "Interrupt signal raised for pin %d.\n", number);
264     if (number >= NumLines)
265         fatal("Line number %d doesn't exist. The max is %d.\n",
266                 number, NumLines - 1);
267     if (!pinStates[number])
268         signalInterrupt(number);
269     pinStates[number] = true;
270 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1I8259_a613ec7d5e1ec64f8d21fec78ae8e568e}{
\index{X86ISA::I8259@{X86ISA::I8259}!read@{read}}
\index{read@{read}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} read ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1I8259_a613ec7d5e1ec64f8d21fec78ae8e568e}
Pure virtual function that the device must implement. Called when a read command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_a842312590432036092c422c87a442358}{PioDevice}を実装しています。


\begin{DoxyCode}
51 {
52     assert(pkt->getSize() == 1);
53     switch(pkt->getAddr() - pioAddr)
54     {
55       case 0x0:
56         if (readIRR) {
57             DPRINTF(I8259, "Reading IRR as %#x.\n", IRR);
58             pkt->set(IRR);
59         } else {
60             DPRINTF(I8259, "Reading ISR as %#x.\n", ISR);
61             pkt->set(ISR);
62         }
63         break;
64       case 0x1:
65         DPRINTF(I8259, "Reading IMR as %#x.\n", IMR);
66         pkt->set(IMR);
67         break;
68     }
69     pkt->makeAtomicResponse();
70     return latency;
71 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1I8259_a432db50d8e5302081e6d1dec35a7a963}{
\index{X86ISA::I8259@{X86ISA::I8259}!requestInterrupt@{requestInterrupt}}
\index{requestInterrupt@{requestInterrupt}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{requestInterrupt}]{\setlength{\rightskip}{0pt plus 5cm}void requestInterrupt (int {\em line})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_a432db50d8e5302081e6d1dec35a7a963}



\begin{DoxyCode}
231 {
232     if (bits(ISR, 7, line) == 0) {
233         if (output) {
234             DPRINTF(I8259, "Propogating interrupt.\n");
235             output->raise();
236             //XXX This is a hack.
237             output->lower();
238         } else {
239             warn("Received interrupt but didn't have "
240                     "anyone to tell about it.\n");
241         }
242     }
243 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1I8259_a53e036786d17361be4c7320d39c99b84}{
\index{X86ISA::I8259@{X86ISA::I8259}!serialize@{serialize}}
\index{serialize@{serialize}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1I8259_a53e036786d17361be4c7320d39c99b84}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。


\begin{DoxyCode}
309 {
310     SERIALIZE_ARRAY(pinStates, NumLines);
311     SERIALIZE_ENUM(mode);
312     SERIALIZE_SCALAR(IRR);
313     SERIALIZE_SCALAR(ISR);
314     SERIALIZE_SCALAR(IMR);
315     SERIALIZE_SCALAR(vectorOffset);
316     SERIALIZE_SCALAR(cascadeMode);
317     SERIALIZE_SCALAR(cascadeBits);
318     SERIALIZE_SCALAR(edgeTriggered);
319     SERIALIZE_SCALAR(readIRR);
320     SERIALIZE_SCALAR(expectICW4);
321     SERIALIZE_SCALAR(initControlWord);
322     SERIALIZE_SCALAR(autoEOI);
323 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1I8259_a9d80b13f2832340962ab374bc9a14c4f}{
\index{X86ISA::I8259@{X86ISA::I8259}!signalInterrupt@{signalInterrupt}}
\index{signalInterrupt@{signalInterrupt}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{signalInterrupt}]{\setlength{\rightskip}{0pt plus 5cm}void signalInterrupt (int {\em line})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1I8259_a9d80b13f2832340962ab374bc9a14c4f}


\hyperlink{classX86ISA_1_1IntDevice_a10c7e7cffe2e50c6c515fa1d8f0a4460}{IntDevice}を再定義しています。


\begin{DoxyCode}
247 {
248     DPRINTF(I8259, "Interrupt requested for line %d.\n", line);
249     if (line >= NumLines)
250         fatal("Line number %d doesn't exist. The max is %d.\n",
251                 line, NumLines - 1);
252     if (bits(IMR, line)) {
253         DPRINTF(I8259, "Interrupt %d was masked.\n", line);
254     } else {
255         IRR |= 1 << line;
256         requestInterrupt(line);
257     }
258 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1I8259_a08091cbfeb72a8155e4a7fc5b93defa8}{
\index{X86ISA::I8259@{X86ISA::I8259}!unmaskAll@{unmaskAll}}
\index{unmaskAll@{unmaskAll}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{unmaskAll}]{\setlength{\rightskip}{0pt plus 5cm}void unmaskAll ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1I8259_a08091cbfeb72a8155e4a7fc5b93defa8}



\begin{DoxyCode}
103     {
104         IMR = 0x00;
105     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1I8259_af22e5d6d660b97db37003ac61ac4ee49}{
\index{X86ISA::I8259@{X86ISA::I8259}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1I8259_af22e5d6d660b97db37003ac61ac4ee49}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。


\begin{DoxyCode}
327 {
328     UNSERIALIZE_ARRAY(pinStates, NumLines);
329     UNSERIALIZE_ENUM(mode);
330     UNSERIALIZE_SCALAR(IRR);
331     UNSERIALIZE_SCALAR(ISR);
332     UNSERIALIZE_SCALAR(IMR);
333     UNSERIALIZE_SCALAR(vectorOffset);
334     UNSERIALIZE_SCALAR(cascadeMode);
335     UNSERIALIZE_SCALAR(cascadeBits);
336     UNSERIALIZE_SCALAR(edgeTriggered);
337     UNSERIALIZE_SCALAR(readIRR);
338     UNSERIALIZE_SCALAR(expectICW4);
339     UNSERIALIZE_SCALAR(initControlWord);
340     UNSERIALIZE_SCALAR(autoEOI);
341 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1I8259_a4cefab464e72b5dd42c003a0a4341802}{
\index{X86ISA::I8259@{X86ISA::I8259}!write@{write}}
\index{write@{write}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} write ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1I8259_a4cefab464e72b5dd42c003a0a4341802}
Pure virtual function that the device must implement. Called when a write command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_afe8371668d023bb2516b286e5e399b6f}{PioDevice}を実装しています。


\begin{DoxyCode}
75 {
76     assert(pkt->getSize() == 1);
77     uint8_t val = pkt->get<uint8_t>();
78     switch (pkt->getAddr() - pioAddr) {
79       case 0x0:
80         if (bits(val, 4)) {
81             DPRINTF(I8259, "Received initialization command word 1.\n");
82             IMR = 0;
83             edgeTriggered = bits(val, 3);
84             DPRINTF(I8259, "%s triggered mode.\n",
85                     edgeTriggered ? "Edge" : "Level");
86             cascadeMode = !bits(val, 1);
87             DPRINTF(I8259, "%s mode.\n",
88                     cascadeMode ? "Cascade" : "Single");
89             expectICW4 = bits(val, 0);
90             if (!expectICW4) {
91                 autoEOI = false;
92             }
93             initControlWord = 1;
94             DPRINTF(I8259, "Expecting %d more bytes.\n", expectICW4 ? 3 : 2);
95         } else if (bits(val, 4, 3) == 0) {
96             DPRINTF(I8259, "Received operation command word 2.\n");
97             switch (bits(val, 7, 5)) {
98               case 0x0:
99                 DPRINTF(I8259,
100                         "Subcommand: Rotate in auto-EOI mode (clear).\n");
101                 break;
102               case 0x1:
103                 {
104                     int line = findMsbSet(ISR);
105                     DPRINTF(I8259, "Subcommand: Nonspecific EOI on line %d.\n",
106                             line);
107                     handleEOI(line);
108                 }
109                 break;
110               case 0x2:
111                 DPRINTF(I8259, "Subcommand: No operation.\n");
112                 break;
113               case 0x3:
114                 {
115                     int line = bits(val, 2, 0);
116                     DPRINTF(I8259, "Subcommand: Specific EIO on line %d.\n",
117                             line);
118                     handleEOI(line);
119                 }
120                 break;
121               case 0x4:
122                 DPRINTF(I8259, "Subcommand: Rotate in auto-EOI mode (set).\n");
123                 break;
124               case 0x5:
125                 DPRINTF(I8259, "Subcommand: Rotate on nonspecific EOI.\n");
126                 break;
127               case 0x6:
128                 DPRINTF(I8259, "Subcommand: Set priority command.\n");
129                 DPRINTF(I8259, "Lowest: IRQ%d   Highest IRQ%d.\n",
130                         bits(val, 2, 0), (bits(val, 2, 0) + 1) % 8);
131                 break;
132               case 0x7:
133                 DPRINTF(I8259, "Subcommand: Rotate on specific EOI.\n");
134                 DPRINTF(I8259, "Lowest: IRQ%d   Highest IRQ%d.\n",
135                         bits(val, 2, 0), (bits(val, 2, 0) + 1) % 8);
136                 break;
137             }
138         } else if (bits(val, 4, 3) == 1) {
139             DPRINTF(I8259, "Received operation command word 3.\n");
140             if (bits(val, 7)) {
141                 DPRINTF(I8259, "%s special mask mode.\n",
142                         bits(val, 6) ? "Set" : "Clear");
143             }
144             if (bits(val, 1)) {
145                 readIRR = bits(val, 0);
146                 DPRINTF(I8259, "Read %s.\n", readIRR ? "IRR" : "ISR");
147             }
148         }
149         break;
150       case 0x1:
151         switch (initControlWord) {
152           case 0x0:
153             DPRINTF(I8259, "Received operation command word 1.\n");
154             DPRINTF(I8259, "Wrote IMR value %#x.\n", val);
155             IMR = val;
156             break;
157           case 0x1:
158             DPRINTF(I8259, "Received initialization command word 2.\n");
159             vectorOffset = val & ~mask(3);
160             DPRINTF(I8259, "Responsible for vectors %#x-%#x.\n",
161                     vectorOffset, vectorOffset | mask(3));
162             if (cascadeMode) {
163                 initControlWord++;
164             } else {
165                 cascadeBits = 0;
166                 initControlWord = 0;
167             }
168             break;
169           case 0x2:
170             DPRINTF(I8259, "Received initialization command word 3.\n");
171             if (mode == Enums::I8259Master) {
172                 DPRINTF(I8259, "Slaves attached to IRQs:%s%s%s%s%s%s%s%s\n",
173                         bits(val, 0) ? " 0" : "",
174                         bits(val, 1) ? " 1" : "",
175                         bits(val, 2) ? " 2" : "",
176                         bits(val, 3) ? " 3" : "",
177                         bits(val, 4) ? " 4" : "",
178                         bits(val, 5) ? " 5" : "",
179                         bits(val, 6) ? " 6" : "",
180                         bits(val, 7) ? " 7" : "");
181                 cascadeBits = val;
182             } else {
183                 DPRINTF(I8259, "Slave ID is %d.\n", val & mask(3));
184                 cascadeBits = val & mask(3);
185             }
186             if (expectICW4)
187                 initControlWord++;
188             else
189                 initControlWord = 0;
190             break;
191           case 0x3:
192             DPRINTF(I8259, "Received initialization command word 4.\n");
193             if (bits(val, 4)) {
194                 DPRINTF(I8259, "Special fully nested mode.\n");
195             } else {
196                 DPRINTF(I8259, "Not special fully nested mode.\n");
197             }
198             if (bits(val, 3) == 0) {
199                 DPRINTF(I8259, "Nonbuffered.\n");
200             } else if (bits(val, 2) == 0) {
201                 DPRINTF(I8259, "Buffered.\n");
202             } else {
203                 DPRINTF(I8259, "Unrecognized buffer mode.\n");
204             }
205             autoEOI = bits(val, 1);
206             DPRINTF(I8259, "%s End Of Interrupt.\n",
207                     autoEOI ? "Automatic" : "Normal");
208 
209             DPRINTF(I8259, "%s mode.\n", bits(val, 0) ? "80x86" : "MCX-80/85");
210             initControlWord = 0;
211             break;
212         }
213         break;
214     }
215     pkt->makeAtomicResponse();
216     return latency;
217 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classX86ISA_1_1I8259_ae34d3675f724192acf53ead552d94230}{
\index{X86ISA::I8259@{X86ISA::I8259}!autoEOI@{autoEOI}}
\index{autoEOI@{autoEOI}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{autoEOI}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf autoEOI}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_ae34d3675f724192acf53ead552d94230}
\hypertarget{classX86ISA_1_1I8259_a452774b3f7a251c0ab94933cdd9cf850}{
\index{X86ISA::I8259@{X86ISA::I8259}!cascadeBits@{cascadeBits}}
\index{cascadeBits@{cascadeBits}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{cascadeBits}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf cascadeBits}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_a452774b3f7a251c0ab94933cdd9cf850}
\hypertarget{classX86ISA_1_1I8259_a9d88ee8939dbad3f6bc3fd19a7ab5cbf}{
\index{X86ISA::I8259@{X86ISA::I8259}!cascadeMode@{cascadeMode}}
\index{cascadeMode@{cascadeMode}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{cascadeMode}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf cascadeMode}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_a9d88ee8939dbad3f6bc3fd19a7ab5cbf}
\hypertarget{classX86ISA_1_1I8259_a60290bd6fbff9031bf6c9ee4fd498f1d}{
\index{X86ISA::I8259@{X86ISA::I8259}!edgeTriggered@{edgeTriggered}}
\index{edgeTriggered@{edgeTriggered}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{edgeTriggered}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf edgeTriggered}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_a60290bd6fbff9031bf6c9ee4fd498f1d}
\hypertarget{classX86ISA_1_1I8259_ae6e7ac9619987193c010dc534cdbcac0}{
\index{X86ISA::I8259@{X86ISA::I8259}!expectICW4@{expectICW4}}
\index{expectICW4@{expectICW4}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{expectICW4}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf expectICW4}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_ae6e7ac9619987193c010dc534cdbcac0}
\hypertarget{classX86ISA_1_1I8259_a08462597fc835560f5d4103a0c7684ce}{
\index{X86ISA::I8259@{X86ISA::I8259}!IMR@{IMR}}
\index{IMR@{IMR}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{IMR}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf IMR}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_a08462597fc835560f5d4103a0c7684ce}
\hypertarget{classX86ISA_1_1I8259_a73a298dcdb4f7e881c60561a06b9d0c1}{
\index{X86ISA::I8259@{X86ISA::I8259}!initControlWord@{initControlWord}}
\index{initControlWord@{initControlWord}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{initControlWord}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf initControlWord}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_a73a298dcdb4f7e881c60561a06b9d0c1}
\hypertarget{classX86ISA_1_1I8259_a3a6aa8a662aa901296e6ee90e345354b}{
\index{X86ISA::I8259@{X86ISA::I8259}!IRR@{IRR}}
\index{IRR@{IRR}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{IRR}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf IRR}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_a3a6aa8a662aa901296e6ee90e345354b}
\hypertarget{classX86ISA_1_1I8259_ac8961b62ac66b7dc8dea1d7285864393}{
\index{X86ISA::I8259@{X86ISA::I8259}!ISR@{ISR}}
\index{ISR@{ISR}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{ISR}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf ISR}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_ac8961b62ac66b7dc8dea1d7285864393}
\hypertarget{classX86ISA_1_1I8259_ac8d8966078cc047949fd1bca8feb21b6}{
\index{X86ISA::I8259@{X86ISA::I8259}!latency@{latency}}
\index{latency@{latency}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{latency}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf latency}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_ac8d8966078cc047949fd1bca8feb21b6}
\hypertarget{classX86ISA_1_1I8259_a7a104649c5cfddf388e2176ea01ee60a}{
\index{X86ISA::I8259@{X86ISA::I8259}!mode@{mode}}
\index{mode@{mode}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{mode}]{\setlength{\rightskip}{0pt plus 5cm}Enums::X86I8259CascadeMode {\bf mode}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_a7a104649c5cfddf388e2176ea01ee60a}
\hypertarget{classX86ISA_1_1I8259_a394ed08d7eedb814e519387710d14243}{
\index{X86ISA::I8259@{X86ISA::I8259}!NumLines@{NumLines}}
\index{NumLines@{NumLines}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{NumLines}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf NumLines} = 8\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_a394ed08d7eedb814e519387710d14243}
\hypertarget{classX86ISA_1_1I8259_a4a4fd7b72e62a3c4ab95cb11fc722c39}{
\index{X86ISA::I8259@{X86ISA::I8259}!output@{output}}
\index{output@{output}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{output}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IntSourcePin}$\ast$ {\bf output}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_a4a4fd7b72e62a3c4ab95cb11fc722c39}
\hypertarget{classX86ISA_1_1I8259_a0cfba6b99782832feb54152b679f416b}{
\index{X86ISA::I8259@{X86ISA::I8259}!pinStates@{pinStates}}
\index{pinStates@{pinStates}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{pinStates}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf pinStates}\mbox{[}{\bf NumLines}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_a0cfba6b99782832feb54152b679f416b}
\hypertarget{classX86ISA_1_1I8259_a6e286ff90731d05a67b6e48701b35cb8}{
\index{X86ISA::I8259@{X86ISA::I8259}!readIRR@{readIRR}}
\index{readIRR@{readIRR}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{readIRR}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf readIRR}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_a6e286ff90731d05a67b6e48701b35cb8}
\hypertarget{classX86ISA_1_1I8259_a8c6f2e957037d32e002591662762b0b9}{
\index{X86ISA::I8259@{X86ISA::I8259}!slave@{slave}}
\index{slave@{slave}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{slave}]{\setlength{\rightskip}{0pt plus 5cm}{\bf I8259}$\ast$ {\bf slave}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_a8c6f2e957037d32e002591662762b0b9}
\hypertarget{classX86ISA_1_1I8259_a0dab9c49a4355dabc77b494a0f2ee7af}{
\index{X86ISA::I8259@{X86ISA::I8259}!vectorOffset@{vectorOffset}}
\index{vectorOffset@{vectorOffset}!X86ISA::I8259@{X86ISA::I8259}}
\subsubsection[{vectorOffset}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf vectorOffset}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1I8259_a0dab9c49a4355dabc77b494a0f2ee7af}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/x86/\hyperlink{i8259_8hh}{i8259.hh}\item 
dev/x86/\hyperlink{i8259_8cc}{i8259.cc}\end{DoxyCompactItemize}
