\hypertarget{classRubyPort_1_1MemSlavePort}{
\section{クラス MemSlavePort}
\label{classRubyPort_1_1MemSlavePort}\index{RubyPort::MemSlavePort@{RubyPort::MemSlavePort}}
}


{\ttfamily \#include $<$RubyPort.hh$>$}MemSlavePortに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=5cm]{classRubyPort_1_1MemSlavePort}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classRubyPort_1_1MemSlavePort_a898fd995c2b8563d692931dc72e50010}{MemSlavePort} (const std::string \&\_\-name, \hyperlink{classRubyPort}{RubyPort} $\ast$\_\-port, \hyperlink{classRubySystem}{RubySystem} $\ast$\_\-system, bool \_\-access\_\-phys\_\-mem, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} \hyperlink{classPort_a0a67444fc1c33a60fe4a92bfff05d0cb}{id})
\item 
void \hyperlink{classRubyPort_1_1MemSlavePort_a24a8f9c1806a15d53eddd6a70d9b3e31}{hitCallback} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classRubyPort_1_1MemSlavePort_a3af79aeefd596a230ebc3a579fcc3fb1}{evictionCallback} (const \hyperlink{classAddress}{Address} \&address)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classRubyPort_1_1MemSlavePort_a3344d9dd0f83257feab5424e761f31c6}{recvTimingReq} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classRubyPort_1_1MemSlavePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{recvAtomic} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classRubyPort_1_1MemSlavePort_aeefa907fb6d6a787e6dab90e8138ea90}{recvFunctional} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classRubyPort_1_1MemSlavePort_a36cf113d5e5e091ebddb32306c098fae}{getAddrRanges} () const 
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classRubyPort_1_1MemSlavePort_aa1da2f433965694958a83f76fcf4adc2}{isPhysMemAddress} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr) const 
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSlavePacketQueue}{SlavePacketQueue} \hyperlink{classRubyPort_1_1MemSlavePort_a3055168363a9ed42f38173363b6c1975}{queue}
\item 
\hyperlink{classRubySystem}{RubySystem} $\ast$ \hyperlink{classRubyPort_1_1MemSlavePort_a88928242e9a532cb6f4abe42dd8240a7}{ruby\_\-system}
\item 
bool \hyperlink{classRubyPort_1_1MemSlavePort_a5925f629d4ec58811bba7c4fa6b4d64d}{access\_\-phys\_\-mem}
\end{DoxyCompactItemize}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classRubyPort_1_1MemSlavePort_a898fd995c2b8563d692931dc72e50010}{
\index{RubyPort::MemSlavePort@{RubyPort::MemSlavePort}!MemSlavePort@{MemSlavePort}}
\index{MemSlavePort@{MemSlavePort}!RubyPort::MemSlavePort@{RubyPort::MemSlavePort}}
\subsubsection[{MemSlavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemSlavePort} (const std::string \& {\em \_\-name}, \/  {\bf RubyPort} $\ast$ {\em \_\-port}, \/  {\bf RubySystem} $\ast$ {\em \_\-system}, \/  bool {\em \_\-access\_\-phys\_\-mem}, \/  {\bf PortID} {\em id})}}
\label{classRubyPort_1_1MemSlavePort_a898fd995c2b8563d692931dc72e50010}



\begin{DoxyCode}
158     : QueuedSlavePort(_name, _port, queue, id), queue(*_port, *this),
159       ruby_system(_system), access_phys_mem(_access_phys_mem)
160 {
161     DPRINTF(RubyPort, "Created slave memport on ruby sequencer %s\n", _name);
162 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classRubyPort_1_1MemSlavePort_a3af79aeefd596a230ebc3a579fcc3fb1}{
\index{RubyPort::MemSlavePort@{RubyPort::MemSlavePort}!evictionCallback@{evictionCallback}}
\index{evictionCallback@{evictionCallback}!RubyPort::MemSlavePort@{RubyPort::MemSlavePort}}
\subsubsection[{evictionCallback}]{\setlength{\rightskip}{0pt plus 5cm}void evictionCallback (const {\bf Address} \& {\em address})}}
\label{classRubyPort_1_1MemSlavePort_a3af79aeefd596a230ebc3a579fcc3fb1}
\hypertarget{classRubyPort_1_1MemSlavePort_a36cf113d5e5e091ebddb32306c098fae}{
\index{RubyPort::MemSlavePort@{RubyPort::MemSlavePort}!getAddrRanges@{getAddrRanges}}
\index{getAddrRanges@{getAddrRanges}!RubyPort::MemSlavePort@{RubyPort::MemSlavePort}}
\subsubsection[{getAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRangeList} getAddrRanges () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classRubyPort_1_1MemSlavePort_a36cf113d5e5e091ebddb32306c098fae}
Get a list of the non-\/overlapping address ranges the owner is responsible for. All slave ports must override this function and return a populated list with at least one item.

\begin{DoxyReturn}{戻り値}
a list of ranges responded to 
\end{DoxyReturn}


\hyperlink{classSlavePort_a6e967f8921e80748eb2be35b6b481a7e}{SlavePort}を実装しています。


\begin{DoxyCode}
96         { AddrRangeList ranges; return ranges; }
\end{DoxyCode}
\hypertarget{classRubyPort_1_1MemSlavePort_a24a8f9c1806a15d53eddd6a70d9b3e31}{
\index{RubyPort::MemSlavePort@{RubyPort::MemSlavePort}!hitCallback@{hitCallback}}
\index{hitCallback@{hitCallback}!RubyPort::MemSlavePort@{RubyPort::MemSlavePort}}
\subsubsection[{hitCallback}]{\setlength{\rightskip}{0pt plus 5cm}void hitCallback ({\bf PacketPtr} {\em pkt})}}
\label{classRubyPort_1_1MemSlavePort_a24a8f9c1806a15d53eddd6a70d9b3e31}



\begin{DoxyCode}
454 {
455     bool needsResponse = pkt->needsResponse();
456 
457     //
458     // Unless specified at configuraiton, all responses except failed SC 
459     // and Flush operations access M5 physical memory.
460     //
461     bool accessPhysMem = access_phys_mem;
462 
463     if (pkt->isLLSC()) {
464         if (pkt->isWrite()) {
465             if (pkt->req->getExtraData() != 0) {
466                 //
467                 // Successful SC packets convert to normal writes
468                 //
469                 pkt->convertScToWrite();
470             } else {
471                 //
472                 // Failed SC packets don't access physical memory and thus
473                 // the RubyPort itself must convert it to a response.
474                 //
475                 accessPhysMem = false;
476             }
477         } else {
478             //
479             // All LL packets convert to normal loads so that M5 PhysMem does
480             // not lock the blocks.
481             //
482             pkt->convertLlToRead();
483         }
484     }
485 
486     //
487     // Flush requests don't access physical memory
488     //
489     if (pkt->isFlush()) {
490         accessPhysMem = false;
491     }
492 
493     DPRINTF(RubyPort, "Hit callback needs response %d\n", needsResponse);
494 
495     if (accessPhysMem) {
496         RubyPort *ruby_port = static_cast<RubyPort *>(&owner);
497         ruby_port->system->getPhysMem().access(pkt);
498     } else if (needsResponse) {
499         pkt->makeResponse();
500     }
501 
502     // turn packet around to go back to requester if response expected
503     if (needsResponse) {
504         DPRINTF(RubyPort, "Sending packet back over port\n");
505         // send next cycle
506         schedTimingResp(pkt, curTick() + g_system_ptr->clockPeriod());
507     } else {
508         delete pkt;
509     }
510     DPRINTF(RubyPort, "Hit callback done!\n");
511 }
\end{DoxyCode}
\hypertarget{classRubyPort_1_1MemSlavePort_aa1da2f433965694958a83f76fcf4adc2}{
\index{RubyPort::MemSlavePort@{RubyPort::MemSlavePort}!isPhysMemAddress@{isPhysMemAddress}}
\index{isPhysMemAddress@{isPhysMemAddress}!RubyPort::MemSlavePort@{RubyPort::MemSlavePort}}
\subsubsection[{isPhysMemAddress}]{\setlength{\rightskip}{0pt plus 5cm}bool isPhysMemAddress ({\bf Addr} {\em addr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyPort_1_1MemSlavePort_aa1da2f433965694958a83f76fcf4adc2}



\begin{DoxyCode}
531 {
532     RubyPort *ruby_port = static_cast<RubyPort *>(&owner);
533     return ruby_port->system->isMemAddr(addr);
534 }
\end{DoxyCode}
\hypertarget{classRubyPort_1_1MemSlavePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{
\index{RubyPort::MemSlavePort@{RubyPort::MemSlavePort}!recvAtomic@{recvAtomic}}
\index{recvAtomic@{recvAtomic}!RubyPort::MemSlavePort@{RubyPort::MemSlavePort}}
\subsubsection[{recvAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvAtomic ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classRubyPort_1_1MemSlavePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}
Receive an atomic request packet from the master port. 

\hyperlink{classSlavePort_a428ab07671bc9372dc44a2487b12a726}{SlavePort}を実装しています。


\begin{DoxyCode}
91         { panic("RubyPort::MemSlavePort::recvAtomic() not implemented!\n"); }
\end{DoxyCode}
\hypertarget{classRubyPort_1_1MemSlavePort_aeefa907fb6d6a787e6dab90e8138ea90}{
\index{RubyPort::MemSlavePort@{RubyPort::MemSlavePort}!recvFunctional@{recvFunctional}}
\index{recvFunctional@{recvFunctional}!RubyPort::MemSlavePort@{RubyPort::MemSlavePort}}
\subsubsection[{recvFunctional}]{\setlength{\rightskip}{0pt plus 5cm}void recvFunctional ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classRubyPort_1_1MemSlavePort_aeefa907fb6d6a787e6dab90e8138ea90}
Receive a functional request packet from the master port. 

\hyperlink{classSlavePort_a6a3d6f2e5dab6bed16d53d9e7c17378d}{SlavePort}を実装しています。


\begin{DoxyCode}
277 {
278     DPRINTF(RubyPort, "Functional access for address: %#x\n", pkt->getAddr());
279     RubyPort *ruby_port = static_cast<RubyPort *>(&owner);
280 
281     // Check for pio requests and directly send them to the dedicated
282     // pio port.
283     if (!isPhysMemAddress(pkt->getAddr())) {
284         assert(ruby_port->memMasterPort.isConnected());
285         DPRINTF(RubyPort, "Pio Request for address: 0x%#x\n", pkt->getAddr());
286         panic("RubyPort::PioMasterPort::recvFunctional() not implemented!\n");
287     }
288 
289     assert(pkt->getAddr() + pkt->getSize() <=
290                 line_address(Address(pkt->getAddr())).getAddress() +
291                 RubySystem::getBlockSizeBytes());
292 
293     bool accessSucceeded = false;
294     bool needsResponse = pkt->needsResponse();
295 
296     // Do the functional access on ruby memory
297     if (pkt->isRead()) {
298         accessSucceeded = ruby_system->functionalRead(pkt);
299     } else if (pkt->isWrite()) {
300         accessSucceeded = ruby_system->functionalWrite(pkt);
301     } else {
302         panic("Unsupported functional command %s\n", pkt->cmdString());
303     }
304 
305     // Unless the requester explicitly said otherwise, generate an error if
306     // the functional request failed
307     if (!accessSucceeded && !pkt->suppressFuncError()) {
308         fatal("Ruby functional %s failed for address %#x\n",
309               pkt->isWrite() ? "write" : "read", pkt->getAddr());
310     }
311 
312     if (access_phys_mem) {
313         // The attached physmem contains the official version of data.
314         // The following command performs the real functional access.
315         // This line should be removed once Ruby supplies the official version
316         // of data.
317         ruby_port->system->getPhysMem().functionalAccess(pkt);
318     }
319 
320     // turn packet around to go back to requester if response expected
321     if (needsResponse) {
322         pkt->setFunctionalResponseStatus(accessSucceeded);
323 
324         // @todo There should not be a reverse call since the response is
325         // communicated through the packet pointer
326         // DPRINTF(RubyPort, "Sending packet back over port\n");
327         // sendFunctional(pkt);
328     }
329     DPRINTF(RubyPort, "Functional access %s!\n",
330             accessSucceeded ? "successful":"failed");
331 }
\end{DoxyCode}
\hypertarget{classRubyPort_1_1MemSlavePort_a3344d9dd0f83257feab5424e761f31c6}{
\index{RubyPort::MemSlavePort@{RubyPort::MemSlavePort}!recvTimingReq@{recvTimingReq}}
\index{recvTimingReq@{recvTimingReq}!RubyPort::MemSlavePort@{RubyPort::MemSlavePort}}
\subsubsection[{recvTimingReq}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingReq ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classRubyPort_1_1MemSlavePort_a3344d9dd0f83257feab5424e761f31c6}
Receive a timing request from the master port. 

\hyperlink{classSlavePort_abcece77e42f88ee41af8d3d01bb48253}{SlavePort}を実装しています。


\begin{DoxyCode}
218 {
219     DPRINTF(RubyPort, "Timing request for address %#x on port %d\n",
220             pkt->getAddr(), id);
221     RubyPort *ruby_port = static_cast<RubyPort *>(&owner);
222 
223     if (pkt->memInhibitAsserted())
224         panic("RubyPort should never see an inhibited request\n");
225 
226     // Check for pio requests and directly send them to the dedicated
227     // pio port.
228     if (!isPhysMemAddress(pkt->getAddr())) {
229         assert(ruby_port->memMasterPort.isConnected());
230         DPRINTF(RubyPort, "Request address %#x assumed to be a pio address\n",
231                 pkt->getAddr());
232 
233         // Save the port in the sender state object to be used later to
234         // route the response
235         pkt->pushSenderState(new SenderState(this));
236 
237         // send next cycle
238         ruby_port->memMasterPort.schedTimingReq(pkt,
239             curTick() + g_system_ptr->clockPeriod());
240         return true;
241     }
242 
243     // Save the port id to be used later to route the response
244     pkt->setSrc(id);
245 
246     assert(Address(pkt->getAddr()).getOffset() + pkt->getSize() <=
247            RubySystem::getBlockSizeBytes());
248 
249     // Submit the ruby request
250     RequestStatus requestStatus = ruby_port->makeRequest(pkt);
251 
252     // If the request successfully issued then we should return true.
253     // Otherwise, we need to tell the port to retry at a later point
254     // and return false.
255     if (requestStatus == RequestStatus_Issued) {
256         DPRINTF(RubyPort, "Request %s 0x%x issued\n", pkt->cmdString(),
257                 pkt->getAddr());
258         return true;
259     }
260 
261     //
262     // Unless one is using the ruby tester, record the stalled M5 port for 
263     // later retry when the sequencer becomes free.
264     //
265     if (!ruby_port->m_usingRubyTester) {
266         ruby_port->addToRetryList(this);
267     }
268 
269     DPRINTF(RubyPort, "Request for address %#x did not issued because %s\n",
270             pkt->getAddr(), RequestStatus_to_string(requestStatus));
271 
272     return false;
273 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classRubyPort_1_1MemSlavePort_a5925f629d4ec58811bba7c4fa6b4d64d}{
\index{RubyPort::MemSlavePort@{RubyPort::MemSlavePort}!access\_\-phys\_\-mem@{access\_\-phys\_\-mem}}
\index{access\_\-phys\_\-mem@{access\_\-phys\_\-mem}!RubyPort::MemSlavePort@{RubyPort::MemSlavePort}}
\subsubsection[{access\_\-phys\_\-mem}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf access\_\-phys\_\-mem}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyPort_1_1MemSlavePort_a5925f629d4ec58811bba7c4fa6b4d64d}
\hypertarget{classRubyPort_1_1MemSlavePort_a3055168363a9ed42f38173363b6c1975}{
\index{RubyPort::MemSlavePort@{RubyPort::MemSlavePort}!queue@{queue}}
\index{queue@{queue}!RubyPort::MemSlavePort@{RubyPort::MemSlavePort}}
\subsubsection[{queue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SlavePacketQueue} {\bf queue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyPort_1_1MemSlavePort_a3055168363a9ed42f38173363b6c1975}
\hyperlink{classPacket}{Packet} queue used to store outgoing requests and responses. 

\hyperlink{classQueuedSlavePort_a89fcdbe2ab63d24f2112bc7e05bf2413}{QueuedSlavePort}を再定義しています。\hypertarget{classRubyPort_1_1MemSlavePort_a88928242e9a532cb6f4abe42dd8240a7}{
\index{RubyPort::MemSlavePort@{RubyPort::MemSlavePort}!ruby\_\-system@{ruby\_\-system}}
\index{ruby\_\-system@{ruby\_\-system}!RubyPort::MemSlavePort@{RubyPort::MemSlavePort}}
\subsubsection[{ruby\_\-system}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RubySystem}$\ast$ {\bf ruby\_\-system}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyPort_1_1MemSlavePort_a88928242e9a532cb6f4abe42dd8240a7}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/ruby/system/\hyperlink{RubyPort_8hh}{RubyPort.hh}\item 
mem/ruby/system/\hyperlink{RubyPort_8cc}{RubyPort.cc}\end{DoxyCompactItemize}
