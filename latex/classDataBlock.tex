\hypertarget{classDataBlock}{
\section{クラス DataBlock}
\label{classDataBlock}\index{DataBlock@{DataBlock}}
}


{\ttfamily \#include $<$DataBlock.hh$>$}\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDataBlock_a70333aa76ea711881e05f285eb676414}{DataBlock} ()
\item 
\hyperlink{classDataBlock_a7d46edaeb847a8973610dc4d4ce6c6a2}{DataBlock} (const \hyperlink{classDataBlock}{DataBlock} \&cp)
\item 
\hyperlink{classDataBlock_a7bf0fa5f818d574e5d4d42b6a3f9e5f0}{$\sim$DataBlock} ()
\item 
\hyperlink{classDataBlock}{DataBlock} \& \hyperlink{classDataBlock_a5a3faa4c9900c71dca129d15aefd10dd}{operator=} (const \hyperlink{classDataBlock}{DataBlock} \&obj)
\item 
void \hyperlink{classDataBlock_a5f8b82315ac0fe6c029cea2ab249024a}{assign} (uint8\_\-t $\ast$data)
\item 
void \hyperlink{classDataBlock_ac8bb3912a3ce86b15842e79d0b421204}{clear} ()
\item 
uint8\_\-t \hyperlink{classDataBlock_a4cd8bb493e935c5c1907d2c92358bfaa}{getByte} (int whichByte) const 
\item 
const uint8\_\-t $\ast$ \hyperlink{classDataBlock_ad7715bb129ad4df13d1503d40dff368b}{getData} (int offset, int len) const 
\item 
void \hyperlink{classDataBlock_aebd25abdba7e6d75c7001647acbd204c}{setByte} (int whichByte, uint8\_\-t data)
\item 
void \hyperlink{classDataBlock_a2d3a78eb60f9589815df5d9d82a0faad}{setData} (uint8\_\-t $\ast$data, int offset, int len)
\item 
void \hyperlink{classDataBlock_a6ba9e3f9a391e9a177f270b59fe6f925}{copyPartial} (const \hyperlink{classDataBlock}{DataBlock} \&dblk, int offset, int len)
\item 
bool \hyperlink{classDataBlock_ae37d94507baba0d67be51551a08b2e67}{equal} (const \hyperlink{classDataBlock}{DataBlock} \&obj) const 
\item 
void \hyperlink{classDataBlock_ac55fe386a101fbae38c716067c9966a0}{print} (std::ostream \&out) const 
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classDataBlock_a84da126492aa15ed1e0a848026779237}{alloc} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
uint8\_\-t $\ast$ \hyperlink{classDataBlock_a8b84eba161b544d25b6f99000ffaba8c}{m\_\-data}
\item 
bool \hyperlink{classDataBlock_a225f13db079994c51d6fc64651239d70}{m\_\-alloc}
\end{DoxyCompactItemize}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classDataBlock_a70333aa76ea711881e05f285eb676414}{
\index{DataBlock@{DataBlock}!DataBlock@{DataBlock}}
\index{DataBlock@{DataBlock}!DataBlock@{DataBlock}}
\subsubsection[{DataBlock}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DataBlock} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDataBlock_a70333aa76ea711881e05f285eb676414}



\begin{DoxyCode}
42     {
43         alloc();
44     }
\end{DoxyCode}
\hypertarget{classDataBlock_a7d46edaeb847a8973610dc4d4ce6c6a2}{
\index{DataBlock@{DataBlock}!DataBlock@{DataBlock}}
\index{DataBlock@{DataBlock}!DataBlock@{DataBlock}}
\subsubsection[{DataBlock}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DataBlock} (const {\bf DataBlock} \& {\em cp})}}
\label{classDataBlock_a7d46edaeb847a8973610dc4d4ce6c6a2}



\begin{DoxyCode}
33 {
34     m_data = new uint8_t[RubySystem::getBlockSizeBytes()];
35     memcpy(m_data, cp.m_data, RubySystem::getBlockSizeBytes());
36     m_alloc = true;
37 }
\end{DoxyCode}
\hypertarget{classDataBlock_a7bf0fa5f818d574e5d4d42b6a3f9e5f0}{
\index{DataBlock@{DataBlock}!$\sim$DataBlock@{$\sim$DataBlock}}
\index{$\sim$DataBlock@{$\sim$DataBlock}!DataBlock@{DataBlock}}
\subsubsection[{$\sim$DataBlock}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf DataBlock} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDataBlock_a7bf0fa5f818d574e5d4d42b6a3f9e5f0}



\begin{DoxyCode}
49     {
50         if (m_alloc)
51             delete [] m_data;
52     }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classDataBlock_a84da126492aa15ed1e0a848026779237}{
\index{DataBlock@{DataBlock}!alloc@{alloc}}
\index{alloc@{alloc}!DataBlock@{DataBlock}}
\subsubsection[{alloc}]{\setlength{\rightskip}{0pt plus 5cm}void alloc ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDataBlock_a84da126492aa15ed1e0a848026779237}



\begin{DoxyCode}
41 {
42     m_data = new uint8_t[RubySystem::getBlockSizeBytes()];
43     m_alloc = true;
44     clear();
45 }
\end{DoxyCode}
\hypertarget{classDataBlock_a5f8b82315ac0fe6c029cea2ab249024a}{
\index{DataBlock@{DataBlock}!assign@{assign}}
\index{assign@{assign}!DataBlock@{DataBlock}}
\subsubsection[{assign}]{\setlength{\rightskip}{0pt plus 5cm}void assign (uint8\_\-t $\ast$ {\em data})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDataBlock_a5f8b82315ac0fe6c029cea2ab249024a}



\begin{DoxyCode}
75 {
76     assert(data != NULL);
77     if (m_alloc) {
78         delete [] m_data;
79     }
80     m_data = data;
81     m_alloc = false;
82 }
\end{DoxyCode}
\hypertarget{classDataBlock_ac8bb3912a3ce86b15842e79d0b421204}{
\index{DataBlock@{DataBlock}!clear@{clear}}
\index{clear@{clear}!DataBlock@{DataBlock}}
\subsubsection[{clear}]{\setlength{\rightskip}{0pt plus 5cm}void clear ()}}
\label{classDataBlock_ac8bb3912a3ce86b15842e79d0b421204}



\begin{DoxyCode}
49 {
50     memset(m_data, 0, RubySystem::getBlockSizeBytes());
51 }
\end{DoxyCode}
\hypertarget{classDataBlock_a6ba9e3f9a391e9a177f270b59fe6f925}{
\index{DataBlock@{DataBlock}!copyPartial@{copyPartial}}
\index{copyPartial@{copyPartial}!DataBlock@{DataBlock}}
\subsubsection[{copyPartial}]{\setlength{\rightskip}{0pt plus 5cm}void copyPartial (const {\bf DataBlock} \& {\em dblk}, \/  int {\em offset}, \/  int {\em len})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDataBlock_a6ba9e3f9a391e9a177f270b59fe6f925}



\begin{DoxyCode}
98 {
99     setData(&dblk.m_data[offset], offset, len);
100 }
\end{DoxyCode}
\hypertarget{classDataBlock_ae37d94507baba0d67be51551a08b2e67}{
\index{DataBlock@{DataBlock}!equal@{equal}}
\index{equal@{equal}!DataBlock@{DataBlock}}
\subsubsection[{equal}]{\setlength{\rightskip}{0pt plus 5cm}bool equal (const {\bf DataBlock} \& {\em obj}) const}}
\label{classDataBlock_ae37d94507baba0d67be51551a08b2e67}



\begin{DoxyCode}
55 {
56     return !memcmp(m_data, obj.m_data, RubySystem::getBlockSizeBytes());
57 }
\end{DoxyCode}
\hypertarget{classDataBlock_a4cd8bb493e935c5c1907d2c92358bfaa}{
\index{DataBlock@{DataBlock}!getByte@{getByte}}
\index{getByte@{getByte}!DataBlock@{DataBlock}}
\subsubsection[{getByte}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t getByte (int {\em whichByte}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDataBlock_a4cd8bb493e935c5c1907d2c92358bfaa}



\begin{DoxyCode}
86 {
87     return m_data[whichByte];
88 }
\end{DoxyCode}
\hypertarget{classDataBlock_ad7715bb129ad4df13d1503d40dff368b}{
\index{DataBlock@{DataBlock}!getData@{getData}}
\index{getData@{getData}!DataBlock@{DataBlock}}
\subsubsection[{getData}]{\setlength{\rightskip}{0pt plus 5cm}const uint8\_\-t $\ast$ getData (int {\em offset}, \/  int {\em len}) const}}
\label{classDataBlock_ad7715bb129ad4df13d1503d40dff368b}



\begin{DoxyCode}
75 {
76     assert(offset + len <= RubySystem::getBlockSizeBytes());
77     return &m_data[offset];
78 }
\end{DoxyCode}
\hypertarget{classDataBlock_a5a3faa4c9900c71dca129d15aefd10dd}{
\index{DataBlock@{DataBlock}!operator=@{operator=}}
\index{operator=@{operator=}!DataBlock@{DataBlock}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DataBlock} \& operator= (const {\bf DataBlock} \& {\em obj})}}
\label{classDataBlock_a5a3faa4c9900c71dca129d15aefd10dd}



\begin{DoxyCode}
89 {
90     memcpy(m_data, obj.m_data, RubySystem::getBlockSizeBytes());
91     return *this;
92 }
\end{DoxyCode}
\hypertarget{classDataBlock_ac55fe386a101fbae38c716067c9966a0}{
\index{DataBlock@{DataBlock}!print@{print}}
\index{print@{print}!DataBlock@{DataBlock}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}void print (std::ostream \& {\em out}) const}}
\label{classDataBlock_ac55fe386a101fbae38c716067c9966a0}



\begin{DoxyCode}
61 {
62     using namespace std;
63 
64     int size = RubySystem::getBlockSizeBytes();
65     out << "[ ";
66     for (int i = 0; i < size; i++) {
67         out << setw(2) << setfill('0') << hex << "0x" << (int)m_data[i] << " ";
68         out << setfill(' ');
69     }
70     out << dec << "]" << flush;
71 }
\end{DoxyCode}
\hypertarget{classDataBlock_aebd25abdba7e6d75c7001647acbd204c}{
\index{DataBlock@{DataBlock}!setByte@{setByte}}
\index{setByte@{setByte}!DataBlock@{DataBlock}}
\subsubsection[{setByte}]{\setlength{\rightskip}{0pt plus 5cm}void setByte (int {\em whichByte}, \/  uint8\_\-t {\em data})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDataBlock_aebd25abdba7e6d75c7001647acbd204c}



\begin{DoxyCode}
92 {
93     m_data[whichByte] = data;
94 }
\end{DoxyCode}
\hypertarget{classDataBlock_a2d3a78eb60f9589815df5d9d82a0faad}{
\index{DataBlock@{DataBlock}!setData@{setData}}
\index{setData@{setData}!DataBlock@{DataBlock}}
\subsubsection[{setData}]{\setlength{\rightskip}{0pt plus 5cm}void setData (uint8\_\-t $\ast$ {\em data}, \/  int {\em offset}, \/  int {\em len})}}
\label{classDataBlock_a2d3a78eb60f9589815df5d9d82a0faad}



\begin{DoxyCode}
82 {
83     assert(offset + len <= RubySystem::getBlockSizeBytes());
84     memcpy(&m_data[offset], data, len);
85 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classDataBlock_a225f13db079994c51d6fc64651239d70}{
\index{DataBlock@{DataBlock}!m\_\-alloc@{m\_\-alloc}}
\index{m\_\-alloc@{m\_\-alloc}!DataBlock@{DataBlock}}
\subsubsection[{m\_\-alloc}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf m\_\-alloc}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDataBlock_a225f13db079994c51d6fc64651239d70}
\hypertarget{classDataBlock_a8b84eba161b544d25b6f99000ffaba8c}{
\index{DataBlock@{DataBlock}!m\_\-data@{m\_\-data}}
\index{m\_\-data@{m\_\-data}!DataBlock@{DataBlock}}
\subsubsection[{m\_\-data}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t$\ast$ {\bf m\_\-data}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDataBlock_a8b84eba161b544d25b6f99000ffaba8c}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/ruby/common/\hyperlink{DataBlock_8hh}{DataBlock.hh}\item 
mem/ruby/common/\hyperlink{DataBlock_8cc}{DataBlock.cc}\end{DoxyCompactItemize}
