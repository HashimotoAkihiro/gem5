\hypertarget{classOzoneLSQ}{
\section{クラス テンプレート OzoneLSQ$<$ Impl $>$}
\label{classOzoneLSQ}\index{OzoneLSQ@{OzoneLSQ}}
}


{\ttfamily \#include $<$lsq\_\-unit.hh$>$}\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structOzoneLSQ_1_1SQEntry}{SQEntry}
\item 
class \hyperlink{classOzoneLSQ_1_1StoreCompletionEvent}{StoreCompletionEvent}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classOzoneLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \{ \hyperlink{classOzoneLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}{Running}, 
\hyperlink{classOzoneLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}{Idle}, 
\hyperlink{classOzoneLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70ba4ba5ae5815b190bd652669e2fdea5ed7}{DcacheMissStall}, 
\hyperlink{classOzoneLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70bad01f64e5e67cc64e6ad4152f187a034d}{DcacheMissSwitch}
 \}
\item 
typedef Impl::Params \hyperlink{classOzoneLSQ_a818e103eae798a24a06a0a34631849ea}{Params}
\item 
typedef Impl::FullCPU \hyperlink{classOzoneLSQ_a90ba84e54618cc07f2e8f05e046cb5ce}{FullCPU}
\item 
typedef Impl::BackEnd \hyperlink{classOzoneLSQ_a3de526baa0cbb2b55bf669a6f7bf81cc}{BackEnd}
\item 
typedef Impl::DynInstPtr \hyperlink{classOzoneLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}
\item 
typedef Impl::IssueStruct \hyperlink{classOzoneLSQ_a568c86f6403070f1cb743e994405ba8b}{IssueStruct}
\item 
typedef TheISA::IntReg \hyperlink{classOzoneLSQ_a1355cb78d031430d4d70eb5080267604}{IntReg}
\item 
typedef std::map$<$ \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum}, \hyperlink{classOzoneLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$::iterator \hyperlink{classOzoneLSQ_a8b43ca5318a59872c61492868e50bab6}{LdMapIt}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classOzoneLSQ_a31be199d33faeff7e77c7ed894288f5b}{OzoneLSQ} ()
\item 
void \hyperlink{classOzoneLSQ_ae8565b0968a8115705f1585e8aa21f75}{init} (\hyperlink{classOzoneLSQ_a818e103eae798a24a06a0a34631849ea}{Params} $\ast$params, unsigned maxLQEntries, unsigned maxSQEntries, unsigned id)
\item 
std::string \hyperlink{classOzoneLSQ_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classOzoneLSQ_ad491c9766121fc19aa77fd0723e7641d}{setCPU} (\hyperlink{classOzoneLSQ_a90ba84e54618cc07f2e8f05e046cb5ce}{FullCPU} $\ast$cpu\_\-ptr)
\item 
void \hyperlink{classOzoneLSQ_a9134276ed85820d74779ad5826580822}{setBE} (\hyperlink{classBackEnd}{BackEnd} $\ast$be\_\-ptr)
\item 
void \hyperlink{classOzoneLSQ_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\item 
void \hyperlink{classOzoneLSQ_a773e88db1aa010c3755e603493bf40ec}{insert} (\hyperlink{classOzoneLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classOzoneLSQ_ad22b3ecafed2bcd9c59fcab049a1cb98}{insertLoad} (\hyperlink{classOzoneLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&load\_\-inst)
\item 
void \hyperlink{classOzoneLSQ_a6a4b4e51bfff3639932ebaba45e8a282}{insertStore} (\hyperlink{classOzoneLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&store\_\-inst)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classOzoneLSQ_a30c6332142c2ecca389ed6ee463c692b}{executeLoad} (\hyperlink{classOzoneLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classOzoneLSQ_a091a4d1788ce66e51ceb888bbd85ac08}{executeLoad} (int lq\_\-idx)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classOzoneLSQ_aad78b8a37ee5c61e47df58dd39980340}{executeStore} (\hyperlink{classOzoneLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classOzoneLSQ_a8ddd26e169a62ec5ae591a9f95934839}{commitLoad} ()
\item 
void \hyperlink{classOzoneLSQ_a1201888477c271cea802f0be0081d76b}{commitLoad} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&inst)
\item 
void \hyperlink{classOzoneLSQ_a1ae517a923a864a4e3a5aa1eeb2dd2d6}{commitLoads} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&youngest\_\-inst)
\item 
void \hyperlink{classOzoneLSQ_a954ce1ce58b67cae49ba127d5ea40701}{commitStores} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&youngest\_\-inst)
\item 
void \hyperlink{classOzoneLSQ_a5f04e29d6f6feb8b86460491f2ba7547}{writebackStores} ()
\item 
void \hyperlink{classOzoneLSQ_ae3af532345dbe6519e8272d9cd677230}{clearLQ} ()
\item 
void \hyperlink{classOzoneLSQ_a171cd7891063f418b1ee217f5c03537b}{clearSQ} ()
\item 
void \hyperlink{classOzoneLSQ_a3bc9500810cb2d5615e29206e2d6499f}{resizeLQ} (unsigned size)
\item 
void \hyperlink{classOzoneLSQ_a341dd6a3bd8d240659fd9d698c3b5c65}{resizeSQ} (unsigned size)
\item 
void \hyperlink{classOzoneLSQ_a51dd7e304d5413447717826fac6f4921}{squash} (const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&squashed\_\-num)
\item 
bool \hyperlink{classOzoneLSQ_a4f720bbfb5fdefdb23516500eeb0b4de}{violation} ()
\item 
\hyperlink{classOzoneLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classOzoneLSQ_a30adaf6f5fb6b38b5747f35c419e3f31}{getMemDepViolator} ()
\item 
bool \hyperlink{classOzoneLSQ_a05c413ba417c6453e99f75d87c958590}{loadBlocked} ()
\item 
unsigned \hyperlink{classOzoneLSQ_a028971a565aca048c67ea1c36a6a9d51}{numFreeEntries} ()
\item 
int \hyperlink{classOzoneLSQ_a9aa5d5a61b2229931008ac2ea802a3ab}{numLoadsReady} ()
\item 
int \hyperlink{classOzoneLSQ_a54460b759fb06e2b18e26657279a6f49}{numLoads} ()
\item 
int \hyperlink{classOzoneLSQ_aa0fc32a4a9d77696f5907f4d25e7d07f}{numStores} ()
\item 
bool \hyperlink{classOzoneLSQ_a3e70330939fdfc4dbc2f60c1a660584d}{isFull} ()
\item 
bool \hyperlink{classOzoneLSQ_a5893daf623130be826f492bbff58f757}{lqFull} ()
\item 
bool \hyperlink{classOzoneLSQ_a477981d1f905d2d398a1527f7149e3c4}{sqFull} ()
\item 
void \hyperlink{classOzoneLSQ_a80587b4fe043bbe1995536cb3b361588}{dumpInsts} ()
\item 
unsigned \hyperlink{classOzoneLSQ_a24ba9cb3fa1e726321780a20a960c8cd}{getCount} ()
\item 
bool \hyperlink{classOzoneLSQ_ad2e4b46255cfb53e85522adeed4e2089}{hasStoresToWB} ()
\item 
int \hyperlink{classOzoneLSQ_a276cdbdaf4551f1b846c4e2535c5f882}{numStoresToWB} ()
\item 
bool \hyperlink{classOzoneLSQ_a338be821734603396bfef8d9fb8f04b0}{willWB} ()
\item 
{\footnotesize template$<$class T $>$ }\\\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classOzoneLSQ_ad2981b6704bca036af0723daaaebe57e}{read} (MemReqPtr \&req, T \&data, int load\_\-idx)
\item 
{\footnotesize template$<$class T $>$ }\\\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classOzoneLSQ_a173162a41482ee35c5a15394b4befa4b}{write} (MemReqPtr \&req, T \&data, int store\_\-idx)
\item 
int \hyperlink{classOzoneLSQ_ad43a7408f4e1c1e181bc40ecab6dc593}{getLoadHead} ()
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classOzoneLSQ_aee7352adadc6b43b7ce36a8c052eb222}{getLoadHeadSeqNum} ()
\item 
int \hyperlink{classOzoneLSQ_ab9d14b0deb8ab44dc09ac784b162e774}{getStoreHead} ()
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classOzoneLSQ_a1813b58ab7569d6aeefb5d4e235cceda}{getStoreHeadSeqNum} ()
\item 
bool \hyperlink{classOzoneLSQ_af8eb8590fbfa6ecd2f796390677a4c00}{isStalled} ()
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classOzoneLSQ_a12ec7cad6ac51a53bca7795588885e5c}{completeStore} (int store\_\-idx)
\item 
void \hyperlink{classOzoneLSQ_a4ec2fe6ed54cf88c23fb214b87f850d1}{incrStIdx} (int \&store\_\-idx)
\item 
void \hyperlink{classOzoneLSQ_aa585a02e67713aeeabb73720e6c89388}{decrStIdx} (int \&store\_\-idx)
\item 
void \hyperlink{classOzoneLSQ_a0e0f98133b2afd7aa1793ba30dd4a96b}{incrLdIdx} (int \&load\_\-idx)
\item 
void \hyperlink{classOzoneLSQ_a73fc7794c8562f58407f59513a891c84}{decrLdIdx} (int \&load\_\-idx)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classOzoneLSQ_a90ba84e54618cc07f2e8f05e046cb5ce}{FullCPU} $\ast$ \hyperlink{classOzoneLSQ_a766385c2941cd46525f4d9dff90200a2}{cpu}
\item 
\hyperlink{classBackEnd}{BackEnd} $\ast$ \hyperlink{classOzoneLSQ_a84f815aa1fa864ba2e6d75f5ad2b52d1}{be}
\item 
MemInterface $\ast$ \hyperlink{classOzoneLSQ_a22dc8294eecb144fbdd951d2e32e9330}{dcacheInterface}
\item 
\hyperlink{classPageTable}{PageTable} $\ast$ \hyperlink{classOzoneLSQ_ad14ffa23ad731f6003755b643f999049}{pTable}
\item 
unsigned \hyperlink{classOzoneLSQ_adfd96fbbaa327a31d20f0d4134418fad}{lsqID}
\item 
\hyperlink{classOzoneLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \hyperlink{classOzoneLSQ_a6cdf6e6db875a442f3ab6db542bd2bb5}{\_\-status}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{structOzoneLSQ_1_1SQEntry}{SQEntry} $>$ \hyperlink{classOzoneLSQ_a1d370cdc36d253e0f786d46c6af77a40}{storeQueue}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classOzoneLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classOzoneLSQ_aa5f3703c5d7c5ce21a497352b94c7465}{loadQueue}
\item 
unsigned \hyperlink{classOzoneLSQ_aafa99d800d574095881acbacdbbbcc47}{LQEntries}
\item 
unsigned \hyperlink{classOzoneLSQ_a38c8af5392da70119dc5cce4e3637cbc}{SQEntries}
\item 
int \hyperlink{classOzoneLSQ_a867971f18e464abd16193e069c64a8ad}{loads}
\item 
int \hyperlink{classOzoneLSQ_ade9e895aa9c5ace27779c985c4f43326}{stores}
\item 
int \hyperlink{classOzoneLSQ_a3831a7965ffbe90df177026988476f9c}{storesToWB}
\item 
int \hyperlink{classOzoneLSQ_ac09af89928d2ef4da4cbdcfce26fa3f5}{loadHead}
\item 
int \hyperlink{classOzoneLSQ_a973a489225da164cc85e690f13c86841}{loadTail}
\item 
int \hyperlink{classOzoneLSQ_a6e87b6f77102183080ea6ab8599b26a9}{storeHead}
\item 
int \hyperlink{classOzoneLSQ_a9023e0813d4f3e566d17fb6334a2da02}{storeWBIdx}
\item 
int \hyperlink{classOzoneLSQ_acd5c7fbb5578b5cb505ffff16bbf6a8b}{storeTail}
\item 
int \hyperlink{classOzoneLSQ_ab2e23636971c40e7ed945026b2a184e1}{cachePorts}
\item 
int \hyperlink{classOzoneLSQ_a03435d626b7567ed154de5d7d8c3d419}{usedPorts}
\item 
\hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classOzoneLSQ_a8b4696062ef09ab956804a7a99491853}{lastDcacheStall}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structIssueStruct}{IssueStruct} $>$::wire \hyperlink{classOzoneLSQ_af6f43373b6586aa8c486538fb076effb}{fromIssue}
\item 
bool \hyperlink{classOzoneLSQ_a6f8bff553ad30865c7d0c62e05421eb8}{stalled}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classOzoneLSQ_afe1cdcfca6b44c28581d862228adc3da}{stallingStoreIsn}
\item 
int \hyperlink{classOzoneLSQ_af55bc9000c8b4e4cfcfbd018feca12a7}{stallingLoadIdx}
\item 
bool \hyperlink{classOzoneLSQ_a95dc31b4ce3ebcb6b9d75a510b3a128c}{isLoadBlocked}
\item 
\hyperlink{classOzoneLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classOzoneLSQ_a7123aa8b10829cc4712dff5454e13978}{loadFaultInst}
\item 
\hyperlink{classOzoneLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classOzoneLSQ_ab98cf7d5235b7402e8916e78569f4ab2}{storeFaultInst}
\item 
\hyperlink{classOzoneLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classOzoneLSQ_a270a20c3fa52139e0538288275db9d22}{memDepViolator}
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classOzoneLSQ_a8f5ca1839f53a90564710f1349dd0199}{StoreCompletionEvent}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$class Impl$>$ class OzoneLSQ$<$ Impl $>$}

Class that implements the actual LQ and SQ for each specific thread. Both are circular queues; load entries are freed upon committing, while store entries are freed once they writeback. The \hyperlink{classLSQUnit}{LSQUnit} tracks if there are memory ordering violations, and also detects partial load to store forwarding cases (a store only has part of a load's data) that requires the load to wait until the store writes back. In the former case it holds onto the instruction until the dependence unit looks at it, and in the latter it stalls the \hyperlink{classLSQ}{LSQ} until the store writes back. At that point the load is replayed. 

\subsection{型定義}
\hypertarget{classOzoneLSQ_a3de526baa0cbb2b55bf669a6f7bf81cc}{
\index{OzoneLSQ@{OzoneLSQ}!BackEnd@{BackEnd}}
\index{BackEnd@{BackEnd}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{BackEnd}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::BackEnd {\bf BackEnd}}}
\label{classOzoneLSQ_a3de526baa0cbb2b55bf669a6f7bf81cc}
\hypertarget{classOzoneLSQ_a028ce10889c5f6450239d9e9a7347976}{
\index{OzoneLSQ@{OzoneLSQ}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInstPtr {\bf DynInstPtr}}}
\label{classOzoneLSQ_a028ce10889c5f6450239d9e9a7347976}
\hypertarget{classOzoneLSQ_a90ba84e54618cc07f2e8f05e046cb5ce}{
\index{OzoneLSQ@{OzoneLSQ}!FullCPU@{FullCPU}}
\index{FullCPU@{FullCPU}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{FullCPU}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::FullCPU {\bf FullCPU}}}
\label{classOzoneLSQ_a90ba84e54618cc07f2e8f05e046cb5ce}
\hypertarget{classOzoneLSQ_a1355cb78d031430d4d70eb5080267604}{
\index{OzoneLSQ@{OzoneLSQ}!IntReg@{IntReg}}
\index{IntReg@{IntReg}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{IntReg}]{\setlength{\rightskip}{0pt plus 5cm}typedef TheISA::IntReg {\bf IntReg}}}
\label{classOzoneLSQ_a1355cb78d031430d4d70eb5080267604}
\hypertarget{classOzoneLSQ_a568c86f6403070f1cb743e994405ba8b}{
\index{OzoneLSQ@{OzoneLSQ}!IssueStruct@{IssueStruct}}
\index{IssueStruct@{IssueStruct}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{IssueStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::IssueStruct {\bf IssueStruct}}}
\label{classOzoneLSQ_a568c86f6403070f1cb743e994405ba8b}
\hypertarget{classOzoneLSQ_a8b43ca5318a59872c61492868e50bab6}{
\index{OzoneLSQ@{OzoneLSQ}!LdMapIt@{LdMapIt}}
\index{LdMapIt@{LdMapIt}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{LdMapIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef std::map$<${\bf InstSeqNum}, {\bf DynInstPtr}$>$::iterator {\bf LdMapIt}}}
\label{classOzoneLSQ_a8b43ca5318a59872c61492868e50bab6}
\hypertarget{classOzoneLSQ_a818e103eae798a24a06a0a34631849ea}{
\index{OzoneLSQ@{OzoneLSQ}!Params@{Params}}
\index{Params@{Params}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::Params {\bf Params}}}
\label{classOzoneLSQ_a818e103eae798a24a06a0a34631849ea}


\subsection{列挙型}
\hypertarget{classOzoneLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70b}{
\index{OzoneLSQ@{OzoneLSQ}!Status@{Status}}
\index{Status@{Status}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{Status}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Status}}}
\label{classOzoneLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70b}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Running@{Running}!OzoneLSQ@{OzoneLSQ}}\index{OzoneLSQ@{OzoneLSQ}!Running@{Running}}\item[{\em 
\hypertarget{classOzoneLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}{
Running}
\label{classOzoneLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}
}]\index{Idle@{Idle}!OzoneLSQ@{OzoneLSQ}}\index{OzoneLSQ@{OzoneLSQ}!Idle@{Idle}}\item[{\em 
\hypertarget{classOzoneLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}{
Idle}
\label{classOzoneLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}
}]\index{DcacheMissStall@{DcacheMissStall}!OzoneLSQ@{OzoneLSQ}}\index{OzoneLSQ@{OzoneLSQ}!DcacheMissStall@{DcacheMissStall}}\item[{\em 
\hypertarget{classOzoneLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70ba4ba5ae5815b190bd652669e2fdea5ed7}{
DcacheMissStall}
\label{classOzoneLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70ba4ba5ae5815b190bd652669e2fdea5ed7}
}]\index{DcacheMissSwitch@{DcacheMissSwitch}!OzoneLSQ@{OzoneLSQ}}\index{OzoneLSQ@{OzoneLSQ}!DcacheMissSwitch@{DcacheMissSwitch}}\item[{\em 
\hypertarget{classOzoneLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70bad01f64e5e67cc64e6ad4152f187a034d}{
DcacheMissSwitch}
\label{classOzoneLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70bad01f64e5e67cc64e6ad4152f187a034d}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
276                 {
277         Running,
278         Idle,
279         DcacheMissStall,
280         DcacheMissSwitch
281     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classOzoneLSQ_a31be199d33faeff7e77c7ed894288f5b}{
\index{OzoneLSQ@{OzoneLSQ}!OzoneLSQ@{OzoneLSQ}}
\index{OzoneLSQ@{OzoneLSQ}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{OzoneLSQ}]{\setlength{\rightskip}{0pt plus 5cm}{\bf OzoneLSQ} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a31be199d33faeff7e77c7ed894288f5b}
Constructs an \hyperlink{classLSQ}{LSQ} unit. \hyperlink{classOzoneLSQ_ae8565b0968a8115705f1585e8aa21f75}{init()} must be called prior to use. 


\begin{DoxyCode}
73     : loads(0), stores(0), storesToWB(0), stalled(false), isLoadBlocked(false)
74 {
75 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classOzoneLSQ_ae3af532345dbe6519e8272d9cd677230}{
\index{OzoneLSQ@{OzoneLSQ}!clearLQ@{clearLQ}}
\index{clearLQ@{clearLQ}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{clearLQ}]{\setlength{\rightskip}{0pt plus 5cm}void clearLQ ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_ae3af532345dbe6519e8272d9cd677230}
Clears all the entries in the LQ. 


\begin{DoxyCode}
118 {
119     loadQueue.clear();
120 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a171cd7891063f418b1ee217f5c03537b}{
\index{OzoneLSQ@{OzoneLSQ}!clearSQ@{clearSQ}}
\index{clearSQ@{clearSQ}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{clearSQ}]{\setlength{\rightskip}{0pt plus 5cm}void clearSQ ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a171cd7891063f418b1ee217f5c03537b}
Clears all the entries in the SQ. 


\begin{DoxyCode}
125 {
126     storeQueue.clear();
127 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a1201888477c271cea802f0be0081d76b}{
\index{OzoneLSQ@{OzoneLSQ}!commitLoad@{commitLoad}}
\index{commitLoad@{commitLoad}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{commitLoad}]{\setlength{\rightskip}{0pt plus 5cm}void commitLoad ({\bf InstSeqNum} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a1201888477c271cea802f0be0081d76b}
Commits a specific load, given by the sequence number. 


\begin{DoxyCode}
458 {
459     // Hopefully I don't use this function too much
460     panic("Don't use this function!");
461 
462     int i = loadHead;
463     while (1) {
464         if (i == loadTail) {
465             assert(0 && "Load not in the queue!");
466         } else if (loadQueue[i]->seqNum == inst) {
467             break;
468         }
469 
470         ++i;
471         if (i >= LQEntries) {
472             i = 0;
473         }
474     }
475 
476 //    loadQueue[i]->removeInLSQ();
477     loadQueue[i] = NULL;
478     --loads;
479 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a8ddd26e169a62ec5ae591a9f95934839}{
\index{OzoneLSQ@{OzoneLSQ}!commitLoad@{commitLoad}}
\index{commitLoad@{commitLoad}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{commitLoad}]{\setlength{\rightskip}{0pt plus 5cm}void commitLoad ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a8ddd26e169a62ec5ae591a9f95934839}
Commits the head load. 


\begin{DoxyCode}
441 {
442     assert(loadQueue[loadHead]);
443 
444     DPRINTF(OzoneLSQ, "[sn:%lli] Committing head load instruction, PC %#x\n",
445             loadQueue[loadHead]->seqNum, loadQueue[loadHead]->readPC());
446 
447 
448     loadQueue[loadHead] = NULL;
449 
450     incrLdIdx(loadHead);
451 
452     --loads;
453 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a1ae517a923a864a4e3a5aa1eeb2dd2d6}{
\index{OzoneLSQ@{OzoneLSQ}!commitLoads@{commitLoads}}
\index{commitLoads@{commitLoads}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{commitLoads}]{\setlength{\rightskip}{0pt plus 5cm}void commitLoads ({\bf InstSeqNum} \& {\em youngest\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a1ae517a923a864a4e3a5aa1eeb2dd2d6}
Commits loads older than a specific sequence number. 


\begin{DoxyCode}
484 {
485     assert(loads == 0 || loadQueue[loadHead]);
486 
487     while (loads != 0 && loadQueue[loadHead]->seqNum <= youngest_inst) {
488         commitLoad();
489     }
490 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a954ce1ce58b67cae49ba127d5ea40701}{
\index{OzoneLSQ@{OzoneLSQ}!commitStores@{commitStores}}
\index{commitStores@{commitStores}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{commitStores}]{\setlength{\rightskip}{0pt plus 5cm}void commitStores ({\bf InstSeqNum} \& {\em youngest\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a954ce1ce58b67cae49ba127d5ea40701}
Commits stores older than a specific sequence number. 


\begin{DoxyCode}
495 {
496     assert(stores == 0 || storeQueue[storeHead].inst);
497 
498     int store_idx = storeHead;
499 
500     while (store_idx != storeTail) {
501         assert(storeQueue[store_idx].inst);
502         if (!storeQueue[store_idx].canWB) {
503             if (storeQueue[store_idx].inst->seqNum > youngest_inst) {
504                 break;
505             }
506             DPRINTF(OzoneLSQ, "Marking store as able to write back, PC "
507                     "%#x [sn:%lli]\n",
508                     storeQueue[store_idx].inst->readPC(),
509                     storeQueue[store_idx].inst->seqNum);
510 
511             storeQueue[store_idx].canWB = true;
512 
513 //            --stores;
514             ++storesToWB;
515         }
516 
517         incrStIdx(store_idx);
518     }
519 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a12ec7cad6ac51a53bca7795588885e5c}{
\index{OzoneLSQ@{OzoneLSQ}!completeStore@{completeStore}}
\index{completeStore@{completeStore}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{completeStore}]{\setlength{\rightskip}{0pt plus 5cm}void completeStore (int {\em store\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classOzoneLSQ_a12ec7cad6ac51a53bca7795588885e5c}
Completes the store at the specified index. 


\begin{DoxyCode}
780 {
781     assert(storeQueue[store_idx].inst);
782     storeQueue[store_idx].completed = true;
783     --storesToWB;
784     // A bit conservative because a store completion may not free up entries,
785     // but hopefully avoids two store completions in one cycle from making
786     // the CPU tick twice.
787 //    cpu->activityThisCycle();
788 
789     if (store_idx == storeHead) {
790         do {
791             incrStIdx(storeHead);
792 
793             --stores;
794         } while (storeQueue[storeHead].completed &&
795                  storeHead != storeTail);
796 
797 //        be->updateLSQNextCycle = true;
798     }
799 
800     DPRINTF(OzoneLSQ, "Store head idx:%i\n", storeHead);
801 
802     if (isStalled() &&
803         storeQueue[store_idx].inst->seqNum == stallingStoreIsn) {
804         DPRINTF(OzoneLSQ, "Unstalling, stalling store [sn:%lli] "
805                 "load idx:%i\n",
806                 stallingStoreIsn, stallingLoadIdx);
807         stalled = false;
808         stallingStoreIsn = 0;
809         be->replayMemInst(loadQueue[stallingLoadIdx]);
810     }
811 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a73fc7794c8562f58407f59513a891c84}{
\index{OzoneLSQ@{OzoneLSQ}!decrLdIdx@{decrLdIdx}}
\index{decrLdIdx@{decrLdIdx}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{decrLdIdx}]{\setlength{\rightskip}{0pt plus 5cm}void decrLdIdx (int \& {\em load\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classOzoneLSQ_a73fc7794c8562f58407f59513a891c84}
Decrements the given load index (circular queue). 


\begin{DoxyCode}
840 {
841     if (--load_idx < 0)
842         load_idx += LQEntries;
843 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_aa585a02e67713aeeabb73720e6c89388}{
\index{OzoneLSQ@{OzoneLSQ}!decrStIdx@{decrStIdx}}
\index{decrStIdx@{decrStIdx}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{decrStIdx}]{\setlength{\rightskip}{0pt plus 5cm}void decrStIdx (int \& {\em store\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classOzoneLSQ_aa585a02e67713aeeabb73720e6c89388}
Decrements the given store index (circular queue). 


\begin{DoxyCode}
824 {
825     if (--store_idx < 0)
826         store_idx += SQEntries;
827 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a80587b4fe043bbe1995536cb3b361588}{
\index{OzoneLSQ@{OzoneLSQ}!dumpInsts@{dumpInsts}}
\index{dumpInsts@{dumpInsts}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{dumpInsts}]{\setlength{\rightskip}{0pt plus 5cm}void dumpInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a80587b4fe043bbe1995536cb3b361588}
Debugging function to dump instructions in the \hyperlink{classLSQ}{LSQ}. 


\begin{DoxyCode}
748 {
749     cprintf("Load store queue: Dumping instructions.\n");
750     cprintf("Load queue size: %i\n", loads);
751     cprintf("Load queue: ");
752 
753     int load_idx = loadHead;
754 
755     while (load_idx != loadTail && loadQueue[load_idx]) {
756         cprintf("[sn:%lli] %#x ", loadQueue[load_idx]->seqNum,
757                 loadQueue[load_idx]->readPC());
758 
759         incrLdIdx(load_idx);
760     }
761 
762     cprintf("\nStore queue size: %i\n", stores);
763     cprintf("Store queue: ");
764 
765     int store_idx = storeHead;
766 
767     while (store_idx != storeTail && storeQueue[store_idx].inst) {
768         cprintf("[sn:%lli] %#x ", storeQueue[store_idx].inst->seqNum,
769                 storeQueue[store_idx].inst->readPC());
770 
771         incrStIdx(store_idx);
772     }
773 
774     cprintf("\n");
775 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a091a4d1788ce66e51ceb888bbd85ac08}{
\index{OzoneLSQ@{OzoneLSQ}!executeLoad@{executeLoad}}
\index{executeLoad@{executeLoad}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{executeLoad}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} executeLoad (int {\em lq\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a091a4d1788ce66e51ceb888bbd85ac08}



\begin{DoxyCode}
352 {
353     // Very hackish.  Not sure the best way to check that this
354     // instruction is at the head of the ROB.  I should have some sort
355     // of extra information here so that I'm not overloading the
356     // canCommit signal for 15 different things.
357     loadQueue[lq_idx]->setCanCommit();
358     Fault ret_fault = executeLoad(loadQueue[lq_idx]);
359     loadQueue[lq_idx]->clearCanCommit();
360     return ret_fault;
361 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a30c6332142c2ecca389ed6ee463c692b}{
\index{OzoneLSQ@{OzoneLSQ}!executeLoad@{executeLoad}}
\index{executeLoad@{executeLoad}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{executeLoad}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} executeLoad ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a30c6332142c2ecca389ed6ee463c692b}
Executes a load instruction. 


\begin{DoxyCode}
308 {
309     // Execute a specific load.
310     Fault load_fault = NoFault;
311 
312     DPRINTF(OzoneLSQ, "Executing load PC %#x, [sn:%lli]\n",
313             inst->readPC(),inst->seqNum);
314 
315     // Make sure it's really in the list.
316     // Normally it should always be in the list.  However,
317     /* due to a syscall it may not be the list.
318 #ifdef DEBUG
319     int i = loadHead;
320     while (1) {
321         if (i == loadTail && !find(inst)) {
322             assert(0 && "Load not in the queue!");
323         } else if (loadQueue[i] == inst) {
324             break;
325         }
326 
327         i = i + 1;
328         if (i >= LQEntries) {
329             i = 0;
330         }
331     }
332 #endif // DEBUG*/
333 
334     load_fault = inst->initiateAcc();
335 
336     // Might want to make sure that I'm not overwriting a previously faulting
337     // instruction that hasn't been checked yet.
338     // Actually probably want the oldest faulting load
339     if (load_fault != NoFault) {
340         // Maybe just set it as can commit here, although that might cause
341         // some other problems with sending traps to the ROB too quickly.
342 //        iewStage->instToCommit(inst);
343 //        iewStage->activityThisCycle();
344     }
345 
346     return load_fault;
347 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_aad78b8a37ee5c61e47df58dd39980340}{
\index{OzoneLSQ@{OzoneLSQ}!executeStore@{executeStore}}
\index{executeStore@{executeStore}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{executeStore}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} executeStore ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_aad78b8a37ee5c61e47df58dd39980340}
Executes a store instruction. 


\begin{DoxyCode}
366 {
367     // Make sure that a store exists.
368     assert(stores != 0);
369 
370     int store_idx = store_inst->sqIdx;
371 
372     DPRINTF(OzoneLSQ, "Executing store PC %#x [sn:%lli]\n",
373             store_inst->readPC(), store_inst->seqNum);
374 
375     // Check the recently completed loads to see if any match this store's
376     // address.  If so, then we have a memory ordering violation.
377     int load_idx = store_inst->lqIdx;
378 
379     Fault store_fault = store_inst->initiateAcc();
380 
381     // Store size should now be available.  Use it to get proper offset for
382     // addr comparisons.
383     int size = storeQueue[store_idx].size;
384 
385     if (size == 0) {
386         DPRINTF(OzoneLSQ,"Fault on Store PC %#x, [sn:%lli],Size = 0\n",
387                 store_inst->readPC(),store_inst->seqNum);
388 
389         return store_fault;
390     }
391 
392     assert(store_fault == NoFault);
393 
394     if (!storeFaultInst) {
395         if (store_fault != NoFault) {
396             panic("Fault in a store instruction!");
397             storeFaultInst = store_inst;
398         } else if (store_inst->isNonSpeculative()) {
399             // Nonspeculative accesses (namely store conditionals)
400             // need to set themselves as able to writeback if we
401             // haven't had a fault by here.
402             storeQueue[store_idx].canWB = true;
403 
404             ++storesToWB;
405         }
406     }
407 
408     if (!memDepViolator) {
409         while (load_idx != loadTail) {
410             // Actually should only check loads that have actually executed
411             // Might be safe because effAddr is set to InvalAddr when the
412             // dyn inst is created.
413 
414             // Must actually check all addrs in the proper size range
415             // Which is more correct than needs to be.  What if for now we just
416             // assume all loads are quad-word loads, and do the addr based
417             // on that.
418             // @todo: Fix this, magic number being used here
419             if ((loadQueue[load_idx]->effAddr >> 8) ==
420                 (store_inst->effAddr >> 8)) {
421                 // A load incorrectly passed this store.  Squash and refetch.
422                 // For now return a fault to show that it was unsuccessful.
423                 memDepViolator = loadQueue[load_idx];
424 
425                 return TheISA::genMachineCheckFault();
426             }
427 
428             incrLdIdx(load_idx);
429         }
430 
431         // If we've reached this point, there was no violation.
432         memDepViolator = NULL;
433     }
434 
435     return store_fault;
436 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a24ba9cb3fa1e726321780a20a960c8cd}{
\index{OzoneLSQ@{OzoneLSQ}!getCount@{getCount}}
\index{getCount@{getCount}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{getCount}]{\setlength{\rightskip}{0pt plus 5cm}unsigned getCount ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a24ba9cb3fa1e726321780a20a960c8cd}
Returns the number of instructions in the \hyperlink{classLSQ}{LSQ}. 


\begin{DoxyCode}
207 { return loads + stores; }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_ad43a7408f4e1c1e181bc40ecab6dc593}{
\index{OzoneLSQ@{OzoneLSQ}!getLoadHead@{getLoadHead}}
\index{getLoadHead@{getLoadHead}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{getLoadHead}]{\setlength{\rightskip}{0pt plus 5cm}int getLoadHead ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_ad43a7408f4e1c1e181bc40ecab6dc593}
Returns the index of the head load instruction. 


\begin{DoxyCode}
377 { return loadHead; }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_aee7352adadc6b43b7ce36a8c052eb222}{
\index{OzoneLSQ@{OzoneLSQ}!getLoadHeadSeqNum@{getLoadHeadSeqNum}}
\index{getLoadHeadSeqNum@{getLoadHeadSeqNum}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{getLoadHeadSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} getLoadHeadSeqNum ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_aee7352adadc6b43b7ce36a8c052eb222}
Returns the sequence number of the head load instruction. 


\begin{DoxyCode}
380     {
381         if (loadQueue[loadHead]) {
382             return loadQueue[loadHead]->seqNum;
383         } else {
384             return 0;
385         }
386 
387     }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a30adaf6f5fb6b38b5747f35c419e3f31}{
\index{OzoneLSQ@{OzoneLSQ}!getMemDepViolator@{getMemDepViolator}}
\index{getMemDepViolator@{getMemDepViolator}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{getMemDepViolator}]{\setlength{\rightskip}{0pt plus 5cm}Impl::DynInstPtr getMemDepViolator ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a30adaf6f5fb6b38b5747f35c419e3f31}
Returns the memory ordering violator. 


\begin{DoxyCode}
230 {
231     DynInstPtr temp = memDepViolator;
232 
233     memDepViolator = NULL;
234 
235     return temp;
236 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_ab9d14b0deb8ab44dc09ac784b162e774}{
\index{OzoneLSQ@{OzoneLSQ}!getStoreHead@{getStoreHead}}
\index{getStoreHead@{getStoreHead}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{getStoreHead}]{\setlength{\rightskip}{0pt plus 5cm}int getStoreHead ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_ab9d14b0deb8ab44dc09ac784b162e774}
Returns the index of the head store instruction. 


\begin{DoxyCode}
390 { return storeHead; }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a1813b58ab7569d6aeefb5d4e235cceda}{
\index{OzoneLSQ@{OzoneLSQ}!getStoreHeadSeqNum@{getStoreHeadSeqNum}}
\index{getStoreHeadSeqNum@{getStoreHeadSeqNum}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{getStoreHeadSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} getStoreHeadSeqNum ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a1813b58ab7569d6aeefb5d4e235cceda}
Returns the sequence number of the head store instruction. 


\begin{DoxyCode}
393     {
394         if (storeQueue[storeHead].inst) {
395             return storeQueue[storeHead].inst->seqNum;
396         } else {
397             return 0;
398         }
399 
400     }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_ad2e4b46255cfb53e85522adeed4e2089}{
\index{OzoneLSQ@{OzoneLSQ}!hasStoresToWB@{hasStoresToWB}}
\index{hasStoresToWB@{hasStoresToWB}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{hasStoresToWB}]{\setlength{\rightskip}{0pt plus 5cm}bool hasStoresToWB ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_ad2e4b46255cfb53e85522adeed4e2089}
Returns if there are any stores to writeback. 


\begin{DoxyCode}
210 { return storesToWB; }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a0e0f98133b2afd7aa1793ba30dd4a96b}{
\index{OzoneLSQ@{OzoneLSQ}!incrLdIdx@{incrLdIdx}}
\index{incrLdIdx@{incrLdIdx}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{incrLdIdx}]{\setlength{\rightskip}{0pt plus 5cm}void incrLdIdx (int \& {\em load\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classOzoneLSQ_a0e0f98133b2afd7aa1793ba30dd4a96b}
Increments the given load index (circular queue). 


\begin{DoxyCode}
832 {
833     if (++load_idx >= LQEntries)
834         load_idx = 0;
835 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a4ec2fe6ed54cf88c23fb214b87f850d1}{
\index{OzoneLSQ@{OzoneLSQ}!incrStIdx@{incrStIdx}}
\index{incrStIdx@{incrStIdx}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{incrStIdx}]{\setlength{\rightskip}{0pt plus 5cm}void incrStIdx (int \& {\em store\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classOzoneLSQ_a4ec2fe6ed54cf88c23fb214b87f850d1}
Increments the given store index (circular queue). 


\begin{DoxyCode}
816 {
817     if (++store_idx >= SQEntries)
818         store_idx = 0;
819 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_ae8565b0968a8115705f1585e8aa21f75}{
\index{OzoneLSQ@{OzoneLSQ}!init@{init}}
\index{init@{init}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ({\bf Params} $\ast$ {\em params}, \/  unsigned {\em maxLQEntries}, \/  unsigned {\em maxSQEntries}, \/  unsigned {\em id})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_ae8565b0968a8115705f1585e8aa21f75}
Initializes the \hyperlink{classLSQ}{LSQ} unit with the specified number of entries. 


\begin{DoxyCode}
82 {
83     DPRINTF(OzoneLSQ, "Creating OzoneLSQ%i object.\n",id);
84 
85     lsqID = id;
86 
87     LQEntries = maxLQEntries;
88     SQEntries = maxSQEntries;
89 
90     loadQueue.resize(LQEntries);
91     storeQueue.resize(SQEntries);
92 
93 
94     // May want to initialize these entries to NULL
95 
96     loadHead = loadTail = 0;
97 
98     storeHead = storeWBIdx = storeTail = 0;
99 
100     usedPorts = 0;
101     cachePorts = params->cachePorts;
102 
103     dcacheInterface = params->dcacheInterface;
104 
105     loadFaultInst = storeFaultInst = memDepViolator = NULL;
106 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a773e88db1aa010c3755e603493bf40ec}{
\index{OzoneLSQ@{OzoneLSQ}!insert@{insert}}
\index{insert@{insert}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{insert}]{\setlength{\rightskip}{0pt plus 5cm}void insert ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a773e88db1aa010c3755e603493bf40ec}
Inserts an instruction. 


\begin{DoxyCode}
165 {
166     // Make sure we really have a memory reference.
167     assert(inst->isMemRef());
168 
169     // Make sure it's one of the two classes of memory references.
170     assert(inst->isLoad() || inst->isStore());
171 
172     if (inst->isLoad()) {
173         insertLoad(inst);
174     } else {
175         insertStore(inst);
176     }
177 
178 //    inst->setInLSQ();
179 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_ad22b3ecafed2bcd9c59fcab049a1cb98}{
\index{OzoneLSQ@{OzoneLSQ}!insertLoad@{insertLoad}}
\index{insertLoad@{insertLoad}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{insertLoad}]{\setlength{\rightskip}{0pt plus 5cm}void insertLoad ({\bf DynInstPtr} \& {\em load\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_ad22b3ecafed2bcd9c59fcab049a1cb98}
Inserts a load instruction. 


\begin{DoxyCode}
184 {
185     assert((loadTail + 1) % LQEntries != loadHead && loads < LQEntries);
186 
187     DPRINTF(OzoneLSQ, "Inserting load PC %#x, idx:%i [sn:%lli]\n",
188             load_inst->readPC(), loadTail, load_inst->seqNum);
189 
190     load_inst->lqIdx = loadTail;
191 
192     if (stores == 0) {
193         load_inst->sqIdx = -1;
194     } else {
195         load_inst->sqIdx = storeTail;
196     }
197 
198     loadQueue[loadTail] = load_inst;
199 
200     incrLdIdx(loadTail);
201 
202     ++loads;
203 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a6a4b4e51bfff3639932ebaba45e8a282}{
\index{OzoneLSQ@{OzoneLSQ}!insertStore@{insertStore}}
\index{insertStore@{insertStore}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{insertStore}]{\setlength{\rightskip}{0pt plus 5cm}void insertStore ({\bf DynInstPtr} \& {\em store\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a6a4b4e51bfff3639932ebaba45e8a282}
Inserts a store instruction. 


\begin{DoxyCode}
208 {
209     // Make sure it is not full before inserting an instruction.
210     assert((storeTail + 1) % SQEntries != storeHead);
211     assert(stores < SQEntries);
212 
213     DPRINTF(OzoneLSQ, "Inserting store PC %#x, idx:%i [sn:%lli]\n",
214             store_inst->readPC(), storeTail, store_inst->seqNum);
215 
216     store_inst->sqIdx = storeTail;
217     store_inst->lqIdx = loadTail;
218 
219     storeQueue[storeTail] = SQEntry(store_inst);
220 
221     incrStIdx(storeTail);
222 
223     ++stores;
224 
225 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a3e70330939fdfc4dbc2f60c1a660584d}{
\index{OzoneLSQ@{OzoneLSQ}!isFull@{isFull}}
\index{isFull@{isFull}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{isFull}]{\setlength{\rightskip}{0pt plus 5cm}bool isFull ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a3e70330939fdfc4dbc2f60c1a660584d}
Returns if either the LQ or SQ is full. 


\begin{DoxyCode}
195 { return lqFull() || sqFull(); }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_af8eb8590fbfa6ecd2f796390677a4c00}{
\index{OzoneLSQ@{OzoneLSQ}!isStalled@{isStalled}}
\index{isStalled@{isStalled}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{isStalled}]{\setlength{\rightskip}{0pt plus 5cm}bool isStalled ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_af8eb8590fbfa6ecd2f796390677a4c00}
Returns whether or not the \hyperlink{classLSQ}{LSQ} unit is stalled. 


\begin{DoxyCode}
403 { return stalled; }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a05c413ba417c6453e99f75d87c958590}{
\index{OzoneLSQ@{OzoneLSQ}!loadBlocked@{loadBlocked}}
\index{loadBlocked@{loadBlocked}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{loadBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool loadBlocked ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a05c413ba417c6453e99f75d87c958590}
Returns if a load became blocked due to the memory system. It clears the bool's value upon this being called. 


\begin{DoxyCode}
630 {
631     bool ret_val = isLoadBlocked;
632     isLoadBlocked = false;
633     return ret_val;
634 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a5893daf623130be826f492bbff58f757}{
\index{OzoneLSQ@{OzoneLSQ}!lqFull@{lqFull}}
\index{lqFull@{lqFull}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{lqFull}]{\setlength{\rightskip}{0pt plus 5cm}bool lqFull ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a5893daf623130be826f492bbff58f757}
Returns if the LQ is full. 


\begin{DoxyCode}
198 { return loads >= (LQEntries - 1); }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{OzoneLSQ@{OzoneLSQ}!name@{name}}
\index{name@{name}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a37627d5d5bba7f4a8690c71c2ab3cb07}
Returns the name of the \hyperlink{classLSQ}{LSQ} unit. 


\begin{DoxyCode}
111 {
112     return "lsqunit";
113 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a028971a565aca048c67ea1c36a6a9d51}{
\index{OzoneLSQ@{OzoneLSQ}!numFreeEntries@{numFreeEntries}}
\index{numFreeEntries@{numFreeEntries}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{numFreeEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned numFreeEntries ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a028971a565aca048c67ea1c36a6a9d51}
Returns the number of free entries (min of free LQ and SQ entries). 


\begin{DoxyCode}
241 {
242     unsigned free_lq_entries = LQEntries - loads;
243     unsigned free_sq_entries = SQEntries - stores;
244 
245     // Both the LQ and SQ entries have an extra dummy entry to differentiate
246     // empty/full conditions.  Subtract 1 from the free entries.
247     if (free_lq_entries < free_sq_entries) {
248         return free_lq_entries - 1;
249     } else {
250         return free_sq_entries - 1;
251     }
252 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a54460b759fb06e2b18e26657279a6f49}{
\index{OzoneLSQ@{OzoneLSQ}!numLoads@{numLoads}}
\index{numLoads@{numLoads}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{numLoads}]{\setlength{\rightskip}{0pt plus 5cm}int numLoads ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a54460b759fb06e2b18e26657279a6f49}
Returns the number of loads in the LQ. 


\begin{DoxyCode}
189 { return loads; }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a9aa5d5a61b2229931008ac2ea802a3ab}{
\index{OzoneLSQ@{OzoneLSQ}!numLoadsReady@{numLoadsReady}}
\index{numLoadsReady@{numLoadsReady}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{numLoadsReady}]{\setlength{\rightskip}{0pt plus 5cm}int numLoadsReady ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a9aa5d5a61b2229931008ac2ea802a3ab}
Returns the number of loads ready to execute. 


\begin{DoxyCode}
257 {
258     int load_idx = loadHead;
259     int retval = 0;
260 
261     while (load_idx != loadTail) {
262         assert(loadQueue[load_idx]);
263 
264         if (loadQueue[load_idx]->readyToIssue()) {
265             ++retval;
266         }
267     }
268 
269     return retval;
270 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_aa0fc32a4a9d77696f5907f4d25e7d07f}{
\index{OzoneLSQ@{OzoneLSQ}!numStores@{numStores}}
\index{numStores@{numStores}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{numStores}]{\setlength{\rightskip}{0pt plus 5cm}int numStores ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_aa0fc32a4a9d77696f5907f4d25e7d07f}
Returns the number of stores in the SQ. 


\begin{DoxyCode}
192 { return stores; }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a276cdbdaf4551f1b846c4e2535c5f882}{
\index{OzoneLSQ@{OzoneLSQ}!numStoresToWB@{numStoresToWB}}
\index{numStoresToWB@{numStoresToWB}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{numStoresToWB}]{\setlength{\rightskip}{0pt plus 5cm}int numStoresToWB ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a276cdbdaf4551f1b846c4e2535c5f882}
Returns the number of stores to writeback. 


\begin{DoxyCode}
213 { return storesToWB; }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_ad2981b6704bca036af0723daaaebe57e}{
\index{OzoneLSQ@{OzoneLSQ}!read@{read}}
\index{read@{read}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} read (MemReqPtr \& {\em req}, \/  T \& {\em data}, \/  int {\em load\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_ad2981b6704bca036af0723daaaebe57e}
Executes the load at the given index. 


\begin{DoxyCode}
410 {
411     //Depending on issue2execute delay a squashed load could
412     //execute if it is found to be squashed in the same
413     //cycle it is scheduled to execute
414     assert(loadQueue[load_idx]);
415 
416     if (loadQueue[load_idx]->isExecuted()) {
417         panic("Should not reach this point with split ops!");
418 
419         memcpy(&data,req->data,req->size);
420 
421         return NoFault;
422     }
423 
424     // Make sure this isn't an uncacheable access
425     // A bit of a hackish way to get uncached accesses to work only if they're
426     // at the head of the LSQ and are ready to commit (at the head of the ROB
427     // too).
428     // @todo: Fix uncached accesses.
429     if (req->isUncacheable() &&
430         (load_idx != loadHead || !loadQueue[load_idx]->readyToCommit())) {
431 
432         return TheISA::genMachineCheckFault();
433     }
434 
435     // Check the SQ for any previous stores that might lead to forwarding
436     int store_idx = loadQueue[load_idx]->sqIdx;
437 
438     int store_size = 0;
439 
440     DPRINTF(OzoneLSQ, "Read called, load idx: %i, store idx: %i, "
441             "storeHead: %i addr: %#x\n",
442             load_idx, store_idx, storeHead, req->paddr);
443 
444     while (store_idx != -1) {
445         // End once we've reached the top of the LSQ
446         if (store_idx == storeWBIdx) {
447             break;
448         }
449 
450         // Move the index to one younger
451         if (--store_idx < 0)
452             store_idx += SQEntries;
453 
454         assert(storeQueue[store_idx].inst);
455 
456         store_size = storeQueue[store_idx].size;
457 
458         if (store_size == 0)
459             continue;
460 
461         // Check if the store data is within the lower and upper bounds of
462         // addresses that the request needs.
463         bool store_has_lower_limit =
464             req->vaddr >= storeQueue[store_idx].inst->effAddr;
465         bool store_has_upper_limit =
466             (req->vaddr + req->size) <= (storeQueue[store_idx].inst->effAddr +
467                                          store_size);
468         bool lower_load_has_store_part =
469             req->vaddr < (storeQueue[store_idx].inst->effAddr +
470                            store_size);
471         bool upper_load_has_store_part =
472             (req->vaddr + req->size) > storeQueue[store_idx].inst->effAddr;
473 
474         // If the store's data has all of the data needed, we can forward.
475         if (store_has_lower_limit && store_has_upper_limit) {
476 
477             int shift_amt = req->vaddr & (store_size - 1);
478             // Assumes byte addressing
479             shift_amt = shift_amt << 3;
480 
481             // Cast this to type T?
482             data = storeQueue[store_idx].data >> shift_amt;
483 
484             req->cmd = Read;
485             assert(!req->completionEvent);
486             req->completionEvent = NULL;
487             req->time = curTick();
488             assert(!req->data);
489             req->data = new uint8_t[64];
490 
491             memcpy(req->data, &data, req->size);
492 
493             DPRINTF(OzoneLSQ, "Forwarding from store idx %i to load to "
494                     "addr %#x, data %#x\n",
495                     store_idx, req->vaddr, *(req->data));
496 
497             typename BackEnd::LdWritebackEvent *wb =
498                 new typename BackEnd::LdWritebackEvent(loadQueue[load_idx],
499                                                        be);
500 
501             // We'll say this has a 1 cycle load-store forwarding latency
502             // for now.
503             // FIXME - Need to make this a parameter.
504             wb->schedule(curTick());
505 
506             // Should keep track of stat for forwarded data
507             return NoFault;
508         } else if ((store_has_lower_limit && lower_load_has_store_part) ||
509                    (store_has_upper_limit && upper_load_has_store_part) ||
510                    (lower_load_has_store_part && upper_load_has_store_part)) {
511             // This is the partial store-load forwarding case where a store
512             // has only part of the load's data.
513 
514             // If it's already been written back, then don't worry about
515             // stalling on it.
516             if (storeQueue[store_idx].completed) {
517                 continue;
518             }
519 
520             // Must stall load and force it to retry, so long as it's the oldest
521             // load that needs to do so.
522             if (!stalled ||
523                 (stalled &&
524                  loadQueue[load_idx]->seqNum <
525                  loadQueue[stallingLoadIdx]->seqNum)) {
526                 stalled = true;
527                 stallingStoreIsn = storeQueue[store_idx].inst->seqNum;
528                 stallingLoadIdx = load_idx;
529             }
530 
531             // Tell IQ/mem dep unit that this instruction will need to be
532             // rescheduled eventually
533             be->rescheduleMemInst(loadQueue[load_idx]);
534 
535             DPRINTF(OzoneLSQ, "Load-store forwarding mis-match. "
536                     "Store idx %i to load addr %#x\n",
537                     store_idx, req->vaddr);
538 
539             return NoFault;
540         }
541     }
542 
543 
544     // If there's no forwarding case, then go access memory
545     DynInstPtr inst = loadQueue[load_idx];
546 
547     ++usedPorts;
548 
549     // if we have a cache, do cache access too
550     if (dcacheInterface) {
551         if (dcacheInterface->isBlocked()) {
552             isLoadBlocked = true;
553             // No fault occurred, even though the interface is blocked.
554             return NoFault;
555         }
556 
557         DPRINTF(OzoneLSQ, "D-cache: PC:%#x reading from paddr:%#x "
558                 "vaddr:%#x flags:%i\n",
559                 inst->readPC(), req->paddr, req->vaddr, req->flags);
560 
561         // Setup MemReq pointer
562         req->cmd = Read;
563         req->completionEvent = NULL;
564         req->time = curTick();
565         assert(!req->data);
566         req->data = new uint8_t[64];
567 
568         assert(!req->completionEvent);
569         typedef typename BackEnd::LdWritebackEvent LdWritebackEvent;
570 
571         LdWritebackEvent *wb = new LdWritebackEvent(loadQueue[load_idx], be);
572 
573         req->completionEvent = wb;
574 
575         // Do Cache Access
576         MemAccessResult result = dcacheInterface->access(req);
577 
578         // Ugly hack to get an event scheduled *only* if the access is
579         // a miss.  We really should add first-class support for this
580         // at some point.
581         // @todo: Probably should support having no events
582         if (result != MA_HIT) {
583             DPRINTF(OzoneLSQ, "D-cache miss!\n");
584             DPRINTF(Activity, "Activity: ld accessing mem miss [sn:%lli]\n",
585                     inst->seqNum);
586 
587             lastDcacheStall = curTick();
588 
589             _status = DcacheMissStall;
590 
591             wb->setDcacheMiss();
592 
593         } else {
594 //            DPRINTF(Activity, "Activity: ld accessing mem hit [sn:%lli]\n",
595 //                    inst->seqNum);
596 
597             DPRINTF(OzoneLSQ, "D-cache hit!\n");
598         }
599     } else {
600         fatal("Must use D-cache with new memory system");
601     }
602 
603     return NoFault;
604 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a3bc9500810cb2d5615e29206e2d6499f}{
\index{OzoneLSQ@{OzoneLSQ}!resizeLQ@{resizeLQ}}
\index{resizeLQ@{resizeLQ}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{resizeLQ}]{\setlength{\rightskip}{0pt plus 5cm}void resizeLQ (unsigned {\em size})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a3bc9500810cb2d5615e29206e2d6499f}
Resizes the LQ to a given size. 


\begin{DoxyCode}
132 {
133     assert( size >= LQEntries);
134 
135     if (size > LQEntries) {
136         while (size > loadQueue.size()) {
137             DynInstPtr dummy;
138             loadQueue.push_back(dummy);
139             LQEntries++;
140         }
141     } else {
142         LQEntries = size;
143     }
144 
145 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a341dd6a3bd8d240659fd9d698c3b5c65}{
\index{OzoneLSQ@{OzoneLSQ}!resizeSQ@{resizeSQ}}
\index{resizeSQ@{resizeSQ}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{resizeSQ}]{\setlength{\rightskip}{0pt plus 5cm}void resizeSQ (unsigned {\em size})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a341dd6a3bd8d240659fd9d698c3b5c65}
Resizes the SQ to a given size. 


\begin{DoxyCode}
150 {
151     if (size > SQEntries) {
152         while (size > storeQueue.size()) {
153             SQEntry dummy;
154             storeQueue.push_back(dummy);
155             SQEntries++;
156         }
157     } else {
158         SQEntries = size;
159     }
160 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a9134276ed85820d74779ad5826580822}{
\index{OzoneLSQ@{OzoneLSQ}!setBE@{setBE}}
\index{setBE@{setBE}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{setBE}]{\setlength{\rightskip}{0pt plus 5cm}void setBE ({\bf BackEnd} $\ast$ {\em be\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a9134276ed85820d74779ad5826580822}
Sets the back-\/end stage pointer. 


\begin{DoxyCode}
115     { be = be_ptr; }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_ad491c9766121fc19aa77fd0723e7641d}{
\index{OzoneLSQ@{OzoneLSQ}!setCPU@{setCPU}}
\index{setCPU@{setCPU}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{setCPU}]{\setlength{\rightskip}{0pt plus 5cm}void setCPU ({\bf FullCPU} $\ast$ {\em cpu\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_ad491c9766121fc19aa77fd0723e7641d}
Sets the CPU pointer. 


\begin{DoxyCode}
111     { cpu = cpu_ptr; }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a477981d1f905d2d398a1527f7149e3c4}{
\index{OzoneLSQ@{OzoneLSQ}!sqFull@{sqFull}}
\index{sqFull@{sqFull}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{sqFull}]{\setlength{\rightskip}{0pt plus 5cm}bool sqFull ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a477981d1f905d2d398a1527f7149e3c4}
Returns if the SQ is full. 


\begin{DoxyCode}
201 { return stores >= (SQEntries - 1); }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a51dd7e304d5413447717826fac6f4921}{
\index{OzoneLSQ@{OzoneLSQ}!squash@{squash}}
\index{squash@{squash}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash (const {\bf InstSeqNum} \& {\em squashed\_\-num})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a51dd7e304d5413447717826fac6f4921}
Squashes all instructions younger than a specific sequence number. 


\begin{DoxyCode}
677 {
678     DPRINTF(OzoneLSQ, "Squashing until [sn:%lli]!"
679             "(Loads:%i Stores:%i)\n",squashed_num,loads,stores);
680 
681     int load_idx = loadTail;
682     decrLdIdx(load_idx);
683 
684     while (loads != 0 && loadQueue[load_idx]->seqNum > squashed_num) {
685 
686         // Clear the smart pointer to make sure it is decremented.
687         DPRINTF(OzoneLSQ,"Load Instruction PC %#x squashed, "
688                 "[sn:%lli]\n",
689                 loadQueue[load_idx]->readPC(),
690                 loadQueue[load_idx]->seqNum);
691 
692         if (isStalled() && load_idx == stallingLoadIdx) {
693             stalled = false;
694             stallingStoreIsn = 0;
695             stallingLoadIdx = 0;
696         }
697 
698 //        loadQueue[load_idx]->squashed = true;
699         loadQueue[load_idx] = NULL;
700         --loads;
701 
702         // Inefficient!
703         loadTail = load_idx;
704 
705         decrLdIdx(load_idx);
706     }
707 
708     int store_idx = storeTail;
709     decrStIdx(store_idx);
710 
711     while (stores != 0 && storeQueue[store_idx].inst->seqNum > squashed_num) {
712 
713         // Clear the smart pointer to make sure it is decremented.
714         DPRINTF(OzoneLSQ,"Store Instruction PC %#x squashed, "
715                 "idx:%i [sn:%lli]\n",
716                 storeQueue[store_idx].inst->readPC(),
717                 store_idx, storeQueue[store_idx].inst->seqNum);
718 
719         // I don't think this can happen.  It should have been cleared by the
720         // stalling load.
721         if (isStalled() &&
722             storeQueue[store_idx].inst->seqNum == stallingStoreIsn) {
723             panic("Is stalled should have been cleared by stalling load!\n");
724             stalled = false;
725             stallingStoreIsn = 0;
726         }
727 
728 //        storeQueue[store_idx].inst->squashed = true;
729         storeQueue[store_idx].inst = NULL;
730         storeQueue[store_idx].canWB = 0;
731 
732         if (storeQueue[store_idx].req) {
733             assert(!storeQueue[store_idx].req->completionEvent);
734         }
735         storeQueue[store_idx].req = NULL;
736         --stores;
737 
738         // Inefficient!
739         storeTail = store_idx;
740 
741         decrStIdx(store_idx);
742     }
743 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a873dd91783f9efb4a590aded1f70d6b0}{
\index{OzoneLSQ@{OzoneLSQ}!tick@{tick}}
\index{tick@{tick}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a873dd91783f9efb4a590aded1f70d6b0}
Ticks the \hyperlink{classLSQ}{LSQ} unit, which in this case only resets the number of used cache ports. \begin{Desc}
\item[\hyperlink{todo__todo000044}{TODO}]: Move the number of used ports up to the \hyperlink{classLSQ}{LSQ} level so it can be shared by all \hyperlink{classLSQ}{LSQ} units. \end{Desc}



\begin{DoxyCode}
122 { usedPorts = 0; }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a4f720bbfb5fdefdb23516500eeb0b4de}{
\index{OzoneLSQ@{OzoneLSQ}!violation@{violation}}
\index{violation@{violation}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{violation}]{\setlength{\rightskip}{0pt plus 5cm}bool violation ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a4f720bbfb5fdefdb23516500eeb0b4de}
Returns if there is a memory ordering violation. Value is reset upon call to \hyperlink{classOzoneLSQ_a30adaf6f5fb6b38b5747f35c419e3f31}{getMemDepViolator()}. 


\begin{DoxyCode}
172 { return memDepViolator; }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a338be821734603396bfef8d9fb8f04b0}{
\index{OzoneLSQ@{OzoneLSQ}!willWB@{willWB}}
\index{willWB@{willWB}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{willWB}]{\setlength{\rightskip}{0pt plus 5cm}bool willWB ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a338be821734603396bfef8d9fb8f04b0}
Returns if the \hyperlink{classLSQ}{LSQ} unit will writeback on this cycle. 


\begin{DoxyCode}
216                   { return storeQueue[storeWBIdx].canWB &&
217                         !storeQueue[storeWBIdx].completed &&
218                         !dcacheInterface->isBlocked(); }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a173162a41482ee35c5a15394b4befa4b}{
\index{OzoneLSQ@{OzoneLSQ}!write@{write}}
\index{write@{write}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} write (MemReqPtr \& {\em req}, \/  T \& {\em data}, \/  int {\em store\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a173162a41482ee35c5a15394b4befa4b}
Executes the store at the given index. 


\begin{DoxyCode}
610 {
611     assert(storeQueue[store_idx].inst);
612 
613     DPRINTF(OzoneLSQ, "Doing write to store idx %i, addr %#x data %#x"
614             " | storeHead:%i [sn:%i]\n",
615             store_idx, req->paddr, data, storeHead,
616             storeQueue[store_idx].inst->seqNum);
617 
618     storeQueue[store_idx].req = req;
619     storeQueue[store_idx].size = sizeof(T);
620     storeQueue[store_idx].data = data;
621 
622     // This function only writes the data to the store queue, so no fault
623     // can happen here.
624     return NoFault;
625 }
\end{DoxyCode}
\hypertarget{classOzoneLSQ_a5f04e29d6f6feb8b86460491f2ba7547}{
\index{OzoneLSQ@{OzoneLSQ}!writebackStores@{writebackStores}}
\index{writebackStores@{writebackStores}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{writebackStores}]{\setlength{\rightskip}{0pt plus 5cm}void writebackStores ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLSQ_a5f04e29d6f6feb8b86460491f2ba7547}
Writes back stores. 


\begin{DoxyCode}
524 {
525     while (storesToWB > 0 &&
526            storeWBIdx != storeTail &&
527            storeQueue[storeWBIdx].inst &&
528            storeQueue[storeWBIdx].canWB &&
529            usedPorts < cachePorts) {
530 
531         if (storeQueue[storeWBIdx].size == 0) {
532             completeStore(storeWBIdx);
533 
534             incrStIdx(storeWBIdx);
535 
536             continue;
537         }
538 
539         if (dcacheInterface && dcacheInterface->isBlocked()) {
540             DPRINTF(OzoneLSQ, "Unable to write back any more stores, cache"
541                     " is blocked!\n");
542             break;
543         }
544 
545         ++usedPorts;
546 
547         if (storeQueue[storeWBIdx].inst->isDataPrefetch()) {
548             incrStIdx(storeWBIdx);
549 
550             continue;
551         }
552 
553         assert(storeQueue[storeWBIdx].req);
554         assert(!storeQueue[storeWBIdx].committed);
555 
556         MemReqPtr req = storeQueue[storeWBIdx].req;
557         storeQueue[storeWBIdx].committed = true;
558 
559 //      Fault fault = cpu->translateDataReadReq(req);
560         req->cmd = Write;
561         req->completionEvent = NULL;
562         req->time = curTick();
563         assert(!req->data);
564         req->data = new uint8_t[64];
565         memcpy(req->data, (uint8_t *)&storeQueue[storeWBIdx].data, req->size);
566 
567         DPRINTF(OzoneLSQ, "D-Cache: Writing back store idx:%i PC:%#x "
568                 "to Addr:%#x, data:%#x [sn:%lli]\n",
569                 storeWBIdx,storeQueue[storeWBIdx].inst->readPC(),
570                 req->paddr, *(req->data),
571                 storeQueue[storeWBIdx].inst->seqNum);
572 
573 //        if (fault != NoFault) {
574             //What should we do if there is a fault???
575             //for now panic
576 //            panic("Page Table Fault!!!!!\n");
577 //        }
578 
579         if (dcacheInterface) {
580             MemAccessResult result = dcacheInterface->access(req);
581 
582             //@todo temp fix for LL/SC (works fine for 1 CPU)
583             if (req->isLLSC()) {
584                 req->result=1;
585                 panic("LL/SC! oh no no support!!!");
586             }
587 
588             if (isStalled() &&
589                 storeQueue[storeWBIdx].inst->seqNum == stallingStoreIsn) {
590                 DPRINTF(OzoneLSQ, "Unstalling, stalling store [sn:%lli] "
591                         "load idx:%i\n",
592                         stallingStoreIsn, stallingLoadIdx);
593                 stalled = false;
594                 stallingStoreIsn = 0;
595                 be->replayMemInst(loadQueue[stallingLoadIdx]);
596             }
597 
598             if (result != MA_HIT && dcacheInterface->doEvents()) {
599                 Event *wb = NULL;
600 /*
601                 typename IEW::LdWritebackEvent *wb = NULL;
602                 if (req->isLLSC()) {
603                     // Stx_C does not generate a system port transaction.
604                     req->result=0;
605                     wb = new typename IEW::LdWritebackEvent(storeQueue[storeWBIdx
      ].inst,
606                                                             iewStage);
607                 }
608 */
609                 DPRINTF(OzoneLSQ,"D-Cache Write Miss!\n");
610 
611 //                DPRINTF(Activity, "Active st accessing mem miss [sn:%lli]\n",
612 //                        storeQueue[storeWBIdx].inst->seqNum);
613 
614                 // Will stores need their own kind of writeback events?
615                 // Do stores even need writeback events?
616                 assert(!req->completionEvent);
617                 req->completionEvent = new
618                     StoreCompletionEvent(storeWBIdx, wb, this);
619 
620                 lastDcacheStall = curTick();
621 
622                 _status = DcacheMissStall;
623 
624                 //mshrSeqNums.push_back(storeQueue[storeWBIdx].inst->seqNum);
625 
626                 //DPRINTF(OzoneLSQ, "Added MSHR. count = %i\n",mshrSeqNums.size()
      );
627 
628                 // Increment stat here or something
629             } else {
630                 DPRINTF(OzoneLSQ,"D-Cache: Write Hit on idx:%i !\n",
631                         storeWBIdx);
632 
633 //                DPRINTF(Activity, "Active st accessing mem hit [sn:%lli]\n",
634 //                        storeQueue[storeWBIdx].inst->seqNum);
635 
636                 if (req->isLLSC()) {
637                     // Stx_C does not generate a system port transaction.
638                     req->result=1;
639                     typename BackEnd::LdWritebackEvent *wb =
640                         new typename BackEnd::LdWritebackEvent(storeQueue[
      storeWBIdx].inst,
641                                                                be);
642                     wb->schedule(curTick());
643                 }
644 
645                 completeStore(storeWBIdx);
646             }
647 
648             incrStIdx(storeWBIdx);
649         } else {
650             panic("Must HAVE DCACHE!!!!!\n");
651         }
652     }
653 
654     // Not sure this should set it to 0.
655     usedPorts = 0;
656 
657     assert(stores >= 0 && storesToWB >= 0);
658 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classOzoneLSQ_a8f5ca1839f53a90564710f1349dd0199}{
\index{OzoneLSQ@{OzoneLSQ}!StoreCompletionEvent@{StoreCompletionEvent}}
\index{StoreCompletionEvent@{StoreCompletionEvent}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{StoreCompletionEvent}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf StoreCompletionEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classOzoneLSQ_a8f5ca1839f53a90564710f1349dd0199}


\subsection{変数}
\hypertarget{classOzoneLSQ_a6cdf6e6db875a442f3ab6db542bd2bb5}{
\index{OzoneLSQ@{OzoneLSQ}!\_\-status@{\_\-status}}
\index{\_\-status@{\_\-status}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{\_\-status}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Status} {\bf \_\-status}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_a6cdf6e6db875a442f3ab6db542bd2bb5}
The status of the \hyperlink{classLSQ}{LSQ} unit. \hypertarget{classOzoneLSQ_a84f815aa1fa864ba2e6d75f5ad2b52d1}{
\index{OzoneLSQ@{OzoneLSQ}!be@{be}}
\index{be@{be}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{be}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BackEnd}$\ast$ {\bf be}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_a84f815aa1fa864ba2e6d75f5ad2b52d1}
Pointer to the back-\/end stage. \hypertarget{classOzoneLSQ_ab2e23636971c40e7ed945026b2a184e1}{
\index{OzoneLSQ@{OzoneLSQ}!cachePorts@{cachePorts}}
\index{cachePorts@{cachePorts}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{cachePorts}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf cachePorts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_ab2e23636971c40e7ed945026b2a184e1}
\begin{Desc}
\item[\hyperlink{todo__todo000045}{TODO}]Consider moving to a more advanced model with write vs read ports \end{Desc}
The number of cache ports available each cycle. \hypertarget{classOzoneLSQ_a766385c2941cd46525f4d9dff90200a2}{
\index{OzoneLSQ@{OzoneLSQ}!cpu@{cpu}}
\index{cpu@{cpu}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FullCPU}$\ast$ {\bf cpu}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_a766385c2941cd46525f4d9dff90200a2}
Pointer to the CPU. \hypertarget{classOzoneLSQ_a22dc8294eecb144fbdd951d2e32e9330}{
\index{OzoneLSQ@{OzoneLSQ}!dcacheInterface@{dcacheInterface}}
\index{dcacheInterface@{dcacheInterface}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{dcacheInterface}]{\setlength{\rightskip}{0pt plus 5cm}MemInterface$\ast$ {\bf dcacheInterface}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_a22dc8294eecb144fbdd951d2e32e9330}
Pointer to the D-\/cache. \hypertarget{classOzoneLSQ_af6f43373b6586aa8c486538fb076effb}{
\index{OzoneLSQ@{OzoneLSQ}!fromIssue@{fromIssue}}
\index{fromIssue@{fromIssue}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{fromIssue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf IssueStruct}$>$::wire {\bf fromIssue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_af6f43373b6586aa8c486538fb076effb}
\hyperlink{classWire}{Wire} to read information from the issue stage time queue. \hypertarget{classOzoneLSQ_a95dc31b4ce3ebcb6b9d75a510b3a128c}{
\index{OzoneLSQ@{OzoneLSQ}!isLoadBlocked@{isLoadBlocked}}
\index{isLoadBlocked@{isLoadBlocked}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{isLoadBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf isLoadBlocked}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_a95dc31b4ce3ebcb6b9d75a510b3a128c}
Whether or not a load is blocked due to the memory system. It is cleared when this value is checked via \hyperlink{classOzoneLSQ_a05c413ba417c6453e99f75d87c958590}{loadBlocked()}. \hypertarget{classOzoneLSQ_a8b4696062ef09ab956804a7a99491853}{
\index{OzoneLSQ@{OzoneLSQ}!lastDcacheStall@{lastDcacheStall}}
\index{lastDcacheStall@{lastDcacheStall}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{lastDcacheStall}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Counter} {\bf lastDcacheStall}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_a8b4696062ef09ab956804a7a99491853}
\hypertarget{classOzoneLSQ_a7123aa8b10829cc4712dff5454e13978}{
\index{OzoneLSQ@{OzoneLSQ}!loadFaultInst@{loadFaultInst}}
\index{loadFaultInst@{loadFaultInst}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{loadFaultInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf loadFaultInst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_a7123aa8b10829cc4712dff5454e13978}
The oldest faulting load instruction. \hypertarget{classOzoneLSQ_ac09af89928d2ef4da4cbdcfce26fa3f5}{
\index{OzoneLSQ@{OzoneLSQ}!loadHead@{loadHead}}
\index{loadHead@{loadHead}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{loadHead}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf loadHead}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_ac09af89928d2ef4da4cbdcfce26fa3f5}
The index of the head instruction in the LQ. \hypertarget{classOzoneLSQ_aa5f3703c5d7c5ce21a497352b94c7465}{
\index{OzoneLSQ@{OzoneLSQ}!loadQueue@{loadQueue}}
\index{loadQueue@{loadQueue}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{loadQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf DynInstPtr}$>$ {\bf loadQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_aa5f3703c5d7c5ce21a497352b94c7465}
The load queue. \hypertarget{classOzoneLSQ_a867971f18e464abd16193e069c64a8ad}{
\index{OzoneLSQ@{OzoneLSQ}!loads@{loads}}
\index{loads@{loads}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{loads}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf loads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_a867971f18e464abd16193e069c64a8ad}
The number of load instructions in the LQ. \hypertarget{classOzoneLSQ_a973a489225da164cc85e690f13c86841}{
\index{OzoneLSQ@{OzoneLSQ}!loadTail@{loadTail}}
\index{loadTail@{loadTail}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{loadTail}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf loadTail}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_a973a489225da164cc85e690f13c86841}
The index of the tail instruction in the LQ. \hypertarget{classOzoneLSQ_aafa99d800d574095881acbacdbbbcc47}{
\index{OzoneLSQ@{OzoneLSQ}!LQEntries@{LQEntries}}
\index{LQEntries@{LQEntries}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{LQEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf LQEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_aafa99d800d574095881acbacdbbbcc47}
The number of LQ entries. \hypertarget{classOzoneLSQ_adfd96fbbaa327a31d20f0d4134418fad}{
\index{OzoneLSQ@{OzoneLSQ}!lsqID@{lsqID}}
\index{lsqID@{lsqID}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{lsqID}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf lsqID}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_adfd96fbbaa327a31d20f0d4134418fad}
The \hyperlink{classOzoneLSQ}{OzoneLSQ} thread id. \hypertarget{classOzoneLSQ_a270a20c3fa52139e0538288275db9d22}{
\index{OzoneLSQ@{OzoneLSQ}!memDepViolator@{memDepViolator}}
\index{memDepViolator@{memDepViolator}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{memDepViolator}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf memDepViolator}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_a270a20c3fa52139e0538288275db9d22}
The oldest load that caused a memory ordering violation. \hypertarget{classOzoneLSQ_ad14ffa23ad731f6003755b643f999049}{
\index{OzoneLSQ@{OzoneLSQ}!pTable@{pTable}}
\index{pTable@{pTable}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{pTable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PageTable}$\ast$ {\bf pTable}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_ad14ffa23ad731f6003755b643f999049}
Pointer to the page table. \hypertarget{classOzoneLSQ_a38c8af5392da70119dc5cce4e3637cbc}{
\index{OzoneLSQ@{OzoneLSQ}!SQEntries@{SQEntries}}
\index{SQEntries@{SQEntries}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{SQEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf SQEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_a38c8af5392da70119dc5cce4e3637cbc}
The number of SQ entries. \hypertarget{classOzoneLSQ_a6f8bff553ad30865c7d0c62e05421eb8}{
\index{OzoneLSQ@{OzoneLSQ}!stalled@{stalled}}
\index{stalled@{stalled}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{stalled}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf stalled}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_a6f8bff553ad30865c7d0c62e05421eb8}
Whether or not the \hyperlink{classLSQ}{LSQ} is stalled. \hypertarget{classOzoneLSQ_af55bc9000c8b4e4cfcfbd018feca12a7}{
\index{OzoneLSQ@{OzoneLSQ}!stallingLoadIdx@{stallingLoadIdx}}
\index{stallingLoadIdx@{stallingLoadIdx}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{stallingLoadIdx}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf stallingLoadIdx}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_af55bc9000c8b4e4cfcfbd018feca12a7}
The index of the above store. \hypertarget{classOzoneLSQ_afe1cdcfca6b44c28581d862228adc3da}{
\index{OzoneLSQ@{OzoneLSQ}!stallingStoreIsn@{stallingStoreIsn}}
\index{stallingStoreIsn@{stallingStoreIsn}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{stallingStoreIsn}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf stallingStoreIsn}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_afe1cdcfca6b44c28581d862228adc3da}
The store that causes the stall due to partial store to load forwarding. \hypertarget{classOzoneLSQ_ab98cf7d5235b7402e8916e78569f4ab2}{
\index{OzoneLSQ@{OzoneLSQ}!storeFaultInst@{storeFaultInst}}
\index{storeFaultInst@{storeFaultInst}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{storeFaultInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf storeFaultInst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_ab98cf7d5235b7402e8916e78569f4ab2}
The oldest faulting store instruction. \hypertarget{classOzoneLSQ_a6e87b6f77102183080ea6ab8599b26a9}{
\index{OzoneLSQ@{OzoneLSQ}!storeHead@{storeHead}}
\index{storeHead@{storeHead}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{storeHead}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf storeHead}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_a6e87b6f77102183080ea6ab8599b26a9}
The index of the head instruction in the SQ. \hypertarget{classOzoneLSQ_a1d370cdc36d253e0f786d46c6af77a40}{
\index{OzoneLSQ@{OzoneLSQ}!storeQueue@{storeQueue}}
\index{storeQueue@{storeQueue}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{storeQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf SQEntry}$>$ {\bf storeQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_a1d370cdc36d253e0f786d46c6af77a40}
The store queue. \hypertarget{classOzoneLSQ_ade9e895aa9c5ace27779c985c4f43326}{
\index{OzoneLSQ@{OzoneLSQ}!stores@{stores}}
\index{stores@{stores}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{stores}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf stores}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_ade9e895aa9c5ace27779c985c4f43326}
The number of store instructions in the SQ (excludes those waiting to writeback). \hypertarget{classOzoneLSQ_a3831a7965ffbe90df177026988476f9c}{
\index{OzoneLSQ@{OzoneLSQ}!storesToWB@{storesToWB}}
\index{storesToWB@{storesToWB}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{storesToWB}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf storesToWB}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_a3831a7965ffbe90df177026988476f9c}
The number of store instructions in the SQ waiting to writeback. \hypertarget{classOzoneLSQ_acd5c7fbb5578b5cb505ffff16bbf6a8b}{
\index{OzoneLSQ@{OzoneLSQ}!storeTail@{storeTail}}
\index{storeTail@{storeTail}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{storeTail}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf storeTail}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_acd5c7fbb5578b5cb505ffff16bbf6a8b}
The index of the tail instruction in the SQ. \hypertarget{classOzoneLSQ_a9023e0813d4f3e566d17fb6334a2da02}{
\index{OzoneLSQ@{OzoneLSQ}!storeWBIdx@{storeWBIdx}}
\index{storeWBIdx@{storeWBIdx}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{storeWBIdx}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf storeWBIdx}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_a9023e0813d4f3e566d17fb6334a2da02}
The index of the first instruction that is ready to be written back, and has not yet been written back. \hypertarget{classOzoneLSQ_a03435d626b7567ed154de5d7d8c3d419}{
\index{OzoneLSQ@{OzoneLSQ}!usedPorts@{usedPorts}}
\index{usedPorts@{usedPorts}!OzoneLSQ@{OzoneLSQ}}
\subsubsection[{usedPorts}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf usedPorts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLSQ_a03435d626b7567ed154de5d7d8c3d419}
The number of used cache ports in this cycle. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/ozone/\hyperlink{ozone_2lsq__unit_8hh}{lsq\_\-unit.hh}\item 
cpu/ozone/\hyperlink{ozone_2lsq__unit__impl_8hh}{lsq\_\-unit\_\-impl.hh}\end{DoxyCompactItemize}
