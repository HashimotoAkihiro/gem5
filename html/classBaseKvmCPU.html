<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>File&nbsp;GEM5&nbsp;Wrapper: クラス BaseKvmCPU</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- 作成： Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>メインページ</span></a></li>
      <li><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>構成</span></a></li>
      <li><a href="classes.html"><span>構成索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>構成メンバ</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>クラス BaseKvmCPU</h1><!-- doxytag: class="BaseKvmCPU" --><!-- doxytag: inherits="BaseCPU" -->
<p><code>#include &lt;<a class="el" href="cpu_2kvm_2base_8hh_source.html">base.hh</a>&gt;</code></p>
<div class="dynheader">
BaseKvmCPUに対する継承グラフ</div>
<div class="dynsection">
 <div class="center">
  <img src="classBaseKvmCPU.gif" usemap="#BaseKvmCPU_map" alt=""/>
  <map id="BaseKvmCPU_map" name="BaseKvmCPU_map">
<area href="classBaseCPU.html" alt="BaseCPU" shape="rect" coords="148,0,237,24"/>
<area href="classArmKvmCPU.html" alt="ArmKvmCPU" shape="rect" coords="0,112,89,136"/>
<area href="classArmKvmCPU_1_1ArmKvmCPU.html" alt="ArmKvmCPU" shape="rect" coords="99,112,188,136"/>
<area href="classX86KvmCPU.html" alt="X86KvmCPU" shape="rect" coords="198,112,287,136"/>
<area href="classX86KvmCPU_1_1X86KvmCPU.html" alt="X86KvmCPU" shape="rect" coords="297,112,386,136"/>
</map>
 </div>
</div>

<p><a href="classBaseKvmCPU-members.html">すべてのメンバ一覧</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>構成</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU_1_1BaseKvmCPU.html">BaseKvmCPU</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU_1_1KVMCpuPort.html">KVMCpuPort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBaseKvmCPU_1_1TickEvent.html">TickEvent</a></td></tr>
<tr><td colspan="2"><h2>Public メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a9eb0b030bd0367a335c97b465d98f01c">BaseKvmCPU</a> (BaseKvmCPUParams *params)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#abd186de5de7d9b8e90d2c1f08daf1ecd">~BaseKvmCPU</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#aecc7d8debf54990ffeaaed5bac7d7d81">startup</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a4dc637449366fcdfc4e764cdf12d9b11">regStats</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a688ca491f5419c29fb81f8235ba1dc13">serializeThread</a> (std::ostream &amp;os, <a class="el" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a> tid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a5122e6d6fdbdb3cb9ba72ae970f00a9e">unserializeThread</a> (<a class="el" href="classCheckpoint.html">Checkpoint</a> *cp, const std::string &amp;section, <a class="el" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a> tid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#aa8a18d230dba7a674ac8a0b4f35bc36a">drain</a> (<a class="el" href="classDrainManager.html">DrainManager</a> *dm)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a8f020d3237536fe007fc488c4125c5d8">drainResume</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a05f299b443f8cc73a93d61572edc0218">switchOut</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a6ab19fbe58a682743f9e652e9777fdac">takeOverFrom</a> (<a class="el" href="classBaseCPU_1_1BaseCPU.html">BaseCPU</a> *cpu)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#ae2e1ccebe596a180f8105d57f9a93645">verifyMemoryMode</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMasterPort.html">MasterPort</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a041a57fcad534c1bed3702a0f8f3a6b1">getDataPort</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMasterPort.html">MasterPort</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#ab8ce6baf7cb0aaaf4ca346896a86fa03">getInstPort</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#ae674290a26ecbd622c5160e38e8a4fe9">wakeup</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#ad7a501b28bdbe8b3e708cd1ef69ac191">activateContext</a> (<a class="el" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a> thread_num, <a class="el" href="classCycles.html">Cycles</a> delay)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a1dad4c4d2c3df4ef367e14fcc973ce74">suspendContext</a> (<a class="el" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a> thread_num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a49259982c98a7959f39b77db5069fea0">deallocateContext</a> (<a class="el" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a> thread_num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#ab39525f324a8a93139e17327f6ccde10">haltContext</a> (<a class="el" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a> thread_num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreadContext.html">ThreadContext</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a2199ea70043ddde97c86e49a656b7ba9">getContext</a> (int tn)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#ae1475755791765b8e6f6a8bb091e273e">Counter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a7e01d94bb5a6e15fa8c94bcdf276115d">totalInsts</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#ae1475755791765b8e6f6a8bb091e273e">Counter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a76fa5df6827aaa8fc26deebad97d9e78">totalOps</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#accd2600060dbaee3a3b41aed4034c63c">dump</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#ae984a01dc23c52800f5fe28344f59b81">kick</a> () const </td></tr>
<tr><td colspan="2"><h2>Public 変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimpleThread.html">SimpleThread</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreadContext.html">ThreadContext</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classKvmVM.html">KvmVM</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a6b8ecd9ec419f0cbe3c1047be643fe08">vm</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#ae1475755791765b8e6f6a8bb091e273e">Counter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a4a8e80967bf91692eb1703752a8203b3">ctrInsts</a></td></tr>
<tr><td colspan="2"><h2>Protected 型</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70b">Status</a> { <a class="el" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>, 
<a class="el" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb">Running</a>, 
<a class="el" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba30f0df86d1d54bb5ea7ee293977f73df">RunningService</a>, 
<a class="el" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba8d38f5f3c8c186646364b893e12e6ae0">RunningServiceCompletion</a>
 }</td></tr>
<tr><td colspan="2"><h2>Protected メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a873dd91783f9efb4a590aded1f70d6b0">tick</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#abcad2a22057ba48360b17b978f694b48">getHostCycles</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#aed3dbd0c0bf26d82ee56367a3f350506">kvmRun</a> (<a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> ticks)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a405afc17ad0dee3b816012ce909b2b6f">kvmRunDrain</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct kvm_run *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#ae544593d8bd3763ec6cf4cc7d0fd614b">getKvmRunState</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a0e5c1a55b7cce45487f5778ee272acdf">getGuestData</a> (uint64_t offset) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__KvmInterrupts.html#gabc700469cba2d4bba666902e552e7c2e">kvmNonMaskableInterrupt</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__KvmInterrupts.html#ga16b8f95e3f70098952604e6b8a121679">kvmInterrupt</a> (const struct kvm_interrupt &amp;interrupt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#af080be5963a74cfafcfc1db16f294f1a">getAndFormatOneReg</a> (uint64_t id) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a4ee4cbdc5d3315fd8016b44d3e77abd5">archIsDrained</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a1a68601eed760a2ebbe974e685901b60">doMMIOAccess</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> paddr, void *data, int size, bool write)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a> (int request, long p1) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__KvmIoctl.html#ga89db87cb31fe2ba732de8fa68c8bd1f1">ioctl</a> (int request, void *p1) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__KvmIoctl.html#ga32cd3b0742689c29c9ab9e3e03feb5f2">ioctl</a> (int request) const </td></tr>
<tr><td colspan="2"><h2>Protected 変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70b">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBaseKvmCPU_1_1KVMCpuPort.html">KVMCpuPort</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a3f709bd88ed61bca6788f8cc3cda97cb">dataPort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBaseKvmCPU_1_1KVMCpuPort.html">KVMCpuPort</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a3d1157769fdf1f3b9566f70b9e7c30ea">instPort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRequest.html">Request</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a22caf021a7ece8d92e5ab612191b1b57">mmio_req</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a8d712456c8dd8a9842aa40a69dbc27dd">threadContextDirty</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a32fdccc14987171c2381947096c363f1">kvmStateDirty</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#ac52bdf6886dcfd53068633de9ed83184">vcpuID</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pthread_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a8a181f878f7db2579a3a67dd2d8c5902">vcpuThread</a></td></tr>
<tr><td colspan="2"><h2>Private メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a2858df681aa95b652e3d371d56def5a3">flushCoalescedMMIO</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#acae9fda1e38c2cd8a3d7c8659a4a66fa">setupSignalHandler</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a8e9cbc5cd93017313960f88c346493ee">discardPendingSignal</a> (int signum) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#abc1464ae4d17eb8f6ea86c6bb5f68532">startupThread</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a250ca18dfc0316e340eaa2ec45d73c3e">tryDrain</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a745968f1246564028e5b3fd8dde0548d">ioctlRun</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a10bd071dda7c87970b3595b2d3c5408e">setupInstStop</a> ()</td></tr>
<tr><td colspan="2"><h2>Private 変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a6b91f8b5649b80e8424cebfa3047e1d0">vcpuFD</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a0915679bdc25b2c015f15996f6d4ff6d">vcpuMMapSize</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct kvm_run *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct kvm_coalesced_mmio_ring *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#ad4e1bcd3f032d2921aa97aec1fc7a45c">mmioRing</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a8386a4766759aabc32038300820a64aa">pageSize</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structBaseKvmCPU_1_1TickEvent.html">TickEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classBaseKvmTimer.html">BaseKvmTimer</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a28c546a9aa908313559ed074632a0c37">runTimer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a0ef366aa4bbbcdc2f7eeb7fcd3962dde">hostFactor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDrainManager.html">DrainManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpd41d8cd98f00b204e9800998ecf8427e"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a302bf9a6fd3b54c46eb3e2bfb18a320e">numInsts</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a6184fcde9e075404315cd7c343054d30">numVMExits</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a8ef83ba51e6ab5f5db813c16e3cebb1d">numVMHalfEntries</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a6cdcd551476b4e8234d5bfd987218d88">numExitSignal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a4030a87068a8b133f5efabfc19f7542d">numMMIO</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a99a92abe3f29c3d0f59af4e384a8fe7f">numCoalescedMMIO</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#ae3a09de1034e0294f5df0ce66d876727">numIO</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a65e906b9e123036deb6bc8922ce53e96">numHalt</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a5ff214621d200e4672d581b12832886a">numInterrupts</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a230908c23db440bfcee954fb8d72f269">numHypercalls</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a9b8c93980540464141f0989b8258295b">activeInstPeriod</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPerfKvmCounter.html">PerfKvmCounter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a496c1c0ab30aeafdeeeede34db1edf45">hwCycles</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPerfKvmCounter.html">PerfKvmCounter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#ab3360069d449c748e7b9efe5f6d427e9">hwInstructions</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a569365e1361250361be1c3f703a52914">perfControlledByTimer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a422ac5896dab3bae0379fa65831e3778">getRegisters</a> (struct kvm_regs &amp;regs) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a104d34588afdf9e14607bad09f01bd53">setRegisters</a> (const struct kvm_regs &amp;regs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a5b5f3c0a541efb9b8567a5e835421c15">getSpecialRegisters</a> (struct kvm_sregs &amp;regs) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#aefaac43fa62903f42a68a637083d5f09">setSpecialRegisters</a> (const struct kvm_sregs &amp;regs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a9fdafd736b7b9ef041b6c3e4768a61d6">getFPUState</a> (struct kvm_fpu &amp;state) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a31b5d1e73edb46a17fa0a8ddd29e7604">setFPUState</a> (const struct kvm_fpu &amp;state)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#ad96695f9596f808056054f3c2026b818">setOneReg</a> (uint64_t id, const void *addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a0f8ff23affd5f22fc47c4d00e6d24979">setOneReg</a> (uint64_t id, uint64_t value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#ab70d563942fa831d4de5da7d94ba8064">setOneReg</a> (uint64_t id, <a class="el" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#ab5a47c64ebf5a4de2539c6f71f7acc51">getOneReg</a> (uint64_t id, void *addr) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a803c633f6b9fc380a376a5a6d2ca17ee">getOneRegU64</a> (uint64_t id) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#abb51d3ccd07e153be4d5982c324a95bc">getOneRegU32</a> (uint64_t id) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a48817be7bf03ef44cc5114ecf4df9b27">updateKvmState</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#ac47bfb587580ca76050e0c9bc753c10d">updateThreadContext</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a5d4ee3823af24f9210efb370a4c8ce93">syncThreadContext</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a8633407bfc3732fef1f78ef60345873d">syncKvmState</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#ab7dc26d4e02dbccc343942dd7a3ed7d8">handleKvmExit</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a404fbd80d6676724d026a932b2258dc7">handleKvmExitIO</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a32523a85b6259326f71aea298ae96ff6">handleKvmExitHypercall</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a405e34c9d079e8823ac2a1ca0e816a47">handleKvmExitIRQWindowOpen</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a00e63a4b01cf730bba2c42ef852b0876">handleKvmExitUnknown</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a9e36bfbe1df222d0ceeaa2f83ad8fa2b">handleKvmExitException</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a0dfcd253bad58e13a071f638d6638b1e">handleKvmExitFailEntry</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a76bff52136628a5be57e6d1ea8ff5370">setSignalMask</a> (const sigset_t *mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a9a2709df130ee7a63e53f9d65a0ebb36">setupCounters</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseKvmCPU.html#a807cad1db3257b823ffdb698c1e62a9a">setupInstCounter</a> (uint64_t period=0)</td></tr>
</table>
<hr/><a name="_details"></a><h2>説明</h2>
<p>Base class for KVM based CPU models</p>
<p>All architecture specific KVM implementation should inherit from this class. The most basic CPU models only need to override the <a class="el" href="classBaseKvmCPU.html#a48817be7bf03ef44cc5114ecf4df9b27">updateKvmState()</a> and <a class="el" href="classBaseKvmCPU.html#ac47bfb587580ca76050e0c9bc753c10d">updateThreadContext()</a> methods to implement state synchronization between gem5 and KVM.</p>
<p>The architecture specific implementation is also responsible for delivering interrupts into the VM. This is typically done by overriding <a class="el" href="classBaseKvmCPU.html#a873dd91783f9efb4a590aded1f70d6b0">tick()</a> and checking the thread context before entering into the VM. In order to deliver an interrupt, the implementation then calls <a class="el" href="group__KvmInterrupts.html#ga5037b917c47fff611ecdd5b547655284">KvmVM::setIRQLine()</a> or <a class="el" href="group__KvmInterrupts.html#ga16b8f95e3f70098952604e6b8a121679">BaseKvmCPU::kvmInterrupt()</a> depending on the specifics of the underlying hardware/drivers. </p>
<hr/><h2>列挙型</h2>
<a class="anchor" id="a67a0db04d321a74b7e7fcfd3f1a3f70b"></a><!-- doxytag: member="BaseKvmCPU::Status" ref="a67a0db04d321a74b7e7fcfd3f1a3f70b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70b">Status</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div align="center">
<img src="inline_dotgraph_1.dot.png" alt="inline_dotgraph_1.dot" border="0" usemap="#inline_dotgraph_1.dot.map">
<map name="inline_dotgraph_1.dot.map" id="inline_dotgraph_1.dot.map"><area shape="poly" id="edge4" href="classBaseKvmCPU.html#ad7a501b28bdbe8b3e708cd1ef69ac191" title="activateContext()" alt="" coords="199,36 93,50 43,64 25,72 13,82 8,93 13,105 36,120 73,132 164,147 163,152 72,137 33,125 9,108 3,93 9,78 22,68 41,59 92,45 199,31"/><area shape="rect" id="edge4" href="classBaseKvmCPU.html#ad7a501b28bdbe8b3e708cd1ef69ac191" title="activateContext()" alt="" coords="11,81,136,106"/><area shape="poly" id="edge14" href="classBaseKvmCPU.html#a8f020d3237536fe007fc488c4125c5d8" title="drainResume()" alt="" coords="205,46 182,60 164,81 160,93 164,105 184,128 180,132 159,108 155,93 159,79 178,56 202,41"/><area shape="rect" id="edge14" href="classBaseKvmCPU.html#a8f020d3237536fe007fc488c4125c5d8" title="drainResume()" alt="" coords="162,81,271,106"/><area shape="poly" id="edge10" href="classBaseKvmCPU.html#a1dad4c4d2c3df4ef367e14fcc973ce74" title="suspendContext()" alt="" coords="258,131 274,106 277,93 274,81 263,62 268,60 279,79 282,93 279,108 262,134"/><area shape="rect" id="edge10" href="classBaseKvmCPU.html#a1dad4c4d2c3df4ef367e14fcc973ce74" title="suspendContext()" alt="" coords="279,81,407,106"/><area shape="poly" id="edge12" href="classBaseKvmCPU.html#aa8a18d230dba7a674ac8a0b4f35bc36a" title="drain()" alt="" coords="293,149 343,141 389,127 405,118 415,108 417,96 410,82 391,68 359,57 283,40 284,35 361,51 393,63 414,78 422,95 420,110 408,123 391,132 344,146 294,154"/><area shape="rect" id="edge12" href="classBaseKvmCPU.html#aa8a18d230dba7a674ac8a0b4f35bc36a" title="drain()" alt="" coords="419,81,468,106"/><area shape="poly" id="edge6" href="classBaseKvmCPU.html#a873dd91783f9efb4a590aded1f70d6b0" title="tick()" alt="" coords="288,142 310,145 317,149 320,156 315,165 302,169 300,164 311,160 315,156 313,153 308,150 287,147"/><area shape="rect" id="edge6" href="classBaseKvmCPU.html#a873dd91783f9efb4a590aded1f70d6b0" title="tick()" alt="" coords="318,143,358,169"/><area shape="poly" id="edge8" href="classBaseKvmCPU.html#a873dd91783f9efb4a590aded1f70d6b0" title="tick()" alt="" coords="216,182 159,248 155,244 212,178"/><area shape="rect" id="edge8" href="classBaseKvmCPU.html#a873dd91783f9efb4a590aded1f70d6b0" title="tick()" alt="" coords="191,206,231,231"/><area shape="poly" id="edge16" href="classBaseKvmCPU.html#ab7dc26d4e02dbccc343942dd7a3ed7d8" title="handleKvmExit()" alt="" coords="84,306 69,318 57,330 53,343 57,356 74,368 104,380 102,385 72,373 53,359 47,343 53,327 65,314 81,302"/><area shape="rect" id="edge16" href="classBaseKvmCPU.html#ab7dc26d4e02dbccc343942dd7a3ed7d8" title="handleKvmExit()" alt="" coords="55,331,183,357"/><area shape="poly" id="edge18" href="classBaseKvmCPU.html#a873dd91783f9efb4a590aded1f70d6b0" title="tick()" alt="" coords="229,380 240,357 248,314 249,271 241,195 246,195 255,271 253,315 245,358 234,382"/><area shape="rect" id="edge18" href="classBaseKvmCPU.html#a873dd91783f9efb4a590aded1f70d6b0" title="tick()" alt="" coords="251,269,291,294"/><area shape="poly" id="edge20" href="classBaseKvmCPU.html#a873dd91783f9efb4a590aded1f70d6b0" title="tick()" alt="" coords="203,382 194,357 181,332 168,317 172,313 185,329 199,355 208,380"/><area shape="rect" id="edge20" href="classBaseKvmCPU.html#a873dd91783f9efb4a590aded1f70d6b0" title="tick()" alt="" coords="198,331,238,357"/></map>
</div>
 <dl><dt><b>列挙型の値: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19"></a><!-- doxytag: member="Idle" ref="a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19" args="" -->Idle</em>&nbsp;</td><td>
<p>Context not scheduled in KVM.</p>
<p>The CPU generally enters this state when the guest execute an instruction that halts the CPU (e.g., WFI on ARM or HLT on X86) if KVM traps this instruction. Ticks are not scheduled in this state.</p>
<dl class="see"><dt><b>参照:</b></dt><dd><a class="el" href="classBaseKvmCPU.html#a1dad4c4d2c3df4ef367e14fcc973ce74">suspendContext()</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb"></a><!-- doxytag: member="Running" ref="a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb" args="" -->Running</em>&nbsp;</td><td>
<p>Running normally.</p>
<p>This is the normal run state of the CPU. KVM will be entered next time <a class="el" href="classBaseKvmCPU.html#a873dd91783f9efb4a590aded1f70d6b0">tick()</a> is called. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a67a0db04d321a74b7e7fcfd3f1a3f70ba30f0df86d1d54bb5ea7ee293977f73df"></a><!-- doxytag: member="RunningService" ref="a67a0db04d321a74b7e7fcfd3f1a3f70ba30f0df86d1d54bb5ea7ee293977f73df" args="" -->RunningService</em>&nbsp;</td><td>
<p>Requiring service at the beginning of the next cycle.</p>
<p>The virtual machine has exited and requires service, <a class="el" href="classBaseKvmCPU.html#a873dd91783f9efb4a590aded1f70d6b0">tick()</a> will call <a class="el" href="classBaseKvmCPU.html#ab7dc26d4e02dbccc343942dd7a3ed7d8">handleKvmExit()</a> on the next cycle. The next state after running service is determined in <a class="el" href="classBaseKvmCPU.html#ab7dc26d4e02dbccc343942dd7a3ed7d8">handleKvmExit()</a> and depends on what kind of service the guest requested: </p>
<ul>
<li>
IO/MMIO: RunningServiceCompletion </li>
<li>
Halt: Idle </li>
<li>
Others: Running </li>
</ul>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a67a0db04d321a74b7e7fcfd3f1a3f70ba8d38f5f3c8c186646364b893e12e6ae0"></a><!-- doxytag: member="RunningServiceCompletion" ref="a67a0db04d321a74b7e7fcfd3f1a3f70ba8d38f5f3c8c186646364b893e12e6ae0" args="" -->RunningServiceCompletion</em>&nbsp;</td><td>
<p>Service completion in progress.</p>
<p>The VM has requested service that requires KVM to be entered once in order to get to a consistent state. This happens in <a class="el" href="classBaseKvmCPU.html#ab7dc26d4e02dbccc343942dd7a3ed7d8">handleKvmExit()</a> or one of its friends after IO exits. After executing <a class="el" href="classBaseKvmCPU.html#a873dd91783f9efb4a590aded1f70d6b0">tick()</a>, the CPU will transition into the Running or RunningService state. </p>
</td></tr>
</table>
</dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00169"></a>00169                 {
<a name="l00179"></a>00179         <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>,
<a name="l00185"></a>00185         <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb">Running</a>,
<a name="l00198"></a>00198         <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba30f0df86d1d54bb5ea7ee293977f73df">RunningService</a>,
<a name="l00207"></a>00207         <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba8d38f5f3c8c186646364b893e12e6ae0">RunningServiceCompletion</a>,
<a name="l00208"></a>00208     };
</pre></div></p>

</div>
</div>
<hr/><h2>コンストラクタとデストラクタ</h2>
<a class="anchor" id="a9eb0b030bd0367a335c97b465d98f01c"></a><!-- doxytag: member="BaseKvmCPU::BaseKvmCPU" ref="a9eb0b030bd0367a335c97b465d98f01c" args="(BaseKvmCPUParams *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBaseKvmCPU_1_1BaseKvmCPU.html">BaseKvmCPU</a> </td>
          <td>(</td>
          <td class="paramtype">BaseKvmCPUParams *&nbsp;</td>
          <td class="paramname"> <em>params</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00067"></a>00067     : <a class="code" href="classBaseCPU.html">BaseCPU</a>(params),
<a name="l00068"></a>00068       <a class="code" href="classBaseKvmCPU.html#a6b8ecd9ec419f0cbe3c1047be643fe08">vm</a>(*params-&gt;kvmVM),
<a name="l00069"></a>00069       <a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a>(<a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>),
<a name="l00070"></a>00070       <a class="code" href="classBaseKvmCPU.html#a3f709bd88ed61bca6788f8cc3cda97cb">dataPort</a>(<a class="code" href="trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>() + <span class="stringliteral">&quot;.dcache_port&quot;</span>, <span class="keyword">this</span>),
<a name="l00071"></a>00071       <a class="code" href="classBaseKvmCPU.html#a3d1157769fdf1f3b9566f70b9e7c30ea">instPort</a>(<a class="code" href="trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>() + <span class="stringliteral">&quot;.icache_port&quot;</span>, <span class="keyword">this</span>),
<a name="l00072"></a>00072       <a class="code" href="classBaseKvmCPU.html#a8d712456c8dd8a9842aa40a69dbc27dd">threadContextDirty</a>(<span class="keyword">true</span>),
<a name="l00073"></a>00073       <a class="code" href="classBaseKvmCPU.html#a32fdccc14987171c2381947096c363f1">kvmStateDirty</a>(<span class="keyword">false</span>),
<a name="l00074"></a>00074       <a class="code" href="classBaseKvmCPU.html#ac52bdf6886dcfd53068633de9ed83184">vcpuID</a>(<a class="code" href="classBaseKvmCPU.html#a6b8ecd9ec419f0cbe3c1047be643fe08">vm</a>.<a class="code" href="classKvmVM.html#a78b0d1b84b25d38fca24a596ebdbcea6">allocVCPUID</a>()), <a class="code" href="classBaseKvmCPU.html#a6b91f8b5649b80e8424cebfa3047e1d0">vcpuFD</a>(-1), <a class="code" href="classBaseKvmCPU.html#a0915679bdc25b2c015f15996f6d4ff6d">vcpuMMapSize</a>(0),
<a name="l00075"></a>00075       <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>(<a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>), <a class="code" href="classBaseKvmCPU.html#ad4e1bcd3f032d2921aa97aec1fc7a45c">mmioRing</a>(<a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>),
<a name="l00076"></a>00076       <a class="code" href="classBaseKvmCPU.html#a8386a4766759aabc32038300820a64aa">pageSize</a>(sysconf(_SC_PAGE_SIZE)),
<a name="l00077"></a>00077       <a class="code" href="classBaseKvmCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>(*<span class="keyword">this</span>),
<a name="l00078"></a>00078       <a class="code" href="classBaseKvmCPU.html#a9b8c93980540464141f0989b8258295b">activeInstPeriod</a>(0),
<a name="l00079"></a>00079       <a class="code" href="classBaseKvmCPU.html#a569365e1361250361be1c3f703a52914">perfControlledByTimer</a>(params-&gt;usePerfOverflow),
<a name="l00080"></a>00080       <a class="code" href="classBaseKvmCPU.html#a0ef366aa4bbbcdc2f7eeb7fcd3962dde">hostFactor</a>(params-&gt;hostFactor),
<a name="l00081"></a>00081       <a class="code" href="classBaseKvmCPU.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a>(<a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>),
<a name="l00082"></a>00082       <a class="code" href="classBaseKvmCPU.html#a4a8e80967bf91692eb1703752a8203b3">ctrInsts</a>(0)
<a name="l00083"></a>00083 {
<a name="l00084"></a>00084     <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#a8386a4766759aabc32038300820a64aa">pageSize</a> == -1)
<a name="l00085"></a>00085         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to determine host page size (%i)\n&quot;</span>,
<a name="l00086"></a>00086               errno);
<a name="l00087"></a>00087 
<a name="l00088"></a>00088     <a class="code" href="classBaseKvmCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a> = <span class="keyword">new</span> <a class="code" href="classSimpleThread.html">SimpleThread</a>(<span class="keyword">this</span>, 0, params-&gt;system,
<a name="l00089"></a>00089                               params-&gt;itb, params-&gt;dtb, params-&gt;isa[0]);
<a name="l00090"></a>00090     <a class="code" href="classBaseKvmCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a1ab41c7c20554bc6a9205b5b69d30406">setStatus</a>(<a class="code" href="classThreadContext.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba185a75df63e845aec97632afd6a34d6a">ThreadContext::Halted</a>);
<a name="l00091"></a>00091     <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a> = <a class="code" href="classBaseKvmCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a81894d15db5190d5364449a4915b76f5">getTC</a>();
<a name="l00092"></a>00092     threadContexts.push_back(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>);
<a name="l00093"></a>00093 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abd186de5de7d9b8e90d2c1f08daf1ecd"></a><!-- doxytag: member="BaseKvmCPU::~BaseKvmCPU" ref="abd186de5de7d9b8e90d2c1f08daf1ecd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classBaseKvmCPU_1_1BaseKvmCPU.html">BaseKvmCPU</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00096"></a>00096 {
<a name="l00097"></a>00097     <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>)
<a name="l00098"></a>00098         munmap(<a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>, <a class="code" href="classBaseKvmCPU.html#a0915679bdc25b2c015f15996f6d4ff6d">vcpuMMapSize</a>);
<a name="l00099"></a>00099     close(<a class="code" href="classBaseKvmCPU.html#a6b91f8b5649b80e8424cebfa3047e1d0">vcpuFD</a>);
<a name="l00100"></a>00100 }
</pre></div></p>

</div>
</div>
<hr/><h2>関数</h2>
<a class="anchor" id="ad7a501b28bdbe8b3e708cd1ef69ac191"></a><!-- doxytag: member="BaseKvmCPU::activateContext" ref="ad7a501b28bdbe8b3e708cd1ef69ac191" args="(ThreadID thread_num, Cycles delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activateContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a>&nbsp;</td>
          <td class="paramname"> <em>thread_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCycles.html">Cycles</a>&nbsp;</td>
          <td class="paramname"> <em>delay</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00434"></a>00434 {
<a name="l00435"></a>00435     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classKvm.html">Kvm</a>, <span class="stringliteral">&quot;ActivateContext %d (%d cycles)\n&quot;</span>, thread_num, delay);
<a name="l00436"></a>00436 
<a name="l00437"></a>00437     assert(thread_num == 0);
<a name="l00438"></a>00438     assert(<a class="code" href="classBaseKvmCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>);
<a name="l00439"></a>00439 
<a name="l00440"></a>00440     assert(<a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> == <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>);
<a name="l00441"></a>00441     assert(!<a class="code" href="classBaseKvmCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>.<a class="code" href="classEvent.html#a9cd69a6b10cb037550943f177a0da688" title="Determine if the current event is scheduled.">scheduled</a>());
<a name="l00442"></a>00442 
<a name="l00443"></a>00443     numCycles += ticksToCycles(<a class="code" href="classBaseKvmCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="structThreadState.html#adba46356f3cbff06bc296a0cf84453e8">lastActivate</a> - <a class="code" href="classBaseKvmCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="structThreadState.html#ac2a3eaa24ceabac390386cca70cc0aa3">lastSuspend</a>);
<a name="l00444"></a>00444 
<a name="l00445"></a>00445     schedule(<a class="code" href="classBaseKvmCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>, clockEdge(delay));
<a name="l00446"></a>00446     <a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> = <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb">Running</a>;
<a name="l00447"></a>00447 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4ee4cbdc5d3315fd8016b44d3e77abd5"></a><!-- doxytag: member="BaseKvmCPU::archIsDrained" ref="a4ee4cbdc5d3315fd8016b44d3e77abd5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool archIsDrained </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Is the architecture specific code in a state that prevents draining?</p>
<p>This method should return false if there are any pending events in the guest vCPU that won't be carried over to the gem5 state and thus will prevent correct checkpointing or CPU handover. It might, for example, check for pending interrupts that have been passed to the vCPU but not acknowledged by the OS. Architecures implementing this method <em>must</em> override <a class="el" href="classBaseKvmCPU.html#a405afc17ad0dee3b816012ce909b2b6f">kvmRunDrain()</a>.</p>
<dl class="see"><dt><b>参照:</b></dt><dd><a class="el" href="classBaseKvmCPU.html#a405afc17ad0dee3b816012ce909b2b6f">BaseKvmCPU::kvmRunDrain()</a></dd></dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>true if the vCPU is drained, false otherwise. </dd></dl>

<p><a class="el" href="classX86KvmCPU.html#a1d97c7e0665d576bb463335078bb02ec">X86KvmCPU</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00493"></a>00493 { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a49259982c98a7959f39b77db5069fea0"></a><!-- doxytag: member="BaseKvmCPU::deallocateContext" ref="a49259982c98a7959f39b77db5069fea0" args="(ThreadID thread_num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deallocateContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a>&nbsp;</td>
          <td class="paramname"> <em>thread_num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00475"></a>00475 {
<a name="l00476"></a>00476     <span class="comment">// for now, these are equivalent</span>
<a name="l00477"></a>00477     <a class="code" href="classBaseKvmCPU.html#a1dad4c4d2c3df4ef367e14fcc973ce74">suspendContext</a>(thread_num);
<a name="l00478"></a>00478 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8e9cbc5cd93017313960f88c346493ee"></a><!-- doxytag: member="BaseKvmCPU::discardPendingSignal" ref="a8e9cbc5cd93017313960f88c346493ee" args="(int signum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool discardPendingSignal </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>signum</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Discard a (potentially) pending signal.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signum</em>&nbsp;</td><td>Signal to discard </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>true if the signal was pending, false otherwise. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01128"></a>01128 {
<a name="l01129"></a>01129     <span class="keywordtype">int</span> discardedSignal;
<a name="l01130"></a>01130 
<a name="l01131"></a>01131     <span class="comment">// Setting the timeout to zero causes sigtimedwait to return</span>
<a name="l01132"></a>01132     <span class="comment">// immediately.</span>
<a name="l01133"></a>01133     <span class="keyword">struct </span>timespec timeout;
<a name="l01134"></a>01134     timeout.tv_sec = 0;
<a name="l01135"></a>01135     timeout.tv_nsec = 0;
<a name="l01136"></a>01136 
<a name="l01137"></a>01137     sigset_t sigset;
<a name="l01138"></a>01138     sigemptyset(&amp;sigset);
<a name="l01139"></a>01139     sigaddset(&amp;sigset, signum);
<a name="l01140"></a>01140 
<a name="l01141"></a>01141     <span class="keywordflow">do</span> {
<a name="l01142"></a>01142         discardedSignal = sigtimedwait(&amp;sigset, <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>, &amp;timeout);
<a name="l01143"></a>01143     } <span class="keywordflow">while</span> (discardedSignal == -1 &amp;&amp; errno == EINTR);
<a name="l01144"></a>01144 
<a name="l01145"></a>01145     <span class="keywordflow">if</span> (discardedSignal == signum)
<a name="l01146"></a>01146         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01147"></a>01147     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (discardedSignal == -1 &amp;&amp; errno == EAGAIN)
<a name="l01148"></a>01148         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01149"></a>01149     <span class="keywordflow">else</span>
<a name="l01150"></a>01150         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;Unexpected return value from sigtimedwait: %i (errno: %i)\n&quot;</span>,
<a name="l01151"></a>01151               discardedSignal, errno);
<a name="l01152"></a>01152 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1a68601eed760a2ebbe974e685901b60"></a><!-- doxytag: member="BaseKvmCPU::doMMIOAccess" ref="a1a68601eed760a2ebbe974e685901b60" args="(Addr paddr, void *data, int size, bool write)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> doMMIOAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>paddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>write</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inject a memory mapped IO request into gem5</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>paddr</em>&nbsp;</td><td>Physical address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Pointer to the source/destination buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Memory access size </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>write</em>&nbsp;</td><td>True if write, False if read </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Number of ticks spent servicing the memory access </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00988"></a>00988 {
<a name="l00989"></a>00989     <a class="code" href="classThreadContext.html">ThreadContext</a> *<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>(<a class="code" href="classBaseKvmCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a81894d15db5190d5364449a4915b76f5">getTC</a>());
<a name="l00990"></a>00990     <a class="code" href="classBaseKvmCPU.html#a5d4ee3823af24f9210efb370a4c8ce93">syncThreadContext</a>();
<a name="l00991"></a>00991 
<a name="l00992"></a>00992     <a class="code" href="classBaseKvmCPU.html#a22caf021a7ece8d92e5ab612191b1b57">mmio_req</a>.<a class="code" href="classRequest.html#aeefca2329f8f252cd5c17463dc7f8fda">setPhys</a>(paddr, size, <a class="code" href="classRequest.html#a0fc1d6bc92a0567b05130468e04f05f8">Request::UNCACHEABLE</a>, dataMasterId());
<a name="l00993"></a>00993     <span class="comment">// Some architectures do need to massage physical addresses a bit</span>
<a name="l00994"></a>00994     <span class="comment">// before they are inserted into the memory system. This enables</span>
<a name="l00995"></a>00995     <span class="comment">// APIC accesses on x86 and m5ops where supported through a MMIO</span>
<a name="l00996"></a>00996     <span class="comment">// interface.</span>
<a name="l00997"></a>00997     <a class="code" href="classBaseTLB.html#a46c8a310cf4c094f8c80e1cb8dc1f911">BaseTLB::Mode</a> tlb_mode(write ? <a class="code" href="classBaseTLB.html#a46c8a310cf4c094f8c80e1cb8dc1f911aa56670174817e3fed92bfd8182d7c0d1">BaseTLB::Write</a> : <a class="code" href="classBaseTLB.html#a46c8a310cf4c094f8c80e1cb8dc1f911a809abe96853e69894bbf8e5730b31348">BaseTLB::Read</a>);
<a name="l00998"></a>00998     <a class="code" href="classRefCountingPtr.html">Fault</a> fault(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a235a0443e22590632cfc95cd4f6db1ae">getDTBPtr</a>()-&gt;finalizePhysical(&amp;<a class="code" href="classBaseKvmCPU.html#a22caf021a7ece8d92e5ab612191b1b57">mmio_req</a>, <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>, tlb_mode));
<a name="l00999"></a>00999     <span class="keywordflow">if</span> (fault != <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>)
<a name="l01000"></a>01000         <a class="code" href="base_2misc_8hh.html#a8224a361dddd2ad59b411982e5ea746f">warn</a>(<span class="stringliteral">&quot;Finalization of MMIO address failed: %s\n&quot;</span>, fault-&gt;name());
<a name="l01001"></a>01001 
<a name="l01002"></a>01002 
<a name="l01003"></a>01003     <span class="keyword">const</span> <a class="code" href="classMemCmd.html">MemCmd</a> cmd(write ? <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153aa5ec34a7e56b23ff12c9b819519d168a">MemCmd::WriteReq</a> : <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a96120c772a9cb695fe62ca81ec93a53b">MemCmd::ReadReq</a>);
<a name="l01004"></a>01004     <a class="code" href="classPacket.html">Packet</a> pkt(&amp;<a class="code" href="classBaseKvmCPU.html#a22caf021a7ece8d92e5ab612191b1b57">mmio_req</a>, cmd);
<a name="l01005"></a>01005     pkt.dataStatic(data);
<a name="l01006"></a>01006 
<a name="l01007"></a>01007     <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#a22caf021a7ece8d92e5ab612191b1b57">mmio_req</a>.<a class="code" href="classRequest.html#aad621c262e009350dd86ad5715c50f7a">isMmappedIpr</a>()) {
<a name="l01008"></a>01008         <span class="comment">// We currently assume that there is no need to migrate to a</span>
<a name="l01009"></a>01009         <span class="comment">// different event queue when doing IPRs. Currently, IPRs are</span>
<a name="l01010"></a>01010         <span class="comment">// only used for m5ops, so it should be a valid assumption.</span>
<a name="l01011"></a>01011         <span class="keyword">const</span> <a class="code" href="classCycles.html">Cycles</a> ipr_delay(write ?
<a name="l01012"></a>01012                              <a class="code" href="namespaceGenericISA.html#a31c83a2af3232333d9a399a2878dc729">TheISA::handleIprWrite</a>(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>, &amp;pkt) :
<a name="l01013"></a>01013                              <a class="code" href="namespaceGenericISA.html#a0b95fcdc1e1fe57dbb4fcad449a6efd8">TheISA::handleIprRead</a>(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>, &amp;pkt));
<a name="l01014"></a>01014         <span class="keywordflow">return</span> clockPeriod() * ipr_delay;
<a name="l01015"></a>01015     } <span class="keywordflow">else</span> {
<a name="l01016"></a>01016         <span class="comment">// Temporarily lock and migrate to the event queue of the</span>
<a name="l01017"></a>01017         <span class="comment">// VM. This queue is assumed to &quot;own&quot; all devices we need to</span>
<a name="l01018"></a>01018         <span class="comment">// access if running in multi-core mode.</span>
<a name="l01019"></a>01019         <a class="code" href="classEventQueue_1_1ScopedMigration.html">EventQueue::ScopedMigration</a> migrate(<a class="code" href="classBaseKvmCPU.html#a6b8ecd9ec419f0cbe3c1047be643fe08">vm</a>.<a class="code" href="classEventManager.html#ad6e91e91036b003cf3661959078e677f">eventQueue</a>());
<a name="l01020"></a>01020 
<a name="l01021"></a>01021         <span class="keywordflow">return</span> <a class="code" href="classBaseKvmCPU.html#a3f709bd88ed61bca6788f8cc3cda97cb">dataPort</a>.<a class="code" href="classMasterPort.html#a49fe5ebde5a0349bff76527b969b7643">sendAtomic</a>(&amp;pkt);
<a name="l01022"></a>01022     }
<a name="l01023"></a>01023 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa8a18d230dba7a674ac8a0b4f35bc36a"></a><!-- doxytag: member="BaseKvmCPU::drain" ref="aa8a18d230dba7a674ac8a0b4f35bc36a" args="(DrainManager *dm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int drain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDrainManager.html">DrainManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dm</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>FALLTHROUGH </p>
</p>

<p><div class="fragment"><pre class="fragment"><a name="l00284"></a>00284 {
<a name="l00285"></a>00285     <span class="keywordflow">if</span> (switchedOut())
<a name="l00286"></a>00286         <span class="keywordflow">return</span> 0;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;BaseKvmCPU::drain\n&quot;</span>);
<a name="l00289"></a>00289     <span class="keywordflow">switch</span> (<a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a>) {
<a name="l00290"></a>00290       <span class="keywordflow">case</span> <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb">Running</a>:
<a name="l00291"></a>00291         <span class="comment">// The base KVM code is normally ready when it is in the</span>
<a name="l00292"></a>00292         <span class="comment">// Running state, but the architecture specific code might be</span>
<a name="l00293"></a>00293         <span class="comment">// of a different opinion. This may happen when the CPU been</span>
<a name="l00294"></a>00294         <span class="comment">// notified of an event that hasn&apos;t been accepted by the vCPU</span>
<a name="l00295"></a>00295         <span class="comment">// yet.</span>
<a name="l00296"></a>00296         <span class="keywordflow">if</span> (!<a class="code" href="classBaseKvmCPU.html#a4ee4cbdc5d3315fd8016b44d3e77abd5">archIsDrained</a>()) {
<a name="l00297"></a>00297             <a class="code" href="classBaseKvmCPU.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a> = dm;
<a name="l00298"></a>00298             <span class="keywordflow">return</span> 1;
<a name="l00299"></a>00299         }
<a name="l00300"></a>00300 
<a name="l00301"></a>00301         <span class="comment">// The state of the CPU is consistent, so we don&apos;t need to do</span>
<a name="l00302"></a>00302         <span class="comment">// anything special to drain it. We simply de-schedule the</span>
<a name="l00303"></a>00303         <span class="comment">// tick event and enter the Idle state to prevent nasty things</span>
<a name="l00304"></a>00304         <span class="comment">// like MMIOs from happening.</span>
<a name="l00305"></a>00305         <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>.<a class="code" href="classEvent.html#a9cd69a6b10cb037550943f177a0da688" title="Determine if the current event is scheduled.">scheduled</a>())
<a name="l00306"></a>00306             deschedule(<a class="code" href="classBaseKvmCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>);
<a name="l00307"></a>00307         <a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> = <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>;
<a name="l00308"></a>00308 
<a name="l00310"></a>00310       <span class="keywordflow">case</span> <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>:
<a name="l00311"></a>00311         <span class="comment">// Idle, no need to drain</span>
<a name="l00312"></a>00312         assert(!<a class="code" href="classBaseKvmCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>.<a class="code" href="classEvent.html#a9cd69a6b10cb037550943f177a0da688" title="Determine if the current event is scheduled.">scheduled</a>());
<a name="l00313"></a>00313 
<a name="l00314"></a>00314         <span class="comment">// Sync the thread context here since we&apos;ll need it when we</span>
<a name="l00315"></a>00315         <span class="comment">// switch CPUs or checkpoint the CPU.</span>
<a name="l00316"></a>00316         <a class="code" href="classBaseKvmCPU.html#a5d4ee3823af24f9210efb370a4c8ce93">syncThreadContext</a>();
<a name="l00317"></a>00317 
<a name="l00318"></a>00318         <span class="keywordflow">return</span> 0;
<a name="l00319"></a>00319 
<a name="l00320"></a>00320       <span class="keywordflow">case</span> <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba8d38f5f3c8c186646364b893e12e6ae0">RunningServiceCompletion</a>:
<a name="l00321"></a>00321         <span class="comment">// The CPU has just requested a service that was handled in</span>
<a name="l00322"></a>00322         <span class="comment">// the RunningService state, but the results have still not</span>
<a name="l00323"></a>00323         <span class="comment">// been reported to the CPU. Now, we /could/ probably just</span>
<a name="l00324"></a>00324         <span class="comment">// update the register state ourselves instead of letting KVM</span>
<a name="l00325"></a>00325         <span class="comment">// handle it, but that would be tricky. Instead, we enter KVM</span>
<a name="l00326"></a>00326         <span class="comment">// and let it do its stuff.</span>
<a name="l00327"></a>00327         <a class="code" href="classBaseKvmCPU.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a> = dm;
<a name="l00328"></a>00328 
<a name="l00329"></a>00329         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;KVM CPU is waiting for service completion, &quot;</span>
<a name="l00330"></a>00330                 <span class="stringliteral">&quot;requesting drain.\n&quot;</span>);
<a name="l00331"></a>00331         <span class="keywordflow">return</span> 1;
<a name="l00332"></a>00332 
<a name="l00333"></a>00333       <span class="keywordflow">case</span> <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba30f0df86d1d54bb5ea7ee293977f73df">RunningService</a>:
<a name="l00334"></a>00334         <span class="comment">// We need to drain since the CPU is waiting for service (e.g., MMIOs)</span>
<a name="l00335"></a>00335         <a class="code" href="classBaseKvmCPU.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a> = dm;
<a name="l00336"></a>00336 
<a name="l00337"></a>00337         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;KVM CPU is waiting for service, requesting drain.\n&quot;</span>);
<a name="l00338"></a>00338         <span class="keywordflow">return</span> 1;
<a name="l00339"></a>00339 
<a name="l00340"></a>00340       <span class="keywordflow">default</span>:
<a name="l00341"></a>00341         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Unhandled CPU state in drain()\n&quot;</span>);
<a name="l00342"></a>00342         <span class="keywordflow">return</span> 0;
<a name="l00343"></a>00343     }
<a name="l00344"></a>00344 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8f020d3237536fe007fc488c4125c5d8"></a><!-- doxytag: member="BaseKvmCPU::drainResume" ref="a8f020d3237536fe007fc488c4125c5d8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drainResume </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00348"></a>00348 {
<a name="l00349"></a>00349     assert(!<a class="code" href="classBaseKvmCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>.<a class="code" href="classEvent.html#a9cd69a6b10cb037550943f177a0da688" title="Determine if the current event is scheduled.">scheduled</a>());
<a name="l00350"></a>00350 
<a name="l00351"></a>00351     <span class="comment">// We might have been switched out. In that case, we don&apos;t need to</span>
<a name="l00352"></a>00352     <span class="comment">// do anything.</span>
<a name="l00353"></a>00353     <span class="keywordflow">if</span> (switchedOut())
<a name="l00354"></a>00354         <span class="keywordflow">return</span>;
<a name="l00355"></a>00355 
<a name="l00356"></a>00356     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classKvm.html">Kvm</a>, <span class="stringliteral">&quot;drainResume\n&quot;</span>);
<a name="l00357"></a>00357     <a class="code" href="classBaseKvmCPU.html#ae2e1ccebe596a180f8105d57f9a93645">verifyMemoryMode</a>();
<a name="l00358"></a>00358 
<a name="l00359"></a>00359     <span class="comment">// The tick event is de-scheduled as a part of the draining</span>
<a name="l00360"></a>00360     <span class="comment">// process. Re-schedule it if the thread context is active.</span>
<a name="l00361"></a>00361     <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#adfba9b39542cba955a02b8ff3ba023a9">status</a>() == <a class="code" href="classThreadContext.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba26bd8444261cc58df7a86753c79d2520">ThreadContext::Active</a>) {
<a name="l00362"></a>00362         schedule(<a class="code" href="classBaseKvmCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>, nextCycle());
<a name="l00363"></a>00363         <a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> = <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb">Running</a>;
<a name="l00364"></a>00364     } <span class="keywordflow">else</span> {
<a name="l00365"></a>00365         <a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> = <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>;
<a name="l00366"></a>00366     }
<a name="l00367"></a>00367 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="accd2600060dbaee3a3b41aed4034c63c"></a><!-- doxytag: member="BaseKvmCPU::dump" ref="accd2600060dbaee3a3b41aed4034c63c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dump </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dump the internal state to the terminal. </p>

<p><a class="el" href="classArmKvmCPU.html#accd2600060dbaee3a3b41aed4034c63c">ArmKvmCPU</a>, と <a class="el" href="classX86KvmCPU.html#accd2600060dbaee3a3b41aed4034c63c">X86KvmCPU</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00511"></a>00511 {
<a name="l00512"></a>00512     <a class="code" href="base_2misc_8hh.html#ae7d790080fa18103d7582effff570b9e">inform</a>(<span class="stringliteral">&quot;State dumping not implemented.&quot;</span>);
<a name="l00513"></a>00513 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2858df681aa95b652e3d371d56def5a3"></a><!-- doxytag: member="BaseKvmCPU::flushCoalescedMMIO" ref="a2858df681aa95b652e3d371d56def5a3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> flushCoalescedMMIO </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Service MMIO requests in the mmioRing.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Number of ticks spent servicing the MMIO requests in the MMIO ring buffer </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01057"></a>01057 {
<a name="l01058"></a>01058     <span class="keywordflow">if</span> (!<a class="code" href="classBaseKvmCPU.html#ad4e1bcd3f032d2921aa97aec1fc7a45c">mmioRing</a>)
<a name="l01059"></a>01059         <span class="keywordflow">return</span> 0;
<a name="l01060"></a>01060 
<a name="l01061"></a>01061     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmIO, <span class="stringliteral">&quot;KVM: Flushing the coalesced MMIO ring buffer\n&quot;</span>);
<a name="l01062"></a>01062 
<a name="l01063"></a>01063     <span class="comment">// TODO: We might need to do synchronization when we start to</span>
<a name="l01064"></a>01064     <span class="comment">// support multiple CPUs</span>
<a name="l01065"></a>01065     <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> ticks(0);
<a name="l01066"></a>01066     <span class="keywordflow">while</span> (<a class="code" href="classBaseKvmCPU.html#ad4e1bcd3f032d2921aa97aec1fc7a45c">mmioRing</a>-&gt;first != <a class="code" href="classBaseKvmCPU.html#ad4e1bcd3f032d2921aa97aec1fc7a45c">mmioRing</a>-&gt;last) {
<a name="l01067"></a>01067         <span class="keyword">struct </span>kvm_coalesced_mmio &amp;ent(
<a name="l01068"></a>01068             <a class="code" href="classBaseKvmCPU.html#ad4e1bcd3f032d2921aa97aec1fc7a45c">mmioRing</a>-&gt;coalesced_mmio[<a class="code" href="classBaseKvmCPU.html#ad4e1bcd3f032d2921aa97aec1fc7a45c">mmioRing</a>-&gt;first]);
<a name="l01069"></a>01069 
<a name="l01070"></a>01070         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmIO, <span class="stringliteral">&quot;KVM: Handling coalesced MMIO (addr: 0x%x, len: %u)\n&quot;</span>,
<a name="l01071"></a>01071                 ent.phys_addr, ent.len);
<a name="l01072"></a>01072 
<a name="l01073"></a>01073         ++<a class="code" href="classBaseKvmCPU.html#a99a92abe3f29c3d0f59af4e384a8fe7f">numCoalescedMMIO</a>;
<a name="l01074"></a>01074         ticks += <a class="code" href="classBaseKvmCPU.html#a1a68601eed760a2ebbe974e685901b60">doMMIOAccess</a>(ent.phys_addr, ent.data, ent.len, <span class="keyword">true</span>);
<a name="l01075"></a>01075 
<a name="l01076"></a>01076         <a class="code" href="classBaseKvmCPU.html#ad4e1bcd3f032d2921aa97aec1fc7a45c">mmioRing</a>-&gt;first = (<a class="code" href="classBaseKvmCPU.html#ad4e1bcd3f032d2921aa97aec1fc7a45c">mmioRing</a>-&gt;first + 1) % KVM_COALESCED_MMIO_MAX;
<a name="l01077"></a>01077     }
<a name="l01078"></a>01078 
<a name="l01079"></a>01079     <span class="keywordflow">return</span> ticks;
<a name="l01080"></a>01080 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af080be5963a74cfafcfc1db16f294f1a"></a><!-- doxytag: member="BaseKvmCPU::getAndFormatOneReg" ref="af080be5963a74cfafcfc1db16f294f1a" args="(uint64_t id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string getAndFormatOneReg </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get and format one register for printout.</p>
<p>This function call <a class="el" href="classBaseKvmCPU.html#ab5a47c64ebf5a4de2539c6f71f7acc51">getOneReg()</a> to retrieve the contents of one register and automatically formats it for printing.</p>
<dl class="note"><dt><b>覚え書き:</b></dt><dd>The presence of this call depends on <a class="el" href="classKvm.html#af1ad3b73711f45008bcb240d012987f7">Kvm::capOneReg()</a>. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00802"></a>00802 {
<a name="l00803"></a>00803 <span class="preprocessor">#ifdef KVM_GET_ONE_REG</span>
<a name="l00804"></a>00804 <span class="preprocessor"></span>    std::ostringstream <a class="code" href="namespaceArmISA.html#a947232c56fc3fcfcef3ee43afafcc4a6">ss</a>;
<a name="l00805"></a>00805 
<a name="l00806"></a>00806     ss.setf(std::ios::hex, std::ios::basefield);
<a name="l00807"></a>00807     ss.setf(std::ios::showbase);
<a name="l00808"></a>00808 <span class="preprocessor">#define HANDLE_INTTYPE(len)                      \</span>
<a name="l00809"></a>00809 <span class="preprocessor">    case KVM_REG_SIZE_U ## len: {                \</span>
<a name="l00810"></a>00810 <span class="preprocessor">        uint ## len ## _t value;                 \</span>
<a name="l00811"></a>00811 <span class="preprocessor">        getOneReg(id, &amp;value);                   \</span>
<a name="l00812"></a>00812 <span class="preprocessor">        ss &lt;&lt; value;                             \</span>
<a name="l00813"></a>00813 <span class="preprocessor">    }  break</span>
<a name="l00814"></a>00814 <span class="preprocessor"></span>
<a name="l00815"></a>00815 <span class="preprocessor">#define HANDLE_ARRAY(len)                       \</span>
<a name="l00816"></a>00816 <span class="preprocessor">    case KVM_REG_SIZE_U ## len: {               \</span>
<a name="l00817"></a>00817 <span class="preprocessor">        uint8_t value[len / 8];                 \</span>
<a name="l00818"></a>00818 <span class="preprocessor">        getOneReg(id, value);                   \</span>
<a name="l00819"></a>00819 <span class="preprocessor">        ss &lt;&lt; &quot;[&quot; &lt;&lt; value[0];                  \</span>
<a name="l00820"></a>00820 <span class="preprocessor">        for (int i = 1; i &lt; len  / 8; ++i)      \</span>
<a name="l00821"></a>00821 <span class="preprocessor">            ss &lt;&lt; &quot;, &quot; &lt;&lt; value[i];             \</span>
<a name="l00822"></a>00822 <span class="preprocessor">        ss &lt;&lt; &quot;]&quot;;                              \</span>
<a name="l00823"></a>00823 <span class="preprocessor">      } break</span>
<a name="l00824"></a>00824 <span class="preprocessor"></span>
<a name="l00825"></a>00825     <span class="keywordflow">switch</span> (<span class="keywordtype">id</span> &amp; KVM_REG_SIZE_MASK) {
<a name="l00826"></a>00826         HANDLE_INTTYPE(8);
<a name="l00827"></a>00827         HANDLE_INTTYPE(16);
<a name="l00828"></a>00828         HANDLE_INTTYPE(32);
<a name="l00829"></a>00829         HANDLE_INTTYPE(64);
<a name="l00830"></a>00830         HANDLE_ARRAY(128);
<a name="l00831"></a>00831         HANDLE_ARRAY(256);
<a name="l00832"></a>00832         HANDLE_ARRAY(512);
<a name="l00833"></a>00833         HANDLE_ARRAY(1024);
<a name="l00834"></a>00834       <span class="keywordflow">default</span>:
<a name="l00835"></a>00835         ss &lt;&lt; <span class="stringliteral">&quot;??&quot;</span>;
<a name="l00836"></a>00836     }
<a name="l00837"></a>00837 
<a name="l00838"></a>00838 <span class="preprocessor">#undef HANDLE_INTTYPE</span>
<a name="l00839"></a>00839 <span class="preprocessor"></span><span class="preprocessor">#undef HANDLE_ARRAY</span>
<a name="l00840"></a>00840 <span class="preprocessor"></span>
<a name="l00841"></a>00841     <span class="keywordflow">return</span> ss.str();
<a name="l00842"></a>00842 <span class="preprocessor">#else</span>
<a name="l00843"></a>00843 <span class="preprocessor"></span>    <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM_GET_ONE_REG is unsupported on this platform.\n&quot;</span>);
<a name="l00844"></a>00844 <span class="preprocessor">#endif</span>
<a name="l00845"></a>00845 <span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2199ea70043ddde97c86e49a656b7ba9"></a><!-- doxytag: member="BaseKvmCPU::getContext" ref="a2199ea70043ddde97c86e49a656b7ba9" args="(int tn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreadContext.html">ThreadContext</a> * getContext </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00489"></a>00489 {
<a name="l00490"></a>00490     assert(tn == 0);
<a name="l00491"></a>00491     <a class="code" href="classBaseKvmCPU.html#a5d4ee3823af24f9210efb370a4c8ce93">syncThreadContext</a>();
<a name="l00492"></a>00492     <span class="keywordflow">return</span> <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>;
<a name="l00493"></a>00493 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a041a57fcad534c1bed3702a0f8f3a6b1"></a><!-- doxytag: member="BaseKvmCPU::getDataPort" ref="a041a57fcad534c1bed3702a0f8f3a6b1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMasterPort.html">MasterPort</a>&amp; getDataPort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00099"></a>00099 { <span class="keywordflow">return</span> <a class="code" href="classBaseKvmCPU.html#a3f709bd88ed61bca6788f8cc3cda97cb">dataPort</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9fdafd736b7b9ef041b6c3e4768a61d6"></a><!-- doxytag: member="BaseKvmCPU::getFPUState" ref="a9fdafd736b7b9ef041b6c3e4768a61d6" args="(struct kvm_fpu &amp;state) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getFPUState </td>
          <td>(</td>
          <td class="paramtype">struct kvm_fpu &amp;&nbsp;</td>
          <td class="paramname"> <em>state</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get/Set the guest FPU/vector state </p>

<p><div class="fragment"><pre class="fragment"><a name="l00753"></a>00753 {
<a name="l00754"></a>00754     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_GET_FPU, &amp;state) == -1)
<a name="l00755"></a>00755         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to get guest FPU state\n&quot;</span>);
<a name="l00756"></a>00756 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0e5c1a55b7cce45487f5778ee272acdf"></a><!-- doxytag: member="BaseKvmCPU::getGuestData" ref="a0e5c1a55b7cce45487f5778ee272acdf" args="(uint64_t offset) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* getGuestData </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve a pointer to guest data stored at the end of the kvm_run structure. This is mainly used for PIO operations (KVM_EXIT_IO).</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>Offset as specified by the kvm_run structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Pointer to guest data </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00289"></a>00289                                                  {
<a name="l00290"></a>00290         <span class="keywordflow">return</span> (uint8_t *)<a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a> + <a class="code" href="namespaceArmISA.html#a87b7a740701cddafb930a9460e9f4eba">offset</a>;
<a name="l00291"></a>00291     };
</pre></div></p>

</div>
</div>
<a class="anchor" id="abcad2a22057ba48360b17b978f694b48"></a><!-- doxytag: member="BaseKvmCPU::getHostCycles" ref="abcad2a22057ba48360b17b978f694b48" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t getHostCycles </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the value of the hardware cycle counter in the guest.</p>
<p>This method is supposed to return the total number of cycles executed in hardware mode relative to some arbitrary point in the past. It's mainly used when estimating the number of cycles actually executed by the CPU in <a class="el" href="classBaseKvmCPU.html#aed3dbd0c0bf26d82ee56367a3f350506">kvmRun()</a>. The default behavior of this method is to use the cycles performance counter, but some architectures may want to use internal registers instead.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Number of host cycles executed relative to an undefined point in the past. </dd></dl>

<p><a class="el" href="classX86KvmCPU.html#abcad2a22057ba48360b17b978f694b48">X86KvmCPU</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00608"></a>00608 {
<a name="l00609"></a>00609     <span class="keywordflow">return</span> <a class="code" href="classBaseKvmCPU.html#a496c1c0ab30aeafdeeeede34db1edf45">hwCycles</a>.<a class="code" href="classPerfKvmCounter.html#af2c9c37fc5a5bcdac6d97825066ce801">read</a>();
<a name="l00610"></a>00610 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab8ce6baf7cb0aaaf4ca346896a86fa03"></a><!-- doxytag: member="BaseKvmCPU::getInstPort" ref="ab8ce6baf7cb0aaaf4ca346896a86fa03" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMasterPort.html">MasterPort</a>&amp; getInstPort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00100"></a>00100 { <span class="keywordflow">return</span> <a class="code" href="classBaseKvmCPU.html#a3d1157769fdf1f3b9566f70b9e7c30ea">instPort</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae544593d8bd3763ec6cf4cc7d0fd614b"></a><!-- doxytag: member="BaseKvmCPU::getKvmRunState" ref="ae544593d8bd3763ec6cf4cc7d0fd614b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct kvm_run* getKvmRunState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, read, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a pointer to the kvm_run structure containing all the input and output parameters from <a class="el" href="classBaseKvmCPU.html#aed3dbd0c0bf26d82ee56367a3f350506">kvmRun()</a>. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00279"></a>00279 { <span class="keywordflow">return</span> <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>; };
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab5a47c64ebf5a4de2539c6f71f7acc51"></a><!-- doxytag: member="BaseKvmCPU::getOneReg" ref="ab5a47c64ebf5a4de2539c6f71f7acc51" args="(uint64_t id, void *addr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getOneReg </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00785"></a>00785 {
<a name="l00786"></a>00786 <span class="preprocessor">#ifdef KVM_GET_ONE_REG</span>
<a name="l00787"></a>00787 <span class="preprocessor"></span>    <span class="keyword">struct </span>kvm_one_reg <a class="code" href="namespaceX86ISA.html#aeeb02ad833ab76f3430553ef93213a6b">reg</a>;
<a name="l00788"></a>00788     <a class="code" href="namespaceX86ISA.html#aeeb02ad833ab76f3430553ef93213a6b">reg</a>.id = <a class="code" href="namespaceSparcISA.html#a2b4cf644f5af9ebaec502fb09986f302">id</a>;
<a name="l00789"></a>00789     <a class="code" href="namespaceX86ISA.html#aeeb02ad833ab76f3430553ef93213a6b">reg</a>.addr = (uint64_t)<a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a>;
<a name="l00790"></a>00790 
<a name="l00791"></a>00791     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_GET_ONE_REG, &amp;<a class="code" href="namespaceX86ISA.html#aeeb02ad833ab76f3430553ef93213a6b">reg</a>) == -1) {
<a name="l00792"></a>00792         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to get register (0x%x) value (errno: %i)\n&quot;</span>,
<a name="l00793"></a>00793               <span class="keywordtype">id</span>, errno);
<a name="l00794"></a>00794     }
<a name="l00795"></a>00795 <span class="preprocessor">#else</span>
<a name="l00796"></a>00796 <span class="preprocessor"></span>    <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM_GET_ONE_REG is unsupported on this platform.\n&quot;</span>);
<a name="l00797"></a>00797 <span class="preprocessor">#endif</span>
<a name="l00798"></a>00798 <span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="abb51d3ccd07e153be4d5982c324a95bc"></a><!-- doxytag: member="BaseKvmCPU::getOneRegU32" ref="abb51d3ccd07e153be4d5982c324a95bc" args="(uint64_t id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> getOneRegU32 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00357"></a>00357                                              {
<a name="l00358"></a>00358         <a class="code" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> <a class="code" href="namespacegenini.html#a7e5f482a3a8a4f98bd1a9c124485f572">value</a>;
<a name="l00359"></a>00359         <a class="code" href="classBaseKvmCPU.html#ab5a47c64ebf5a4de2539c6f71f7acc51">getOneReg</a>(<span class="keywordtype">id</span>, &amp;value);
<a name="l00360"></a>00360         <span class="keywordflow">return</span> value;
<a name="l00361"></a>00361     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a803c633f6b9fc380a376a5a6d2ca17ee"></a><!-- doxytag: member="BaseKvmCPU::getOneRegU64" ref="a803c633f6b9fc380a376a5a6d2ca17ee" args="(uint64_t id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t getOneRegU64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00352"></a>00352                                              {
<a name="l00353"></a>00353         uint64_t <a class="code" href="namespacegenini.html#a7e5f482a3a8a4f98bd1a9c124485f572">value</a>;
<a name="l00354"></a>00354         <a class="code" href="classBaseKvmCPU.html#ab5a47c64ebf5a4de2539c6f71f7acc51">getOneReg</a>(<span class="keywordtype">id</span>, &amp;value);
<a name="l00355"></a>00355         <span class="keywordflow">return</span> value;
<a name="l00356"></a>00356     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a422ac5896dab3bae0379fa65831e3778"></a><!-- doxytag: member="BaseKvmCPU::getRegisters" ref="a422ac5896dab3bae0379fa65831e3778" args="(struct kvm_regs &amp;regs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getRegisters </td>
          <td>(</td>
          <td class="paramtype">struct kvm_regs &amp;&nbsp;</td>
          <td class="paramname"> <em>regs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get/Set the register state of the guest vCPU</p>
<p>KVM has two different interfaces for accessing the state of the guest CPU. One interface updates 'normal' registers and one updates 'special' registers. The distinction between special and normal registers isn't very clear and is architecture dependent. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00725"></a>00725 {
<a name="l00726"></a>00726     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_GET_REGS, &amp;regs) == -1)
<a name="l00727"></a>00727         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to get guest registers\n&quot;</span>);
<a name="l00728"></a>00728 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5b5f3c0a541efb9b8567a5e835421c15"></a><!-- doxytag: member="BaseKvmCPU::getSpecialRegisters" ref="a5b5f3c0a541efb9b8567a5e835421c15" args="(struct kvm_sregs &amp;regs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getSpecialRegisters </td>
          <td>(</td>
          <td class="paramtype">struct kvm_sregs &amp;&nbsp;</td>
          <td class="paramname"> <em>regs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00739"></a>00739 {
<a name="l00740"></a>00740     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_GET_SREGS, &amp;regs) == -1)
<a name="l00741"></a>00741         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to get guest special registers\n&quot;</span>);
<a name="l00742"></a>00742 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab39525f324a8a93139e17327f6ccde10"></a><!-- doxytag: member="BaseKvmCPU::haltContext" ref="ab39525f324a8a93139e17327f6ccde10" args="(ThreadID thread_num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void haltContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a>&nbsp;</td>
          <td class="paramname"> <em>thread_num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00482"></a>00482 {
<a name="l00483"></a>00483     <span class="comment">// for now, these are equivalent</span>
<a name="l00484"></a>00484     <a class="code" href="classBaseKvmCPU.html#a1dad4c4d2c3df4ef367e14fcc973ce74">suspendContext</a>(thread_num);
<a name="l00485"></a>00485 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab7dc26d4e02dbccc343942dd7a3ed7d8"></a><!-- doxytag: member="BaseKvmCPU::handleKvmExit" ref="ab7dc26d4e02dbccc343942dd7a3ed7d8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> handleKvmExit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Main kvmRun exit handler, calls the relevant handleKvmExit* depending on exit type.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Number of ticks spent servicing the exit request </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00873"></a>00873 {
<a name="l00874"></a>00874     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmRun, <span class="stringliteral">&quot;handleKvmExit (exit_reason: %i)\n&quot;</span>, <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;exit_reason);
<a name="l00875"></a>00875     assert(<a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> == <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba30f0df86d1d54bb5ea7ee293977f73df">RunningService</a>);
<a name="l00876"></a>00876 
<a name="l00877"></a>00877     <span class="comment">// Switch into the running state by default. Individual handlers</span>
<a name="l00878"></a>00878     <span class="comment">// can override this.</span>
<a name="l00879"></a>00879     <a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> = <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb">Running</a>;
<a name="l00880"></a>00880     <span class="keywordflow">switch</span> (<a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;exit_reason) {
<a name="l00881"></a>00881       <span class="keywordflow">case</span> KVM_EXIT_UNKNOWN:
<a name="l00882"></a>00882         <span class="keywordflow">return</span> <a class="code" href="classBaseKvmCPU.html#a00e63a4b01cf730bba2c42ef852b0876">handleKvmExitUnknown</a>();
<a name="l00883"></a>00883 
<a name="l00884"></a>00884       <span class="keywordflow">case</span> KVM_EXIT_EXCEPTION:
<a name="l00885"></a>00885         <span class="keywordflow">return</span> <a class="code" href="classBaseKvmCPU.html#a9e36bfbe1df222d0ceeaa2f83ad8fa2b">handleKvmExitException</a>();
<a name="l00886"></a>00886 
<a name="l00887"></a>00887       <span class="keywordflow">case</span> KVM_EXIT_IO:
<a name="l00888"></a>00888         <a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> = <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba8d38f5f3c8c186646364b893e12e6ae0">RunningServiceCompletion</a>;
<a name="l00889"></a>00889         ++<a class="code" href="classBaseKvmCPU.html#ae3a09de1034e0294f5df0ce66d876727">numIO</a>;
<a name="l00890"></a>00890         <span class="keywordflow">return</span> <a class="code" href="classBaseKvmCPU.html#a404fbd80d6676724d026a932b2258dc7">handleKvmExitIO</a>();
<a name="l00891"></a>00891 
<a name="l00892"></a>00892       <span class="keywordflow">case</span> KVM_EXIT_HYPERCALL:
<a name="l00893"></a>00893         ++<a class="code" href="classBaseKvmCPU.html#a230908c23db440bfcee954fb8d72f269">numHypercalls</a>;
<a name="l00894"></a>00894         <span class="keywordflow">return</span> <a class="code" href="classBaseKvmCPU.html#a32523a85b6259326f71aea298ae96ff6">handleKvmExitHypercall</a>();
<a name="l00895"></a>00895 
<a name="l00896"></a>00896       <span class="keywordflow">case</span> KVM_EXIT_HLT:
<a name="l00897"></a>00897         <span class="comment">/* The guest has halted and is waiting for interrupts */</span>
<a name="l00898"></a>00898         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classKvm.html">Kvm</a>, <span class="stringliteral">&quot;handleKvmExitHalt\n&quot;</span>);
<a name="l00899"></a>00899         ++<a class="code" href="classBaseKvmCPU.html#a65e906b9e123036deb6bc8922ce53e96">numHalt</a>;
<a name="l00900"></a>00900 
<a name="l00901"></a>00901         <span class="comment">// Suspend the thread until the next interrupt arrives</span>
<a name="l00902"></a>00902         <a class="code" href="classBaseKvmCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a3605b58fb45d69d498721bc2f2a14b1c" title="Set the status to Suspended.">suspend</a>();
<a name="l00903"></a>00903 
<a name="l00904"></a>00904         <span class="comment">// This is actually ignored since the thread is suspended.</span>
<a name="l00905"></a>00905         <span class="keywordflow">return</span> 0;
<a name="l00906"></a>00906 
<a name="l00907"></a>00907       <span class="keywordflow">case</span> KVM_EXIT_MMIO:
<a name="l00908"></a>00908         <a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> = <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba8d38f5f3c8c186646364b893e12e6ae0">RunningServiceCompletion</a>;
<a name="l00909"></a>00909         <span class="comment">/* Service memory mapped IO requests */</span>
<a name="l00910"></a>00910         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmIO, <span class="stringliteral">&quot;KVM: Handling MMIO (w: %u, addr: 0x%x, len: %u)\n&quot;</span>,
<a name="l00911"></a>00911                 <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;mmio.is_write,
<a name="l00912"></a>00912                 <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;mmio.phys_addr, <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;mmio.len);
<a name="l00913"></a>00913 
<a name="l00914"></a>00914         ++<a class="code" href="classBaseKvmCPU.html#a4030a87068a8b133f5efabfc19f7542d">numMMIO</a>;
<a name="l00915"></a>00915         <span class="keywordflow">return</span> <a class="code" href="classBaseKvmCPU.html#a1a68601eed760a2ebbe974e685901b60">doMMIOAccess</a>(<a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;mmio.phys_addr, <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;mmio.data,
<a name="l00916"></a>00916                             <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;mmio.len, <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;mmio.is_write);
<a name="l00917"></a>00917 
<a name="l00918"></a>00918       <span class="keywordflow">case</span> KVM_EXIT_IRQ_WINDOW_OPEN:
<a name="l00919"></a>00919         <span class="keywordflow">return</span> <a class="code" href="classBaseKvmCPU.html#a405e34c9d079e8823ac2a1ca0e816a47">handleKvmExitIRQWindowOpen</a>();
<a name="l00920"></a>00920 
<a name="l00921"></a>00921       <span class="keywordflow">case</span> KVM_EXIT_FAIL_ENTRY:
<a name="l00922"></a>00922         <span class="keywordflow">return</span> <a class="code" href="classBaseKvmCPU.html#a0dfcd253bad58e13a071f638d6638b1e">handleKvmExitFailEntry</a>();
<a name="l00923"></a>00923 
<a name="l00924"></a>00924       <span class="keywordflow">case</span> KVM_EXIT_INTR:
<a name="l00925"></a>00925         <span class="comment">/* KVM was interrupted by a signal, restart it in the next</span>
<a name="l00926"></a>00926 <span class="comment">         * tick. */</span>
<a name="l00927"></a>00927         <span class="keywordflow">return</span> 0;
<a name="l00928"></a>00928 
<a name="l00929"></a>00929       <span class="keywordflow">case</span> KVM_EXIT_INTERNAL_ERROR:
<a name="l00930"></a>00930         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Internal error (suberror: %u)\n&quot;</span>,
<a name="l00931"></a>00931               <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;internal.suberror);
<a name="l00932"></a>00932 
<a name="l00933"></a>00933       <span class="keywordflow">default</span>:
<a name="l00934"></a>00934         <a class="code" href="classBaseKvmCPU.html#accd2600060dbaee3a3b41aed4034c63c">dump</a>();
<a name="l00935"></a>00935         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Unexpected exit (exit_reason: %u)\n&quot;</span>, <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;exit_reason);
<a name="l00936"></a>00936     }
<a name="l00937"></a>00937 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9e36bfbe1df222d0ceeaa2f83ad8fa2b"></a><!-- doxytag: member="BaseKvmCPU::handleKvmExitException" ref="a9e36bfbe1df222d0ceeaa2f83ad8fa2b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> handleKvmExitException </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An unhandled virtualization exception occured</p>
<p>Some KVM virtualization drivers return unhandled exceptions to the user-space monitor. This interface is currently only used by the Intel VMX KVM driver.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Number of ticks delay the next CPU tick </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00971"></a>00971 {
<a name="l00972"></a>00972     <a class="code" href="classBaseKvmCPU.html#accd2600060dbaee3a3b41aed4034c63c">dump</a>();
<a name="l00973"></a>00973     <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Got exception when starting vCPU &quot;</span>
<a name="l00974"></a>00974           <span class="stringliteral">&quot;(exception: %u, error_code: %u)\n&quot;</span>,
<a name="l00975"></a>00975           <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;ex.exception, <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;ex.error_code);
<a name="l00976"></a>00976 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0dfcd253bad58e13a071f638d6638b1e"></a><!-- doxytag: member="BaseKvmCPU::handleKvmExitFailEntry" ref="a0dfcd253bad58e13a071f638d6638b1e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> handleKvmExitFailEntry </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>KVM failed to start the virtualized CPU</p>
<p>The kvm_run data structure contains the hardware-specific error code.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Number of ticks delay the next CPU tick </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00980"></a>00980 {
<a name="l00981"></a>00981     <a class="code" href="classBaseKvmCPU.html#accd2600060dbaee3a3b41aed4034c63c">dump</a>();
<a name="l00982"></a>00982     <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to enter virtualized mode (hw reason: 0x%llx)\n&quot;</span>,
<a name="l00983"></a>00983           <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;fail_entry.hardware_entry_failure_reason);
<a name="l00984"></a>00984 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a32523a85b6259326f71aea298ae96ff6"></a><!-- doxytag: member="BaseKvmCPU::handleKvmExitHypercall" ref="a32523a85b6259326f71aea298ae96ff6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> handleKvmExitHypercall </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The guest requested a monitor service using a hypercall</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Number of ticks spent servicing the hypercall </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00949"></a>00949 {
<a name="l00950"></a>00950     <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Unhandled hypercall\n&quot;</span>);
<a name="l00951"></a>00951 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a404fbd80d6676724d026a932b2258dc7"></a><!-- doxytag: member="BaseKvmCPU::handleKvmExitIO" ref="a404fbd80d6676724d026a932b2258dc7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> handleKvmExitIO </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The guest performed a legacy IO request (out/inp on x86)</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Number of ticks spent servicing the IO request </dd></dl>

<p><a class="el" href="classX86KvmCPU.html#a404fbd80d6676724d026a932b2258dc7">X86KvmCPU</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00941"></a>00941 {
<a name="l00942"></a>00942     <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Unhandled guest IO (dir: %i, size: %i, port: 0x%x, count: %i)\n&quot;</span>,
<a name="l00943"></a>00943           <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;io.direction, <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;io.size,
<a name="l00944"></a>00944           <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;io.port, <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;io.count);
<a name="l00945"></a>00945 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a405e34c9d079e8823ac2a1ca0e816a47"></a><!-- doxytag: member="BaseKvmCPU::handleKvmExitIRQWindowOpen" ref="a405e34c9d079e8823ac2a1ca0e816a47" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> handleKvmExitIRQWindowOpen </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The guest exited because an interrupt window was requested</p>
<p>The guest exited because an interrupt window was requested (request_interrupt_window in the kvm_run structure was set to 1 before calling kvmRun) and it is now ready to receive</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Number of ticks spent servicing the IRQ </dd></dl>

<p><a class="el" href="classX86KvmCPU.html#a405e34c9d079e8823ac2a1ca0e816a47">X86KvmCPU</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00955"></a>00955 {
<a name="l00956"></a>00956     <a class="code" href="base_2misc_8hh.html#a8224a361dddd2ad59b411982e5ea746f">warn</a>(<span class="stringliteral">&quot;KVM: Unhandled IRQ window.\n&quot;</span>);
<a name="l00957"></a>00957     <span class="keywordflow">return</span> 0;
<a name="l00958"></a>00958 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a00e63a4b01cf730bba2c42ef852b0876"></a><!-- doxytag: member="BaseKvmCPU::handleKvmExitUnknown" ref="a00e63a4b01cf730bba2c42ef852b0876" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> handleKvmExitUnknown </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An unknown architecture dependent error occurred when starting the vCPU</p>
<p>The kvm_run data structure contains the hardware error code. The defaults behavior of this method just prints the HW error code and panics. Architecture dependent implementations may want to override this method to provide better, hardware-aware, error messages.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Number of ticks delay the next CPU tick </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00963"></a>00963 {
<a name="l00964"></a>00964     <a class="code" href="classBaseKvmCPU.html#accd2600060dbaee3a3b41aed4034c63c">dump</a>();
<a name="l00965"></a>00965     <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Unknown error when starting vCPU (hw reason: 0x%llx)\n&quot;</span>,
<a name="l00966"></a>00966           <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;hw.hardware_exit_reason);
<a name="l00967"></a>00967 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a02fd73d861ef2e4aabb38c0c9ff82947"></a><!-- doxytag: member="BaseKvmCPU::init" ref="a02fd73d861ef2e4aabb38c0c9ff82947" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00104"></a>00104 {
<a name="l00105"></a>00105     <a class="code" href="classSimObject.html#a02fd73d861ef2e4aabb38c0c9ff82947">BaseCPU::init</a>();
<a name="l00106"></a>00106 
<a name="l00107"></a>00107     <span class="keywordflow">if</span> (<a class="code" href="classBaseCPU.html#aac03a586f9fcb28bcbe8c3721888fa93">numThreads</a> != 1)
<a name="l00108"></a>00108         <a class="code" href="base_2misc_8hh.html#acad519418dbfdd70c1208711e609c80e">fatal</a>(<span class="stringliteral">&quot;KVM: Multithreading not supported&quot;</span>);
<a name="l00109"></a>00109 
<a name="l00110"></a>00110     <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a6657d03bdea324a6ada2e4450307262c">initMemProxies</a>(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>);
<a name="l00111"></a>00111 
<a name="l00112"></a>00112     <span class="comment">// initialize CPU, including PC</span>
<a name="l00113"></a>00113     <span class="keywordflow">if</span> (<a class="code" href="full__system_8hh.html#af929576af6f85c8849704b66d04b8370">FullSystem</a> &amp;&amp; !switchedOut())
<a name="l00114"></a>00114         <a class="code" href="namespaceAlphaISA.html#aded557a1e716c6f849b0e0b05fc77676">TheISA::initCPU</a>(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>, <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a5a3ce3f955d2ec16ac6f2aa21e42f3a0">contextId</a>());
<a name="l00115"></a>00115 
<a name="l00116"></a>00116     <a class="code" href="classBaseKvmCPU.html#a22caf021a7ece8d92e5ab612191b1b57">mmio_req</a>.<a class="code" href="classRequest.html#a40574dadf22fb92b4966eb9815da7575">setThreadContext</a>(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a5a3ce3f955d2ec16ac6f2aa21e42f3a0">contextId</a>(), 0);
<a name="l00117"></a>00117 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a745968f1246564028e5b3fd8dde0548d"></a><!-- doxytag: member="BaseKvmCPU::ioctlRun" ref="a745968f1246564028e5b3fd8dde0548d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ioctlRun </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Execute the KVM_RUN ioctl </p>

<p><div class="fragment"><pre class="fragment"><a name="l01210"></a>01210 {
<a name="l01211"></a>01211     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_RUN) == -1) {
<a name="l01212"></a>01212         <span class="keywordflow">if</span> (errno != EINTR)
<a name="l01213"></a>01213             <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to start virtual CPU (errno: %i)\n&quot;</span>,
<a name="l01214"></a>01214                   errno);
<a name="l01215"></a>01215     }
<a name="l01216"></a>01216 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae984a01dc23c52800f5fe28344f59b81"></a><!-- doxytag: member="BaseKvmCPU::kick" ref="ae984a01dc23c52800f5fe28344f59b81" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kick </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Force an exit from KVM.</p>
<p>Send a signal to the thread owning this vCPU to get it to exit from KVM. Ignored if the vCPU is not executing. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00122"></a>00122 { pthread_kill(<a class="code" href="classBaseKvmCPU.html#a8a181f878f7db2579a3a67dd2d8c5902">vcpuThread</a>, <a class="code" href="cpu_2kvm_2base_8hh.html#a7aba22a2f8cca986ad7802c54c654847">KVM_KICK_SIGNAL</a>); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aed3dbd0c0bf26d82ee56367a3f350506"></a><!-- doxytag: member="BaseKvmCPU::kvmRun" ref="aed3dbd0c0bf26d82ee56367a3f350506" args="(Tick ticks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> kvmRun </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td>
          <td class="paramname"> <em>ticks</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classRequest.html">Request</a> KVM to run the guest for a given number of ticks. The method returns the approximate number of ticks executed.</p>
<dl class="note"><dt><b>覚え書き:</b></dt><dd>The returned number of ticks can be both larger or smaller than the requested number of ticks. A smaller number can, for example, occur when the guest executes MMIO. A larger number is typically due to performance counter inaccuracies.</dd>
<dd>
This method is virtual in order to allow implementations to check for architecture specific events (e.g., interrupts) before entering the VM.</dd>
<dd>
It is the response of the caller (normally <a class="el" href="classBaseKvmCPU.html#a873dd91783f9efb4a590aded1f70d6b0">tick()</a>) to make sure that the KVM state is synchronized and that the TC is invalidated after entering KVM.</dd>
<dd>
This method does not normally cause any state transitions. However, if it may suspend the CPU by suspending the thread, which leads to a transition to the Idle state. In such a case, kvm <em>must not</em> be entered.</dd></dl>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ticks</em>&nbsp;</td><td>Number of ticks to execute, set to 0 to exit immediately after finishing pending operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Number of ticks executed (see note) </dd></dl>

<p><a class="el" href="classArmKvmCPU.html#aed3dbd0c0bf26d82ee56367a3f350506">ArmKvmCPU</a>, と <a class="el" href="classX86KvmCPU.html#aed3dbd0c0bf26d82ee56367a3f350506">X86KvmCPU</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00614"></a>00614 {
<a name="l00615"></a>00615     <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> ticksExecuted;
<a name="l00616"></a>00616     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmRun, <span class="stringliteral">&quot;KVM: Executing for %i ticks\n&quot;</span>, ticks);
<a name="l00617"></a>00617 
<a name="l00618"></a>00618     <span class="keywordflow">if</span> (ticks == 0) {
<a name="l00619"></a>00619         <span class="comment">// Settings ticks == 0 is a special case which causes an entry</span>
<a name="l00620"></a>00620         <span class="comment">// into KVM that finishes pending operations (e.g., IO) and</span>
<a name="l00621"></a>00621         <span class="comment">// then immediately exits.</span>
<a name="l00622"></a>00622         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmRun, <span class="stringliteral">&quot;KVM: Delivering IO without full guest entry\n&quot;</span>);
<a name="l00623"></a>00623 
<a name="l00624"></a>00624         ++<a class="code" href="classBaseKvmCPU.html#a8ef83ba51e6ab5f5db813c16e3cebb1d">numVMHalfEntries</a>;
<a name="l00625"></a>00625 
<a name="l00626"></a>00626         <span class="comment">// Send a KVM_KICK_SIGNAL to the vCPU thread (i.e., this</span>
<a name="l00627"></a>00627         <span class="comment">// thread). The KVM control signal is masked while executing</span>
<a name="l00628"></a>00628         <span class="comment">// in gem5 and gets unmasked temporarily as when entering</span>
<a name="l00629"></a>00629         <span class="comment">// KVM. See setSignalMask() and setupSignalHandler().</span>
<a name="l00630"></a>00630         <a class="code" href="classBaseKvmCPU.html#ae984a01dc23c52800f5fe28344f59b81">kick</a>();
<a name="l00631"></a>00631 
<a name="l00632"></a>00632         <span class="comment">// Start the vCPU. KVM will check for signals after completing</span>
<a name="l00633"></a>00633         <span class="comment">// pending operations (IO). Since the KVM_KICK_SIGNAL is</span>
<a name="l00634"></a>00634         <span class="comment">// pending, this forces an immediate exit to gem5 again. We</span>
<a name="l00635"></a>00635         <span class="comment">// don&apos;t bother to setup timers since this shouldn&apos;t actually</span>
<a name="l00636"></a>00636         <span class="comment">// execute any code (other than completing half-executed IO</span>
<a name="l00637"></a>00637         <span class="comment">// instructions) in the guest.</span>
<a name="l00638"></a>00638         <a class="code" href="classBaseKvmCPU.html#a745968f1246564028e5b3fd8dde0548d">ioctlRun</a>();
<a name="l00639"></a>00639 
<a name="l00640"></a>00640         <span class="comment">// We always execute at least one cycle to prevent the</span>
<a name="l00641"></a>00641         <span class="comment">// BaseKvmCPU::tick() to be rescheduled on the same tick</span>
<a name="l00642"></a>00642         <span class="comment">// twice.</span>
<a name="l00643"></a>00643         ticksExecuted = clockPeriod();
<a name="l00644"></a>00644     } <span class="keywordflow">else</span> {
<a name="l00645"></a>00645         <span class="comment">// This method is executed as a result of a tick event. That</span>
<a name="l00646"></a>00646         <span class="comment">// means that the event queue will be locked when entering the</span>
<a name="l00647"></a>00647         <span class="comment">// method. We temporarily unlock the event queue to allow</span>
<a name="l00648"></a>00648         <span class="comment">// other threads to steal control of this thread to inject</span>
<a name="l00649"></a>00649         <span class="comment">// interrupts. They will typically lock the queue and then</span>
<a name="l00650"></a>00650         <span class="comment">// force an exit from KVM by kicking the vCPU.</span>
<a name="l00651"></a>00651         <a class="code" href="classEventQueue_1_1ScopedRelease.html">EventQueue::ScopedRelease</a> release(<a class="code" href="eventq_8hh.html#a64a8603a1af7020a19d30c54152fdcb2">curEventQueue</a>());
<a name="l00652"></a>00652 
<a name="l00653"></a>00653         <span class="keywordflow">if</span> (ticks &lt; runTimer-&gt;resolution()) {
<a name="l00654"></a>00654             <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmRun, <span class="stringliteral">&quot;KVM: Adjusting tick count (%i -&gt; %i)\n&quot;</span>,
<a name="l00655"></a>00655                     ticks, <a class="code" href="classBaseKvmCPU.html#a28c546a9aa908313559ed074632a0c37">runTimer</a>-&gt;resolution());
<a name="l00656"></a>00656             ticks = <a class="code" href="classBaseKvmCPU.html#a28c546a9aa908313559ed074632a0c37">runTimer</a>-&gt;resolution();
<a name="l00657"></a>00657         }
<a name="l00658"></a>00658 
<a name="l00659"></a>00659         <span class="comment">// Get hardware statistics after synchronizing contexts. The KVM</span>
<a name="l00660"></a>00660         <span class="comment">// state update might affect guest cycle counters.</span>
<a name="l00661"></a>00661         uint64_t baseCycles(<a class="code" href="classBaseKvmCPU.html#abcad2a22057ba48360b17b978f694b48">getHostCycles</a>());
<a name="l00662"></a>00662         uint64_t baseInstrs(<a class="code" href="classBaseKvmCPU.html#ab3360069d449c748e7b9efe5f6d427e9">hwInstructions</a>.<a class="code" href="classPerfKvmCounter.html#af2c9c37fc5a5bcdac6d97825066ce801">read</a>());
<a name="l00663"></a>00663 
<a name="l00664"></a>00664         <span class="comment">// Arm the run timer and start the cycle timer if it isn&apos;t</span>
<a name="l00665"></a>00665         <span class="comment">// controlled by the overflow timer. Starting/stopping the cycle</span>
<a name="l00666"></a>00666         <span class="comment">// timer automatically starts the other perf timers as they are in</span>
<a name="l00667"></a>00667         <span class="comment">// the same counter group.</span>
<a name="l00668"></a>00668         <a class="code" href="classBaseKvmCPU.html#a28c546a9aa908313559ed074632a0c37">runTimer</a>-&gt;arm(ticks);
<a name="l00669"></a>00669         <span class="keywordflow">if</span> (!<a class="code" href="classBaseKvmCPU.html#a569365e1361250361be1c3f703a52914">perfControlledByTimer</a>)
<a name="l00670"></a>00670             <a class="code" href="classBaseKvmCPU.html#a496c1c0ab30aeafdeeeede34db1edf45">hwCycles</a>.<a class="code" href="classPerfKvmCounter.html#a60de64d75454385b23995437f1d72669">start</a>();
<a name="l00671"></a>00671 
<a name="l00672"></a>00672         <a class="code" href="classBaseKvmCPU.html#a745968f1246564028e5b3fd8dde0548d">ioctlRun</a>();
<a name="l00673"></a>00673 
<a name="l00674"></a>00674         <a class="code" href="classBaseKvmCPU.html#a28c546a9aa908313559ed074632a0c37">runTimer</a>-&gt;disarm();
<a name="l00675"></a>00675         <span class="keywordflow">if</span> (!<a class="code" href="classBaseKvmCPU.html#a569365e1361250361be1c3f703a52914">perfControlledByTimer</a>)
<a name="l00676"></a>00676             <a class="code" href="classBaseKvmCPU.html#a496c1c0ab30aeafdeeeede34db1edf45">hwCycles</a>.<a class="code" href="classPerfKvmCounter.html#a8c528baf37154d347366083f0f816846">stop</a>();
<a name="l00677"></a>00677 
<a name="l00678"></a>00678         <span class="comment">// The control signal may have been delivered after we exited</span>
<a name="l00679"></a>00679         <span class="comment">// from KVM. It will be pending in that case since it is</span>
<a name="l00680"></a>00680         <span class="comment">// masked when we aren&apos;t executing in KVM. Discard it to make</span>
<a name="l00681"></a>00681         <span class="comment">// sure we don&apos;t deliver it immediately next time we try to</span>
<a name="l00682"></a>00682         <span class="comment">// enter into KVM.</span>
<a name="l00683"></a>00683         <a class="code" href="classBaseKvmCPU.html#a8e9cbc5cd93017313960f88c346493ee">discardPendingSignal</a>(<a class="code" href="cpu_2kvm_2base_8hh.html#a7aba22a2f8cca986ad7802c54c654847">KVM_KICK_SIGNAL</a>);
<a name="l00684"></a>00684 
<a name="l00685"></a>00685         <span class="keyword">const</span> uint64_t hostCyclesExecuted(<a class="code" href="classBaseKvmCPU.html#abcad2a22057ba48360b17b978f694b48">getHostCycles</a>() - baseCycles);
<a name="l00686"></a>00686         <span class="keyword">const</span> uint64_t simCyclesExecuted(hostCyclesExecuted * <a class="code" href="classBaseKvmCPU.html#a0ef366aa4bbbcdc2f7eeb7fcd3962dde">hostFactor</a>);
<a name="l00687"></a>00687         <span class="keyword">const</span> uint64_t instsExecuted(<a class="code" href="classBaseKvmCPU.html#ab3360069d449c748e7b9efe5f6d427e9">hwInstructions</a>.<a class="code" href="classPerfKvmCounter.html#af2c9c37fc5a5bcdac6d97825066ce801">read</a>() - baseInstrs);
<a name="l00688"></a>00688         ticksExecuted = <a class="code" href="classBaseKvmCPU.html#a28c546a9aa908313559ed074632a0c37">runTimer</a>-&gt;ticksFromHostCycles(hostCyclesExecuted);
<a name="l00689"></a>00689 
<a name="l00690"></a>00690         <span class="comment">/* Update statistics */</span>
<a name="l00691"></a>00691         numCycles += simCyclesExecuted;;
<a name="l00692"></a>00692         <a class="code" href="classBaseKvmCPU.html#a302bf9a6fd3b54c46eb3e2bfb18a320e">numInsts</a> += instsExecuted;
<a name="l00693"></a>00693         <a class="code" href="classBaseKvmCPU.html#a4a8e80967bf91692eb1703752a8203b3">ctrInsts</a> += instsExecuted;
<a name="l00694"></a>00694         <a class="code" href="classBaseCPU.html#ab737471139f5a296e5b26e8a0e1b0744" title="initialize section">system</a>-&gt;totalNumInsts += instsExecuted;
<a name="l00695"></a>00695 
<a name="l00696"></a>00696         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmRun,
<a name="l00697"></a>00697                 <span class="stringliteral">&quot;KVM: Executed %i instructions in %i cycles &quot;</span>
<a name="l00698"></a>00698                 <span class="stringliteral">&quot;(%i ticks, sim cycles: %i).\n&quot;</span>,
<a name="l00699"></a>00699                 instsExecuted, hostCyclesExecuted, ticksExecuted, simCyclesExecuted);
<a name="l00700"></a>00700     }
<a name="l00701"></a>00701 
<a name="l00702"></a>00702     ++<a class="code" href="classBaseKvmCPU.html#a6184fcde9e075404315cd7c343054d30">numVMExits</a>;
<a name="l00703"></a>00703 
<a name="l00704"></a>00704     <span class="keywordflow">return</span> ticksExecuted + <a class="code" href="classBaseKvmCPU.html#a2858df681aa95b652e3d371d56def5a3">flushCoalescedMMIO</a>();
<a name="l00705"></a>00705 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a405afc17ad0dee3b816012ce909b2b6f"></a><!-- doxytag: member="BaseKvmCPU::kvmRunDrain" ref="a405afc17ad0dee3b816012ce909b2b6f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> kvmRunDrain </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classRequest.html">Request</a> the CPU to run until draining completes.</p>
<p>This function normally calls kvmRun(0) to make KVM finish pending MMIO operations. Architecures implementing <a class="el" href="classBaseKvmCPU.html#a4ee4cbdc5d3315fd8016b44d3e77abd5">archIsDrained()</a> must override this method.</p>
<dl class="see"><dt><b>参照:</b></dt><dd><a class="el" href="classBaseKvmCPU.html#a4ee4cbdc5d3315fd8016b44d3e77abd5">BaseKvmCPU::archIsDrained()</a></dd></dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Number of ticks executed </dd></dl>

<p><a class="el" href="classX86KvmCPU.html#a405afc17ad0dee3b816012ce909b2b6f">X86KvmCPU</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00595"></a>00595 {
<a name="l00596"></a>00596     <span class="comment">// By default, the only thing we need to drain is a pending IO</span>
<a name="l00597"></a>00597     <span class="comment">// operation which assumes that we are in the</span>
<a name="l00598"></a>00598     <span class="comment">// RunningServiceCompletion state.</span>
<a name="l00599"></a>00599     assert(<a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> == <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba8d38f5f3c8c186646364b893e12e6ae0">RunningServiceCompletion</a>);
<a name="l00600"></a>00600 
<a name="l00601"></a>00601     <span class="comment">// Deliver the data from the pending IO operation and immediately</span>
<a name="l00602"></a>00602     <span class="comment">// exit.</span>
<a name="l00603"></a>00603     <span class="keywordflow">return</span> <a class="code" href="classBaseKvmCPU.html#aed3dbd0c0bf26d82ee56367a3f350506">kvmRun</a>(0);
<a name="l00604"></a>00604 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4dc637449366fcdfc4e764cdf12d9b11"></a><!-- doxytag: member="BaseKvmCPU::regStats" ref="a4dc637449366fcdfc4e764cdf12d9b11" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regStats </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00201"></a>00201 {
<a name="l00202"></a>00202     <span class="keyword">using namespace </span>Stats;
<a name="l00203"></a>00203 
<a name="l00204"></a>00204     <a class="code" href="classSimObject.html#a4dc637449366fcdfc4e764cdf12d9b11">BaseCPU::regStats</a>();
<a name="l00205"></a>00205 
<a name="l00206"></a>00206     <a class="code" href="classBaseKvmCPU.html#a302bf9a6fd3b54c46eb3e2bfb18a320e">numInsts</a>
<a name="l00207"></a>00207         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>() + <span class="stringliteral">&quot;.committedInsts&quot;</span>)
<a name="l00208"></a>00208         .desc(<span class="stringliteral">&quot;Number of instructions committed&quot;</span>)
<a name="l00209"></a>00209         ;
<a name="l00210"></a>00210 
<a name="l00211"></a>00211     <a class="code" href="classBaseKvmCPU.html#a6184fcde9e075404315cd7c343054d30">numVMExits</a>
<a name="l00212"></a>00212         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>() + <span class="stringliteral">&quot;.numVMExits&quot;</span>)
<a name="l00213"></a>00213         .desc(<span class="stringliteral">&quot;total number of KVM exits&quot;</span>)
<a name="l00214"></a>00214         ;
<a name="l00215"></a>00215 
<a name="l00216"></a>00216     <a class="code" href="classBaseKvmCPU.html#a8ef83ba51e6ab5f5db813c16e3cebb1d">numVMHalfEntries</a>
<a name="l00217"></a>00217         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>() + <span class="stringliteral">&quot;.numVMHalfEntries&quot;</span>)
<a name="l00218"></a>00218         .desc(<span class="stringliteral">&quot;number of KVM entries to finalize pending operations&quot;</span>)
<a name="l00219"></a>00219         ;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221     <a class="code" href="classBaseKvmCPU.html#a6cdcd551476b4e8234d5bfd987218d88">numExitSignal</a>
<a name="l00222"></a>00222         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>() + <span class="stringliteral">&quot;.numExitSignal&quot;</span>)
<a name="l00223"></a>00223         .desc(<span class="stringliteral">&quot;exits due to signal delivery&quot;</span>)
<a name="l00224"></a>00224         ;
<a name="l00225"></a>00225 
<a name="l00226"></a>00226     <a class="code" href="classBaseKvmCPU.html#a4030a87068a8b133f5efabfc19f7542d">numMMIO</a>
<a name="l00227"></a>00227         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>() + <span class="stringliteral">&quot;.numMMIO&quot;</span>)
<a name="l00228"></a>00228         .desc(<span class="stringliteral">&quot;number of VM exits due to memory mapped IO&quot;</span>)
<a name="l00229"></a>00229         ;
<a name="l00230"></a>00230 
<a name="l00231"></a>00231     <a class="code" href="classBaseKvmCPU.html#a99a92abe3f29c3d0f59af4e384a8fe7f">numCoalescedMMIO</a>
<a name="l00232"></a>00232         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>() + <span class="stringliteral">&quot;.numCoalescedMMIO&quot;</span>)
<a name="l00233"></a>00233         .desc(<span class="stringliteral">&quot;number of coalesced memory mapped IO requests&quot;</span>)
<a name="l00234"></a>00234         ;
<a name="l00235"></a>00235 
<a name="l00236"></a>00236     <a class="code" href="classBaseKvmCPU.html#ae3a09de1034e0294f5df0ce66d876727">numIO</a>
<a name="l00237"></a>00237         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>() + <span class="stringliteral">&quot;.numIO&quot;</span>)
<a name="l00238"></a>00238         .desc(<span class="stringliteral">&quot;number of VM exits due to legacy IO&quot;</span>)
<a name="l00239"></a>00239         ;
<a name="l00240"></a>00240 
<a name="l00241"></a>00241     <a class="code" href="classBaseKvmCPU.html#a65e906b9e123036deb6bc8922ce53e96">numHalt</a>
<a name="l00242"></a>00242         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>() + <span class="stringliteral">&quot;.numHalt&quot;</span>)
<a name="l00243"></a>00243         .desc(<span class="stringliteral">&quot;number of VM exits due to wait for interrupt instructions&quot;</span>)
<a name="l00244"></a>00244         ;
<a name="l00245"></a>00245 
<a name="l00246"></a>00246     <a class="code" href="classBaseKvmCPU.html#a5ff214621d200e4672d581b12832886a">numInterrupts</a>
<a name="l00247"></a>00247         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>() + <span class="stringliteral">&quot;.numInterrupts&quot;</span>)
<a name="l00248"></a>00248         .desc(<span class="stringliteral">&quot;number of interrupts delivered&quot;</span>)
<a name="l00249"></a>00249         ;
<a name="l00250"></a>00250 
<a name="l00251"></a>00251     <a class="code" href="classBaseKvmCPU.html#a230908c23db440bfcee954fb8d72f269">numHypercalls</a>
<a name="l00252"></a>00252         .<a class="code" href="classStats_1_1DataWrap.html#a8eaf5c2b92132dfcacd7d9b10afb1726">name</a>(<a class="code" href="trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>() + <span class="stringliteral">&quot;.numHypercalls&quot;</span>)
<a name="l00253"></a>00253         .desc(<span class="stringliteral">&quot;number of hypercalls&quot;</span>)
<a name="l00254"></a>00254         ;
<a name="l00255"></a>00255 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a688ca491f5419c29fb81f8235ba1dc13"></a><!-- doxytag: member="BaseKvmCPU::serializeThread" ref="a688ca491f5419c29fb81f8235ba1dc13" args="(std::ostream &amp;os, ThreadID tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serializeThread </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a>&nbsp;</td>
          <td class="paramname"> <em>tid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00259"></a>00259 {
<a name="l00260"></a>00260     <span class="keywordflow">if</span> (<a class="code" href="trace_8hh.html#af76c9f7776aade1bf9d7dfa8a0c6b341">DTRACE</a>(<a class="code" href="classCheckpoint.html">Checkpoint</a>)) {
<a name="l00261"></a>00261         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCheckpoint.html">Checkpoint</a>, <span class="stringliteral">&quot;KVM: Serializing thread %i:\n&quot;</span>, tid);
<a name="l00262"></a>00262         <a class="code" href="classBaseKvmCPU.html#accd2600060dbaee3a3b41aed4034c63c">dump</a>();
<a name="l00263"></a>00263     }
<a name="l00264"></a>00264 
<a name="l00265"></a>00265     assert(tid == 0);
<a name="l00266"></a>00266     assert(<a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> == <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>);
<a name="l00267"></a>00267     <a class="code" href="classBaseKvmCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a53e036786d17361be4c7320d39c99b84">serialize</a>(<a class="code" href="namespaceX86ISA.html#a6b6e6ba763e7eaf46ac5b6372ca98d30">os</a>);
<a name="l00268"></a>00268 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a31b5d1e73edb46a17fa0a8ddd29e7604"></a><!-- doxytag: member="BaseKvmCPU::setFPUState" ref="a31b5d1e73edb46a17fa0a8ddd29e7604" args="(const struct kvm_fpu &amp;state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setFPUState </td>
          <td>(</td>
          <td class="paramtype">const struct kvm_fpu &amp;&nbsp;</td>
          <td class="paramname"> <em>state</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00760"></a>00760 {
<a name="l00761"></a>00761     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_SET_FPU, (<span class="keywordtype">void</span> *)&amp;state) == -1)
<a name="l00762"></a>00762         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to set guest FPU state\n&quot;</span>);
<a name="l00763"></a>00763 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab70d563942fa831d4de5da7d94ba8064"></a><!-- doxytag: member="BaseKvmCPU::setOneReg" ref="ab70d563942fa831d4de5da7d94ba8064" args="(uint64_t id, uint32_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setOneReg </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00350"></a>00350 { <a class="code" href="classBaseKvmCPU.html#ad96695f9596f808056054f3c2026b818">setOneReg</a>(<span class="keywordtype">id</span>, &amp;<a class="code" href="namespacegenini.html#a7e5f482a3a8a4f98bd1a9c124485f572">value</a>); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0f8ff23affd5f22fc47c4d00e6d24979"></a><!-- doxytag: member="BaseKvmCPU::setOneReg" ref="a0f8ff23affd5f22fc47c4d00e6d24979" args="(uint64_t id, uint64_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setOneReg </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00349"></a>00349 { <a class="code" href="classBaseKvmCPU.html#ad96695f9596f808056054f3c2026b818">setOneReg</a>(<span class="keywordtype">id</span>, &amp;<a class="code" href="namespacegenini.html#a7e5f482a3a8a4f98bd1a9c124485f572">value</a>); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad96695f9596f808056054f3c2026b818"></a><!-- doxytag: member="BaseKvmCPU::setOneReg" ref="ad96695f9596f808056054f3c2026b818" args="(uint64_t id, const void *addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setOneReg </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get/Set single register using the KVM_(SET|GET)_ONE_REG API.</p>
<dl class="note"><dt><b>覚え書き:</b></dt><dd>The presence of this call depends on <a class="el" href="classKvm.html#af1ad3b73711f45008bcb240d012987f7">Kvm::capOneReg()</a>. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00768"></a>00768 {
<a name="l00769"></a>00769 <span class="preprocessor">#ifdef KVM_SET_ONE_REG</span>
<a name="l00770"></a>00770 <span class="preprocessor"></span>    <span class="keyword">struct </span>kvm_one_reg <a class="code" href="namespaceX86ISA.html#aeeb02ad833ab76f3430553ef93213a6b">reg</a>;
<a name="l00771"></a>00771     <a class="code" href="namespaceX86ISA.html#aeeb02ad833ab76f3430553ef93213a6b">reg</a>.id = <a class="code" href="namespaceSparcISA.html#a2b4cf644f5af9ebaec502fb09986f302">id</a>;
<a name="l00772"></a>00772     <a class="code" href="namespaceX86ISA.html#aeeb02ad833ab76f3430553ef93213a6b">reg</a>.addr = (uint64_t)<a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a>;
<a name="l00773"></a>00773 
<a name="l00774"></a>00774     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_SET_ONE_REG, &amp;<a class="code" href="namespaceX86ISA.html#aeeb02ad833ab76f3430553ef93213a6b">reg</a>) == -1) {
<a name="l00775"></a>00775         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to set register (0x%x) value (errno: %i)\n&quot;</span>,
<a name="l00776"></a>00776               <span class="keywordtype">id</span>, errno);
<a name="l00777"></a>00777     }
<a name="l00778"></a>00778 <span class="preprocessor">#else</span>
<a name="l00779"></a>00779 <span class="preprocessor"></span>    <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM_SET_ONE_REG is unsupported on this platform.\n&quot;</span>);
<a name="l00780"></a>00780 <span class="preprocessor">#endif</span>
<a name="l00781"></a>00781 <span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a104d34588afdf9e14607bad09f01bd53"></a><!-- doxytag: member="BaseKvmCPU::setRegisters" ref="a104d34588afdf9e14607bad09f01bd53" args="(const struct kvm_regs &amp;regs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setRegisters </td>
          <td>(</td>
          <td class="paramtype">const struct kvm_regs &amp;&nbsp;</td>
          <td class="paramname"> <em>regs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00732"></a>00732 {
<a name="l00733"></a>00733     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_SET_REGS, (<span class="keywordtype">void</span> *)&amp;regs) == -1)
<a name="l00734"></a>00734         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to set guest registers\n&quot;</span>);
<a name="l00735"></a>00735 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a76bff52136628a5be57e6d1ea8ff5370"></a><!-- doxytag: member="BaseKvmCPU::setSignalMask" ref="a76bff52136628a5be57e6d1ea8ff5370" args="(const sigset_t *mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSignalMask </td>
          <td>(</td>
          <td class="paramtype">const sigset_t *&nbsp;</td>
          <td class="paramname"> <em>mask</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classSet.html">Set</a> the signal mask used in <a class="el" href="classBaseKvmCPU.html#aed3dbd0c0bf26d82ee56367a3f350506">kvmRun()</a></p>
<p>This method allows the signal mask of the thread executing <a class="el" href="classBaseKvmCPU.html#aed3dbd0c0bf26d82ee56367a3f350506">kvmRun()</a> to be overridden inside the actual system call. This allows us to mask timer signals used to force KVM exits while in gem5.</p>
<p>The signal mask can be disabled by setting it to NULL.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>Signals to mask </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01027"></a>01027 {
<a name="l01028"></a>01028     std::unique_ptr&lt;struct kvm_signal_mask&gt; kvm_mask;
<a name="l01029"></a>01029 
<a name="l01030"></a>01030     <span class="keywordflow">if</span> (<a class="code" href="namespaceArmISA.html#a9534dbda5e7db9881c7955c6e08cfdc0">mask</a>) {
<a name="l01031"></a>01031         kvm_mask.reset((<span class="keyword">struct</span> kvm_signal_mask *)<span class="keyword">operator</span> <span class="keyword">new</span>(
<a name="l01032"></a>01032                            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> kvm_signal_mask) + <span class="keyword">sizeof</span>(*<a class="code" href="namespaceArmISA.html#a9534dbda5e7db9881c7955c6e08cfdc0">mask</a>)));
<a name="l01033"></a>01033         <span class="comment">// The kernel and the user-space headers have different ideas</span>
<a name="l01034"></a>01034         <span class="comment">// about the size of sigset_t. This seems like a massive hack,</span>
<a name="l01035"></a>01035         <span class="comment">// but is actually what qemu does.</span>
<a name="l01036"></a>01036         assert(<span class="keyword">sizeof</span>(*<a class="code" href="namespaceArmISA.html#a9534dbda5e7db9881c7955c6e08cfdc0">mask</a>) &gt;= 8);
<a name="l01037"></a>01037         kvm_mask-&gt;len = 8;
<a name="l01038"></a>01038         memcpy(kvm_mask-&gt;sigset, <a class="code" href="namespaceArmISA.html#a9534dbda5e7db9881c7955c6e08cfdc0">mask</a>, kvm_mask-&gt;len);
<a name="l01039"></a>01039     }
<a name="l01040"></a>01040 
<a name="l01041"></a>01041     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_SET_SIGNAL_MASK, (<span class="keywordtype">void</span> *)kvm_mask.get()) == -1)
<a name="l01042"></a>01042         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to set vCPU signal mask (errno: %i)\n&quot;</span>,
<a name="l01043"></a>01043               errno);
<a name="l01044"></a>01044 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aefaac43fa62903f42a68a637083d5f09"></a><!-- doxytag: member="BaseKvmCPU::setSpecialRegisters" ref="aefaac43fa62903f42a68a637083d5f09" args="(const struct kvm_sregs &amp;regs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSpecialRegisters </td>
          <td>(</td>
          <td class="paramtype">const struct kvm_sregs &amp;&nbsp;</td>
          <td class="paramname"> <em>regs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00746"></a>00746 {
<a name="l00747"></a>00747     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_SET_SREGS, (<span class="keywordtype">void</span> *)&amp;regs) == -1)
<a name="l00748"></a>00748         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to set guest special registers\n&quot;</span>);
<a name="l00749"></a>00749 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9a2709df130ee7a63e53f9d65a0ebb36"></a><!-- doxytag: member="BaseKvmCPU::setupCounters" ref="a9a2709df130ee7a63e53f9d65a0ebb36" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setupCounters </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Setup hardware performance counters </p>

<p><div class="fragment"><pre class="fragment"><a name="l01156"></a>01156 {
<a name="l01157"></a>01157     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classKvm.html">Kvm</a>, <span class="stringliteral">&quot;Attaching cycle counter...\n&quot;</span>);
<a name="l01158"></a>01158     <a class="code" href="classPerfKvmCounterConfig.html">PerfKvmCounterConfig</a> cfgCycles(PERF_TYPE_HARDWARE,
<a name="l01159"></a>01159                                 PERF_COUNT_HW_CPU_CYCLES);
<a name="l01160"></a>01160     cfgCycles.disabled(<span class="keyword">true</span>)
<a name="l01161"></a>01161         .pinned(<span class="keyword">true</span>);
<a name="l01162"></a>01162 
<a name="l01163"></a>01163     <span class="comment">// Try to exclude the host. We set both exclude_hv and</span>
<a name="l01164"></a>01164     <span class="comment">// exclude_host since different architectures use slightly</span>
<a name="l01165"></a>01165     <span class="comment">// different APIs in the kernel.</span>
<a name="l01166"></a>01166     cfgCycles.exclude_hv(<span class="keyword">true</span>)
<a name="l01167"></a>01167         .exclude_host(<span class="keyword">true</span>);
<a name="l01168"></a>01168 
<a name="l01169"></a>01169     <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#a569365e1361250361be1c3f703a52914">perfControlledByTimer</a>) {
<a name="l01170"></a>01170         <span class="comment">// We need to configure the cycles counter to send overflows</span>
<a name="l01171"></a>01171         <span class="comment">// since we are going to use it to trigger timer signals that</span>
<a name="l01172"></a>01172         <span class="comment">// trap back into m5 from KVM. In practice, this means that we</span>
<a name="l01173"></a>01173         <span class="comment">// need to set some non-zero sample period that gets</span>
<a name="l01174"></a>01174         <span class="comment">// overridden when the timer is armed.</span>
<a name="l01175"></a>01175         cfgCycles.wakeupEvents(1)
<a name="l01176"></a>01176             .samplePeriod(42);
<a name="l01177"></a>01177     }
<a name="l01178"></a>01178 
<a name="l01179"></a>01179     <a class="code" href="classBaseKvmCPU.html#a496c1c0ab30aeafdeeeede34db1edf45">hwCycles</a>.<a class="code" href="classPerfKvmCounter.html#a162e5b205959ecba29def7e7e0bf92dd">attach</a>(cfgCycles,
<a name="l01180"></a>01180                     0); <span class="comment">// TID (0 =&gt; currentThread)</span>
<a name="l01181"></a>01181 
<a name="l01182"></a>01182     <a class="code" href="classBaseKvmCPU.html#a807cad1db3257b823ffdb698c1e62a9a">setupInstCounter</a>();
<a name="l01183"></a>01183 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a807cad1db3257b823ffdb698c1e62a9a"></a><!-- doxytag: member="BaseKvmCPU::setupInstCounter" ref="a807cad1db3257b823ffdb698c1e62a9a" args="(uint64_t period=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setupInstCounter </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>period</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Setup the guest instruction counter.</p>
<p>Setup the guest instruction counter and optionally request a signal every N instructions executed by the guest. This method will re-attach the counter if the counter has already been attached and its sampling settings have changed.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>period</em>&nbsp;</td><td>Signal period, set to 0 to disable signaling. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01233"></a>01233 {
<a name="l01234"></a>01234     <span class="comment">// No need to do anything if we aren&apos;t attaching for the first</span>
<a name="l01235"></a>01235     <span class="comment">// time or the period isn&apos;t changing.</span>
<a name="l01236"></a>01236     <span class="keywordflow">if</span> (period == <a class="code" href="classBaseKvmCPU.html#a9b8c93980540464141f0989b8258295b">activeInstPeriod</a> &amp;&amp; <a class="code" href="classBaseKvmCPU.html#ab3360069d449c748e7b9efe5f6d427e9">hwInstructions</a>.<a class="code" href="classPerfKvmCounter.html#aa828991b44e099ad372a7833c34d3e24">attached</a>())
<a name="l01237"></a>01237         <span class="keywordflow">return</span>;
<a name="l01238"></a>01238 
<a name="l01239"></a>01239     <a class="code" href="classPerfKvmCounterConfig.html">PerfKvmCounterConfig</a> cfgInstructions(PERF_TYPE_HARDWARE,
<a name="l01240"></a>01240                                          PERF_COUNT_HW_INSTRUCTIONS);
<a name="l01241"></a>01241 
<a name="l01242"></a>01242     <span class="comment">// Try to exclude the host. We set both exclude_hv and</span>
<a name="l01243"></a>01243     <span class="comment">// exclude_host since different architectures use slightly</span>
<a name="l01244"></a>01244     <span class="comment">// different APIs in the kernel.</span>
<a name="l01245"></a>01245     cfgInstructions.exclude_hv(<span class="keyword">true</span>)
<a name="l01246"></a>01246         .exclude_host(<span class="keyword">true</span>);
<a name="l01247"></a>01247 
<a name="l01248"></a>01248     <span class="keywordflow">if</span> (period) {
<a name="l01249"></a>01249         <span class="comment">// Setup a sampling counter if that has been requested.</span>
<a name="l01250"></a>01250         cfgInstructions.wakeupEvents(1)
<a name="l01251"></a>01251             .samplePeriod(period);
<a name="l01252"></a>01252     }
<a name="l01253"></a>01253 
<a name="l01254"></a>01254     <span class="comment">// We need to detach and re-attach the counter to reliably change</span>
<a name="l01255"></a>01255     <span class="comment">// sampling settings. See PerfKvmCounter::period() for details.</span>
<a name="l01256"></a>01256     <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#ab3360069d449c748e7b9efe5f6d427e9">hwInstructions</a>.<a class="code" href="classPerfKvmCounter.html#aa828991b44e099ad372a7833c34d3e24">attached</a>())
<a name="l01257"></a>01257         <a class="code" href="classBaseKvmCPU.html#ab3360069d449c748e7b9efe5f6d427e9">hwInstructions</a>.<a class="code" href="classPerfKvmCounter.html#ac295bade8aee589f6718dfa79edc2a34">detach</a>();
<a name="l01258"></a>01258     assert(<a class="code" href="classBaseKvmCPU.html#a496c1c0ab30aeafdeeeede34db1edf45">hwCycles</a>.<a class="code" href="classPerfKvmCounter.html#aa828991b44e099ad372a7833c34d3e24">attached</a>());
<a name="l01259"></a>01259     <a class="code" href="classBaseKvmCPU.html#ab3360069d449c748e7b9efe5f6d427e9">hwInstructions</a>.<a class="code" href="classPerfKvmCounter.html#a162e5b205959ecba29def7e7e0bf92dd">attach</a>(cfgInstructions,
<a name="l01260"></a>01260                           0, <span class="comment">// TID (0 =&gt; currentThread)</span>
<a name="l01261"></a>01261                           <a class="code" href="classBaseKvmCPU.html#a496c1c0ab30aeafdeeeede34db1edf45">hwCycles</a>);
<a name="l01262"></a>01262 
<a name="l01263"></a>01263     <span class="keywordflow">if</span> (period)
<a name="l01264"></a>01264         <a class="code" href="classBaseKvmCPU.html#ab3360069d449c748e7b9efe5f6d427e9">hwInstructions</a>.<a class="code" href="classPerfKvmCounter.html#adcb1192220b2f38f9e05b5c8a0f3ab30">enableSignals</a>(<a class="code" href="cpu_2kvm_2base_8hh.html#a7aba22a2f8cca986ad7802c54c654847">KVM_KICK_SIGNAL</a>);
<a name="l01265"></a>01265 
<a name="l01266"></a>01266     <a class="code" href="classBaseKvmCPU.html#a9b8c93980540464141f0989b8258295b">activeInstPeriod</a> = period;
<a name="l01267"></a>01267 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a10bd071dda7c87970b3595b2d3c5408e"></a><!-- doxytag: member="BaseKvmCPU::setupInstStop" ref="a10bd071dda7c87970b3595b2d3c5408e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setupInstStop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Setup an instruction break if there is one pending.</p>
<p><a class="el" href="classCheck.html">Check</a> if there are pending instruction breaks in the CPU's instruction event queue and schedule an instruction break using PerfEvent.</p>
<dl class="note"><dt><b>覚え書き:</b></dt><dd>This method doesn't currently handle the main system instruction event queue. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01220"></a>01220 {
<a name="l01221"></a>01221     <span class="keywordflow">if</span> (comInstEventQueue[0]-&gt;empty()) {
<a name="l01222"></a>01222         <a class="code" href="classBaseKvmCPU.html#a807cad1db3257b823ffdb698c1e62a9a">setupInstCounter</a>(0);
<a name="l01223"></a>01223     } <span class="keywordflow">else</span> {
<a name="l01224"></a>01224         <span class="keyword">const</span> uint64_t next(comInstEventQueue[0]-&gt;nextTick());
<a name="l01225"></a>01225 
<a name="l01226"></a>01226         assert(next &gt; <a class="code" href="classBaseKvmCPU.html#a4a8e80967bf91692eb1703752a8203b3">ctrInsts</a>);
<a name="l01227"></a>01227         <a class="code" href="classBaseKvmCPU.html#a807cad1db3257b823ffdb698c1e62a9a">setupInstCounter</a>(next - <a class="code" href="classBaseKvmCPU.html#a4a8e80967bf91692eb1703752a8203b3">ctrInsts</a>);
<a name="l01228"></a>01228     }
<a name="l01229"></a>01229 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="acae9fda1e38c2cd8a3d7c8659a4a66fa"></a><!-- doxytag: member="BaseKvmCPU::setupSignalHandler" ref="acae9fda1e38c2cd8a3d7c8659a4a66fa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setupSignalHandler </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Setup a signal handler to catch the timer signal used to switch back to the monitor. </p>

<p><div class="fragment"><pre class="fragment"><a name="l01099"></a>01099 {
<a name="l01100"></a>01100     <span class="keyword">struct </span>sigaction <a class="code" href="namespaceArmISA.html#a13cb6ab00c171f7ae38987d4e1342d75">sa</a>;
<a name="l01101"></a>01101 
<a name="l01102"></a>01102     memset(&amp;<a class="code" href="namespaceArmISA.html#a13cb6ab00c171f7ae38987d4e1342d75">sa</a>, 0, <span class="keyword">sizeof</span>(<a class="code" href="namespaceArmISA.html#a13cb6ab00c171f7ae38987d4e1342d75">sa</a>));
<a name="l01103"></a>01103     <a class="code" href="namespaceArmISA.html#a13cb6ab00c171f7ae38987d4e1342d75">sa</a>.sa_sigaction = <a class="code" href="cpu_2kvm_2base_8cc.html#aada2690e36c909f8ff0abe948e1bdc9d">onKickSignal</a>;
<a name="l01104"></a>01104     <a class="code" href="namespaceArmISA.html#a13cb6ab00c171f7ae38987d4e1342d75">sa</a>.sa_flags = SA_SIGINFO | SA_RESTART;
<a name="l01105"></a>01105     <span class="keywordflow">if</span> (sigaction(<a class="code" href="cpu_2kvm_2base_8hh.html#a7aba22a2f8cca986ad7802c54c654847">KVM_KICK_SIGNAL</a>, &amp;<a class="code" href="namespaceArmISA.html#a13cb6ab00c171f7ae38987d4e1342d75">sa</a>, <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>) == -1)
<a name="l01106"></a>01106         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to setup vCPU timer signal handler\n&quot;</span>);
<a name="l01107"></a>01107 
<a name="l01108"></a>01108     sigset_t sigset;
<a name="l01109"></a>01109     <span class="keywordflow">if</span> (pthread_sigmask(SIG_BLOCK, <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>, &amp;sigset) == -1)
<a name="l01110"></a>01110         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed get signal mask\n&quot;</span>);
<a name="l01111"></a>01111 
<a name="l01112"></a>01112     <span class="comment">// Request KVM to setup the same signal mask as we&apos;re currently</span>
<a name="l01113"></a>01113     <span class="comment">// running with except for the KVM control signal. We&apos;ll sometimes</span>
<a name="l01114"></a>01114     <span class="comment">// need to raise the KVM_KICK_SIGNAL to cause immediate exits from</span>
<a name="l01115"></a>01115     <span class="comment">// KVM after servicing IO requests. See kvmRun().</span>
<a name="l01116"></a>01116     sigdelset(&amp;sigset, <a class="code" href="cpu_2kvm_2base_8hh.html#a7aba22a2f8cca986ad7802c54c654847">KVM_KICK_SIGNAL</a>);
<a name="l01117"></a>01117     <a class="code" href="classBaseKvmCPU.html#a76bff52136628a5be57e6d1ea8ff5370">setSignalMask</a>(&amp;sigset);
<a name="l01118"></a>01118 
<a name="l01119"></a>01119     <span class="comment">// Mask our control signals so they aren&apos;t delivered unless we&apos;re</span>
<a name="l01120"></a>01120     <span class="comment">// actually executing inside KVM.</span>
<a name="l01121"></a>01121     sigaddset(&amp;sigset, <a class="code" href="cpu_2kvm_2base_8hh.html#a7aba22a2f8cca986ad7802c54c654847">KVM_KICK_SIGNAL</a>);
<a name="l01122"></a>01122     <span class="keywordflow">if</span> (pthread_sigmask(SIG_SETMASK, &amp;sigset, <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>) == -1)
<a name="l01123"></a>01123         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed mask the KVM control signals\n&quot;</span>);
<a name="l01124"></a>01124 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aecc7d8debf54990ffeaaed5bac7d7d81"></a><!-- doxytag: member="BaseKvmCPU::startup" ref="aecc7d8debf54990ffeaaed5bac7d7d81" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void startup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classArmKvmCPU.html#aecc7d8debf54990ffeaaed5bac7d7d81">ArmKvmCPU</a>, と <a class="el" href="classX86KvmCPU.html#aecc7d8debf54990ffeaaed5bac7d7d81">X86KvmCPU</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00121"></a>00121 {
<a name="l00122"></a>00122     <span class="keyword">const</span> BaseKvmCPUParams * <span class="keyword">const</span> <a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>(
<a name="l00123"></a>00123         dynamic_cast&lt;const BaseKvmCPUParams *&gt;(params()));
<a name="l00124"></a>00124 
<a name="l00125"></a>00125     <a class="code" href="classKvm.html">Kvm</a> &amp;kvm(<a class="code" href="classBaseKvmCPU.html#a6b8ecd9ec419f0cbe3c1047be643fe08">vm</a>.<a class="code" href="classKvmVM.html#a4169de9bdb8aa1afbeed2acc231dbb7f">kvm</a>);
<a name="l00126"></a>00126 
<a name="l00127"></a>00127     <a class="code" href="classSimObject.html#aecc7d8debf54990ffeaaed5bac7d7d81">BaseCPU::startup</a>();
<a name="l00128"></a>00128 
<a name="l00129"></a>00129     assert(<a class="code" href="classBaseKvmCPU.html#a6b91f8b5649b80e8424cebfa3047e1d0">vcpuFD</a> == -1);
<a name="l00130"></a>00130 
<a name="l00131"></a>00131     <span class="comment">// Tell the VM that a CPU is about to start.</span>
<a name="l00132"></a>00132     <a class="code" href="classBaseKvmCPU.html#a6b8ecd9ec419f0cbe3c1047be643fe08">vm</a>.<a class="code" href="classKvmVM.html#a0161816a71e88927cba137fb4dde7298">cpuStartup</a>();
<a name="l00133"></a>00133 
<a name="l00134"></a>00134     <span class="comment">// We can&apos;t initialize KVM CPUs in BaseKvmCPU::init() since we are</span>
<a name="l00135"></a>00135     <span class="comment">// not guaranteed that the parent KVM VM has initialized at that</span>
<a name="l00136"></a>00136     <span class="comment">// point. Initialize virtual CPUs here instead.</span>
<a name="l00137"></a>00137     <a class="code" href="classBaseKvmCPU.html#a6b91f8b5649b80e8424cebfa3047e1d0">vcpuFD</a> = <a class="code" href="classBaseKvmCPU.html#a6b8ecd9ec419f0cbe3c1047be643fe08">vm</a>.<a class="code" href="classKvmVM.html#a3841d0c536bfa3b8f3b4e8ef5a46039b">createVCPU</a>(<a class="code" href="classBaseKvmCPU.html#ac52bdf6886dcfd53068633de9ed83184">vcpuID</a>);
<a name="l00138"></a>00138 
<a name="l00139"></a>00139     <span class="comment">// Map the KVM run structure */</span>
<a name="l00140"></a>00140     <a class="code" href="classBaseKvmCPU.html#a0915679bdc25b2c015f15996f6d4ff6d">vcpuMMapSize</a> = kvm.getVCPUMMapSize();
<a name="l00141"></a>00141     <a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a> = (<span class="keyword">struct </span>kvm_run *)mmap(0, <a class="code" href="classBaseKvmCPU.html#a0915679bdc25b2c015f15996f6d4ff6d">vcpuMMapSize</a>,
<a name="l00142"></a>00142                                      PROT_READ | PROT_WRITE, MAP_SHARED,
<a name="l00143"></a>00143                                      <a class="code" href="classBaseKvmCPU.html#a6b91f8b5649b80e8424cebfa3047e1d0">vcpuFD</a>, 0);
<a name="l00144"></a>00144     <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a> == MAP_FAILED)
<a name="l00145"></a>00145         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to map run data structure\n&quot;</span>);
<a name="l00146"></a>00146 
<a name="l00147"></a>00147     <span class="comment">// Setup a pointer to the MMIO ring buffer if coalesced MMIO is</span>
<a name="l00148"></a>00148     <span class="comment">// available. The offset into the KVM&apos;s communication page is</span>
<a name="l00149"></a>00149     <span class="comment">// provided by the coalesced MMIO capability.</span>
<a name="l00150"></a>00150     <span class="keywordtype">int</span> mmioOffset(kvm.capCoalescedMMIO());
<a name="l00151"></a>00151     <span class="keywordflow">if</span> (!<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;useCoalescedMMIO) {
<a name="l00152"></a>00152         <a class="code" href="base_2misc_8hh.html#ae7d790080fa18103d7582effff570b9e">inform</a>(<span class="stringliteral">&quot;KVM: Coalesced MMIO disabled by config.\n&quot;</span>);
<a name="l00153"></a>00153     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mmioOffset) {
<a name="l00154"></a>00154         <a class="code" href="base_2misc_8hh.html#ae7d790080fa18103d7582effff570b9e">inform</a>(<span class="stringliteral">&quot;KVM: Coalesced IO available\n&quot;</span>);
<a name="l00155"></a>00155         <a class="code" href="classBaseKvmCPU.html#ad4e1bcd3f032d2921aa97aec1fc7a45c">mmioRing</a> = (<span class="keyword">struct </span>kvm_coalesced_mmio_ring *)(
<a name="l00156"></a>00156             (<span class="keywordtype">char</span> *)<a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a> + (mmioOffset * <a class="code" href="classBaseKvmCPU.html#a8386a4766759aabc32038300820a64aa">pageSize</a>));
<a name="l00157"></a>00157     } <span class="keywordflow">else</span> {
<a name="l00158"></a>00158         <a class="code" href="base_2misc_8hh.html#ae7d790080fa18103d7582effff570b9e">inform</a>(<span class="stringliteral">&quot;KVM: Coalesced not supported by host OS\n&quot;</span>);
<a name="l00159"></a>00159     }
<a name="l00160"></a>00160 
<a name="l00161"></a>00161     <a class="code" href="classBaseKvmCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#aecc7d8debf54990ffeaaed5bac7d7d81">startup</a>();
<a name="l00162"></a>00162 
<a name="l00163"></a>00163     <a class="code" href="classEvent.html">Event</a> *startupEvent(
<a name="l00164"></a>00164         <span class="keyword">new</span> <a class="code" href="classEventWrapper.html">EventWrapper</a>&lt;<a class="code" href="classBaseKvmCPU.html">BaseKvmCPU</a>,
<a name="l00165"></a>00165                          &amp;<a class="code" href="classBaseKvmCPU.html#abc1464ae4d17eb8f6ea86c6bb5f68532">BaseKvmCPU::startupThread</a>&gt;(<span class="keyword">this</span>, <span class="keyword">true</span>));
<a name="l00166"></a>00166     schedule(startupEvent, <a class="code" href="statistics_8hh.html#a7acdccbf0d35ce0c159c0cdd36371b22" title="The universal simulation clock.">curTick</a>());
<a name="l00167"></a>00167 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abc1464ae4d17eb8f6ea86c6bb5f68532"></a><!-- doxytag: member="BaseKvmCPU::startupThread" ref="abc1464ae4d17eb8f6ea86c6bb5f68532" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void startupThread </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Thread-specific initialization.</p>
<p>Some KVM-related initialization requires us to know the TID of the thread that is going to execute our event queue. For example, when setting up timers, we need to know the TID of the thread executing in KVM in order to deliver the timer signal to that thread. This method is called as the first event in this SimObject's event queue.</p>
<dl class="see"><dt><b>参照:</b></dt><dd><a class="el" href="classBaseKvmCPU.html#aecc7d8debf54990ffeaaed5bac7d7d81">startup</a> </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00171"></a>00171 {
<a name="l00172"></a>00172     <span class="comment">// Do thread-specific initialization. We need to setup signal</span>
<a name="l00173"></a>00173     <span class="comment">// delivery for counters and timers from within the thread that</span>
<a name="l00174"></a>00174     <span class="comment">// will execute the event queue to ensure that signals are</span>
<a name="l00175"></a>00175     <span class="comment">// delivered to the right threads.</span>
<a name="l00176"></a>00176     <span class="keyword">const</span> BaseKvmCPUParams * <span class="keyword">const</span> <a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>(
<a name="l00177"></a>00177         dynamic_cast&lt;const BaseKvmCPUParams *&gt;(params()));
<a name="l00178"></a>00178 
<a name="l00179"></a>00179     <a class="code" href="classBaseKvmCPU.html#a8a181f878f7db2579a3a67dd2d8c5902">vcpuThread</a> = pthread_self();
<a name="l00180"></a>00180 
<a name="l00181"></a>00181     <span class="comment">// Setup signal handlers. This has to be done after the vCPU is</span>
<a name="l00182"></a>00182     <span class="comment">// created since it manipulates the vCPU signal mask.</span>
<a name="l00183"></a>00183     <a class="code" href="classBaseKvmCPU.html#acae9fda1e38c2cd8a3d7c8659a4a66fa">setupSignalHandler</a>();
<a name="l00184"></a>00184 
<a name="l00185"></a>00185     <a class="code" href="classBaseKvmCPU.html#a9a2709df130ee7a63e53f9d65a0ebb36">setupCounters</a>();
<a name="l00186"></a>00186 
<a name="l00187"></a>00187     <span class="keywordflow">if</span> (<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;usePerfOverflow)
<a name="l00188"></a>00188         <a class="code" href="classBaseKvmCPU.html#a28c546a9aa908313559ed074632a0c37">runTimer</a>.reset(<span class="keyword">new</span> <a class="code" href="classPerfKvmTimer.html">PerfKvmTimer</a>(<a class="code" href="classBaseKvmCPU.html#a496c1c0ab30aeafdeeeede34db1edf45">hwCycles</a>,
<a name="l00189"></a>00189                                         <a class="code" href="cpu_2kvm_2base_8hh.html#a7aba22a2f8cca986ad7802c54c654847">KVM_KICK_SIGNAL</a>,
<a name="l00190"></a>00190                                         <a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;hostFactor,
<a name="l00191"></a>00191                                         <a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;hostFreq));
<a name="l00192"></a>00192     <span class="keywordflow">else</span>
<a name="l00193"></a>00193         <a class="code" href="classBaseKvmCPU.html#a28c546a9aa908313559ed074632a0c37">runTimer</a>.reset(<span class="keyword">new</span> <a class="code" href="classPosixKvmTimer.html">PosixKvmTimer</a>(<a class="code" href="cpu_2kvm_2base_8hh.html#a7aba22a2f8cca986ad7802c54c654847">KVM_KICK_SIGNAL</a>, CLOCK_MONOTONIC,
<a name="l00194"></a>00194                                          <a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;hostFactor,
<a name="l00195"></a>00195                                          <a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;hostFreq));
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1dad4c4d2c3df4ef367e14fcc973ce74"></a><!-- doxytag: member="BaseKvmCPU::suspendContext" ref="a1dad4c4d2c3df4ef367e14fcc973ce74" args="(ThreadID thread_num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void suspendContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a>&nbsp;</td>
          <td class="paramname"> <em>thread_num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00452"></a>00452 {
<a name="l00453"></a>00453     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classKvm.html">Kvm</a>, <span class="stringliteral">&quot;SuspendContext %d\n&quot;</span>, thread_num);
<a name="l00454"></a>00454 
<a name="l00455"></a>00455     assert(thread_num == 0);
<a name="l00456"></a>00456     assert(<a class="code" href="classBaseKvmCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>);
<a name="l00457"></a>00457 
<a name="l00458"></a>00458     <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> == <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>)
<a name="l00459"></a>00459         <span class="keywordflow">return</span>;
<a name="l00460"></a>00460 
<a name="l00461"></a>00461     assert(<a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> == <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb">Running</a>);
<a name="l00462"></a>00462 
<a name="l00463"></a>00463     <span class="comment">// The tick event may no be scheduled if the quest has requested</span>
<a name="l00464"></a>00464     <span class="comment">// the monitor to wait for interrupts. The normal CPU models can</span>
<a name="l00465"></a>00465     <span class="comment">// get their tick events descheduled by quiesce instructions, but</span>
<a name="l00466"></a>00466     <span class="comment">// that can&apos;t happen here.</span>
<a name="l00467"></a>00467     <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>.<a class="code" href="classEvent.html#a9cd69a6b10cb037550943f177a0da688" title="Determine if the current event is scheduled.">scheduled</a>())
<a name="l00468"></a>00468         deschedule(<a class="code" href="classBaseKvmCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>);
<a name="l00469"></a>00469 
<a name="l00470"></a>00470     <a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> = <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>;
<a name="l00471"></a>00471 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a05f299b443f8cc73a93d61572edc0218"></a><!-- doxytag: member="BaseKvmCPU::switchOut" ref="a05f299b443f8cc73a93d61572edc0218" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void switchOut </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00371"></a>00371 {
<a name="l00372"></a>00372     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classKvm.html">Kvm</a>, <span class="stringliteral">&quot;switchOut\n&quot;</span>);
<a name="l00373"></a>00373 
<a name="l00374"></a>00374     <a class="code" href="classBaseKvmCPU.html#a05f299b443f8cc73a93d61572edc0218">BaseCPU::switchOut</a>();
<a name="l00375"></a>00375 
<a name="l00376"></a>00376     <span class="comment">// We should have drained prior to executing a switchOut, which</span>
<a name="l00377"></a>00377     <span class="comment">// means that the tick event shouldn&apos;t be scheduled and the CPU is</span>
<a name="l00378"></a>00378     <span class="comment">// idle.</span>
<a name="l00379"></a>00379     assert(!<a class="code" href="classBaseKvmCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>.<a class="code" href="classEvent.html#a9cd69a6b10cb037550943f177a0da688" title="Determine if the current event is scheduled.">scheduled</a>());
<a name="l00380"></a>00380     assert(<a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> == <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>);
<a name="l00381"></a>00381 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8633407bfc3732fef1f78ef60345873d"></a><!-- doxytag: member="BaseKvmCPU::syncKvmState" ref="a8633407bfc3732fef1f78ef60345873d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void syncKvmState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update the KVM if the thread context is dirty. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00861"></a>00861 {
<a name="l00862"></a>00862     <span class="keywordflow">if</span> (!<a class="code" href="classBaseKvmCPU.html#a8d712456c8dd8a9842aa40a69dbc27dd">threadContextDirty</a>)
<a name="l00863"></a>00863         <span class="keywordflow">return</span>;
<a name="l00864"></a>00864 
<a name="l00865"></a>00865     assert(!<a class="code" href="classBaseKvmCPU.html#a32fdccc14987171c2381947096c363f1">kvmStateDirty</a>);
<a name="l00866"></a>00866 
<a name="l00867"></a>00867     <a class="code" href="classBaseKvmCPU.html#a48817be7bf03ef44cc5114ecf4df9b27">updateKvmState</a>();
<a name="l00868"></a>00868     <a class="code" href="classBaseKvmCPU.html#a8d712456c8dd8a9842aa40a69dbc27dd">threadContextDirty</a> = <span class="keyword">false</span>;
<a name="l00869"></a>00869 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5d4ee3823af24f9210efb370a4c8ce93"></a><!-- doxytag: member="BaseKvmCPU::syncThreadContext" ref="a5d4ee3823af24f9210efb370a4c8ce93" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void syncThreadContext </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update a thread context if the KVM state is dirty with respect to the cached thread context. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00849"></a>00849 {
<a name="l00850"></a>00850     <span class="keywordflow">if</span> (!<a class="code" href="classBaseKvmCPU.html#a32fdccc14987171c2381947096c363f1">kvmStateDirty</a>)
<a name="l00851"></a>00851         <span class="keywordflow">return</span>;
<a name="l00852"></a>00852 
<a name="l00853"></a>00853     assert(!<a class="code" href="classBaseKvmCPU.html#a8d712456c8dd8a9842aa40a69dbc27dd">threadContextDirty</a>);
<a name="l00854"></a>00854 
<a name="l00855"></a>00855     <a class="code" href="classBaseKvmCPU.html#ac47bfb587580ca76050e0c9bc753c10d">updateThreadContext</a>();
<a name="l00856"></a>00856     <a class="code" href="classBaseKvmCPU.html#a32fdccc14987171c2381947096c363f1">kvmStateDirty</a> = <span class="keyword">false</span>;
<a name="l00857"></a>00857 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6ab19fbe58a682743f9e652e9777fdac"></a><!-- doxytag: member="BaseKvmCPU::takeOverFrom" ref="a6ab19fbe58a682743f9e652e9777fdac" args="(BaseCPU *cpu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void takeOverFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBaseCPU_1_1BaseCPU.html">BaseCPU</a> *&nbsp;</td>
          <td class="paramname"> <em>cpu</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a873dd91783f9efb4a590aded1f70d6b0"></a><!-- doxytag: member="BaseKvmCPU::tick" ref="a873dd91783f9efb4a590aded1f70d6b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tick </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Execute the CPU until the next event in the main event queue or until the guest needs service from gem5. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00517"></a>00517 {
<a name="l00518"></a>00518     <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> delay(0);
<a name="l00519"></a>00519     assert(<a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> != <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>);
<a name="l00520"></a>00520 
<a name="l00521"></a>00521     <span class="keywordflow">switch</span> (<a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a>) {
<a name="l00522"></a>00522       <span class="keywordflow">case</span> <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba30f0df86d1d54bb5ea7ee293977f73df">RunningService</a>:
<a name="l00523"></a>00523         <span class="comment">// handleKvmExit() will determine the next state of the CPU</span>
<a name="l00524"></a>00524         delay = <a class="code" href="classBaseKvmCPU.html#ab7dc26d4e02dbccc343942dd7a3ed7d8">handleKvmExit</a>();
<a name="l00525"></a>00525 
<a name="l00526"></a>00526         <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#a250ca18dfc0316e340eaa2ec45d73c3e">tryDrain</a>())
<a name="l00527"></a>00527             <a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> = <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>;
<a name="l00528"></a>00528         <span class="keywordflow">break</span>;
<a name="l00529"></a>00529 
<a name="l00530"></a>00530       <span class="keywordflow">case</span> <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba8d38f5f3c8c186646364b893e12e6ae0">RunningServiceCompletion</a>:
<a name="l00531"></a>00531       <span class="keywordflow">case</span> <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb">Running</a>: {
<a name="l00532"></a>00532           <a class="code" href="classEventQueue.html">EventQueue</a> *<a class="code" href="namespaceArmISA.html#a853401ad1c480843ad53caaa0198fd05">q</a> = <a class="code" href="eventq_8hh.html#a64a8603a1af7020a19d30c54152fdcb2">curEventQueue</a>();
<a name="l00533"></a>00533           <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> ticksToExecute(q-&gt;<a class="code" href="classEventQueue.html#ac7fc06f25478db3060a43a096e023243">nextTick</a>() - <a class="code" href="statistics_8hh.html#a7acdccbf0d35ce0c159c0cdd36371b22" title="The universal simulation clock.">curTick</a>());
<a name="l00534"></a>00534 
<a name="l00535"></a>00535           <span class="comment">// We might need to update the KVM state.</span>
<a name="l00536"></a>00536           <a class="code" href="classBaseKvmCPU.html#a8633407bfc3732fef1f78ef60345873d">syncKvmState</a>();
<a name="l00537"></a>00537 
<a name="l00538"></a>00538           <span class="comment">// Setup any pending instruction count breakpoints using</span>
<a name="l00539"></a>00539           <span class="comment">// PerfEvent.</span>
<a name="l00540"></a>00540           <a class="code" href="classBaseKvmCPU.html#a10bd071dda7c87970b3595b2d3c5408e">setupInstStop</a>();
<a name="l00541"></a>00541 
<a name="l00542"></a>00542           <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmRun, <span class="stringliteral">&quot;Entering KVM...\n&quot;</span>);
<a name="l00543"></a>00543           <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a>) {
<a name="l00544"></a>00544               <span class="comment">// Force an immediate exit from KVM after completing</span>
<a name="l00545"></a>00545               <span class="comment">// pending operations. The architecture-specific code</span>
<a name="l00546"></a>00546               <span class="comment">// takes care to run until it is in a state where it can</span>
<a name="l00547"></a>00547               <span class="comment">// safely be drained.</span>
<a name="l00548"></a>00548               delay = <a class="code" href="classBaseKvmCPU.html#a405afc17ad0dee3b816012ce909b2b6f">kvmRunDrain</a>();
<a name="l00549"></a>00549           } <span class="keywordflow">else</span> {
<a name="l00550"></a>00550               delay = <a class="code" href="classBaseKvmCPU.html#aed3dbd0c0bf26d82ee56367a3f350506">kvmRun</a>(ticksToExecute);
<a name="l00551"></a>00551           }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553           <span class="comment">// The CPU might have been suspended before entering into</span>
<a name="l00554"></a>00554           <span class="comment">// KVM. Assume that the CPU was suspended /before/ entering</span>
<a name="l00555"></a>00555           <span class="comment">// into KVM and skip the exit handling.</span>
<a name="l00556"></a>00556           <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> == <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>)
<a name="l00557"></a>00557               <span class="keywordflow">break</span>;
<a name="l00558"></a>00558 
<a name="l00559"></a>00559           <span class="comment">// Entering into KVM implies that we&apos;ll have to reload the thread</span>
<a name="l00560"></a>00560           <span class="comment">// context from KVM if we want to access it. Flag the KVM state as</span>
<a name="l00561"></a>00561           <span class="comment">// dirty with respect to the cached thread context.</span>
<a name="l00562"></a>00562           <a class="code" href="classBaseKvmCPU.html#a32fdccc14987171c2381947096c363f1">kvmStateDirty</a> = <span class="keyword">true</span>;
<a name="l00563"></a>00563 
<a name="l00564"></a>00564           <span class="comment">// Enter into the RunningService state unless the</span>
<a name="l00565"></a>00565           <span class="comment">// simulation was stopped by a timer.</span>
<a name="l00566"></a>00566           <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a>-&gt;exit_reason !=  KVM_EXIT_INTR) {
<a name="l00567"></a>00567               <a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> = <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba30f0df86d1d54bb5ea7ee293977f73df">RunningService</a>;
<a name="l00568"></a>00568           } <span class="keywordflow">else</span> {
<a name="l00569"></a>00569               ++<a class="code" href="classBaseKvmCPU.html#a6cdcd551476b4e8234d5bfd987218d88">numExitSignal</a>;
<a name="l00570"></a>00570               <a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> = <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb">Running</a>;
<a name="l00571"></a>00571           }
<a name="l00572"></a>00572 
<a name="l00573"></a>00573           <span class="comment">// Service any pending instruction events. The vCPU should</span>
<a name="l00574"></a>00574           <span class="comment">// have exited in time for the event using the instruction</span>
<a name="l00575"></a>00575           <span class="comment">// counter configured by setupInstStop().</span>
<a name="l00576"></a>00576           comInstEventQueue[0]-&gt;serviceEvents(<a class="code" href="classBaseKvmCPU.html#a4a8e80967bf91692eb1703752a8203b3">ctrInsts</a>);
<a name="l00577"></a>00577           <a class="code" href="classBaseCPU.html#ab737471139f5a296e5b26e8a0e1b0744" title="initialize section">system</a>-&gt;instEventQueue.serviceEvents(<a class="code" href="classBaseCPU.html#ab737471139f5a296e5b26e8a0e1b0744" title="initialize section">system</a>-&gt;totalNumInsts);
<a name="l00578"></a>00578 
<a name="l00579"></a>00579           <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#a250ca18dfc0316e340eaa2ec45d73c3e">tryDrain</a>())
<a name="l00580"></a>00580               <a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> = <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>;
<a name="l00581"></a>00581       } <span class="keywordflow">break</span>;
<a name="l00582"></a>00582 
<a name="l00583"></a>00583       <span class="keywordflow">default</span>:
<a name="l00584"></a>00584         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;BaseKvmCPU entered tick() in an illegal state (%i)\n&quot;</span>,
<a name="l00585"></a>00585               <a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a>);
<a name="l00586"></a>00586     }
<a name="l00587"></a>00587 
<a name="l00588"></a>00588     <span class="comment">// Schedule a new tick if we are still running</span>
<a name="l00589"></a>00589     <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> != <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>)
<a name="l00590"></a>00590         schedule(<a class="code" href="classBaseKvmCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>, clockEdge(ticksToCycles(delay)));
<a name="l00591"></a>00591 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7e01d94bb5a6e15fa8c94bcdf276115d"></a><!-- doxytag: member="BaseKvmCPU::totalInsts" ref="a7e01d94bb5a6e15fa8c94bcdf276115d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#ae1475755791765b8e6f6a8bb091e273e">Counter</a> totalInsts </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00498"></a>00498 {
<a name="l00499"></a>00499     <span class="keywordflow">return</span> <a class="code" href="classBaseKvmCPU.html#a4a8e80967bf91692eb1703752a8203b3">ctrInsts</a>;
<a name="l00500"></a>00500 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a76fa5df6827aaa8fc26deebad97d9e78"></a><!-- doxytag: member="BaseKvmCPU::totalOps" ref="a76fa5df6827aaa8fc26deebad97d9e78" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#ae1475755791765b8e6f6a8bb091e273e">Counter</a> totalOps </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00504"></a>00504 {
<a name="l00505"></a>00505     <a class="code" href="base_2misc_8hh.html#ae2881bab26c1d2bf4a411f8b1fb7e574">hack_once</a>(<span class="stringliteral">&quot;Pretending totalOps is equivalent to totalInsts()\n&quot;</span>);
<a name="l00506"></a>00506     <span class="keywordflow">return</span> <a class="code" href="classBaseKvmCPU.html#a4a8e80967bf91692eb1703752a8203b3">ctrInsts</a>;
<a name="l00507"></a>00507 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a250ca18dfc0316e340eaa2ec45d73c3e"></a><!-- doxytag: member="BaseKvmCPU::tryDrain" ref="a250ca18dfc0316e340eaa2ec45d73c3e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tryDrain </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Try to drain the CPU if a drain is pending </p>

<p><div class="fragment"><pre class="fragment"><a name="l01187"></a>01187 {
<a name="l01188"></a>01188     <span class="keywordflow">if</span> (!<a class="code" href="classBaseKvmCPU.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a>)
<a name="l01189"></a>01189         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01190"></a>01190 
<a name="l01191"></a>01191     <span class="keywordflow">if</span> (!<a class="code" href="classBaseKvmCPU.html#a4ee4cbdc5d3315fd8016b44d3e77abd5">archIsDrained</a>()) {
<a name="l01192"></a>01192         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;tryDrain: Architecture code is not ready.\n&quot;</span>);
<a name="l01193"></a>01193         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01194"></a>01194     }
<a name="l01195"></a>01195 
<a name="l01196"></a>01196     <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> == <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a> || <a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> == <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb">Running</a>) {
<a name="l01197"></a>01197         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain,
<a name="l01198"></a>01198                 <span class="stringliteral">&quot;tryDrain: CPU transitioned into the Idle state, drain done\n&quot;</span>);
<a name="l01199"></a>01199         <a class="code" href="classBaseKvmCPU.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a>-&gt;<a class="code" href="classDrainManager.html#ab89d10e368d2e82061eddb9e40022382">signalDrainDone</a>();
<a name="l01200"></a>01200         <a class="code" href="classBaseKvmCPU.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a> = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l01201"></a>01201         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01202"></a>01202     } <span class="keywordflow">else</span> {
<a name="l01203"></a>01203         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;tryDrain: CPU not ready.\n&quot;</span>);
<a name="l01204"></a>01204         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01205"></a>01205     }
<a name="l01206"></a>01206 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5122e6d6fdbdb3cb9ba72ae970f00a9e"></a><!-- doxytag: member="BaseKvmCPU::unserializeThread" ref="a5122e6d6fdbdb3cb9ba72ae970f00a9e" args="(Checkpoint *cp, const std::string &amp;section, ThreadID tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unserializeThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCheckpoint.html">Checkpoint</a> *&nbsp;</td>
          <td class="paramname"> <em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a>&nbsp;</td>
          <td class="paramname"> <em>tid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00273"></a>00273 {
<a name="l00274"></a>00274     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classCheckpoint.html">Checkpoint</a>, <span class="stringliteral">&quot;KVM: Unserialize thread %i:\n&quot;</span>, tid);
<a name="l00275"></a>00275 
<a name="l00276"></a>00276     assert(tid == 0);
<a name="l00277"></a>00277     assert(<a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> == <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>);
<a name="l00278"></a>00278     <a class="code" href="classBaseKvmCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#af22e5d6d660b97db37003ac61ac4ee49">unserialize</a>(cp, section);
<a name="l00279"></a>00279     <a class="code" href="classBaseKvmCPU.html#a8d712456c8dd8a9842aa40a69dbc27dd">threadContextDirty</a> = <span class="keyword">true</span>;
<a name="l00280"></a>00280 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a48817be7bf03ef44cc5114ecf4df9b27"></a><!-- doxytag: member="BaseKvmCPU::updateKvmState" ref="a48817be7bf03ef44cc5114ecf4df9b27" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void updateKvmState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update the KVM state from the current thread context</p>
<p>The base CPU calls this method before starting the guest CPU when the contextDirty flag is set. The architecture dependent CPU implementation is expected to update all guest state (registers, special registers, and FPU state). </p>

<p><a class="el" href="classArmKvmCPU.html#a93c6e8c82dfb63c7039f0cbf064fae5d">ArmKvmCPU</a>, と <a class="el" href="classX86KvmCPU.html#a93c6e8c82dfb63c7039f0cbf064fae5d">X86KvmCPU</a>で実装されています。</p>

</div>
</div>
<a class="anchor" id="ac47bfb587580ca76050e0c9bc753c10d"></a><!-- doxytag: member="BaseKvmCPU::updateThreadContext" ref="ac47bfb587580ca76050e0c9bc753c10d" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void updateThreadContext </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update the current thread context with the KVM state</p>
<p>The base CPU after the guest updates any of the KVM state. In practice, this happens after kvmRun is called. The architecture dependent code is expected to read the state of the guest CPU and update gem5's thread state. </p>

<p><a class="el" href="classArmKvmCPU.html#adbd5e38eae7c8c3021f2c4f430b399fd">ArmKvmCPU</a>, と <a class="el" href="classX86KvmCPU.html#adbd5e38eae7c8c3021f2c4f430b399fd">X86KvmCPU</a>で実装されています。</p>

</div>
</div>
<a class="anchor" id="ae2e1ccebe596a180f8105d57f9a93645"></a><!-- doxytag: member="BaseKvmCPU::verifyMemoryMode" ref="ae2e1ccebe596a180f8105d57f9a93645" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void verifyMemoryMode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00407"></a>00407 {
<a name="l00408"></a>00408     <span class="keywordflow">if</span> (!(<a class="code" href="classBaseCPU.html#ab737471139f5a296e5b26e8a0e1b0744" title="initialize section">system</a>-&gt;isAtomicMode() &amp;&amp; <a class="code" href="classBaseCPU.html#ab737471139f5a296e5b26e8a0e1b0744" title="initialize section">system</a>-&gt;bypassCaches())) {
<a name="l00409"></a>00409         <a class="code" href="base_2misc_8hh.html#acad519418dbfdd70c1208711e609c80e">fatal</a>(<span class="stringliteral">&quot;The KVM-based CPUs requires the memory system to be in the &quot;</span>
<a name="l00410"></a>00410               <span class="stringliteral">&quot;&apos;atomic_noncaching&apos; mode.\n&quot;</span>);
<a name="l00411"></a>00411     }
<a name="l00412"></a>00412 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae674290a26ecbd622c5160e38e8a4fe9"></a><!-- doxytag: member="BaseKvmCPU::wakeup" ref="ae674290a26ecbd622c5160e38e8a4fe9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wakeup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classBaseCPU.html#a75101f8aee74078c8c3c1d1f3617f7cc">BaseCPU</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00416"></a>00416 {
<a name="l00417"></a>00417     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classKvm.html">Kvm</a>, <span class="stringliteral">&quot;wakeup()\n&quot;</span>);
<a name="l00418"></a>00418     <span class="comment">// This method might have been called from another</span>
<a name="l00419"></a>00419     <span class="comment">// context. Migrate to this SimObject&apos;s event queue when</span>
<a name="l00420"></a>00420     <span class="comment">// delivering the wakeup signal.</span>
<a name="l00421"></a>00421     <a class="code" href="classEventQueue_1_1ScopedMigration.html">EventQueue::ScopedMigration</a> migrate(eventQueue());
<a name="l00422"></a>00422 
<a name="l00423"></a>00423     <span class="comment">// Kick the vCPU to get it to come out of KVM.</span>
<a name="l00424"></a>00424     <a class="code" href="classBaseKvmCPU.html#ae984a01dc23c52800f5fe28344f59b81">kick</a>();
<a name="l00425"></a>00425 
<a name="l00426"></a>00426     <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a2ad9e92a82d6f783b3061584729c2f4a">status</a>() != <a class="code" href="classThreadContext.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba13bd6ff4bd5714ccc293f6802aacb40d">ThreadContext::Suspended</a>)
<a name="l00427"></a>00427         <span class="keywordflow">return</span>;
<a name="l00428"></a>00428 
<a name="l00429"></a>00429     <a class="code" href="classBaseKvmCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#ab542a5cf9ce4b41042d61e42dfe3aeab">activate</a>();
<a name="l00430"></a>00430 }
</pre></div></p>

</div>
</div>
<hr/><h2>変数</h2>
<a class="anchor" id="ab174cc060c981cfd21406dc3797c8c6b"></a><!-- doxytag: member="BaseKvmCPU::_kvmRun" ref="ab174cc060c981cfd21406dc3797c8c6b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct kvm_run* <a class="el" href="classBaseKvmCPU.html#ab174cc060c981cfd21406dc3797c8c6b">_kvmRun</a><code> [read, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer to the kvm_run structure used to communicate parameters with KVM.</p>
<dl class="note"><dt><b>覚え書き:</b></dt><dd>This is the base pointer of the MMAPed KVM region. The first page contains the kvm_run structure. Subsequent pages may contain other data such as the MMIO ring buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a6cdf6e6db875a442f3ab6db542bd2bb5"></a><!-- doxytag: member="BaseKvmCPU::_status" ref="a6cdf6e6db875a442f3ab6db542bd2bb5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70b">Status</a> <a class="el" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>CPU run state </p>

</div>
</div>
<a class="anchor" id="a9b8c93980540464141f0989b8258295b"></a><!-- doxytag: member="BaseKvmCPU::activeInstPeriod" ref="a9b8c93980540464141f0989b8258295b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classBaseKvmCPU.html#a9b8c93980540464141f0989b8258295b">activeInstPeriod</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Currently active instruction count breakpoint </p>

</div>
</div>
<a class="anchor" id="a4a8e80967bf91692eb1703752a8203b3"></a><!-- doxytag: member="BaseKvmCPU::ctrInsts" ref="a4a8e80967bf91692eb1703752a8203b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#ae1475755791765b8e6f6a8bb091e273e">Counter</a> <a class="el" href="classBaseKvmCPU.html#a4a8e80967bf91692eb1703752a8203b3">ctrInsts</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number of instructions executed by the CPU </p>

</div>
</div>
<a class="anchor" id="a3f709bd88ed61bca6788f8cc3cda97cb"></a><!-- doxytag: member="BaseKvmCPU::dataPort" ref="a3f709bd88ed61bca6788f8cc3cda97cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBaseKvmCPU_1_1KVMCpuPort.html">KVMCpuPort</a> <a class="el" href="classBaseKvmCPU.html#a3f709bd88ed61bca6788f8cc3cda97cb">dataPort</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classPort.html">Port</a> for data requests </p>

</div>
</div>
<a class="anchor" id="a329b71fb934a93312ca0aacbf5a3f982"></a><!-- doxytag: member="BaseKvmCPU::drainManager" ref="a329b71fb934a93312ca0aacbf5a3f982" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDrainManager.html">DrainManager</a>* <a class="el" href="classBaseKvmCPU.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Drain manager to use when signaling drain completion</p>
<p>This pointer is non-NULL when draining and NULL otherwise. </p>

</div>
</div>
<a class="anchor" id="a0ef366aa4bbbcdc2f7eeb7fcd3962dde"></a><!-- doxytag: member="BaseKvmCPU::hostFactor" ref="a0ef366aa4bbbcdc2f7eeb7fcd3962dde" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classBaseKvmCPU.html#a0ef366aa4bbbcdc2f7eeb7fcd3962dde">hostFactor</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Host factor as specified in the configuration </p>

</div>
</div>
<a class="anchor" id="a496c1c0ab30aeafdeeeede34db1edf45"></a><!-- doxytag: member="BaseKvmCPU::hwCycles" ref="a496c1c0ab30aeafdeeeede34db1edf45" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPerfKvmCounter.html">PerfKvmCounter</a> <a class="el" href="classBaseKvmCPU.html#a496c1c0ab30aeafdeeeede34db1edf45">hwCycles</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Guest cycle counter.</p>
<p>This is the group leader of all performance counters measuring the guest system. It can be used in conjunction with the <a class="el" href="classPerfKvmTimer.html">PerfKvmTimer</a> (see perfControlledByTimer) to trigger exits from KVM. </p>

</div>
</div>
<a class="anchor" id="ab3360069d449c748e7b9efe5f6d427e9"></a><!-- doxytag: member="BaseKvmCPU::hwInstructions" ref="ab3360069d449c748e7b9efe5f6d427e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPerfKvmCounter.html">PerfKvmCounter</a> <a class="el" href="classBaseKvmCPU.html#ab3360069d449c748e7b9efe5f6d427e9">hwInstructions</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Guest instruction counter.</p>
<p>This counter is typically only used to measure the number of instructions executed by the guest. However, it can also be used to trigger exits from KVM if the configuration script requests an exit after a certain number of instructions.</p>
<dl class="see"><dt><b>参照:</b></dt><dd>setupInstBreak </dd>
<dd>
scheduleInstStop </dd></dl>

</div>
</div>
<a class="anchor" id="a3d1157769fdf1f3b9566f70b9e7c30ea"></a><!-- doxytag: member="BaseKvmCPU::instPort" ref="a3d1157769fdf1f3b9566f70b9e7c30ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBaseKvmCPU_1_1KVMCpuPort.html">KVMCpuPort</a> <a class="el" href="classBaseKvmCPU.html#a3d1157769fdf1f3b9566f70b9e7c30ea">instPort</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unused dummy port for the instruction interface </p>

</div>
</div>
<a class="anchor" id="a32fdccc14987171c2381947096c363f1"></a><!-- doxytag: member="BaseKvmCPU::kvmStateDirty" ref="a32fdccc14987171c2381947096c363f1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBaseKvmCPU.html#a32fdccc14987171c2381947096c363f1">kvmStateDirty</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Is the KVM state dirty? <a class="el" href="classSet.html">Set</a> to true to force an update of the KVM vCPU state upon the next call to <a class="el" href="classBaseKvmCPU.html#aed3dbd0c0bf26d82ee56367a3f350506">kvmRun()</a>. </p>

</div>
</div>
<a class="anchor" id="a22caf021a7ece8d92e5ab612191b1b57"></a><!-- doxytag: member="BaseKvmCPU::mmio_req" ref="a22caf021a7ece8d92e5ab612191b1b57" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRequest.html">Request</a> <a class="el" href="classBaseKvmCPU.html#a22caf021a7ece8d92e5ab612191b1b57">mmio_req</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pre-allocated MMIO memory request </p>

</div>
</div>
<a class="anchor" id="ad4e1bcd3f032d2921aa97aec1fc7a45c"></a><!-- doxytag: member="BaseKvmCPU::mmioRing" ref="ad4e1bcd3f032d2921aa97aec1fc7a45c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct kvm_coalesced_mmio_ring* <a class="el" href="classBaseKvmCPU.html#ad4e1bcd3f032d2921aa97aec1fc7a45c">mmioRing</a><code> [read, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Coalesced MMIO ring buffer. NULL if coalesced MMIO is not supported. </p>

</div>
</div>
<a class="anchor" id="a99a92abe3f29c3d0f59af4e384a8fe7f"></a><!-- doxytag: member="BaseKvmCPU::numCoalescedMMIO" ref="a99a92abe3f29c3d0f59af4e384a8fe7f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classBaseKvmCPU.html#a99a92abe3f29c3d0f59af4e384a8fe7f">numCoalescedMMIO</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6cdcd551476b4e8234d5bfd987218d88"></a><!-- doxytag: member="BaseKvmCPU::numExitSignal" ref="a6cdcd551476b4e8234d5bfd987218d88" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classBaseKvmCPU.html#a6cdcd551476b4e8234d5bfd987218d88">numExitSignal</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a65e906b9e123036deb6bc8922ce53e96"></a><!-- doxytag: member="BaseKvmCPU::numHalt" ref="a65e906b9e123036deb6bc8922ce53e96" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classBaseKvmCPU.html#a65e906b9e123036deb6bc8922ce53e96">numHalt</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a230908c23db440bfcee954fb8d72f269"></a><!-- doxytag: member="BaseKvmCPU::numHypercalls" ref="a230908c23db440bfcee954fb8d72f269" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classBaseKvmCPU.html#a230908c23db440bfcee954fb8d72f269">numHypercalls</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a302bf9a6fd3b54c46eb3e2bfb18a320e"></a><!-- doxytag: member="BaseKvmCPU::numInsts" ref="a302bf9a6fd3b54c46eb3e2bfb18a320e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classBaseKvmCPU.html#a302bf9a6fd3b54c46eb3e2bfb18a320e">numInsts</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ff214621d200e4672d581b12832886a"></a><!-- doxytag: member="BaseKvmCPU::numInterrupts" ref="a5ff214621d200e4672d581b12832886a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classBaseKvmCPU.html#a5ff214621d200e4672d581b12832886a">numInterrupts</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae3a09de1034e0294f5df0ce66d876727"></a><!-- doxytag: member="BaseKvmCPU::numIO" ref="ae3a09de1034e0294f5df0ce66d876727" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classBaseKvmCPU.html#ae3a09de1034e0294f5df0ce66d876727">numIO</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4030a87068a8b133f5efabfc19f7542d"></a><!-- doxytag: member="BaseKvmCPU::numMMIO" ref="a4030a87068a8b133f5efabfc19f7542d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classBaseKvmCPU.html#a4030a87068a8b133f5efabfc19f7542d">numMMIO</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6184fcde9e075404315cd7c343054d30"></a><!-- doxytag: member="BaseKvmCPU::numVMExits" ref="a6184fcde9e075404315cd7c343054d30" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classBaseKvmCPU.html#a6184fcde9e075404315cd7c343054d30">numVMExits</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8ef83ba51e6ab5f5db813c16e3cebb1d"></a><!-- doxytag: member="BaseKvmCPU::numVMHalfEntries" ref="a8ef83ba51e6ab5f5db813c16e3cebb1d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classBaseKvmCPU.html#a8ef83ba51e6ab5f5db813c16e3cebb1d">numVMHalfEntries</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8386a4766759aabc32038300820a64aa"></a><!-- doxytag: member="BaseKvmCPU::pageSize" ref="a8386a4766759aabc32038300820a64aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const long <a class="el" href="classBaseKvmCPU.html#a8386a4766759aabc32038300820a64aa">pageSize</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cached page size of the host </p>

</div>
</div>
<a class="anchor" id="a569365e1361250361be1c3f703a52914"></a><!-- doxytag: member="BaseKvmCPU::perfControlledByTimer" ref="a569365e1361250361be1c3f703a52914" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBaseKvmCPU.html#a569365e1361250361be1c3f703a52914">perfControlledByTimer</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Does the runTimer control the performance counters?</p>
<p>The run timer will automatically enable and disable performance counters if a PerfEvent-based timer is used to control KVM exits. </p>

</div>
</div>
<a class="anchor" id="a28c546a9aa908313559ed074632a0c37"></a><!-- doxytag: member="BaseKvmCPU::runTimer" ref="a28c546a9aa908313559ed074632a0c37" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classBaseKvmTimer.html">BaseKvmTimer</a>&gt; <a class="el" href="classBaseKvmCPU.html#a28c546a9aa908313559ed074632a0c37">runTimer</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Timer used to force execution into the monitor after a specified number of simulation tick equivalents have executed in the guest. This counter generates the signal specified by KVM_TIMER_SIGNAL. </p>

</div>
</div>
<a class="anchor" id="a4455a4759e69e5ebe68ae7298cbcc37d"></a><!-- doxytag: member="BaseKvmCPU::tc" ref="a4455a4759e69e5ebe68ae7298cbcc37d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreadContext.html">ThreadContext</a>* <a class="el" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classThreadContext.html">ThreadContext</a> object, provides an interface for external objects to modify this thread's state. </p>

</div>
</div>
<a class="anchor" id="af9572fa907cd21b54cb14bd626010d39"></a><!-- doxytag: member="BaseKvmCPU::thread" ref="af9572fa907cd21b54cb14bd626010d39" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleThread.html">SimpleThread</a>* <a class="el" href="classBaseKvmCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A cached copy of a thread's state in the form of a <a class="el" href="classSimpleThread.html">SimpleThread</a> object.</p>
<p>Normally the actual thread state is stored in the KVM vCPU. If KVM has been running this copy is will be out of date. If we recently handled some events within gem5 that required state to be updated this could be the most up-to-date copy. When <a class="el" href="classBaseKvmCPU.html#a2199ea70043ddde97c86e49a656b7ba9">getContext()</a> or <a class="el" href="classBaseKvmCPU.html#ac47bfb587580ca76050e0c9bc753c10d">updateThreadContext()</a> is called this copy gets updated. The method syncThreadContext can be used within a KVM CPU to update the thread context if the KVM state is dirty (i.e., the vCPU has been run since the last update). </p>

</div>
</div>
<a class="anchor" id="a8d712456c8dd8a9842aa40a69dbc27dd"></a><!-- doxytag: member="BaseKvmCPU::threadContextDirty" ref="a8d712456c8dd8a9842aa40a69dbc27dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBaseKvmCPU.html#a8d712456c8dd8a9842aa40a69dbc27dd">threadContextDirty</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Is the gem5 context dirty? <a class="el" href="classSet.html">Set</a> to true to force an update of the KVM vCPU state upon the next call to <a class="el" href="classBaseKvmCPU.html#aed3dbd0c0bf26d82ee56367a3f350506">kvmRun()</a>. </p>

</div>
</div>
<a class="anchor" id="aa36b8e894416f0ec98f701ab08f2ac22"></a><!-- doxytag: member="BaseKvmCPU::tickEvent" ref="aa36b8e894416f0ec98f701ab08f2ac22" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBaseKvmCPU_1_1TickEvent.html">TickEvent</a> <a class="el" href="classBaseKvmCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6b91f8b5649b80e8424cebfa3047e1d0"></a><!-- doxytag: member="BaseKvmCPU::vcpuFD" ref="a6b91f8b5649b80e8424cebfa3047e1d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classBaseKvmCPU.html#a6b91f8b5649b80e8424cebfa3047e1d0">vcpuFD</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>KVM vCPU file descriptor </p>

</div>
</div>
<a class="anchor" id="ac52bdf6886dcfd53068633de9ed83184"></a><!-- doxytag: member="BaseKvmCPU::vcpuID" ref="ac52bdf6886dcfd53068633de9ed83184" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const long <a class="el" href="classBaseKvmCPU.html#ac52bdf6886dcfd53068633de9ed83184">vcpuID</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>KVM internal ID of the vCPU </p>

</div>
</div>
<a class="anchor" id="a0915679bdc25b2c015f15996f6d4ff6d"></a><!-- doxytag: member="BaseKvmCPU::vcpuMMapSize" ref="a0915679bdc25b2c015f15996f6d4ff6d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classBaseKvmCPU.html#a0915679bdc25b2c015f15996f6d4ff6d">vcpuMMapSize</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Size of MMAPed kvm_run area </p>

</div>
</div>
<a class="anchor" id="a8a181f878f7db2579a3a67dd2d8c5902"></a><!-- doxytag: member="BaseKvmCPU::vcpuThread" ref="a8a181f878f7db2579a3a67dd2d8c5902" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_t <a class="el" href="classBaseKvmCPU.html#a8a181f878f7db2579a3a67dd2d8c5902">vcpuThread</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ID of the vCPU thread </p>

</div>
</div>
<a class="anchor" id="a6b8ecd9ec419f0cbe3c1047be643fe08"></a><!-- doxytag: member="BaseKvmCPU::vm" ref="a6b8ecd9ec419f0cbe3c1047be643fe08" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKvmVM.html">KvmVM</a>&amp; <a class="el" href="classBaseKvmCPU.html#a6b8ecd9ec419f0cbe3c1047be643fe08">vm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>このクラスの説明は次のファイルから生成されました:<ul>
<li>cpu/kvm/<a class="el" href="cpu_2kvm_2base_8hh_source.html">base.hh</a></li>
<li>cpu/kvm/<a class="el" href="cpu_2kvm_2base_8cc.html">base.cc</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>File&nbsp;GEM5&nbsp;Wrapperに対して25 May 2015に生成されました。&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
