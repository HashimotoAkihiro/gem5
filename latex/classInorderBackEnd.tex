\hypertarget{classInorderBackEnd}{
\section{クラス テンプレート InorderBackEnd$<$ Impl $>$}
\label{classInorderBackEnd}\index{InorderBackEnd@{InorderBackEnd}}
}


{\ttfamily \#include $<$inorder\_\-back\_\-end.hh$>$}\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classInorderBackEnd_1_1DCacheCompletionEvent}{DCacheCompletionEvent}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef Impl::Params \hyperlink{classInorderBackEnd_a818e103eae798a24a06a0a34631849ea}{Params}
\item 
typedef Impl::DynInstPtr \hyperlink{classInorderBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}
\item 
typedef Impl::FullCPU \hyperlink{classInorderBackEnd_a90ba84e54618cc07f2e8f05e046cb5ce}{FullCPU}
\item 
typedef Impl::FrontEnd \hyperlink{classInorderBackEnd_abe8e1d8243582d5024a1076f6091d9fe}{FrontEnd}
\item 
typedef FullCPU::OzoneTC \hyperlink{classInorderBackEnd_abb1fee810c0fc9d68df56bdf67688be8}{OzoneTC}
\item 
typedef Impl::FullCPU::CommStruct \hyperlink{classInorderBackEnd_a82fb3c7183ba777a05c510ab2fbcfb82}{CommStruct}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classInorderBackEnd_ae2482e08cc2f4d90269bf53efd5193b7}{InorderBackEnd} (\hyperlink{classInorderBackEnd_a818e103eae798a24a06a0a34631849ea}{Params} $\ast$params)
\item 
std::string \hyperlink{classInorderBackEnd_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classInorderBackEnd_ad491c9766121fc19aa77fd0723e7641d}{setCPU} (\hyperlink{classInorderBackEnd_a90ba84e54618cc07f2e8f05e046cb5ce}{FullCPU} $\ast$cpu\_\-ptr)
\item 
void \hyperlink{classInorderBackEnd_a122009fa2730cee3898ac945227da8eb}{setFrontEnd} (\hyperlink{classFrontEnd}{FrontEnd} $\ast$front\_\-end\_\-ptr)
\item 
void \hyperlink{classInorderBackEnd_aeabdb9f0aae07df67c3029f8fddb2693}{setCommBuffer} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classInorderBackEnd_a82fb3c7183ba777a05c510ab2fbcfb82}{CommStruct} $>$ $\ast$\_\-comm)
\item 
void \hyperlink{classInorderBackEnd_ac6ccaaea6ac518cab92f71723b5a739e}{setTC} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc\_\-ptr)
\item 
void \hyperlink{classInorderBackEnd_a2a6551551e11d9e1947d6805e8322757}{setThreadState} (\hyperlink{structOzoneThreadState}{OzoneThreadState}$<$ Impl $>$ $\ast$thread\_\-ptr)
\item 
void \hyperlink{classInorderBackEnd_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classInorderBackEnd_a53f309de2e633a8788fc67ba03d23675}{checkInterrupts} ()
\item 
void \hyperlink{classInorderBackEnd_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\item 
void \hyperlink{classInorderBackEnd_a2d00e30d66a56e4667e28df302c98ac0}{executeInsts} ()
\item 
void \hyperlink{classInorderBackEnd_aa332542122e7959baf01e00f79e82bba}{squash} (const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&squash\_\-num, const \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \&next\_\-PC)
\item 
void \hyperlink{classInorderBackEnd_a647eb6c891733b0ef3d9233af7f15748}{squashFromXC} ()
\item 
void \hyperlink{classInorderBackEnd_ae4e704602e6cab77b5b96396fee5d104}{generateXCEvent} ()
\item 
bool \hyperlink{classInorderBackEnd_a5c38df1621043861ada4dd0939509869}{robEmpty} ()
\item 
bool \hyperlink{classInorderBackEnd_a3e70330939fdfc4dbc2f60c1a660584d}{isFull} ()
\item 
bool \hyperlink{classInorderBackEnd_ae6ec007d68382eb124ed25bc90ae9c17}{isBlocked} ()
\item 
void \hyperlink{classInorderBackEnd_a71dcc69e5b01fa12b8ccd2dccdcc9917}{fetchFault} (\hyperlink{classRefCountingPtr}{Fault} \&fault)
\item 
void \hyperlink{classInorderBackEnd_a80587b4fe043bbe1995536cb3b361588}{dumpInsts} ()
\item 
{\footnotesize template$<$class T $>$ }\\\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classInorderBackEnd_a54c0093df1bc3e8cd4f00246884389cc}{read} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, T \&data, unsigned flags)
\item 
{\footnotesize template$<$class T $>$ }\\\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classInorderBackEnd_a0747777ac998dabdc20fa0c554d378d3}{read} (\hyperlink{classRequest}{RequestPtr} req, T \&data, int load\_\-idx)
\item 
{\footnotesize template$<$class T $>$ }\\\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classInorderBackEnd_ace3a2a0aed65c3714979fca6f51276f9}{write} (T data, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, unsigned flags, uint64\_\-t $\ast$res)
\item 
{\footnotesize template$<$class T $>$ }\\\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classInorderBackEnd_abbf7bcc93511421a1787650a43e2642a}{write} (\hyperlink{classRequest}{RequestPtr} req, T \&data, int store\_\-idx)
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classInorderBackEnd_aa28f3fe58fde4b038a92b9f87a40cb10}{readCommitPC} ()
\item 
void \hyperlink{classInorderBackEnd_a05f299b443f8cc73a93d61572edc0218}{switchOut} ()
\item 
void \hyperlink{classInorderBackEnd_a039b639c41c289e1cfe6d71c41d9308c}{doSwitchOut} ()
\item 
void \hyperlink{classInorderBackEnd_a5a901e7ec5b94a55bd61fde88ad0b7f1}{takeOverFrom} (\hyperlink{classThreadContext}{ThreadContext} $\ast$old\_\-tc=NULL)
\item 
{\footnotesize template$<$class T $>$ }\\\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classInorderBackEnd_ad2981b6704bca036af0723daaaebe57e}{read} (MemReqPtr \&req, T \&data, int load\_\-idx)
\item 
{\footnotesize template$<$class T $>$ }\\\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classInorderBackEnd_a173162a41482ee35c5a15394b4befa4b}{write} (MemReqPtr \&req, T \&data, int store\_\-idx)
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classInorderBackEnd_af043d6103c5f173871f527899c41d2d2}{commitPC}
\item 
\hyperlink{classInorderBackEnd_a90ba84e54618cc07f2e8f05e046cb5ce}{FullCPU} $\ast$ \hyperlink{classInorderBackEnd_a766385c2941cd46525f4d9dff90200a2}{cpu}
\item 
\hyperlink{classFrontEnd}{FrontEnd} $\ast$ \hyperlink{classInorderBackEnd_a67c762418bb2017cb2dce5a0c94f0788}{frontEnd}
\item 
\hyperlink{classThreadContext}{ThreadContext} $\ast$ \hyperlink{classInorderBackEnd_a4455a4759e69e5ebe68ae7298cbcc37d}{tc}
\item 
\hyperlink{structOzoneThreadState}{OzoneThreadState}$<$ Impl $>$ $\ast$ \hyperlink{classInorderBackEnd_ab6f834310107fd693035eba2eeca583f}{thread}
\item 
\hyperlink{classRenameTable}{RenameTable}$<$ Impl $>$ \hyperlink{classInorderBackEnd_af8d3f859e7c0dd9408ba99de6f415616}{renameTable}
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \{ \par
\hyperlink{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}{Running}, 
\hyperlink{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}{Idle}, 
\hyperlink{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70bad5ccc7221ed484b5a546171f5a52c806}{DcacheMissLoadStall}, 
\hyperlink{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba616b5057fea90109e3c27b633a60b77f}{DcacheMissStoreStall}, 
\par
\hyperlink{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba1eb81f4540c1c4b90839b08ae63c5d7f}{DcacheMissComplete}, 
\hyperlink{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba9463ee9b8700258a1019b4b9d2d77a30}{Blocked}
 \}
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \hyperlink{classInorderBackEnd_ae29aa2d4ae440022daaed1107eb306b3}{status}
\item 
\hyperlink{classInorderBackEnd_1_1DCacheCompletionEvent}{DCacheCompletionEvent} \hyperlink{classInorderBackEnd_a08f9ddeb55a0840fc2f9d8f4c5e7a9fc}{cacheCompletionEvent}
\item 
\hyperlink{classRequest}{RequestPtr} \hyperlink{classInorderBackEnd_a5520eb2f7c2cf4b0e109d6ffd6d2d053}{memReq}
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classInorderBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$::iterator \hyperlink{classInorderBackEnd_a4da46d72d68fcd5bfe65dc701c358379}{InstListIt}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classInorderBackEnd_acd8f81ae1aa6143073f58ab038f684f0}{handleFault} ()
\item 
void \hyperlink{classInorderBackEnd_a9f7604c717497f0c9b7f416b3265e085}{setSquashInfoFromTC} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classInorderBackEnd_a2aafb6fc593b04986eeed845923a8953}{squashPending}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classInorderBackEnd_a34292b1418c46ca63c892e7826510d77}{squashSeqNum}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classInorderBackEnd_aabe0c73b4678ef858d3363c9bed18906}{squashNextPC}
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classInorderBackEnd_a21a86a2f5f30b0f512909bdc8b2aae53}{faultFromFetch}
\item 
bool \hyperlink{classInorderBackEnd_ae2e3d2da6f5c26e7f0eca5784b6397d1}{interruptBlocked}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classInorderBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classInorderBackEnd_ae10a391d02ce1ef67ee13cd82b7d46e5}{instList}
\item 
int \hyperlink{classInorderBackEnd_a2474a5474cbff19523a51eb1de01cda4}{width}
\item 
int \hyperlink{classInorderBackEnd_a9c5bf07170b5d91cfb44d4bfd0517128}{latency}
\item 
int \hyperlink{classInorderBackEnd_a440f8cda1481977c324a827c7c9f1e24}{squashLatency}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ int $>$ \hyperlink{classInorderBackEnd_a34cd6ffaeb59e3f95f2cc2aaf8eb7ecf}{numInstsToWB}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ int $>$::wire \hyperlink{classInorderBackEnd_a3bafa8bcab17d8f51c2b5fdf04679d47}{instsAdded}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ int $>$::wire \hyperlink{classInorderBackEnd_aea4c234514337a9dd2233b49732f6638}{instsToExecute}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classInorderBackEnd_a82fb3c7183ba777a05c510ab2fbcfb82}{CommStruct} $>$ $\ast$ \hyperlink{classInorderBackEnd_a282f2307a986f183b83e887756561687}{comm}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInorderBackEnd_a06d11574ef2a7c403c51d626e834d91e}{dcacheStallCycles}
\item 
\hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classInorderBackEnd_a8b4696062ef09ab956804a7a99491853}{lastDcacheStall}
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classInorderBackEnd_a27227be5511e316f17702a3a99fb0b98}{DCacheCompletionEvent}
\end{DoxyCompactItemize}
\subsubsection*{template$<$class Impl$>$ class InorderBackEnd$<$ Impl $>$}



\subsection{型定義}
\hypertarget{classInorderBackEnd_a82fb3c7183ba777a05c510ab2fbcfb82}{
\index{InorderBackEnd@{InorderBackEnd}!CommStruct@{CommStruct}}
\index{CommStruct@{CommStruct}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{CommStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::FullCPU::CommStruct {\bf CommStruct}}}
\label{classInorderBackEnd_a82fb3c7183ba777a05c510ab2fbcfb82}
\hypertarget{classInorderBackEnd_a028ce10889c5f6450239d9e9a7347976}{
\index{InorderBackEnd@{InorderBackEnd}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInstPtr {\bf DynInstPtr}}}
\label{classInorderBackEnd_a028ce10889c5f6450239d9e9a7347976}
\hypertarget{classInorderBackEnd_abe8e1d8243582d5024a1076f6091d9fe}{
\index{InorderBackEnd@{InorderBackEnd}!FrontEnd@{FrontEnd}}
\index{FrontEnd@{FrontEnd}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{FrontEnd}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::FrontEnd {\bf FrontEnd}}}
\label{classInorderBackEnd_abe8e1d8243582d5024a1076f6091d9fe}
\hypertarget{classInorderBackEnd_a90ba84e54618cc07f2e8f05e046cb5ce}{
\index{InorderBackEnd@{InorderBackEnd}!FullCPU@{FullCPU}}
\index{FullCPU@{FullCPU}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{FullCPU}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::FullCPU {\bf FullCPU}}}
\label{classInorderBackEnd_a90ba84e54618cc07f2e8f05e046cb5ce}
\hypertarget{classInorderBackEnd_a4da46d72d68fcd5bfe65dc701c358379}{
\index{InorderBackEnd@{InorderBackEnd}!InstListIt@{InstListIt}}
\index{InstListIt@{InstListIt}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{InstListIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf DynInstPtr}$>$::iterator {\bf InstListIt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInorderBackEnd_a4da46d72d68fcd5bfe65dc701c358379}
\hypertarget{classInorderBackEnd_abb1fee810c0fc9d68df56bdf67688be8}{
\index{InorderBackEnd@{InorderBackEnd}!OzoneTC@{OzoneTC}}
\index{OzoneTC@{OzoneTC}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{OzoneTC}]{\setlength{\rightskip}{0pt plus 5cm}typedef FullCPU::OzoneTC {\bf OzoneTC}}}
\label{classInorderBackEnd_abb1fee810c0fc9d68df56bdf67688be8}
\hypertarget{classInorderBackEnd_a818e103eae798a24a06a0a34631849ea}{
\index{InorderBackEnd@{InorderBackEnd}!Params@{Params}}
\index{Params@{Params}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::Params {\bf Params}}}
\label{classInorderBackEnd_a818e103eae798a24a06a0a34631849ea}


\subsection{列挙型}
\hypertarget{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}{
\index{InorderBackEnd@{InorderBackEnd}!Status@{Status}}
\index{Status@{Status}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{Status}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Status}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Running@{Running}!InorderBackEnd@{InorderBackEnd}}\index{InorderBackEnd@{InorderBackEnd}!Running@{Running}}\item[{\em 
\hypertarget{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}{
Running}
\label{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}
}]\index{Idle@{Idle}!InorderBackEnd@{InorderBackEnd}}\index{InorderBackEnd@{InorderBackEnd}!Idle@{Idle}}\item[{\em 
\hypertarget{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}{
Idle}
\label{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}
}]\index{DcacheMissLoadStall@{DcacheMissLoadStall}!InorderBackEnd@{InorderBackEnd}}\index{InorderBackEnd@{InorderBackEnd}!DcacheMissLoadStall@{DcacheMissLoadStall}}\item[{\em 
\hypertarget{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70bad5ccc7221ed484b5a546171f5a52c806}{
DcacheMissLoadStall}
\label{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70bad5ccc7221ed484b5a546171f5a52c806}
}]\index{DcacheMissStoreStall@{DcacheMissStoreStall}!InorderBackEnd@{InorderBackEnd}}\index{InorderBackEnd@{InorderBackEnd}!DcacheMissStoreStall@{DcacheMissStoreStall}}\item[{\em 
\hypertarget{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba616b5057fea90109e3c27b633a60b77f}{
DcacheMissStoreStall}
\label{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba616b5057fea90109e3c27b633a60b77f}
}]\index{DcacheMissComplete@{DcacheMissComplete}!InorderBackEnd@{InorderBackEnd}}\index{InorderBackEnd@{InorderBackEnd}!DcacheMissComplete@{DcacheMissComplete}}\item[{\em 
\hypertarget{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba1eb81f4540c1c4b90839b08ae63c5d7f}{
DcacheMissComplete}
\label{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba1eb81f4540c1c4b90839b08ae63c5d7f}
}]\index{Blocked@{Blocked}!InorderBackEnd@{InorderBackEnd}}\index{InorderBackEnd@{InorderBackEnd}!Blocked@{Blocked}}\item[{\em 
\hypertarget{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba9463ee9b8700258a1019b4b9d2d77a30}{
Blocked}
\label{classInorderBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba9463ee9b8700258a1019b4b9d2d77a30}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
142                 {
143         Running,
144         Idle,
145         DcacheMissLoadStall,
146         DcacheMissStoreStall,
147         DcacheMissComplete,
148         Blocked
149     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classInorderBackEnd_ae2482e08cc2f4d90269bf53efd5193b7}{
\index{InorderBackEnd@{InorderBackEnd}!InorderBackEnd@{InorderBackEnd}}
\index{InorderBackEnd@{InorderBackEnd}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{InorderBackEnd}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InorderBackEnd} ({\bf Params} $\ast$ {\em params})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_ae2482e08cc2f4d90269bf53efd5193b7}



\begin{DoxyCode}
42     : squashPending(false),
43       squashSeqNum(0),
44       squashNextPC(0),
45       faultFromFetch(NoFault),
46       interruptBlocked(false),
47       cacheCompletionEvent(this),
48       dcacheInterface(params->dcacheInterface),
49       width(params->backEndWidth),
50       latency(params->backEndLatency),
51       squashLatency(params->backEndSquashLatency),
52       numInstsToWB(0, latency + 1)
53 {
54     instsAdded = numInstsToWB.getWire(latency);
55     instsToExecute = numInstsToWB.getWire(0);
56 
57     memReq = new MemReq;
58     memReq->data = new uint8_t[64];
59     status = Running;
60 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classInorderBackEnd_a53f309de2e633a8788fc67ba03d23675}{
\index{InorderBackEnd@{InorderBackEnd}!checkInterrupts@{checkInterrupts}}
\index{checkInterrupts@{checkInterrupts}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{checkInterrupts}]{\setlength{\rightskip}{0pt plus 5cm}void checkInterrupts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_a53f309de2e633a8788fc67ba03d23675}



\begin{DoxyCode}
88 {
89     //Check if there are any outstanding interrupts
90     //Handle the interrupts
91     int ipl = 0;
92     int summary = 0;
93 
94 
95     if (thread->readMiscRegNoEffect(IPR_ASTRR))
96         panic("asynchronous traps not implemented\n");
97 
98     if (thread->readMiscRegNoEffect(IPR_SIRR)) {
99         for (int i = INTLEVEL_SOFTWARE_MIN;
100              i < INTLEVEL_SOFTWARE_MAX; i++) {
101             if (thread->readMiscRegNoEffect(IPR_SIRR) & (ULL(1) << i)) {
102                 // See table 4-19 of the 21164 hardware reference
103                 ipl = (i - INTLEVEL_SOFTWARE_MIN) + 1;
104                 summary |= (ULL(1) << i);
105             }
106         }
107     }
108 
109     uint64_t interrupts = cpu->intr_status();
110 
111     if (interrupts) {
112         for (int i = INTLEVEL_EXTERNAL_MIN;
113              i < INTLEVEL_EXTERNAL_MAX; i++) {
114             if (interrupts & (ULL(1) << i)) {
115                 // See table 4-19 of the 21164 hardware reference
116                 ipl = i;
117                 summary |= (ULL(1) << i);
118             }
119         }
120     }
121 
122     if (ipl && ipl > thread->readMiscRegNoEffect(IPR_IPLR)) {
123         thread->noSquashFromTC = true;
124 
125         thread->setMiscRegNoEffect(IPR_ISR, summary);
126         thread->setMiscRegNoEffect(IPR_INTID, ipl);
127         Fault(new InterruptFault)->invoke(xc);
128         DPRINTF(Flow, "Interrupt! IPLR=%d ipl=%d summary=%x\n",
129                 thread->readMiscRegNoEffect(IPR_IPLR), ipl, summary);
130 
131         // May need to go 1 inst prior
132         squashPending = true;
133 
134         thread->noSquashFromTC = false;
135 
136         setSquashInfoFromXC();
137     }
138 }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_a039b639c41c289e1cfe6d71c41d9308c}{
\index{InorderBackEnd@{InorderBackEnd}!doSwitchOut@{doSwitchOut}}
\index{doSwitchOut@{doSwitchOut}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{doSwitchOut}]{\setlength{\rightskip}{0pt plus 5cm}void doSwitchOut ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_a039b639c41c289e1cfe6d71c41d9308c}



\begin{DoxyCode}
127 { panic("Not implemented!"); }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_a80587b4fe043bbe1995536cb3b361588}{
\index{InorderBackEnd@{InorderBackEnd}!dumpInsts@{dumpInsts}}
\index{dumpInsts@{dumpInsts}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{dumpInsts}]{\setlength{\rightskip}{0pt plus 5cm}void dumpInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_a80587b4fe043bbe1995536cb3b361588}



\begin{DoxyCode}
461 {
462     int num = 0;
463     int valid_num = 0;
464 
465     InstListIt inst_list_it = instList.begin();
466 
467     cprintf("Inst list size: %i\n", instList.size());
468 
469     while (inst_list_it != instList.end())
470     {
471         cprintf("Instruction:%i\n",
472                 num);
473         if (!(*inst_list_it)->isSquashed()) {
474             if (!(*inst_list_it)->isIssued()) {
475                 ++valid_num;
476                 cprintf("Count:%i\n", valid_num);
477             } else if ((*inst_list_it)->isMemRef() &&
478                        !(*inst_list_it)->memOpDone) {
479                 // Loads that have not been marked as executed still count
480                 // towards the total instructions.
481                 ++valid_num;
482                 cprintf("Count:%i\n", valid_num);
483             }
484         }
485 
486         cprintf("PC:%#x\n[sn:%lli]\n[tid:%i]\n"
487                 "Issued:%i\nSquashed:%i\n",
488                 (*inst_list_it)->readPC(),
489                 (*inst_list_it)->seqNum,
490                 (*inst_list_it)->threadNumber,
491                 (*inst_list_it)->isIssued(),
492                 (*inst_list_it)->isSquashed());
493 
494         if ((*inst_list_it)->isMemRef()) {
495             cprintf("MemOpDone:%i\n", (*inst_list_it)->memOpDone);
496         }
497 
498         cprintf("\n");
499 
500         inst_list_it++;
501         ++num;
502     }
503 }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_a2d00e30d66a56e4667e28df302c98ac0}{
\index{InorderBackEnd@{InorderBackEnd}!executeInsts@{executeInsts}}
\index{executeInsts@{executeInsts}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{executeInsts}]{\setlength{\rightskip}{0pt plus 5cm}void executeInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_a2d00e30d66a56e4667e28df302c98ac0}



\begin{DoxyCode}
193 {
194     bool completed_last_inst = true;
195     int insts_to_execute = *instsToExecute;
196     int freed_regs = 0;
197 
198     while (insts_to_execute > 0) {
199         assert(!instList.empty());
200         DynInstPtr inst = instList.front();
201 
202         commitPC = inst->readPC();
203 
204         thread->setPC(commitPC);
205         thread->setNextPC(inst->readNextPC());
206 
207         if (FullSystem) {
208             int count = 0;
209             Addr oldpc;
210             do {
211                 if (count == 0)
212                     assert(!thread->noSquashFromTC && !thread->trapPending);
213                 oldpc = thread->readPC();
214                 cpu->system->pcEventQueue.service(
215                     thread->getXCProxy());
216                 count++;
217             } while (oldpc != thread->readPC());
218             if (count > 1) {
219                 DPRINTF(IBE, "PC skip function event, stopping commit\n");
220                 completed_last_inst = false;
221                 squashPending = true;
222                 break;
223             }
224         }
225 
226         Fault inst_fault = NoFault;
227 
228         if (status == DcacheMissComplete) {
229             DPRINTF(IBE, "Completing inst [sn:%lli]\n", inst->seqNum);
230             status = Running;
231         } else if (inst->isMemRef() && status != DcacheMissComplete &&
232             (!inst->isDataPrefetch() && !inst->isInstPrefetch())) {
233             DPRINTF(IBE, "Initiating mem op inst [sn:%lli] PC: %#x\n",
234                     inst->seqNum, inst->readPC());
235 
236             cacheCompletionEvent.inst = inst;
237             inst_fault = inst->initiateAcc();
238             if (inst_fault == NoFault &&
239                 status != DcacheMissLoadStall &&
240                 status != DcacheMissStoreStall) {
241                 inst_fault = inst->completeAcc();
242             }
243             ++thread->funcExeInst;
244         } else {
245             DPRINTF(IBE, "Executing inst [sn:%lli] PC: %#x\n",
246                     inst->seqNum, inst->readPC());
247             inst_fault = inst->execute();
248             ++thread->funcExeInst;
249         }
250 
251         // Will need to be able to break this loop in case the load
252         // misses.  Split access/complete ops would be useful here
253         // with writeback events.
254         if (status == DcacheMissLoadStall) {
255             *instsToExecute = insts_to_execute;
256 
257             completed_last_inst = false;
258             break;
259         } else if (status == DcacheMissStoreStall) {
260             // Figure out how to fix this hack.  Probably have DcacheMissLoad
261             // vs DcacheMissStore.
262             *instsToExecute = insts_to_execute;
263             completed_last_inst = false;
264 /*
265             instList.pop_front();
266             --insts_to_execute;
267             if (inst->traceData) {
268                 inst->traceData->finalize();
269             }
270 */
271 
272             // Don't really need to stop for a store stall as long as
273             // the memory system is able to handle store forwarding
274             // and such.  Breaking out might help avoid the cache
275             // interface becoming blocked.
276             break;
277         }
278 
279         inst->setExecuted();
280         inst->setResultReady();
281         inst->setCanCommit();
282 
283         instList.pop_front();
284 
285         --insts_to_execute;
286         --(*instsToExecute);
287 
288         if (inst->traceData) {
289             inst->traceData->finalize();
290             inst->traceData = NULL;
291         }
292 
293         if (inst_fault != NoFault) {
294             DPRINTF(IBE, "Inst [sn:%lli] PC %#x has a fault\n",
295                     inst->seqNum, inst->readPC());
296 
297             assert(!thread->noSquashFromTC);
298 
299             thread->noSquashFromTC = true;
300 
301             // Consider holding onto the trap and waiting until the trap event
302             // happens for this to be executed.
303             inst_fault->invoke(xc);
304 
305             // Exit state update mode to avoid accidental updating.
306             thread->noSquashFromTC = false;
307 
308             squashPending = true;
309 
310             completed_last_inst = false;
311             break;
312         }
313 
314         for (int i = 0; i < inst->numDestRegs(); ++i) {
315             renameTable[inst->destRegIdx(i)] = inst;
316             thread->renameTable[inst->destRegIdx(i)] = inst;
317             ++freed_regs;
318         }
319 
320         inst->clearDependents();
321 
322         comm->access(0)->doneSeqNum = inst->seqNum;
323 
324         if (inst->mispredicted()) {
325             squash(inst->seqNum, inst->readNextPC());
326 
327             thread->setNextPC(inst->readNextPC());
328 
329             break;
330         } else if (squashPending) {
331             // Something external happened that caused the CPU to squash.
332             // Break out of commit and handle the squash next cycle.
333             break;
334         }
335         // If it didn't mispredict, then it executed fine.  Send back its
336         // registers and BP info?  What about insts that may still have
337         // latency, like loads?  Probably can send back the information after
338         // it is completed.
339 
340         // keep an instruction count
341         cpu->numInst++;
342         thread->numInsts++;
343     }
344 
345     frontEnd->addFreeRegs(freed_regs);
346 
347     assert(insts_to_execute >= 0);
348 
349     // Should only advance this if I have executed all instructions.
350     if (insts_to_execute == 0) {
351         numInstsToWB.advance();
352     }
353 
354     // Should I set the PC to the next PC here?  What do I set next PC to?
355     if (completed_last_inst) {
356         thread->setPC(thread->readNextPC());
357         thread->setNextPC(thread->readPC() + sizeof(MachInst));
358     }
359 
360     if (squashPending) {
361         setSquashInfoFromXC();
362     }
363 }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_a71dcc69e5b01fa12b8ccd2dccdcc9917}{
\index{InorderBackEnd@{InorderBackEnd}!fetchFault@{fetchFault}}
\index{fetchFault@{fetchFault}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{fetchFault}]{\setlength{\rightskip}{0pt plus 5cm}void fetchFault ({\bf Fault} \& {\em fault})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_a71dcc69e5b01fa12b8ccd2dccdcc9917}



\begin{DoxyCode}
454 {
455     faultFromFetch = fault;
456 }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_ae4e704602e6cab77b5b96396fee5d104}{
\index{InorderBackEnd@{InorderBackEnd}!generateXCEvent@{generateXCEvent}}
\index{generateXCEvent@{generateXCEvent}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{generateXCEvent}]{\setlength{\rightskip}{0pt plus 5cm}void generateXCEvent ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_ae4e704602e6cab77b5b96396fee5d104}



\begin{DoxyCode}
83 { }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_acd8f81ae1aa6143073f58ab038f684f0}{
\index{InorderBackEnd@{InorderBackEnd}!handleFault@{handleFault}}
\index{handleFault@{handleFault}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{handleFault}]{\setlength{\rightskip}{0pt plus 5cm}void handleFault ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classInorderBackEnd_acd8f81ae1aa6143073f58ab038f684f0}



\begin{DoxyCode}
368 {
369     DPRINTF(Commit, "Handling fault from fetch\n");
370 
371     assert(!thread->noSquashFromTC);
372 
373     thread->noSquashFromTC = true;
374 
375     // Consider holding onto the trap and waiting until the trap event
376     // happens for this to be executed.
377     faultFromFetch->invoke(xc);
378 
379     // Exit state update mode to avoid accidental updating.
380     thread->noSquashFromTC = false;
381 
382     squashPending = true;
383 
384     setSquashInfoFromXC();
385 }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_ae6ec007d68382eb124ed25bc90ae9c17}{
\index{InorderBackEnd@{InorderBackEnd}!isBlocked@{isBlocked}}
\index{isBlocked@{isBlocked}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{isBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool isBlocked ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_ae6ec007d68382eb124ed25bc90ae9c17}



\begin{DoxyCode}
88                      { return status == DcacheMissStoreStall ||
89                            status == DcacheMissLoadStall ||
90                            interruptBlocked; }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_a3e70330939fdfc4dbc2f60c1a660584d}{
\index{InorderBackEnd@{InorderBackEnd}!isFull@{isFull}}
\index{isFull@{isFull}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{isFull}]{\setlength{\rightskip}{0pt plus 5cm}bool isFull ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_a3e70330939fdfc4dbc2f60c1a660584d}



\begin{DoxyCode}
87 { return false; }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{InorderBackEnd@{InorderBackEnd}!name@{name}}
\index{name@{name}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_a37627d5d5bba7f4a8690c71c2ab3cb07}



\begin{DoxyCode}
65 {
66     return cpu->name() + ".inorderbackend";
67 }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_ad2981b6704bca036af0723daaaebe57e}{
\index{InorderBackEnd@{InorderBackEnd}!read@{read}}
\index{read@{read}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} read (MemReqPtr \& {\em req}, \/  T \& {\em data}, \/  int {\em load\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_ad2981b6704bca036af0723daaaebe57e}



\begin{DoxyCode}
273 {
274 //    panic("Unimplemented!");
275 //    memReq->reset(addr, sizeof(T), flags);
276 
277     // translate to physical address
278 //    Fault fault = cpu->translateDataReadReq(req);
279     req->cmd = Read;
280     req->completionEvent = NULL;
281     req->time = curTick();
282     assert(!req->data);
283     req->data = new uint8_t[64];
284     Fault fault = cpu->read(req, data);
285     memcpy(req->data, &data, sizeof(T));
286 
287     // if we have a cache, do cache access too
288     if (dcacheInterface) {
289         MemAccessResult result = dcacheInterface->access(req);
290 
291         // Ugly hack to get an event scheduled *only* if the access is
292         // a miss.  We really should add first-class support for this
293         // at some point.
294         if (result != MA_HIT) {
295             req->completionEvent = &cacheCompletionEvent;
296             lastDcacheStall = curTick();
297 //          unscheduleTickEvent();
298             status = DcacheMissLoadStall;
299             DPRINTF(IBE, "Dcache miss load stall!\n");
300         } else {
301             DPRINTF(IBE, "Dcache hit!\n");
302 
303         }
304     }
305 
306     return NoFault;
307 }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_a0747777ac998dabdc20fa0c554d378d3}{
\index{InorderBackEnd@{InorderBackEnd}!read@{read}}
\index{read@{read}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} read ({\bf RequestPtr} {\em req}, \/  T \& {\em data}, \/  int {\em load\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_a0747777ac998dabdc20fa0c554d378d3}
\hypertarget{classInorderBackEnd_a54c0093df1bc3e8cd4f00246884389cc}{
\index{InorderBackEnd@{InorderBackEnd}!read@{read}}
\index{read@{read}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} read ({\bf Addr} {\em addr}, \/  T \& {\em data}, \/  unsigned {\em flags})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_a54c0093df1bc3e8cd4f00246884389cc}



\begin{DoxyCode}
201 {
202     memReq->reset(addr, sizeof(T), flags);
203 
204     // translate to physical address
205     Fault fault = cpu->dtb->translateAtomic(memReq, thread->getTC(), false);
206 
207     // if we have a cache, do cache access too
208     if (fault == NoFault && dcacheInterface) {
209         memReq->cmd = Read;
210         memReq->completionEvent = NULL;
211         memReq->time = curTick();
212         MemAccessResult result = dcacheInterface->access(memReq);
213 
214         // Ugly hack to get an event scheduled *only* if the access is
215         // a miss.  We really should add first-class support for this
216         // at some point.
217         if (result != MA_HIT) {
218             // Fix this hack for keeping funcExeInst correct with loads that
219             // are executed twice.
220             memReq->completionEvent = &cacheCompletionEvent;
221             lastDcacheStall = curTick();
222 //          unscheduleTickEvent();
223             status = DcacheMissLoadStall;
224             DPRINTF(IBE, "Dcache miss stall!\n");
225         } else {
226             // do functional access
227             DPRINTF(IBE, "Dcache hit!\n");
228         }
229     }
230     return fault;
231 }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_aa28f3fe58fde4b038a92b9f87a40cb10}{
\index{InorderBackEnd@{InorderBackEnd}!readCommitPC@{readCommitPC}}
\index{readCommitPC@{readCommitPC}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{readCommitPC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} readCommitPC ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_aa28f3fe58fde4b038a92b9f87a40cb10}



\begin{DoxyCode}
122 { return commitPC; }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{InorderBackEnd@{InorderBackEnd}!regStats@{regStats}}
\index{regStats@{regStats}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_a4dc637449366fcdfc4e764cdf12d9b11}



\begin{DoxyCode}
74 { }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_a5c38df1621043861ada4dd0939509869}{
\index{InorderBackEnd@{InorderBackEnd}!robEmpty@{robEmpty}}
\index{robEmpty@{robEmpty}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{robEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool robEmpty ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_a5c38df1621043861ada4dd0939509869}



\begin{DoxyCode}
85 { return instList.empty(); }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_aeabdb9f0aae07df67c3029f8fddb2693}{
\index{InorderBackEnd@{InorderBackEnd}!setCommBuffer@{setCommBuffer}}
\index{setCommBuffer@{setCommBuffer}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{setCommBuffer}]{\setlength{\rightskip}{0pt plus 5cm}void setCommBuffer ({\bf TimeBuffer}$<$ {\bf CommStruct} $>$ $\ast$ {\em \_\-comm})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_aeabdb9f0aae07df67c3029f8fddb2693}



\begin{DoxyCode}
68     { comm = _comm; }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_ad491c9766121fc19aa77fd0723e7641d}{
\index{InorderBackEnd@{InorderBackEnd}!setCPU@{setCPU}}
\index{setCPU@{setCPU}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{setCPU}]{\setlength{\rightskip}{0pt plus 5cm}void setCPU ({\bf FullCPU} $\ast$ {\em cpu\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_ad491c9766121fc19aa77fd0723e7641d}



\begin{DoxyCode}
62     { cpu = cpu_ptr; }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_a122009fa2730cee3898ac945227da8eb}{
\index{InorderBackEnd@{InorderBackEnd}!setFrontEnd@{setFrontEnd}}
\index{setFrontEnd@{setFrontEnd}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{setFrontEnd}]{\setlength{\rightskip}{0pt plus 5cm}void setFrontEnd ({\bf FrontEnd} $\ast$ {\em front\_\-end\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_a122009fa2730cee3898ac945227da8eb}



\begin{DoxyCode}
65     { frontEnd = front_end_ptr; }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_a9f7604c717497f0c9b7f416b3265e085}{
\index{InorderBackEnd@{InorderBackEnd}!setSquashInfoFromTC@{setSquashInfoFromTC}}
\index{setSquashInfoFromTC@{setSquashInfoFromTC}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{setSquashInfoFromTC}]{\setlength{\rightskip}{0pt plus 5cm}void setSquashInfoFromTC ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInorderBackEnd_a9f7604c717497f0c9b7f416b3265e085}
\hypertarget{classInorderBackEnd_ac6ccaaea6ac518cab92f71723b5a739e}{
\index{InorderBackEnd@{InorderBackEnd}!setTC@{setTC}}
\index{setTC@{setTC}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{setTC}]{\setlength{\rightskip}{0pt plus 5cm}void setTC ({\bf ThreadContext} $\ast$ {\em tc\_\-ptr})}}
\label{classInorderBackEnd_ac6ccaaea6ac518cab92f71723b5a739e}
\hypertarget{classInorderBackEnd_a2a6551551e11d9e1947d6805e8322757}{
\index{InorderBackEnd@{InorderBackEnd}!setThreadState@{setThreadState}}
\index{setThreadState@{setThreadState}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{setThreadState}]{\setlength{\rightskip}{0pt plus 5cm}void setThreadState ({\bf OzoneThreadState}$<$ Impl $>$ $\ast$ {\em thread\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_a2a6551551e11d9e1947d6805e8322757}



\begin{DoxyCode}
80 {
81     thread = thread_ptr;
82     thread->setFuncExeInst(0);
83 }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_aa332542122e7959baf01e00f79e82bba}{
\index{InorderBackEnd@{InorderBackEnd}!squash@{squash}}
\index{squash@{squash}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash (const {\bf InstSeqNum} \& {\em squash\_\-num}, \/  const {\bf Addr} \& {\em next\_\-PC})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_aa332542122e7959baf01e00f79e82bba}



\begin{DoxyCode}
390 {
391     DPRINTF(IBE, "Squashing from [sn:%lli], setting PC to %#x\n",
392             squash_num, next_PC);
393 
394     InstListIt squash_it = --(instList.end());
395 
396     int freed_regs = 0;
397 
398     while (!instList.empty() && (*squash_it)->seqNum > squash_num) {
399         DynInstPtr inst = *squash_it;
400 
401         DPRINTF(IBE, "Squashing instruction PC %#x, [sn:%lli].\n",
402                 inst->readPC(),
403                 inst->seqNum);
404 
405         // May cause problems with misc regs
406         freed_regs+= inst->numDestRegs();
407         inst->clearDependents();
408         squash_it--;
409         instList.pop_back();
410     }
411 
412     frontEnd->addFreeRegs(freed_regs);
413 
414     for (int i = 0; i < latency+1; ++i) {
415         numInstsToWB.advance();
416     }
417 
418     squashPending = false;
419 
420     // Probably want to make sure that this squash is the one that set the
421     // thread into noSquashFromTC mode.
422     thread->noSquashFromTC = false;
423 
424     // Tell front end to squash, reset PC to new one.
425     frontEnd->squash(squash_num, next_PC);
426 
427     faultFromFetch = NULL;
428 }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_a647eb6c891733b0ef3d9233af7f15748}{
\index{InorderBackEnd@{InorderBackEnd}!squashFromXC@{squashFromXC}}
\index{squashFromXC@{squashFromXC}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{squashFromXC}]{\setlength{\rightskip}{0pt plus 5cm}void squashFromXC ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_a647eb6c891733b0ef3d9233af7f15748}



\begin{DoxyCode}
433 {
434     // Record that I need to squash
435     squashPending = true;
436 
437     thread->noSquashFromTC = true;
438 }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_a05f299b443f8cc73a93d61572edc0218}{
\index{InorderBackEnd@{InorderBackEnd}!switchOut@{switchOut}}
\index{switchOut@{switchOut}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{switchOut}]{\setlength{\rightskip}{0pt plus 5cm}void switchOut ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_a05f299b443f8cc73a93d61572edc0218}



\begin{DoxyCode}
126 { panic("Not implemented!"); }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_a5a901e7ec5b94a55bd61fde88ad0b7f1}{
\index{InorderBackEnd@{InorderBackEnd}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ({\bf ThreadContext} $\ast$ {\em old\_\-tc} = {\ttfamily NULL})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_a5a901e7ec5b94a55bd61fde88ad0b7f1}



\begin{DoxyCode}
128 { panic("Not implemented!"); }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_a873dd91783f9efb4a590aded1f70d6b0}{
\index{InorderBackEnd@{InorderBackEnd}!tick@{tick}}
\index{tick@{tick}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_a873dd91783f9efb4a590aded1f70d6b0}



\begin{DoxyCode}
143 {
144     // Squash due to an external source
145     // Not sure if this or an interrupt has higher priority
146     if (squashPending) {
147         squash(squashSeqNum, squashNextPC);
148         return;
149     }
150 
151     // if (interrupt) then set thread PC, stall front end, record that
152     // I'm waiting for it to drain.  (for now just squash)
153     if (FullSystem && (interruptBlocked || cpu->checkInterrupts(tc))) {
154         if (!robEmpty()) {
155             interruptBlocked = true;
156         //AlphaDep
157         } else if (robEmpty() && (PC & 0x3)) {
158             // Will need to let the front end continue a bit until
159             // we're out of pal mode.  Hopefully we never get into an
160             // infinite loop...
161             interruptBlocked = false;
162         } else {
163             interruptBlocked = false;
164             checkInterrupts();
165             return;
166         }
167     }
168 
169     if (status != DcacheMissLoadStall &&
170         status != DcacheMissStoreStall) {
171         for (int i = 0; i < width && (*instsAdded) < width; ++i) {
172             DynInstPtr inst = frontEnd->getInst();
173 
174             if (!inst)
175                 break;
176 
177             instList.push_back(inst);
178 
179             (*instsAdded)++;
180         }
181 
182         if (faultFromFetch && robEmpty() && frontEnd->isEmpty()) {
183             handleFault();
184         } else {
185             executeInsts();
186         }
187     }
188 }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_a173162a41482ee35c5a15394b4befa4b}{
\index{InorderBackEnd@{InorderBackEnd}!write@{write}}
\index{write@{write}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} write (MemReqPtr \& {\em req}, \/  T \& {\em data}, \/  int {\em store\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_a173162a41482ee35c5a15394b4befa4b}



\begin{DoxyCode}
313 {
314 //    req->reset(addr, sizeof(T), flags);
315 
316     // translate to physical address
317 //    Fault fault = cpu->translateDataWriteReq(req);
318 
319     req->cmd = Write;
320     req->completionEvent = NULL;
321     req->time = curTick();
322     assert(!req->data);
323     req->data = new uint8_t[64];
324     memcpy(req->data, (uint8_t *)&data, req->size);
325 
326     switch(req->size) {
327       case 1:
328         cpu->write(req, (uint8_t &)data);
329         break;
330       case 2:
331         cpu->write(req, (uint16_t &)data);
332         break;
333       case 4:
334         cpu->write(req, (uint32_t &)data);
335         break;
336       case 8:
337         cpu->write(req, (uint64_t &)data);
338         break;
339       default:
340         panic("Unexpected store size!\n");
341     }
342 
343     if (dcacheInterface) {
344         req->cmd = Write;
345         req->data = new uint8_t[64];
346         memcpy(req->data,(uint8_t *)&data,req->size);
347         req->completionEvent = NULL;
348         req->time = curTick();
349         MemAccessResult result = dcacheInterface->access(req);
350 
351         // Ugly hack to get an event scheduled *only* if the access is
352         // a miss.  We really should add first-class support for this
353         // at some point.
354         if (result != MA_HIT) {
355             req->completionEvent = &cacheCompletionEvent;
356             lastDcacheStall = curTick();
357 //          unscheduleTickEvent();
358             status = DcacheMissStoreStall;
359             DPRINTF(IBE, "Dcache miss store stall!\n");
360         } else {
361             DPRINTF(IBE, "Dcache hit!\n");
362 
363         }
364     }
365 /*
366     if (req->isLLSC()) {
367         if (req->isUncacheable()) {
368             // Don't update result register (see stq_c in isa_desc)
369             req->result = 2;
370         } else {
371             req->result = 1;
372         }
373     }
374 */
375 /*
376     if (res && (fault == NoFault))
377         *res = req->result;
378         */
379     return NoFault;
380 }
\end{DoxyCode}
\hypertarget{classInorderBackEnd_abbf7bcc93511421a1787650a43e2642a}{
\index{InorderBackEnd@{InorderBackEnd}!write@{write}}
\index{write@{write}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} write ({\bf RequestPtr} {\em req}, \/  T \& {\em data}, \/  int {\em store\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_abbf7bcc93511421a1787650a43e2642a}
\hypertarget{classInorderBackEnd_ace3a2a0aed65c3714979fca6f51276f9}{
\index{InorderBackEnd@{InorderBackEnd}!write@{write}}
\index{write@{write}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} write (T {\em data}, \/  {\bf Addr} {\em addr}, \/  unsigned {\em flags}, \/  uint64\_\-t $\ast$ {\em res})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInorderBackEnd_ace3a2a0aed65c3714979fca6f51276f9}



\begin{DoxyCode}
237 {
238     memReq->reset(addr, sizeof(T), flags);
239 
240     // translate to physical address
241     Fault fault = cpu->dtb->translateAtomic(memReq, thread->getTC(), true);
242 
243     if (fault == NoFault && dcacheInterface) {
244         memReq->cmd = Write;
245 //      memcpy(memReq->data,(uint8_t *)&data,memReq->size);
246         memReq->completionEvent = NULL;
247         memReq->time = curTick();
248         MemAccessResult result = dcacheInterface->access(memReq);
249 
250         // Ugly hack to get an event scheduled *only* if the access is
251         // a miss.  We really should add first-class support for this
252         // at some point.
253         if (result != MA_HIT) {
254             memReq->completionEvent = &cacheCompletionEvent;
255             lastDcacheStall = curTick();
256 //          unscheduleTickEvent();
257             status = DcacheMissStoreStall;
258             DPRINTF(IBE, "Dcache miss stall!\n");
259         } else {
260             DPRINTF(IBE, "Dcache hit!\n");
261         }
262     }
263 
264     if (res && (fault == NoFault))
265         *res = memReq->result;
266     return fault;
267 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classInorderBackEnd_a27227be5511e316f17702a3a99fb0b98}{
\index{InorderBackEnd@{InorderBackEnd}!DCacheCompletionEvent@{DCacheCompletionEvent}}
\index{DCacheCompletionEvent@{DCacheCompletionEvent}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{DCacheCompletionEvent}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf DCacheCompletionEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classInorderBackEnd_a27227be5511e316f17702a3a99fb0b98}


\subsection{変数}
\hypertarget{classInorderBackEnd_a08f9ddeb55a0840fc2f9d8f4c5e7a9fc}{
\index{InorderBackEnd@{InorderBackEnd}!cacheCompletionEvent@{cacheCompletionEvent}}
\index{cacheCompletionEvent@{cacheCompletionEvent}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{cacheCompletionEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DCacheCompletionEvent} {\bf cacheCompletionEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classInorderBackEnd_a08f9ddeb55a0840fc2f9d8f4c5e7a9fc}
\hypertarget{classInorderBackEnd_a282f2307a986f183b83e887756561687}{
\index{InorderBackEnd@{InorderBackEnd}!comm@{comm}}
\index{comm@{comm}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{comm}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf CommStruct}$>$$\ast$ {\bf comm}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInorderBackEnd_a282f2307a986f183b83e887756561687}
\hypertarget{classInorderBackEnd_af043d6103c5f173871f527899c41d2d2}{
\index{InorderBackEnd@{InorderBackEnd}!commitPC@{commitPC}}
\index{commitPC@{commitPC}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{commitPC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf commitPC}}}
\label{classInorderBackEnd_af043d6103c5f173871f527899c41d2d2}
\hypertarget{classInorderBackEnd_a766385c2941cd46525f4d9dff90200a2}{
\index{InorderBackEnd@{InorderBackEnd}!cpu@{cpu}}
\index{cpu@{cpu}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FullCPU}$\ast$ {\bf cpu}}}
\label{classInorderBackEnd_a766385c2941cd46525f4d9dff90200a2}
\hypertarget{classInorderBackEnd_a06d11574ef2a7c403c51d626e834d91e}{
\index{InorderBackEnd@{InorderBackEnd}!dcacheStallCycles@{dcacheStallCycles}}
\index{dcacheStallCycles@{dcacheStallCycles}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{dcacheStallCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf dcacheStallCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInorderBackEnd_a06d11574ef2a7c403c51d626e834d91e}
\hypertarget{classInorderBackEnd_a21a86a2f5f30b0f512909bdc8b2aae53}{
\index{InorderBackEnd@{InorderBackEnd}!faultFromFetch@{faultFromFetch}}
\index{faultFromFetch@{faultFromFetch}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{faultFromFetch}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} {\bf faultFromFetch}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInorderBackEnd_a21a86a2f5f30b0f512909bdc8b2aae53}
\hypertarget{classInorderBackEnd_a67c762418bb2017cb2dce5a0c94f0788}{
\index{InorderBackEnd@{InorderBackEnd}!frontEnd@{frontEnd}}
\index{frontEnd@{frontEnd}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{frontEnd}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FrontEnd}$\ast$ {\bf frontEnd}}}
\label{classInorderBackEnd_a67c762418bb2017cb2dce5a0c94f0788}
\hypertarget{classInorderBackEnd_ae10a391d02ce1ef67ee13cd82b7d46e5}{
\index{InorderBackEnd@{InorderBackEnd}!instList@{instList}}
\index{instList@{instList}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{instList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf instList}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInorderBackEnd_ae10a391d02ce1ef67ee13cd82b7d46e5}
\hypertarget{classInorderBackEnd_a3bafa8bcab17d8f51c2b5fdf04679d47}{
\index{InorderBackEnd@{InorderBackEnd}!instsAdded@{instsAdded}}
\index{instsAdded@{instsAdded}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{instsAdded}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<$int$>$::wire {\bf instsAdded}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInorderBackEnd_a3bafa8bcab17d8f51c2b5fdf04679d47}
\hypertarget{classInorderBackEnd_aea4c234514337a9dd2233b49732f6638}{
\index{InorderBackEnd@{InorderBackEnd}!instsToExecute@{instsToExecute}}
\index{instsToExecute@{instsToExecute}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{instsToExecute}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<$int$>$::wire {\bf instsToExecute}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInorderBackEnd_aea4c234514337a9dd2233b49732f6638}
\hypertarget{classInorderBackEnd_ae2e3d2da6f5c26e7f0eca5784b6397d1}{
\index{InorderBackEnd@{InorderBackEnd}!interruptBlocked@{interruptBlocked}}
\index{interruptBlocked@{interruptBlocked}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{interruptBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf interruptBlocked}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInorderBackEnd_ae2e3d2da6f5c26e7f0eca5784b6397d1}
\hypertarget{classInorderBackEnd_a8b4696062ef09ab956804a7a99491853}{
\index{InorderBackEnd@{InorderBackEnd}!lastDcacheStall@{lastDcacheStall}}
\index{lastDcacheStall@{lastDcacheStall}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{lastDcacheStall}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Counter} {\bf lastDcacheStall}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInorderBackEnd_a8b4696062ef09ab956804a7a99491853}
\hypertarget{classInorderBackEnd_a9c5bf07170b5d91cfb44d4bfd0517128}{
\index{InorderBackEnd@{InorderBackEnd}!latency@{latency}}
\index{latency@{latency}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{latency}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf latency}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInorderBackEnd_a9c5bf07170b5d91cfb44d4bfd0517128}
\hypertarget{classInorderBackEnd_a5520eb2f7c2cf4b0e109d6ffd6d2d053}{
\index{InorderBackEnd@{InorderBackEnd}!memReq@{memReq}}
\index{memReq@{memReq}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{memReq}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RequestPtr} {\bf memReq}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classInorderBackEnd_a5520eb2f7c2cf4b0e109d6ffd6d2d053}
\hypertarget{classInorderBackEnd_a34cd6ffaeb59e3f95f2cc2aaf8eb7ecf}{
\index{InorderBackEnd@{InorderBackEnd}!numInstsToWB@{numInstsToWB}}
\index{numInstsToWB@{numInstsToWB}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{numInstsToWB}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<$int$>$ {\bf numInstsToWB}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInorderBackEnd_a34cd6ffaeb59e3f95f2cc2aaf8eb7ecf}
\hypertarget{classInorderBackEnd_af8d3f859e7c0dd9408ba99de6f415616}{
\index{InorderBackEnd@{InorderBackEnd}!renameTable@{renameTable}}
\index{renameTable@{renameTable}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{renameTable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RenameTable}$<$Impl$>$ {\bf renameTable}}}
\label{classInorderBackEnd_af8d3f859e7c0dd9408ba99de6f415616}
\hypertarget{classInorderBackEnd_a440f8cda1481977c324a827c7c9f1e24}{
\index{InorderBackEnd@{InorderBackEnd}!squashLatency@{squashLatency}}
\index{squashLatency@{squashLatency}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{squashLatency}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf squashLatency}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInorderBackEnd_a440f8cda1481977c324a827c7c9f1e24}
\hypertarget{classInorderBackEnd_aabe0c73b4678ef858d3363c9bed18906}{
\index{InorderBackEnd@{InorderBackEnd}!squashNextPC@{squashNextPC}}
\index{squashNextPC@{squashNextPC}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{squashNextPC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf squashNextPC}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInorderBackEnd_aabe0c73b4678ef858d3363c9bed18906}
\hypertarget{classInorderBackEnd_a2aafb6fc593b04986eeed845923a8953}{
\index{InorderBackEnd@{InorderBackEnd}!squashPending@{squashPending}}
\index{squashPending@{squashPending}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{squashPending}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf squashPending}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInorderBackEnd_a2aafb6fc593b04986eeed845923a8953}
\hypertarget{classInorderBackEnd_a34292b1418c46ca63c892e7826510d77}{
\index{InorderBackEnd@{InorderBackEnd}!squashSeqNum@{squashSeqNum}}
\index{squashSeqNum@{squashSeqNum}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{squashSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf squashSeqNum}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInorderBackEnd_a34292b1418c46ca63c892e7826510d77}
\hypertarget{classInorderBackEnd_ae29aa2d4ae440022daaed1107eb306b3}{
\index{InorderBackEnd@{InorderBackEnd}!status@{status}}
\index{status@{status}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{status}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Status} {\bf status}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classInorderBackEnd_ae29aa2d4ae440022daaed1107eb306b3}
\hypertarget{classInorderBackEnd_a4455a4759e69e5ebe68ae7298cbcc37d}{
\index{InorderBackEnd@{InorderBackEnd}!tc@{tc}}
\index{tc@{tc}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{tc}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadContext}$\ast$ {\bf tc}}}
\label{classInorderBackEnd_a4455a4759e69e5ebe68ae7298cbcc37d}
\hypertarget{classInorderBackEnd_ab6f834310107fd693035eba2eeca583f}{
\index{InorderBackEnd@{InorderBackEnd}!thread@{thread}}
\index{thread@{thread}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{thread}]{\setlength{\rightskip}{0pt plus 5cm}{\bf OzoneThreadState}$<$Impl$>$$\ast$ {\bf thread}}}
\label{classInorderBackEnd_ab6f834310107fd693035eba2eeca583f}
\hypertarget{classInorderBackEnd_a2474a5474cbff19523a51eb1de01cda4}{
\index{InorderBackEnd@{InorderBackEnd}!width@{width}}
\index{width@{width}!InorderBackEnd@{InorderBackEnd}}
\subsubsection[{width}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf width}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInorderBackEnd_a2474a5474cbff19523a51eb1de01cda4}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/ozone/\hyperlink{inorder__back__end_8hh}{inorder\_\-back\_\-end.hh}\item 
cpu/ozone/\hyperlink{inorder__back__end__impl_8hh}{inorder\_\-back\_\-end\_\-impl.hh}\end{DoxyCompactItemize}
