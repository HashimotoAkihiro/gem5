\hypertarget{classPhysicalMemory}{
\section{クラス PhysicalMemory}
\label{classPhysicalMemory}\index{PhysicalMemory@{PhysicalMemory}}
}


{\ttfamily \#include $<$physical.hh$>$}PhysicalMemoryに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classPhysicalMemory}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classPhysicalMemory_a987bb2d4a9b94b62fa15261e024019e5}{PhysicalMemory} (const std::string \&\hyperlink{classPhysicalMemory_aaf2ed934b37cbbd236fdd1b01a5f5005}{\_\-name}, const \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classAbstractMemory}{AbstractMemory} $\ast$ $>$ \&\_\-memories)
\item 
\hyperlink{classPhysicalMemory_ad6a6b96cf5b3ed869b4a6f06429fd4eb}{$\sim$PhysicalMemory} ()
\item 
const std::string \hyperlink{classPhysicalMemory_a6490f765a824ced1cc94979609fe7e07}{name} () const 
\item 
bool \hyperlink{classPhysicalMemory_a0faeadf06436f8123c7bda01087bb222}{isMemAddr} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr) const 
\item 
\hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classPhysicalMemory_a564b079bb27347c8bd8430f009539623}{getConfAddrRanges} () const 
\item 
uint64\_\-t \hyperlink{classPhysicalMemory_a990c48a7ad4a4821fe4f04a1e58845a6}{totalSize} () const 
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classstd_1_1pair}{std::pair}$<$ \hyperlink{classAddrRange}{AddrRange}, uint8\_\-t $\ast$ $>$ $>$ \hyperlink{classPhysicalMemory_a57d8785b312d1d1a53c4beb67a019d46}{getBackingStore} () const 
\item 
void \hyperlink{classPhysicalMemory_aac5d96736802cb79fb2287135bcc1dff}{access} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classPhysicalMemory_ace845b5316308e12fd958fa5df09a8e8}{functionalAccess} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classPhysicalMemory_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
void \hyperlink{classPhysicalMemory_adda88c8306de32c98ea608a0a85c3dcd}{serializeStore} (std::ostream \&os, unsigned int store\_\-id, \hyperlink{classAddrRange}{AddrRange} range, uint8\_\-t $\ast$pmem)
\item 
void \hyperlink{classPhysicalMemory_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\item 
void \hyperlink{classPhysicalMemory_ad180e1b910a31a4f7e6ad1a701c8a286}{unserializeStore} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classPhysicalMemory_a5247a8a9ca8b14d01253a6861b8b3bf2}{PhysicalMemory} (const \hyperlink{classPhysicalMemory}{PhysicalMemory} \&)
\item 
\hyperlink{classPhysicalMemory}{PhysicalMemory} \& \hyperlink{classPhysicalMemory_a3ce2a36a848a843e660964c9bc4237e8}{operator=} (const \hyperlink{classPhysicalMemory}{PhysicalMemory} \&)
\item 
void \hyperlink{classPhysicalMemory_a4a205bfc337649ce4e62fe5cb5c7579a}{createBackingStore} (\hyperlink{classAddrRange}{AddrRange} range, const \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classAbstractMemory}{AbstractMemory} $\ast$ $>$ \&\_\-memories)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
std::string \hyperlink{classPhysicalMemory_aaf2ed934b37cbbd236fdd1b01a5f5005}{\_\-name}
\item 
\hyperlink{classAddrRangeMap}{AddrRangeMap}$<$ \hyperlink{classAbstractMemory}{AbstractMemory} $\ast$ $>$ \hyperlink{classPhysicalMemory_ab5cfae3fb0ca282c337c30f0f36ea8d5}{addrMap}
\item 
\hyperlink{classAddrRange}{AddrRange} \hyperlink{classPhysicalMemory_a356adf3dbde22587d20fa428473a00d6}{rangeCache}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classAbstractMemory}{AbstractMemory} $\ast$ $>$ \hyperlink{classPhysicalMemory_a4c874036afca619454444242943675f4}{memories}
\item 
uint64\_\-t \hyperlink{classPhysicalMemory_af931a8871310b4dad23f0f0b0f623560}{size}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classstd_1_1pair}{std::pair}$<$ \hyperlink{classAddrRange}{AddrRange}, uint8\_\-t $\ast$ $>$ $>$ \hyperlink{classPhysicalMemory_a0c347314a9f0b468ed498abaf77bbe44}{backingStore}
\end{DoxyCompactItemize}


\subsection{説明}
The physical memory encapsulates all memories in the system and provides basic functionality for accessing those memories without going through the memory system and interconnect.

The physical memory is also responsible for providing the host system backingstore used by the memories in the simulated guest system. When the system is created, the physical memory allocates the backing store based on the address ranges that are populated in the system, and does so indepentent of how those map to actual memory controllers. Thus, the physical memory completely abstracts the mapping of the backing store of the host system and the address mapping in the guest system. This enables us to arbitrarily change the number of memory controllers, and their address mapping, as long as the ranges stay the same. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classPhysicalMemory_a5247a8a9ca8b14d01253a6861b8b3bf2}{
\index{PhysicalMemory@{PhysicalMemory}!PhysicalMemory@{PhysicalMemory}}
\index{PhysicalMemory@{PhysicalMemory}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{PhysicalMemory}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PhysicalMemory} (const {\bf PhysicalMemory} \&)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPhysicalMemory_a5247a8a9ca8b14d01253a6861b8b3bf2}
\hypertarget{classPhysicalMemory_a987bb2d4a9b94b62fa15261e024019e5}{
\index{PhysicalMemory@{PhysicalMemory}!PhysicalMemory@{PhysicalMemory}}
\index{PhysicalMemory@{PhysicalMemory}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{PhysicalMemory}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PhysicalMemory} (const std::string \& {\em \_\-name}, \/  const {\bf std::vector}$<$ {\bf AbstractMemory} $\ast$ $>$ \& {\em \_\-memories})}}
\label{classPhysicalMemory_a987bb2d4a9b94b62fa15261e024019e5}
Create a physical memory object, wrapping a number of memories. \hypertarget{classPhysicalMemory_ad6a6b96cf5b3ed869b4a6f06429fd4eb}{
\index{PhysicalMemory@{PhysicalMemory}!$\sim$PhysicalMemory@{$\sim$PhysicalMemory}}
\index{$\sim$PhysicalMemory@{$\sim$PhysicalMemory}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{$\sim$PhysicalMemory}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf PhysicalMemory} ()}}
\label{classPhysicalMemory_ad6a6b96cf5b3ed869b4a6f06429fd4eb}
Unmap all the backing store we have used. 


\begin{DoxyCode}
174 {
175     // unmap the backing store
176     for (vector<pair<AddrRange, uint8_t*> >::iterator s = backingStore.begin();
177          s != backingStore.end(); ++s)
178         munmap((char*)s->second, s->first.size());
179 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classPhysicalMemory_aac5d96736802cb79fb2287135bcc1dff}{
\index{PhysicalMemory@{PhysicalMemory}!access@{access}}
\index{access@{access}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{access}]{\setlength{\rightskip}{0pt plus 5cm}void access ({\bf PacketPtr} {\em pkt})}}
\label{classPhysicalMemory_aac5d96736802cb79fb2287135bcc1dff}
Perform an untimed memory access and update all the state (e.g. locked addresses) and statistics accordingly. The packet is turned into a response if required.


\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} performing the access \end{DoxyParams}



\begin{DoxyCode}
241 {
242     assert(pkt->isRequest());
243     Addr addr = pkt->getAddr();
244     AddrRangeMap<AbstractMemory*>::const_iterator m = addrMap.find(addr);
245     assert(m != addrMap.end());
246     m->second->access(pkt);
247 }
\end{DoxyCode}
\hypertarget{classPhysicalMemory_a4a205bfc337649ce4e62fe5cb5c7579a}{
\index{PhysicalMemory@{PhysicalMemory}!createBackingStore@{createBackingStore}}
\index{createBackingStore@{createBackingStore}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{createBackingStore}]{\setlength{\rightskip}{0pt plus 5cm}void createBackingStore ({\bf AddrRange} {\em range}, \/  const {\bf std::vector}$<$ {\bf AbstractMemory} $\ast$ $>$ \& {\em \_\-memories})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPhysicalMemory_a4a205bfc337649ce4e62fe5cb5c7579a}
Create the memory region providing the backing store for a given address range that corresponds to a set of memories in the simulated system.


\begin{DoxyParams}{引数}
\item[{\em range}]The address range covered \item[{\em memories}]The memories this range maps to \end{DoxyParams}



\begin{DoxyCode}
141 {
142     if (range.interleaved())
143         panic("Cannot create backing store for interleaved range %s\n",
144               range.to_string());
145 
146     // perform the actual mmap
147     DPRINTF(BusAddrRanges, "Creating backing store for range %s with size %d\n",
148             range.to_string(), range.size());
149     int map_flags = MAP_ANON | MAP_PRIVATE;
150     uint8_t* pmem = (uint8_t*) mmap(NULL, range.size(),
151                                     PROT_READ | PROT_WRITE,
152                                     map_flags, -1, 0);
153 
154     if (pmem == (uint8_t*) MAP_FAILED) {
155         perror("mmap");
156         fatal("Could not mmap %d bytes for range %s!\n", range.size(),
157               range.to_string());
158     }
159 
160     // remember this backing store so we can checkpoint it and unmap
161     // it appropriately
162     backingStore.push_back(make_pair(range, pmem));
163 
164     // point the memories to their backing store
165     for (vector<AbstractMemory*>::const_iterator m = _memories.begin();
166          m != _memories.end(); ++m) {
167         DPRINTF(BusAddrRanges, "Mapping memory %s to backing store\n",
168                 (*m)->name());
169         (*m)->setBackingStore(pmem);
170     }
171 }
\end{DoxyCode}
\hypertarget{classPhysicalMemory_ace845b5316308e12fd958fa5df09a8e8}{
\index{PhysicalMemory@{PhysicalMemory}!functionalAccess@{functionalAccess}}
\index{functionalAccess@{functionalAccess}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{functionalAccess}]{\setlength{\rightskip}{0pt plus 5cm}void functionalAccess ({\bf PacketPtr} {\em pkt})}}
\label{classPhysicalMemory_ace845b5316308e12fd958fa5df09a8e8}
Perform an untimed memory read or write without changing anything but the memory itself. No stats are affected by this access. In addition to normal accesses this also facilitates print requests.


\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} performing the access \end{DoxyParams}



\begin{DoxyCode}
251 {
252     assert(pkt->isRequest());
253     Addr addr = pkt->getAddr();
254     AddrRangeMap<AbstractMemory*>::const_iterator m = addrMap.find(addr);
255     assert(m != addrMap.end());
256     m->second->functionalAccess(pkt);
257 }
\end{DoxyCode}
\hypertarget{classPhysicalMemory_a57d8785b312d1d1a53c4beb67a019d46}{
\index{PhysicalMemory@{PhysicalMemory}!getBackingStore@{getBackingStore}}
\index{getBackingStore@{getBackingStore}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{getBackingStore}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf std::pair}$<${\bf AddrRange}, uint8\_\-t$\ast$$>$ $>$ getBackingStore () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPhysicalMemory_a57d8785b312d1d1a53c4beb67a019d46}
Get the pointers to the backing store for external host access. Note that memory in the guest should be accessed using \hyperlink{classPhysicalMemory_aac5d96736802cb79fb2287135bcc1dff}{access()} or \hyperlink{classPhysicalMemory_ace845b5316308e12fd958fa5df09a8e8}{functionalAccess()}. This interface is primarily intended for CPU models using hardware virtualization. Note that memories that are null are not present, and that the backing store may also contain memories that are not part of the OS-\/visible global address map and thus are allowed to overlap.

\begin{DoxyReturn}{戻り値}
Pointers to the memory backing store 
\end{DoxyReturn}



\begin{DoxyCode}
166     { return backingStore; }
\end{DoxyCode}
\hypertarget{classPhysicalMemory_a564b079bb27347c8bd8430f009539623}{
\index{PhysicalMemory@{PhysicalMemory}!getConfAddrRanges@{getConfAddrRanges}}
\index{getConfAddrRanges@{getConfAddrRanges}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{getConfAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRangeList} getConfAddrRanges () const}}
\label{classPhysicalMemory_a564b079bb27347c8bd8430f009539623}
Get the memory ranges for all memories that are to be reported to the configuration table. The ranges are merged before they are returned such that any interleaved ranges appear as a single range.

\begin{DoxyReturn}{戻り値}
All configuration table memory ranges 
\end{DoxyReturn}



\begin{DoxyCode}
204 {
205     // this could be done once in the constructor, but since it is unlikely to
206     // be called more than once the iteration should not be a problem
207     AddrRangeList ranges;
208     vector<AddrRange> intlv_ranges;
209     for (AddrRangeMap<AbstractMemory*>::const_iterator r = addrMap.begin();
210          r != addrMap.end(); ++r) {
211         if (r->second->isConfReported()) {
212             // if the range is interleaved then save it for now
213             if (r->first.interleaved()) {
214                 // if we already got interleaved ranges that are not
215                 // part of the same range, then first do a merge
216                 // before we add the new one
217                 if (!intlv_ranges.empty() &&
218                     !intlv_ranges.back().mergesWith(r->first)) {
219                     ranges.push_back(AddrRange(intlv_ranges));
220                     intlv_ranges.clear();
221                 }
222                 intlv_ranges.push_back(r->first);
223             } else {
224                 // keep the current range
225                 ranges.push_back(r->first);
226             }
227         }
228     }
229 
230     // if there is still interleaved ranges waiting to be merged,
231     // go ahead and do it
232     if (!intlv_ranges.empty()) {
233         ranges.push_back(AddrRange(intlv_ranges));
234     }
235 
236     return ranges;
237 }
\end{DoxyCode}
\hypertarget{classPhysicalMemory_a0faeadf06436f8123c7bda01087bb222}{
\index{PhysicalMemory@{PhysicalMemory}!isMemAddr@{isMemAddr}}
\index{isMemAddr@{isMemAddr}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{isMemAddr}]{\setlength{\rightskip}{0pt plus 5cm}bool isMemAddr ({\bf Addr} {\em addr}) const}}
\label{classPhysicalMemory_a0faeadf06436f8123c7bda01087bb222}
\hyperlink{classCheck}{Check} if a physical address is within a range of a memory that is part of the global address map.


\begin{DoxyParams}{引数}
\item[{\em addr}]A physical address \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Whether the address corresponds to a memory 
\end{DoxyReturn}



\begin{DoxyCode}
183 {
184     // see if the address is within the last matched range
185     if (!rangeCache.contains(addr)) {
186         // lookup in the interval tree
187         AddrRangeMap<AbstractMemory*>::const_iterator r = addrMap.find(addr);
188         if (r == addrMap.end()) {
189             // not in the cache, and not in the tree
190             return false;
191         }
192         // the range is in the tree, update the cache
193         rangeCache = r->first;
194     }
195 
196     assert(addrMap.find(addr) != addrMap.end());
197 
198     // either matched the cache or found in the tree
199     return true;
200 }
\end{DoxyCode}
\hypertarget{classPhysicalMemory_a6490f765a824ced1cc94979609fe7e07}{
\index{PhysicalMemory@{PhysicalMemory}!name@{name}}
\index{name@{name}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}const std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classPhysicalMemory_a6490f765a824ced1cc94979609fe7e07}
Return the name for debugging and for creation of sections for checkpointing. 

\hyperlink{classSerializable_a2d319721a65496069642871a52e47056}{Serializable}を実装しています。


\begin{DoxyCode}
125 { return _name; }
\end{DoxyCode}
\hypertarget{classPhysicalMemory_a3ce2a36a848a843e660964c9bc4237e8}{
\index{PhysicalMemory@{PhysicalMemory}!operator=@{operator=}}
\index{operator=@{operator=}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PhysicalMemory}\& operator= (const {\bf PhysicalMemory} \&)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPhysicalMemory_a3ce2a36a848a843e660964c9bc4237e8}
\hypertarget{classPhysicalMemory_a53e036786d17361be4c7320d39c99b84}{
\index{PhysicalMemory@{PhysicalMemory}!serialize@{serialize}}
\index{serialize@{serialize}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPhysicalMemory_a53e036786d17361be4c7320d39c99b84}
Serialize all the memories in the system. This is independent of the logical memory layout, and the serialization only sees the contigous backing store, independent of how this maps to logical memories in the guest system.


\begin{DoxyParams}{引数}
\item[{\em os}]stream to serialize to \end{DoxyParams}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。\hypertarget{classPhysicalMemory_adda88c8306de32c98ea608a0a85c3dcd}{
\index{PhysicalMemory@{PhysicalMemory}!serializeStore@{serializeStore}}
\index{serializeStore@{serializeStore}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{serializeStore}]{\setlength{\rightskip}{0pt plus 5cm}void serializeStore (std::ostream \& {\em os}, \/  unsigned int {\em store\_\-id}, \/  {\bf AddrRange} {\em range}, \/  uint8\_\-t $\ast$ {\em pmem})}}
\label{classPhysicalMemory_adda88c8306de32c98ea608a0a85c3dcd}
Serialize a specific store.


\begin{DoxyParams}{引数}
\item[{\em store\_\-id}]Unique identifier of this backing store \item[{\em range}]The address range of this backing store \item[{\em pmem}]The host pointer to this backing store \end{DoxyParams}
\hypertarget{classPhysicalMemory_a990c48a7ad4a4821fe4f04a1e58845a6}{
\index{PhysicalMemory@{PhysicalMemory}!totalSize@{totalSize}}
\index{totalSize@{totalSize}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{totalSize}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t totalSize () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPhysicalMemory_a990c48a7ad4a4821fe4f04a1e58845a6}
Get the total physical memory size.

\begin{DoxyReturn}{戻り値}
The sum of all memory sizes 
\end{DoxyReturn}



\begin{DoxyCode}
151 { return size; }
\end{DoxyCode}
\hypertarget{classPhysicalMemory_af22e5d6d660b97db37003ac61ac4ee49}{
\index{PhysicalMemory@{PhysicalMemory}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPhysicalMemory_af22e5d6d660b97db37003ac61ac4ee49}
Unserialize the memories in the system. As with the serialization, this action is independent of how the address ranges are mapped to logical memories in the guest system. 

\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。\hypertarget{classPhysicalMemory_ad180e1b910a31a4f7e6ad1a701c8a286}{
\index{PhysicalMemory@{PhysicalMemory}!unserializeStore@{unserializeStore}}
\index{unserializeStore@{unserializeStore}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{unserializeStore}]{\setlength{\rightskip}{0pt plus 5cm}void unserializeStore ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})}}
\label{classPhysicalMemory_ad180e1b910a31a4f7e6ad1a701c8a286}
Unserialize a specific backing store, identified by a section. 

\subsection{変数}
\hypertarget{classPhysicalMemory_aaf2ed934b37cbbd236fdd1b01a5f5005}{
\index{PhysicalMemory@{PhysicalMemory}!\_\-name@{\_\-name}}
\index{\_\-name@{\_\-name}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{\_\-name}]{\setlength{\rightskip}{0pt plus 5cm}std::string {\bf \_\-name}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPhysicalMemory_aaf2ed934b37cbbd236fdd1b01a5f5005}
\hypertarget{classPhysicalMemory_ab5cfae3fb0ca282c337c30f0f36ea8d5}{
\index{PhysicalMemory@{PhysicalMemory}!addrMap@{addrMap}}
\index{addrMap@{addrMap}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{addrMap}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRangeMap}$<${\bf AbstractMemory}$\ast$$>$ {\bf addrMap}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPhysicalMemory_ab5cfae3fb0ca282c337c30f0f36ea8d5}
\hypertarget{classPhysicalMemory_a0c347314a9f0b468ed498abaf77bbe44}{
\index{PhysicalMemory@{PhysicalMemory}!backingStore@{backingStore}}
\index{backingStore@{backingStore}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{backingStore}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf std::pair}$<${\bf AddrRange}, uint8\_\-t$\ast$$>$ $>$ {\bf backingStore}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPhysicalMemory_a0c347314a9f0b468ed498abaf77bbe44}
\hypertarget{classPhysicalMemory_a4c874036afca619454444242943675f4}{
\index{PhysicalMemory@{PhysicalMemory}!memories@{memories}}
\index{memories@{memories}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{memories}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf AbstractMemory}$\ast$$>$ {\bf memories}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPhysicalMemory_a4c874036afca619454444242943675f4}
\hypertarget{classPhysicalMemory_a356adf3dbde22587d20fa428473a00d6}{
\index{PhysicalMemory@{PhysicalMemory}!rangeCache@{rangeCache}}
\index{rangeCache@{rangeCache}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{rangeCache}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRange} {\bf rangeCache}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, private\mbox{]}}}}
\label{classPhysicalMemory_a356adf3dbde22587d20fa428473a00d6}
\hypertarget{classPhysicalMemory_af931a8871310b4dad23f0f0b0f623560}{
\index{PhysicalMemory@{PhysicalMemory}!size@{size}}
\index{size@{size}!PhysicalMemory@{PhysicalMemory}}
\subsubsection[{size}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf size}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPhysicalMemory_af931a8871310b4dad23f0f0b0f623560}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{physical_8hh}{physical.hh}\item 
mem/\hyperlink{physical_8cc}{physical.cc}\end{DoxyCompactItemize}
