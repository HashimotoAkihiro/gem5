\hypertarget{classX86ISA_1_1Interrupts}{
\section{クラス Interrupts}
\label{classX86ISA_1_1Interrupts}\index{X86ISA::Interrupts@{X86ISA::Interrupts}}
}


{\ttfamily \#include $<$interrupts.hh$>$}Interruptsに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=7cm]{classX86ISA_1_1Interrupts}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef X86LocalApicParams \hyperlink{classX86ISA_1_1Interrupts_a3c48a671abef695247afdd48259ac20a}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classX86ISA_1_1Interrupts_a91c9a4205f98f4fe9cef39ae0641002b}{getInitialApicId} ()
\item 
void \hyperlink{classX86ISA_1_1Interrupts_aa209f4cfe10a4390a73aadcf2d176294}{setCPU} (\hyperlink{classBaseCPU}{BaseCPU} $\ast$newCPU)
\item 
const \hyperlink{classX86ISA_1_1Interrupts_a3c48a671abef695247afdd48259ac20a}{Params} $\ast$ \hyperlink{classX86ISA_1_1Interrupts_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
void \hyperlink{classX86ISA_1_1Interrupts_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classX86ISA_1_1Interrupts_a613ec7d5e1ec64f8d21fec78ae8e568e}{read} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classX86ISA_1_1Interrupts_a4cefab464e72b5dd42c003a0a4341802}{write} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classX86ISA_1_1Interrupts_a3dad3b561a1022eee5fab74df92ce766}{recvMessage} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classX86ISA_1_1Interrupts_a96d1a00beed669f9145d55bc3675d99c}{recvResponse} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classX86ISA_1_1Interrupts_a07d266f0ad36cfec987f7487aa2c54cc}{triggerTimerInterrupt} ()
\item 
\hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classX86ISA_1_1Interrupts_ad86b339471781a0d7634d3c41c6a1c87}{getIntAddrRange} () const 
\item 
\hyperlink{classBaseMasterPort}{BaseMasterPort} \& \hyperlink{classX86ISA_1_1Interrupts_ac66222ec5b6b7beb5d1189c07778bc8a}{getMasterPort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
\hyperlink{classBaseSlavePort}{BaseSlavePort} \& \hyperlink{classX86ISA_1_1Interrupts_a5b5b45105eb4b64567ecea56e5bc30f2}{getSlavePort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classX86ISA_1_1Interrupts_a505f3b9c44f3e911ac16a833289d72d6}{readReg} (\hyperlink{namespaceX86ISA_aaa839fcdf6f426c03c7382fcc29ac649}{ApicRegIndex} miscReg)
\item 
void \hyperlink{classX86ISA_1_1Interrupts_af0c2ac2127c28e0a1e26b9b005e1bfa1}{setReg} (\hyperlink{namespaceX86ISA_aaa839fcdf6f426c03c7382fcc29ac649}{ApicRegIndex} \hyperlink{namespaceX86ISA_aeeb02ad833ab76f3430553ef93213a6b}{reg}, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{namespaceX86ISA_ae13bf1250853ff6b72aabe3c79b587cc}{val})
\item 
void \hyperlink{classX86ISA_1_1Interrupts_aa35a02e092cafc6be88b0eb6afe22937}{setRegNoEffect} (\hyperlink{namespaceX86ISA_aaa839fcdf6f426c03c7382fcc29ac649}{ApicRegIndex} \hyperlink{namespaceX86ISA_aeeb02ad833ab76f3430553ef93213a6b}{reg}, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{namespaceX86ISA_ae13bf1250853ff6b72aabe3c79b587cc}{val})
\item 
\hyperlink{classX86ISA_1_1Interrupts_a3d148759405b99148e0c34750966edb1}{Interrupts} (\hyperlink{classX86ISA_1_1Interrupts_a3c48a671abef695247afdd48259ac20a}{Params} $\ast$\hyperlink{namespaceX86ISA_af675c1d542a25b96e11164b80809a856}{p})
\item 
bool \hyperlink{classX86ISA_1_1Interrupts_af3c66fb49fec598cf78aaec29d764952}{checkInterrupts} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc) const 
\item 
bool \hyperlink{classX86ISA_1_1Interrupts_a764a42ffe59f12449457ca2373515884}{checkInterruptsRaw} () const 
\item 
bool \hyperlink{classX86ISA_1_1Interrupts_a24a3de3c5f8caba5e9aa0d5653a31f63}{hasPendingUnmaskable} () const 
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classX86ISA_1_1Interrupts_ae603c88d759977611d3bcc6e2deb61ae}{getInterrupt} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\item 
void \hyperlink{classX86ISA_1_1Interrupts_a00892e9b06edcba6c3c27454d6235100}{updateIntrInfo} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\item 
virtual void \hyperlink{classX86ISA_1_1Interrupts_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&\hyperlink{namespaceX86ISA_a6b6e6ba763e7eaf46ac5b6372ca98d30}{os})
\item 
virtual void \hyperlink{classX86ISA_1_1Interrupts_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\item 
void \hyperlink{classX86ISA_1_1Interrupts_a24c6c4fbdc0605bcd015ce06f194e4b4}{post} (int int\_\-num, int \hyperlink{namespaceX86ISA_aa7f971ede8ba06dbd8a605007eda1c6f}{index})
\item 
void \hyperlink{classX86ISA_1_1Interrupts_af60c3484087379d0330467d77f6cbaae}{clear} (int int\_\-num, int \hyperlink{namespaceX86ISA_aa7f971ede8ba06dbd8a605007eda1c6f}{index})
\item 
void \hyperlink{classX86ISA_1_1Interrupts_a798729dca95209ecdc609807a653a2bf}{clearAll} ()
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classX86ISA_1_1Interrupts_af3c3b79e5ae32617b335938e6717ea0e}{BitUnion32} (LVTEntry) Bitfield$<$7
\item 
\hyperlink{classX86ISA_1_1Interrupts_a3dcded9d0e81db3da6da13a1ce23ef0c}{EndBitUnion} (LVTEntry) class ApicTimerEvent
\item 
int \hyperlink{classX86ISA_1_1Interrupts_a8d15a5b6dddd42176d18d4952a9c8713}{findRegArrayMSB} (\hyperlink{namespaceX86ISA_aaa839fcdf6f426c03c7382fcc29ac649}{ApicRegIndex} \hyperlink{namespaceX86ISA_a22fd87812cbb48f6d80b6cc7957490cf}{base})
\item 
void \hyperlink{classX86ISA_1_1Interrupts_a9e275b8054220a16ea40b772c0c04d96}{updateIRRV} ()
\item 
void \hyperlink{classX86ISA_1_1Interrupts_af645e39703e6f7ea975409c79fc0f41b}{updateISRV} ()
\item 
void \hyperlink{classX86ISA_1_1Interrupts_ac346555c2f6639d76b0d3730d0e216e2}{setRegArrayBit} (\hyperlink{namespaceX86ISA_aaa839fcdf6f426c03c7382fcc29ac649}{ApicRegIndex} \hyperlink{namespaceX86ISA_a22fd87812cbb48f6d80b6cc7957490cf}{base}, uint8\_\-t \hyperlink{classX86ISA_1_1Interrupts_a7ea82552101f041fad7635b3ed036a84}{vector})
\item 
void \hyperlink{classX86ISA_1_1Interrupts_a6ccfdb5e91c1463b861d5cd6cbb23c46}{clearRegArrayBit} (\hyperlink{namespaceX86ISA_aaa839fcdf6f426c03c7382fcc29ac649}{ApicRegIndex} \hyperlink{namespaceX86ISA_a22fd87812cbb48f6d80b6cc7957490cf}{base}, uint8\_\-t \hyperlink{classX86ISA_1_1Interrupts_a7ea82552101f041fad7635b3ed036a84}{vector})
\item 
bool \hyperlink{classX86ISA_1_1Interrupts_ae3b47da5f3237bda2aa53f8ae3399040}{getRegArrayBit} (\hyperlink{namespaceX86ISA_aaa839fcdf6f426c03c7382fcc29ac649}{ApicRegIndex} \hyperlink{namespaceX86ISA_a22fd87812cbb48f6d80b6cc7957490cf}{base}, uint8\_\-t \hyperlink{classX86ISA_1_1Interrupts_a7ea82552101f041fad7635b3ed036a84}{vector})
\item 
void \hyperlink{classX86ISA_1_1Interrupts_a19885e71b7427a0f49d5b006c1d7fc7f}{requestInterrupt} (uint8\_\-t \hyperlink{classX86ISA_1_1Interrupts_a7ea82552101f041fad7635b3ed036a84}{vector}, uint8\_\-t \hyperlink{classX86ISA_1_1Interrupts_aa6bdaa7818eb499f0dcf848f4ae7d569}{deliveryMode}, bool \hyperlink{namespaceX86ISA_a66adbc3470a30c6702194c0e48f2225d}{level})
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classX86ISA_1_1Interrupts_a707ddf628cd5b3ebd09a9721fbc2d9ee}{regs} \mbox{[}NUM\_\-APIC\_\-REGS\mbox{]}
\item 
\hyperlink{classX86ISA_1_1Interrupts_a7ea82552101f041fad7635b3ed036a84}{vector}
\item 
Bitfield$<$ 10, 8 $>$ \hyperlink{classX86ISA_1_1Interrupts_aa6bdaa7818eb499f0dcf848f4ae7d569}{deliveryMode}
\item 
Bitfield$<$ 12 $>$ \hyperlink{classX86ISA_1_1Interrupts_a7d1baf1ae14e4e146b6809c41c82bde5}{status}
\item 
Bitfield$<$ 13 $>$ \hyperlink{classX86ISA_1_1Interrupts_ae3c9a79ca2272b1906da22919f226af3}{polarity}
\item 
Bitfield$<$ 14 $>$ \hyperlink{classX86ISA_1_1Interrupts_ae074e6e7f5c02b863d4ffe1040e7e7a0}{remoteIRR}
\item 
Bitfield$<$ 15 $>$ \hyperlink{classX86ISA_1_1Interrupts_a1a8acf21e383afeb477a3d8e88b689de}{trigger}
\item 
Bitfield$<$ 16 $>$ \hyperlink{classX86ISA_1_1Interrupts_ac68c9e75c6befae7812cc44b8426a97e}{masked}
\item 
Bitfield$<$ 17 $>$ \hyperlink{classX86ISA_1_1Interrupts_a333fdd71ed0dd6e53569e894f9367ffb}{periodic}
\item 
ApicTimerEvent \hyperlink{classX86ISA_1_1Interrupts_a21b9dbd6985d9ae8c9f83cfccafd7d29}{apicTimerEvent}
\item 
bool \hyperlink{classX86ISA_1_1Interrupts_aeeb4c03ee1caa86828b12a7085f845c9}{pendingSmi}
\item 
uint8\_\-t \hyperlink{classX86ISA_1_1Interrupts_ac62acbbee5adef17b6e0b960b7fb11c5}{smiVector}
\item 
bool \hyperlink{classX86ISA_1_1Interrupts_a1ecac2b1b786eb4f69035a6f1b499297}{pendingNmi}
\item 
uint8\_\-t \hyperlink{classX86ISA_1_1Interrupts_acc5de6934d3b5e99ddfa33038bedc24a}{nmiVector}
\item 
bool \hyperlink{classX86ISA_1_1Interrupts_abd62a9c6790d83c7ae435b181c831471}{pendingExtInt}
\item 
uint8\_\-t \hyperlink{classX86ISA_1_1Interrupts_a916ffa14869566ee27ff80a156e8dade}{extIntVector}
\item 
bool \hyperlink{classX86ISA_1_1Interrupts_a3c53994e08d31f19e9ee2400effd6f5e}{pendingInit}
\item 
uint8\_\-t \hyperlink{classX86ISA_1_1Interrupts_a3e21475b0787502498afda4c6931da0c}{initVector}
\item 
bool \hyperlink{classX86ISA_1_1Interrupts_aa6f1c7032da250f8932f9856dcda20f0}{pendingStartup}
\item 
uint8\_\-t \hyperlink{classX86ISA_1_1Interrupts_af7c23ab865f682ddda21c75170de1126}{startupVector}
\item 
bool \hyperlink{classX86ISA_1_1Interrupts_a46feb43d5deb6cf7bcd3f142d7dc11da}{startedUp}
\item 
bool \hyperlink{classX86ISA_1_1Interrupts_a0725ba3c06fc82e5da0f8800ed5eae68}{pendingUnmaskableInt}
\item 
int \hyperlink{classX86ISA_1_1Interrupts_aef75f0fcb528c2f7cafdf0fa0dcccb40}{pendingIPIs}
\item 
uint8\_\-t \hyperlink{classX86ISA_1_1Interrupts_aded378249f3df42588aede301cf2ae4a}{IRRV}
\item 
uint8\_\-t \hyperlink{classX86ISA_1_1Interrupts_a89802b4867c1ebeb92a413ec679732c9}{ISRV}
\item 
\hyperlink{classBaseCPU}{BaseCPU} $\ast$ \hyperlink{classX86ISA_1_1Interrupts_a7a31ca9fefb2fe821f29a270678912db}{cpu}
\item 
int \hyperlink{classX86ISA_1_1Interrupts_adde09bc135bea2df205ff1ddc88d8fe6}{initialApicId}
\item 
\hyperlink{classX86ISA_1_1IntDevice_1_1IntSlavePort}{IntSlavePort} \hyperlink{classX86ISA_1_1Interrupts_ae8b4c7c51db0b74d5e60b6db0ca0016c}{intSlavePort}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classX86ISA_1_1Interrupts_a3c48a671abef695247afdd48259ac20a}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!Params@{Params}}
\index{Params@{Params}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef X86LocalApicParams {\bf Params}}}
\label{classX86ISA_1_1Interrupts_a3c48a671abef695247afdd48259ac20a}


\hyperlink{classBasicPioDevice_a2845515ac6467f10540747053c8a0449}{BasicPioDevice}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classX86ISA_1_1Interrupts_a3d148759405b99148e0c34750966edb1}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!Interrupts@{Interrupts}}
\index{Interrupts@{Interrupts}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{Interrupts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Interrupts} ({\bf Params} $\ast$ {\em p})}}
\label{classX86ISA_1_1Interrupts_a3d148759405b99148e0c34750966edb1}



\begin{DoxyCode}
611     : BasicPioDevice(p, PageBytes), IntDevice(this, p->int_latency),
612       apicTimerEvent(this),
613       pendingSmi(false), smiVector(0),
614       pendingNmi(false), nmiVector(0),
615       pendingExtInt(false), extIntVector(0),
616       pendingInit(false), initVector(0),
617       pendingStartup(false), startupVector(0),
618       startedUp(false), pendingUnmaskableInt(false),
619       pendingIPIs(0), cpu(NULL),
620       intSlavePort(name() + ".int_slave", this, this)
621 {
622     memset(regs, 0, sizeof(regs));
623     //Set the local apic DFR to the flat model.
624     regs[APIC_DESTINATION_FORMAT] = (uint32_t)(-1);
625     ISRV = 0;
626     IRRV = 0;
627 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classX86ISA_1_1Interrupts_af3c3b79e5ae32617b335938e6717ea0e}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!BitUnion32@{BitUnion32}}
\index{BitUnion32@{BitUnion32}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{BitUnion32}]{\setlength{\rightskip}{0pt plus 5cm}BitUnion32 (LVTEntry)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_af3c3b79e5ae32617b335938e6717ea0e}
\hypertarget{classX86ISA_1_1Interrupts_af3c66fb49fec598cf78aaec29d764952}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!checkInterrupts@{checkInterrupts}}
\index{checkInterrupts@{checkInterrupts}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{checkInterrupts}]{\setlength{\rightskip}{0pt plus 5cm}bool checkInterrupts ({\bf ThreadContext} $\ast$ {\em tc}) const}}
\label{classX86ISA_1_1Interrupts_af3c66fb49fec598cf78aaec29d764952}



\begin{DoxyCode}
632 {
633     RFLAGS rflags = tc->readMiscRegNoEffect(MISCREG_RFLAGS);
634     if (pendingUnmaskableInt) {
635         DPRINTF(LocalApic, "Reported pending unmaskable interrupt.\n");
636         return true;
637     }
638     if (rflags.intf) {
639         if (pendingExtInt) {
640             DPRINTF(LocalApic, "Reported pending external interrupt.\n");
641             return true;
642         }
643         if (IRRV > ISRV && bits(IRRV, 7, 4) >
644                bits(regs[APIC_TASK_PRIORITY], 7, 4)) {
645             DPRINTF(LocalApic, "Reported pending regular interrupt.\n");
646             return true;
647         }
648     }
649     return false;
650 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a764a42ffe59f12449457ca2373515884}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!checkInterruptsRaw@{checkInterruptsRaw}}
\index{checkInterruptsRaw@{checkInterruptsRaw}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{checkInterruptsRaw}]{\setlength{\rightskip}{0pt plus 5cm}bool checkInterruptsRaw () const}}
\label{classX86ISA_1_1Interrupts_a764a42ffe59f12449457ca2373515884}
\hyperlink{classCheck}{Check} if there are pending interrupts without ignoring the interrupts disabled flag.

\begin{DoxyReturn}{戻り値}
true if there are interrupts pending. 
\end{DoxyReturn}



\begin{DoxyCode}
654 {
655     return pendingUnmaskableInt || pendingExtInt ||
656         (IRRV > ISRV && bits(IRRV, 7, 4) >
657          bits(regs[APIC_TASK_PRIORITY], 7, 4));
658 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_af60c3484087379d0330467d77f6cbaae}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!clear@{clear}}
\index{clear@{clear}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{clear}]{\setlength{\rightskip}{0pt plus 5cm}void clear (int {\em int\_\-num}, \/  int {\em index})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_af60c3484087379d0330467d77f6cbaae}



\begin{DoxyCode}
312     {
313         panic("Interrupts::clear unimplemented!\n");
314     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a798729dca95209ecdc609807a653a2bf}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!clearAll@{clearAll}}
\index{clearAll@{clearAll}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{clearAll}]{\setlength{\rightskip}{0pt plus 5cm}void clearAll ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a798729dca95209ecdc609807a653a2bf}



\begin{DoxyCode}
318     {
319         panic("Interrupts::clearAll unimplemented!\n");
320     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a6ccfdb5e91c1463b861d5cd6cbb23c46}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!clearRegArrayBit@{clearRegArrayBit}}
\index{clearRegArrayBit@{clearRegArrayBit}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{clearRegArrayBit}]{\setlength{\rightskip}{0pt plus 5cm}void clearRegArrayBit ({\bf ApicRegIndex} {\em base}, \/  uint8\_\-t {\em vector})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a6ccfdb5e91c1463b861d5cd6cbb23c46}



\begin{DoxyCode}
176     {
177         regs[base + (vector / 32)] &= ~(1 << (vector % 32));
178     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a3dcded9d0e81db3da6da13a1ce23ef0c}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion (LVTEntry)\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a3dcded9d0e81db3da6da13a1ce23ef0c}



\begin{DoxyCode}
95                          : public Event
96     {
97       private:
98         Interrupts *localApic;
99       public:
100         ApicTimerEvent(Interrupts *_localApic) :
101             Event(), localApic(_localApic)
102         {}
103 
104         void process()
105         {
106             assert(localApic);
107             if (localApic->triggerTimerInterrupt()) {
108                 localApic->setReg(APIC_INITIAL_COUNT,
109                         localApic->readReg(APIC_INITIAL_COUNT));
110             }
111         }
112     };
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a8d15a5b6dddd42176d18d4952a9c8713}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!findRegArrayMSB@{findRegArrayMSB}}
\index{findRegArrayMSB@{findRegArrayMSB}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{findRegArrayMSB}]{\setlength{\rightskip}{0pt plus 5cm}int findRegArrayMSB ({\bf ApicRegIndex} {\em base})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a8d15a5b6dddd42176d18d4952a9c8713}



\begin{DoxyCode}
146     {
147         int offset = 7;
148         do {
149             if (regs[base + offset] != 0) {
150                 return offset * 32 + findMsbSet(regs[base + offset]);
151             }
152         } while (offset--);
153         return 0;
154     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a91c9a4205f98f4fe9cef39ae0641002b}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!getInitialApicId@{getInitialApicId}}
\index{getInitialApicId@{getInitialApicId}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{getInitialApicId}]{\setlength{\rightskip}{0pt plus 5cm}int getInitialApicId ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a91c9a4205f98f4fe9cef39ae0641002b}



\begin{DoxyCode}
197 { return initialApicId; }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_ad86b339471781a0d7634d3c41c6a1c87}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!getIntAddrRange@{getIntAddrRange}}
\index{getIntAddrRange@{getIntAddrRange}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{getIntAddrRange}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRangeList} getIntAddrRange () const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_ad86b339471781a0d7634d3c41c6a1c87}


\hyperlink{classX86ISA_1_1IntDevice_ac142ed8f5e7f1e45022f45d316e131a3}{IntDevice}を再定義しています。


\begin{DoxyCode}
373 {
374     AddrRangeList ranges;
375     ranges.push_back(RangeEx(x86InterruptAddress(initialApicId, 0),
376                              x86InterruptAddress(initialApicId, 0) +
377                              PhysAddrAPICRangeSize));
378     return ranges;
379 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_ae603c88d759977611d3bcc6e2deb61ae}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!getInterrupt@{getInterrupt}}
\index{getInterrupt@{getInterrupt}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{getInterrupt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} getInterrupt ({\bf ThreadContext} $\ast$ {\em tc})}}
\label{classX86ISA_1_1Interrupts_ae603c88d759977611d3bcc6e2deb61ae}



\begin{DoxyCode}
662 {
663     assert(checkInterrupts(tc));
664     // These are all probably fairly uncommon, so we'll make them easier to
665     // check for.
666     if (pendingUnmaskableInt) {
667         if (pendingSmi) {
668             DPRINTF(LocalApic, "Generated SMI fault object.\n");
669             return new SystemManagementInterrupt();
670         } else if (pendingNmi) {
671             DPRINTF(LocalApic, "Generated NMI fault object.\n");
672             return new NonMaskableInterrupt(nmiVector);
673         } else if (pendingInit) {
674             DPRINTF(LocalApic, "Generated INIT fault object.\n");
675             return new InitInterrupt(initVector);
676         } else if (pendingStartup) {
677             DPRINTF(LocalApic, "Generating SIPI fault object.\n");
678             return new StartupInterrupt(startupVector);
679         } else {
680             panic("pendingUnmaskableInt set, but no unmaskable "
681                     "ints were pending.\n");
682             return NoFault;
683         }
684     } else if (pendingExtInt) {
685         DPRINTF(LocalApic, "Generated external interrupt fault object.\n");
686         return new ExternalInterrupt(extIntVector);
687     } else {
688         DPRINTF(LocalApic, "Generated regular interrupt fault object.\n");
689         // The only thing left are fixed and lowest priority interrupts.
690         return new ExternalInterrupt(IRRV);
691     }
692 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_ac66222ec5b6b7beb5d1189c07778bc8a}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!getMasterPort@{getMasterPort}}
\index{getMasterPort@{getMasterPort}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{getMasterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseMasterPort}\& getMasterPort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_ac66222ec5b6b7beb5d1189c07778bc8a}
Get a master port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classMemObject_adc4e675e51defbdd1e354dac729d0703}{MemObject}を再定義しています。


\begin{DoxyCode}
238     {
239         if (if_name == "int_master") {
240             return intMasterPort;
241         }
242         return BasicPioDevice::getMasterPort(if_name, idx);
243     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_ae3b47da5f3237bda2aa53f8ae3399040}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!getRegArrayBit@{getRegArrayBit}}
\index{getRegArrayBit@{getRegArrayBit}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{getRegArrayBit}]{\setlength{\rightskip}{0pt plus 5cm}bool getRegArrayBit ({\bf ApicRegIndex} {\em base}, \/  uint8\_\-t {\em vector})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_ae3b47da5f3237bda2aa53f8ae3399040}



\begin{DoxyCode}
182     {
183         return bits(regs[base + (vector / 32)], vector % 5);
184     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a5b5b45105eb4b64567ecea56e5bc30f2}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!getSlavePort@{getSlavePort}}
\index{getSlavePort@{getSlavePort}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{getSlavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseSlavePort}\& getSlavePort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a5b5b45105eb4b64567ecea56e5bc30f2}
Get a slave port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classPioDevice_ac918a145092d7514ebc6dbd952dceafb}{PioDevice}を再定義しています。


\begin{DoxyCode}
247     {
248         if (if_name == "int_slave") {
249             return intSlavePort;
250         }
251         return BasicPioDevice::getSlavePort(if_name, idx);
252     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a24a3de3c5f8caba5e9aa0d5653a31f63}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!hasPendingUnmaskable@{hasPendingUnmaskable}}
\index{hasPendingUnmaskable@{hasPendingUnmaskable}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{hasPendingUnmaskable}]{\setlength{\rightskip}{0pt plus 5cm}bool hasPendingUnmaskable () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a24a3de3c5f8caba5e9aa0d5653a31f63}
\hyperlink{classCheck}{Check} if there are pending unmaskable interrupts.

\begin{DoxyReturn}{戻り値}
true there are unmaskable interrupts pending. 
\end{DoxyReturn}



\begin{DoxyCode}
289 { return pendingUnmaskableInt; }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!init@{init}}
\index{init@{init}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a02fd73d861ef2e4aabb38c0c9ff82947}


\hyperlink{classX86ISA_1_1IntDevice_a02fd73d861ef2e4aabb38c0c9ff82947}{IntDevice}を再定義しています。


\begin{DoxyCode}
312 {
313     //
314     // The local apic must register its address ranges on both its pio
315     // port via the basicpiodevice(piodevice) init() function and its
316     // int port that it inherited from IntDevice.  Note IntDevice is
317     // not a SimObject itself.
318     //
319     BasicPioDevice::init();
320     IntDevice::init();
321 
322     // the slave port has a range so inform the connected master
323     intSlavePort.sendRangeChange();
324 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!params@{params}}
\index{params@{params}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classBasicPioDevice_acd3c3feb78ae7a8f88fe0f110a718dff}{BasicPioDevice}を再定義しています。


\begin{DoxyCode}
208     {
209         return dynamic_cast<const Params *>(_params);
210     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a24c6c4fbdc0605bcd015ce06f194e4b4}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!post@{post}}
\index{post@{post}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{post}]{\setlength{\rightskip}{0pt plus 5cm}void post (int {\em int\_\-num}, \/  int {\em index})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a24c6c4fbdc0605bcd015ce06f194e4b4}



\begin{DoxyCode}
306     {
307         panic("Interrupts::post unimplemented!\n");
308     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a613ec7d5e1ec64f8d21fec78ae8e568e}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!read@{read}}
\index{read@{read}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} read ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a613ec7d5e1ec64f8d21fec78ae8e568e}
Pure virtual function that the device must implement. Called when a read command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_a842312590432036092c422c87a442358}{PioDevice}を実装しています。


\begin{DoxyCode}
213 {
214     Addr offset = pkt->getAddr() - pioAddr;
215     //Make sure we're at least only accessing one register.
216     if ((offset & ~mask(3)) != ((offset + pkt->getSize()) & ~mask(3)))
217         panic("Accessed more than one register at a time in the APIC!\n");
218     ApicRegIndex reg = decodeAddr(offset);
219     uint32_t val = htog(readReg(reg));
220     DPRINTF(LocalApic,
221             "Reading Local APIC register %d at offset %#x as %#x.\n",
222             reg, offset, val);
223     pkt->setData(((uint8_t *)&val) + (offset & mask(3)));
224     pkt->makeAtomicResponse();
225     return pioDelay;
226 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a505f3b9c44f3e911ac16a833289d72d6}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!readReg@{readReg}}
\index{readReg@{readReg}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{readReg}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} readReg ({\bf ApicRegIndex} {\em miscReg})}}
\label{classX86ISA_1_1Interrupts_a505f3b9c44f3e911ac16a833289d72d6}



\begin{DoxyCode}
384 {
385     if (reg >= APIC_TRIGGER_MODE(0) &&
386             reg <= APIC_TRIGGER_MODE(15)) {
387         panic("Local APIC Trigger Mode registers are unimplemented.\n");
388     }
389     switch (reg) {
390       case APIC_ARBITRATION_PRIORITY:
391         panic("Local APIC Arbitration Priority register unimplemented.\n");
392         break;
393       case APIC_PROCESSOR_PRIORITY:
394         panic("Local APIC Processor Priority register unimplemented.\n");
395         break;
396       case APIC_ERROR_STATUS:
397         regs[APIC_INTERNAL_STATE] &= ~ULL(0x1);
398         break;
399       case APIC_CURRENT_COUNT:
400         {
401             if (apicTimerEvent.scheduled()) {
402                 // Compute how many m5 ticks happen per count.
403                 uint64_t ticksPerCount = clockPeriod() *
404                     divideFromConf(regs[APIC_DIVIDE_CONFIGURATION]);
405                 // Compute how many m5 ticks are left.
406                 uint64_t val = apicTimerEvent.when() - curTick();
407                 // Turn that into a count.
408                 val = (val + ticksPerCount - 1) / ticksPerCount;
409                 return val;
410             } else {
411                 return 0;
412             }
413         }
414       default:
415         break;
416     }
417     return regs[reg];
418 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a3dad3b561a1022eee5fab74df92ce766}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!recvMessage@{recvMessage}}
\index{recvMessage@{recvMessage}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{recvMessage}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvMessage ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a3dad3b561a1022eee5fab74df92ce766}


\hyperlink{classX86ISA_1_1IntDevice_a6da97a03af9e80f6f8b865b85a430f35}{IntDevice}を再定義しています。


\begin{DoxyCode}
329 {
330     Addr offset = pkt->getAddr() - x86InterruptAddress(initialApicId, 0);
331     assert(pkt->cmd == MemCmd::MessageReq);
332     switch(offset)
333     {
334       case 0:
335         {
336             TriggerIntMessage message = pkt->get<TriggerIntMessage>();
337             DPRINTF(LocalApic,
338                     "Got Trigger Interrupt message with vector %#x.\n",
339                     message.vector);
340 
341             requestInterrupt(message.vector,
342                     message.deliveryMode, message.trigger);
343         }
344         break;
345       default:
346         panic("Local apic got unknown interrupt message at offset %#x.\n",
347                 offset);
348         break;
349     }
350     pkt->makeAtomicResponse();
351     return pioDelay;
352 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a96d1a00beed669f9145d55bc3675d99c}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!recvResponse@{recvResponse}}
\index{recvResponse@{recvResponse}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{recvResponse}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvResponse ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a96d1a00beed669f9145d55bc3675d99c}


\hyperlink{classX86ISA_1_1IntDevice_ae473b2a0c55e73359b9643810869ca81}{IntDevice}を再定義しています。


\begin{DoxyCode}
357 {
358     assert(!pkt->isError());
359     assert(pkt->cmd == MemCmd::MessageResp);
360     if (--pendingIPIs == 0) {
361         InterruptCommandRegLow low = regs[APIC_INTERRUPT_COMMAND_LOW];
362         // Record that the ICR is now idle.
363         low.deliveryStatus = 0;
364         regs[APIC_INTERRUPT_COMMAND_LOW] = low;
365     }
366     DPRINTF(LocalApic, "ICR is now idle.\n");
367     return 0;
368 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a19885e71b7427a0f49d5b006c1d7fc7f}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!requestInterrupt@{requestInterrupt}}
\index{requestInterrupt@{requestInterrupt}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{requestInterrupt}]{\setlength{\rightskip}{0pt plus 5cm}void requestInterrupt (uint8\_\-t {\em vector}, \/  uint8\_\-t {\em deliveryMode}, \/  bool {\em level})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a19885e71b7427a0f49d5b006c1d7fc7f}



\begin{DoxyCode}
248 {
249     /*
250      * Fixed and lowest-priority delivery mode interrupts are handled
251      * using the IRR/ISR registers, checking against the TPR, etc.
252      * The SMI, NMI, ExtInt, INIT, etc interrupts go straight through.
253      */
254     if (deliveryMode == DeliveryMode::Fixed ||
255             deliveryMode == DeliveryMode::LowestPriority) {
256         DPRINTF(LocalApic, "Interrupt is an %s.\n",
257                 DeliveryMode::names[deliveryMode]);
258         // Queue up the interrupt in the IRR.
259         if (vector > IRRV)
260             IRRV = vector;
261         if (!getRegArrayBit(APIC_INTERRUPT_REQUEST_BASE, vector)) {
262             setRegArrayBit(APIC_INTERRUPT_REQUEST_BASE, vector);
263             if (level) {
264                 setRegArrayBit(APIC_TRIGGER_MODE_BASE, vector);
265             } else {
266                 clearRegArrayBit(APIC_TRIGGER_MODE_BASE, vector);
267             }
268         }
269     } else if (!DeliveryMode::isReserved(deliveryMode)) {
270         DPRINTF(LocalApic, "Interrupt is an %s.\n",
271                 DeliveryMode::names[deliveryMode]);
272         if (deliveryMode == DeliveryMode::SMI && !pendingSmi) {
273             pendingUnmaskableInt = pendingSmi = true;
274             smiVector = vector;
275         } else if (deliveryMode == DeliveryMode::NMI && !pendingNmi) {
276             pendingUnmaskableInt = pendingNmi = true;
277             nmiVector = vector;
278         } else if (deliveryMode == DeliveryMode::ExtInt && !pendingExtInt) {
279             pendingExtInt = true;
280             extIntVector = vector;
281         } else if (deliveryMode == DeliveryMode::INIT && !pendingInit) {
282             pendingUnmaskableInt = pendingInit = true;
283             initVector = vector;
284         } else if (deliveryMode == DeliveryMode::SIPI &&
285                 !pendingStartup && !startedUp) {
286             pendingUnmaskableInt = pendingStartup = true;
287             startupVector = vector;
288         }
289     }
290     if (FullSystem)
291         cpu->wakeup();
292 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a53e036786d17361be4c7320d39c99b84}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!serialize@{serialize}}
\index{serialize@{serialize}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a53e036786d17361be4c7320d39c99b84}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。


\begin{DoxyCode}
731 {
732     SERIALIZE_ARRAY(regs, NUM_APIC_REGS);
733     SERIALIZE_SCALAR(pendingSmi);
734     SERIALIZE_SCALAR(smiVector);
735     SERIALIZE_SCALAR(pendingNmi);
736     SERIALIZE_SCALAR(nmiVector);
737     SERIALIZE_SCALAR(pendingExtInt);
738     SERIALIZE_SCALAR(extIntVector);
739     SERIALIZE_SCALAR(pendingInit);
740     SERIALIZE_SCALAR(initVector);
741     SERIALIZE_SCALAR(pendingStartup);
742     SERIALIZE_SCALAR(startupVector);
743     SERIALIZE_SCALAR(startedUp);
744     SERIALIZE_SCALAR(pendingUnmaskableInt);
745     SERIALIZE_SCALAR(pendingIPIs);
746     SERIALIZE_SCALAR(IRRV);
747     SERIALIZE_SCALAR(ISRV);
748     bool apicTimerEventScheduled = apicTimerEvent.scheduled();
749     SERIALIZE_SCALAR(apicTimerEventScheduled);
750     Tick apicTimerEventTick = apicTimerEvent.when();
751     SERIALIZE_SCALAR(apicTimerEventTick);
752 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_aa209f4cfe10a4390a73aadcf2d176294}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!setCPU@{setCPU}}
\index{setCPU@{setCPU}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{setCPU}]{\setlength{\rightskip}{0pt plus 5cm}void setCPU ({\bf BaseCPU} $\ast$ {\em newCPU})}}
\label{classX86ISA_1_1Interrupts_aa209f4cfe10a4390a73aadcf2d176294}



\begin{DoxyCode}
297 {
298     assert(newCPU);
299     if (cpu != NULL && cpu->cpuId() != newCPU->cpuId()) {
300         panic("Local APICs can't be moved between CPUs"
301                 " with different IDs.\n");
302     }
303     cpu = newCPU;
304     initialApicId = cpu->cpuId();
305     regs[APIC_ID] = (initialApicId << 24);
306     pioAddr = x86LocalAPICAddress(initialApicId, 0);
307 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_af0c2ac2127c28e0a1e26b9b005e1bfa1}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!setReg@{setReg}}
\index{setReg@{setReg}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{setReg}]{\setlength{\rightskip}{0pt plus 5cm}void setReg ({\bf ApicRegIndex} {\em reg}, \/  {\bf uint32\_\-t} {\em val})}}
\label{classX86ISA_1_1Interrupts_af0c2ac2127c28e0a1e26b9b005e1bfa1}



\begin{DoxyCode}
422 {
423     uint32_t newVal = val;
424     if (reg >= APIC_IN_SERVICE(0) &&
425             reg <= APIC_IN_SERVICE(15)) {
426         panic("Local APIC In-Service registers are unimplemented.\n");
427     }
428     if (reg >= APIC_TRIGGER_MODE(0) &&
429             reg <= APIC_TRIGGER_MODE(15)) {
430         panic("Local APIC Trigger Mode registers are unimplemented.\n");
431     }
432     if (reg >= APIC_INTERRUPT_REQUEST(0) &&
433             reg <= APIC_INTERRUPT_REQUEST(15)) {
434         panic("Local APIC Interrupt Request registers "
435                 "are unimplemented.\n");
436     }
437     switch (reg) {
438       case APIC_ID:
439         newVal = val & 0xFF;
440         break;
441       case APIC_VERSION:
442         // The Local APIC Version register is read only.
443         return;
444       case APIC_TASK_PRIORITY:
445         newVal = val & 0xFF;
446         break;
447       case APIC_ARBITRATION_PRIORITY:
448         panic("Local APIC Arbitration Priority register unimplemented.\n");
449         break;
450       case APIC_PROCESSOR_PRIORITY:
451         panic("Local APIC Processor Priority register unimplemented.\n");
452         break;
453       case APIC_EOI:
454         // Remove the interrupt that just completed from the local apic state.
455         clearRegArrayBit(APIC_IN_SERVICE_BASE, ISRV);
456         updateISRV();
457         return;
458       case APIC_LOGICAL_DESTINATION:
459         newVal = val & 0xFF000000;
460         break;
461       case APIC_DESTINATION_FORMAT:
462         newVal = val | 0x0FFFFFFF;
463         break;
464       case APIC_SPURIOUS_INTERRUPT_VECTOR:
465         regs[APIC_INTERNAL_STATE] &= ~ULL(1 << 1);
466         regs[APIC_INTERNAL_STATE] |= val & (1 << 8);
467         if (val & (1 << 9))
468             warn("Focus processor checking not implemented.\n");
469         break;
470       case APIC_ERROR_STATUS:
471         {
472             if (regs[APIC_INTERNAL_STATE] & 0x1) {
473                 regs[APIC_INTERNAL_STATE] &= ~ULL(0x1);
474                 newVal = 0;
475             } else {
476                 regs[APIC_INTERNAL_STATE] |= ULL(0x1);
477                 return;
478             }
479 
480         }
481         break;
482       case APIC_INTERRUPT_COMMAND_LOW:
483         {
484             InterruptCommandRegLow low = regs[APIC_INTERRUPT_COMMAND_LOW];
485             // Check if we're already sending an IPI.
486             if (low.deliveryStatus) {
487                 newVal = low;
488                 break;
489             }
490             low = val;
491             InterruptCommandRegHigh high = regs[APIC_INTERRUPT_COMMAND_HIGH];
492             // Record that an IPI is being sent.
493             low.deliveryStatus = 1;
494             TriggerIntMessage message = 0;
495             message.destination = high.destination;
496             message.vector = low.vector;
497             message.deliveryMode = low.deliveryMode;
498             message.destMode = low.destMode;
499             message.level = low.level;
500             message.trigger = low.trigger;
501             bool timing(sys->isTimingMode());
502             // Be careful no updates of the delivery status bit get lost.
503             regs[APIC_INTERRUPT_COMMAND_LOW] = low;
504             ApicList apics;
505             int numContexts = sys->numContexts();
506             switch (low.destShorthand) {
507               case 0:
508                 if (message.deliveryMode == DeliveryMode::LowestPriority) {
509                     panic("Lowest priority delivery mode "
510                             "IPIs aren't implemented.\n");
511                 }
512                 if (message.destMode == 1) {
513                     int dest = message.destination;
514                     hack_once("Assuming logical destinations are 1 << id.\n");
515                     for (int i = 0; i < numContexts; i++) {
516                         if (dest & 0x1)
517                             apics.push_back(i);
518                         dest = dest >> 1;
519                     }
520                 } else {
521                     if (message.destination == 0xFF) {
522                         for (int i = 0; i < numContexts; i++) {
523                             if (i == initialApicId) {
524                                 requestInterrupt(message.vector,
525                                         message.deliveryMode, message.trigger);
526                             } else {
527                                 apics.push_back(i);
528                             }
529                         }
530                     } else {
531                         if (message.destination == initialApicId) {
532                             requestInterrupt(message.vector,
533                                     message.deliveryMode, message.trigger);
534                         } else {
535                             apics.push_back(message.destination);
536                         }
537                     }
538                 }
539                 break;
540               case 1:
541                 newVal = val;
542                 requestInterrupt(message.vector,
543                         message.deliveryMode, message.trigger);
544                 break;
545               case 2:
546                 requestInterrupt(message.vector,
547                         message.deliveryMode, message.trigger);
548                 // Fall through
549               case 3:
550                 {
551                     for (int i = 0; i < numContexts; i++) {
552                         if (i != initialApicId) {
553                             apics.push_back(i);
554                         }
555                     }
556                 }
557                 break;
558             }
559             pendingIPIs += apics.size();
560             intMasterPort.sendMessage(apics, message, timing);
561             newVal = regs[APIC_INTERRUPT_COMMAND_LOW];
562         }
563         break;
564       case APIC_LVT_TIMER:
565       case APIC_LVT_THERMAL_SENSOR:
566       case APIC_LVT_PERFORMANCE_MONITORING_COUNTERS:
567       case APIC_LVT_LINT0:
568       case APIC_LVT_LINT1:
569       case APIC_LVT_ERROR:
570         {
571             uint64_t readOnlyMask = (1 << 12) | (1 << 14);
572             newVal = (val & ~readOnlyMask) |
573                      (regs[reg] & readOnlyMask);
574         }
575         break;
576       case APIC_INITIAL_COUNT:
577         {
578             newVal = bits(val, 31, 0);
579             // Compute how many timer ticks we're being programmed for.
580             uint64_t newCount = newVal *
581                 (divideFromConf(regs[APIC_DIVIDE_CONFIGURATION]));
582             // Schedule on the edge of the next tick plus the new count.
583             Tick offset = curTick() % clockPeriod();
584             if (offset) {
585                 reschedule(apicTimerEvent,
586                            curTick() + (newCount + 1) *
587                            clockPeriod() - offset, true);
588             } else {
589                 if (newCount)
590                     reschedule(apicTimerEvent,
591                                curTick() + newCount *
592                                clockPeriod(), true);
593             }
594         }
595         break;
596       case APIC_CURRENT_COUNT:
597         //Local APIC Current Count register is read only.
598         return;
599       case APIC_DIVIDE_CONFIGURATION:
600         newVal = val & 0xB;
601         break;
602       default:
603         break;
604     }
605     regs[reg] = newVal;
606     return;
607 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_ac346555c2f6639d76b0d3730d0e216e2}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!setRegArrayBit@{setRegArrayBit}}
\index{setRegArrayBit@{setRegArrayBit}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{setRegArrayBit}]{\setlength{\rightskip}{0pt plus 5cm}void setRegArrayBit ({\bf ApicRegIndex} {\em base}, \/  uint8\_\-t {\em vector})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_ac346555c2f6639d76b0d3730d0e216e2}



\begin{DoxyCode}
170     {
171         regs[base + (vector / 32)] |= (1 << (vector % 32));
172     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_aa35a02e092cafc6be88b0eb6afe22937}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!setRegNoEffect@{setRegNoEffect}}
\index{setRegNoEffect@{setRegNoEffect}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{setRegNoEffect}]{\setlength{\rightskip}{0pt plus 5cm}void setRegNoEffect ({\bf ApicRegIndex} {\em reg}, \/  {\bf uint32\_\-t} {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_aa35a02e092cafc6be88b0eb6afe22937}



\begin{DoxyCode}
262     {
263         regs[reg] = val;
264     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a07d266f0ad36cfec987f7487aa2c54cc}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!triggerTimerInterrupt@{triggerTimerInterrupt}}
\index{triggerTimerInterrupt@{triggerTimerInterrupt}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{triggerTimerInterrupt}]{\setlength{\rightskip}{0pt plus 5cm}bool triggerTimerInterrupt ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a07d266f0ad36cfec987f7487aa2c54cc}



\begin{DoxyCode}
227     {
228         LVTEntry entry = regs[APIC_LVT_TIMER];
229         if (!entry.masked)
230             requestInterrupt(entry.vector, entry.deliveryMode, entry.trigger);
231         return entry.periodic;
232     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_af22e5d6d660b97db37003ac61ac4ee49}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_af22e5d6d660b97db37003ac61ac4ee49}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。


\begin{DoxyCode}
756 {
757     UNSERIALIZE_ARRAY(regs, NUM_APIC_REGS);
758     UNSERIALIZE_SCALAR(pendingSmi);
759     UNSERIALIZE_SCALAR(smiVector);
760     UNSERIALIZE_SCALAR(pendingNmi);
761     UNSERIALIZE_SCALAR(nmiVector);
762     UNSERIALIZE_SCALAR(pendingExtInt);
763     UNSERIALIZE_SCALAR(extIntVector);
764     UNSERIALIZE_SCALAR(pendingInit);
765     UNSERIALIZE_SCALAR(initVector);
766     UNSERIALIZE_SCALAR(pendingStartup);
767     UNSERIALIZE_SCALAR(startupVector);
768     UNSERIALIZE_SCALAR(startedUp);
769     UNSERIALIZE_SCALAR(pendingUnmaskableInt);
770     UNSERIALIZE_SCALAR(pendingIPIs);
771     UNSERIALIZE_SCALAR(IRRV);
772     UNSERIALIZE_SCALAR(ISRV);
773     bool apicTimerEventScheduled;
774     UNSERIALIZE_SCALAR(apicTimerEventScheduled);
775     if (apicTimerEventScheduled) {
776         Tick apicTimerEventTick;
777         UNSERIALIZE_SCALAR(apicTimerEventTick);
778         if (apicTimerEvent.scheduled()) {
779             reschedule(apicTimerEvent, apicTimerEventTick, true);
780         } else {
781             schedule(apicTimerEvent, apicTimerEventTick);
782         }
783     }
784 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a00892e9b06edcba6c3c27454d6235100}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!updateIntrInfo@{updateIntrInfo}}
\index{updateIntrInfo@{updateIntrInfo}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{updateIntrInfo}]{\setlength{\rightskip}{0pt plus 5cm}void updateIntrInfo ({\bf ThreadContext} $\ast$ {\em tc})}}
\label{classX86ISA_1_1Interrupts_a00892e9b06edcba6c3c27454d6235100}



\begin{DoxyCode}
696 {
697     assert(checkInterrupts(tc));
698     if (pendingUnmaskableInt) {
699         if (pendingSmi) {
700             DPRINTF(LocalApic, "SMI sent to core.\n");
701             pendingSmi = false;
702         } else if (pendingNmi) {
703             DPRINTF(LocalApic, "NMI sent to core.\n");
704             pendingNmi = false;
705         } else if (pendingInit) {
706             DPRINTF(LocalApic, "Init sent to core.\n");
707             pendingInit = false;
708             startedUp = false;
709         } else if (pendingStartup) {
710             DPRINTF(LocalApic, "SIPI sent to core.\n");
711             pendingStartup = false;
712             startedUp = true;
713         }
714         if (!(pendingSmi || pendingNmi || pendingInit || pendingStartup))
715             pendingUnmaskableInt = false;
716     } else if (pendingExtInt) {
717         pendingExtInt = false;
718     } else {
719         DPRINTF(LocalApic, "Interrupt %d sent to core.\n", IRRV);
720         // Mark the interrupt as "in service".
721         ISRV = IRRV;
722         setRegArrayBit(APIC_IN_SERVICE_BASE, ISRV);
723         // Clear it out of the IRR.
724         clearRegArrayBit(APIC_INTERRUPT_REQUEST_BASE, IRRV);
725         updateIRRV();
726     }
727 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a9e275b8054220a16ea40b772c0c04d96}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!updateIRRV@{updateIRRV}}
\index{updateIRRV@{updateIRRV}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{updateIRRV}]{\setlength{\rightskip}{0pt plus 5cm}void updateIRRV ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a9e275b8054220a16ea40b772c0c04d96}



\begin{DoxyCode}
158     {
159         IRRV = findRegArrayMSB(APIC_INTERRUPT_REQUEST_BASE);
160     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_af645e39703e6f7ea975409c79fc0f41b}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!updateISRV@{updateISRV}}
\index{updateISRV@{updateISRV}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{updateISRV}]{\setlength{\rightskip}{0pt plus 5cm}void updateISRV ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_af645e39703e6f7ea975409c79fc0f41b}



\begin{DoxyCode}
164     {
165         ISRV = findRegArrayMSB(APIC_IN_SERVICE_BASE);
166     }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Interrupts_a4cefab464e72b5dd42c003a0a4341802}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!write@{write}}
\index{write@{write}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} write ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a4cefab464e72b5dd42c003a0a4341802}
Pure virtual function that the device must implement. Called when a write command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_afe8371668d023bb2516b286e5e399b6f}{PioDevice}を実装しています。


\begin{DoxyCode}
230 {
231     Addr offset = pkt->getAddr() - pioAddr;
232     //Make sure we're at least only accessing one register.
233     if ((offset & ~mask(3)) != ((offset + pkt->getSize()) & ~mask(3)))
234         panic("Accessed more than one register at a time in the APIC!\n");
235     ApicRegIndex reg = decodeAddr(offset);
236     uint32_t val = regs[reg];
237     pkt->writeData(((uint8_t *)&val) + (offset & mask(3)));
238     DPRINTF(LocalApic,
239             "Writing Local APIC register %d at offset %#x as %#x.\n",
240             reg, offset, gtoh(val));
241     setReg(reg, gtoh(val));
242     pkt->makeAtomicResponse();
243     return pioDelay;
244 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classX86ISA_1_1Interrupts_a21b9dbd6985d9ae8c9f83cfccafd7d29}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!apicTimerEvent@{apicTimerEvent}}
\index{apicTimerEvent@{apicTimerEvent}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{apicTimerEvent}]{\setlength{\rightskip}{0pt plus 5cm}ApicTimerEvent {\bf apicTimerEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a21b9dbd6985d9ae8c9f83cfccafd7d29}
\hypertarget{classX86ISA_1_1Interrupts_a7a31ca9fefb2fe821f29a270678912db}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!cpu@{cpu}}
\index{cpu@{cpu}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseCPU}$\ast$ {\bf cpu}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a7a31ca9fefb2fe821f29a270678912db}
\hypertarget{classX86ISA_1_1Interrupts_aa6bdaa7818eb499f0dcf848f4ae7d569}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!deliveryMode@{deliveryMode}}
\index{deliveryMode@{deliveryMode}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{deliveryMode}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$10, 8$>$ {\bf deliveryMode}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_aa6bdaa7818eb499f0dcf848f4ae7d569}
\hypertarget{classX86ISA_1_1Interrupts_a916ffa14869566ee27ff80a156e8dade}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!extIntVector@{extIntVector}}
\index{extIntVector@{extIntVector}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{extIntVector}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf extIntVector}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a916ffa14869566ee27ff80a156e8dade}
\hypertarget{classX86ISA_1_1Interrupts_adde09bc135bea2df205ff1ddc88d8fe6}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!initialApicId@{initialApicId}}
\index{initialApicId@{initialApicId}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{initialApicId}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf initialApicId}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_adde09bc135bea2df205ff1ddc88d8fe6}
\hypertarget{classX86ISA_1_1Interrupts_a3e21475b0787502498afda4c6931da0c}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!initVector@{initVector}}
\index{initVector@{initVector}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{initVector}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf initVector}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a3e21475b0787502498afda4c6931da0c}
\hypertarget{classX86ISA_1_1Interrupts_ae8b4c7c51db0b74d5e60b6db0ca0016c}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!intSlavePort@{intSlavePort}}
\index{intSlavePort@{intSlavePort}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{intSlavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IntSlavePort} {\bf intSlavePort}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_ae8b4c7c51db0b74d5e60b6db0ca0016c}
\hypertarget{classX86ISA_1_1Interrupts_aded378249f3df42588aede301cf2ae4a}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!IRRV@{IRRV}}
\index{IRRV@{IRRV}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{IRRV}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf IRRV}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_aded378249f3df42588aede301cf2ae4a}
\hypertarget{classX86ISA_1_1Interrupts_a89802b4867c1ebeb92a413ec679732c9}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!ISRV@{ISRV}}
\index{ISRV@{ISRV}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{ISRV}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf ISRV}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a89802b4867c1ebeb92a413ec679732c9}
\hypertarget{classX86ISA_1_1Interrupts_ac68c9e75c6befae7812cc44b8426a97e}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!masked@{masked}}
\index{masked@{masked}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{masked}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$16$>$ {\bf masked}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_ac68c9e75c6befae7812cc44b8426a97e}
\hypertarget{classX86ISA_1_1Interrupts_acc5de6934d3b5e99ddfa33038bedc24a}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!nmiVector@{nmiVector}}
\index{nmiVector@{nmiVector}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{nmiVector}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf nmiVector}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_acc5de6934d3b5e99ddfa33038bedc24a}
\hypertarget{classX86ISA_1_1Interrupts_abd62a9c6790d83c7ae435b181c831471}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!pendingExtInt@{pendingExtInt}}
\index{pendingExtInt@{pendingExtInt}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{pendingExtInt}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf pendingExtInt}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_abd62a9c6790d83c7ae435b181c831471}
\hypertarget{classX86ISA_1_1Interrupts_a3c53994e08d31f19e9ee2400effd6f5e}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!pendingInit@{pendingInit}}
\index{pendingInit@{pendingInit}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{pendingInit}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf pendingInit}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a3c53994e08d31f19e9ee2400effd6f5e}
\hypertarget{classX86ISA_1_1Interrupts_aef75f0fcb528c2f7cafdf0fa0dcccb40}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!pendingIPIs@{pendingIPIs}}
\index{pendingIPIs@{pendingIPIs}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{pendingIPIs}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf pendingIPIs}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_aef75f0fcb528c2f7cafdf0fa0dcccb40}
\hypertarget{classX86ISA_1_1Interrupts_a1ecac2b1b786eb4f69035a6f1b499297}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!pendingNmi@{pendingNmi}}
\index{pendingNmi@{pendingNmi}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{pendingNmi}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf pendingNmi}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a1ecac2b1b786eb4f69035a6f1b499297}
\hypertarget{classX86ISA_1_1Interrupts_aeeb4c03ee1caa86828b12a7085f845c9}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!pendingSmi@{pendingSmi}}
\index{pendingSmi@{pendingSmi}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{pendingSmi}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf pendingSmi}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_aeeb4c03ee1caa86828b12a7085f845c9}
\hypertarget{classX86ISA_1_1Interrupts_aa6f1c7032da250f8932f9856dcda20f0}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!pendingStartup@{pendingStartup}}
\index{pendingStartup@{pendingStartup}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{pendingStartup}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf pendingStartup}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_aa6f1c7032da250f8932f9856dcda20f0}
\hypertarget{classX86ISA_1_1Interrupts_a0725ba3c06fc82e5da0f8800ed5eae68}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!pendingUnmaskableInt@{pendingUnmaskableInt}}
\index{pendingUnmaskableInt@{pendingUnmaskableInt}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{pendingUnmaskableInt}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf pendingUnmaskableInt}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a0725ba3c06fc82e5da0f8800ed5eae68}
\hypertarget{classX86ISA_1_1Interrupts_a333fdd71ed0dd6e53569e894f9367ffb}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!periodic@{periodic}}
\index{periodic@{periodic}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{periodic}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$17$>$ {\bf periodic}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a333fdd71ed0dd6e53569e894f9367ffb}
\hypertarget{classX86ISA_1_1Interrupts_ae3c9a79ca2272b1906da22919f226af3}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!polarity@{polarity}}
\index{polarity@{polarity}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{polarity}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$13$>$ {\bf polarity}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_ae3c9a79ca2272b1906da22919f226af3}
\hypertarget{classX86ISA_1_1Interrupts_a707ddf628cd5b3ebd09a9721fbc2d9ee}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!regs@{regs}}
\index{regs@{regs}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{regs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf regs}\mbox{[}NUM\_\-APIC\_\-REGS\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a707ddf628cd5b3ebd09a9721fbc2d9ee}
\hypertarget{classX86ISA_1_1Interrupts_ae074e6e7f5c02b863d4ffe1040e7e7a0}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!remoteIRR@{remoteIRR}}
\index{remoteIRR@{remoteIRR}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{remoteIRR}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$14$>$ {\bf remoteIRR}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_ae074e6e7f5c02b863d4ffe1040e7e7a0}
\hypertarget{classX86ISA_1_1Interrupts_ac62acbbee5adef17b6e0b960b7fb11c5}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!smiVector@{smiVector}}
\index{smiVector@{smiVector}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{smiVector}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf smiVector}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_ac62acbbee5adef17b6e0b960b7fb11c5}
\hypertarget{classX86ISA_1_1Interrupts_a46feb43d5deb6cf7bcd3f142d7dc11da}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!startedUp@{startedUp}}
\index{startedUp@{startedUp}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{startedUp}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf startedUp}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a46feb43d5deb6cf7bcd3f142d7dc11da}
\hypertarget{classX86ISA_1_1Interrupts_af7c23ab865f682ddda21c75170de1126}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!startupVector@{startupVector}}
\index{startupVector@{startupVector}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{startupVector}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf startupVector}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_af7c23ab865f682ddda21c75170de1126}
\hypertarget{classX86ISA_1_1Interrupts_a7d1baf1ae14e4e146b6809c41c82bde5}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!status@{status}}
\index{status@{status}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{status}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$12$>$ {\bf status}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a7d1baf1ae14e4e146b6809c41c82bde5}
\hypertarget{classX86ISA_1_1Interrupts_a1a8acf21e383afeb477a3d8e88b689de}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!trigger@{trigger}}
\index{trigger@{trigger}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{trigger}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$15$>$ {\bf trigger}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a1a8acf21e383afeb477a3d8e88b689de}
\hypertarget{classX86ISA_1_1Interrupts_a7ea82552101f041fad7635b3ed036a84}{
\index{X86ISA::Interrupts@{X86ISA::Interrupts}!vector@{vector}}
\index{vector@{vector}!X86ISA::Interrupts@{X86ISA::Interrupts}}
\subsubsection[{vector}]{\setlength{\rightskip}{0pt plus 5cm}{\bf vector}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Interrupts_a7ea82552101f041fad7635b3ed036a84}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/x86/\hyperlink{x86_2interrupts_8hh}{interrupts.hh}\item 
arch/x86/\hyperlink{x86_2interrupts_8cc}{interrupts.cc}\end{DoxyCompactItemize}
