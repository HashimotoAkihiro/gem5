\hypertarget{classEventQueue}{
\section{クラス EventQueue}
\label{classEventQueue}\index{EventQueue@{EventQueue}}
}


{\ttfamily \#include $<$eventq.hh$>$}EventQueueに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classEventQueue}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classEventQueue_1_1ScopedMigration}{ScopedMigration}
\item 
class \hyperlink{classEventQueue_1_1ScopedRelease}{ScopedRelease}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classEventQueue_a6034f8afa29a6178a4b6d0e371344d0d}{EventQueue} (const std::string \&n)
\item 
virtual const std::string \hyperlink{classEventQueue_adbcff144e5e199d332a1352af1798148}{name} () const 
\item 
void \hyperlink{classEventQueue_a413b79e026328fa4210d327d1958bd12}{name} (const std::string \&st)
\item 
void \hyperlink{classEventQueue_a6e13c0d68fbc26df6eff27313813b8a4}{schedule} (\hyperlink{classEvent}{Event} $\ast$event, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} when, bool global=false)
\item 
void \hyperlink{classEventQueue_ab1b8fc2b2605fdc1d88bf07a86e1fe07}{deschedule} (\hyperlink{classEvent}{Event} $\ast$event)
\item 
void \hyperlink{classEventQueue_a676294f5f01031f3dfdf956185390db8}{reschedule} (\hyperlink{classEvent}{Event} $\ast$event, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} when, bool always=false)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classEventQueue_ac7fc06f25478db3060a43a096e023243}{nextTick} () const 
\item 
void \hyperlink{classEventQueue_abc2f41fbb4828612a2637268ab8ce640}{setCurTick} (\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} newVal)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classEventQueue_ab9e4d6c1f3218aee0ff70854de959a6c}{getCurTick} ()
\item 
Event $\ast$ \hyperlink{classEventQueue_a95b9c78d6fb18e716e5d13362b609798}{serviceOne} ()
\item 
void \hyperlink{classEventQueue_adc925eabe90846085072915cc6c544c2}{serviceEvents} (\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} when)
\item 
bool \hyperlink{classEventQueue_ac6e61de369e994009e36f344f99c15ad}{empty} () const 
\item 
void \hyperlink{classEventQueue_a4a4fecb6d7cd9d0b8eb6579eee183af8}{dump} () const 
\item 
bool \hyperlink{classEventQueue_a66392764e022762d90e80efbee0500b2}{debugVerify} () const 
\item 
void \hyperlink{classEventQueue_a2f9d0ed8258183804bc764aa3b859f70}{handleAsyncInsertions} ()
\begin{DoxyCompactList}\small\item\em Function for moving events from the async\_\-queue to the main queue. \item\end{DoxyCompactList}\item 
Event $\ast$ \hyperlink{classEventQueue_a1c4b36385e86f178f625f84d95cb6778}{replaceHead} (Event $\ast$s)
\item 
virtual void \hyperlink{classEventQueue_ad6272f80ae37e8331e3969b3f072a801}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classEventQueue_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\begin{Indent}{\bf }\par
{\em \label{_amgrpd41d8cd98f00b204e9800998ecf8427e}
 }\begin{DoxyCompactItemize}
\item 
void \hyperlink{classEventQueue_aa81aed607133209dade63a226818224d}{lock} ()
\item 
void \hyperlink{classEventQueue_a9278be8203e1c42e2619179882ae4403}{unlock} ()
\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classEventQueue_ad8e469f292d876af9e2ec380e8e7e51e}{insert} (Event $\ast$event)
\item 
void \hyperlink{classEventQueue_a3f3ea68ae4a3b85263c9e223efcce2f6}{remove} (Event $\ast$event)
\item 
void \hyperlink{classEventQueue_aadb31d9952f03cb2a934f93cac304153}{asyncInsert} (Event $\ast$event)
\item 
\hyperlink{classEventQueue_aac902b23c2f4ad571d6229b56ea09d0b}{EventQueue} (const \hyperlink{classEventQueue}{EventQueue} \&)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
std::string \hyperlink{classEventQueue_acdd07b78b47375ca2a51a7a956b1697f}{objName}
\item 
\hyperlink{classEvent}{Event} $\ast$ \hyperlink{classEventQueue_a08321f57dbffd90b5b365a6d53bb2933}{head}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classEventQueue_a09b29d670564770f8cde7490c4fa4ebb}{\_\-curTick}
\item 
std::mutex $\ast$ \hyperlink{classEventQueue_a7d6bb496422e204e32492a7012a44b66}{async\_\-queue\_\-mutex}
\begin{DoxyCompactList}\small\item\em Mutex to protect async queue. \item\end{DoxyCompactList}\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classEvent}{Event} $\ast$ $>$ \hyperlink{classEventQueue_a9c9b5322e34950b9d27abca2b8207ca9}{async\_\-queue}
\begin{DoxyCompactList}\small\item\em List of events added by other threads to this event queue. \item\end{DoxyCompactList}\item 
std::mutex \hyperlink{classEventQueue_acfc3095049c7deadb02a9eee0ec54a13}{service\_\-mutex}
\end{DoxyCompactItemize}


\subsection{説明}
Queue of events sorted in time order

Events are scheduled (inserted into the event queue) using the \hyperlink{classEventQueue_a6e13c0d68fbc26df6eff27313813b8a4}{schedule()} method. This method either inserts a {\itshape synchronous\/} or {\itshape asynchronous\/} event.

Synchronous events are scheduled using \hyperlink{classEventQueue_a6e13c0d68fbc26df6eff27313813b8a4}{schedule()} method with the argument 'global' set to false (default). This should only be done from a thread holding the event queue lock (\hyperlink{classEventQueue_acfc3095049c7deadb02a9eee0ec54a13}{EventQueue::service\_\-mutex}). The lock is always held when an event handler is called, it can therefore always insert events into its own event queue unless it voluntarily releases the lock.

Events can be scheduled across thread (and event queue borders) by either scheduling asynchronous events or taking the target event queue's lock. However, the lock should {\itshape never\/} be taken directly since this is likely to cause deadlocks. Instead, code that needs to schedule events in other event queues should temporarily release its own queue and lock the new queue. This prevents deadlocks since a single thread never owns more than one event queue lock. This functionality is provided by the \hyperlink{classEventQueue_1_1ScopedMigration}{ScopedMigration} helper class. Note that temporarily migrating between event queues can make the simulation non-\/deterministic, it should therefore be limited to cases where that can be tolerated (e.g., handling asynchronous IO or fast-\/forwarding in KVM).

Asynchronous events can also be scheduled using the normal \hyperlink{classEventQueue_a6e13c0d68fbc26df6eff27313813b8a4}{schedule()} method with the 'global' parameter set to true. Unlike the previous queue migration strategy, this strategy is fully deterministic. This causes the event to be inserted in a separate queue of asynchronous events (async\_\-queue), which is merged main event queue at the end of each simulation quantum (by calling the \hyperlink{classEventQueue_a2f9d0ed8258183804bc764aa3b859f70}{handleAsyncInsertions()} method). Note that this implies that such events must happen at least one simulation quantum into the future, otherwise they risk being scheduled in the past by \hyperlink{classEventQueue_a2f9d0ed8258183804bc764aa3b859f70}{handleAsyncInsertions()}. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classEventQueue_aac902b23c2f4ad571d6229b56ea09d0b}{
\index{EventQueue@{EventQueue}!EventQueue@{EventQueue}}
\index{EventQueue@{EventQueue}!EventQueue@{EventQueue}}
\subsubsection[{EventQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventQueue} (const {\bf EventQueue} \&)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classEventQueue_aac902b23c2f4ad571d6229b56ea09d0b}
\hypertarget{classEventQueue_a6034f8afa29a6178a4b6d0e371344d0d}{
\index{EventQueue@{EventQueue}!EventQueue@{EventQueue}}
\index{EventQueue@{EventQueue}!EventQueue@{EventQueue}}
\subsubsection[{EventQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventQueue} (const std::string \& {\em n})}}
\label{classEventQueue_a6034f8afa29a6178a4b6d0e371344d0d}


\subsection{関数}
\hypertarget{classEventQueue_aadb31d9952f03cb2a934f93cac304153}{
\index{EventQueue@{EventQueue}!asyncInsert@{asyncInsert}}
\index{asyncInsert@{asyncInsert}!EventQueue@{EventQueue}}
\subsubsection[{asyncInsert}]{\setlength{\rightskip}{0pt plus 5cm}void asyncInsert (Event $\ast$ {\em event})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classEventQueue_aadb31d9952f03cb2a934f93cac304153}
Function for adding events to the async queue. The added events are added to main event queue later. Threads, other than the owning thread, should call this function instead of \hyperlink{classEventQueue_ad8e469f292d876af9e2ec380e8e7e51e}{insert()}. 


\begin{DoxyCode}
470 {
471     async_queue_mutex->lock();
472     async_queue.push_back(event);
473     async_queue_mutex->unlock();
474 }
\end{DoxyCode}
\hypertarget{classEventQueue_a66392764e022762d90e80efbee0500b2}{
\index{EventQueue@{EventQueue}!debugVerify@{debugVerify}}
\index{debugVerify@{debugVerify}!EventQueue@{EventQueue}}
\subsubsection[{debugVerify}]{\setlength{\rightskip}{0pt plus 5cm}bool debugVerify () const}}
\label{classEventQueue_a66392764e022762d90e80efbee0500b2}



\begin{DoxyCode}
366 {
367     m5::hash_map<long, bool> map;
368 
369     Tick time = 0;
370     short priority = 0;
371 
372     Event *nextBin = head;
373     while (nextBin) {
374         Event *nextInBin = nextBin;
375         while (nextInBin) {
376             if (nextInBin->when() < time) {
377                 cprintf("time goes backwards!");
378                 nextInBin->dump();
379                 return false;
380             } else if (nextInBin->when() == time &&
381                        nextInBin->priority() < priority) {
382                 cprintf("priority inverted!");
383                 nextInBin->dump();
384                 return false;
385             }
386 
387             if (map[reinterpret_cast<long>(nextInBin)]) {
388                 cprintf("Node already seen");
389                 nextInBin->dump();
390                 return false;
391             }
392             map[reinterpret_cast<long>(nextInBin)] = true;
393 
394             time = nextInBin->when();
395             priority = nextInBin->priority();
396 
397             nextInBin = nextInBin->nextInBin;
398         }
399 
400         nextBin = nextBin->nextBin;
401     }
402 
403     return true;
404 }
\end{DoxyCode}
\hypertarget{classEventQueue_ab1b8fc2b2605fdc1d88bf07a86e1fe07}{
\index{EventQueue@{EventQueue}!deschedule@{deschedule}}
\index{deschedule@{deschedule}!EventQueue@{EventQueue}}
\subsubsection[{deschedule}]{\setlength{\rightskip}{0pt plus 5cm}void deschedule ({\bf Event} $\ast$ {\em event})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classEventQueue_ab1b8fc2b2605fdc1d88bf07a86e1fe07}
Deschedule the specified event. Should be called only from the owning thread. 


\begin{DoxyCode}
69 {
70     assert(event->scheduled());
71     assert(event->initialized());
72     assert(!inParallelMode || this == curEventQueue());
73 
74     remove(event);
75 
76     event->flags.clear(Event::Squashed);
77     event->flags.clear(Event::Scheduled);
78 
79     if (DTRACE(Event))
80         event->trace("descheduled");
81 
82     if (event->flags.isSet(Event::AutoDelete))
83         delete event;
84 }
\end{DoxyCode}
\hypertarget{classEventQueue_a4a4fecb6d7cd9d0b8eb6579eee183af8}{
\index{EventQueue@{EventQueue}!dump@{dump}}
\index{dump@{dump}!EventQueue@{EventQueue}}
\subsubsection[{dump}]{\setlength{\rightskip}{0pt plus 5cm}void dump () const}}
\label{classEventQueue_a4a4fecb6d7cd9d0b8eb6579eee183af8}



\begin{DoxyCode}
341 {
342     cprintf("============================================================\n");
343     cprintf("EventQueue Dump  (cycle %d)\n", curTick());
344     cprintf("------------------------------------------------------------\n");
345 
346     if (empty())
347         cprintf("<No Events>\n");
348     else {
349         Event *nextBin = head;
350         while (nextBin) {
351             Event *nextInBin = nextBin;
352             while (nextInBin) {
353                 nextInBin->dump();
354                 nextInBin = nextInBin->nextInBin;
355             }
356 
357             nextBin = nextBin->nextBin;
358         }
359     }
360 
361     cprintf("============================================================\n");
362 }
\end{DoxyCode}
\hypertarget{classEventQueue_ac6e61de369e994009e36f344f99c15ad}{
\index{EventQueue@{EventQueue}!empty@{empty}}
\index{empty@{empty}!EventQueue@{EventQueue}}
\subsubsection[{empty}]{\setlength{\rightskip}{0pt plus 5cm}bool empty () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classEventQueue_ac6e61de369e994009e36f344f99c15ad}



\begin{DoxyCode}
594 { return head == NULL; }
\end{DoxyCode}
\hypertarget{classEventQueue_ab9e4d6c1f3218aee0ff70854de959a6c}{
\index{EventQueue@{EventQueue}!getCurTick@{getCurTick}}
\index{getCurTick@{getCurTick}!EventQueue@{EventQueue}}
\subsubsection[{getCurTick}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} getCurTick ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classEventQueue_ab9e4d6c1f3218aee0ff70854de959a6c}



\begin{DoxyCode}
568 { return _curTick; }
\end{DoxyCode}
\hypertarget{classEventQueue_a2f9d0ed8258183804bc764aa3b859f70}{
\index{EventQueue@{EventQueue}!handleAsyncInsertions@{handleAsyncInsertions}}
\index{handleAsyncInsertions@{handleAsyncInsertions}!EventQueue@{EventQueue}}
\subsubsection[{handleAsyncInsertions}]{\setlength{\rightskip}{0pt plus 5cm}void handleAsyncInsertions ()}}
\label{classEventQueue_a2f9d0ed8258183804bc764aa3b859f70}


Function for moving events from the async\_\-queue to the main queue. 


\begin{DoxyCode}
478 {
479     assert(this == curEventQueue());
480     async_queue_mutex->lock();
481 
482     while (!async_queue.empty()) {
483         insert(async_queue.front());
484         async_queue.pop_front();
485     }
486 
487     async_queue_mutex->unlock();
488 }
\end{DoxyCode}
\hypertarget{classEventQueue_ad8e469f292d876af9e2ec380e8e7e51e}{
\index{EventQueue@{EventQueue}!insert@{insert}}
\index{insert@{insert}!EventQueue@{EventQueue}}
\subsubsection[{insert}]{\setlength{\rightskip}{0pt plus 5cm}void insert (Event $\ast$ {\em event})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classEventQueue_ad8e469f292d876af9e2ec380e8e7e51e}
Insert / remove event from the queue. Should only be called by thread operating this queue. 


\begin{DoxyCode}
119 {
120     // Deal with the head case
121     if (!head || *event <= *head) {
122         head = Event::insertBefore(event, head);
123         return;
124     }
125 
126     // Figure out either which 'in bin' list we are on, or where a new list
127     // needs to be inserted
128     Event *prev = head;
129     Event *curr = head->nextBin;
130     while (curr && *curr < *event) {
131         prev = curr;
132         curr = curr->nextBin;
133     }
134 
135     // Note: this operation may render all nextBin pointers on the
136     // prev 'in bin' list stale (except for the top one)
137     prev->nextBin = Event::insertBefore(event, curr);
138 }
\end{DoxyCode}
\hypertarget{classEventQueue_aa81aed607133209dade63a226818224d}{
\index{EventQueue@{EventQueue}!lock@{lock}}
\index{lock@{lock}!EventQueue@{EventQueue}}
\subsubsection[{lock}]{\setlength{\rightskip}{0pt plus 5cm}void lock ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classEventQueue_aa81aed607133209dade63a226818224d}
Provide an interface for locking/unlocking the event queue.

Do NOT use these methods directly unless you really know what you are doing. Incorrect use can easily lead to simulator deadlocks.

\begin{DoxySeeAlso}{参照}
\hyperlink{classEventQueue_1_1ScopedMigration}{EventQueue::ScopedMigration}. 

\hyperlink{classEventQueue_1_1ScopedRelease}{EventQueue::ScopedRelease} 

\hyperlink{classEventQueue}{EventQueue} 
\end{DoxySeeAlso}



\begin{DoxyCode}
625 { service_mutex.lock(); }
\end{DoxyCode}
\hypertarget{classEventQueue_a413b79e026328fa4210d327d1958bd12}{
\index{EventQueue@{EventQueue}!name@{name}}
\index{name@{name}!EventQueue@{EventQueue}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}void name (const std::string \& {\em st})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classEventQueue_a413b79e026328fa4210d327d1958bd12}



\begin{DoxyCode}
552 { objName = st; }
\end{DoxyCode}
\hypertarget{classEventQueue_adbcff144e5e199d332a1352af1798148}{
\index{EventQueue@{EventQueue}!name@{name}}
\index{name@{name}!EventQueue@{EventQueue}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}virtual const std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classEventQueue_adbcff144e5e199d332a1352af1798148}


\hyperlink{classSerializable_a2d319721a65496069642871a52e47056}{Serializable}を実装しています。


\begin{DoxyCode}
551 { return objName; }
\end{DoxyCode}
\hypertarget{classEventQueue_ac7fc06f25478db3060a43a096e023243}{
\index{EventQueue@{EventQueue}!nextTick@{nextTick}}
\index{nextTick@{nextTick}!EventQueue@{EventQueue}}
\subsubsection[{nextTick}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} nextTick () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classEventQueue_ac7fc06f25478db3060a43a096e023243}



\begin{DoxyCode}
566 { return head->when(); }
\end{DoxyCode}
\hypertarget{classEventQueue_a3f3ea68ae4a3b85263c9e223efcce2f6}{
\index{EventQueue@{EventQueue}!remove@{remove}}
\index{remove@{remove}!EventQueue@{EventQueue}}
\subsubsection[{remove}]{\setlength{\rightskip}{0pt plus 5cm}void remove (Event $\ast$ {\em event})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classEventQueue_a3f3ea68ae4a3b85263c9e223efcce2f6}



\begin{DoxyCode}
173 {
174     if (head == NULL)
175         panic("event not found!");
176 
177     assert(event->queue == this);
178 
179     // deal with an event on the head's 'in bin' list (event has the same
180     // time as the head)
181     if (*head == *event) {
182         head = Event::removeItem(event, head);
183         return;
184     }
185 
186     // Find the 'in bin' list that this event belongs on
187     Event *prev = head;
188     Event *curr = head->nextBin;
189     while (curr && *curr < *event) {
190         prev = curr;
191         curr = curr->nextBin;
192     }
193 
194     if (!curr || *curr != *event)
195         panic("event not found!");
196 
197     // curr points to the top item of the the correct 'in bin' list, when
198     // we remove an item, it returns the new top item (which may be
199     // unchanged)
200     prev->nextBin = Event::removeItem(event, curr);
201 }
\end{DoxyCode}
\hypertarget{classEventQueue_a1c4b36385e86f178f625f84d95cb6778}{
\index{EventQueue@{EventQueue}!replaceHead@{replaceHead}}
\index{replaceHead@{replaceHead}!EventQueue@{EventQueue}}
\subsubsection[{replaceHead}]{\setlength{\rightskip}{0pt plus 5cm}Event $\ast$ replaceHead (Event $\ast$ {\em s})}}
\label{classEventQueue_a1c4b36385e86f178f625f84d95cb6778}
function for replacing the head of the event queue, so that a different set of events can run without disturbing events that have already been scheduled. Already scheduled events can be processed by replacing the original head back. USING THIS FUNCTION CAN BE DANGEROUS TO THE HEALTH OF THE SIMULATOR. NOT RECOMMENDED FOR USE. 


\begin{DoxyCode}
408 {
409     Event* t = head;
410     head = s;
411     return t;
412 }
\end{DoxyCode}
\hypertarget{classEventQueue_a676294f5f01031f3dfdf956185390db8}{
\index{EventQueue@{EventQueue}!reschedule@{reschedule}}
\index{reschedule@{reschedule}!EventQueue@{EventQueue}}
\subsubsection[{reschedule}]{\setlength{\rightskip}{0pt plus 5cm}void reschedule ({\bf Event} $\ast$ {\em event}, \/  {\bf Tick} {\em when}, \/  bool {\em always} = {\ttfamily false})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classEventQueue_a676294f5f01031f3dfdf956185390db8}
Reschedule the specified event. Should be called only from the owning thread. 


\begin{DoxyCode}
88 {
89     assert(when >= getCurTick());
90     assert(always || event->scheduled());
91     assert(event->initialized());
92     assert(!inParallelMode || this == curEventQueue());
93 
94     if (event->scheduled())
95         remove(event);
96 
97     event->setWhen(when, this);
98     insert(event);
99     event->flags.clear(Event::Squashed);
100     event->flags.set(Event::Scheduled);
101 
102     if (DTRACE(Event))
103         event->trace("rescheduled");
104 }
\end{DoxyCode}
\hypertarget{classEventQueue_a6e13c0d68fbc26df6eff27313813b8a4}{
\index{EventQueue@{EventQueue}!schedule@{schedule}}
\index{schedule@{schedule}!EventQueue@{EventQueue}}
\subsubsection[{schedule}]{\setlength{\rightskip}{0pt plus 5cm}void schedule ({\bf Event} $\ast$ {\em event}, \/  {\bf Tick} {\em when}, \/  bool {\em global} = {\ttfamily false})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classEventQueue_a6e13c0d68fbc26df6eff27313813b8a4}
Schedule the given event on this queue. Safe to call from any thread. 


\begin{DoxyCode}
43 {
44     assert(when >= getCurTick());
45     assert(!event->scheduled());
46     assert(event->initialized());
47 
48     event->setWhen(when, this);
49 
50     // The check below is to make sure of two things
51     // a. a thread schedules local events on other queues through the asyncq
52     // b. a thread schedules global events on the asyncq, whether or not
53     //    this event belongs to this eventq. This is required to maintain
54     //    a total order amongst the global events. See global_event.{cc,hh}
55     //    for more explanation.
56     if (inParallelMode && (this != curEventQueue() || global)) {
57         asyncInsert(event);
58     } else {
59         insert(event);
60     }
61     event->flags.set(Event::Scheduled);
62 
63     if (DTRACE(Event))
64         event->trace("scheduled");
65 }
\end{DoxyCode}
\hypertarget{classEventQueue_ad6272f80ae37e8331e3969b3f072a801}{
\index{EventQueue@{EventQueue}!serialize@{serialize}}
\index{serialize@{serialize}!EventQueue@{EventQueue}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}virtual void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classEventQueue_ad6272f80ae37e8331e3969b3f072a801}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。\hypertarget{classEventQueue_adc925eabe90846085072915cc6c544c2}{
\index{EventQueue@{EventQueue}!serviceEvents@{serviceEvents}}
\index{serviceEvents@{serviceEvents}!EventQueue@{EventQueue}}
\subsubsection[{serviceEvents}]{\setlength{\rightskip}{0pt plus 5cm}void serviceEvents ({\bf Tick} {\em when})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classEventQueue_adc925eabe90846085072915cc6c544c2}


\begin{Desc}
\item[\hyperlink{todo__todo000091}{TODO}]this assert is a good bug catcher. I need to make it true again. \end{Desc}



\begin{DoxyCode}
577     {
578         while (!empty()) {
579             if (nextTick() > when)
580                 break;
581 
586             //assert(head->when() >= when && "event scheduled in the past");
587             serviceOne();
588         }
589 
590         setCurTick(when);
591     }
\end{DoxyCode}
\hypertarget{classEventQueue_a95b9c78d6fb18e716e5d13362b609798}{
\index{EventQueue@{EventQueue}!serviceOne@{serviceOne}}
\index{serviceOne@{serviceOne}!EventQueue@{EventQueue}}
\subsubsection[{serviceOne}]{\setlength{\rightskip}{0pt plus 5cm}Event $\ast$ serviceOne ()}}
\label{classEventQueue_a95b9c78d6fb18e716e5d13362b609798}



\begin{DoxyCode}
205 {
206     std::lock_guard<EventQueue> lock(*this);
207     Event *event = head;
208     Event *next = head->nextInBin;
209     event->flags.clear(Event::Scheduled);
210 
211     if (next) {
212         // update the next bin pointer since it could be stale
213         next->nextBin = head->nextBin;
214 
215         // pop the stack
216         head = next;
217     } else {
218         // this was the only element on the 'in bin' list, so get rid of
219         // the 'in bin' list and point to the next bin list
220         head = head->nextBin;
221     }
222 
223     // handle action
224     if (!event->squashed()) {
225         // forward current cycle to the time when this event occurs.
226         setCurTick(event->when());
227 
228         event->process();
229         if (event->isExitEvent()) {
230             assert(!event->flags.isSet(Event::AutoDelete) ||
231                    !event->flags.isSet(Event::IsMainQueue)); // would be silly
232             return event;
233         }
234     } else {
235         event->flags.clear(Event::Squashed);
236     }
237 
238     if (event->flags.isSet(Event::AutoDelete) && !event->scheduled())
239         delete event;
240 
241     return NULL;
242 }
\end{DoxyCode}
\hypertarget{classEventQueue_abc2f41fbb4828612a2637268ab8ce640}{
\index{EventQueue@{EventQueue}!setCurTick@{setCurTick}}
\index{setCurTick@{setCurTick}!EventQueue@{EventQueue}}
\subsubsection[{setCurTick}]{\setlength{\rightskip}{0pt plus 5cm}void setCurTick ({\bf Tick} {\em newVal})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classEventQueue_abc2f41fbb4828612a2637268ab8ce640}



\begin{DoxyCode}
567 { _curTick = newVal; }
\end{DoxyCode}
\hypertarget{classEventQueue_a9278be8203e1c42e2619179882ae4403}{
\index{EventQueue@{EventQueue}!unlock@{unlock}}
\index{unlock@{unlock}!EventQueue@{EventQueue}}
\subsubsection[{unlock}]{\setlength{\rightskip}{0pt plus 5cm}void unlock ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classEventQueue_a9278be8203e1c42e2619179882ae4403}



\begin{DoxyCode}
626 { service_mutex.unlock(); }
\end{DoxyCode}
\hypertarget{classEventQueue_af22e5d6d660b97db37003ac61ac4ee49}{
\index{EventQueue@{EventQueue}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!EventQueue@{EventQueue}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classEventQueue_af22e5d6d660b97db37003ac61ac4ee49}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。


\begin{DoxyCode}
325 {
326     int numEvents;
327     UNSERIALIZE_SCALAR(numEvents);
328 
329     std::string eventName;
330     for (int i = 0; i < numEvents; i++) {
331         // get the pointer value associated with the event
332         paramIn(cp, section, csprintf("event%d", i), eventName);
333 
334         // create the event based on its pointer value
335         Serializable::create(cp, eventName);
336     }
337 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classEventQueue_a09b29d670564770f8cde7490c4fa4ebb}{
\index{EventQueue@{EventQueue}!\_\-curTick@{\_\-curTick}}
\index{\_\-curTick@{\_\-curTick}!EventQueue@{EventQueue}}
\subsubsection[{\_\-curTick}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf \_\-curTick}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classEventQueue_a09b29d670564770f8cde7490c4fa4ebb}
\hypertarget{classEventQueue_a9c9b5322e34950b9d27abca2b8207ca9}{
\index{EventQueue@{EventQueue}!async\_\-queue@{async\_\-queue}}
\index{async\_\-queue@{async\_\-queue}!EventQueue@{EventQueue}}
\subsubsection[{async\_\-queue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf Event}$\ast$$>$ {\bf async\_\-queue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classEventQueue_a9c9b5322e34950b9d27abca2b8207ca9}


List of events added by other threads to this event queue. \hypertarget{classEventQueue_a7d6bb496422e204e32492a7012a44b66}{
\index{EventQueue@{EventQueue}!async\_\-queue\_\-mutex@{async\_\-queue\_\-mutex}}
\index{async\_\-queue\_\-mutex@{async\_\-queue\_\-mutex}!EventQueue@{EventQueue}}
\subsubsection[{async\_\-queue\_\-mutex}]{\setlength{\rightskip}{0pt plus 5cm}std::mutex$\ast$ {\bf async\_\-queue\_\-mutex}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classEventQueue_a7d6bb496422e204e32492a7012a44b66}


Mutex to protect async queue. \hypertarget{classEventQueue_a08321f57dbffd90b5b365a6d53bb2933}{
\index{EventQueue@{EventQueue}!head@{head}}
\index{head@{head}!EventQueue@{EventQueue}}
\subsubsection[{head}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Event}$\ast$ {\bf head}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classEventQueue_a08321f57dbffd90b5b365a6d53bb2933}
\hypertarget{classEventQueue_acdd07b78b47375ca2a51a7a956b1697f}{
\index{EventQueue@{EventQueue}!objName@{objName}}
\index{objName@{objName}!EventQueue@{EventQueue}}
\subsubsection[{objName}]{\setlength{\rightskip}{0pt plus 5cm}std::string {\bf objName}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classEventQueue_acdd07b78b47375ca2a51a7a956b1697f}
\hypertarget{classEventQueue_acfc3095049c7deadb02a9eee0ec54a13}{
\index{EventQueue@{EventQueue}!service\_\-mutex@{service\_\-mutex}}
\index{service\_\-mutex@{service\_\-mutex}!EventQueue@{EventQueue}}
\subsubsection[{service\_\-mutex}]{\setlength{\rightskip}{0pt plus 5cm}std::mutex {\bf service\_\-mutex}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classEventQueue_acfc3095049c7deadb02a9eee0ec54a13}
Lock protecting event handling.

This lock is always taken when servicing events. It is assumed that the thread scheduling new events (not asynchronous events though) have taken this lock. This is normally done by \hyperlink{classEventQueue_a95b9c78d6fb18e716e5d13362b609798}{serviceOne()} since new events are typically scheduled as a response to an earlier event.

This lock is intended to be used to temporarily steal an event queue to support inter-\/thread communication when some deterministic timing can be sacrificed for speed. For example, the KVM CPU can use this support to access devices running in a different thread.

\begin{DoxySeeAlso}{参照}
\hyperlink{classEventQueue_1_1ScopedMigration}{EventQueue::ScopedMigration}. 

\hyperlink{classEventQueue_1_1ScopedRelease}{EventQueue::ScopedRelease} 

\hyperlink{classEventQueue_aa81aed607133209dade63a226818224d}{EventQueue::lock()} 

\hyperlink{classEventQueue_a9278be8203e1c42e2619179882ae4403}{EventQueue::unlock()} 
\end{DoxySeeAlso}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
sim/\hyperlink{eventq_8hh}{eventq.hh}\item 
sim/\hyperlink{eventq_8cc}{eventq.cc}\item 
sim/\hyperlink{eventq__impl_8hh}{eventq\_\-impl.hh}\end{DoxyCompactItemize}
