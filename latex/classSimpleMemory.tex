\hypertarget{classSimpleMemory}{
\section{クラス SimpleMemory}
\label{classSimpleMemory}\index{SimpleMemory@{SimpleMemory}}
}


{\ttfamily \#include $<$simple\_\-mem.hh$>$}SimpleMemoryに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=6cm]{classSimpleMemory}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classSimpleMemory_1_1DeferredPacket}{DeferredPacket}
\item 
class \hyperlink{classSimpleMemory_1_1MemoryPort}{MemoryPort}
\item 
class \hyperlink{classSimpleMemory_1_1SimpleMemory}{SimpleMemory}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSimpleMemory_afc0d41f7c9b61cc5161f7f4b10a1b942}{SimpleMemory} (const SimpleMemoryParams $\ast$p)
\item 
unsigned int \hyperlink{classSimpleMemory_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)
\item 
\hyperlink{classBaseSlavePort}{BaseSlavePort} \& \hyperlink{classSimpleMemory_ac918a145092d7514ebc6dbd952dceafb}{getSlavePort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
void \hyperlink{classSimpleMemory_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classSimpleMemory_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{recvAtomic} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classSimpleMemory_aeefa907fb6d6a787e6dab90e8138ea90}{recvFunctional} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classSimpleMemory_a3344d9dd0f83257feab5424e761f31c6}{recvTimingReq} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classSimpleMemory_a29cb5a4f98063ce6e9210eacbdb35298}{recvRetry} ()
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classSimpleMemory_a23b477d0e2d399f75d585d154c346591}{release} ()
\item 
void \hyperlink{classSimpleMemory_a851b6644e3e336c07f8e6fe77234b97f}{dequeue} ()
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classSimpleMemory_aab331854844f48e55c064a1d20d74361}{getLatency} () const 
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSimpleMemory_1_1MemoryPort}{MemoryPort} \hyperlink{classSimpleMemory_a55c076720c982014096b57cadebf9a14}{port}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classSimpleMemory_a8291bf96dadb3695aea55321d10c0e77}{latency}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classSimpleMemory_aa983b5b77f758b06806499ada4568803}{latency\_\-var}
\item 
\hyperlink{classstd_1_1deque}{std::deque}$<$ \hyperlink{classSimpleMemory_1_1DeferredPacket}{DeferredPacket} $>$ \hyperlink{classSimpleMemory_ae20fc3a6f9b02bebe5a9bff0c939c1f5}{packetQueue}
\item 
const double \hyperlink{classSimpleMemory_a18386495a208eab463cafbccfc28d5f4}{bandwidth}
\item 
bool \hyperlink{classSimpleMemory_a099f725f22a344e190121634f53328d8}{isBusy}
\item 
bool \hyperlink{classSimpleMemory_aab3b947b2633a30b5973a39b7e9b018a}{retryReq}
\item 
bool \hyperlink{classSimpleMemory_a6ddfdd4eb676d50001bda88567e6da14}{retryResp}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classSimpleMemory_1_1SimpleMemory}{SimpleMemory},\&SimpleMemory::release $>$ \hyperlink{classSimpleMemory_a152504c9de53c1ab4c16f4dceaa6bbfa}{releaseEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classSimpleMemory_1_1SimpleMemory}{SimpleMemory},\&SimpleMemory::dequeue $>$ \hyperlink{classSimpleMemory_a8c2927c28d324098f4c7bb9b4d96bca1}{dequeueEvent}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classPacket}{PacketPtr} $>$ \hyperlink{classSimpleMemory_a21da4bea3554874b557428e4cce5d4a4}{pendingDelete}
\item 
\hyperlink{classDrainManager}{DrainManager} $\ast$ \hyperlink{classSimpleMemory_a329b71fb934a93312ca0aacbf5a3f982}{drainManager}
\end{DoxyCompactItemize}


\subsection{説明}
The simple memory is a basic single-\/ported memory controller with a configurable throughput and latency.

\begin{DoxySeeAlso}{参照}
gem5 Memory System 
\end{DoxySeeAlso}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classSimpleMemory_afc0d41f7c9b61cc5161f7f4b10a1b942}{
\index{SimpleMemory@{SimpleMemory}!SimpleMemory@{SimpleMemory}}
\index{SimpleMemory@{SimpleMemory}!SimpleMemory@{SimpleMemory}}
\subsubsection[{SimpleMemory}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SimpleMemory} (const SimpleMemoryParams $\ast$ {\em p})}}
\label{classSimpleMemory_afc0d41f7c9b61cc5161f7f4b10a1b942}



\begin{DoxyCode}
50                                                       :
51     AbstractMemory(p),
52     port(name() + ".port", *this), latency(p->latency),
53     latency_var(p->latency_var), bandwidth(p->bandwidth), isBusy(false),
54     retryReq(false), retryResp(false),
55     releaseEvent(this), dequeueEvent(this), drainManager(NULL)
56 {
57 }

\end{DoxyCode}


\subsection{関数}
\hypertarget{classSimpleMemory_a851b6644e3e336c07f8e6fe77234b97f}{
\index{SimpleMemory@{SimpleMemory}!dequeue@{dequeue}}
\index{dequeue@{dequeue}!SimpleMemory@{SimpleMemory}}
\subsubsection[{dequeue}]{\setlength{\rightskip}{0pt plus 5cm}void dequeue ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSimpleMemory_a851b6644e3e336c07f8e6fe77234b97f}
Dequeue a packet from our internal packet queue and move it to the port where it will be sent as soon as possible. 


\begin{DoxyCode}
180 {
181     assert(!packetQueue.empty());
182     DeferredPacket deferred_pkt = packetQueue.front();
183 
184     retryResp = !port.sendTimingResp(deferred_pkt.pkt);
185 
186     if (!retryResp) {
187         packetQueue.pop_front();
188 
189         // if the queue is not empty, schedule the next dequeue event,
190         // otherwise signal that we are drained if we were asked to do so
191         if (!packetQueue.empty()) {
192             // if there were packets that got in-between then we
193             // already have an event scheduled, so use re-schedule
194             reschedule(dequeueEvent,
195                        std::max(packetQueue.front().tick, curTick()), true);
196         } else if (drainManager) {
197             drainManager->signalDrainDone();
198             drainManager = NULL;
199         }
200     }
201 }
\end{DoxyCode}
\hypertarget{classSimpleMemory_aa8a18d230dba7a674ac8a0b4f35bc36a}{
\index{SimpleMemory@{SimpleMemory}!drain@{drain}}
\index{drain@{drain}!SimpleMemory@{SimpleMemory}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em drainManger})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSimpleMemory_aa8a18d230dba7a674ac8a0b4f35bc36a}
Provide a default implementation of the drain interface that simply returns 0 (draining completed) and sets the drain state to Drained. 

\hyperlink{classSimObject_a6bf479c521c7c3eb473822d953275b26}{SimObject}を再定義しています。


\begin{DoxyCode}
230 {
231     int count = 0;
232 
233     // also track our internal queue
234     if (!packetQueue.empty()) {
235         count += 1;
236         drainManager = dm;
237     }
238 
239     if (count)
240         setDrainState(Drainable::Draining);
241     else
242         setDrainState(Drainable::Drained);
243     return count;
244 }
\end{DoxyCode}
\hypertarget{classSimpleMemory_aab331854844f48e55c064a1d20d74361}{
\index{SimpleMemory@{SimpleMemory}!getLatency@{getLatency}}
\index{getLatency@{getLatency}!SimpleMemory@{SimpleMemory}}
\subsubsection[{getLatency}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} getLatency () const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSimpleMemory_aab331854844f48e55c064a1d20d74361}
Detemine the latency.

\begin{DoxyReturn}{戻り値}
the latency seen by the current packet 
\end{DoxyReturn}



\begin{DoxyCode}
205 {
206     return latency +
207         (latency_var ? random_mt.random<Tick>(0, latency_var) : 0);
208 }
\end{DoxyCode}
\hypertarget{classSimpleMemory_ac918a145092d7514ebc6dbd952dceafb}{
\index{SimpleMemory@{SimpleMemory}!getSlavePort@{getSlavePort}}
\index{getSlavePort@{getSlavePort}!SimpleMemory@{SimpleMemory}}
\subsubsection[{getSlavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseSlavePort} \& getSlavePort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSimpleMemory_ac918a145092d7514ebc6dbd952dceafb}
Get a slave port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classMemObject_ac918a145092d7514ebc6dbd952dceafb}{MemObject}を再定義しています。


\begin{DoxyCode}
220 {
221     if (if_name != "port") {
222         return MemObject::getSlavePort(if_name, idx);
223     } else {
224         return port;
225     }
226 }
\end{DoxyCode}
\hypertarget{classSimpleMemory_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{SimpleMemory@{SimpleMemory}!init@{init}}
\index{init@{init}!SimpleMemory@{SimpleMemory}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSimpleMemory_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classSimpleMemory_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{SimObject}を再定義しています。


\begin{DoxyCode}
61 {
62     // allow unconnected memories as this is used in several ruby
63     // systems at the moment
64     if (port.isConnected()) {
65         port.sendRangeChange();
66     }
67 }
\end{DoxyCode}
\hypertarget{classSimpleMemory_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{
\index{SimpleMemory@{SimpleMemory}!recvAtomic@{recvAtomic}}
\index{recvAtomic@{recvAtomic}!SimpleMemory@{SimpleMemory}}
\subsubsection[{recvAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvAtomic ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSimpleMemory_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}



\begin{DoxyCode}
71 {
72     access(pkt);
73     return pkt->memInhibitAsserted() ? 0 : getLatency();
74 }
\end{DoxyCode}
\hypertarget{classSimpleMemory_aeefa907fb6d6a787e6dab90e8138ea90}{
\index{SimpleMemory@{SimpleMemory}!recvFunctional@{recvFunctional}}
\index{recvFunctional@{recvFunctional}!SimpleMemory@{SimpleMemory}}
\subsubsection[{recvFunctional}]{\setlength{\rightskip}{0pt plus 5cm}void recvFunctional ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSimpleMemory_aeefa907fb6d6a787e6dab90e8138ea90}



\begin{DoxyCode}
78 {
79     pkt->pushLabel(name());
80 
81     functionalAccess(pkt);
82 
83     // potentially update the packets in our packet queue as well
84     for (auto i = packetQueue.begin(); i != packetQueue.end(); ++i)
85         pkt->checkFunctional(i->pkt);
86 
87     pkt->popLabel();
88 }
\end{DoxyCode}
\hypertarget{classSimpleMemory_a29cb5a4f98063ce6e9210eacbdb35298}{
\index{SimpleMemory@{SimpleMemory}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!SimpleMemory@{SimpleMemory}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetry ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSimpleMemory_a29cb5a4f98063ce6e9210eacbdb35298}



\begin{DoxyCode}
212 {
213     assert(retryResp);
214 
215     dequeue();
216 }
\end{DoxyCode}
\hypertarget{classSimpleMemory_a3344d9dd0f83257feab5424e761f31c6}{
\index{SimpleMemory@{SimpleMemory}!recvTimingReq@{recvTimingReq}}
\index{recvTimingReq@{recvTimingReq}!SimpleMemory@{SimpleMemory}}
\subsubsection[{recvTimingReq}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingReq ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSimpleMemory_a3344d9dd0f83257feab5424e761f31c6}


\begin{Desc}
\item[\hyperlink{todo__todo000086}{TODO}]temporary hack to deal with memory corruption issues until 4-\/phase transactions are complete \end{Desc}



\begin{DoxyCode}
92 {
95     for (int x = 0; x < pendingDelete.size(); x++)
96         delete pendingDelete[x];
97     pendingDelete.clear();
98 
99     if (pkt->memInhibitAsserted()) {
100         // snooper will supply based on copy of packet
101         // still target's responsibility to delete packet
102         pendingDelete.push_back(pkt);
103         return true;
104     }
105 
106     // we should never get a new request after committing to retry the
107     // current one, the bus violates the rule as it simply sends a
108     // retry to the next one waiting on the retry list, so simply
109     // ignore it
110     if (retryReq)
111         return false;
112 
113     // if we are busy with a read or write, remember that we have to
114     // retry
115     if (isBusy) {
116         retryReq = true;
117         return false;
118     }
119 
120     // @todo someone should pay for this
121     pkt->busFirstWordDelay = pkt->busLastWordDelay = 0;
122 
123     // update the release time according to the bandwidth limit, and
124     // do so with respect to the time it takes to finish this request
125     // rather than long term as it is the short term data rate that is
126     // limited for any real memory
127 
128     // only look at reads and writes when determining if we are busy,
129     // and for how long, as it is not clear what to regulate for the
130     // other types of commands
131     if (pkt->isRead() || pkt->isWrite()) {
132         // calculate an appropriate tick to release to not exceed
133         // the bandwidth limit
134         Tick duration = pkt->getSize() * bandwidth;
135 
136         // only consider ourselves busy if there is any need to wait
137         // to avoid extra events being scheduled for (infinitely) fast
138         // memories
139         if (duration != 0) {
140             schedule(releaseEvent, curTick() + duration);
141             isBusy = true;
142         }
143     }
144 
145     // go ahead and deal with the packet and put the response in the
146     // queue if there is one
147     bool needsResponse = pkt->needsResponse();
148     recvAtomic(pkt);
149     // turn packet around to go back to requester if response expected
150     if (needsResponse) {
151         // recvAtomic() should already have turned packet into
152         // atomic response
153         assert(pkt->isResponse());
154         // to keep things simple (and in order), we put the packet at
155         // the end even if the latency suggests it should be sent
156         // before the packet(s) before it
157         packetQueue.push_back(DeferredPacket(pkt, curTick() + getLatency()));
158         if (!retryResp && !dequeueEvent.scheduled())
159             schedule(dequeueEvent, packetQueue.back().tick);
160     } else {
161         pendingDelete.push_back(pkt);
162     }
163 
164     return true;
165 }
\end{DoxyCode}
\hypertarget{classSimpleMemory_a23b477d0e2d399f75d585d154c346591}{
\index{SimpleMemory@{SimpleMemory}!release@{release}}
\index{release@{release}!SimpleMemory@{SimpleMemory}}
\subsubsection[{release}]{\setlength{\rightskip}{0pt plus 5cm}void release ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSimpleMemory_a23b477d0e2d399f75d585d154c346591}
Release the memory after being busy and send a retry if a request was rejected in the meanwhile. 


\begin{DoxyCode}
169 {
170     assert(isBusy);
171     isBusy = false;
172     if (retryReq) {
173         retryReq = false;
174         port.sendRetry();
175     }
176 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classSimpleMemory_a18386495a208eab463cafbccfc28d5f4}{
\index{SimpleMemory@{SimpleMemory}!bandwidth@{bandwidth}}
\index{bandwidth@{bandwidth}!SimpleMemory@{SimpleMemory}}
\subsubsection[{bandwidth}]{\setlength{\rightskip}{0pt plus 5cm}const double {\bf bandwidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSimpleMemory_a18386495a208eab463cafbccfc28d5f4}
Bandwidth in ticks per byte. The regulation affects the acceptance rate of requests and the queueing takes place after the regulation. \hypertarget{classSimpleMemory_a8c2927c28d324098f4c7bb9b4d96bca1}{
\index{SimpleMemory@{SimpleMemory}!dequeueEvent@{dequeueEvent}}
\index{dequeueEvent@{dequeueEvent}!SimpleMemory@{SimpleMemory}}
\subsubsection[{dequeueEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf SimpleMemory}, \&SimpleMemory::dequeue$>$ {\bf dequeueEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSimpleMemory_a8c2927c28d324098f4c7bb9b4d96bca1}
\hypertarget{classSimpleMemory_a329b71fb934a93312ca0aacbf5a3f982}{
\index{SimpleMemory@{SimpleMemory}!drainManager@{drainManager}}
\index{drainManager@{drainManager}!SimpleMemory@{SimpleMemory}}
\subsubsection[{drainManager}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DrainManager}$\ast$ {\bf drainManager}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSimpleMemory_a329b71fb934a93312ca0aacbf5a3f982}
If we need to drain, keep the drain manager around until we're done here. \hypertarget{classSimpleMemory_a099f725f22a344e190121634f53328d8}{
\index{SimpleMemory@{SimpleMemory}!isBusy@{isBusy}}
\index{isBusy@{isBusy}!SimpleMemory@{SimpleMemory}}
\subsubsection[{isBusy}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf isBusy}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSimpleMemory_a099f725f22a344e190121634f53328d8}
Track the state of the memory as either idle or busy, no need for an enum with only two states. \hypertarget{classSimpleMemory_a8291bf96dadb3695aea55321d10c0e77}{
\index{SimpleMemory@{SimpleMemory}!latency@{latency}}
\index{latency@{latency}!SimpleMemory@{SimpleMemory}}
\subsubsection[{latency}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf latency}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSimpleMemory_a8291bf96dadb3695aea55321d10c0e77}
Latency from that a request is accepted until the response is ready to be sent. \hypertarget{classSimpleMemory_aa983b5b77f758b06806499ada4568803}{
\index{SimpleMemory@{SimpleMemory}!latency\_\-var@{latency\_\-var}}
\index{latency\_\-var@{latency\_\-var}!SimpleMemory@{SimpleMemory}}
\subsubsection[{latency\_\-var}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf latency\_\-var}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSimpleMemory_aa983b5b77f758b06806499ada4568803}
Fudge factor added to the latency. \hypertarget{classSimpleMemory_ae20fc3a6f9b02bebe5a9bff0c939c1f5}{
\index{SimpleMemory@{SimpleMemory}!packetQueue@{packetQueue}}
\index{packetQueue@{packetQueue}!SimpleMemory@{SimpleMemory}}
\subsubsection[{packetQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::deque}$<${\bf DeferredPacket}$>$ {\bf packetQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSimpleMemory_ae20fc3a6f9b02bebe5a9bff0c939c1f5}
Internal (unbounded) storage to mimic the delay caused by the actual memory access. Note that this is where the packet spends the memory latency. \hypertarget{classSimpleMemory_a21da4bea3554874b557428e4cce5d4a4}{
\index{SimpleMemory@{SimpleMemory}!pendingDelete@{pendingDelete}}
\index{pendingDelete@{pendingDelete}!SimpleMemory@{SimpleMemory}}
\subsubsection[{pendingDelete}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf PacketPtr}$>$ {\bf pendingDelete}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSimpleMemory_a21da4bea3554874b557428e4cce5d4a4}
\begin{Desc}
\item[\hyperlink{todo__todo000087}{TODO}]this is a temporary workaround until the 4-\/phase code is committed. upstream caches needs this packet until true is returned, so hold onto it for deletion until a subsequent call \end{Desc}
\hypertarget{classSimpleMemory_a55c076720c982014096b57cadebf9a14}{
\index{SimpleMemory@{SimpleMemory}!port@{port}}
\index{port@{port}!SimpleMemory@{SimpleMemory}}
\subsubsection[{port}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemoryPort} {\bf port}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSimpleMemory_a55c076720c982014096b57cadebf9a14}
\hypertarget{classSimpleMemory_a152504c9de53c1ab4c16f4dceaa6bbfa}{
\index{SimpleMemory@{SimpleMemory}!releaseEvent@{releaseEvent}}
\index{releaseEvent@{releaseEvent}!SimpleMemory@{SimpleMemory}}
\subsubsection[{releaseEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf SimpleMemory}, \&SimpleMemory::release$>$ {\bf releaseEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSimpleMemory_a152504c9de53c1ab4c16f4dceaa6bbfa}
\hypertarget{classSimpleMemory_aab3b947b2633a30b5973a39b7e9b018a}{
\index{SimpleMemory@{SimpleMemory}!retryReq@{retryReq}}
\index{retryReq@{retryReq}!SimpleMemory@{SimpleMemory}}
\subsubsection[{retryReq}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf retryReq}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSimpleMemory_aab3b947b2633a30b5973a39b7e9b018a}
Remember if we have to retry an outstanding request that arrived while we were busy. \hypertarget{classSimpleMemory_a6ddfdd4eb676d50001bda88567e6da14}{
\index{SimpleMemory@{SimpleMemory}!retryResp@{retryResp}}
\index{retryResp@{retryResp}!SimpleMemory@{SimpleMemory}}
\subsubsection[{retryResp}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf retryResp}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSimpleMemory_a6ddfdd4eb676d50001bda88567e6da14}
Remember if we failed to send a response and are awaiting a retry. This is only used as a check. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{simple__mem_8hh}{simple\_\-mem.hh}\item 
mem/\hyperlink{simple__mem_8cc}{simple\_\-mem.cc}\end{DoxyCompactItemize}
