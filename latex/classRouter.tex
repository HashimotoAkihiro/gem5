\hypertarget{classRouter}{
\section{クラス Router}
\label{classRouter}\index{Router@{Router}}
}


{\ttfamily \#include $<$Router.hh$>$}Routerに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=5cm]{classRouter}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef GarnetRouterParams \hyperlink{classRouter_aefbd30db7d0c203dbe4553fdfe3c2b0e}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classRouter_a08e8916427569b37de6a373acb130e0d}{Router} (const \hyperlink{classRouter_aefbd30db7d0c203dbe4553fdfe3c2b0e}{Params} $\ast$p)
\item 
\hyperlink{classRouter_ae646b52cde146755b62e42fbcf59a309}{$\sim$Router} ()
\item 
void \hyperlink{classRouter_a861b99bda673a31b1b48132ed9369f28}{addInPort} (\hyperlink{classNetworkLink}{NetworkLink} $\ast$in\_\-link)
\item 
void \hyperlink{classRouter_a8958cd696038e2c830e9ab3445bb1ae5}{addOutPort} (\hyperlink{classNetworkLink}{NetworkLink} $\ast$out\_\-link, const \hyperlink{classNetDest}{NetDest} \&routing\_\-table\_\-entry, int link\_\-weight)
\item 
void \hyperlink{classRouter_ae674290a26ecbd622c5160e38e8a4fe9}{wakeup} ()
\item 
void \hyperlink{classRouter_ac2db714adfe0dfd2c3ac2b88bd6a5308}{request\_\-vc} (int in\_\-vc, int in\_\-port, \hyperlink{classNetDest}{NetDest} destination, \hyperlink{classCycles}{Cycles} request\_\-time)
\item 
bool \hyperlink{classRouter_af3465adbf20f8764ea878ce2d28d2bc8}{isBufferNotFull} (int vc, int inport)
\item 
void \hyperlink{classRouter_af90fb6c473130244fe64e30e61b714f6}{grant\_\-vc} (int out\_\-port, int vc, \hyperlink{classCycles}{Cycles} grant\_\-time)
\item 
void \hyperlink{classRouter_adced7fd7d25eb0d6a869fff14085e8c3}{release\_\-vc} (int out\_\-port, int vc, \hyperlink{classCycles}{Cycles} release\_\-time)
\item 
void \hyperlink{classRouter_a3e82da716c2557efa2e6a293843b4d0a}{vc\_\-arbitrate} ()
\item 
int \hyperlink{classRouter_ae73de77352867d272505f41222809e17}{get\_\-vnet} (int vc)
\item 
void \hyperlink{classRouter_ac55fe386a101fbae38c716067c9966a0}{print} (std::ostream \&out) const 
\item 
void \hyperlink{classRouter_ab5da6a3c41f86ad2993eb11f4894ef00}{init\_\-net\_\-ptr} (\hyperlink{classGarnetNetwork}{GarnetNetwork} $\ast$net\_\-ptr)
\item 
bool \hyperlink{classRouter_a6db56c593ee28a561c47e75a859300dd}{functionalRead} (\hyperlink{classPacket}{Packet} $\ast$)
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classRouter_aba9037f662122b5f2e85647d35670e5c}{functionalWrite} (\hyperlink{classPacket}{Packet} $\ast$)
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classRouter_a2e327aa228d7975550910a9dfc67e222}{getRoute} (\hyperlink{classNetDest}{NetDest} destination)
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ int $>$ \hyperlink{classRouter_a1a1889612585bf284775701c742a8449}{get\_\-valid\_\-vcs} (int invc)
\item 
void \hyperlink{classRouter_aeb1ad1b60d443efcb72a73917e20bbd1}{routeCompute} (\hyperlink{classflit}{flit} $\ast$m\_\-flit, int inport)
\item 
void \hyperlink{classRouter_af954e8e2150e2ce2e1b87081bbd9c678}{checkReschedule} ()
\item 
void \hyperlink{classRouter_a16c0664c8f37fe80b30fd3e7cd90fa33}{check\_\-arbiter\_\-reschedule} ()
\item 
void \hyperlink{classRouter_a4a8dc105bd8d06865d65c708e3e21188}{scheduleOutputLinks} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classRouter_af4cc96182e80059859793d92cb3dd769}{m\_\-virtual\_\-networks}
\item 
int \hyperlink{classRouter_a2e1a9213321dfa0386cdedaf6fc22996}{m\_\-num\_\-vcs}
\item 
int \hyperlink{classRouter_a2d66b8cad5144408ed492eeff4d37c2f}{m\_\-vc\_\-per\_\-vnet}
\item 
\hyperlink{classGarnetNetwork}{GarnetNetwork} $\ast$ \hyperlink{classRouter_a6f69c0ff922be798fa1cfce69f83244e}{m\_\-net\_\-ptr}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ int $>$ \hyperlink{classRouter_aac15a2e45cd3199aa6645027c3c49f29}{m\_\-vc\_\-round\_\-robin}
\item 
int \hyperlink{classRouter_a0c263ebf781383b8d6c95870cfaf076d}{m\_\-round\_\-robin\_\-inport}
\item 
int \hyperlink{classRouter_af4ca19e1a3ce236185490cf7e67f86d3}{m\_\-round\_\-robin\_\-start}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ int $>$ \hyperlink{classRouter_a0445a5ec24b4ba3c94bfaac14bdff561}{m\_\-round\_\-robin\_\-invc}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classflitBuffer}{flitBuffer} $\ast$ $>$ $>$ \hyperlink{classRouter_acb8a77bcc0e2cbc61f9b60cfa443acf0}{m\_\-router\_\-buffers}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classflitBuffer}{flitBuffer} $\ast$ $>$ \hyperlink{classRouter_a1022c5b57cefcbc48cc2b28e5b15f12e}{m\_\-out\_\-src\_\-queue}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classNetworkLink}{NetworkLink} $\ast$ $>$ \hyperlink{classRouter_a4ff3f0c2e50626b517ea98c165c9a0c3}{m\_\-in\_\-link}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classNetworkLink}{NetworkLink} $\ast$ $>$ \hyperlink{classRouter_a2c9a37a8e348b31100b016ef9b51b235}{m\_\-out\_\-link}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classInVcState}{InVcState} $\ast$ $>$ $>$ \hyperlink{classRouter_a9d8dfe7ed8a1027af42c383e180b8023}{m\_\-in\_\-vc\_\-state}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classOutVcState}{OutVcState} $\ast$ $>$ $>$ \hyperlink{classRouter_ac42fe6cf02410262c5525a2abcc921b6}{m\_\-out\_\-vc\_\-state}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classNetDest}{NetDest} $>$ \hyperlink{classRouter_adce3e392ac98699a80750fa4a4aa9b40}{m\_\-routing\_\-table}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ int $>$ \hyperlink{classRouter_a0894e57ab5d2ddc0e8c5d60a53a27cff}{m\_\-link\_\-weights}
\item 
\hyperlink{classVCarbiter}{VCarbiter} $\ast$ \hyperlink{classRouter_a03eb166814fcfceb112402a09259cae7}{m\_\-vc\_\-arbiter}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classRouter_aefbd30db7d0c203dbe4553fdfe3c2b0e}{
\index{Router@{Router}!Params@{Params}}
\index{Params@{Params}!Router@{Router}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef GarnetRouterParams {\bf Params}}}
\label{classRouter_aefbd30db7d0c203dbe4553fdfe3c2b0e}


\hyperlink{classBasicRouter_af2c419269bc768b96a7bae9bfbcd3e94}{BasicRouter}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classRouter_a08e8916427569b37de6a373acb130e0d}{
\index{Router@{Router}!Router@{Router}}
\index{Router@{Router}!Router@{Router}}
\subsubsection[{Router}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Router} (const {\bf Params} $\ast$ {\em p})}}
\label{classRouter_a08e8916427569b37de6a373acb130e0d}



\begin{DoxyCode}
44     : BasicRouter(p), FlexibleConsumer(this)
45 {
46     m_virtual_networks = p->virt_nets;
47     m_vc_per_vnet = p->vcs_per_vnet;
48     m_round_robin_inport = 0;
49     m_round_robin_start = 0;
50     m_num_vcs = m_vc_per_vnet * m_virtual_networks;
51     m_vc_arbiter = new VCarbiter(this);
52 }
\end{DoxyCode}
\hypertarget{classRouter_ae646b52cde146755b62e42fbcf59a309}{
\index{Router@{Router}!$\sim$Router@{$\sim$Router}}
\index{$\sim$Router@{$\sim$Router}!Router@{Router}}
\subsubsection[{$\sim$Router}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf Router} ()}}
\label{classRouter_ae646b52cde146755b62e42fbcf59a309}



\begin{DoxyCode}
55 {
56     for (int i = 0; i < m_in_link.size(); i++) {
57         deletePointers(m_in_vc_state[i]);
58     }
59     for (int i = 0; i < m_out_link.size(); i++) {
60         deletePointers(m_out_vc_state[i]);
61         deletePointers(m_router_buffers[i]);
62     }
63     deletePointers(m_out_src_queue);
64     delete m_vc_arbiter;
65 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classRouter_a861b99bda673a31b1b48132ed9369f28}{
\index{Router@{Router}!addInPort@{addInPort}}
\index{addInPort@{addInPort}!Router@{Router}}
\subsubsection[{addInPort}]{\setlength{\rightskip}{0pt plus 5cm}void addInPort ({\bf NetworkLink} $\ast$ {\em in\_\-link})}}
\label{classRouter_a861b99bda673a31b1b48132ed9369f28}



\begin{DoxyCode}
69 {
70     int port = m_in_link.size();
71     vector<InVcState *> in_vc_vector;
72     for (int i = 0; i < m_num_vcs; i++) {
73         in_vc_vector.push_back(new InVcState(i));
74         in_vc_vector[i]->setState(IDLE_, curCycle());
75     }
76     m_in_vc_state.push_back(in_vc_vector);
77     m_in_link.push_back(in_link);
78     in_link->setLinkConsumer(this);
79     in_link->setInPort(port);
80 
81     int start = 0;
82     m_round_robin_invc.push_back(start);
83 }
\end{DoxyCode}
\hypertarget{classRouter_a8958cd696038e2c830e9ab3445bb1ae5}{
\index{Router@{Router}!addOutPort@{addOutPort}}
\index{addOutPort@{addOutPort}!Router@{Router}}
\subsubsection[{addOutPort}]{\setlength{\rightskip}{0pt plus 5cm}void addOutPort ({\bf NetworkLink} $\ast$ {\em out\_\-link}, \/  const {\bf NetDest} \& {\em routing\_\-table\_\-entry}, \/  int {\em link\_\-weight})}}
\label{classRouter_a8958cd696038e2c830e9ab3445bb1ae5}



\begin{DoxyCode}
88 {
89     int port = m_out_link.size();
90     out_link->setOutPort(port);
91     int start = 0;
92     m_vc_round_robin.push_back(start);
93 
94     m_out_src_queue.push_back(new flitBuffer());
95 
96     m_out_link.push_back(out_link);
97     m_routing_table.push_back(routing_table_entry);
98     out_link->setSourceQueue(m_out_src_queue[port]);
99     out_link->setSource(this);
100 
101     vector<flitBuffer *> intermediateQueues;
102     for (int i = 0; i < m_num_vcs; i++) {
103         int buffer_size = m_net_ptr->getBufferSize();
104         if (buffer_size > 0) // finite size
105             intermediateQueues.push_back(new flitBuffer(buffer_size));
106         else // infinite size
107             intermediateQueues.push_back(new flitBuffer());
108     }
109     m_router_buffers.push_back(intermediateQueues);
110 
111     vector<OutVcState *> out_vc_vector;
112     for (int i = 0; i < m_num_vcs; i++) {
113         out_vc_vector.push_back(new OutVcState(i));
114         out_vc_vector[i]->setState(IDLE_, curCycle());
115     }
116     m_out_vc_state.push_back(out_vc_vector);
117     m_link_weights.push_back(link_weight);
118 }
\end{DoxyCode}
\hypertarget{classRouter_a16c0664c8f37fe80b30fd3e7cd90fa33}{
\index{Router@{Router}!check\_\-arbiter\_\-reschedule@{check\_\-arbiter\_\-reschedule}}
\index{check\_\-arbiter\_\-reschedule@{check\_\-arbiter\_\-reschedule}!Router@{Router}}
\subsubsection[{check\_\-arbiter\_\-reschedule}]{\setlength{\rightskip}{0pt plus 5cm}void check\_\-arbiter\_\-reschedule ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_a16c0664c8f37fe80b30fd3e7cd90fa33}



\begin{DoxyCode}
400 {
401     for (int port = 0; port < m_in_link.size(); port++) {
402         for (int vc = 0; vc < m_num_vcs; vc++) {
403             if (m_in_vc_state[port][vc]->isInState(VC_AB_, curCycle() +
404                                                    Cycles(1))) {
405                 m_vc_arbiter->scheduleEventAbsolute(clockEdge(Cycles(1)));
406                 return;
407             }
408         }
409     }
410 }
\end{DoxyCode}
\hypertarget{classRouter_af954e8e2150e2ce2e1b87081bbd9c678}{
\index{Router@{Router}!checkReschedule@{checkReschedule}}
\index{checkReschedule@{checkReschedule}!Router@{Router}}
\subsubsection[{checkReschedule}]{\setlength{\rightskip}{0pt plus 5cm}void checkReschedule ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_af954e8e2150e2ce2e1b87081bbd9c678}



\begin{DoxyCode}
387 {
388     for (int port = 0; port < m_out_link.size(); port++) {
389         for (int vc = 0; vc < m_num_vcs; vc++) {
390             if (m_router_buffers[port][vc]->isReadyForNext(curCycle())) {
391                 scheduleEvent(Cycles(1));
392                 return;
393             }
394         }
395     }
396 }
\end{DoxyCode}
\hypertarget{classRouter_a6db56c593ee28a561c47e75a859300dd}{
\index{Router@{Router}!functionalRead@{functionalRead}}
\index{functionalRead@{functionalRead}!Router@{Router}}
\subsubsection[{functionalRead}]{\setlength{\rightskip}{0pt plus 5cm}bool functionalRead ({\bf Packet} $\ast$ {\em pkt})}}
\label{classRouter_a6db56c593ee28a561c47e75a859300dd}



\begin{DoxyCode}
414 {
415     // Access the buffers in the router for performing a functional read
416     for (unsigned int i = 0; i < m_router_buffers.size(); i++) {
417         for (unsigned int j = 0; j < m_router_buffers[i].size(); ++j) {
418             if (m_router_buffers[i][j]->functionalRead(pkt)) {
419                 return true;
420             }
421         }
422     }
423 
424     // Access the link queues for performing a functional read
425     for (unsigned int i = 0; i < m_out_src_queue.size(); i++) {
426         if (m_out_src_queue[i]->functionalRead(pkt)) {
427             return true;
428         }
429     }
430     return false;
431 }
\end{DoxyCode}
\hypertarget{classRouter_aba9037f662122b5f2e85647d35670e5c}{
\index{Router@{Router}!functionalWrite@{functionalWrite}}
\index{functionalWrite@{functionalWrite}!Router@{Router}}
\subsubsection[{functionalWrite}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} functionalWrite ({\bf Packet} $\ast$ {\em pkt})}}
\label{classRouter_aba9037f662122b5f2e85647d35670e5c}



\begin{DoxyCode}
435 {
436     uint32_t num_functional_writes = 0;
437 
438     // Access the buffers in the router for performing a functional write
439     for (unsigned int i = 0; i < m_router_buffers.size(); i++) {
440         for (unsigned int j = 0; j < m_router_buffers[i].size(); ++j) {
441             num_functional_writes +=
442                 m_router_buffers[i][j]->functionalWrite(pkt);
443         }
444     }
445 
446     // Access the link queues for performing a functional write
447     for (unsigned int i = 0; i < m_out_src_queue.size(); i++) {
448         num_functional_writes += m_out_src_queue[i]->functionalWrite(pkt);
449     }
450 
451     return num_functional_writes;
452 }
\end{DoxyCode}
\hypertarget{classRouter_a1a1889612585bf284775701c742a8449}{
\index{Router@{Router}!get\_\-valid\_\-vcs@{get\_\-valid\_\-vcs}}
\index{get\_\-valid\_\-vcs@{get\_\-valid\_\-vcs}!Router@{Router}}
\subsubsection[{get\_\-valid\_\-vcs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf vector}$<$ int $>$ get\_\-valid\_\-vcs (int {\em invc})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_a1a1889612585bf284775701c742a8449}



\begin{DoxyCode}
208 {
209     vector<int> vc_list;
210 
211     for (int vnet = 0; vnet < m_virtual_networks; vnet++) {
212         if (invc >= (vnet*m_vc_per_vnet) && invc < ((vnet+1)*m_vc_per_vnet)) {
213             int base = vnet*m_vc_per_vnet;
214             int vc_per_vnet;
215             if (m_net_ptr->isVNetOrdered(vnet))
216                 vc_per_vnet = 1;
217             else
218                 vc_per_vnet = m_vc_per_vnet;
219 
220             for (int offset = 0; offset < vc_per_vnet; offset++) {
221                 vc_list.push_back(base+offset);
222             }
223             break;
224         }
225     }
226     return vc_list;
227 }
\end{DoxyCode}
\hypertarget{classRouter_ae73de77352867d272505f41222809e17}{
\index{Router@{Router}!get\_\-vnet@{get\_\-vnet}}
\index{get\_\-vnet@{get\_\-vnet}!Router@{Router}}
\subsubsection[{get\_\-vnet}]{\setlength{\rightskip}{0pt plus 5cm}int get\_\-vnet (int {\em vc})}}
\label{classRouter_ae73de77352867d272505f41222809e17}



\begin{DoxyCode}
379 {
380     int vnet = vc/m_vc_per_vnet;
381     assert(vnet < m_virtual_networks);
382     return vnet;
383 }
\end{DoxyCode}
\hypertarget{classRouter_a2e327aa228d7975550910a9dfc67e222}{
\index{Router@{Router}!getRoute@{getRoute}}
\index{getRoute@{getRoute}!Router@{Router}}
\subsubsection[{getRoute}]{\setlength{\rightskip}{0pt plus 5cm}int getRoute ({\bf NetDest} {\em destination})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_a2e327aa228d7975550910a9dfc67e222}



\begin{DoxyCode}
248 {
249     int output_link = -1;
250     int min_weight = INFINITE_;
251     for (int link = 0; link < m_routing_table.size(); link++) {
252         if (destination.intersectionIsNotEmpty(m_routing_table[link])) {
253             if ((m_link_weights[link] >= min_weight))
254                 continue;
255             output_link = link;
256             min_weight = m_link_weights[link];
257         }
258     }
259     return output_link;
260 }
\end{DoxyCode}
\hypertarget{classRouter_af90fb6c473130244fe64e30e61b714f6}{
\index{Router@{Router}!grant\_\-vc@{grant\_\-vc}}
\index{grant\_\-vc@{grant\_\-vc}!Router@{Router}}
\subsubsection[{grant\_\-vc}]{\setlength{\rightskip}{0pt plus 5cm}void grant\_\-vc (int {\em out\_\-port}, \/  int {\em vc}, \/  {\bf Cycles} {\em grant\_\-time})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRouter_af90fb6c473130244fe64e30e61b714f6}


\hyperlink{classFlexibleConsumer_a775e8414113748731990f3979cdd4632}{FlexibleConsumer}を再定義しています。


\begin{DoxyCode}
231 {
232     assert(m_out_vc_state[out_port][vc]->isInState(VC_AB_, grant_time));
233     m_out_vc_state[out_port][vc]->grant_vc(grant_time);
234     scheduleEvent(Cycles(1));
235 }
\end{DoxyCode}
\hypertarget{classRouter_ab5da6a3c41f86ad2993eb11f4894ef00}{
\index{Router@{Router}!init\_\-net\_\-ptr@{init\_\-net\_\-ptr}}
\index{init\_\-net\_\-ptr@{init\_\-net\_\-ptr}!Router@{Router}}
\subsubsection[{init\_\-net\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}void init\_\-net\_\-ptr ({\bf GarnetNetwork} $\ast$ {\em net\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRouter_ab5da6a3c41f86ad2993eb11f4894ef00}



\begin{DoxyCode}
73     { 
74         m_net_ptr = net_ptr; 
75     }
\end{DoxyCode}
\hypertarget{classRouter_af3465adbf20f8764ea878ce2d28d2bc8}{
\index{Router@{Router}!isBufferNotFull@{isBufferNotFull}}
\index{isBufferNotFull@{isBufferNotFull}!Router@{Router}}
\subsubsection[{isBufferNotFull}]{\setlength{\rightskip}{0pt plus 5cm}bool isBufferNotFull (int {\em vc}, \/  int {\em inport})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRouter_af3465adbf20f8764ea878ce2d28d2bc8}


\hyperlink{classFlexibleConsumer_aa3732d20c1f3f94fb27ef60ac660f363}{FlexibleConsumer}を再定義しています。


\begin{DoxyCode}
122 {
123     int outport = m_in_vc_state[inport][vc]->get_outport();
124     int outvc = m_in_vc_state[inport][vc]->get_outvc();
125 
126     return (!m_router_buffers[outport][outvc]->isFull());
127 }
\end{DoxyCode}
\hypertarget{classRouter_ac55fe386a101fbae38c716067c9966a0}{
\index{Router@{Router}!print@{print}}
\index{print@{print}!Router@{Router}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}void print (std::ostream \& {\em out}) const}}
\label{classRouter_ac55fe386a101fbae38c716067c9966a0}


\hyperlink{classBasicRouter_ac55fe386a101fbae38c716067c9966a0}{BasicRouter}を再定義しています。\hypertarget{classRouter_adced7fd7d25eb0d6a869fff14085e8c3}{
\index{Router@{Router}!release\_\-vc@{release\_\-vc}}
\index{release\_\-vc@{release\_\-vc}!Router@{Router}}
\subsubsection[{release\_\-vc}]{\setlength{\rightskip}{0pt plus 5cm}void release\_\-vc (int {\em out\_\-port}, \/  int {\em vc}, \/  {\bf Cycles} {\em release\_\-time})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRouter_adced7fd7d25eb0d6a869fff14085e8c3}


\hyperlink{classFlexibleConsumer_a54d4f8948ced53110ed96024a64adf7e}{FlexibleConsumer}を再定義しています。


\begin{DoxyCode}
239 {
240     assert(m_out_vc_state[out_port][vc]->isInState(ACTIVE_, release_time));
241     m_out_vc_state[out_port][vc]->setState(IDLE_, release_time);
242     scheduleEvent(Cycles(1));
243 }
\end{DoxyCode}
\hypertarget{classRouter_ac2db714adfe0dfd2c3ac2b88bd6a5308}{
\index{Router@{Router}!request\_\-vc@{request\_\-vc}}
\index{request\_\-vc@{request\_\-vc}!Router@{Router}}
\subsubsection[{request\_\-vc}]{\setlength{\rightskip}{0pt plus 5cm}void request\_\-vc (int {\em in\_\-vc}, \/  int {\em in\_\-port}, \/  {\bf NetDest} {\em destination}, \/  {\bf Cycles} {\em request\_\-time})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRouter_ac2db714adfe0dfd2c3ac2b88bd6a5308}


\hyperlink{classFlexibleConsumer_aa0ffe58ceb5a05129736d59f3eeabcf0}{FlexibleConsumer}を再定義しています。


\begin{DoxyCode}
134 {
135     assert(m_in_vc_state[in_port][in_vc]->isInState(IDLE_, request_time));
136 
137     int outport = getRoute(destination);
138     m_in_vc_state[in_port][in_vc]->setRoute(outport);
139     m_in_vc_state[in_port][in_vc]->setState(VC_AB_, request_time);
140     assert(request_time >= curCycle());
141     if (request_time > curCycle())
142         m_vc_arbiter->scheduleEventAbsolute(clockPeriod() * request_time);
143     else
144         vc_arbitrate();
145 }
\end{DoxyCode}
\hypertarget{classRouter_aeb1ad1b60d443efcb72a73917e20bbd1}{
\index{Router@{Router}!routeCompute@{routeCompute}}
\index{routeCompute@{routeCompute}!Router@{Router}}
\subsubsection[{routeCompute}]{\setlength{\rightskip}{0pt plus 5cm}void routeCompute ({\bf flit} $\ast$ {\em m\_\-flit}, \/  int {\em inport})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_aeb1ad1b60d443efcb72a73917e20bbd1}



\begin{DoxyCode}
264 {
265     int invc = m_flit->get_vc();
266     int outport = m_in_vc_state[inport][invc]->get_outport();
267     int outvc = m_in_vc_state[inport][invc]->get_outvc();
268 
269     assert(m_net_ptr->getNumPipeStages() >= 1);
270 
271     // Subtract 1 as 1 cycle will be consumed in scheduling the output link
272     m_flit->set_time(curCycle() + Cycles((m_net_ptr->getNumPipeStages() - 1)));
273     m_flit->set_vc(outvc);
274     m_router_buffers[outport][outvc]->insert(m_flit);
275 
276     if (m_net_ptr->getNumPipeStages() > 1)
277         scheduleEvent(Cycles(m_net_ptr->getNumPipeStages() - 1));
278 
279     if ((m_flit->get_type() == HEAD_) || (m_flit->get_type() == HEAD_TAIL_)) {
280         NetworkMessage *nm =
281             safe_cast<NetworkMessage*>(m_flit->get_msg_ptr().get());
282         NetDest destination = nm->getInternalDestination();
283 
284         if (m_net_ptr->getNumPipeStages() > 1) {
285             m_out_vc_state[outport][outvc]->setState(VC_AB_, curCycle() +
286                                                      Cycles(1));
287             m_out_link[outport]->request_vc_link(outvc, destination,
288                                                  curCycle() + Cycles(1));
289         } else {
290             m_out_vc_state[outport][outvc]->setState(VC_AB_, curCycle());
291             m_out_link[outport]->request_vc_link(outvc, destination,
292                 curCycle());
293         }
294     }
295 
296     if ((m_flit->get_type() == TAIL_) || (m_flit->get_type() == HEAD_TAIL_)) {
297         m_in_vc_state[inport][invc]->setState(IDLE_, curCycle() + Cycles(1));
298         m_in_link[inport]->release_vc_link(invc, curCycle() + Cycles(1));
299     }
300 }
\end{DoxyCode}
\hypertarget{classRouter_a4a8dc105bd8d06865d65c708e3e21188}{
\index{Router@{Router}!scheduleOutputLinks@{scheduleOutputLinks}}
\index{scheduleOutputLinks@{scheduleOutputLinks}!Router@{Router}}
\subsubsection[{scheduleOutputLinks}]{\setlength{\rightskip}{0pt plus 5cm}void scheduleOutputLinks ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_a4a8dc105bd8d06865d65c708e3e21188}



\begin{DoxyCode}
336 {
337     for (int port = 0; port < m_out_link.size(); port++) {
338         int vc_tolookat = m_vc_round_robin[port];
339 
340         int next_round_robin_vc_tolookat = vc_tolookat;
341         do {
342             next_round_robin_vc_tolookat++;
343 
344             if (next_round_robin_vc_tolookat == m_num_vcs)
345                 next_round_robin_vc_tolookat = 0;
346         } while (!(m_net_ptr->validVirtualNetwork(
347                    get_vnet(next_round_robin_vc_tolookat))));
348 
349         m_vc_round_robin[port] = next_round_robin_vc_tolookat;
350 
351         for (int i = 0; i < m_num_vcs; i++) {
352             vc_tolookat++;
353             if (vc_tolookat == m_num_vcs)
354                 vc_tolookat = 0;
355 
356             if (m_router_buffers[port][vc_tolookat]->isReady(curCycle())) {
357 
358                 // models buffer backpressure
359                 if (m_out_vc_state[port][vc_tolookat]->isInState(ACTIVE_,
360                    curCycle()) &&
361                    m_out_link[port]->isBufferNotFull_link(vc_tolookat)) {
362 
363                     flit *t_flit =
364                         m_router_buffers[port][vc_tolookat]->getTopFlit();
365                     t_flit->set_time(curCycle() + Cycles(1));
366                     m_out_src_queue[port]->insert(t_flit);
367 
368                     m_out_link[port]->
369                         scheduleEventAbsolute(clockEdge(Cycles(1)));
370                     break; // done for this port
371                 }
372             }
373         }
374     }
375 }
\end{DoxyCode}
\hypertarget{classRouter_a3e82da716c2557efa2e6a293843b4d0a}{
\index{Router@{Router}!vc\_\-arbitrate@{vc\_\-arbitrate}}
\index{vc\_\-arbitrate@{vc\_\-arbitrate}!Router@{Router}}
\subsubsection[{vc\_\-arbitrate}]{\setlength{\rightskip}{0pt plus 5cm}void vc\_\-arbitrate ()}}
\label{classRouter_a3e82da716c2557efa2e6a293843b4d0a}



\begin{DoxyCode}
149 {
150     int inport = m_round_robin_inport;
151     m_round_robin_inport++;
152     if (m_round_robin_inport == m_in_link.size())
153         m_round_robin_inport = 0;
154 
155     for (int port_iter = 0; port_iter < m_in_link.size(); port_iter++) {
156         inport++;
157         if (inport >= m_in_link.size())
158             inport = 0;
159         int invc = m_round_robin_invc[inport];
160 
161         int next_round_robin_invc = invc;
162         do {
163             next_round_robin_invc++;
164 
165             if (next_round_robin_invc >= m_num_vcs)
166                 next_round_robin_invc = 0;
167 
168         } while (!(m_net_ptr->validVirtualNetwork(
169                    get_vnet(next_round_robin_invc))));
170 
171         m_round_robin_invc[inport] = next_round_robin_invc;
172 
173         for (int vc_iter = 0; vc_iter < m_num_vcs; vc_iter++) {
174             invc++;
175             if (invc >= m_num_vcs)
176                 invc = 0;
177 
178             if (!(m_net_ptr->validVirtualNetwork(get_vnet(invc))))
179                 continue;
180 
181             InVcState *in_vc_state = m_in_vc_state[inport][invc];
182 
183             if (in_vc_state->isInState(VC_AB_, curCycle())) {
184                 int outport = in_vc_state->get_outport();
185                 vector<int> valid_vcs = get_valid_vcs(invc);
186                 for (int valid_vc_iter = 0; valid_vc_iter < valid_vcs.size();
187                         valid_vc_iter++) {
188                     if (m_out_vc_state[outport][valid_vcs[valid_vc_iter]]
189                             ->isInState(IDLE_, curCycle())) {
190 
191                         in_vc_state->grant_vc(valid_vcs[valid_vc_iter],
192                                 curCycle());
193 
194                         m_in_link[inport]->grant_vc_link(invc, curCycle());
195 
196                         m_out_vc_state[outport][valid_vcs[valid_vc_iter]]
197                             ->setState(VC_AB_, curCycle());
198                         break;
199                     }
200                 }
201             }
202         }
203     }
204 }
\end{DoxyCode}
\hypertarget{classRouter_ae674290a26ecbd622c5160e38e8a4fe9}{
\index{Router@{Router}!wakeup@{wakeup}}
\index{wakeup@{wakeup}!Router@{Router}}
\subsubsection[{wakeup}]{\setlength{\rightskip}{0pt plus 5cm}void wakeup ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRouter_ae674290a26ecbd622c5160e38e8a4fe9}


\hyperlink{classConsumer_a623e3e7d1b1c725d70009f7b01a421b9}{Consumer}を実装しています。


\begin{DoxyCode}
304 {
305     flit *t_flit;
306 
307     // This is for round-robin scheduling of incoming ports
308     int incoming_port = m_round_robin_start;
309     m_round_robin_start++;
310     if (m_round_robin_start >= m_in_link.size()) {
311         m_round_robin_start = 0;
312     }
313 
314     for (int port = 0; port < m_in_link.size(); port++) {
315         // Round robin scheduling
316         incoming_port++;
317         if (incoming_port >= m_in_link.size())
318             incoming_port = 0;
319 
320         // checking the incoming link
321         if (m_in_link[incoming_port]->isReady()) {
322             DPRINTF(RubyNetwork, "m_id: %d, Time: %lld\n", m_id, curCycle());
323             t_flit = m_in_link[incoming_port]->peekLink();
324             routeCompute(t_flit, incoming_port);
325             m_in_link[incoming_port]->consumeLink();
326         }
327     }
328     scheduleOutputLinks();
329     checkReschedule(); // This is for flits lying in the router buffers
330     vc_arbitrate();
331     check_arbiter_reschedule();
332 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classRouter_a4ff3f0c2e50626b517ea98c165c9a0c3}{
\index{Router@{Router}!m\_\-in\_\-link@{m\_\-in\_\-link}}
\index{m\_\-in\_\-link@{m\_\-in\_\-link}!Router@{Router}}
\subsubsection[{m\_\-in\_\-link}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf NetworkLink} $\ast$$>$ {\bf m\_\-in\_\-link}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_a4ff3f0c2e50626b517ea98c165c9a0c3}
\hypertarget{classRouter_a9d8dfe7ed8a1027af42c383e180b8023}{
\index{Router@{Router}!m\_\-in\_\-vc\_\-state@{m\_\-in\_\-vc\_\-state}}
\index{m\_\-in\_\-vc\_\-state@{m\_\-in\_\-vc\_\-state}!Router@{Router}}
\subsubsection[{m\_\-in\_\-vc\_\-state}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf std::vector}$<${\bf InVcState} $\ast$$>$ $>$ {\bf m\_\-in\_\-vc\_\-state}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_a9d8dfe7ed8a1027af42c383e180b8023}
\hypertarget{classRouter_a0894e57ab5d2ddc0e8c5d60a53a27cff}{
\index{Router@{Router}!m\_\-link\_\-weights@{m\_\-link\_\-weights}}
\index{m\_\-link\_\-weights@{m\_\-link\_\-weights}!Router@{Router}}
\subsubsection[{m\_\-link\_\-weights}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<$int$>$ {\bf m\_\-link\_\-weights}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_a0894e57ab5d2ddc0e8c5d60a53a27cff}
\hypertarget{classRouter_a6f69c0ff922be798fa1cfce69f83244e}{
\index{Router@{Router}!m\_\-net\_\-ptr@{m\_\-net\_\-ptr}}
\index{m\_\-net\_\-ptr@{m\_\-net\_\-ptr}!Router@{Router}}
\subsubsection[{m\_\-net\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf GarnetNetwork}$\ast$ {\bf m\_\-net\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_a6f69c0ff922be798fa1cfce69f83244e}
\hypertarget{classRouter_a2e1a9213321dfa0386cdedaf6fc22996}{
\index{Router@{Router}!m\_\-num\_\-vcs@{m\_\-num\_\-vcs}}
\index{m\_\-num\_\-vcs@{m\_\-num\_\-vcs}!Router@{Router}}
\subsubsection[{m\_\-num\_\-vcs}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-num\_\-vcs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_a2e1a9213321dfa0386cdedaf6fc22996}
\hypertarget{classRouter_a2c9a37a8e348b31100b016ef9b51b235}{
\index{Router@{Router}!m\_\-out\_\-link@{m\_\-out\_\-link}}
\index{m\_\-out\_\-link@{m\_\-out\_\-link}!Router@{Router}}
\subsubsection[{m\_\-out\_\-link}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf NetworkLink} $\ast$$>$ {\bf m\_\-out\_\-link}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_a2c9a37a8e348b31100b016ef9b51b235}
\hypertarget{classRouter_a1022c5b57cefcbc48cc2b28e5b15f12e}{
\index{Router@{Router}!m\_\-out\_\-src\_\-queue@{m\_\-out\_\-src\_\-queue}}
\index{m\_\-out\_\-src\_\-queue@{m\_\-out\_\-src\_\-queue}!Router@{Router}}
\subsubsection[{m\_\-out\_\-src\_\-queue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf flitBuffer} $\ast$$>$ {\bf m\_\-out\_\-src\_\-queue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_a1022c5b57cefcbc48cc2b28e5b15f12e}
\hypertarget{classRouter_ac42fe6cf02410262c5525a2abcc921b6}{
\index{Router@{Router}!m\_\-out\_\-vc\_\-state@{m\_\-out\_\-vc\_\-state}}
\index{m\_\-out\_\-vc\_\-state@{m\_\-out\_\-vc\_\-state}!Router@{Router}}
\subsubsection[{m\_\-out\_\-vc\_\-state}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf std::vector}$<${\bf OutVcState} $\ast$$>$ $>$ {\bf m\_\-out\_\-vc\_\-state}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_ac42fe6cf02410262c5525a2abcc921b6}
\hypertarget{classRouter_a0c263ebf781383b8d6c95870cfaf076d}{
\index{Router@{Router}!m\_\-round\_\-robin\_\-inport@{m\_\-round\_\-robin\_\-inport}}
\index{m\_\-round\_\-robin\_\-inport@{m\_\-round\_\-robin\_\-inport}!Router@{Router}}
\subsubsection[{m\_\-round\_\-robin\_\-inport}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-round\_\-robin\_\-inport}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_a0c263ebf781383b8d6c95870cfaf076d}
\hypertarget{classRouter_a0445a5ec24b4ba3c94bfaac14bdff561}{
\index{Router@{Router}!m\_\-round\_\-robin\_\-invc@{m\_\-round\_\-robin\_\-invc}}
\index{m\_\-round\_\-robin\_\-invc@{m\_\-round\_\-robin\_\-invc}!Router@{Router}}
\subsubsection[{m\_\-round\_\-robin\_\-invc}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<$int$>$ {\bf m\_\-round\_\-robin\_\-invc}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_a0445a5ec24b4ba3c94bfaac14bdff561}
\hypertarget{classRouter_af4ca19e1a3ce236185490cf7e67f86d3}{
\index{Router@{Router}!m\_\-round\_\-robin\_\-start@{m\_\-round\_\-robin\_\-start}}
\index{m\_\-round\_\-robin\_\-start@{m\_\-round\_\-robin\_\-start}!Router@{Router}}
\subsubsection[{m\_\-round\_\-robin\_\-start}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-round\_\-robin\_\-start}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_af4ca19e1a3ce236185490cf7e67f86d3}
\hypertarget{classRouter_acb8a77bcc0e2cbc61f9b60cfa443acf0}{
\index{Router@{Router}!m\_\-router\_\-buffers@{m\_\-router\_\-buffers}}
\index{m\_\-router\_\-buffers@{m\_\-router\_\-buffers}!Router@{Router}}
\subsubsection[{m\_\-router\_\-buffers}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf std::vector}$<${\bf flitBuffer} $\ast$$>$ $>$ {\bf m\_\-router\_\-buffers}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_acb8a77bcc0e2cbc61f9b60cfa443acf0}
\hypertarget{classRouter_adce3e392ac98699a80750fa4a4aa9b40}{
\index{Router@{Router}!m\_\-routing\_\-table@{m\_\-routing\_\-table}}
\index{m\_\-routing\_\-table@{m\_\-routing\_\-table}!Router@{Router}}
\subsubsection[{m\_\-routing\_\-table}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf NetDest}$>$ {\bf m\_\-routing\_\-table}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_adce3e392ac98699a80750fa4a4aa9b40}
\hypertarget{classRouter_a03eb166814fcfceb112402a09259cae7}{
\index{Router@{Router}!m\_\-vc\_\-arbiter@{m\_\-vc\_\-arbiter}}
\index{m\_\-vc\_\-arbiter@{m\_\-vc\_\-arbiter}!Router@{Router}}
\subsubsection[{m\_\-vc\_\-arbiter}]{\setlength{\rightskip}{0pt plus 5cm}{\bf VCarbiter}$\ast$ {\bf m\_\-vc\_\-arbiter}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_a03eb166814fcfceb112402a09259cae7}
\hypertarget{classRouter_a2d66b8cad5144408ed492eeff4d37c2f}{
\index{Router@{Router}!m\_\-vc\_\-per\_\-vnet@{m\_\-vc\_\-per\_\-vnet}}
\index{m\_\-vc\_\-per\_\-vnet@{m\_\-vc\_\-per\_\-vnet}!Router@{Router}}
\subsubsection[{m\_\-vc\_\-per\_\-vnet}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-vc\_\-per\_\-vnet}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_a2d66b8cad5144408ed492eeff4d37c2f}
\hypertarget{classRouter_aac15a2e45cd3199aa6645027c3c49f29}{
\index{Router@{Router}!m\_\-vc\_\-round\_\-robin@{m\_\-vc\_\-round\_\-robin}}
\index{m\_\-vc\_\-round\_\-robin@{m\_\-vc\_\-round\_\-robin}!Router@{Router}}
\subsubsection[{m\_\-vc\_\-round\_\-robin}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<$int$>$ {\bf m\_\-vc\_\-round\_\-robin}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_aac15a2e45cd3199aa6645027c3c49f29}
\hypertarget{classRouter_af4cc96182e80059859793d92cb3dd769}{
\index{Router@{Router}!m\_\-virtual\_\-networks@{m\_\-virtual\_\-networks}}
\index{m\_\-virtual\_\-networks@{m\_\-virtual\_\-networks}!Router@{Router}}
\subsubsection[{m\_\-virtual\_\-networks}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-virtual\_\-networks}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRouter_af4cc96182e80059859793d92cb3dd769}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/ruby/network/garnet/flexible-\/pipeline/\hyperlink{Router_8hh}{Router.hh}\item 
mem/ruby/network/garnet/flexible-\/pipeline/\hyperlink{Router_8cc}{Router.cc}\end{DoxyCompactItemize}
