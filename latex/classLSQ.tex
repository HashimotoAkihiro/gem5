\hypertarget{classLSQ}{
\section{クラス テンプレート LSQ$<$ Impl $>$}
\label{classLSQ}\index{LSQ@{LSQ}}
}


{\ttfamily \#include $<$lsq.hh$>$}\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classLSQ_a2ecb54b28634ef872a820651cce92599}{LSQPolicy} \{ \hyperlink{classLSQ_a2ecb54b28634ef872a820651cce92599a96535b1625776102bcc13f7dfb598dcb}{Dynamic}, 
\hyperlink{classLSQ_a2ecb54b28634ef872a820651cce92599add8dfa69b567f90d3f13d819109ab74e}{Partitioned}, 
\hyperlink{classLSQ_a2ecb54b28634ef872a820651cce92599a267544c4de8ecc66bd0fed6310af63be}{Threshold}
 \}
\item 
typedef Impl::O3CPU \hyperlink{classLSQ_a44622cf06940413482836cb62931ac3f}{O3CPU}
\item 
typedef Impl::DynInstPtr \hyperlink{classLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}
\item 
typedef Impl::CPUPol::IEW \hyperlink{classLSQ_a23f60a4095b5240dfcb18a4ec40210a9}{IEW}
\item 
typedef Impl::CPUPol::LSQUnit \hyperlink{classLSQ_a978eac36269e7f814c4b396c9e4bf51e}{LSQUnit}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classLSQ_a268c66c8da0a95e3c0778a5e454ba669}{LSQ} (\hyperlink{classLSQ_a44622cf06940413482836cb62931ac3f}{O3CPU} $\ast$cpu\_\-ptr, \hyperlink{classLSQ_a23f60a4095b5240dfcb18a4ec40210a9}{IEW} $\ast$iew\_\-ptr, DerivO3CPUParams $\ast$params)
\item 
\hyperlink{classLSQ_aacb0af998a42267ae15bb83ec2b0753a}{$\sim$LSQ} ()
\item 
std::string \hyperlink{classLSQ_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classLSQ_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classLSQ_aab96bdacf8bd420402cbb543f994e054}{setActiveThreads} (\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$at\_\-ptr)
\item 
void \hyperlink{classLSQ_a0240eb42fa57fe5d3788093f62b77347}{drainSanityCheck} () const 
\item 
bool \hyperlink{classLSQ_adf5473c18a3d7c1e88c4a2072bce5526}{isDrained} () const 
\item 
void \hyperlink{classLSQ_a8674059ce345e23aac5086b2c3e24a43}{takeOverFrom} ()
\item 
int \hyperlink{classLSQ_a5d2b0e4e7d98ea4ebd9fb98ac0d91e2f}{entryAmount} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} num\_\-threads)
\item 
void \hyperlink{classLSQ_a53a4e3e73adce8cf2b544117971131c5}{removeEntries} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classLSQ_aaf9a05771a835f9f8d634cef36e24d40}{resetEntries} ()
\item 
void \hyperlink{classLSQ_a3672feee3a3eaad63f2e96d46385a099}{resizeEntries} (unsigned size, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classLSQ_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\item 
void \hyperlink{classLSQ_a6968bcfead3fa275f8a1e740c1e337e8}{tick} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classLSQ_ad22b3ecafed2bcd9c59fcab049a1cb98}{insertLoad} (\hyperlink{classLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&load\_\-inst)
\item 
void \hyperlink{classLSQ_a6a4b4e51bfff3639932ebaba45e8a282}{insertStore} (\hyperlink{classLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&store\_\-inst)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classLSQ_a30c6332142c2ecca389ed6ee463c692b}{executeLoad} (\hyperlink{classLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classLSQ_aad78b8a37ee5c61e47df58dd39980340}{executeStore} (\hyperlink{classLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classLSQ_af03ccef8cb6360230dd0060c8996be2d}{commitLoads} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&youngest\_\-inst, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classLSQ_a096edcd9c962aec4ad10871da44aa5b9}{commitStores} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&youngest\_\-inst, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classLSQ_a5f04e29d6f6feb8b86460491f2ba7547}{writebackStores} ()
\item 
void \hyperlink{classLSQ_aebf9f82a83e61cd390df68a2fb7a8641}{writebackStores} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classLSQ_a74283dfde2ab06c84e10bd85000c168b}{squash} (const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&squashed\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classLSQ_a4f720bbfb5fdefdb23516500eeb0b4de}{violation} ()
\item 
bool \hyperlink{classLSQ_a24dee29bada56cd1c98a7c3d80e77b6e}{violation} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classLSQ_a95b69602ad810ff8ec5d2b0ea2619945}{loadBlocked} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classLSQ_a27440751be2f0a382983e7077342f2fe}{isLoadBlockedHandled} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classLSQ_a30c462e914644ddba59b0d769941b5dd}{setLoadBlockedHandled} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
\hyperlink{classLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classLSQ_a62fec9ff095a709800a97ac7a3d27c78}{getMemDepViolator} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
int \hyperlink{classLSQ_afa7f4e992343baa21a2580e2243e71e0}{getLoadHead} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classLSQ_a190e0bb202a3dc8a203e18c67b334729}{getLoadHeadSeqNum} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
int \hyperlink{classLSQ_a0645614312b9a74b4adb8bc83b4f34ef}{getStoreHead} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classLSQ_a12f6a1158c09e1531b46d0aafb4e2ae4}{getStoreHeadSeqNum} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
int \hyperlink{classLSQ_ae452b1c7e00c383f2916c4a530fab737}{getCount} ()
\item 
int \hyperlink{classLSQ_aa2a7dc807b5a961bae06a5aa5b348448}{getCount} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
int \hyperlink{classLSQ_a54460b759fb06e2b18e26657279a6f49}{numLoads} ()
\item 
int \hyperlink{classLSQ_adcdafd05eb96f01fa490a847d57d0bec}{numLoads} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
int \hyperlink{classLSQ_aa0fc32a4a9d77696f5907f4d25e7d07f}{numStores} ()
\item 
int \hyperlink{classLSQ_a12346c097127dd67f1f9e8d28e12858f}{numStores} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
unsigned \hyperlink{classLSQ_a028971a565aca048c67ea1c36a6a9d51}{numFreeEntries} ()
\item 
unsigned \hyperlink{classLSQ_acc878f608deead5b5319a6a3f98b50c8}{numFreeEntries} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classLSQ_a3e70330939fdfc4dbc2f60c1a660584d}{isFull} ()
\item 
bool \hyperlink{classLSQ_a30fac732df9b3fda011c7329a112cb31}{isFull} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classLSQ_a479432127ee77145cc19d6a2d1590821}{isEmpty} () const 
\item 
bool \hyperlink{classLSQ_a01d2807c1345befcffd168a2a9dbdbf2}{lqEmpty} () const 
\item 
bool \hyperlink{classLSQ_a5761e9640bec8ba8474945cce57b6501}{sqEmpty} () const 
\item 
bool \hyperlink{classLSQ_a5893daf623130be826f492bbff58f757}{lqFull} ()
\item 
bool \hyperlink{classLSQ_afa1d531e5f388b1cdc3af03100f63061}{lqFull} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classLSQ_a477981d1f905d2d398a1527f7149e3c4}{sqFull} ()
\item 
bool \hyperlink{classLSQ_a6a3501ebb06c38938a3b0ebcea2b6a8b}{sqFull} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classLSQ_af8eb8590fbfa6ecd2f796390677a4c00}{isStalled} ()
\item 
bool \hyperlink{classLSQ_a5532c6a5a314b05c9d29a319aa3a76a6}{isStalled} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classLSQ_ad2e4b46255cfb53e85522adeed4e2089}{hasStoresToWB} ()
\item 
bool \hyperlink{classLSQ_a7e6f40e5ef3dbfe9d3d8da2dbeaf2b91}{hasStoresToWB} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
int \hyperlink{classLSQ_a4115edd209f7e5e51c3a17d40edd9e7a}{numStoresToWB} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classLSQ_a338be821734603396bfef8d9fb8f04b0}{willWB} ()
\item 
bool \hyperlink{classLSQ_a71ae97788e6b1230662807e1b03f47b3}{willWB} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classLSQ_a050e3736ea48bf74bd0c216b1cd3f494}{cacheBlocked} () const 
\item 
void \hyperlink{classLSQ_aca00d390ba2ada0daf6e0c0a7cf75f57}{setRetryTid} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classLSQ_ad0dcc54f6823ec37a9ab4eef289e2305}{dumpInsts} () const 
\item 
void \hyperlink{classLSQ_a720e1bd0f477c100c9c9ca0b6ced109f}{dumpInsts} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid) const 
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classLSQ_a206ad0283d431e78e6f38bb9b54b23ee}{read} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classRequest}{RequestPtr} sreqLow, \hyperlink{classRequest}{RequestPtr} sreqHigh, uint8\_\-t $\ast$data, int load\_\-idx)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classLSQ_a1be8f3ccb9b2787a2c92bfab3fda9675}{write} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classRequest}{RequestPtr} sreqLow, \hyperlink{classRequest}{RequestPtr} sreqHigh, uint8\_\-t $\ast$data, int store\_\-idx)
\item 
void \hyperlink{classLSQ_a29cb5a4f98063ce6e9210eacbdb35298}{recvRetry} ()
\item 
bool \hyperlink{classLSQ_a482dba5588f4bee43e498875a61e5e0b}{recvTimingResp} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classLSQ_aff3031c56fc4947a19695c868bb8233e}{recvTimingSnoopReq} (\hyperlink{classPacket}{PacketPtr} pkt)
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classLSQ_a44622cf06940413482836cb62931ac3f}{O3CPU} $\ast$ \hyperlink{classLSQ_a1379cf882a12ac6fc9eba5da7c84b18b}{cpu}
\item 
\hyperlink{classLSQ_a23f60a4095b5240dfcb18a4ec40210a9}{IEW} $\ast$ \hyperlink{classLSQ_a4e9ef25d8913b270d432be4bbfe4965c}{iewStage}
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classLSQ_a2ecb54b28634ef872a820651cce92599}{LSQPolicy} \hyperlink{classLSQ_a28ca1f0961b84f3386b592d1e3e1b411}{lsqPolicy}
\item 
\hyperlink{classLSQUnit}{LSQUnit} $\ast$ \hyperlink{classLSQ_a5709dc03226b4fc5a49a4c6a41ff50ad}{thread}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$ \hyperlink{classLSQ_af6eaea53db532812052f71bf0380dab5}{activeThreads}
\item 
unsigned \hyperlink{classLSQ_aafa99d800d574095881acbacdbbbcc47}{LQEntries}
\item 
unsigned \hyperlink{classLSQ_a38c8af5392da70119dc5cce4e3637cbc}{SQEntries}
\item 
unsigned \hyperlink{classLSQ_ad2f4fd027fe71a87d5ee2d798ec19ac3}{maxLQEntries}
\item 
unsigned \hyperlink{classLSQ_a0e9eef7cd7598f554f1f89c35cb08128}{maxSQEntries}
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classLSQ_a88377f855dbf5adeeecb06b5bb821d35}{numThreads}
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classLSQ_a865aaad70625f17392c717930860d386}{retryTid}
\end{DoxyCompactItemize}
\subsubsection*{template$<$class Impl$>$ class LSQ$<$ Impl $>$}



\subsection{型定義}
\hypertarget{classLSQ_a028ce10889c5f6450239d9e9a7347976}{
\index{LSQ@{LSQ}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!LSQ@{LSQ}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInstPtr {\bf DynInstPtr}}}
\label{classLSQ_a028ce10889c5f6450239d9e9a7347976}
\hypertarget{classLSQ_a23f60a4095b5240dfcb18a4ec40210a9}{
\index{LSQ@{LSQ}!IEW@{IEW}}
\index{IEW@{IEW}!LSQ@{LSQ}}
\subsubsection[{IEW}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::CPUPol::IEW {\bf IEW}}}
\label{classLSQ_a23f60a4095b5240dfcb18a4ec40210a9}
\hypertarget{classLSQ_a978eac36269e7f814c4b396c9e4bf51e}{
\index{LSQ@{LSQ}!LSQUnit@{LSQUnit}}
\index{LSQUnit@{LSQUnit}!LSQ@{LSQ}}
\subsubsection[{LSQUnit}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::CPUPol::LSQUnit {\bf LSQUnit}}}
\label{classLSQ_a978eac36269e7f814c4b396c9e4bf51e}
\hypertarget{classLSQ_a44622cf06940413482836cb62931ac3f}{
\index{LSQ@{LSQ}!O3CPU@{O3CPU}}
\index{O3CPU@{O3CPU}!LSQ@{LSQ}}
\subsubsection[{O3CPU}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::O3CPU {\bf O3CPU}}}
\label{classLSQ_a44622cf06940413482836cb62931ac3f}


\subsection{列挙型}
\hypertarget{classLSQ_a2ecb54b28634ef872a820651cce92599}{
\index{LSQ@{LSQ}!LSQPolicy@{LSQPolicy}}
\index{LSQPolicy@{LSQPolicy}!LSQ@{LSQ}}
\subsubsection[{LSQPolicy}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf LSQPolicy}}}
\label{classLSQ_a2ecb54b28634ef872a820651cce92599}
SMT policy. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Dynamic@{Dynamic}!LSQ@{LSQ}}\index{LSQ@{LSQ}!Dynamic@{Dynamic}}\item[{\em 
\hypertarget{classLSQ_a2ecb54b28634ef872a820651cce92599a96535b1625776102bcc13f7dfb598dcb}{
Dynamic}
\label{classLSQ_a2ecb54b28634ef872a820651cce92599a96535b1625776102bcc13f7dfb598dcb}
}]\index{Partitioned@{Partitioned}!LSQ@{LSQ}}\index{LSQ@{LSQ}!Partitioned@{Partitioned}}\item[{\em 
\hypertarget{classLSQ_a2ecb54b28634ef872a820651cce92599add8dfa69b567f90d3f13d819109ab74e}{
Partitioned}
\label{classLSQ_a2ecb54b28634ef872a820651cce92599add8dfa69b567f90d3f13d819109ab74e}
}]\index{Threshold@{Threshold}!LSQ@{LSQ}}\index{LSQ@{LSQ}!Threshold@{Threshold}}\item[{\em 
\hypertarget{classLSQ_a2ecb54b28634ef872a820651cce92599a267544c4de8ecc66bd0fed6310af63be}{
Threshold}
\label{classLSQ_a2ecb54b28634ef872a820651cce92599a267544c4de8ecc66bd0fed6310af63be}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
65                    {
66         Dynamic,
67         Partitioned,
68         Threshold
69     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classLSQ_a268c66c8da0a95e3c0778a5e454ba669}{
\index{LSQ@{LSQ}!LSQ@{LSQ}}
\index{LSQ@{LSQ}!LSQ@{LSQ}}
\subsubsection[{LSQ}]{\setlength{\rightskip}{0pt plus 5cm}{\bf LSQ} ({\bf O3CPU} $\ast$ {\em cpu\_\-ptr}, \/  {\bf IEW} $\ast$ {\em iew\_\-ptr}, \/  DerivO3CPUParams $\ast$ {\em params})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a268c66c8da0a95e3c0778a5e454ba669}
Constructs an \hyperlink{classLSQ}{LSQ} with the given parameters. 


\begin{DoxyCode}
61     : cpu(cpu_ptr), iewStage(iew_ptr),
62       LQEntries(params->LQEntries),
63       SQEntries(params->SQEntries),
64       numThreads(params->numThreads),
65       retryTid(-1)
66 {
67     assert(numThreads > 0 && numThreads <= Impl::MaxThreads);
68 
69     //**********************************************/
70     //************ Handle SMT Parameters ***********/
71     //**********************************************/
72     std::string policy = params->smtLSQPolicy;
73 
74     //Convert string to lowercase
75     std::transform(policy.begin(), policy.end(), policy.begin(),
76                    (int(*)(int)) tolower);
77 
78     //Figure out fetch policy
79     if (policy == "dynamic") {
80         lsqPolicy = Dynamic;
81 
82         maxLQEntries = LQEntries;
83         maxSQEntries = SQEntries;
84 
85         DPRINTF(LSQ, "LSQ sharing policy set to Dynamic\n");
86     } else if (policy == "partitioned") {
87         lsqPolicy = Partitioned;
88 
89         //@todo:make work if part_amt doesnt divide evenly.
90         maxLQEntries = LQEntries / numThreads;
91         maxSQEntries = SQEntries / numThreads;
92 
93         DPRINTF(Fetch, "LSQ sharing policy set to Partitioned: "
94                 "%i entries per LQ | %i entries per SQ\n",
95                 maxLQEntries,maxSQEntries);
96     } else if (policy == "threshold") {
97         lsqPolicy = Threshold;
98 
99         assert(params->smtLSQThreshold > LQEntries);
100         assert(params->smtLSQThreshold > SQEntries);
101 
102         //Divide up by threshold amount
103         //@todo: Should threads check the max and the total
104         //amount of the LSQ
105         maxLQEntries  = params->smtLSQThreshold;
106         maxSQEntries  = params->smtLSQThreshold;
107 
108         DPRINTF(LSQ, "LSQ sharing policy set to Threshold: "
109                 "%i entries per LQ | %i entries per SQ\n",
110                 maxLQEntries,maxSQEntries);
111     } else {
112         assert(0 && "Invalid LSQ Sharing Policy.Options Are:{Dynamic,"
113                     "Partitioned, Threshold}");
114     }
115 
116     //Initialize LSQs
117     thread = new LSQUnit[numThreads];
118     for (ThreadID tid = 0; tid < numThreads; tid++) {
119         thread[tid].init(cpu, iew_ptr, params, this,
120                          maxLQEntries, maxSQEntries, tid);
121         thread[tid].setDcachePort(&cpu_ptr->getDataPort());
122     }
123 }
\end{DoxyCode}
\hypertarget{classLSQ_aacb0af998a42267ae15bb83ec2b0753a}{
\index{LSQ@{LSQ}!$\sim$LSQ@{$\sim$LSQ}}
\index{$\sim$LSQ@{$\sim$LSQ}!LSQ@{LSQ}}
\subsubsection[{$\sim$LSQ}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf LSQ} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_aacb0af998a42267ae15bb83ec2b0753a}



\begin{DoxyCode}
73            {
74         if (thread) delete [] thread;
75     }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classLSQ_a050e3736ea48bf74bd0c216b1cd3f494}{
\index{LSQ@{LSQ}!cacheBlocked@{cacheBlocked}}
\index{cacheBlocked@{cacheBlocked}!LSQ@{LSQ}}
\subsubsection[{cacheBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool cacheBlocked () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a050e3736ea48bf74bd0c216b1cd3f494}
Returns if the cache is currently blocked. 


\begin{DoxyCode}
271     { return retryTid != InvalidThreadID; }
\end{DoxyCode}
\hypertarget{classLSQ_af03ccef8cb6360230dd0060c8996be2d}{
\index{LSQ@{LSQ}!commitLoads@{commitLoads}}
\index{commitLoads@{commitLoads}!LSQ@{LSQ}}
\subsubsection[{commitLoads}]{\setlength{\rightskip}{0pt plus 5cm}void commitLoads ({\bf InstSeqNum} \& {\em youngest\_\-inst}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_af03ccef8cb6360230dd0060c8996be2d}
Commits loads up until the given sequence number for a specific thread. 


\begin{DoxyCode}
122     { thread[tid].commitLoads(youngest_inst); }
\end{DoxyCode}
\hypertarget{classLSQ_a096edcd9c962aec4ad10871da44aa5b9}{
\index{LSQ@{LSQ}!commitStores@{commitStores}}
\index{commitStores@{commitStores}!LSQ@{LSQ}}
\subsubsection[{commitStores}]{\setlength{\rightskip}{0pt plus 5cm}void commitStores ({\bf InstSeqNum} \& {\em youngest\_\-inst}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a096edcd9c962aec4ad10871da44aa5b9}
Commits stores up until the given sequence number for a specific thread. 


\begin{DoxyCode}
128     { thread[tid].commitStores(youngest_inst); }
\end{DoxyCode}
\hypertarget{classLSQ_a0240eb42fa57fe5d3788093f62b77347}{
\index{LSQ@{LSQ}!drainSanityCheck@{drainSanityCheck}}
\index{drainSanityCheck@{drainSanityCheck}!LSQ@{LSQ}}
\subsubsection[{drainSanityCheck}]{\setlength{\rightskip}{0pt plus 5cm}void drainSanityCheck () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a0240eb42fa57fe5d3788093f62b77347}
Perform sanity checks after a drain. 


\begin{DoxyCode}
154 {
155     assert(isDrained());
156 
157     for (ThreadID tid = 0; tid < numThreads; tid++)
158         thread[tid].drainSanityCheck();
159 }
\end{DoxyCode}
\hypertarget{classLSQ_a720e1bd0f477c100c9c9ca0b6ced109f}{
\index{LSQ@{LSQ}!dumpInsts@{dumpInsts}}
\index{dumpInsts@{dumpInsts}!LSQ@{LSQ}}
\subsubsection[{dumpInsts}]{\setlength{\rightskip}{0pt plus 5cm}void dumpInsts ({\bf ThreadID} {\em tid}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a720e1bd0f477c100c9c9ca0b6ced109f}
Debugging function to print out instructions from a specific thread. 


\begin{DoxyCode}
282     { thread[tid].dumpInsts(); }
\end{DoxyCode}
\hypertarget{classLSQ_ad0dcc54f6823ec37a9ab4eef289e2305}{
\index{LSQ@{LSQ}!dumpInsts@{dumpInsts}}
\index{dumpInsts@{dumpInsts}!LSQ@{LSQ}}
\subsubsection[{dumpInsts}]{\setlength{\rightskip}{0pt plus 5cm}void dumpInsts () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_ad0dcc54f6823ec37a9ab4eef289e2305}
Debugging function to print out all instructions. 


\begin{DoxyCode}
654 {
655     list<ThreadID>::const_iterator threads = activeThreads->begin();
656     list<ThreadID>::const_iterator end = activeThreads->end();
657 
658     while (threads != end) {
659         ThreadID tid = *threads++;
660 
661         thread[tid].dumpInsts();
662     }
663 }
\end{DoxyCode}
\hypertarget{classLSQ_a5d2b0e4e7d98ea4ebd9fb98ac0d91e2f}{
\index{LSQ@{LSQ}!entryAmount@{entryAmount}}
\index{entryAmount@{entryAmount}!LSQ@{LSQ}}
\subsubsection[{entryAmount}]{\setlength{\rightskip}{0pt plus 5cm}int entryAmount ({\bf ThreadID} {\em num\_\-threads})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a5d2b0e4e7d98ea4ebd9fb98ac0d91e2f}
Number of entries needed for the given amount of threads. 


\begin{DoxyCode}
197 {
198     if (lsqPolicy == Partitioned) {
199         return LQEntries / num_threads;
200     } else {
201         return 0;
202     }
203 }
\end{DoxyCode}
\hypertarget{classLSQ_a30c6332142c2ecca389ed6ee463c692b}{
\index{LSQ@{LSQ}!executeLoad@{executeLoad}}
\index{executeLoad@{executeLoad}!LSQ@{LSQ}}
\subsubsection[{executeLoad}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} executeLoad ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a30c6332142c2ecca389ed6ee463c692b}
Executes a load. 


\begin{DoxyCode}
284 {
285     ThreadID tid = inst->threadNumber;
286 
287     return thread[tid].executeLoad(inst);
288 }
\end{DoxyCode}
\hypertarget{classLSQ_aad78b8a37ee5c61e47df58dd39980340}{
\index{LSQ@{LSQ}!executeStore@{executeStore}}
\index{executeStore@{executeStore}!LSQ@{LSQ}}
\subsubsection[{executeStore}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} executeStore ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_aad78b8a37ee5c61e47df58dd39980340}
Executes a store. 


\begin{DoxyCode}
293 {
294     ThreadID tid = inst->threadNumber;
295 
296     return thread[tid].executeStore(inst);
297 }
\end{DoxyCode}
\hypertarget{classLSQ_aa2a7dc807b5a961bae06a5aa5b348448}{
\index{LSQ@{LSQ}!getCount@{getCount}}
\index{getCount@{getCount}!LSQ@{LSQ}}
\subsubsection[{getCount}]{\setlength{\rightskip}{0pt plus 5cm}int getCount ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_aa2a7dc807b5a961bae06a5aa5b348448}
Returns the number of instructions in the queues of one thread. 


\begin{DoxyCode}
193     { return thread[tid].getCount(); }
\end{DoxyCode}
\hypertarget{classLSQ_ae452b1c7e00c383f2916c4a530fab737}{
\index{LSQ@{LSQ}!getCount@{getCount}}
\index{getCount@{getCount}!LSQ@{LSQ}}
\subsubsection[{getCount}]{\setlength{\rightskip}{0pt plus 5cm}int getCount ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_ae452b1c7e00c383f2916c4a530fab737}
Returns the number of instructions in all of the queues. 


\begin{DoxyCode}
383 {
384     unsigned total = 0;
385 
386     list<ThreadID>::iterator threads = activeThreads->begin();
387     list<ThreadID>::iterator end = activeThreads->end();
388 
389     while (threads != end) {
390         ThreadID tid = *threads++;
391 
392         total += getCount(tid);
393     }
394 
395     return total;
396 }
\end{DoxyCode}
\hypertarget{classLSQ_afa7f4e992343baa21a2580e2243e71e0}{
\index{LSQ@{LSQ}!getLoadHead@{getLoadHead}}
\index{getLoadHead@{getLoadHead}!LSQ@{LSQ}}
\subsubsection[{getLoadHead}]{\setlength{\rightskip}{0pt plus 5cm}int getLoadHead ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_afa7f4e992343baa21a2580e2243e71e0}
Returns the head index of the load queue for a specific thread. 


\begin{DoxyCode}
171     { return thread[tid].getLoadHead(); }
\end{DoxyCode}
\hypertarget{classLSQ_a190e0bb202a3dc8a203e18c67b334729}{
\index{LSQ@{LSQ}!getLoadHeadSeqNum@{getLoadHeadSeqNum}}
\index{getLoadHeadSeqNum@{getLoadHeadSeqNum}!LSQ@{LSQ}}
\subsubsection[{getLoadHeadSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} getLoadHeadSeqNum ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a190e0bb202a3dc8a203e18c67b334729}
Returns the sequence number of the head of the load queue. 


\begin{DoxyCode}
175     {
176         return thread[tid].getLoadHeadSeqNum();
177     }
\end{DoxyCode}
\hypertarget{classLSQ_a62fec9ff095a709800a97ac7a3d27c78}{
\index{LSQ@{LSQ}!getMemDepViolator@{getMemDepViolator}}
\index{getMemDepViolator@{getMemDepViolator}!LSQ@{LSQ}}
\subsubsection[{getMemDepViolator}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} getMemDepViolator ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a62fec9ff095a709800a97ac7a3d27c78}
Gets the instruction that caused the memory ordering violation. 


\begin{DoxyCode}
167     { return thread[tid].getMemDepViolator(); }
\end{DoxyCode}
\hypertarget{classLSQ_a0645614312b9a74b4adb8bc83b4f34ef}{
\index{LSQ@{LSQ}!getStoreHead@{getStoreHead}}
\index{getStoreHead@{getStoreHead}!LSQ@{LSQ}}
\subsubsection[{getStoreHead}]{\setlength{\rightskip}{0pt plus 5cm}int getStoreHead ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a0645614312b9a74b4adb8bc83b4f34ef}
Returns the head index of the store queue. 


\begin{DoxyCode}
181     { return thread[tid].getStoreHead(); }
\end{DoxyCode}
\hypertarget{classLSQ_a12f6a1158c09e1531b46d0aafb4e2ae4}{
\index{LSQ@{LSQ}!getStoreHeadSeqNum@{getStoreHeadSeqNum}}
\index{getStoreHeadSeqNum@{getStoreHeadSeqNum}!LSQ@{LSQ}}
\subsubsection[{getStoreHeadSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} getStoreHeadSeqNum ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a12f6a1158c09e1531b46d0aafb4e2ae4}
Returns the sequence number of the head of the store queue. 


\begin{DoxyCode}
185     {
186         return thread[tid].getStoreHeadSeqNum();
187     }
\end{DoxyCode}
\hypertarget{classLSQ_a7e6f40e5ef3dbfe9d3d8da2dbeaf2b91}{
\index{LSQ@{LSQ}!hasStoresToWB@{hasStoresToWB}}
\index{hasStoresToWB@{hasStoresToWB}!LSQ@{LSQ}}
\subsubsection[{hasStoresToWB}]{\setlength{\rightskip}{0pt plus 5cm}bool hasStoresToWB ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a7e6f40e5ef3dbfe9d3d8da2dbeaf2b91}
Returns whether or not a specific thread has any stores to write back to memory. 


\begin{DoxyCode}
255     { return thread[tid].hasStoresToWB(); }
\end{DoxyCode}
\hypertarget{classLSQ_ad2e4b46255cfb53e85522adeed4e2089}{
\index{LSQ@{LSQ}!hasStoresToWB@{hasStoresToWB}}
\index{hasStoresToWB@{hasStoresToWB}!LSQ@{LSQ}}
\subsubsection[{hasStoresToWB}]{\setlength{\rightskip}{0pt plus 5cm}bool hasStoresToWB ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_ad2e4b46255cfb53e85522adeed4e2089}
Returns whether or not there are any stores to write back to memory. 


\begin{DoxyCode}
620 {
621     list<ThreadID>::iterator threads = activeThreads->begin();
622     list<ThreadID>::iterator end = activeThreads->end();
623 
624     while (threads != end) {
625         ThreadID tid = *threads++;
626 
627         if (hasStoresToWB(tid))
628             return true;
629     }
630 
631     return false;
632 }
\end{DoxyCode}
\hypertarget{classLSQ_ad22b3ecafed2bcd9c59fcab049a1cb98}{
\index{LSQ@{LSQ}!insertLoad@{insertLoad}}
\index{insertLoad@{insertLoad}!LSQ@{LSQ}}
\subsubsection[{insertLoad}]{\setlength{\rightskip}{0pt plus 5cm}void insertLoad ({\bf DynInstPtr} \& {\em load\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_ad22b3ecafed2bcd9c59fcab049a1cb98}
Inserts a load into the \hyperlink{classLSQ}{LSQ}. 


\begin{DoxyCode}
266 {
267     ThreadID tid = load_inst->threadNumber;
268 
269     thread[tid].insertLoad(load_inst);
270 }
\end{DoxyCode}
\hypertarget{classLSQ_a6a4b4e51bfff3639932ebaba45e8a282}{
\index{LSQ@{LSQ}!insertStore@{insertStore}}
\index{insertStore@{insertStore}!LSQ@{LSQ}}
\subsubsection[{insertStore}]{\setlength{\rightskip}{0pt plus 5cm}void insertStore ({\bf DynInstPtr} \& {\em store\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a6a4b4e51bfff3639932ebaba45e8a282}
Inserts a store into the \hyperlink{classLSQ}{LSQ}. 


\begin{DoxyCode}
275 {
276     ThreadID tid = store_inst->threadNumber;
277 
278     thread[tid].insertStore(store_inst);
279 }
\end{DoxyCode}
\hypertarget{classLSQ_adf5473c18a3d7c1e88c4a2072bce5526}{
\index{LSQ@{LSQ}!isDrained@{isDrained}}
\index{isDrained@{isDrained}!LSQ@{LSQ}}
\subsubsection[{isDrained}]{\setlength{\rightskip}{0pt plus 5cm}bool isDrained () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_adf5473c18a3d7c1e88c4a2072bce5526}
Has the \hyperlink{classLSQ}{LSQ} drained? 


\begin{DoxyCode}
164 {
165     bool drained(true);
166 
167     if (!lqEmpty()) {
168         DPRINTF(Drain, "Not drained, LQ not empty.\n");
169         drained = false;
170     }
171 
172     if (!sqEmpty()) {
173         DPRINTF(Drain, "Not drained, SQ not empty.\n");
174         drained = false;
175     }
176 
177     if (retryTid != InvalidThreadID) {
178         DPRINTF(Drain, "Not drained, the LSQ has blocked the caches.\n");
179         drained = false;
180     }
181 
182     return drained;
183 }
\end{DoxyCode}
\hypertarget{classLSQ_a479432127ee77145cc19d6a2d1590821}{
\index{LSQ@{LSQ}!isEmpty@{isEmpty}}
\index{isEmpty@{isEmpty}!LSQ@{LSQ}}
\subsubsection[{isEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool isEmpty () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a479432127ee77145cc19d6a2d1590821}
Returns if the \hyperlink{classLSQ}{LSQ} is empty (both LQ and SQ are empty). 


\begin{DoxyCode}
494 {
495     return lqEmpty() && sqEmpty();
496 }
\end{DoxyCode}
\hypertarget{classLSQ_a30fac732df9b3fda011c7329a112cb31}{
\index{LSQ@{LSQ}!isFull@{isFull}}
\index{isFull@{isFull}!LSQ@{LSQ}}
\subsubsection[{isFull}]{\setlength{\rightskip}{0pt plus 5cm}bool isFull ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a30fac732df9b3fda011c7329a112cb31}
Returns if the \hyperlink{classLSQ}{LSQ} is full for a specific thread (either LQ or SQ is full). 


\begin{DoxyCode}
482 {
483     //@todo: Change to Calculate All Entries for
484     //Dynamic Policy
485     if (lsqPolicy == Dynamic)
486         return isFull();
487     else
488         return thread[tid].lqFull() || thread[tid].sqFull();
489 }
\end{DoxyCode}
\hypertarget{classLSQ_a3e70330939fdfc4dbc2f60c1a660584d}{
\index{LSQ@{LSQ}!isFull@{isFull}}
\index{isFull@{isFull}!LSQ@{LSQ}}
\subsubsection[{isFull}]{\setlength{\rightskip}{0pt plus 5cm}bool isFull ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a3e70330939fdfc4dbc2f60c1a660584d}
Returns if the \hyperlink{classLSQ}{LSQ} is full (either LQ or SQ is full). 


\begin{DoxyCode}
465 {
466     list<ThreadID>::iterator threads = activeThreads->begin();
467     list<ThreadID>::iterator end = activeThreads->end();
468 
469     while (threads != end) {
470         ThreadID tid = *threads++;
471 
472         if (!(thread[tid].lqFull() || thread[tid].sqFull()))
473             return false;
474     }
475 
476     return true;
477 }
\end{DoxyCode}
\hypertarget{classLSQ_a27440751be2f0a382983e7077342f2fe}{
\index{LSQ@{LSQ}!isLoadBlockedHandled@{isLoadBlockedHandled}}
\index{isLoadBlockedHandled@{isLoadBlockedHandled}!LSQ@{LSQ}}
\subsubsection[{isLoadBlockedHandled}]{\setlength{\rightskip}{0pt plus 5cm}bool isLoadBlockedHandled ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a27440751be2f0a382983e7077342f2fe}



\begin{DoxyCode}
160     { return thread[tid].isLoadBlockedHandled(); }
\end{DoxyCode}
\hypertarget{classLSQ_a5532c6a5a314b05c9d29a319aa3a76a6}{
\index{LSQ@{LSQ}!isStalled@{isStalled}}
\index{isStalled@{isStalled}!LSQ@{LSQ}}
\subsubsection[{isStalled}]{\setlength{\rightskip}{0pt plus 5cm}bool isStalled ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a5532c6a5a314b05c9d29a319aa3a76a6}
Returns if the \hyperlink{classLSQ}{LSQ} of a specific thread is stalled due to a memory operation that must be replayed. 


\begin{DoxyCode}
610 {
611     if (lsqPolicy == Dynamic)
612         return isStalled();
613     else
614         return thread[tid].isStalled();
615 }
\end{DoxyCode}
\hypertarget{classLSQ_af8eb8590fbfa6ecd2f796390677a4c00}{
\index{LSQ@{LSQ}!isStalled@{isStalled}}
\index{isStalled@{isStalled}!LSQ@{LSQ}}
\subsubsection[{isStalled}]{\setlength{\rightskip}{0pt plus 5cm}bool isStalled ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_af8eb8590fbfa6ecd2f796390677a4c00}
Returns if the \hyperlink{classLSQ}{LSQ} is stalled due to a memory operation that must be replayed. 


\begin{DoxyCode}
593 {
594     list<ThreadID>::iterator threads = activeThreads->begin();
595     list<ThreadID>::iterator end = activeThreads->end();
596 
597     while (threads != end) {
598         ThreadID tid = *threads++;
599 
600         if (!thread[tid].isStalled())
601             return false;
602     }
603 
604     return true;
605 }
\end{DoxyCode}
\hypertarget{classLSQ_a95b69602ad810ff8ec5d2b0ea2619945}{
\index{LSQ@{LSQ}!loadBlocked@{loadBlocked}}
\index{loadBlocked@{loadBlocked}!LSQ@{LSQ}}
\subsubsection[{loadBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool loadBlocked ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a95b69602ad810ff8ec5d2b0ea2619945}
Returns if a load is blocked due to the memory system for a specific thread. 


\begin{DoxyCode}
157     { return thread[tid].loadBlocked(); }
\end{DoxyCode}
\hypertarget{classLSQ_a01d2807c1345befcffd168a2a9dbdbf2}{
\index{LSQ@{LSQ}!lqEmpty@{lqEmpty}}
\index{lqEmpty@{lqEmpty}!LSQ@{LSQ}}
\subsubsection[{lqEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool lqEmpty () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a01d2807c1345befcffd168a2a9dbdbf2}
Returns if all of the LQs are empty. 


\begin{DoxyCode}
501 {
502     list<ThreadID>::const_iterator threads = activeThreads->begin();
503     list<ThreadID>::const_iterator end = activeThreads->end();
504 
505     while (threads != end) {
506         ThreadID tid = *threads++;
507 
508         if (!thread[tid].lqEmpty())
509             return false;
510     }
511 
512     return true;
513 }
\end{DoxyCode}
\hypertarget{classLSQ_afa1d531e5f388b1cdc3af03100f63061}{
\index{LSQ@{LSQ}!lqFull@{lqFull}}
\index{lqFull@{lqFull}!LSQ@{LSQ}}
\subsubsection[{lqFull}]{\setlength{\rightskip}{0pt plus 5cm}bool lqFull ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_afa1d531e5f388b1cdc3af03100f63061}
Returns if the LQ of a given thread is full. 


\begin{DoxyCode}
552 {
553     //@todo: Change to Calculate All Entries for
554     //Dynamic Policy
555     if (lsqPolicy == Dynamic)
556         return lqFull();
557     else
558         return thread[tid].lqFull();
559 }
\end{DoxyCode}
\hypertarget{classLSQ_a5893daf623130be826f492bbff58f757}{
\index{LSQ@{LSQ}!lqFull@{lqFull}}
\index{lqFull@{lqFull}!LSQ@{LSQ}}
\subsubsection[{lqFull}]{\setlength{\rightskip}{0pt plus 5cm}bool lqFull ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a5893daf623130be826f492bbff58f757}
Returns if any of the LQs are full. 


\begin{DoxyCode}
535 {
536     list<ThreadID>::iterator threads = activeThreads->begin();
537     list<ThreadID>::iterator end = activeThreads->end();
538 
539     while (threads != end) {
540         ThreadID tid = *threads++;
541 
542         if (!thread[tid].lqFull())
543             return false;
544     }
545 
546     return true;
547 }
\end{DoxyCode}
\hypertarget{classLSQ_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{LSQ@{LSQ}!name@{name}}
\index{name@{name}!LSQ@{LSQ}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a37627d5d5bba7f4a8690c71c2ab3cb07}
Returns the name of the \hyperlink{classLSQ}{LSQ}. 


\begin{DoxyCode}
129 {
130     return iewStage->name() + ".lsq";
131 }
\end{DoxyCode}
\hypertarget{classLSQ_acc878f608deead5b5319a6a3f98b50c8}{
\index{LSQ@{LSQ}!numFreeEntries@{numFreeEntries}}
\index{numFreeEntries@{numFreeEntries}!LSQ@{LSQ}}
\subsubsection[{numFreeEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned numFreeEntries ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_acc878f608deead5b5319a6a3f98b50c8}
Returns the number of free entries for a specific thread. 


\begin{DoxyCode}
455 {
456     //if (lsqPolicy == Dynamic)
457     //return numFreeEntries();
458     //else
459         return thread[tid].numFreeEntries();
460 }
\end{DoxyCode}
\hypertarget{classLSQ_a028971a565aca048c67ea1c36a6a9d51}{
\index{LSQ@{LSQ}!numFreeEntries@{numFreeEntries}}
\index{numFreeEntries@{numFreeEntries}!LSQ@{LSQ}}
\subsubsection[{numFreeEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned numFreeEntries ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a028971a565aca048c67ea1c36a6a9d51}
Returns the number of free entries. 


\begin{DoxyCode}
437 {
438     unsigned total = 0;
439 
440     list<ThreadID>::iterator threads = activeThreads->begin();
441     list<ThreadID>::iterator end = activeThreads->end();
442 
443     while (threads != end) {
444         ThreadID tid = *threads++;
445 
446         total += thread[tid].numFreeEntries();
447     }
448 
449     return total;
450 }
\end{DoxyCode}
\hypertarget{classLSQ_adcdafd05eb96f01fa490a847d57d0bec}{
\index{LSQ@{LSQ}!numLoads@{numLoads}}
\index{numLoads@{numLoads}!LSQ@{LSQ}}
\subsubsection[{numLoads}]{\setlength{\rightskip}{0pt plus 5cm}int numLoads ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_adcdafd05eb96f01fa490a847d57d0bec}
Returns the total number of loads for a single thread. 


\begin{DoxyCode}
199     { return thread[tid].numLoads(); }
\end{DoxyCode}
\hypertarget{classLSQ_a54460b759fb06e2b18e26657279a6f49}{
\index{LSQ@{LSQ}!numLoads@{numLoads}}
\index{numLoads@{numLoads}!LSQ@{LSQ}}
\subsubsection[{numLoads}]{\setlength{\rightskip}{0pt plus 5cm}int numLoads ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a54460b759fb06e2b18e26657279a6f49}
Returns the total number of loads in the load queue. 


\begin{DoxyCode}
401 {
402     unsigned total = 0;
403 
404     list<ThreadID>::iterator threads = activeThreads->begin();
405     list<ThreadID>::iterator end = activeThreads->end();
406 
407     while (threads != end) {
408         ThreadID tid = *threads++;
409 
410         total += numLoads(tid);
411     }
412 
413     return total;
414 }
\end{DoxyCode}
\hypertarget{classLSQ_a12346c097127dd67f1f9e8d28e12858f}{
\index{LSQ@{LSQ}!numStores@{numStores}}
\index{numStores@{numStores}!LSQ@{LSQ}}
\subsubsection[{numStores}]{\setlength{\rightskip}{0pt plus 5cm}int numStores ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a12346c097127dd67f1f9e8d28e12858f}
Returns the total number of stores for a single thread. 


\begin{DoxyCode}
205     { return thread[tid].numStores(); }
\end{DoxyCode}
\hypertarget{classLSQ_aa0fc32a4a9d77696f5907f4d25e7d07f}{
\index{LSQ@{LSQ}!numStores@{numStores}}
\index{numStores@{numStores}!LSQ@{LSQ}}
\subsubsection[{numStores}]{\setlength{\rightskip}{0pt plus 5cm}int numStores ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_aa0fc32a4a9d77696f5907f4d25e7d07f}
Returns the total number of stores in the store queue. 


\begin{DoxyCode}
419 {
420     unsigned total = 0;
421 
422     list<ThreadID>::iterator threads = activeThreads->begin();
423     list<ThreadID>::iterator end = activeThreads->end();
424 
425     while (threads != end) {
426         ThreadID tid = *threads++;
427 
428         total += thread[tid].numStores();
429     }
430 
431     return total;
432 }
\end{DoxyCode}
\hypertarget{classLSQ_a4115edd209f7e5e51c3a17d40edd9e7a}{
\index{LSQ@{LSQ}!numStoresToWB@{numStoresToWB}}
\index{numStoresToWB@{numStoresToWB}!LSQ@{LSQ}}
\subsubsection[{numStoresToWB}]{\setlength{\rightskip}{0pt plus 5cm}int numStoresToWB ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a4115edd209f7e5e51c3a17d40edd9e7a}
Returns the number of stores a specific thread has to write back. 


\begin{DoxyCode}
259     { return thread[tid].numStoresToWB(); }
\end{DoxyCode}
\hypertarget{classLSQ_a206ad0283d431e78e6f38bb9b54b23ee}{
\index{LSQ@{LSQ}!read@{read}}
\index{read@{read}!LSQ@{LSQ}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} read ({\bf RequestPtr} {\em req}, \/  {\bf RequestPtr} {\em sreqLow}, \/  {\bf RequestPtr} {\em sreqHigh}, \/  uint8\_\-t $\ast$ {\em data}, \/  int {\em load\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a206ad0283d431e78e6f38bb9b54b23ee}
Executes a read operation, using the load specified at the load index. 


\begin{DoxyCode}
350 {
351     ThreadID tid = req->threadId();
352 
353     return thread[tid].read(req, sreqLow, sreqHigh, data, load_idx);
354 }
\end{DoxyCode}
\hypertarget{classLSQ_a29cb5a4f98063ce6e9210eacbdb35298}{
\index{LSQ@{LSQ}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!LSQ@{LSQ}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetry ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a29cb5a4f98063ce6e9210eacbdb35298}
Retry the previous send that failed. 


\begin{DoxyCode}
339 {
340     if (retryTid == InvalidThreadID)
341     {
342         //Squashed, so drop it
343         return;
344     }
345     int curr_retry_tid = retryTid;
346     // Speculatively clear the retry Tid.  This will get set again if
347     // the LSQUnit was unable to complete its access.
348     retryTid = -1;
349     thread[curr_retry_tid].recvRetry();
350 }
\end{DoxyCode}
\hypertarget{classLSQ_a482dba5588f4bee43e498875a61e5e0b}{
\index{LSQ@{LSQ}!recvTimingResp@{recvTimingResp}}
\index{recvTimingResp@{recvTimingResp}!LSQ@{LSQ}}
\subsubsection[{recvTimingResp}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingResp ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a482dba5588f4bee43e498875a61e5e0b}
Handles writing back and completing the load or store that has returned from memory.


\begin{DoxyParams}{引数}
\item[{\em pkt}]Response packet from the memory sub-\/system \end{DoxyParams}



\begin{DoxyCode}
355 {
356     if (pkt->isError())
357         DPRINTF(LSQ, "Got error packet back for address: %#X\n",
358                 pkt->getAddr());
359     thread[pkt->req->threadId()].completeDataAccess(pkt);
360     return true;
361 }
\end{DoxyCode}
\hypertarget{classLSQ_aff3031c56fc4947a19695c868bb8233e}{
\index{LSQ@{LSQ}!recvTimingSnoopReq@{recvTimingSnoopReq}}
\index{recvTimingSnoopReq@{recvTimingSnoopReq}!LSQ@{LSQ}}
\subsubsection[{recvTimingSnoopReq}]{\setlength{\rightskip}{0pt plus 5cm}void recvTimingSnoopReq ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_aff3031c56fc4947a19695c868bb8233e}



\begin{DoxyCode}
366 {
367     DPRINTF(LSQ, "received pkt for addr:%#x %s\n", pkt->getAddr(),
368             pkt->cmdString());
369 
370     // must be a snoop
371     if (pkt->isInvalidate()) {
372         DPRINTF(LSQ, "received invalidation for addr:%#x\n",
373                 pkt->getAddr());
374         for (ThreadID tid = 0; tid < numThreads; tid++) {
375             thread[tid].checkSnoop(pkt);
376         }
377     }
378 }
\end{DoxyCode}
\hypertarget{classLSQ_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{LSQ@{LSQ}!regStats@{regStats}}
\index{regStats@{regStats}!LSQ@{LSQ}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a4dc637449366fcdfc4e764cdf12d9b11}
Registers statistics of each \hyperlink{classLSQ}{LSQ} unit. 


\begin{DoxyCode}
136 {
137     //Initialize LSQs
138     for (ThreadID tid = 0; tid < numThreads; tid++) {
139         thread[tid].regStats();
140     }
141 }
\end{DoxyCode}
\hypertarget{classLSQ_a53a4e3e73adce8cf2b544117971131c5}{
\index{LSQ@{LSQ}!removeEntries@{removeEntries}}
\index{removeEntries@{removeEntries}!LSQ@{LSQ}}
\subsubsection[{removeEntries}]{\setlength{\rightskip}{0pt plus 5cm}void removeEntries ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a53a4e3e73adce8cf2b544117971131c5}



\begin{DoxyCode}
236 {
237     thread[tid].clearLQ();
238     thread[tid].clearSQ();
239 }
\end{DoxyCode}
\hypertarget{classLSQ_aaf9a05771a835f9f8d634cef36e24d40}{
\index{LSQ@{LSQ}!resetEntries@{resetEntries}}
\index{resetEntries@{resetEntries}!LSQ@{LSQ}}
\subsubsection[{resetEntries}]{\setlength{\rightskip}{0pt plus 5cm}void resetEntries ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_aaf9a05771a835f9f8d634cef36e24d40}
Reset the max entries for each thread. 


\begin{DoxyCode}
208 {
209     if (lsqPolicy != Dynamic || numThreads > 1) {
210         int active_threads = activeThreads->size();
211 
212         int maxEntries;
213 
214         if (lsqPolicy == Partitioned) {
215             maxEntries = LQEntries / active_threads;
216         } else if (lsqPolicy == Threshold && active_threads == 1) {
217             maxEntries = LQEntries;
218         } else {
219             maxEntries = LQEntries;
220         }
221 
222         list<ThreadID>::iterator threads  = activeThreads->begin();
223         list<ThreadID>::iterator end = activeThreads->end();
224 
225         while (threads != end) {
226             ThreadID tid = *threads++;
227 
228             resizeEntries(maxEntries, tid);
229         }
230     }
231 }
\end{DoxyCode}
\hypertarget{classLSQ_a3672feee3a3eaad63f2e96d46385a099}{
\index{LSQ@{LSQ}!resizeEntries@{resizeEntries}}
\index{resizeEntries@{resizeEntries}!LSQ@{LSQ}}
\subsubsection[{resizeEntries}]{\setlength{\rightskip}{0pt plus 5cm}void resizeEntries (unsigned {\em size}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a3672feee3a3eaad63f2e96d46385a099}
Resize the max entries for a thread. 


\begin{DoxyCode}
244 {
245     thread[tid].resizeLQ(size);
246     thread[tid].resizeSQ(size);
247 }
\end{DoxyCode}
\hypertarget{classLSQ_aab96bdacf8bd420402cbb543f994e054}{
\index{LSQ@{LSQ}!setActiveThreads@{setActiveThreads}}
\index{setActiveThreads@{setActiveThreads}!LSQ@{LSQ}}
\subsubsection[{setActiveThreads}]{\setlength{\rightskip}{0pt plus 5cm}void setActiveThreads ({\bf std::list}$<$ {\bf ThreadID} $>$ $\ast$ {\em at\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_aab96bdacf8bd420402cbb543f994e054}
Sets the pointer to the list of active threads. 


\begin{DoxyCode}
146 {
147     activeThreads = at_ptr;
148     assert(activeThreads != 0);
149 }
\end{DoxyCode}
\hypertarget{classLSQ_a30c462e914644ddba59b0d769941b5dd}{
\index{LSQ@{LSQ}!setLoadBlockedHandled@{setLoadBlockedHandled}}
\index{setLoadBlockedHandled@{setLoadBlockedHandled}!LSQ@{LSQ}}
\subsubsection[{setLoadBlockedHandled}]{\setlength{\rightskip}{0pt plus 5cm}void setLoadBlockedHandled ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a30c462e914644ddba59b0d769941b5dd}



\begin{DoxyCode}
163     { thread[tid].setLoadBlockedHandled(); }
\end{DoxyCode}
\hypertarget{classLSQ_aca00d390ba2ada0daf6e0c0a7cf75f57}{
\index{LSQ@{LSQ}!setRetryTid@{setRetryTid}}
\index{setRetryTid@{setRetryTid}!LSQ@{LSQ}}
\subsubsection[{setRetryTid}]{\setlength{\rightskip}{0pt plus 5cm}void setRetryTid ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_aca00d390ba2ada0daf6e0c0a7cf75f57}
Sets the retry thread id, indicating that one of the LSQUnits tried to access the cache but the cache was blocked. 


\begin{DoxyCode}
276     { retryTid = tid; }
\end{DoxyCode}
\hypertarget{classLSQ_a5761e9640bec8ba8474945cce57b6501}{
\index{LSQ@{LSQ}!sqEmpty@{sqEmpty}}
\index{sqEmpty@{sqEmpty}!LSQ@{LSQ}}
\subsubsection[{sqEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool sqEmpty () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a5761e9640bec8ba8474945cce57b6501}
Returns if all of the SQs are empty. 


\begin{DoxyCode}
518 {
519     list<ThreadID>::const_iterator threads = activeThreads->begin();
520     list<ThreadID>::const_iterator end = activeThreads->end();
521 
522     while (threads != end) {
523         ThreadID tid = *threads++;
524 
525         if (!thread[tid].sqEmpty())
526             return false;
527     }
528 
529     return true;
530 }
\end{DoxyCode}
\hypertarget{classLSQ_a6a3501ebb06c38938a3b0ebcea2b6a8b}{
\index{LSQ@{LSQ}!sqFull@{sqFull}}
\index{sqFull@{sqFull}!LSQ@{LSQ}}
\subsubsection[{sqFull}]{\setlength{\rightskip}{0pt plus 5cm}bool sqFull ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a6a3501ebb06c38938a3b0ebcea2b6a8b}
Returns if the SQ of a given thread is full. 


\begin{DoxyCode}
581 {
582      //@todo: Change to Calculate All Entries for
583     //Dynamic Policy
584     if (lsqPolicy == Dynamic)
585         return sqFull();
586     else
587         return thread[tid].sqFull();
588 }
\end{DoxyCode}
\hypertarget{classLSQ_a477981d1f905d2d398a1527f7149e3c4}{
\index{LSQ@{LSQ}!sqFull@{sqFull}}
\index{sqFull@{sqFull}!LSQ@{LSQ}}
\subsubsection[{sqFull}]{\setlength{\rightskip}{0pt plus 5cm}bool sqFull ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a477981d1f905d2d398a1527f7149e3c4}
Returns if any of the SQs are full. 


\begin{DoxyCode}
564 {
565     list<ThreadID>::iterator threads = activeThreads->begin();
566     list<ThreadID>::iterator end = activeThreads->end();
567 
568     while (threads != end) {
569         ThreadID tid = *threads++;
570 
571         if (!sqFull(tid))
572             return false;
573     }
574 
575     return true;
576 }
\end{DoxyCode}
\hypertarget{classLSQ_a74283dfde2ab06c84e10bd85000c168b}{
\index{LSQ@{LSQ}!squash@{squash}}
\index{squash@{squash}!LSQ@{LSQ}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash (const {\bf InstSeqNum} \& {\em squashed\_\-num}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a74283dfde2ab06c84e10bd85000c168b}
Squash instructions from a thread until the specified sequence number. 


\begin{DoxyCode}
142     { thread[tid].squash(squashed_num); }
\end{DoxyCode}
\hypertarget{classLSQ_a8674059ce345e23aac5086b2c3e24a43}{
\index{LSQ@{LSQ}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!LSQ@{LSQ}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a8674059ce345e23aac5086b2c3e24a43}
Takes over execution from another CPU's thread. 


\begin{DoxyCode}
188 {
189     for (ThreadID tid = 0; tid < numThreads; tid++) {
190         thread[tid].takeOverFrom();
191     }
192 }
\end{DoxyCode}
\hypertarget{classLSQ_a6968bcfead3fa275f8a1e740c1e337e8}{
\index{LSQ@{LSQ}!tick@{tick}}
\index{tick@{tick}!LSQ@{LSQ}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a6968bcfead3fa275f8a1e740c1e337e8}
Ticks a specific \hyperlink{classLSQ}{LSQ} Unit. 


\begin{DoxyCode}
105     { thread[tid].tick(); }
\end{DoxyCode}
\hypertarget{classLSQ_a873dd91783f9efb4a590aded1f70d6b0}{
\index{LSQ@{LSQ}!tick@{tick}}
\index{tick@{tick}!LSQ@{LSQ}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a873dd91783f9efb4a590aded1f70d6b0}
Ticks the \hyperlink{classLSQ}{LSQ}. 


\begin{DoxyCode}
252 {
253     list<ThreadID>::iterator threads = activeThreads->begin();
254     list<ThreadID>::iterator end = activeThreads->end();
255 
256     while (threads != end) {
257         ThreadID tid = *threads++;
258 
259         thread[tid].tick();
260     }
261 }
\end{DoxyCode}
\hypertarget{classLSQ_a24dee29bada56cd1c98a7c3d80e77b6e}{
\index{LSQ@{LSQ}!violation@{violation}}
\index{violation@{violation}!LSQ@{LSQ}}
\subsubsection[{violation}]{\setlength{\rightskip}{0pt plus 5cm}bool violation ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a24dee29bada56cd1c98a7c3d80e77b6e}
Returns whether or not there was a memory ordering violation for a specific thread. 


\begin{DoxyCode}
151     { return thread[tid].violation(); }
\end{DoxyCode}
\hypertarget{classLSQ_a4f720bbfb5fdefdb23516500eeb0b4de}{
\index{LSQ@{LSQ}!violation@{violation}}
\index{violation@{violation}!LSQ@{LSQ}}
\subsubsection[{violation}]{\setlength{\rightskip}{0pt plus 5cm}bool violation ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a4f720bbfb5fdefdb23516500eeb0b4de}
Returns whether or not there was a memory ordering violation. 


\begin{DoxyCode}
321 {
322     /* Answers: Does Anybody Have a Violation?*/
323     list<ThreadID>::iterator threads = activeThreads->begin();
324     list<ThreadID>::iterator end = activeThreads->end();
325 
326     while (threads != end) {
327         ThreadID tid = *threads++;
328 
329         if (thread[tid].violation())
330             return true;
331     }
332 
333     return false;
334 }
\end{DoxyCode}
\hypertarget{classLSQ_a71ae97788e6b1230662807e1b03f47b3}{
\index{LSQ@{LSQ}!willWB@{willWB}}
\index{willWB@{willWB}!LSQ@{LSQ}}
\subsubsection[{willWB}]{\setlength{\rightskip}{0pt plus 5cm}bool willWB ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a71ae97788e6b1230662807e1b03f47b3}
Returns if the \hyperlink{classLSQ}{LSQ} of a specific thread will write back to memory this cycle. 


\begin{DoxyCode}
267     { return thread[tid].willWB(); }
\end{DoxyCode}
\hypertarget{classLSQ_a338be821734603396bfef8d9fb8f04b0}{
\index{LSQ@{LSQ}!willWB@{willWB}}
\index{willWB@{willWB}!LSQ@{LSQ}}
\subsubsection[{willWB}]{\setlength{\rightskip}{0pt plus 5cm}bool willWB ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a338be821734603396bfef8d9fb8f04b0}
Returns if the \hyperlink{classLSQ}{LSQ} will write back to memory this cycle. 


\begin{DoxyCode}
637 {
638     list<ThreadID>::iterator threads = activeThreads->begin();
639     list<ThreadID>::iterator end = activeThreads->end();
640 
641     while (threads != end) {
642         ThreadID tid = *threads++;
643 
644         if (willWB(tid))
645             return true;
646     }
647 
648     return false;
649 }
\end{DoxyCode}
\hypertarget{classLSQ_a1be8f3ccb9b2787a2c92bfab3fda9675}{
\index{LSQ@{LSQ}!write@{write}}
\index{write@{write}!LSQ@{LSQ}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} write ({\bf RequestPtr} {\em req}, \/  {\bf RequestPtr} {\em sreqLow}, \/  {\bf RequestPtr} {\em sreqHigh}, \/  uint8\_\-t $\ast$ {\em data}, \/  int {\em store\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a1be8f3ccb9b2787a2c92bfab3fda9675}
Executes a store operation, using the store specified at the store index. 


\begin{DoxyCode}
360 {
361     ThreadID tid = req->threadId();
362 
363     return thread[tid].write(req, sreqLow, sreqHigh, data, store_idx);
364 }
\end{DoxyCode}
\hypertarget{classLSQ_aebf9f82a83e61cd390df68a2fb7a8641}{
\index{LSQ@{LSQ}!writebackStores@{writebackStores}}
\index{writebackStores@{writebackStores}!LSQ@{LSQ}}
\subsubsection[{writebackStores}]{\setlength{\rightskip}{0pt plus 5cm}void writebackStores ({\bf ThreadID} {\em tid})}}
\label{classLSQ_aebf9f82a83e61cd390df68a2fb7a8641}
Same as above, but only for one thread. \hypertarget{classLSQ_a5f04e29d6f6feb8b86460491f2ba7547}{
\index{LSQ@{LSQ}!writebackStores@{writebackStores}}
\index{writebackStores@{writebackStores}!LSQ@{LSQ}}
\subsubsection[{writebackStores}]{\setlength{\rightskip}{0pt plus 5cm}void writebackStores ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQ_a5f04e29d6f6feb8b86460491f2ba7547}
Attempts to write back stores until all cache ports are used or the interface becomes blocked. 


\begin{DoxyCode}
302 {
303     list<ThreadID>::iterator threads = activeThreads->begin();
304     list<ThreadID>::iterator end = activeThreads->end();
305 
306     while (threads != end) {
307         ThreadID tid = *threads++;
308 
309         if (numStoresToWB(tid) > 0) {
310             DPRINTF(Writeback,"[tid:%i] Writing back stores. %i stores "
311                 "available for Writeback.\n", tid, numStoresToWB(tid));
312         }
313 
314         thread[tid].writebackStores();
315     }
316 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classLSQ_af6eaea53db532812052f71bf0380dab5}{
\index{LSQ@{LSQ}!activeThreads@{activeThreads}}
\index{activeThreads@{activeThreads}!LSQ@{LSQ}}
\subsubsection[{activeThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf ThreadID}$>$$\ast$ {\bf activeThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLSQ_af6eaea53db532812052f71bf0380dab5}
List of Active Threads in \hyperlink{classSystem}{System}. \hypertarget{classLSQ_a1379cf882a12ac6fc9eba5da7c84b18b}{
\index{LSQ@{LSQ}!cpu@{cpu}}
\index{cpu@{cpu}!LSQ@{LSQ}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf O3CPU}$\ast$ {\bf cpu}}}
\label{classLSQ_a1379cf882a12ac6fc9eba5da7c84b18b}
The CPU pointer. \hypertarget{classLSQ_a4e9ef25d8913b270d432be4bbfe4965c}{
\index{LSQ@{LSQ}!iewStage@{iewStage}}
\index{iewStage@{iewStage}!LSQ@{LSQ}}
\subsubsection[{iewStage}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IEW}$\ast$ {\bf iewStage}}}
\label{classLSQ_a4e9ef25d8913b270d432be4bbfe4965c}
The IEW stage pointer. \hypertarget{classLSQ_aafa99d800d574095881acbacdbbbcc47}{
\index{LSQ@{LSQ}!LQEntries@{LQEntries}}
\index{LQEntries@{LQEntries}!LSQ@{LSQ}}
\subsubsection[{LQEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf LQEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLSQ_aafa99d800d574095881acbacdbbbcc47}
Total Size of LQ Entries. \hypertarget{classLSQ_a28ca1f0961b84f3386b592d1e3e1b411}{
\index{LSQ@{LSQ}!lsqPolicy@{lsqPolicy}}
\index{lsqPolicy@{lsqPolicy}!LSQ@{LSQ}}
\subsubsection[{lsqPolicy}]{\setlength{\rightskip}{0pt plus 5cm}{\bf LSQPolicy} {\bf lsqPolicy}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLSQ_a28ca1f0961b84f3386b592d1e3e1b411}
The \hyperlink{classLSQ}{LSQ} policy for SMT mode. \hypertarget{classLSQ_ad2f4fd027fe71a87d5ee2d798ec19ac3}{
\index{LSQ@{LSQ}!maxLQEntries@{maxLQEntries}}
\index{maxLQEntries@{maxLQEntries}!LSQ@{LSQ}}
\subsubsection[{maxLQEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf maxLQEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLSQ_ad2f4fd027fe71a87d5ee2d798ec19ac3}
Max LQ Size -\/ Used to Enforce Sharing Policies. \hypertarget{classLSQ_a0e9eef7cd7598f554f1f89c35cb08128}{
\index{LSQ@{LSQ}!maxSQEntries@{maxSQEntries}}
\index{maxSQEntries@{maxSQEntries}!LSQ@{LSQ}}
\subsubsection[{maxSQEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf maxSQEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLSQ_a0e9eef7cd7598f554f1f89c35cb08128}
Max SQ Size -\/ Used to Enforce Sharing Policies. \hypertarget{classLSQ_a88377f855dbf5adeeecb06b5bb821d35}{
\index{LSQ@{LSQ}!numThreads@{numThreads}}
\index{numThreads@{numThreads}!LSQ@{LSQ}}
\subsubsection[{numThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} {\bf numThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLSQ_a88377f855dbf5adeeecb06b5bb821d35}
Number of Threads. \hypertarget{classLSQ_a865aaad70625f17392c717930860d386}{
\index{LSQ@{LSQ}!retryTid@{retryTid}}
\index{retryTid@{retryTid}!LSQ@{LSQ}}
\subsubsection[{retryTid}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} {\bf retryTid}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLSQ_a865aaad70625f17392c717930860d386}
The thread id of the \hyperlink{classLSQ}{LSQ} Unit that is currently waiting for a retry. \hypertarget{classLSQ_a38c8af5392da70119dc5cce4e3637cbc}{
\index{LSQ@{LSQ}!SQEntries@{SQEntries}}
\index{SQEntries@{SQEntries}!LSQ@{LSQ}}
\subsubsection[{SQEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf SQEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLSQ_a38c8af5392da70119dc5cce4e3637cbc}
Total Size of SQ Entries. \hypertarget{classLSQ_a5709dc03226b4fc5a49a4c6a41ff50ad}{
\index{LSQ@{LSQ}!thread@{thread}}
\index{thread@{thread}!LSQ@{LSQ}}
\subsubsection[{thread}]{\setlength{\rightskip}{0pt plus 5cm}{\bf LSQUnit}$\ast$ {\bf thread}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLSQ_a5709dc03226b4fc5a49a4c6a41ff50ad}
The \hyperlink{classLSQ}{LSQ} units for individual threads. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/o3/\hyperlink{lsq_8hh}{lsq.hh}\item 
cpu/o3/\hyperlink{lsq__impl_8hh}{lsq\_\-impl.hh}\end{DoxyCompactItemize}
