\hypertarget{classDRAMSim2}{
\section{クラス DRAMSim2}
\label{classDRAMSim2}\index{DRAMSim2@{DRAMSim2}}
}


{\ttfamily \#include $<$dramsim2.hh$>$}DRAMSim2に対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=6cm]{classDRAMSim2}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classDRAMSim2_1_1DRAMSim2}{DRAMSim2}
\item 
class \hyperlink{classDRAMSim2_1_1MemoryPort}{MemoryPort}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef DRAMSim2Params \hyperlink{classDRAMSim2_ae66665a06c9d64a6ba0e56d589b74d6c}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDRAMSim2_ab8d8de0105b7d92ea63130025ee2bc5a}{DRAMSim2} (const \hyperlink{classDRAMSim2_ae66665a06c9d64a6ba0e56d589b74d6c}{Params} $\ast$p)
\item 
void \hyperlink{classDRAMSim2_a8c698c38274256cd03843f1296ac9eed}{readComplete} (unsigned id, uint64\_\-t addr, uint64\_\-t \hyperlink{classClockedObject_a5dd7a975aae396561aafab3faa698033}{cycle})
\item 
void \hyperlink{classDRAMSim2_aeb50ab991dbcebefc4952362893d0891}{writeComplete} (unsigned id, uint64\_\-t addr, uint64\_\-t \hyperlink{classClockedObject_a5dd7a975aae396561aafab3faa698033}{cycle})
\item 
unsigned int \hyperlink{classDRAMSim2_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)
\item 
virtual \hyperlink{classBaseSlavePort}{BaseSlavePort} \& \hyperlink{classDRAMSim2_ac918a145092d7514ebc6dbd952dceafb}{getSlavePort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
virtual void \hyperlink{classDRAMSim2_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
virtual void \hyperlink{classDRAMSim2_aecc7d8debf54990ffeaaed5bac7d7d81}{startup} ()
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMSim2_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{recvAtomic} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classDRAMSim2_aeefa907fb6d6a787e6dab90e8138ea90}{recvFunctional} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classDRAMSim2_a3344d9dd0f83257feab5424e761f31c6}{recvTimingReq} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classDRAMSim2_a29cb5a4f98063ce6e9210eacbdb35298}{recvRetry} ()
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
unsigned int \hyperlink{classDRAMSim2_a034e8a2b3dd91f3ad9ca116c60aa3ea5}{nbrOutstanding} () const 
\item 
void \hyperlink{classDRAMSim2_a26aa336cb4192aab04418121f361fa49}{accessAndRespond} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classDRAMSim2_a07982d2ae9430f5cd468e15bb4920ea4}{sendResponse} ()
\item 
void \hyperlink{classDRAMSim2_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDRAMSim2_1_1MemoryPort}{MemoryPort} \hyperlink{classDRAMSim2_a55c076720c982014096b57cadebf9a14}{port}
\item 
\hyperlink{classDRAMSim2Wrapper}{DRAMSim2Wrapper} \hyperlink{classDRAMSim2_a19f45f63dee6f1b0a77c2758069683f8}{wrapper}
\item 
bool \hyperlink{classDRAMSim2_aab3b947b2633a30b5973a39b7e9b018a}{retryReq}
\item 
bool \hyperlink{classDRAMSim2_a6ddfdd4eb676d50001bda88567e6da14}{retryResp}
\item 
m5::hash\_\-map$<$ \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr}, std::queue$<$ \hyperlink{classPacket}{PacketPtr} $>$ $>$ \hyperlink{classDRAMSim2_aa436e51811d19fcd65fcc5061afc981a}{outstandingReads}
\item 
m5::hash\_\-map$<$ \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr}, std::queue$<$ \hyperlink{classPacket}{PacketPtr} $>$ $>$ \hyperlink{classDRAMSim2_ae3f05f6f5f0f558c32291a43c04fc1a1}{outstandingWrites}
\item 
unsigned int \hyperlink{classDRAMSim2_a75a96fd06206c4a8580628497ad694df}{nbrOutstandingReads}
\item 
unsigned int \hyperlink{classDRAMSim2_ae13aa3a1980dc05e181f85d7304baa82}{nbrOutstandingWrites}
\item 
\hyperlink{classstd_1_1deque}{std::deque}$<$ \hyperlink{classPacket}{PacketPtr} $>$ \hyperlink{classDRAMSim2_a7dd56c8ca058e3e734ec0460b1587932}{responseQueue}
\item 
\hyperlink{classDrainManager}{DrainManager} $\ast$ \hyperlink{classDRAMSim2_a329b71fb934a93312ca0aacbf5a3f982}{drainManager}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classDRAMSim2_1_1DRAMSim2}{DRAMSim2},\&DRAMSim2::sendResponse $>$ \hyperlink{classDRAMSim2_a46a89603d961c3ae9b2cb2df412503f6}{sendResponseEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classDRAMSim2_1_1DRAMSim2}{DRAMSim2},\&DRAMSim2::tick $>$ \hyperlink{classDRAMSim2_acab0bec584b681055f948abbbaf8acb2}{tickEvent}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classPacket}{PacketPtr} $>$ \hyperlink{classDRAMSim2_a21da4bea3554874b557428e4cce5d4a4}{pendingDelete}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classDRAMSim2_ae66665a06c9d64a6ba0e56d589b74d6c}{
\index{DRAMSim2@{DRAMSim2}!Params@{Params}}
\index{Params@{Params}!DRAMSim2@{DRAMSim2}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef DRAMSim2Params {\bf Params}}}
\label{classDRAMSim2_ae66665a06c9d64a6ba0e56d589b74d6c}


\hyperlink{classAbstractMemory_ab4fcbcbcfef78d6bc871995f8eca40eb}{AbstractMemory}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classDRAMSim2_ab8d8de0105b7d92ea63130025ee2bc5a}{
\index{DRAMSim2@{DRAMSim2}!DRAMSim2@{DRAMSim2}}
\index{DRAMSim2@{DRAMSim2}!DRAMSim2@{DRAMSim2}}
\subsubsection[{DRAMSim2}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DRAMSim2} (const {\bf Params} $\ast$ {\em p})}}
\label{classDRAMSim2_ab8d8de0105b7d92ea63130025ee2bc5a}



\begin{DoxyCode}
48                                   :
49     AbstractMemory(p),
50     port(name() + ".port", *this),
51     wrapper(p->deviceConfigFile, p->systemConfigFile, p->filePath,
52             p->traceFile, p->range.size() / 1024 / 1024, p->enableDebug),
53     retryReq(false), retryResp(false),
54     nbrOutstandingReads(0), nbrOutstandingWrites(0),
55     drainManager(NULL),
56     sendResponseEvent(this), tickEvent(this)
57 {
58     DPRINTF(DRAMSim2,
59             "Instantiated DRAMSim2 with clock %d ns and queue size %d\n",
60             wrapper.clockPeriod(), wrapper.queueSize());
61 
62     DRAMSim::TransactionCompleteCB* read_cb =
63         new DRAMSim::Callback<DRAMSim2, void, unsigned, uint64_t, uint64_t>(
64             this, &DRAMSim2::readComplete);
65     DRAMSim::TransactionCompleteCB* write_cb =
66         new DRAMSim::Callback<DRAMSim2, void, unsigned, uint64_t, uint64_t>(
67             this, &DRAMSim2::writeComplete);
68     wrapper.setCallbacks(read_cb, write_cb);
69 
70     // Register a callback to compensate for the destructor not
71     // being called. The callback prints the DRAMSim2 stats.
72     Callback* cb = new MakeCallback<DRAMSim2Wrapper,
73         &DRAMSim2Wrapper::printStats>(wrapper);
74     registerExitCallback(cb);
75 }

\end{DoxyCode}


\subsection{関数}
\hypertarget{classDRAMSim2_a26aa336cb4192aab04418121f361fa49}{
\index{DRAMSim2@{DRAMSim2}!accessAndRespond@{accessAndRespond}}
\index{accessAndRespond@{accessAndRespond}!DRAMSim2@{DRAMSim2}}
\subsubsection[{accessAndRespond}]{\setlength{\rightskip}{0pt plus 5cm}void accessAndRespond ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMSim2_a26aa336cb4192aab04418121f361fa49}
When a packet is ready, use the \char`\"{}access()\char`\"{} method in \hyperlink{classAbstractMemory}{AbstractMemory} to actually create the response packet, and send it back to the outside world requestor.


\begin{DoxyParams}{引数}
\item[{\em pkt}]The packet from the outside world \end{DoxyParams}



\begin{DoxyCode}
254 {
255     DPRINTF(DRAMSim2, "Access for address %lld\n", pkt->getAddr());
256 
257     bool needsResponse = pkt->needsResponse();
258 
259     // do the actual memory access which also turns the packet into a
260     // response
261     access(pkt);
262 
263     // turn packet around to go back to requester if response expected
264     if (needsResponse) {
265         // access already turned the packet into a response
266         assert(pkt->isResponse());
267 
268         // @todo someone should pay for this
269         pkt->busFirstWordDelay = pkt->busLastWordDelay = 0;
270 
271         DPRINTF(DRAMSim2, "Queuing response for address %lld\n",
272                 pkt->getAddr());
273 
274         // queue it to be sent back
275         responseQueue.push_back(pkt);
276 
277         // if we are not already waiting for a retry, or are scheduled
278         // to send a response, schedule an event
279         if (!retryResp && !sendResponseEvent.scheduled())
280             schedule(sendResponseEvent, curTick());
281     } else {
282         // @todo the packet is going to be deleted, and the DRAMPacket
283         // is still having a pointer to it
284         pendingDelete.push_back(pkt);
285     }
286 }
\end{DoxyCode}
\hypertarget{classDRAMSim2_aa8a18d230dba7a674ac8a0b4f35bc36a}{
\index{DRAMSim2@{DRAMSim2}!drain@{drain}}
\index{drain@{drain}!DRAMSim2@{DRAMSim2}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em drainManger})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classDRAMSim2_aa8a18d230dba7a674ac8a0b4f35bc36a}
Provide a default implementation of the drain interface that simply returns 0 (draining completed) and sets the drain state to Drained. 

\hyperlink{classSimObject_a6bf479c521c7c3eb473822d953275b26}{SimObject}を再定義しています。


\begin{DoxyCode}
355 {
356     // check our outstanding reads and writes and if any they need to
357     // drain
358     if (nbrOutstanding() != 0) {
359         setDrainState(Drainable::Draining);
360         drainManager = dm;
361         return 1;
362     } else {
363         setDrainState(Drainable::Drained);
364         return 0;
365     }
366 }
\end{DoxyCode}
\hypertarget{classDRAMSim2_ac918a145092d7514ebc6dbd952dceafb}{
\index{DRAMSim2@{DRAMSim2}!getSlavePort@{getSlavePort}}
\index{getSlavePort@{getSlavePort}!DRAMSim2@{DRAMSim2}}
\subsubsection[{getSlavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseSlavePort} \& getSlavePort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classDRAMSim2_ac918a145092d7514ebc6dbd952dceafb}
Get a slave port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classMemObject_ac918a145092d7514ebc6dbd952dceafb}{MemObject}を再定義しています。


\begin{DoxyCode}
345 {
346     if (if_name != "port") {
347         return MemObject::getSlavePort(if_name, idx);
348     } else {
349         return port;
350     }
351 }
\end{DoxyCode}
\hypertarget{classDRAMSim2_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{DRAMSim2@{DRAMSim2}!init@{init}}
\index{init@{init}!DRAMSim2@{DRAMSim2}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classDRAMSim2_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classDRAMSim2_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{SimObject}を再定義しています。


\begin{DoxyCode}
79 {
80     if (!port.isConnected()) {
81         fatal("DRAMSim2 %s is unconnected!\n", name());
82     } else {
83         port.sendRangeChange();
84     }
85 
86     if (system()->cacheLineSize() != wrapper.burstSize())
87         fatal("DRAMSim2 burst size %d does not match cache line size %d\n",
88               wrapper.burstSize(), system()->cacheLineSize());
89 }
\end{DoxyCode}
\hypertarget{classDRAMSim2_a034e8a2b3dd91f3ad9ca116c60aa3ea5}{
\index{DRAMSim2@{DRAMSim2}!nbrOutstanding@{nbrOutstanding}}
\index{nbrOutstanding@{nbrOutstanding}!DRAMSim2@{DRAMSim2}}
\subsubsection[{nbrOutstanding}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int nbrOutstanding () const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMSim2_a034e8a2b3dd91f3ad9ca116c60aa3ea5}



\begin{DoxyCode}
133 {
134     return nbrOutstandingReads + nbrOutstandingWrites + responseQueue.size();
135 }
\end{DoxyCode}
\hypertarget{classDRAMSim2_a8c698c38274256cd03843f1296ac9eed}{
\index{DRAMSim2@{DRAMSim2}!readComplete@{readComplete}}
\index{readComplete@{readComplete}!DRAMSim2@{DRAMSim2}}
\subsubsection[{readComplete}]{\setlength{\rightskip}{0pt plus 5cm}void readComplete (unsigned {\em id}, \/  uint64\_\-t {\em addr}, \/  uint64\_\-t {\em cycle})}}
\label{classDRAMSim2_a8c698c38274256cd03843f1296ac9eed}
Read completion callback.


\begin{DoxyParams}{引数}
\item[{\em id}]Channel id of the responder \item[{\em addr}]\hyperlink{classAddress}{Address} of the request \item[{\em cycle}]Internal cycle count of \hyperlink{classDRAMSim2}{DRAMSim2} \end{DoxyParams}



\begin{DoxyCode}
289 {
290     assert(cycle == divCeil(curTick(),
291                             wrapper.clockPeriod() * SimClock::Int::ns));
292 
293     DPRINTF(DRAMSim2, "Read to address %lld complete\n", addr);
294 
295     // get the outstanding reads for the address in question
296     auto p = outstandingReads.find(addr);
297     assert(p != outstandingReads.end());
298 
299     // first in first out, which is not necessarily true, but it is
300     // the best we can do at this point
301     PacketPtr pkt = p->second.front();
302     p->second.pop();
303 
304     if (p->second.empty())
305         outstandingReads.erase(p);
306 
307     // no need to check for drain here as the next call will add a
308     // response to the response queue straight away
309     assert(nbrOutstandingReads != 0);
310     --nbrOutstandingReads;
311 
312     // perform the actual memory access
313     accessAndRespond(pkt);
314 }
\end{DoxyCode}
\hypertarget{classDRAMSim2_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{
\index{DRAMSim2@{DRAMSim2}!recvAtomic@{recvAtomic}}
\index{recvAtomic@{recvAtomic}!DRAMSim2@{DRAMSim2}}
\subsubsection[{recvAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvAtomic ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classDRAMSim2_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}



\begin{DoxyCode}
154 {
155     access(pkt);
156 
157     // 50 ns is just an arbitrary value at this point
158     return pkt->memInhibitAsserted() ? 0 : 50000;
159 }
\end{DoxyCode}
\hypertarget{classDRAMSim2_aeefa907fb6d6a787e6dab90e8138ea90}{
\index{DRAMSim2@{DRAMSim2}!recvFunctional@{recvFunctional}}
\index{recvFunctional@{recvFunctional}!DRAMSim2@{DRAMSim2}}
\subsubsection[{recvFunctional}]{\setlength{\rightskip}{0pt plus 5cm}void recvFunctional ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classDRAMSim2_aeefa907fb6d6a787e6dab90e8138ea90}



\begin{DoxyCode}
163 {
164     pkt->pushLabel(name());
165 
166     functionalAccess(pkt);
167 
168     // potentially update the packets in our response queue as well
169     for (auto i = responseQueue.begin(); i != responseQueue.end(); ++i)
170         pkt->checkFunctional(*i);
171 
172     pkt->popLabel();
173 }
\end{DoxyCode}
\hypertarget{classDRAMSim2_a29cb5a4f98063ce6e9210eacbdb35298}{
\index{DRAMSim2@{DRAMSim2}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!DRAMSim2@{DRAMSim2}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetry ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classDRAMSim2_a29cb5a4f98063ce6e9210eacbdb35298}



\begin{DoxyCode}
244 {
245     DPRINTF(DRAMSim2, "Retrying\n");
246 
247     assert(retryResp);
248     retryResp = false;
249     sendResponse();
250 }
\end{DoxyCode}
\hypertarget{classDRAMSim2_a3344d9dd0f83257feab5424e761f31c6}{
\index{DRAMSim2@{DRAMSim2}!recvTimingReq@{recvTimingReq}}
\index{recvTimingReq@{recvTimingReq}!DRAMSim2@{DRAMSim2}}
\subsubsection[{recvTimingReq}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingReq ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classDRAMSim2_a3344d9dd0f83257feab5424e761f31c6}



\begin{DoxyCode}
177 {
178     // we should never see a new request while in retry
179     assert(!retryReq);
180 
181     // @todo temporary hack to deal with memory corruption issues until
182     // 4-phase transactions are complete
183     for (int x = 0; x < pendingDelete.size(); x++)
184         delete pendingDelete[x];
185     pendingDelete.clear();
186 
187     if (pkt->memInhibitAsserted()) {
188         // snooper will supply based on copy of packet
189         // still target's responsibility to delete packet
190         pendingDelete.push_back(pkt);
191         return true;
192     }
193 
194     // if we cannot accept we need to send a retry once progress can
195     // be made
196     bool can_accept = nbrOutstanding() < wrapper.queueSize();
197 
198     // keep track of the transaction
199     if (pkt->isRead()) {
200         if (can_accept) {
201             outstandingReads[pkt->getAddr()].push(pkt);
202 
203             // we count a transaction as outstanding until it has left the
204             // queue in the controller, and the response has been sent
205             // back, note that this will differ for reads and writes
206             ++nbrOutstandingReads;
207         }
208     } else if (pkt->isWrite()) {
209         if (can_accept) {
210             outstandingWrites[pkt->getAddr()].push(pkt);
211 
212             ++nbrOutstandingWrites;
213 
214             // perform the access for writes
215             accessAndRespond(pkt);
216         }
217     } else {
218         // keep it simple and just respond if necessary
219         accessAndRespond(pkt);
220         return true;
221     }
222 
223     if (can_accept) {
224         // we should never have a situation when we think there is space,
225         // and there isn't
226         assert(wrapper.canAccept());
227 
228         DPRINTF(DRAMSim2, "Enqueueing address %lld\n", pkt->getAddr());
229 
230         // @todo what about the granularity here, implicit assumption that
231         // a transaction matches the burst size of the memory (which we
232         // cannot determine without parsing the ini file ourselves)
233         wrapper.enqueue(pkt->isWrite(), pkt->getAddr());
234 
235         return true;
236     } else {
237         retryReq = true;
238         return false;
239     }
240 }
\end{DoxyCode}
\hypertarget{classDRAMSim2_a07982d2ae9430f5cd468e15bb4920ea4}{
\index{DRAMSim2@{DRAMSim2}!sendResponse@{sendResponse}}
\index{sendResponse@{sendResponse}!DRAMSim2@{DRAMSim2}}
\subsubsection[{sendResponse}]{\setlength{\rightskip}{0pt plus 5cm}void sendResponse ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMSim2_a07982d2ae9430f5cd468e15bb4920ea4}



\begin{DoxyCode}
100 {
101     assert(!retryResp);
102     assert(!responseQueue.empty());
103 
104     DPRINTF(DRAMSim2, "Attempting to send response\n");
105 
106     bool success = port.sendTimingResp(responseQueue.front());
107     if (success) {
108         responseQueue.pop_front();
109 
110         DPRINTF(DRAMSim2, "Have %d read, %d write, %d responses outstanding\n",
111                 nbrOutstandingReads, nbrOutstandingWrites,
112                 responseQueue.size());
113 
114         if (!responseQueue.empty() && !sendResponseEvent.scheduled())
115             schedule(sendResponseEvent, curTick());
116 
117         // check if we were asked to drain and if we are now done
118         if (drainManager && nbrOutstanding() == 0) {
119             drainManager->signalDrainDone();
120             drainManager = NULL;
121         }
122     } else {
123         retryResp = true;
124 
125         DPRINTF(DRAMSim2, "Waiting for response retry\n");
126 
127         assert(!sendResponseEvent.scheduled());
128     }
129 }
\end{DoxyCode}
\hypertarget{classDRAMSim2_aecc7d8debf54990ffeaaed5bac7d7d81}{
\index{DRAMSim2@{DRAMSim2}!startup@{startup}}
\index{startup@{startup}!DRAMSim2@{DRAMSim2}}
\subsubsection[{startup}]{\setlength{\rightskip}{0pt plus 5cm}void startup ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classDRAMSim2_aecc7d8debf54990ffeaaed5bac7d7d81}
\hyperlink{classDRAMSim2_aecc7d8debf54990ffeaaed5bac7d7d81}{startup()} is the final initialization call before simulation. All state is initialized (including unserialized state, if any, such as the \hyperlink{statistics_8hh_a7acdccbf0d35ce0c159c0cdd36371b22}{curTick()} value), so this is the appropriate place to schedule initial event(s) for objects that need them. 

\hyperlink{classSimObject_aecc7d8debf54990ffeaaed5bac7d7d81}{SimObject}を再定義しています。


\begin{DoxyCode}
93 {
94     // kick off the clock ticks
95     schedule(tickEvent, clockEdge());
96 }
\end{DoxyCode}
\hypertarget{classDRAMSim2_a873dd91783f9efb4a590aded1f70d6b0}{
\index{DRAMSim2@{DRAMSim2}!tick@{tick}}
\index{tick@{tick}!DRAMSim2@{DRAMSim2}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMSim2_a873dd91783f9efb4a590aded1f70d6b0}
Progress the controller one clock cycle. 


\begin{DoxyCode}
139 {
140     wrapper.tick();
141 
142     // is the connected port waiting for a retry, if so check the
143     // state and send a retry if conditions have changed
144     if (retryReq && nbrOutstanding() < wrapper.queueSize()) {
145         retryReq = false;
146         port.sendRetry();
147     }
148 
149     schedule(tickEvent, curTick() + wrapper.clockPeriod() * SimClock::Int::ns);
150 }
\end{DoxyCode}
\hypertarget{classDRAMSim2_aeb50ab991dbcebefc4952362893d0891}{
\index{DRAMSim2@{DRAMSim2}!writeComplete@{writeComplete}}
\index{writeComplete@{writeComplete}!DRAMSim2@{DRAMSim2}}
\subsubsection[{writeComplete}]{\setlength{\rightskip}{0pt plus 5cm}void writeComplete (unsigned {\em id}, \/  uint64\_\-t {\em addr}, \/  uint64\_\-t {\em cycle})}}
\label{classDRAMSim2_aeb50ab991dbcebefc4952362893d0891}
Write completion callback.


\begin{DoxyParams}{引数}
\item[{\em id}]Channel id of the responder \item[{\em addr}]\hyperlink{classAddress}{Address} of the request \item[{\em cycle}]Internal cycle count of \hyperlink{classDRAMSim2}{DRAMSim2} \end{DoxyParams}



\begin{DoxyCode}
317 {
318     assert(cycle == divCeil(curTick(),
319                             wrapper.clockPeriod() * SimClock::Int::ns));
320 
321     DPRINTF(DRAMSim2, "Write to address %lld complete\n", addr);
322 
323     // get the outstanding reads for the address in question
324     auto p = outstandingWrites.find(addr);
325     assert(p != outstandingWrites.end());
326 
327     // we have already responded, and this is only to keep track of
328     // what is outstanding
329     p->second.pop();
330     if (p->second.empty())
331         outstandingWrites.erase(p);
332 
333     assert(nbrOutstandingWrites != 0);
334     --nbrOutstandingWrites;
335 
336     // check if we were asked to drain and if we are now done
337     if (drainManager && nbrOutstanding() == 0) {
338         drainManager->signalDrainDone();
339         drainManager = NULL;
340     }
341 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classDRAMSim2_a329b71fb934a93312ca0aacbf5a3f982}{
\index{DRAMSim2@{DRAMSim2}!drainManager@{drainManager}}
\index{drainManager@{drainManager}!DRAMSim2@{DRAMSim2}}
\subsubsection[{drainManager}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DrainManager}$\ast$ {\bf drainManager}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMSim2_a329b71fb934a93312ca0aacbf5a3f982}
If we need to drain, keep the drain manager around until we're done here. \hypertarget{classDRAMSim2_a75a96fd06206c4a8580628497ad694df}{
\index{DRAMSim2@{DRAMSim2}!nbrOutstandingReads@{nbrOutstandingReads}}
\index{nbrOutstandingReads@{nbrOutstandingReads}!DRAMSim2@{DRAMSim2}}
\subsubsection[{nbrOutstandingReads}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf nbrOutstandingReads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMSim2_a75a96fd06206c4a8580628497ad694df}
Count the number of outstanding transactions so that we can block any further requests until there is space in \hyperlink{classDRAMSim2}{DRAMSim2} and the sending queue we need to buffer the response packets. \hypertarget{classDRAMSim2_ae13aa3a1980dc05e181f85d7304baa82}{
\index{DRAMSim2@{DRAMSim2}!nbrOutstandingWrites@{nbrOutstandingWrites}}
\index{nbrOutstandingWrites@{nbrOutstandingWrites}!DRAMSim2@{DRAMSim2}}
\subsubsection[{nbrOutstandingWrites}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf nbrOutstandingWrites}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMSim2_ae13aa3a1980dc05e181f85d7304baa82}
\hypertarget{classDRAMSim2_aa436e51811d19fcd65fcc5061afc981a}{
\index{DRAMSim2@{DRAMSim2}!outstandingReads@{outstandingReads}}
\index{outstandingReads@{outstandingReads}!DRAMSim2@{DRAMSim2}}
\subsubsection[{outstandingReads}]{\setlength{\rightskip}{0pt plus 5cm}m5::hash\_\-map$<${\bf Addr}, std::queue$<${\bf PacketPtr}$>$ $>$ {\bf outstandingReads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMSim2_aa436e51811d19fcd65fcc5061afc981a}
Keep track of what packets are outstanding per address, and do so separately for reads and writes. This is done so that we can return the right packet on completion from \hyperlink{namespaceDRAMSim}{DRAMSim}. \hypertarget{classDRAMSim2_ae3f05f6f5f0f558c32291a43c04fc1a1}{
\index{DRAMSim2@{DRAMSim2}!outstandingWrites@{outstandingWrites}}
\index{outstandingWrites@{outstandingWrites}!DRAMSim2@{DRAMSim2}}
\subsubsection[{outstandingWrites}]{\setlength{\rightskip}{0pt plus 5cm}m5::hash\_\-map$<${\bf Addr}, std::queue$<${\bf PacketPtr}$>$ $>$ {\bf outstandingWrites}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMSim2_ae3f05f6f5f0f558c32291a43c04fc1a1}
\hypertarget{classDRAMSim2_a21da4bea3554874b557428e4cce5d4a4}{
\index{DRAMSim2@{DRAMSim2}!pendingDelete@{pendingDelete}}
\index{pendingDelete@{pendingDelete}!DRAMSim2@{DRAMSim2}}
\subsubsection[{pendingDelete}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf PacketPtr}$>$ {\bf pendingDelete}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMSim2_a21da4bea3554874b557428e4cce5d4a4}
\begin{Desc}
\item[\hyperlink{todo__todo000084}{TODO}]this is a temporary workaround until the 4-\/phase code is committed. upstream caches needs this packet until true is returned, so hold onto it for deletion until a subsequent call \end{Desc}
\hypertarget{classDRAMSim2_a55c076720c982014096b57cadebf9a14}{
\index{DRAMSim2@{DRAMSim2}!port@{port}}
\index{port@{port}!DRAMSim2@{DRAMSim2}}
\subsubsection[{port}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemoryPort} {\bf port}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMSim2_a55c076720c982014096b57cadebf9a14}
\hypertarget{classDRAMSim2_a7dd56c8ca058e3e734ec0460b1587932}{
\index{DRAMSim2@{DRAMSim2}!responseQueue@{responseQueue}}
\index{responseQueue@{responseQueue}!DRAMSim2@{DRAMSim2}}
\subsubsection[{responseQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::deque}$<${\bf PacketPtr}$>$ {\bf responseQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMSim2_a7dd56c8ca058e3e734ec0460b1587932}
Queue to hold response packets until we can send them back. This is needed as \hyperlink{classDRAMSim2}{DRAMSim2} unconditionally passes responses back without any flow control. \hypertarget{classDRAMSim2_aab3b947b2633a30b5973a39b7e9b018a}{
\index{DRAMSim2@{DRAMSim2}!retryReq@{retryReq}}
\index{retryReq@{retryReq}!DRAMSim2@{DRAMSim2}}
\subsubsection[{retryReq}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf retryReq}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMSim2_aab3b947b2633a30b5973a39b7e9b018a}
Is the connected port waiting for a retry from us \hypertarget{classDRAMSim2_a6ddfdd4eb676d50001bda88567e6da14}{
\index{DRAMSim2@{DRAMSim2}!retryResp@{retryResp}}
\index{retryResp@{retryResp}!DRAMSim2@{DRAMSim2}}
\subsubsection[{retryResp}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf retryResp}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMSim2_a6ddfdd4eb676d50001bda88567e6da14}
Are we waiting for a retry for sending a response. \hypertarget{classDRAMSim2_a46a89603d961c3ae9b2cb2df412503f6}{
\index{DRAMSim2@{DRAMSim2}!sendResponseEvent@{sendResponseEvent}}
\index{sendResponseEvent@{sendResponseEvent}!DRAMSim2@{DRAMSim2}}
\subsubsection[{sendResponseEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf DRAMSim2}, \&DRAMSim2::sendResponse$>$ {\bf sendResponseEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMSim2_a46a89603d961c3ae9b2cb2df412503f6}
\hyperlink{classEvent}{Event} to schedule sending of responses \hypertarget{classDRAMSim2_acab0bec584b681055f948abbbaf8acb2}{
\index{DRAMSim2@{DRAMSim2}!tickEvent@{tickEvent}}
\index{tickEvent@{tickEvent}!DRAMSim2@{DRAMSim2}}
\subsubsection[{tickEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf DRAMSim2}, \&DRAMSim2::tick$>$ {\bf tickEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMSim2_acab0bec584b681055f948abbbaf8acb2}
\hyperlink{classEvent}{Event} to schedule clock ticks \hypertarget{classDRAMSim2_a19f45f63dee6f1b0a77c2758069683f8}{
\index{DRAMSim2@{DRAMSim2}!wrapper@{wrapper}}
\index{wrapper@{wrapper}!DRAMSim2@{DRAMSim2}}
\subsubsection[{wrapper}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DRAMSim2Wrapper} {\bf wrapper}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMSim2_a19f45f63dee6f1b0a77c2758069683f8}
The actual \hyperlink{classDRAMSim2}{DRAMSim2} wrapper 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{dramsim2_8hh}{dramsim2.hh}\item 
mem/\hyperlink{dramsim2_8cc}{dramsim2.cc}\end{DoxyCompactItemize}
