\hypertarget{classPerfectSwitch}{
\section{クラス PerfectSwitch}
\label{classPerfectSwitch}\index{PerfectSwitch@{PerfectSwitch}}
}


{\ttfamily \#include $<$PerfectSwitch.hh$>$}PerfectSwitchに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classPerfectSwitch}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classPerfectSwitch_ae33d3c4e7ad672dcef325947b8c6c306}{PerfectSwitch} (\hyperlink{TypeDefines_8hh_ac925a332c83eaf1e40e056e7a20ebcd8}{SwitchID} sid, \hyperlink{classSwitch}{Switch} $\ast$, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t})
\item 
\hyperlink{classPerfectSwitch_a86d266f35b6d2d7f0f7887a31a6e1978}{$\sim$PerfectSwitch} ()
\item 
std::string \hyperlink{classPerfectSwitch_af1801e31af6399bccce114ab12575168}{name} ()
\item 
void \hyperlink{classPerfectSwitch_a2c2a3eb1ad7853288ac72dc245aea836}{init} (\hyperlink{classSimpleNetwork}{SimpleNetwork} $\ast$)
\item 
void \hyperlink{classPerfectSwitch_a1c4c43d5cc554f870b4c7a485fb25c7e}{addInPort} (const \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMessageBuffer}{MessageBuffer} $\ast$ $>$ \&in)
\item 
void \hyperlink{classPerfectSwitch_a79640b497a553306c19f2458ce05d4be}{addOutPort} (const \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMessageBuffer}{MessageBuffer} $\ast$ $>$ \&out, const \hyperlink{classNetDest}{NetDest} \&routing\_\-table\_\-entry)
\item 
int \hyperlink{classPerfectSwitch_a6b34df98756ca04e25a39378d1a7cc06}{getInLinks} () const 
\item 
int \hyperlink{classPerfectSwitch_adb57a9f7220739b3d11d85188ca7e87d}{getOutLinks} () const 
\item 
void \hyperlink{classPerfectSwitch_ae674290a26ecbd622c5160e38e8a4fe9}{wakeup} ()
\item 
void \hyperlink{classPerfectSwitch_accd0665763c9caa446789b27a62f931b}{storeEventInfo} (int info)
\item 
void \hyperlink{classPerfectSwitch_ac7ec7476159db4e2bb0372e30010fc9e}{clearStats} ()
\item 
void \hyperlink{classPerfectSwitch_a208669cbc0bb1d52565956ca8c690c55}{collateStats} ()
\item 
void \hyperlink{classPerfectSwitch_ac55fe386a101fbae38c716067c9966a0}{print} (std::ostream \&out) const 
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classPerfectSwitch_a787abd150358b9f808fe959f9cb079ee}{PerfectSwitch} (const \hyperlink{classPerfectSwitch}{PerfectSwitch} \&obj)
\item 
\hyperlink{classPerfectSwitch}{PerfectSwitch} \& \hyperlink{classPerfectSwitch_ab37620fb3c7a42bfae3ac244e4f3c3ac}{operator=} (const \hyperlink{classPerfectSwitch}{PerfectSwitch} \&obj)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{TypeDefines_8hh_ac925a332c83eaf1e40e056e7a20ebcd8}{SwitchID} \hyperlink{classPerfectSwitch_aace5aee128494c07cfc442438ef9d0cd}{m\_\-switch\_\-id}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMessageBuffer}{MessageBuffer} $\ast$ $>$ $>$ \hyperlink{classPerfectSwitch_ab0345216ab4e417dda296ba970b74c70}{m\_\-in}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMessageBuffer}{MessageBuffer} $\ast$ $>$ $>$ \hyperlink{classPerfectSwitch_a6a473b3d280f223c89ffc2f5827d523f}{m\_\-out}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classNetDest}{NetDest} $>$ \hyperlink{classPerfectSwitch_adce3e392ac98699a80750fa4a4aa9b40}{m\_\-routing\_\-table}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{structLinkOrder}{LinkOrder} $>$ \hyperlink{classPerfectSwitch_a3dfc7818b7839c506d99739067de07db}{m\_\-link\_\-order}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classPerfectSwitch_a3c1d97c5d987e52985843dcb76edc7fb}{m\_\-virtual\_\-networks}
\item 
int \hyperlink{classPerfectSwitch_af4ca19e1a3ce236185490cf7e67f86d3}{m\_\-round\_\-robin\_\-start}
\item 
int \hyperlink{classPerfectSwitch_aae3ca2ac27d25e29fa0b1856a862d658}{m\_\-wakeups\_\-wo\_\-switch}
\item 
\hyperlink{classSimpleNetwork}{SimpleNetwork} $\ast$ \hyperlink{classPerfectSwitch_a512555c08578dfab6c301b43cc2b0f1b}{m\_\-network\_\-ptr}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ int $>$ \hyperlink{classPerfectSwitch_a39fc69c7cb772cc966b371aa7de444b9}{m\_\-pending\_\-message\_\-count}
\end{DoxyCompactItemize}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classPerfectSwitch_ae33d3c4e7ad672dcef325947b8c6c306}{
\index{PerfectSwitch@{PerfectSwitch}!PerfectSwitch@{PerfectSwitch}}
\index{PerfectSwitch@{PerfectSwitch}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{PerfectSwitch}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PerfectSwitch} ({\bf SwitchID} {\em sid}, \/  {\bf Switch} $\ast$ {\em sw}, \/  {\bf uint32\_\-t} {\em virt\_\-nets})}}
\label{classPerfectSwitch_ae33d3c4e7ad672dcef325947b8c6c306}



\begin{DoxyCode}
51     : Consumer(sw)
52 {
53     m_switch_id = sid;
54     m_round_robin_start = 0;
55     m_wakeups_wo_switch = 0;
56     m_virtual_networks = virt_nets;
57 }
\end{DoxyCode}
\hypertarget{classPerfectSwitch_a86d266f35b6d2d7f0f7887a31a6e1978}{
\index{PerfectSwitch@{PerfectSwitch}!$\sim$PerfectSwitch@{$\sim$PerfectSwitch}}
\index{$\sim$PerfectSwitch@{$\sim$PerfectSwitch}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{$\sim$PerfectSwitch}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf PerfectSwitch} ()}}
\label{classPerfectSwitch_a86d266f35b6d2d7f0f7887a31a6e1978}



\begin{DoxyCode}
106 {
107 }
\end{DoxyCode}
\hypertarget{classPerfectSwitch_a787abd150358b9f808fe959f9cb079ee}{
\index{PerfectSwitch@{PerfectSwitch}!PerfectSwitch@{PerfectSwitch}}
\index{PerfectSwitch@{PerfectSwitch}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{PerfectSwitch}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PerfectSwitch} (const {\bf PerfectSwitch} \& {\em obj})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPerfectSwitch_a787abd150358b9f808fe959f9cb079ee}


\subsection{関数}
\hypertarget{classPerfectSwitch_a1c4c43d5cc554f870b4c7a485fb25c7e}{
\index{PerfectSwitch@{PerfectSwitch}!addInPort@{addInPort}}
\index{addInPort@{addInPort}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{addInPort}]{\setlength{\rightskip}{0pt plus 5cm}void addInPort (const {\bf std::vector}$<$ {\bf MessageBuffer} $\ast$ $>$ \& {\em in})}}
\label{classPerfectSwitch_a1c4c43d5cc554f870b4c7a485fb25c7e}



\begin{DoxyCode}
72 {
73     assert(in.size() == m_virtual_networks);
74     NodeID port = m_in.size();
75     m_in.push_back(in);
76 
77     for (int j = 0; j < m_virtual_networks; j++) {
78         m_in[port][j]->setConsumer(this);
79 
80         string desc = csprintf("[Queue from port %s %s %s to PerfectSwitch]",
81             to_string(m_switch_id), to_string(port), to_string(j));
82         m_in[port][j]->setDescription(desc);
83         m_in[port][j]->setIncomingLink(port);
84         m_in[port][j]->setVnet(j);
85     }
86 }
\end{DoxyCode}
\hypertarget{classPerfectSwitch_a79640b497a553306c19f2458ce05d4be}{
\index{PerfectSwitch@{PerfectSwitch}!addOutPort@{addOutPort}}
\index{addOutPort@{addOutPort}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{addOutPort}]{\setlength{\rightskip}{0pt plus 5cm}void addOutPort (const {\bf std::vector}$<$ {\bf MessageBuffer} $\ast$ $>$ \& {\em out}, \/  const {\bf NetDest} \& {\em routing\_\-table\_\-entry})}}
\label{classPerfectSwitch_a79640b497a553306c19f2458ce05d4be}



\begin{DoxyCode}
91 {
92     assert(out.size() == m_virtual_networks);
93 
94     // Setup link order
95     LinkOrder l;
96     l.m_value = 0;
97     l.m_link = m_out.size();
98     m_link_order.push_back(l);
99 
100     // Add to routing table
101     m_out.push_back(out);
102     m_routing_table.push_back(routing_table_entry);
103 }
\end{DoxyCode}
\hypertarget{classPerfectSwitch_ac7ec7476159db4e2bb0372e30010fc9e}{
\index{PerfectSwitch@{PerfectSwitch}!clearStats@{clearStats}}
\index{clearStats@{clearStats}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{clearStats}]{\setlength{\rightskip}{0pt plus 5cm}void clearStats ()}}
\label{classPerfectSwitch_ac7ec7476159db4e2bb0372e30010fc9e}



\begin{DoxyCode}
305 {
306 }
\end{DoxyCode}
\hypertarget{classPerfectSwitch_a208669cbc0bb1d52565956ca8c690c55}{
\index{PerfectSwitch@{PerfectSwitch}!collateStats@{collateStats}}
\index{collateStats@{collateStats}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{collateStats}]{\setlength{\rightskip}{0pt plus 5cm}void collateStats ()}}
\label{classPerfectSwitch_a208669cbc0bb1d52565956ca8c690c55}



\begin{DoxyCode}
309 {
310 }
\end{DoxyCode}
\hypertarget{classPerfectSwitch_a6b34df98756ca04e25a39378d1a7cc06}{
\index{PerfectSwitch@{PerfectSwitch}!getInLinks@{getInLinks}}
\index{getInLinks@{getInLinks}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{getInLinks}]{\setlength{\rightskip}{0pt plus 5cm}int getInLinks () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPerfectSwitch_a6b34df98756ca04e25a39378d1a7cc06}



\begin{DoxyCode}
71 { return m_in.size(); }
\end{DoxyCode}
\hypertarget{classPerfectSwitch_adb57a9f7220739b3d11d85188ca7e87d}{
\index{PerfectSwitch@{PerfectSwitch}!getOutLinks@{getOutLinks}}
\index{getOutLinks@{getOutLinks}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{getOutLinks}]{\setlength{\rightskip}{0pt plus 5cm}int getOutLinks () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPerfectSwitch_adb57a9f7220739b3d11d85188ca7e87d}



\begin{DoxyCode}
72 { return m_out.size(); }
\end{DoxyCode}
\hypertarget{classPerfectSwitch_a2c2a3eb1ad7853288ac72dc245aea836}{
\index{PerfectSwitch@{PerfectSwitch}!init@{init}}
\index{init@{init}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ({\bf SimpleNetwork} $\ast$ {\em network\_\-ptr})}}
\label{classPerfectSwitch_a2c2a3eb1ad7853288ac72dc245aea836}



\begin{DoxyCode}
61 {
62     m_network_ptr = network_ptr;
63 
64     for(int i = 0;i < m_virtual_networks;++i)
65     {
66         m_pending_message_count.push_back(0);
67     }
68 }
\end{DoxyCode}
\hypertarget{classPerfectSwitch_af1801e31af6399bccce114ab12575168}{
\index{PerfectSwitch@{PerfectSwitch}!name@{name}}
\index{name@{name}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPerfectSwitch_af1801e31af6399bccce114ab12575168}



\begin{DoxyCode}
65     { return csprintf("PerfectSwitch-%i", m_switch_id); }
\end{DoxyCode}
\hypertarget{classPerfectSwitch_ab37620fb3c7a42bfae3ac244e4f3c3ac}{
\index{PerfectSwitch@{PerfectSwitch}!operator=@{operator=}}
\index{operator=@{operator=}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PerfectSwitch}\& operator= (const {\bf PerfectSwitch} \& {\em obj})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPerfectSwitch_ab37620fb3c7a42bfae3ac244e4f3c3ac}
\hypertarget{classPerfectSwitch_ac55fe386a101fbae38c716067c9966a0}{
\index{PerfectSwitch@{PerfectSwitch}!print@{print}}
\index{print@{print}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}void print (std::ostream \& {\em out}) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPerfectSwitch_ac55fe386a101fbae38c716067c9966a0}


\hyperlink{classConsumer_a3ea5f7af5db62cc24f4e40df9ea5c971}{Consumer}を実装しています。


\begin{DoxyCode}
315 {
316     out << "[PerfectSwitch " << m_switch_id << "]";
317 }
\end{DoxyCode}
\hypertarget{classPerfectSwitch_accd0665763c9caa446789b27a62f931b}{
\index{PerfectSwitch@{PerfectSwitch}!storeEventInfo@{storeEventInfo}}
\index{storeEventInfo@{storeEventInfo}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{storeEventInfo}]{\setlength{\rightskip}{0pt plus 5cm}void storeEventInfo (int {\em info})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPerfectSwitch_accd0665763c9caa446789b27a62f931b}


\hyperlink{classConsumer_a6f82fdec6e5674ac2254f16b8fa82afb}{Consumer}を再定義しています。


\begin{DoxyCode}
299 {
300     m_pending_message_count[info]++;
301 }
\end{DoxyCode}
\hypertarget{classPerfectSwitch_ae674290a26ecbd622c5160e38e8a4fe9}{
\index{PerfectSwitch@{PerfectSwitch}!wakeup@{wakeup}}
\index{wakeup@{wakeup}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{wakeup}]{\setlength{\rightskip}{0pt plus 5cm}void wakeup ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPerfectSwitch_ae674290a26ecbd622c5160e38e8a4fe9}


\hyperlink{classConsumer_a623e3e7d1b1c725d70009f7b01a421b9}{Consumer}を実装しています。


\begin{DoxyCode}
111 {
112     MsgPtr msg_ptr;
113 
114     // Give the highest numbered link priority most of the time
115     m_wakeups_wo_switch++;
116     int highest_prio_vnet = m_virtual_networks-1;
117     int lowest_prio_vnet = 0;
118     int decrementer = 1;
119     NetworkMessage* net_msg_ptr = NULL;
120 
121     // invert priorities to avoid starvation seen in the component network
122     if (m_wakeups_wo_switch > PRIORITY_SWITCH_LIMIT) {
123         m_wakeups_wo_switch = 0;
124         highest_prio_vnet = 0;
125         lowest_prio_vnet = m_virtual_networks-1;
126         decrementer = -1;
127     }
128 
129     // For all components incoming queues
130     for (int vnet = highest_prio_vnet;
131          (vnet * decrementer) >= (decrementer * lowest_prio_vnet);
132          vnet -= decrementer) {
133 
134         // This is for round-robin scheduling
135         int incoming = m_round_robin_start;
136         m_round_robin_start++;
137         if (m_round_robin_start >= m_in.size()) {
138             m_round_robin_start = 0;
139         }
140 
141         if(m_pending_message_count[vnet] > 0) {
142             // for all input ports, use round robin scheduling
143             for (int counter = 0; counter < m_in.size(); counter++) {
144                 // Round robin scheduling
145                 incoming++;
146                 if (incoming >= m_in.size()) {
147                     incoming = 0;
148                 }
149 
150                 // temporary vectors to store the routing results
151                 vector<LinkID> output_links;
152                 vector<NetDest> output_link_destinations;
153 
154                 // Is there a message waiting?
155                 while (m_in[incoming][vnet]->isReady()) {
156                     DPRINTF(RubyNetwork, "incoming: %d\n", incoming);
157 
158                     // Peek at message
159                     msg_ptr = m_in[incoming][vnet]->peekMsgPtr();
160                     net_msg_ptr = safe_cast<NetworkMessage*>(msg_ptr.get());
161                     DPRINTF(RubyNetwork, "Message: %s\n", (*net_msg_ptr));
162 
163                     output_links.clear();
164                     output_link_destinations.clear();
165                     NetDest msg_dsts =
166                         net_msg_ptr->getInternalDestination();
167 
168                     // Unfortunately, the token-protocol sends some
169                     // zero-destination messages, so this assert isn't valid
170                     // assert(msg_dsts.count() > 0);
171 
172                     assert(m_link_order.size() == m_routing_table.size());
173                     assert(m_link_order.size() == m_out.size());
174 
175                     if (m_network_ptr->getAdaptiveRouting()) {
176                         if (m_network_ptr->isVNetOrdered(vnet)) {
177                             // Don't adaptively route
178                             for (int out = 0; out < m_out.size(); out++) {
179                                 m_link_order[out].m_link = out;
180                                 m_link_order[out].m_value = 0;
181                             }
182                         } else {
183                             // Find how clogged each link is
184                             for (int out = 0; out < m_out.size(); out++) {
185                                 int out_queue_length = 0;
186                                 for (int v = 0; v < m_virtual_networks; v++) {
187                                     out_queue_length += m_out[out][v]->getSize();
      
188                                 }
189                                 int value =
190                                     (out_queue_length << 8) | (random() & 0xff);
191                                 m_link_order[out].m_link = out;
192                                 m_link_order[out].m_value = value;
193                             }
194 
195                             // Look at the most empty link first
196                             sort(m_link_order.begin(), m_link_order.end());
197                         }
198                     }
199 
200                     for (int i = 0; i < m_routing_table.size(); i++) {
201                         // pick the next link to look at
202                         int link = m_link_order[i].m_link;
203                         NetDest dst = m_routing_table[link];
204                         DPRINTF(RubyNetwork, "dst: %s\n", dst);
205 
206                         if (!msg_dsts.intersectionIsNotEmpty(dst))
207                             continue;
208 
209                         // Remember what link we're using
210                         output_links.push_back(link);
211 
212                         // Need to remember which destinations need this
213                         // message in another vector.  This Set is the
214                         // intersection of the routing_table entry and the
215                         // current destination set.  The intersection must
216                         // not be empty, since we are inside "if"
217                         output_link_destinations.push_back(msg_dsts.AND(dst));
218 
219                         // Next, we update the msg_destination not to
220                         // include those nodes that were already handled
221                         // by this link
222                         msg_dsts.removeNetDest(dst);
223                     }
224 
225                     assert(msg_dsts.count() == 0);
226                     //assert(output_links.size() > 0);
227 
228                     // Check for resources - for all outgoing queues
229                     bool enough = true;
230                     for (int i = 0; i < output_links.size(); i++) {
231                         int outgoing = output_links[i];
232                         if (!m_out[outgoing][vnet]->areNSlotsAvailable(1))
233                             enough = false;
234                         DPRINTF(RubyNetwork, "Checking if node is blocked ..."
235                                 "outgoing: %d, vnet: %d, enough: %d\n",
236                                 outgoing, vnet, enough);
237                     }
238 
239                     // There were not enough resources
240                     if (!enough) {
241                         scheduleEvent(Cycles(1));
242                         DPRINTF(RubyNetwork, "Can't deliver message since a node 
      "
243                                 "is blocked\n");
244                         DPRINTF(RubyNetwork, "Message: %s\n", (*net_msg_ptr));
245                         break; // go to next incoming port
246                     }
247 
248                     MsgPtr unmodified_msg_ptr;
249 
250                     if (output_links.size() > 1) {
251                         // If we are sending this message down more than
252                         // one link (size>1), we need to make a copy of
253                         // the message so each branch can have a different
254                         // internal destination we need to create an
255                         // unmodified MsgPtr because the MessageBuffer
256                         // enqueue func will modify the message
257 
258                         // This magic line creates a private copy of the
259                         // message
260                         unmodified_msg_ptr = msg_ptr->clone();
261                     }
262 
263                     // Dequeue msg
264                     m_in[incoming][vnet]->dequeue();
265                     m_pending_message_count[vnet]--;
266 
267                     // Enqueue it - for all outgoing queues
268                     for (int i=0; i<output_links.size(); i++) {
269                         int outgoing = output_links[i];
270 
271                         if (i > 0) {
272                             // create a private copy of the unmodified
273                             // message
274                             msg_ptr = unmodified_msg_ptr->clone();
275                         }
276 
277                         // Change the internal destination set of the
278                         // message so it knows which destinations this
279                         // link is responsible for.
280                         net_msg_ptr = safe_cast<NetworkMessage*>(msg_ptr.get());
281                         net_msg_ptr->getInternalDestination() =
282                             output_link_destinations[i];
283 
284                         // Enqeue msg
285                         DPRINTF(RubyNetwork, "Enqueuing net msg from "
286                                 "inport[%d][%d] to outport [%d][%d].\n",
287                                 incoming, vnet, outgoing, vnet);
288 
289                         m_out[outgoing][vnet]->enqueue(msg_ptr);
290                     }
291                 }
292             }
293         }
294     }
295 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classPerfectSwitch_ab0345216ab4e417dda296ba970b74c70}{
\index{PerfectSwitch@{PerfectSwitch}!m\_\-in@{m\_\-in}}
\index{m\_\-in@{m\_\-in}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{m\_\-in}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf std::vector}$<${\bf MessageBuffer}$\ast$$>$ $>$ {\bf m\_\-in}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPerfectSwitch_ab0345216ab4e417dda296ba970b74c70}
\hypertarget{classPerfectSwitch_a3dfc7818b7839c506d99739067de07db}{
\index{PerfectSwitch@{PerfectSwitch}!m\_\-link\_\-order@{m\_\-link\_\-order}}
\index{m\_\-link\_\-order@{m\_\-link\_\-order}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{m\_\-link\_\-order}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf LinkOrder}$>$ {\bf m\_\-link\_\-order}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPerfectSwitch_a3dfc7818b7839c506d99739067de07db}
\hypertarget{classPerfectSwitch_a512555c08578dfab6c301b43cc2b0f1b}{
\index{PerfectSwitch@{PerfectSwitch}!m\_\-network\_\-ptr@{m\_\-network\_\-ptr}}
\index{m\_\-network\_\-ptr@{m\_\-network\_\-ptr}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{m\_\-network\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SimpleNetwork}$\ast$ {\bf m\_\-network\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPerfectSwitch_a512555c08578dfab6c301b43cc2b0f1b}
\hypertarget{classPerfectSwitch_a6a473b3d280f223c89ffc2f5827d523f}{
\index{PerfectSwitch@{PerfectSwitch}!m\_\-out@{m\_\-out}}
\index{m\_\-out@{m\_\-out}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{m\_\-out}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf std::vector}$<${\bf MessageBuffer}$\ast$$>$ $>$ {\bf m\_\-out}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPerfectSwitch_a6a473b3d280f223c89ffc2f5827d523f}
\hypertarget{classPerfectSwitch_a39fc69c7cb772cc966b371aa7de444b9}{
\index{PerfectSwitch@{PerfectSwitch}!m\_\-pending\_\-message\_\-count@{m\_\-pending\_\-message\_\-count}}
\index{m\_\-pending\_\-message\_\-count@{m\_\-pending\_\-message\_\-count}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{m\_\-pending\_\-message\_\-count}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<$int$>$ {\bf m\_\-pending\_\-message\_\-count}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPerfectSwitch_a39fc69c7cb772cc966b371aa7de444b9}
\hypertarget{classPerfectSwitch_af4ca19e1a3ce236185490cf7e67f86d3}{
\index{PerfectSwitch@{PerfectSwitch}!m\_\-round\_\-robin\_\-start@{m\_\-round\_\-robin\_\-start}}
\index{m\_\-round\_\-robin\_\-start@{m\_\-round\_\-robin\_\-start}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{m\_\-round\_\-robin\_\-start}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-round\_\-robin\_\-start}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPerfectSwitch_af4ca19e1a3ce236185490cf7e67f86d3}
\hypertarget{classPerfectSwitch_adce3e392ac98699a80750fa4a4aa9b40}{
\index{PerfectSwitch@{PerfectSwitch}!m\_\-routing\_\-table@{m\_\-routing\_\-table}}
\index{m\_\-routing\_\-table@{m\_\-routing\_\-table}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{m\_\-routing\_\-table}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf NetDest}$>$ {\bf m\_\-routing\_\-table}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPerfectSwitch_adce3e392ac98699a80750fa4a4aa9b40}
\hypertarget{classPerfectSwitch_aace5aee128494c07cfc442438ef9d0cd}{
\index{PerfectSwitch@{PerfectSwitch}!m\_\-switch\_\-id@{m\_\-switch\_\-id}}
\index{m\_\-switch\_\-id@{m\_\-switch\_\-id}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{m\_\-switch\_\-id}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SwitchID} {\bf m\_\-switch\_\-id}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPerfectSwitch_aace5aee128494c07cfc442438ef9d0cd}
\hypertarget{classPerfectSwitch_a3c1d97c5d987e52985843dcb76edc7fb}{
\index{PerfectSwitch@{PerfectSwitch}!m\_\-virtual\_\-networks@{m\_\-virtual\_\-networks}}
\index{m\_\-virtual\_\-networks@{m\_\-virtual\_\-networks}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{m\_\-virtual\_\-networks}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf m\_\-virtual\_\-networks}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPerfectSwitch_a3c1d97c5d987e52985843dcb76edc7fb}
\hypertarget{classPerfectSwitch_aae3ca2ac27d25e29fa0b1856a862d658}{
\index{PerfectSwitch@{PerfectSwitch}!m\_\-wakeups\_\-wo\_\-switch@{m\_\-wakeups\_\-wo\_\-switch}}
\index{m\_\-wakeups\_\-wo\_\-switch@{m\_\-wakeups\_\-wo\_\-switch}!PerfectSwitch@{PerfectSwitch}}
\subsubsection[{m\_\-wakeups\_\-wo\_\-switch}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-wakeups\_\-wo\_\-switch}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPerfectSwitch_aae3ca2ac27d25e29fa0b1856a862d658}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/ruby/network/simple/\hyperlink{PerfectSwitch_8hh}{PerfectSwitch.hh}\item 
mem/ruby/network/simple/\hyperlink{PerfectSwitch_8cc}{PerfectSwitch.cc}\end{DoxyCompactItemize}
