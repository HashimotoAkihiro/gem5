\hypertarget{classAbstractMemory}{
\section{クラス AbstractMemory}
\label{classAbstractMemory}\index{AbstractMemory@{AbstractMemory}}
}


{\ttfamily \#include $<$abstract\_\-mem.hh$>$}AbstractMemoryに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.44086cm]{classAbstractMemory}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classAbstractMemory_1_1AbstractMemory}{AbstractMemory}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef AbstractMemoryParams \hyperlink{classAbstractMemory_ab4fcbcbcfef78d6bc871995f8eca40eb}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classAbstractMemory_a69baeab8b9f1056447fe16519fd89923}{AbstractMemory} (const \hyperlink{classAbstractMemory_ab4fcbcbcfef78d6bc871995f8eca40eb}{Params} $\ast$p)
\item 
virtual \hyperlink{classAbstractMemory_a7cff70b609d2b2b8ac45e1fe12b7bc96}{$\sim$AbstractMemory} ()
\item 
bool \hyperlink{classAbstractMemory_ac02f2a4d7312eb91f40980adfd4e31b2}{isNull} () const 
\item 
void \hyperlink{classAbstractMemory_a2651a6edea3b7884410b1abefac8b2de}{setBackingStore} (uint8\_\-t $\ast$pmem\_\-addr)
\item 
const \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classLockedAddr}{LockedAddr} $>$ \& \hyperlink{classAbstractMemory_a5b569455e6a1bd8629737fa02564a9a8}{getLockedAddrList} () const 
\item 
void \hyperlink{classAbstractMemory_a41e2bc27bc88cc5c7d1d8c7a905e7cfc}{addLockedAddr} (\hyperlink{classLockedAddr}{LockedAddr} addr)
\item 
\hyperlink{classSystem}{System} $\ast$ \hyperlink{classAbstractMemory_a83984c42bc765168929779ed9a37ebe8}{system} () const 
\item 
void \hyperlink{classAbstractMemory_ad086bdc3ed123ad02169847d658bf5cb}{system} (\hyperlink{classSystem}{System} $\ast$sys)
\item 
const \hyperlink{classAbstractMemory_ab4fcbcbcfef78d6bc871995f8eca40eb}{Params} $\ast$ \hyperlink{classAbstractMemory_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{classAddrRange}{AddrRange} \hyperlink{classAbstractMemory_aa3df62a6c92a30a0ab9247f8ec9e6e7a}{getAddrRange} () const 
\item 
uint64\_\-t \hyperlink{classAbstractMemory_a0b6868dbef44fc07f11d050eb59e5f7e}{size} () const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classAbstractMemory_a85325674b7aed05d6b4e40a48563189b}{start} () const 
\item 
bool \hyperlink{classAbstractMemory_aca224861e09cf94a49088bb51bb02350}{isConfReported} () const 
\item 
bool \hyperlink{classAbstractMemory_ad89e9980a76342142d63ff15deb19497}{isInAddrMap} () const 
\item 
void \hyperlink{classAbstractMemory_aac5d96736802cb79fb2287135bcc1dff}{access} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classAbstractMemory_ace845b5316308e12fd958fa5df09a8e8}{functionalAccess} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual void \hyperlink{classAbstractMemory_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classAbstractMemory_af088ed7a675d24827a3300bdbc62e96a}{checkLockedAddrList} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classAbstractMemory_ad317aec11d97a72993e653755fa1c003}{trackLoadLocked} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classAbstractMemory_ab1136219a28374092ad398d673bd23e0}{writeOK} (\hyperlink{classPacket}{PacketPtr} pkt)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classAddrRange}{AddrRange} \hyperlink{classAbstractMemory_a194876a072a83a9fd59dde82e5213f0d}{range}
\item 
uint8\_\-t $\ast$ \hyperlink{classAbstractMemory_a9f8ed24d8442f662831d51922e7fddd2}{pmemAddr}
\item 
bool \hyperlink{classAbstractMemory_adee792d6bf567779ea9c16640af42784}{confTableReported}
\item 
bool \hyperlink{classAbstractMemory_a7302c053380cdccd0bdf63b25f73cbc5}{inAddrMap}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classLockedAddr}{LockedAddr} $>$ \hyperlink{classAbstractMemory_af35631da2ae35079d76e07c46fe78565}{lockedAddrList}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classAbstractMemory_aa36971a2ea8ddd9d82832059cbc1b21f}{bytesRead}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classAbstractMemory_a5e52eb4a824c1fb452d77dae86dfa970}{bytesInstRead}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classAbstractMemory_ab89ec4a4876671ad5186d0e9c0e674ed}{bytesWritten}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classAbstractMemory_a27f442fbcb7bc7661412cc1d96ca51e7}{numReads}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classAbstractMemory_acfd6a97aa6c2de05417a7403369e71c2}{numWrites}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classAbstractMemory_a52bafd014022e75d82b4e0de25d3faf7}{numOther}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classAbstractMemory_a14a0a95f3cd104b70d5b5c19c3ee8099}{bwRead}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classAbstractMemory_a00512ebb77886b71a63bd1595828d592}{bwInstRead}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classAbstractMemory_a8077d31db9c4f4f9e78888def6de8430}{bwWrite}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classAbstractMemory_a678ff8c93c78d0be1884742ef8aa41e8}{bwTotal}
\item 
\hyperlink{classSystem}{System} $\ast$ \hyperlink{classAbstractMemory_a1da55f4024bf8a9b14b64054841148b8}{\_\-system}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classAbstractMemory_abe7c4ad03729f9b3dd25d3dc43361103}{AbstractMemory} (const \hyperlink{classAbstractMemory_1_1AbstractMemory}{AbstractMemory} \&)
\item 
\hyperlink{classAbstractMemory_1_1AbstractMemory}{AbstractMemory} \& \hyperlink{classAbstractMemory_a8524c3be63882adac591f591519f3a3b}{operator=} (const \hyperlink{classAbstractMemory_1_1AbstractMemory}{AbstractMemory} \&)
\end{DoxyCompactItemize}


\subsection{説明}
An abstract memory represents a contiguous block of physical memory, with an associated address range, and also provides basic functionality for reading and writing this memory without any timing information. It is a \hyperlink{classMemObject}{MemObject} since any subclass must have at least one slave port. 

\subsection{型定義}
\hypertarget{classAbstractMemory_ab4fcbcbcfef78d6bc871995f8eca40eb}{
\index{AbstractMemory@{AbstractMemory}!Params@{Params}}
\index{Params@{Params}!AbstractMemory@{AbstractMemory}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef AbstractMemoryParams {\bf Params}}}
\label{classAbstractMemory_ab4fcbcbcfef78d6bc871995f8eca40eb}


\hyperlink{classMemObject_a905bbc621eeec0ed08859e21c8c95412}{MemObject}を再定義しています。

\hyperlink{classDRAMSim2_ae66665a06c9d64a6ba0e56d589b74d6c}{DRAMSim2}で再定義されています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classAbstractMemory_abe7c4ad03729f9b3dd25d3dc43361103}{
\index{AbstractMemory@{AbstractMemory}!AbstractMemory@{AbstractMemory}}
\index{AbstractMemory@{AbstractMemory}!AbstractMemory@{AbstractMemory}}
\subsubsection[{AbstractMemory}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AbstractMemory} (const {\bf AbstractMemory} \&)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAbstractMemory_abe7c4ad03729f9b3dd25d3dc43361103}
\hypertarget{classAbstractMemory_a69baeab8b9f1056447fe16519fd89923}{
\index{AbstractMemory@{AbstractMemory}!AbstractMemory@{AbstractMemory}}
\index{AbstractMemory@{AbstractMemory}!AbstractMemory@{AbstractMemory}}
\subsubsection[{AbstractMemory}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AbstractMemory} (const {\bf Params} $\ast$ {\em p})}}
\label{classAbstractMemory_a69baeab8b9f1056447fe16519fd89923}



\begin{DoxyCode}
57                                               :
58     MemObject(p), range(params()->range), pmemAddr(NULL),
59     confTableReported(p->conf_table_reported), inAddrMap(p->in_addr_map),
60     _system(NULL)
61 {
62     if (size() % TheISA::PageBytes != 0)
63         panic("Memory Size not divisible by page size\n");
64 }

\end{DoxyCode}
\hypertarget{classAbstractMemory_a7cff70b609d2b2b8ac45e1fe12b7bc96}{
\index{AbstractMemory@{AbstractMemory}!$\sim$AbstractMemory@{$\sim$AbstractMemory}}
\index{$\sim$AbstractMemory@{$\sim$AbstractMemory}!AbstractMemory@{AbstractMemory}}
\subsubsection[{$\sim$AbstractMemory}]{\setlength{\rightskip}{0pt plus 5cm}virtual $\sim${\bf AbstractMemory} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classAbstractMemory_a7cff70b609d2b2b8ac45e1fe12b7bc96}



\begin{DoxyCode}
195 {}
\end{DoxyCode}


\subsection{関数}
\hypertarget{classAbstractMemory_aac5d96736802cb79fb2287135bcc1dff}{
\index{AbstractMemory@{AbstractMemory}!access@{access}}
\index{access@{access}!AbstractMemory@{AbstractMemory}}
\subsubsection[{access}]{\setlength{\rightskip}{0pt plus 5cm}void access ({\bf PacketPtr} {\em pkt})}}
\label{classAbstractMemory_aac5d96736802cb79fb2287135bcc1dff}
Perform an untimed memory access and update all the state (e.g. locked addresses) and statistics accordingly. The packet is turned into a response if required.


\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} performing the access \end{DoxyParams}



\begin{DoxyCode}
317 {
318     assert(AddrRange(pkt->getAddr(),
319                      pkt->getAddr() + pkt->getSize() - 1).isSubset(range));
320 
321     if (pkt->memInhibitAsserted()) {
322         DPRINTF(MemoryAccess, "mem inhibited on 0x%x: not responding\n",
323                 pkt->getAddr());
324         return;
325     }
326 
327     uint8_t *hostAddr = pmemAddr + pkt->getAddr() - range.start();
328 
329     if (pkt->cmd == MemCmd::SwapReq) {
330         TheISA::IntReg overwrite_val;
331         bool overwrite_mem;
332         uint64_t condition_val64;
333         uint32_t condition_val32;
334 
335         if (!pmemAddr)
336             panic("Swap only works if there is real memory (i.e. null=False)");
337         assert(sizeof(TheISA::IntReg) >= pkt->getSize());
338 
339         overwrite_mem = true;
340         // keep a copy of our possible write value, and copy what is at the
341         // memory address into the packet
342         std::memcpy(&overwrite_val, pkt->getPtr<uint8_t>(), pkt->getSize());
343         std::memcpy(pkt->getPtr<uint8_t>(), hostAddr, pkt->getSize());
344 
345         if (pkt->req->isCondSwap()) {
346             if (pkt->getSize() == sizeof(uint64_t)) {
347                 condition_val64 = pkt->req->getExtraData();
348                 overwrite_mem = !std::memcmp(&condition_val64, hostAddr,
349                                              sizeof(uint64_t));
350             } else if (pkt->getSize() == sizeof(uint32_t)) {
351                 condition_val32 = (uint32_t)pkt->req->getExtraData();
352                 overwrite_mem = !std::memcmp(&condition_val32, hostAddr,
353                                              sizeof(uint32_t));
354             } else
355                 panic("Invalid size for conditional read/write\n");
356         }
357 
358         if (overwrite_mem)
359             std::memcpy(hostAddr, &overwrite_val, pkt->getSize());
360 
361         assert(!pkt->req->isInstFetch());
362         TRACE_PACKET("Read/Write");
363         numOther[pkt->req->masterId()]++;
364     } else if (pkt->isRead()) {
365         assert(!pkt->isWrite());
366         if (pkt->isLLSC()) {
367             trackLoadLocked(pkt);
368         }
369         if (pmemAddr)
370             memcpy(pkt->getPtr<uint8_t>(), hostAddr, pkt->getSize());
371         TRACE_PACKET(pkt->req->isInstFetch() ? "IFetch" : "Read");
372         numReads[pkt->req->masterId()]++;
373         bytesRead[pkt->req->masterId()] += pkt->getSize();
374         if (pkt->req->isInstFetch())
375             bytesInstRead[pkt->req->masterId()] += pkt->getSize();
376     } else if (pkt->isWrite()) {
377         if (writeOK(pkt)) {
378             if (pmemAddr) {
379                 memcpy(hostAddr, pkt->getPtr<uint8_t>(), pkt->getSize());
380                 DPRINTF(MemoryAccess, "%s wrote %x bytes to address %x\n",
381                         __func__, pkt->getSize(), pkt->getAddr());
382             }
383             assert(!pkt->req->isInstFetch());
384             TRACE_PACKET("Write");
385             numWrites[pkt->req->masterId()]++;
386             bytesWritten[pkt->req->masterId()] += pkt->getSize();
387         }
388     } else if (pkt->isInvalidate()) {
389         // no need to do anything
390     } else {
391         panic("unimplemented");
392     }
393 
394     if (pkt->needsResponse()) {
395         pkt->makeResponse();
396     }
397 }
\end{DoxyCode}
\hypertarget{classAbstractMemory_a41e2bc27bc88cc5c7d1d8c7a905e7cfc}{
\index{AbstractMemory@{AbstractMemory}!addLockedAddr@{addLockedAddr}}
\index{addLockedAddr@{addLockedAddr}!AbstractMemory@{AbstractMemory}}
\subsubsection[{addLockedAddr}]{\setlength{\rightskip}{0pt plus 5cm}void addLockedAddr ({\bf LockedAddr} {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAbstractMemory_a41e2bc27bc88cc5c7d1d8c7a905e7cfc}
Add a locked address to allow for checkpointing. 


\begin{DoxyCode}
222 { lockedAddrList.push_back(addr); }
\end{DoxyCode}
\hypertarget{classAbstractMemory_af088ed7a675d24827a3300bdbc62e96a}{
\index{AbstractMemory@{AbstractMemory}!checkLockedAddrList@{checkLockedAddrList}}
\index{checkLockedAddrList@{checkLockedAddrList}!AbstractMemory@{AbstractMemory}}
\subsubsection[{checkLockedAddrList}]{\setlength{\rightskip}{0pt plus 5cm}bool checkLockedAddrList ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractMemory_af088ed7a675d24827a3300bdbc62e96a}



\begin{DoxyCode}
221 {
222     Request *req = pkt->req;
223     Addr paddr = LockedAddr::mask(req->getPaddr());
224     bool isLLSC = pkt->isLLSC();
225 
226     // Initialize return value.  Non-conditional stores always
227     // succeed.  Assume conditional stores will fail until proven
228     // otherwise.
229     bool allowStore = !isLLSC;
230 
231     // Iterate over list.  Note that there could be multiple matching records,
232     // as more than one context could have done a load locked to this location.
233     // Only remove records when we succeed in finding a record for (xc, addr);
234     // then, remove all records with this address.  Failed store-conditionals do
235     // not blow unrelated reservations.
236     list<LockedAddr>::iterator i = lockedAddrList.begin();
237 
238     if (isLLSC) {
239         while (i != lockedAddrList.end()) {
240             if (i->addr == paddr && i->matchesContext(req)) {
241                 // it's a store conditional, and as far as the memory system can
242                 // tell, the requesting context's lock is still valid.
243                 DPRINTF(LLSC, "StCond success: context %d addr %#x\n",
244                         req->contextId(), paddr);
245                 allowStore = true;
246                 break;
247             }
248             // If we didn't find a match, keep searching!  Someone else may well
249             // have a reservation on this line here but we may find ours in just
250             // a little while.
251             i++;
252         }
253         req->setExtraData(allowStore ? 1 : 0);
254     }
255     // LLSCs that succeeded AND non-LLSC stores both fall into here:
256     if (allowStore) {
257         // We write address paddr.  However, there may be several entries with a
258         // reservation on this address (for other contextIds) and they must all
259         // be removed.
260         i = lockedAddrList.begin();
261         while (i != lockedAddrList.end()) {
262             if (i->addr == paddr) {
263                 DPRINTF(LLSC, "Erasing lock record: context %d addr %#x\n",
264                         i->contextId, paddr);
265                 // For ARM, a spinlock would typically include a Wait
266                 // For Event (WFE) to conserve energy. The ARMv8
267                 // architecture specifies that an event is
268                 // automatically generated when clearing the exclusive
269                 // monitor to wake up the processor in WFE.
270                 system()->getThreadContext(i->contextId)->getCpuPtr()->wakeup();
271                 i = lockedAddrList.erase(i);
272             } else {
273                 i++;
274             }
275         }
276     }
277 
278     return allowStore;
279 }
\end{DoxyCode}
\hypertarget{classAbstractMemory_ace845b5316308e12fd958fa5df09a8e8}{
\index{AbstractMemory@{AbstractMemory}!functionalAccess@{functionalAccess}}
\index{functionalAccess@{functionalAccess}!AbstractMemory@{AbstractMemory}}
\subsubsection[{functionalAccess}]{\setlength{\rightskip}{0pt plus 5cm}void functionalAccess ({\bf PacketPtr} {\em pkt})}}
\label{classAbstractMemory_ace845b5316308e12fd958fa5df09a8e8}
Perform an untimed memory read or write without changing anything but the memory itself. No stats are affected by this access. In addition to normal accesses this also facilitates print requests.


\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} performing the access \end{DoxyParams}



\begin{DoxyCode}
401 {
402     assert(AddrRange(pkt->getAddr(),
403                      pkt->getAddr() + pkt->getSize() - 1).isSubset(range));
404 
405     uint8_t *hostAddr = pmemAddr + pkt->getAddr() - range.start();
406 
407     if (pkt->isRead()) {
408         if (pmemAddr)
409             memcpy(pkt->getPtr<uint8_t>(), hostAddr, pkt->getSize());
410         TRACE_PACKET("Read");
411         pkt->makeResponse();
412     } else if (pkt->isWrite()) {
413         if (pmemAddr)
414             memcpy(hostAddr, pkt->getPtr<uint8_t>(), pkt->getSize());
415         TRACE_PACKET("Write");
416         pkt->makeResponse();
417     } else if (pkt->isPrint()) {
418         Packet::PrintReqState *prs =
419             dynamic_cast<Packet::PrintReqState*>(pkt->senderState);
420         assert(prs);
421         // Need to call printLabels() explicitly since we're not going
422         // through printObj().
423         prs->printLabels();
424         // Right now we just print the single byte at the specified address.
425         ccprintf(prs->os, "%s%#x\n", prs->curPrefix(), *hostAddr);
426     } else {
427         panic("AbstractMemory: unimplemented functional command %s",
428               pkt->cmdString());
429     }
430 }
\end{DoxyCode}
\hypertarget{classAbstractMemory_aa3df62a6c92a30a0ab9247f8ec9e6e7a}{
\index{AbstractMemory@{AbstractMemory}!getAddrRange@{getAddrRange}}
\index{getAddrRange@{getAddrRange}!AbstractMemory@{AbstractMemory}}
\subsubsection[{getAddrRange}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRange} getAddrRange () const}}
\label{classAbstractMemory_aa3df62a6c92a30a0ab9247f8ec9e6e7a}
Get the address range

\begin{DoxyReturn}{戻り値}
a single contigous address range 
\end{DoxyReturn}



\begin{DoxyCode}
182 {
183     return range;
184 }
\end{DoxyCode}
\hypertarget{classAbstractMemory_a5b569455e6a1bd8629737fa02564a9a8}{
\index{AbstractMemory@{AbstractMemory}!getLockedAddrList@{getLockedAddrList}}
\index{getLockedAddrList@{getLockedAddrList}!AbstractMemory@{AbstractMemory}}
\subsubsection[{getLockedAddrList}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf std::list}$<${\bf LockedAddr}$>$\& getLockedAddrList () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAbstractMemory_a5b569455e6a1bd8629737fa02564a9a8}
Get the list of locked addresses to allow checkpointing. 


\begin{DoxyCode}
217     { return lockedAddrList; }
\end{DoxyCode}
\hypertarget{classAbstractMemory_aca224861e09cf94a49088bb51bb02350}{
\index{AbstractMemory@{AbstractMemory}!isConfReported@{isConfReported}}
\index{isConfReported@{isConfReported}!AbstractMemory@{AbstractMemory}}
\subsubsection[{isConfReported}]{\setlength{\rightskip}{0pt plus 5cm}bool isConfReported () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAbstractMemory_aca224861e09cf94a49088bb51bb02350}
Should this memory be passed to the kernel and part of the OS physical memory layout.

\begin{DoxyReturn}{戻り値}
if this memory is reported 
\end{DoxyReturn}



\begin{DoxyCode}
270 { return confTableReported; }
\end{DoxyCode}
\hypertarget{classAbstractMemory_ad89e9980a76342142d63ff15deb19497}{
\index{AbstractMemory@{AbstractMemory}!isInAddrMap@{isInAddrMap}}
\index{isInAddrMap@{isInAddrMap}!AbstractMemory@{AbstractMemory}}
\subsubsection[{isInAddrMap}]{\setlength{\rightskip}{0pt plus 5cm}bool isInAddrMap () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAbstractMemory_ad89e9980a76342142d63ff15deb19497}
Some memories are used as shadow memories or should for other reasons not be part of the global address map.

\begin{DoxyReturn}{戻り値}
if this memory is part of the address map 
\end{DoxyReturn}



\begin{DoxyCode}
278 { return inAddrMap; }
\end{DoxyCode}
\hypertarget{classAbstractMemory_ac02f2a4d7312eb91f40980adfd4e31b2}{
\index{AbstractMemory@{AbstractMemory}!isNull@{isNull}}
\index{isNull@{isNull}!AbstractMemory@{AbstractMemory}}
\subsubsection[{isNull}]{\setlength{\rightskip}{0pt plus 5cm}bool isNull () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAbstractMemory_ac02f2a4d7312eb91f40980adfd4e31b2}
See if this is a null memory that should never store data and always return zero.

\begin{DoxyReturn}{戻り値}
true if null 
\end{DoxyReturn}



\begin{DoxyCode}
203 { return params()->null; }
\end{DoxyCode}
\hypertarget{classAbstractMemory_a8524c3be63882adac591f591519f3a3b}{
\index{AbstractMemory@{AbstractMemory}!operator=@{operator=}}
\index{operator=@{operator=}!AbstractMemory@{AbstractMemory}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AbstractMemory}\& operator= (const {\bf AbstractMemory} \&)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAbstractMemory_a8524c3be63882adac591f591519f3a3b}
\hypertarget{classAbstractMemory_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{AbstractMemory@{AbstractMemory}!params@{params}}
\index{params@{params}!AbstractMemory@{AbstractMemory}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAbstractMemory_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classMemObject_acd3c3feb78ae7a8f88fe0f110a718dff}{MemObject}を再定義しています。


\begin{DoxyCode}
239     {
240         return dynamic_cast<const Params *>(_params);
241     }
\end{DoxyCode}
\hypertarget{classAbstractMemory_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{AbstractMemory@{AbstractMemory}!regStats@{regStats}}
\index{regStats@{regStats}!AbstractMemory@{AbstractMemory}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classAbstractMemory_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} Statistics 

\hyperlink{classSimObject_a4dc637449366fcdfc4e764cdf12d9b11}{SimObject}を再定義しています。

\hyperlink{classDRAMCtrl_a4dc637449366fcdfc4e764cdf12d9b11}{DRAMCtrl}で再定義されています。


\begin{DoxyCode}
74 {
75     using namespace Stats;
76 
77     assert(system());
78 
79     bytesRead
80         .init(system()->maxMasters())
81         .name(name() + ".bytes_read")
82         .desc("Number of bytes read from this memory")
83         .flags(total | nozero | nonan)
84         ;
85     for (int i = 0; i < system()->maxMasters(); i++) {
86         bytesRead.subname(i, system()->getMasterName(i));
87     }
88     bytesInstRead
89         .init(system()->maxMasters())
90         .name(name() + ".bytes_inst_read")
91         .desc("Number of instructions bytes read from this memory")
92         .flags(total | nozero | nonan)
93         ;
94     for (int i = 0; i < system()->maxMasters(); i++) {
95         bytesInstRead.subname(i, system()->getMasterName(i));
96     }
97     bytesWritten
98         .init(system()->maxMasters())
99         .name(name() + ".bytes_written")
100         .desc("Number of bytes written to this memory")
101         .flags(total | nozero | nonan)
102         ;
103     for (int i = 0; i < system()->maxMasters(); i++) {
104         bytesWritten.subname(i, system()->getMasterName(i));
105     }
106     numReads
107         .init(system()->maxMasters())
108         .name(name() + ".num_reads")
109         .desc("Number of read requests responded to by this memory")
110         .flags(total | nozero | nonan)
111         ;
112     for (int i = 0; i < system()->maxMasters(); i++) {
113         numReads.subname(i, system()->getMasterName(i));
114     }
115     numWrites
116         .init(system()->maxMasters())
117         .name(name() + ".num_writes")
118         .desc("Number of write requests responded to by this memory")
119         .flags(total | nozero | nonan)
120         ;
121     for (int i = 0; i < system()->maxMasters(); i++) {
122         numWrites.subname(i, system()->getMasterName(i));
123     }
124     numOther
125         .init(system()->maxMasters())
126         .name(name() + ".num_other")
127         .desc("Number of other requests responded to by this memory")
128         .flags(total | nozero | nonan)
129         ;
130     for (int i = 0; i < system()->maxMasters(); i++) {
131         numOther.subname(i, system()->getMasterName(i));
132     }
133     bwRead
134         .name(name() + ".bw_read")
135         .desc("Total read bandwidth from this memory (bytes/s)")
136         .precision(0)
137         .prereq(bytesRead)
138         .flags(total | nozero | nonan)
139         ;
140     for (int i = 0; i < system()->maxMasters(); i++) {
141         bwRead.subname(i, system()->getMasterName(i));
142     }
143 
144     bwInstRead
145         .name(name() + ".bw_inst_read")
146         .desc("Instruction read bandwidth from this memory (bytes/s)")
147         .precision(0)
148         .prereq(bytesInstRead)
149         .flags(total | nozero | nonan)
150         ;
151     for (int i = 0; i < system()->maxMasters(); i++) {
152         bwInstRead.subname(i, system()->getMasterName(i));
153     }
154     bwWrite
155         .name(name() + ".bw_write")
156         .desc("Write bandwidth from this memory (bytes/s)")
157         .precision(0)
158         .prereq(bytesWritten)
159         .flags(total | nozero | nonan)
160         ;
161     for (int i = 0; i < system()->maxMasters(); i++) {
162         bwWrite.subname(i, system()->getMasterName(i));
163     }
164     bwTotal
165         .name(name() + ".bw_total")
166         .desc("Total bandwidth to/from this memory (bytes/s)")
167         .precision(0)
168         .prereq(bwTotal)
169         .flags(total | nozero | nonan)
170         ;
171     for (int i = 0; i < system()->maxMasters(); i++) {
172         bwTotal.subname(i, system()->getMasterName(i));
173     }
174     bwRead = bytesRead / simSeconds;
175     bwInstRead = bytesInstRead / simSeconds;
176     bwWrite = bytesWritten / simSeconds;
177     bwTotal = (bytesRead + bytesWritten) / simSeconds;
178 }
\end{DoxyCode}
\hypertarget{classAbstractMemory_a2651a6edea3b7884410b1abefac8b2de}{
\index{AbstractMemory@{AbstractMemory}!setBackingStore@{setBackingStore}}
\index{setBackingStore@{setBackingStore}!AbstractMemory@{AbstractMemory}}
\subsubsection[{setBackingStore}]{\setlength{\rightskip}{0pt plus 5cm}void setBackingStore (uint8\_\-t $\ast$ {\em pmem\_\-addr})}}
\label{classAbstractMemory_a2651a6edea3b7884410b1abefac8b2de}
\hyperlink{classSet}{Set} the host memory backing store to be used by this memory controller.


\begin{DoxyParams}{引数}
\item[{\em pmem\_\-addr}]Pointer to a segment of host memory \end{DoxyParams}



\begin{DoxyCode}
68 {
69     pmemAddr = pmem_addr;
70 }
\end{DoxyCode}
\hypertarget{classAbstractMemory_a0b6868dbef44fc07f11d050eb59e5f7e}{
\index{AbstractMemory@{AbstractMemory}!size@{size}}
\index{size@{size}!AbstractMemory@{AbstractMemory}}
\subsubsection[{size}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t size () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAbstractMemory_a0b6868dbef44fc07f11d050eb59e5f7e}
Get the memory size.

\begin{DoxyReturn}{戻り値}
the size of the memory 
\end{DoxyReturn}



\begin{DoxyCode}
255 { return range.size(); }
\end{DoxyCode}
\hypertarget{classAbstractMemory_a85325674b7aed05d6b4e40a48563189b}{
\index{AbstractMemory@{AbstractMemory}!start@{start}}
\index{start@{start}!AbstractMemory@{AbstractMemory}}
\subsubsection[{start}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} start () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAbstractMemory_a85325674b7aed05d6b4e40a48563189b}
Get the start address.

\begin{DoxyReturn}{戻り値}
the start address of the memory 
\end{DoxyReturn}



\begin{DoxyCode}
262 { return range.start(); }
\end{DoxyCode}
\hypertarget{classAbstractMemory_ad086bdc3ed123ad02169847d658bf5cb}{
\index{AbstractMemory@{AbstractMemory}!system@{system}}
\index{system@{system}!AbstractMemory@{AbstractMemory}}
\subsubsection[{system}]{\setlength{\rightskip}{0pt plus 5cm}void system ({\bf System} $\ast$ {\em sys})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAbstractMemory_ad086bdc3ed123ad02169847d658bf5cb}
\hyperlink{classSet}{Set} the system pointer on this memory This can't be done via a python parameter because the system needs pointers to all the memories and the reverse would create a cycle in the object graph. An \hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} this is set. 
\begin{DoxyParams}{引数}
\item[{\em sys}]system pointer to set \end{DoxyParams}



\begin{DoxyCode}
235 { _system = sys; }
\end{DoxyCode}
\hypertarget{classAbstractMemory_a83984c42bc765168929779ed9a37ebe8}{
\index{AbstractMemory@{AbstractMemory}!system@{system}}
\index{system@{system}!AbstractMemory@{AbstractMemory}}
\subsubsection[{system}]{\setlength{\rightskip}{0pt plus 5cm}{\bf System}$\ast$ system () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAbstractMemory_a83984c42bc765168929779ed9a37ebe8}
read the system pointer Implemented for completeness with the setter \begin{DoxyReturn}{戻り値}
pointer to the system object 
\end{DoxyReturn}



\begin{DoxyCode}
227 { return _system; }
\end{DoxyCode}
\hypertarget{classAbstractMemory_ad317aec11d97a72993e653755fa1c003}{
\index{AbstractMemory@{AbstractMemory}!trackLoadLocked@{trackLoadLocked}}
\index{trackLoadLocked@{trackLoadLocked}!AbstractMemory@{AbstractMemory}}
\subsubsection[{trackLoadLocked}]{\setlength{\rightskip}{0pt plus 5cm}void trackLoadLocked ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractMemory_ad317aec11d97a72993e653755fa1c003}



\begin{DoxyCode}
190 {
191     Request *req = pkt->req;
192     Addr paddr = LockedAddr::mask(req->getPaddr());
193 
194     // first we check if we already have a locked addr for this
195     // xc.  Since each xc only gets one, we just update the
196     // existing record with the new address.
197     list<LockedAddr>::iterator i;
198 
199     for (i = lockedAddrList.begin(); i != lockedAddrList.end(); ++i) {
200         if (i->matchesContext(req)) {
201             DPRINTF(LLSC, "Modifying lock record: context %d addr %#x\n",
202                     req->contextId(), paddr);
203             i->addr = paddr;
204             return;
205         }
206     }
207 
208     // no record for this xc: need to allocate a new one
209     DPRINTF(LLSC, "Adding lock record: context %d addr %#x\n",
210             req->contextId(), paddr);
211     lockedAddrList.push_front(LockedAddr(req));
212 }
\end{DoxyCode}
\hypertarget{classAbstractMemory_ab1136219a28374092ad398d673bd23e0}{
\index{AbstractMemory@{AbstractMemory}!writeOK@{writeOK}}
\index{writeOK@{writeOK}!AbstractMemory@{AbstractMemory}}
\subsubsection[{writeOK}]{\setlength{\rightskip}{0pt plus 5cm}bool writeOK ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classAbstractMemory_ab1136219a28374092ad398d673bd23e0}



\begin{DoxyCode}
139                                 {
140         Request *req = pkt->req;
141         if (lockedAddrList.empty()) {
142             // no locked addrs: nothing to check, store_conditional fails
143             bool isLLSC = pkt->isLLSC();
144             if (isLLSC) {
145                 req->setExtraData(0);
146             }
147             return !isLLSC; // only do write if not an sc
148         } else {
149             // iterate over list...
150             return checkLockedAddrList(pkt);
151         }
152     }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classAbstractMemory_a1da55f4024bf8a9b14b64054841148b8}{
\index{AbstractMemory@{AbstractMemory}!\_\-system@{\_\-system}}
\index{\_\-system@{\_\-system}!AbstractMemory@{AbstractMemory}}
\subsubsection[{\_\-system}]{\setlength{\rightskip}{0pt plus 5cm}{\bf System}$\ast$ {\bf \_\-system}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractMemory_a1da55f4024bf8a9b14b64054841148b8}
Pointor to the \hyperlink{classSystem}{System} object. This is used for getting the number of masters in the system which is needed when registering stats \hypertarget{classAbstractMemory_a00512ebb77886b71a63bd1595828d592}{
\index{AbstractMemory@{AbstractMemory}!bwInstRead@{bwInstRead}}
\index{bwInstRead@{bwInstRead}!AbstractMemory@{AbstractMemory}}
\subsubsection[{bwInstRead}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf bwInstRead}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractMemory_a00512ebb77886b71a63bd1595828d592}
Read bandwidth from this memory \hypertarget{classAbstractMemory_a14a0a95f3cd104b70d5b5c19c3ee8099}{
\index{AbstractMemory@{AbstractMemory}!bwRead@{bwRead}}
\index{bwRead@{bwRead}!AbstractMemory@{AbstractMemory}}
\subsubsection[{bwRead}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf bwRead}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractMemory_a14a0a95f3cd104b70d5b5c19c3ee8099}
Read bandwidth from this memory \hypertarget{classAbstractMemory_a678ff8c93c78d0be1884742ef8aa41e8}{
\index{AbstractMemory@{AbstractMemory}!bwTotal@{bwTotal}}
\index{bwTotal@{bwTotal}!AbstractMemory@{AbstractMemory}}
\subsubsection[{bwTotal}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf bwTotal}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractMemory_a678ff8c93c78d0be1884742ef8aa41e8}
Total bandwidth from this memory \hypertarget{classAbstractMemory_a8077d31db9c4f4f9e78888def6de8430}{
\index{AbstractMemory@{AbstractMemory}!bwWrite@{bwWrite}}
\index{bwWrite@{bwWrite}!AbstractMemory@{AbstractMemory}}
\subsubsection[{bwWrite}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf bwWrite}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractMemory_a8077d31db9c4f4f9e78888def6de8430}
Write bandwidth from this memory \hypertarget{classAbstractMemory_a5e52eb4a824c1fb452d77dae86dfa970}{
\index{AbstractMemory@{AbstractMemory}!bytesInstRead@{bytesInstRead}}
\index{bytesInstRead@{bytesInstRead}!AbstractMemory@{AbstractMemory}}
\subsubsection[{bytesInstRead}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf bytesInstRead}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractMemory_a5e52eb4a824c1fb452d77dae86dfa970}
Number of instruction bytes read from this memory \hypertarget{classAbstractMemory_aa36971a2ea8ddd9d82832059cbc1b21f}{
\index{AbstractMemory@{AbstractMemory}!bytesRead@{bytesRead}}
\index{bytesRead@{bytesRead}!AbstractMemory@{AbstractMemory}}
\subsubsection[{bytesRead}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf bytesRead}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractMemory_aa36971a2ea8ddd9d82832059cbc1b21f}
Number of total bytes read from this memory \hypertarget{classAbstractMemory_ab89ec4a4876671ad5186d0e9c0e674ed}{
\index{AbstractMemory@{AbstractMemory}!bytesWritten@{bytesWritten}}
\index{bytesWritten@{bytesWritten}!AbstractMemory@{AbstractMemory}}
\subsubsection[{bytesWritten}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf bytesWritten}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractMemory_ab89ec4a4876671ad5186d0e9c0e674ed}
Number of bytes written to this memory 

\hyperlink{classDRAMCtrl_a98c4533d0a7053d00f6882f984ebdaef}{DRAMCtrl}で再定義されています。\hypertarget{classAbstractMemory_adee792d6bf567779ea9c16640af42784}{
\index{AbstractMemory@{AbstractMemory}!confTableReported@{confTableReported}}
\index{confTableReported@{confTableReported}!AbstractMemory@{AbstractMemory}}
\subsubsection[{confTableReported}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf confTableReported}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractMemory_adee792d6bf567779ea9c16640af42784}
\hypertarget{classAbstractMemory_a7302c053380cdccd0bdf63b25f73cbc5}{
\index{AbstractMemory@{AbstractMemory}!inAddrMap@{inAddrMap}}
\index{inAddrMap@{inAddrMap}!AbstractMemory@{AbstractMemory}}
\subsubsection[{inAddrMap}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf inAddrMap}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractMemory_a7302c053380cdccd0bdf63b25f73cbc5}
\hypertarget{classAbstractMemory_af35631da2ae35079d76e07c46fe78565}{
\index{AbstractMemory@{AbstractMemory}!lockedAddrList@{lockedAddrList}}
\index{lockedAddrList@{lockedAddrList}!AbstractMemory@{AbstractMemory}}
\subsubsection[{lockedAddrList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf LockedAddr}$>$ {\bf lockedAddrList}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractMemory_af35631da2ae35079d76e07c46fe78565}
\hypertarget{classAbstractMemory_a52bafd014022e75d82b4e0de25d3faf7}{
\index{AbstractMemory@{AbstractMemory}!numOther@{numOther}}
\index{numOther@{numOther}!AbstractMemory@{AbstractMemory}}
\subsubsection[{numOther}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf numOther}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractMemory_a52bafd014022e75d82b4e0de25d3faf7}
Number of other requests \hypertarget{classAbstractMemory_a27f442fbcb7bc7661412cc1d96ca51e7}{
\index{AbstractMemory@{AbstractMemory}!numReads@{numReads}}
\index{numReads@{numReads}!AbstractMemory@{AbstractMemory}}
\subsubsection[{numReads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf numReads}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractMemory_a27f442fbcb7bc7661412cc1d96ca51e7}
Number of read requests \hypertarget{classAbstractMemory_acfd6a97aa6c2de05417a7403369e71c2}{
\index{AbstractMemory@{AbstractMemory}!numWrites@{numWrites}}
\index{numWrites@{numWrites}!AbstractMemory@{AbstractMemory}}
\subsubsection[{numWrites}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf numWrites}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractMemory_acfd6a97aa6c2de05417a7403369e71c2}
Number of write requests \hypertarget{classAbstractMemory_a9f8ed24d8442f662831d51922e7fddd2}{
\index{AbstractMemory@{AbstractMemory}!pmemAddr@{pmemAddr}}
\index{pmemAddr@{pmemAddr}!AbstractMemory@{AbstractMemory}}
\subsubsection[{pmemAddr}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t$\ast$ {\bf pmemAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractMemory_a9f8ed24d8442f662831d51922e7fddd2}
\hypertarget{classAbstractMemory_a194876a072a83a9fd59dde82e5213f0d}{
\index{AbstractMemory@{AbstractMemory}!range@{range}}
\index{range@{range}!AbstractMemory@{AbstractMemory}}
\subsubsection[{range}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRange} {\bf range}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAbstractMemory_a194876a072a83a9fd59dde82e5213f0d}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{abstract__mem_8hh}{abstract\_\-mem.hh}\item 
mem/\hyperlink{abstract__mem_8cc}{abstract\_\-mem.cc}\end{DoxyCompactItemize}
