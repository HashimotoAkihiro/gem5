\hypertarget{classSet}{
\section{クラス Set}
\label{classSet}\index{Set@{Set}}
}


{\ttfamily \#include $<$Set.hh$>$}\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSet_ad2293f668ddb9a9fc99f78a737f6e86e}{Set} ()
\item 
\hyperlink{classSet_a4002084bb3b696e4d7208803d6778140}{Set} (int size)
\item 
\hyperlink{classSet_a730402671835f0f3385ca4d591f03bbe}{Set} (const \hyperlink{classSet}{Set} \&obj)
\item 
\hyperlink{classSet_a64c23991280aa719d76b8995d530115f}{$\sim$Set} ()
\item 
\hyperlink{classSet}{Set} \& \hyperlink{classSet_a274b72d7f852e6eb0e416c1d2e00c1ee}{operator=} (const \hyperlink{classSet}{Set} \&obj)
\item 
void \hyperlink{classSet_a9d3c0a08ea232cfc4e207b1bc39d43c9}{add} (\hyperlink{TypeDefines_8hh_a83c14b4ae37e80071f6b3506a6c46151}{NodeID} index)
\item 
void \hyperlink{classSet_a0412c72301eb345aceb1b0c2c38dd26a}{addSet} (const \hyperlink{classSet}{Set} \&set)
\item 
void \hyperlink{classSet_abd48774eca8e19eb2371c41bdf73c93c}{addRandom} ()
\item 
void \hyperlink{classSet_a1c1436bbfbdadb662db0fa20bfd8cc8b}{remove} (\hyperlink{TypeDefines_8hh_a83c14b4ae37e80071f6b3506a6c46151}{NodeID} index)
\item 
void \hyperlink{classSet_ab66a463aa908331ff43ccb847213b07c}{removeSet} (const \hyperlink{classSet}{Set} \&set)
\item 
void \hyperlink{classSet_ac8bb3912a3ce86b15842e79d0b421204}{clear} ()
\item 
void \hyperlink{classSet_a299d89c50484c4d3a597f6b43b65e21c}{broadcast} ()
\item 
int \hyperlink{classSet_a0745638c9967e2ed90bc96c012288c55}{count} () const 
\item 
bool \hyperlink{classSet_ad6a92fc7477f163a8730441d3597f5e1}{isEqual} (const \hyperlink{classSet}{Set} \&set) const 
\item 
\hyperlink{classSet}{Set} \hyperlink{classSet_aaba9e97960a8c78f28a2fe8f28e5b37a}{OR} (const \hyperlink{classSet}{Set} \&orSet) const 
\item 
\hyperlink{classSet}{Set} \hyperlink{classSet_a090263cd0c6181f2cb60641253dd6413}{AND} (const \hyperlink{classSet}{Set} \&andSet) const 
\item 
bool \hyperlink{classSet_a6746cdf4bc4e7e90ce81d368ac57c125}{intersectionIsEmpty} (const \hyperlink{classSet}{Set} \&other\_\-set) const 
\item 
bool \hyperlink{classSet_afa8a7c09df1409cc3cbf2c0a8a9758c9}{isSuperset} (const \hyperlink{classSet}{Set} \&test) const 
\item 
bool \hyperlink{classSet_a103a25450363d9ffaf73f74e3690be62}{isSubset} (const \hyperlink{classSet}{Set} \&test) const 
\item 
bool \hyperlink{classSet_a86a028497c9a1969149e86b34685ae2d}{isElement} (\hyperlink{TypeDefines_8hh_a83c14b4ae37e80071f6b3506a6c46151}{NodeID} element) const 
\item 
bool \hyperlink{classSet_ad6e06804cf170a9f5925776696c32060}{isBroadcast} () const 
\item 
bool \hyperlink{classSet_a479432127ee77145cc19d6a2d1590821}{isEmpty} () const 
\item 
\hyperlink{TypeDefines_8hh_a83c14b4ae37e80071f6b3506a6c46151}{NodeID} \hyperlink{classSet_a0df0ef450758d1afd49a460353d702da}{smallestElement} () const 
\item 
void \hyperlink{classSet_a72020e2e3721c814d7a5ff1dac539484}{setSize} (int size)
\item 
\hyperlink{TypeDefines_8hh_a83c14b4ae37e80071f6b3506a6c46151}{NodeID} \hyperlink{classSet_ace4040d47fd875f3fac8516a49d5b416}{elementAt} (int index) const 
\item 
int \hyperlink{classSet_a4f8dbb76319fe40792867d6ca51ef447}{getSize} () const 
\item 
void \hyperlink{classSet_ac55fe386a101fbae38c716067c9966a0}{print} (std::ostream \&out) const 
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classSet_aa7e5ecedaad0a7d835a819cb8f568f4a}{clearExcess} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classSet_a596ca3ad7845fc90a3bc5b0b39f8a439}{m\_\-nSize}
\item 
int \hyperlink{classSet_a195377de8b2a14cb8858ab158a80b916}{m\_\-nArrayLen}
\item 
long $\ast$ \hyperlink{classSet_a92c58ed80e0e7dade7838d3d300cc4cf}{m\_\-p\_\-nArray}
\item 
long \hyperlink{classSet_a3fef4acb279bdd97b96c6da7b042cc1e}{m\_\-p\_\-nArray\_\-Static} \mbox{[}\hyperlink{Set_8hh_aeafee2fb41f8658683a0f674ac339e3d}{NUMBER\_\-WORDS\_\-PER\_\-SET}\mbox{]}
\end{DoxyCompactItemize}
\subsection*{Static Private 変数}
\begin{DoxyCompactItemize}
\item 
static const int \hyperlink{classSet_a255499bfd2e55c748b3b35f4c0715e07}{LONG\_\-BITS} = std::numeric\_\-limits$<$long$>$::digits + 1
\item 
static const int \hyperlink{classSet_a33af0963dbe2fdf9ce5b7303c924b673}{INDEX\_\-SHIFT} = \hyperlink{classSet_a255499bfd2e55c748b3b35f4c0715e07}{LONG\_\-BITS} == 64 ? 6 : 5
\item 
static const int \hyperlink{classSet_af544f28f2a0f3d2222314eb4dbcba4e8}{INDEX\_\-MASK} = (1 $<$$<$ \hyperlink{classSet_a33af0963dbe2fdf9ce5b7303c924b673}{INDEX\_\-SHIFT}) -\/ 1
\end{DoxyCompactItemize}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classSet_ad2293f668ddb9a9fc99f78a737f6e86e}{
\index{Set@{Set}!Set@{Set}}
\index{Set@{Set}!Set@{Set}}
\subsubsection[{Set}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Set} ()}}
\label{classSet_ad2293f668ddb9a9fc99f78a737f6e86e}



\begin{DoxyCode}
39 {
40     m_p_nArray = NULL;
41     m_nArrayLen = 0;
42     m_nSize = 0;
43 }
\end{DoxyCode}
\hypertarget{classSet_a4002084bb3b696e4d7208803d6778140}{
\index{Set@{Set}!Set@{Set}}
\index{Set@{Set}!Set@{Set}}
\subsubsection[{Set}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Set} (int {\em size})}}
\label{classSet_a4002084bb3b696e4d7208803d6778140}



\begin{DoxyCode}
56 {
57     m_p_nArray = NULL;
58     m_nArrayLen = 0;
59     m_nSize = 0;
60     if (size > 0)
61         setSize(size);
62 }
\end{DoxyCode}
\hypertarget{classSet_a730402671835f0f3385ca4d591f03bbe}{
\index{Set@{Set}!Set@{Set}}
\index{Set@{Set}!Set@{Set}}
\subsubsection[{Set}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Set} (const {\bf Set} \& {\em obj})}}
\label{classSet_a730402671835f0f3385ca4d591f03bbe}



\begin{DoxyCode}
46 {
47     m_p_nArray = NULL;
48     setSize(obj.m_nSize);
49 
50     // copy from the host to this array
51     for (int i = 0; i < m_nArrayLen; i++)
52         m_p_nArray[i] = obj.m_p_nArray[i];
53 }
\end{DoxyCode}
\hypertarget{classSet_a64c23991280aa719d76b8995d530115f}{
\index{Set@{Set}!$\sim$Set@{$\sim$Set}}
\index{$\sim$Set@{$\sim$Set}!Set@{Set}}
\subsubsection[{$\sim$Set}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf Set} ()}}
\label{classSet_a64c23991280aa719d76b8995d530115f}



\begin{DoxyCode}
65 {
66     if (m_p_nArray && m_p_nArray != &m_p_nArray_Static[0])
67         delete [] m_p_nArray;
68     m_p_nArray = NULL;
69 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classSet_a9d3c0a08ea232cfc4e207b1bc39d43c9}{
\index{Set@{Set}!add@{add}}
\index{add@{add}!Set@{Set}}
\subsubsection[{add}]{\setlength{\rightskip}{0pt plus 5cm}void add ({\bf NodeID} {\em index})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSet_a9d3c0a08ea232cfc4e207b1bc39d43c9}



\begin{DoxyCode}
84     {
85         m_p_nArray[index >> INDEX_SHIFT] |=
86             (((unsigned long) 1) << (index & INDEX_MASK));
87     }
\end{DoxyCode}
\hypertarget{classSet_abd48774eca8e19eb2371c41bdf73c93c}{
\index{Set@{Set}!addRandom@{addRandom}}
\index{addRandom@{addRandom}!Set@{Set}}
\subsubsection[{addRandom}]{\setlength{\rightskip}{0pt plus 5cm}void addRandom ()}}
\label{classSet_abd48774eca8e19eb2371c41bdf73c93c}



\begin{DoxyCode}
111 {
112 
113     for (int i = 0; i < m_nArrayLen; i++) {
114         // this ensures that all 32 bits are subject to random effects,
115         // as RAND_MAX typically = 0x7FFFFFFF
116         m_p_nArray[i] |= random() ^ (random() << 4);
117     }
118     clearExcess();
119 }
\end{DoxyCode}
\hypertarget{classSet_a0412c72301eb345aceb1b0c2c38dd26a}{
\index{Set@{Set}!addSet@{addSet}}
\index{addSet@{addSet}!Set@{Set}}
\subsubsection[{addSet}]{\setlength{\rightskip}{0pt plus 5cm}void addSet (const {\bf Set} \& {\em set})}}
\label{classSet_a0412c72301eb345aceb1b0c2c38dd26a}



\begin{DoxyCode}
99 {
100     assert(getSize()==set.getSize());
101     for (int i = 0; i < m_nArrayLen; i++)
102         m_p_nArray[i] |= set.m_p_nArray[i];
103 }
\end{DoxyCode}
\hypertarget{classSet_a090263cd0c6181f2cb60641253dd6413}{
\index{Set@{Set}!AND@{AND}}
\index{AND@{AND}!Set@{Set}}
\subsubsection[{AND}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Set} AND (const {\bf Set} \& {\em andSet}) const}}
\label{classSet_a090263cd0c6181f2cb60641253dd6413}



\begin{DoxyCode}
272 {
273     Set result(m_nSize);
274     assert(m_nSize == andSet.m_nSize);
275 
276     for (int i = 0; i < m_nArrayLen; i++) {
277         result.m_p_nArray[i] = m_p_nArray[i] & andSet.m_p_nArray[i];
278     }
279 
280     return result;
281 }
\end{DoxyCode}
\hypertarget{classSet_a299d89c50484c4d3a597f6b43b65e21c}{
\index{Set@{Set}!broadcast@{broadcast}}
\index{broadcast@{broadcast}!Set@{Set}}
\subsubsection[{broadcast}]{\setlength{\rightskip}{0pt plus 5cm}void broadcast ()}}
\label{classSet_a299d89c50484c4d3a597f6b43b65e21c}



\begin{DoxyCode}
137 {
138     for (int i = 0; i < m_nArrayLen; i++)
139         m_p_nArray[i] = -1; // note that -1 corresponds to all 1's in 2's comp.
140 
141     clearExcess();
142 }
\end{DoxyCode}
\hypertarget{classSet_ac8bb3912a3ce86b15842e79d0b421204}{
\index{Set@{Set}!clear@{clear}}
\index{clear@{clear}!Set@{Set}}
\subsubsection[{clear}]{\setlength{\rightskip}{0pt plus 5cm}void clear ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSet_ac8bb3912a3ce86b15842e79d0b421204}



\begin{DoxyCode}
103     {
104         for (int i = 0; i < m_nArrayLen; i++)
105             m_p_nArray[i] = 0;
106     }
\end{DoxyCode}
\hypertarget{classSet_aa7e5ecedaad0a7d835a819cb8f568f4a}{
\index{Set@{Set}!clearExcess@{clearExcess}}
\index{clearExcess@{clearExcess}!Set@{Set}}
\subsubsection[{clearExcess}]{\setlength{\rightskip}{0pt plus 5cm}void clearExcess ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSet_aa7e5ecedaad0a7d835a819cb8f568f4a}



\begin{DoxyCode}
73 {
74     // now just ensure that no bits over the maximum size were set
75 #ifdef _LP64
76     long mask = 0x7FFFFFFFFFFFFFFF;
77 #else
78     long mask = 0x7FFFFFFF;
79 #endif
80 
81     // the number of populated spaces in the higest-order array slot
82     // is: m_nSize % LONG_BITS, so the uppermost LONG_BITS -
83     // m_nSize%64 bits should be cleared
84     if ((m_nSize % LONG_BITS) != 0) {
85         for (int j = 0; j < 64 - (m_nSize & INDEX_MASK); j++) {
86             m_p_nArray[m_nArrayLen - 1] &= mask;
87             mask = mask >> 1;
88         }
89     }
90 }
\end{DoxyCode}
\hypertarget{classSet_a0745638c9967e2ed90bc96c012288c55}{
\index{Set@{Set}!count@{count}}
\index{count@{count}!Set@{Set}}
\subsubsection[{count}]{\setlength{\rightskip}{0pt plus 5cm}int count () const}}
\label{classSet_a0745638c9967e2ed90bc96c012288c55}



\begin{DoxyCode}
149 {
150     int counter = 0;
151     long mask;
152 
153     for (int i = 0; i < m_nArrayLen; i++) {
154         mask = (long)0x01;
155 
156         for (int j = 0; j < LONG_BITS; j++) {
157             // FIXME - significant performance loss when array
158             // population << LONG_BITS
159             if ((m_p_nArray[i] & mask) != 0) {
160                 counter++;
161             }
162             mask = mask << 1;
163         }
164     }
165 
166     return counter;
167 }
\end{DoxyCode}
\hypertarget{classSet_ace4040d47fd875f3fac8516a49d5b416}{
\index{Set@{Set}!elementAt@{elementAt}}
\index{elementAt@{elementAt}!Set@{Set}}
\subsubsection[{elementAt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf NodeID} elementAt (int {\em index}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSet_ace4040d47fd875f3fac8516a49d5b416}



\begin{DoxyCode}
147     {
148         if (isElement(index))
149             return (NodeID)true;
150         else
151             return 0;
152     }
\end{DoxyCode}
\hypertarget{classSet_a4f8dbb76319fe40792867d6ca51ef447}{
\index{Set@{Set}!getSize@{getSize}}
\index{getSize@{getSize}!Set@{Set}}
\subsubsection[{getSize}]{\setlength{\rightskip}{0pt plus 5cm}int getSize () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSet_a4f8dbb76319fe40792867d6ca51ef447}



\begin{DoxyCode}
154 { return m_nSize; }
\end{DoxyCode}
\hypertarget{classSet_a6746cdf4bc4e7e90ce81d368ac57c125}{
\index{Set@{Set}!intersectionIsEmpty@{intersectionIsEmpty}}
\index{intersectionIsEmpty@{intersectionIsEmpty}!Set@{Set}}
\subsubsection[{intersectionIsEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool intersectionIsEmpty (const {\bf Set} \& {\em other\_\-set}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSet_a6746cdf4bc4e7e90ce81d368ac57c125}



\begin{DoxyCode}
121     {
122         for (int i = 0; i < m_nArrayLen; i++)
123             if (m_p_nArray[i] & other_set.m_p_nArray[i])
124                 return false;
125         return true;
126     }
\end{DoxyCode}
\hypertarget{classSet_ad6e06804cf170a9f5925776696c32060}{
\index{Set@{Set}!isBroadcast@{isBroadcast}}
\index{isBroadcast@{isBroadcast}!Set@{Set}}
\subsubsection[{isBroadcast}]{\setlength{\rightskip}{0pt plus 5cm}bool isBroadcast () const}}
\label{classSet_ad6e06804cf170a9f5925776696c32060}



\begin{DoxyCode}
217 {
218     // check the fully-loaded words by equal to 0xffffffff
219     // only the last word may not be fully loaded, it is not
220     // fully loaded iff m_nSize % 32 or 64 !=0 => fully loaded iff
221     // m_nSize % 32 or 64 == 0
222 
223     int max = (m_nSize % LONG_BITS) == 0 ? m_nArrayLen : m_nArrayLen - 1;
224     for (int i = 0; i < max; i++) {
225         if (m_p_nArray[i] != -1) {
226             return false;
227         }
228     }
229 
230     // now check the last word, which may not be fully loaded
231     long mask = 1;
232     for (int j = 0; j < (m_nSize % LONG_BITS); j++) {
233         if ((mask & m_p_nArray[m_nArrayLen-1]) == 0) {
234             return false;
235         }
236         mask = mask << 1;
237     }
238 
239     return true;
240 }
\end{DoxyCode}
\hypertarget{classSet_a86a028497c9a1969149e86b34685ae2d}{
\index{Set@{Set}!isElement@{isElement}}
\index{isElement@{isElement}!Set@{Set}}
\subsubsection[{isElement}]{\setlength{\rightskip}{0pt plus 5cm}bool isElement ({\bf NodeID} {\em element}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSet_a86a028497c9a1969149e86b34685ae2d}



\begin{DoxyCode}
133     {
134         return (m_p_nArray[element>>INDEX_SHIFT] &
135             (((unsigned long)1) << (element & INDEX_MASK))) != 0;
136     }
\end{DoxyCode}
\hypertarget{classSet_a479432127ee77145cc19d6a2d1590821}{
\index{Set@{Set}!isEmpty@{isEmpty}}
\index{isEmpty@{isEmpty}!Set@{Set}}
\subsubsection[{isEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool isEmpty () const}}
\label{classSet_a479432127ee77145cc19d6a2d1590821}



\begin{DoxyCode}
247 {
248     // here we can simply check if all = 0, since we ensure
249     // that "extra slots" are all zero
250     for (int i = 0; i < m_nArrayLen ; i++)
251         if (m_p_nArray[i])
252             return false;
253 
254     return true;
255 }
\end{DoxyCode}
\hypertarget{classSet_ad6a92fc7477f163a8730441d3597f5e1}{
\index{Set@{Set}!isEqual@{isEqual}}
\index{isEqual@{isEqual}!Set@{Set}}
\subsubsection[{isEqual}]{\setlength{\rightskip}{0pt plus 5cm}bool isEqual (const {\bf Set} \& {\em set}) const}}
\label{classSet_ad6a92fc7477f163a8730441d3597f5e1}



\begin{DoxyCode}
174 {
175     assert(m_nSize == set.m_nSize);
176 
177     for (int i = 0; i < m_nArrayLen; i++)
178         if (m_p_nArray[i] != set.m_p_nArray[i])
179             return false;
180 
181     return true;
182 }
\end{DoxyCode}
\hypertarget{classSet_a103a25450363d9ffaf73f74e3690be62}{
\index{Set@{Set}!isSubset@{isSubset}}
\index{isSubset@{isSubset}!Set@{Set}}
\subsubsection[{isSubset}]{\setlength{\rightskip}{0pt plus 5cm}bool isSubset (const {\bf Set} \& {\em test}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSet_a103a25450363d9ffaf73f74e3690be62}



\begin{DoxyCode}
129 { return test.isSuperset(*this); }
\end{DoxyCode}
\hypertarget{classSet_afa8a7c09df1409cc3cbf2c0a8a9758c9}{
\index{Set@{Set}!isSuperset@{isSuperset}}
\index{isSuperset@{isSuperset}!Set@{Set}}
\subsubsection[{isSuperset}]{\setlength{\rightskip}{0pt plus 5cm}bool isSuperset (const {\bf Set} \& {\em test}) const}}
\label{classSet_afa8a7c09df1409cc3cbf2c0a8a9758c9}



\begin{DoxyCode}
289 {
290     assert(m_nSize == test.m_nSize);
291 
292     for (int i = 0; i < m_nArrayLen; i++)
293         if (((test.m_p_nArray[i] & m_p_nArray[i]) | ~test.m_p_nArray[i]) != -1)
294             return false;
295 
296     return true;
297 }
\end{DoxyCode}
\hypertarget{classSet_a274b72d7f852e6eb0e416c1d2e00c1ee}{
\index{Set@{Set}!operator=@{operator=}}
\index{operator=@{operator=}!Set@{Set}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Set} \& operator= (const {\bf Set} \& {\em obj})}}
\label{classSet_a274b72d7f852e6eb0e416c1d2e00c1ee}



\begin{DoxyCode}
333 {
334     if (this != &obj) {
335         // resize this item
336         setSize(obj.getSize());
337 
338         // copy the elements from obj to this
339         for (int i = 0; i < m_nArrayLen; i++)
340             m_p_nArray[i] = obj.m_p_nArray[i];
341     }
342 
343     return *this;
344 }
\end{DoxyCode}
\hypertarget{classSet_aaba9e97960a8c78f28a2fe8f28e5b37a}{
\index{Set@{Set}!OR@{OR}}
\index{OR@{OR}!Set@{Set}}
\subsubsection[{OR}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Set} OR (const {\bf Set} \& {\em orSet}) const}}
\label{classSet_aaba9e97960a8c78f28a2fe8f28e5b37a}



\begin{DoxyCode}
260 {
261     Set result(m_nSize);
262     assert(m_nSize == orSet.m_nSize);
263     for (int i = 0; i < m_nArrayLen; i++)
264         result.m_p_nArray[i] = m_p_nArray[i] | orSet.m_p_nArray[i];
265 
266     return result;
267 }
\end{DoxyCode}
\hypertarget{classSet_ac55fe386a101fbae38c716067c9966a0}{
\index{Set@{Set}!print@{print}}
\index{print@{print}!Set@{Set}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}void print (std::ostream \& {\em out}) const}}
\label{classSet_ac55fe386a101fbae38c716067c9966a0}



\begin{DoxyCode}
348 {
349     if (!m_p_nArray) {
350         out << "[Set {Empty}]";
351         return;
352     }
353 
354     out << "[Set (" << m_nSize << ")";
355     for (int i = m_nArrayLen - 1; i >= 0; i--) {
356         out << csprintf(" 0x%08X", m_p_nArray[i]);
357     }
358     out << " ]";
359 }
\end{DoxyCode}
\hypertarget{classSet_a1c1436bbfbdadb662db0fa20bfd8cc8b}{
\index{Set@{Set}!remove@{remove}}
\index{remove@{remove}!Set@{Set}}
\subsubsection[{remove}]{\setlength{\rightskip}{0pt plus 5cm}void remove ({\bf NodeID} {\em index})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSet_a1c1436bbfbdadb662db0fa20bfd8cc8b}



\begin{DoxyCode}
94     {
95         m_p_nArray[index >> INDEX_SHIFT] &=
96             ~(((unsigned long)1) << (index & INDEX_MASK));
97     }
\end{DoxyCode}
\hypertarget{classSet_ab66a463aa908331ff43ccb847213b07c}{
\index{Set@{Set}!removeSet@{removeSet}}
\index{removeSet@{removeSet}!Set@{Set}}
\subsubsection[{removeSet}]{\setlength{\rightskip}{0pt plus 5cm}void removeSet (const {\bf Set} \& {\em set})}}
\label{classSet_ab66a463aa908331ff43ccb847213b07c}



\begin{DoxyCode}
126 {
127     assert(m_nSize == set.m_nSize);
128     for (int i = 0; i < m_nArrayLen; i++)
129         m_p_nArray[i] &= ~set.m_p_nArray[i];
130 }
\end{DoxyCode}
\hypertarget{classSet_a72020e2e3721c814d7a5ff1dac539484}{
\index{Set@{Set}!setSize@{setSize}}
\index{setSize@{setSize}!Set@{Set}}
\subsubsection[{setSize}]{\setlength{\rightskip}{0pt plus 5cm}void setSize (int {\em size})}}
\label{classSet_a72020e2e3721c814d7a5ff1dac539484}



\begin{DoxyCode}
301 {
302     m_nSize = size;
303     m_nArrayLen = (m_nSize + LONG_BITS - 1) / LONG_BITS;
304 
305     // decide whether to use dynamic or static alloction
306     if (m_nArrayLen <= NUMBER_WORDS_PER_SET) {
307         // constant defined in RubySystem.hh
308         // its OK to use the static allocation, and it will
309         // probably be faster (as m_nArrayLen is already in the
310         // cache and they will probably share the same cache line)
311 
312         // if switching from dyanamic to static allocation (which
313         // is probably rare, but why not be complete?), must delete
314         // the dynamically allocated space
315         if (m_p_nArray && m_p_nArray != &m_p_nArray_Static[0])
316             delete [] m_p_nArray;
317 
318         m_p_nArray = &m_p_nArray_Static[0];
319     } else {
320         // can't use static allocation...simply not enough room
321         // so dynamically allocate some space
322         if (m_p_nArray && m_p_nArray != &m_p_nArray_Static[0])
323             delete [] m_p_nArray;
324 
325         m_p_nArray = new long[m_nArrayLen];
326     }
327 
328     clear();
329 }
\end{DoxyCode}
\hypertarget{classSet_a0df0ef450758d1afd49a460353d702da}{
\index{Set@{Set}!smallestElement@{smallestElement}}
\index{smallestElement@{smallestElement}!Set@{Set}}
\subsubsection[{smallestElement}]{\setlength{\rightskip}{0pt plus 5cm}{\bf NodeID} smallestElement () const}}
\label{classSet_a0df0ef450758d1afd49a460353d702da}



\begin{DoxyCode}
189 {
190     assert(count() > 0);
191     long x;
192     for (int i = 0; i < m_nArrayLen; i++) {
193         if (m_p_nArray[i] != 0) {
194             // the least-set bit must be in here
195             x = m_p_nArray[i];
196 
197             for (int j = 0; j < LONG_BITS; j++) {
198                 if (x & (unsigned long)1) {
199                     return LONG_BITS * i + j;
200                 }
201 
202                 x = x >> 1;
203             }
204 
205             panic("No smallest element of an empty set.");
206         }
207     }
208 
209     panic("No smallest element of an empty set.");
210 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classSet_af544f28f2a0f3d2222314eb4dbcba4e8}{
\index{Set@{Set}!INDEX\_\-MASK@{INDEX\_\-MASK}}
\index{INDEX\_\-MASK@{INDEX\_\-MASK}!Set@{Set}}
\subsubsection[{INDEX\_\-MASK}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf INDEX\_\-MASK} = (1 $<$$<$ {\bf INDEX\_\-SHIFT}) -\/ 1\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classSet_af544f28f2a0f3d2222314eb4dbcba4e8}
\hypertarget{classSet_a33af0963dbe2fdf9ce5b7303c924b673}{
\index{Set@{Set}!INDEX\_\-SHIFT@{INDEX\_\-SHIFT}}
\index{INDEX\_\-SHIFT@{INDEX\_\-SHIFT}!Set@{Set}}
\subsubsection[{INDEX\_\-SHIFT}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf INDEX\_\-SHIFT} = {\bf LONG\_\-BITS} == 64 ? 6 : 5\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classSet_a33af0963dbe2fdf9ce5b7303c924b673}
\hypertarget{classSet_a255499bfd2e55c748b3b35f4c0715e07}{
\index{Set@{Set}!LONG\_\-BITS@{LONG\_\-BITS}}
\index{LONG\_\-BITS@{LONG\_\-BITS}!Set@{Set}}
\subsubsection[{LONG\_\-BITS}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf LONG\_\-BITS} = std::numeric\_\-limits$<$long$>$::digits + 1\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classSet_a255499bfd2e55c748b3b35f4c0715e07}
\hypertarget{classSet_a195377de8b2a14cb8858ab158a80b916}{
\index{Set@{Set}!m\_\-nArrayLen@{m\_\-nArrayLen}}
\index{m\_\-nArrayLen@{m\_\-nArrayLen}!Set@{Set}}
\subsubsection[{m\_\-nArrayLen}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-nArrayLen}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSet_a195377de8b2a14cb8858ab158a80b916}
\hypertarget{classSet_a596ca3ad7845fc90a3bc5b0b39f8a439}{
\index{Set@{Set}!m\_\-nSize@{m\_\-nSize}}
\index{m\_\-nSize@{m\_\-nSize}!Set@{Set}}
\subsubsection[{m\_\-nSize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-nSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSet_a596ca3ad7845fc90a3bc5b0b39f8a439}
\hypertarget{classSet_a92c58ed80e0e7dade7838d3d300cc4cf}{
\index{Set@{Set}!m\_\-p\_\-nArray@{m\_\-p\_\-nArray}}
\index{m\_\-p\_\-nArray@{m\_\-p\_\-nArray}!Set@{Set}}
\subsubsection[{m\_\-p\_\-nArray}]{\setlength{\rightskip}{0pt plus 5cm}long$\ast$ {\bf m\_\-p\_\-nArray}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSet_a92c58ed80e0e7dade7838d3d300cc4cf}
\hypertarget{classSet_a3fef4acb279bdd97b96c6da7b042cc1e}{
\index{Set@{Set}!m\_\-p\_\-nArray\_\-Static@{m\_\-p\_\-nArray\_\-Static}}
\index{m\_\-p\_\-nArray\_\-Static@{m\_\-p\_\-nArray\_\-Static}!Set@{Set}}
\subsubsection[{m\_\-p\_\-nArray\_\-Static}]{\setlength{\rightskip}{0pt plus 5cm}long {\bf m\_\-p\_\-nArray\_\-Static}\mbox{[}{\bf NUMBER\_\-WORDS\_\-PER\_\-SET}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSet_a3fef4acb279bdd97b96c6da7b042cc1e}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/ruby/common/\hyperlink{Set_8hh}{Set.hh}\item 
mem/ruby/common/\hyperlink{Set_8cc}{Set.cc}\end{DoxyCompactItemize}
