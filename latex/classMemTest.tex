\hypertarget{classMemTest}{
\section{クラス MemTest}
\label{classMemTest}\index{MemTest@{MemTest}}
}


{\ttfamily \#include $<$memtest.hh$>$}MemTestに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=5cm]{classMemTest}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classMemTest_1_1CpuPort}{CpuPort}
\item 
class \hyperlink{classMemTest_1_1MemTest}{MemTest}
\item 
class \hyperlink{classMemTest_1_1MemTestSenderState}{MemTestSenderState}
\item 
class \hyperlink{classMemTest_1_1TickEvent}{TickEvent}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef MemTestParams \hyperlink{classMemTest_a9c0e666eb773a0cfe77b832270b05c24}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMemTest_ae10fa702de4fca2792933a1386ca93a1}{MemTest} (const \hyperlink{classMemTest_a9c0e666eb773a0cfe77b832270b05c24}{Params} $\ast$p)
\item 
virtual void \hyperlink{classMemTest_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
virtual void \hyperlink{classMemTest_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classMemTest_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\item 
virtual \hyperlink{classBaseMasterPort}{BaseMasterPort} \& \hyperlink{classMemTest_adc4e675e51defbdd1e354dac729d0703}{getMasterPort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
void \hyperlink{classMemTest_a88aa41e2693dd0091afae2604eba9bed}{printAddr} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} a)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classMemTest_adb0890c3c50f747f06c26986a37a5f99}{blockAddr} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr)
\item 
void \hyperlink{classMemTest_afad8eceee562939262183ad20f806b82}{completeRequest} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classMemTest_afd43ca83ca8c1d5fde8a2f349aa2cdc0}{sendPkt} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classMemTest_a31440e5510a8c7bfc74e17363d813401}{doRetry} ()
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMemTest_1_1TickEvent}{TickEvent} \hyperlink{classMemTest_aa36b8e894416f0ec98f701ab08f2ac22}{tickEvent}
\item 
\hyperlink{classMemTest_1_1CpuPort}{CpuPort} \hyperlink{classMemTest_a9529cc9b43e49c677df49655a2dcae59}{cachePort}
\item 
\hyperlink{classMemTest_1_1CpuPort}{CpuPort} \hyperlink{classMemTest_ae15ac85298e9af5a2c9235648142038c}{funcPort}
\item 
\hyperlink{classPortProxy}{PortProxy} \hyperlink{classMemTest_a9ac4a204ae63e4b0faa0de1494001ad1}{funcProxy}
\item 
\hyperlink{classPacket}{PacketPtr} \hyperlink{classMemTest_a314ae93c04b3ca96e79e1b1f39a8e478}{retryPkt}
\item 
bool \hyperlink{classMemTest_ad5bf7786dfa39d56df912238c9440d29}{accessRetry}
\item 
bool \hyperlink{classMemTest_ab1e2d7543dee7540da2f77f9c021b200}{dmaOutstanding}
\item 
unsigned \hyperlink{classMemTest_a245260f6f74972558f61b85227df5aae}{size}
\item 
unsigned \hyperlink{classMemTest_ad154c2c04ac9a3233fec090cc4ef9e62}{percentReads}
\item 
unsigned \hyperlink{classMemTest_a610799cbc3661025682ac441b64e1f5b}{percentFunctional}
\item 
unsigned \hyperlink{classMemTest_aadfb1913bfffe90c30ba7ecff262c25e}{percentUncacheable}
\item 
bool \hyperlink{classMemTest_a8519fa2de8677d71f7a76d5e6696f1fd}{issueDmas}
\item 
\hyperlink{request_8hh_ac366b729262fd8e7cbd3283da6f775cf}{MasterID} \hyperlink{classMemTest_a96ec6a422ac492d05f8b3edc5b58532b}{masterId}
\item 
int \hyperlink{classMemTest_a7441ef0865bcb3db9b8064dd7375c1ea}{id}
\item 
std::set$<$ unsigned $>$ \hyperlink{classMemTest_a45c00cfc104db07c25492851538a4659}{outstandingAddrs}
\item 
unsigned \hyperlink{classMemTest_a5ac9071f2dc21549be52e298e877d8ab}{blockSize}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classMemTest_a6a8310b55ab96dd81aafe314bf214807}{blockAddrMask}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classMemTest_ae3e97c58873f5e4cc0933f70403c8c4c}{traceBlockAddr}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classMemTest_a9baf22f315ea7fad548e9714bc63edec}{baseAddr1}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classMemTest_ad6c75fc30aa9f41b4d50e98037de2e2e}{baseAddr2}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classMemTest_a412d3918caf07e4a7ece4af035d8bba8}{uncacheAddr}
\item 
unsigned \hyperlink{classMemTest_ae3960f606add02b45373ddcb89670ce6}{progressInterval}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classMemTest_a58289da8d79ce7d01b5649b56bf49883}{nextProgressMessage}
\item 
unsigned \hyperlink{classMemTest_a7e9a130962196ae77a0cedf049200449}{percentSourceUnaligned}
\item 
unsigned \hyperlink{classMemTest_a079b4c1338ed7e0366210d7b784f9bab}{percentDestUnaligned}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classMemTest_abd244ba570b7767d45bbc8400f11cb63}{noResponseCycles}
\item 
uint64\_\-t \hyperlink{classMemTest_a0b6f668a9b18b1bf570b1f9bad4318ca}{numReads}
\item 
uint64\_\-t \hyperlink{classMemTest_ab468dc093a7e9b3bd2a17a6b8100e7a8}{numWrites}
\item 
uint64\_\-t \hyperlink{classMemTest_a817c65bf38fc97deca86dee7d5f36029}{maxLoads}
\item 
bool \hyperlink{classMemTest_a927a5f2d0c20b3bb538ebc178df347ce}{atomic}
\item 
bool \hyperlink{classMemTest_a5f4982e0dc4eb2df5f01dd41caaf248b}{suppress\_\-func\_\-warnings}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classMemTest_a1a927562f3bb1e82c8d841f100b66abe}{numReadsStat}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classMemTest_a5ddc16e6d03c7e8091be867da3a20094}{numWritesStat}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classMemTest_abc679ae651f6703a72b4296a9384caed}{numCopiesStat}
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classMemTest_a24edf30be1f143e9b680a6b2e3747fbd}{MemCompleteEvent}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classMemTest_a9c0e666eb773a0cfe77b832270b05c24}{
\index{MemTest@{MemTest}!Params@{Params}}
\index{Params@{Params}!MemTest@{MemTest}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef MemTestParams {\bf Params}}}
\label{classMemTest_a9c0e666eb773a0cfe77b832270b05c24}


\hyperlink{classMemObject_a905bbc621eeec0ed08859e21c8c95412}{MemObject}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classMemTest_ae10fa702de4fca2792933a1386ca93a1}{
\index{MemTest@{MemTest}!MemTest@{MemTest}}
\index{MemTest@{MemTest}!MemTest@{MemTest}}
\subsubsection[{MemTest}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemTest} (const {\bf Params} $\ast$ {\em p})}}
\label{classMemTest_ae10fa702de4fca2792933a1386ca93a1}



\begin{DoxyCode}
94     : MemObject(p),
95       tickEvent(this),
96       cachePort("test", this),
97       funcPort("functional", this),
98       funcProxy(funcPort, p->sys->cacheLineSize()),
99       retryPkt(NULL),
100 //      mainMem(main_mem),
101 //      checkMem(check_mem),
102       size(p->memory_size),
103       percentReads(p->percent_reads),
104       percentFunctional(p->percent_functional),
105       percentUncacheable(p->percent_uncacheable),
106       issueDmas(p->issue_dmas),
107       masterId(p->sys->getMasterId(name())),
108       blockSize(p->sys->cacheLineSize()),
109       progressInterval(p->progress_interval),
110       nextProgressMessage(p->progress_interval),
111       percentSourceUnaligned(p->percent_source_unaligned),
112       percentDestUnaligned(p->percent_dest_unaligned),
113       maxLoads(p->max_loads),
114       atomic(p->atomic),
115       suppress_func_warnings(p->suppress_func_warnings)
116 {
117     id = TESTER_ALLOCATOR++;
118 
119     // Needs to be masked off once we know the block size.
120     traceBlockAddr = p->trace_addr;
121     baseAddr1 = 0x100000;
122     baseAddr2 = 0x400000;
123     uncacheAddr = 0x800000;
124 
125     blockAddrMask = blockSize - 1;
126     traceBlockAddr = blockAddr(traceBlockAddr);
127 
128     // set up counters
129     noResponseCycles = 0;
130     numReads = 0;
131     numWrites = 0;
132     schedule(tickEvent, 0);
133 
134     accessRetry = false;
135     dmaOutstanding = false;
136 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classMemTest_adb0890c3c50f747f06c26986a37a5f99}{
\index{MemTest@{MemTest}!blockAddr@{blockAddr}}
\index{blockAddr@{blockAddr}!MemTest@{MemTest}}
\subsubsection[{blockAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} blockAddr ({\bf Addr} {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classMemTest_adb0890c3c50f747f06c26986a37a5f99}



\begin{DoxyCode}
153     {
154         return (addr & ~blockAddrMask);
155     }
\end{DoxyCode}
\hypertarget{classMemTest_afad8eceee562939262183ad20f806b82}{
\index{MemTest@{MemTest}!completeRequest@{completeRequest}}
\index{completeRequest@{completeRequest}!MemTest@{MemTest}}
\subsubsection[{completeRequest}]{\setlength{\rightskip}{0pt plus 5cm}void completeRequest ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_afad8eceee562939262183ad20f806b82}



\begin{DoxyCode}
159 {
160     Request *req = pkt->req;
161 
162     if (issueDmas) {
163         dmaOutstanding = false;
164     }
165 
166     DPRINTF(MemTest, "completing %s at address %x (blk %x) %s\n",
167             pkt->isWrite() ? "write" : "read",
168             req->getPaddr(), blockAddr(req->getPaddr()),
169             pkt->isError() ? "error" : "success");
170 
171     MemTestSenderState *state =
172         dynamic_cast<MemTestSenderState *>(pkt->senderState);
173 
174     uint8_t *data = state->data;
175     uint8_t *pkt_data = pkt->getPtr<uint8_t>();
176 
177     //Remove the address from the list of outstanding
178     std::set<unsigned>::iterator removeAddr =
179         outstandingAddrs.find(req->getPaddr());
180     assert(removeAddr != outstandingAddrs.end());
181     outstandingAddrs.erase(removeAddr);
182 
183     if (pkt->isError()) {
184         if (!suppress_func_warnings) {
185           warn("Functional %s access failed at %#x\n",
186                pkt->isWrite() ? "write" : "read", req->getPaddr());
187         }
188     } else {
189         if (pkt->isRead()) {
190             if (memcmp(pkt_data, data, pkt->getSize()) != 0) {
191                 panic("%s: read of %x (blk %x) @ cycle %d "
192                       "returns %x, expected %x\n", name(),
193                       req->getPaddr(), blockAddr(req->getPaddr()), curTick(),
194                       *pkt_data, *data);
195             }
196 
197             numReads++;
198             numReadsStat++;
199 
200             if (numReads == (uint64_t)nextProgressMessage) {
201                 ccprintf(cerr, "%s: completed %d read, %d write accesses @%d\n",
202                          name(), numReads, numWrites, curTick());
203                 nextProgressMessage += progressInterval;
204             }
205 
206             if (maxLoads != 0 && numReads >= maxLoads)
207                 exitSimLoop("maximum number of loads reached");
208         } else {
209             assert(pkt->isWrite());
210             funcProxy.writeBlob(req->getPaddr(), pkt_data, req->getSize());
211             numWrites++;
212             numWritesStat++;
213         }
214     }
215 
216     noResponseCycles = 0;
217     delete state;
218     delete [] data;
219     delete pkt->req;
220     delete pkt;
221 }
\end{DoxyCode}
\hypertarget{classMemTest_a31440e5510a8c7bfc74e17363d813401}{
\index{MemTest@{MemTest}!doRetry@{doRetry}}
\index{doRetry@{doRetry}!MemTest@{MemTest}}
\subsubsection[{doRetry}]{\setlength{\rightskip}{0pt plus 5cm}void doRetry ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a31440e5510a8c7bfc74e17363d813401}



\begin{DoxyCode}
366 {
367     if (cachePort.sendTimingReq(retryPkt)) {
368         DPRINTF(MemTest, "accessRetry setting to false\n");
369         accessRetry = false;
370         retryPkt = NULL;
371     }
372 }
\end{DoxyCode}
\hypertarget{classMemTest_adc4e675e51defbdd1e354dac729d0703}{
\index{MemTest@{MemTest}!getMasterPort@{getMasterPort}}
\index{getMasterPort@{getMasterPort}!MemTest@{MemTest}}
\subsubsection[{getMasterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseMasterPort} \& getMasterPort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classMemTest_adc4e675e51defbdd1e354dac729d0703}
Get a master port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classMemObject_adc4e675e51defbdd1e354dac729d0703}{MemObject}を再定義しています。


\begin{DoxyCode}
140 {
141     if (if_name == "functional")
142         return funcPort;
143     else if (if_name == "test")
144         return cachePort;
145     else
146         return MemObject::getMasterPort(if_name, idx);
147 }
\end{DoxyCode}
\hypertarget{classMemTest_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{MemTest@{MemTest}!init@{init}}
\index{init@{init}!MemTest@{MemTest}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classMemTest_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classMemTest_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{SimObject}を再定義しています。


\begin{DoxyCode}
151 {
152     // initial memory contents for both physical memory and functional
153     // memory should be 0; no need to initialize them.
154 }
\end{DoxyCode}
\hypertarget{classMemTest_a88aa41e2693dd0091afae2604eba9bed}{
\index{MemTest@{MemTest}!printAddr@{printAddr}}
\index{printAddr@{printAddr}!MemTest@{MemTest}}
\subsubsection[{printAddr}]{\setlength{\rightskip}{0pt plus 5cm}void printAddr ({\bf Addr} {\em a})}}
\label{classMemTest_a88aa41e2693dd0091afae2604eba9bed}
Print state of address in memory system via PrintReq (for debugging). 


\begin{DoxyCode}
377 {
378     cachePort.printAddr(a);
379 }
\end{DoxyCode}
\hypertarget{classMemTest_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{MemTest@{MemTest}!regStats@{regStats}}
\index{regStats@{regStats}!MemTest@{MemTest}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classMemTest_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} statistics for this object. 

\hyperlink{classSimObject_a4dc637449366fcdfc4e764cdf12d9b11}{SimObject}を再定義しています。


\begin{DoxyCode}
225 {
226     using namespace Stats;
227 
228     numReadsStat
229         .name(name() + ".num_reads")
230         .desc("number of read accesses completed")
231         ;
232 
233     numWritesStat
234         .name(name() + ".num_writes")
235         .desc("number of write accesses completed")
236         ;
237 
238     numCopiesStat
239         .name(name() + ".num_copies")
240         .desc("number of copy accesses completed")
241         ;
242 }
\end{DoxyCode}
\hypertarget{classMemTest_afd43ca83ca8c1d5fde8a2f349aa2cdc0}{
\index{MemTest@{MemTest}!sendPkt@{sendPkt}}
\index{sendPkt@{sendPkt}!MemTest@{MemTest}}
\subsubsection[{sendPkt}]{\setlength{\rightskip}{0pt plus 5cm}void sendPkt ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_afd43ca83ca8c1d5fde8a2f349aa2cdc0}



\begin{DoxyCode}
69                               {
70     if (atomic) {
71         cachePort.sendAtomic(pkt);
72         completeRequest(pkt);
73     }
74     else if (!cachePort.sendTimingReq(pkt)) {
75         DPRINTF(MemTest, "accessRetry setting to true\n");
76 
77         //
78         // dma requests should never be retried
79         //
80         if (issueDmas) {
81             panic("Nacked DMA requests are not supported\n");
82         }
83         accessRetry = true;
84         retryPkt = pkt;
85     } else {
86         if (issueDmas) {
87             dmaOutstanding = true;
88         }
89     }
90 
91 }
\end{DoxyCode}
\hypertarget{classMemTest_a873dd91783f9efb4a590aded1f70d6b0}{
\index{MemTest@{MemTest}!tick@{tick}}
\index{tick@{tick}!MemTest@{MemTest}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()}}
\label{classMemTest_a873dd91783f9efb4a590aded1f70d6b0}



\begin{DoxyCode}
246 {
247     if (!tickEvent.scheduled())
248         schedule(tickEvent, clockEdge(Cycles(1)));
249 
250     if (++noResponseCycles >= 500000) {
251         if (issueDmas) {
252             cerr << "DMA tester ";
253         }
254         cerr << name() << ": deadlocked at cycle " << curTick() << endl;
255         fatal("");
256     }
257 
258     if (accessRetry || (issueDmas && dmaOutstanding)) {
259         DPRINTF(MemTest, "MemTester waiting on accessRetry or DMA response\n");
260         return;
261     }
262 
263     //make new request
264     unsigned cmd = random() % 100;
265     unsigned offset = random() % size;
266     unsigned base = random() % 2;
267     uint64_t data = random();
268     unsigned access_size = random() % 4;
269     bool uncacheable = (random() % 100) < percentUncacheable;
270 
271     unsigned dma_access_size = random() % 4; 
272 
273     //If we aren't doing copies, use id as offset, and do a false sharing
274     //mem tester
275     //We can eliminate the lower bits of the offset, and then use the id
276     //to offset within the blks
277     offset = blockAddr(offset);
278     offset += id;
279     access_size = 0;
280     dma_access_size = 0;
281 
282     Request::Flags flags;
283     Addr paddr;
284 
285     if (uncacheable) {
286         flags.set(Request::UNCACHEABLE);
287         paddr = uncacheAddr + offset;
288     } else  {
289         paddr = ((base) ? baseAddr1 : baseAddr2) + offset;
290     }
291 
292     // For now we only allow one outstanding request per address
293     // per tester This means we assume CPU does write forwarding
294     // to reads that alias something in the cpu store buffer.
295     if (outstandingAddrs.find(paddr) != outstandingAddrs.end()) {
296         return;
297     }
298 
299     bool do_functional = (random() % 100 < percentFunctional) && !uncacheable;
300     Request *req = new Request();
301     uint8_t *result = new uint8_t[8];
302 
303     if (issueDmas) {
304         paddr &= ~((1 << dma_access_size) - 1);
305         req->setPhys(paddr, 1 << dma_access_size, flags, masterId);
306         req->setThreadContext(id,0);
307     } else {
308         paddr &= ~((1 << access_size) - 1);
309         req->setPhys(paddr, 1 << access_size, flags, masterId);
310         req->setThreadContext(id,0);
311     }
312     assert(req->getSize() == 1);
313 
314     if (cmd < percentReads) {
315         // read
316         outstandingAddrs.insert(paddr);
317 
318         // ***** NOTE FOR RON: I'm not sure how to access checkMem. - Kevin
319         funcProxy.readBlob(req->getPaddr(), result, req->getSize());
320 
321         DPRINTF(MemTest,
322                 "id %d initiating %sread at addr %x (blk %x) expecting %x\n",
323                 id, do_functional ? "functional " : "", req->getPaddr(),
324                 blockAddr(req->getPaddr()), *result);
325 
326         PacketPtr pkt = new Packet(req, MemCmd::ReadReq);
327         pkt->dataDynamicArray(new uint8_t[req->getSize()]);
328         MemTestSenderState *state = new MemTestSenderState(result);
329         pkt->senderState = state;
330 
331         if (do_functional) {
332             assert(pkt->needsResponse());
333             pkt->setSuppressFuncError();
334             cachePort.sendFunctional(pkt);
335             completeRequest(pkt);
336         } else {
337             sendPkt(pkt);
338         }
339     } else {
340         // write
341         outstandingAddrs.insert(paddr);
342 
343         DPRINTF(MemTest, "initiating %swrite at addr %x (blk %x) value %x\n",
344                 do_functional ? "functional " : "", req->getPaddr(),
345                 blockAddr(req->getPaddr()), data & 0xff);
346 
347         PacketPtr pkt = new Packet(req, MemCmd::WriteReq);
348         uint8_t *pkt_data = new uint8_t[req->getSize()];
349         pkt->dataDynamicArray(pkt_data);
350         memcpy(pkt_data, &data, req->getSize());
351         MemTestSenderState *state = new MemTestSenderState(result);
352         pkt->senderState = state;
353 
354         if (do_functional) {
355             pkt->setSuppressFuncError();
356             cachePort.sendFunctional(pkt);
357             completeRequest(pkt);
358         } else {
359             sendPkt(pkt);
360         }
361     }
362 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classMemTest_a24edf30be1f143e9b680a6b2e3747fbd}{
\index{MemTest@{MemTest}!MemCompleteEvent@{MemCompleteEvent}}
\index{MemCompleteEvent@{MemCompleteEvent}!MemTest@{MemTest}}
\subsubsection[{MemCompleteEvent}]{\setlength{\rightskip}{0pt plus 5cm}friend class MemCompleteEvent\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classMemTest_a24edf30be1f143e9b680a6b2e3747fbd}


\subsection{変数}
\hypertarget{classMemTest_ad5bf7786dfa39d56df912238c9440d29}{
\index{MemTest@{MemTest}!accessRetry@{accessRetry}}
\index{accessRetry@{accessRetry}!MemTest@{MemTest}}
\subsubsection[{accessRetry}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf accessRetry}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_ad5bf7786dfa39d56df912238c9440d29}
\hypertarget{classMemTest_a927a5f2d0c20b3bb538ebc178df347ce}{
\index{MemTest@{MemTest}!atomic@{atomic}}
\index{atomic@{atomic}!MemTest@{MemTest}}
\subsubsection[{atomic}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf atomic}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a927a5f2d0c20b3bb538ebc178df347ce}
\hypertarget{classMemTest_a9baf22f315ea7fad548e9714bc63edec}{
\index{MemTest@{MemTest}!baseAddr1@{baseAddr1}}
\index{baseAddr1@{baseAddr1}!MemTest@{MemTest}}
\subsubsection[{baseAddr1}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf baseAddr1}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a9baf22f315ea7fad548e9714bc63edec}
\hypertarget{classMemTest_ad6c75fc30aa9f41b4d50e98037de2e2e}{
\index{MemTest@{MemTest}!baseAddr2@{baseAddr2}}
\index{baseAddr2@{baseAddr2}!MemTest@{MemTest}}
\subsubsection[{baseAddr2}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf baseAddr2}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_ad6c75fc30aa9f41b4d50e98037de2e2e}
\hypertarget{classMemTest_a6a8310b55ab96dd81aafe314bf214807}{
\index{MemTest@{MemTest}!blockAddrMask@{blockAddrMask}}
\index{blockAddrMask@{blockAddrMask}!MemTest@{MemTest}}
\subsubsection[{blockAddrMask}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf blockAddrMask}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a6a8310b55ab96dd81aafe314bf214807}
\hypertarget{classMemTest_a5ac9071f2dc21549be52e298e877d8ab}{
\index{MemTest@{MemTest}!blockSize@{blockSize}}
\index{blockSize@{blockSize}!MemTest@{MemTest}}
\subsubsection[{blockSize}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf blockSize}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a5ac9071f2dc21549be52e298e877d8ab}
\hypertarget{classMemTest_a9529cc9b43e49c677df49655a2dcae59}{
\index{MemTest@{MemTest}!cachePort@{cachePort}}
\index{cachePort@{cachePort}!MemTest@{MemTest}}
\subsubsection[{cachePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CpuPort} {\bf cachePort}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a9529cc9b43e49c677df49655a2dcae59}
\hypertarget{classMemTest_ab1e2d7543dee7540da2f77f9c021b200}{
\index{MemTest@{MemTest}!dmaOutstanding@{dmaOutstanding}}
\index{dmaOutstanding@{dmaOutstanding}!MemTest@{MemTest}}
\subsubsection[{dmaOutstanding}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf dmaOutstanding}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_ab1e2d7543dee7540da2f77f9c021b200}
\hypertarget{classMemTest_ae15ac85298e9af5a2c9235648142038c}{
\index{MemTest@{MemTest}!funcPort@{funcPort}}
\index{funcPort@{funcPort}!MemTest@{MemTest}}
\subsubsection[{funcPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CpuPort} {\bf funcPort}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_ae15ac85298e9af5a2c9235648142038c}
\hypertarget{classMemTest_a9ac4a204ae63e4b0faa0de1494001ad1}{
\index{MemTest@{MemTest}!funcProxy@{funcProxy}}
\index{funcProxy@{funcProxy}!MemTest@{MemTest}}
\subsubsection[{funcProxy}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PortProxy} {\bf funcProxy}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a9ac4a204ae63e4b0faa0de1494001ad1}
\hypertarget{classMemTest_a7441ef0865bcb3db9b8064dd7375c1ea}{
\index{MemTest@{MemTest}!id@{id}}
\index{id@{id}!MemTest@{MemTest}}
\subsubsection[{id}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf id}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a7441ef0865bcb3db9b8064dd7375c1ea}
\hypertarget{classMemTest_a8519fa2de8677d71f7a76d5e6696f1fd}{
\index{MemTest@{MemTest}!issueDmas@{issueDmas}}
\index{issueDmas@{issueDmas}!MemTest@{MemTest}}
\subsubsection[{issueDmas}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf issueDmas}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a8519fa2de8677d71f7a76d5e6696f1fd}
\hypertarget{classMemTest_a96ec6a422ac492d05f8b3edc5b58532b}{
\index{MemTest@{MemTest}!masterId@{masterId}}
\index{masterId@{masterId}!MemTest@{MemTest}}
\subsubsection[{masterId}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterID} {\bf masterId}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a96ec6a422ac492d05f8b3edc5b58532b}
\hyperlink{classRequest}{Request} id for all generated traffic \hypertarget{classMemTest_a817c65bf38fc97deca86dee7d5f36029}{
\index{MemTest@{MemTest}!maxLoads@{maxLoads}}
\index{maxLoads@{maxLoads}!MemTest@{MemTest}}
\subsubsection[{maxLoads}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf maxLoads}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a817c65bf38fc97deca86dee7d5f36029}
\hypertarget{classMemTest_a58289da8d79ce7d01b5649b56bf49883}{
\index{MemTest@{MemTest}!nextProgressMessage@{nextProgressMessage}}
\index{nextProgressMessage@{nextProgressMessage}!MemTest@{MemTest}}
\subsubsection[{nextProgressMessage}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf nextProgressMessage}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a58289da8d79ce7d01b5649b56bf49883}
\hypertarget{classMemTest_abd244ba570b7767d45bbc8400f11cb63}{
\index{MemTest@{MemTest}!noResponseCycles@{noResponseCycles}}
\index{noResponseCycles@{noResponseCycles}!MemTest@{MemTest}}
\subsubsection[{noResponseCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf noResponseCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_abd244ba570b7767d45bbc8400f11cb63}
\hypertarget{classMemTest_abc679ae651f6703a72b4296a9384caed}{
\index{MemTest@{MemTest}!numCopiesStat@{numCopiesStat}}
\index{numCopiesStat@{numCopiesStat}!MemTest@{MemTest}}
\subsubsection[{numCopiesStat}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numCopiesStat}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_abc679ae651f6703a72b4296a9384caed}
\hypertarget{classMemTest_a0b6f668a9b18b1bf570b1f9bad4318ca}{
\index{MemTest@{MemTest}!numReads@{numReads}}
\index{numReads@{numReads}!MemTest@{MemTest}}
\subsubsection[{numReads}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf numReads}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a0b6f668a9b18b1bf570b1f9bad4318ca}
\hypertarget{classMemTest_a1a927562f3bb1e82c8d841f100b66abe}{
\index{MemTest@{MemTest}!numReadsStat@{numReadsStat}}
\index{numReadsStat@{numReadsStat}!MemTest@{MemTest}}
\subsubsection[{numReadsStat}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numReadsStat}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a1a927562f3bb1e82c8d841f100b66abe}
\hypertarget{classMemTest_ab468dc093a7e9b3bd2a17a6b8100e7a8}{
\index{MemTest@{MemTest}!numWrites@{numWrites}}
\index{numWrites@{numWrites}!MemTest@{MemTest}}
\subsubsection[{numWrites}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf numWrites}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_ab468dc093a7e9b3bd2a17a6b8100e7a8}
\hypertarget{classMemTest_a5ddc16e6d03c7e8091be867da3a20094}{
\index{MemTest@{MemTest}!numWritesStat@{numWritesStat}}
\index{numWritesStat@{numWritesStat}!MemTest@{MemTest}}
\subsubsection[{numWritesStat}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numWritesStat}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a5ddc16e6d03c7e8091be867da3a20094}
\hypertarget{classMemTest_a45c00cfc104db07c25492851538a4659}{
\index{MemTest@{MemTest}!outstandingAddrs@{outstandingAddrs}}
\index{outstandingAddrs@{outstandingAddrs}!MemTest@{MemTest}}
\subsubsection[{outstandingAddrs}]{\setlength{\rightskip}{0pt plus 5cm}std::set$<$unsigned$>$ {\bf outstandingAddrs}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a45c00cfc104db07c25492851538a4659}
\hypertarget{classMemTest_a079b4c1338ed7e0366210d7b784f9bab}{
\index{MemTest@{MemTest}!percentDestUnaligned@{percentDestUnaligned}}
\index{percentDestUnaligned@{percentDestUnaligned}!MemTest@{MemTest}}
\subsubsection[{percentDestUnaligned}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf percentDestUnaligned}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a079b4c1338ed7e0366210d7b784f9bab}
\hypertarget{classMemTest_a610799cbc3661025682ac441b64e1f5b}{
\index{MemTest@{MemTest}!percentFunctional@{percentFunctional}}
\index{percentFunctional@{percentFunctional}!MemTest@{MemTest}}
\subsubsection[{percentFunctional}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf percentFunctional}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a610799cbc3661025682ac441b64e1f5b}
\hypertarget{classMemTest_ad154c2c04ac9a3233fec090cc4ef9e62}{
\index{MemTest@{MemTest}!percentReads@{percentReads}}
\index{percentReads@{percentReads}!MemTest@{MemTest}}
\subsubsection[{percentReads}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf percentReads}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_ad154c2c04ac9a3233fec090cc4ef9e62}
\hypertarget{classMemTest_a7e9a130962196ae77a0cedf049200449}{
\index{MemTest@{MemTest}!percentSourceUnaligned@{percentSourceUnaligned}}
\index{percentSourceUnaligned@{percentSourceUnaligned}!MemTest@{MemTest}}
\subsubsection[{percentSourceUnaligned}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf percentSourceUnaligned}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a7e9a130962196ae77a0cedf049200449}
\hypertarget{classMemTest_aadfb1913bfffe90c30ba7ecff262c25e}{
\index{MemTest@{MemTest}!percentUncacheable@{percentUncacheable}}
\index{percentUncacheable@{percentUncacheable}!MemTest@{MemTest}}
\subsubsection[{percentUncacheable}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf percentUncacheable}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_aadfb1913bfffe90c30ba7ecff262c25e}
\hypertarget{classMemTest_ae3960f606add02b45373ddcb89670ce6}{
\index{MemTest@{MemTest}!progressInterval@{progressInterval}}
\index{progressInterval@{progressInterval}!MemTest@{MemTest}}
\subsubsection[{progressInterval}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf progressInterval}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_ae3960f606add02b45373ddcb89670ce6}
\hypertarget{classMemTest_a314ae93c04b3ca96e79e1b1f39a8e478}{
\index{MemTest@{MemTest}!retryPkt@{retryPkt}}
\index{retryPkt@{retryPkt}!MemTest@{MemTest}}
\subsubsection[{retryPkt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketPtr} {\bf retryPkt}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a314ae93c04b3ca96e79e1b1f39a8e478}
\hypertarget{classMemTest_a245260f6f74972558f61b85227df5aae}{
\index{MemTest@{MemTest}!size@{size}}
\index{size@{size}!MemTest@{MemTest}}
\subsubsection[{size}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf size}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a245260f6f74972558f61b85227df5aae}
\hypertarget{classMemTest_a5f4982e0dc4eb2df5f01dd41caaf248b}{
\index{MemTest@{MemTest}!suppress\_\-func\_\-warnings@{suppress\_\-func\_\-warnings}}
\index{suppress\_\-func\_\-warnings@{suppress\_\-func\_\-warnings}!MemTest@{MemTest}}
\subsubsection[{suppress\_\-func\_\-warnings}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf suppress\_\-func\_\-warnings}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a5f4982e0dc4eb2df5f01dd41caaf248b}
\hypertarget{classMemTest_aa36b8e894416f0ec98f701ab08f2ac22}{
\index{MemTest@{MemTest}!tickEvent@{tickEvent}}
\index{tickEvent@{tickEvent}!MemTest@{MemTest}}
\subsubsection[{tickEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TickEvent} {\bf tickEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_aa36b8e894416f0ec98f701ab08f2ac22}
\hypertarget{classMemTest_ae3e97c58873f5e4cc0933f70403c8c4c}{
\index{MemTest@{MemTest}!traceBlockAddr@{traceBlockAddr}}
\index{traceBlockAddr@{traceBlockAddr}!MemTest@{MemTest}}
\subsubsection[{traceBlockAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf traceBlockAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_ae3e97c58873f5e4cc0933f70403c8c4c}
\hypertarget{classMemTest_a412d3918caf07e4a7ece4af035d8bba8}{
\index{MemTest@{MemTest}!uncacheAddr@{uncacheAddr}}
\index{uncacheAddr@{uncacheAddr}!MemTest@{MemTest}}
\subsubsection[{uncacheAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf uncacheAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemTest_a412d3918caf07e4a7ece4af035d8bba8}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/testers/memtest/\hyperlink{memtest_8hh}{memtest.hh}\item 
cpu/testers/memtest/\hyperlink{memtest_8cc}{memtest.cc}\end{DoxyCompactItemize}
