\hypertarget{classX86ISA_1_1TLB}{
\section{クラス TLB}
\label{classX86ISA_1_1TLB}\index{X86ISA::TLB@{X86ISA::TLB}}
}


{\ttfamily \#include $<$tlb.hh$>$}TLBに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4cm]{classX86ISA_1_1TLB}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef X86TLBParams \hyperlink{classX86ISA_1_1TLB_a9122b46075a6970493519b96564e6356}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classX86ISA_1_1TLB_acb886bd3c59f00c21be9ceaaf25dab97}{TLB} (const \hyperlink{classX86ISA_1_1TLB_a9122b46075a6970493519b96564e6356}{Params} $\ast$\hyperlink{namespaceX86ISA_af675c1d542a25b96e11164b80809a856}{p})
\item 
void \hyperlink{classX86ISA_1_1TLB_a15b6c15c1be2ca4de3e65772a02aa29f}{takeOverFrom} (\hyperlink{classBaseTLB}{BaseTLB} $\ast$otlb)
\item 
TlbEntry $\ast$ \hyperlink{classX86ISA_1_1TLB_ab71ae01bf6743de678ebdc212e7bb401}{lookup} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} va, bool update\_\-lru=true)
\item 
void \hyperlink{classX86ISA_1_1TLB_ae9a8e1a2483b506a07feeeea766ba43e}{setConfigAddress} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{namespaceX86ISA_ab705917f60c5566f9ce56a93f798b2e2}{addr})
\item 
\hyperlink{classX86ISA_1_1Walker}{Walker} $\ast$ \hyperlink{classX86ISA_1_1TLB_a2f35a7f4b93d6ec096a0785e0d7113cd}{getWalker} ()
\item 
void \hyperlink{classX86ISA_1_1TLB_aca1483a67aee5a91e442f7131d66bcbd}{flushAll} ()
\item 
void \hyperlink{classX86ISA_1_1TLB_a31bf0dd34724a05bf42926ee68e516ef}{flushNonGlobal} ()
\item 
void \hyperlink{classX86ISA_1_1TLB_a18477caae4a9699b99ee4f1ebca75c31}{demapPage} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} va, uint64\_\-t asn)
\item 
void \hyperlink{classX86ISA_1_1TLB_ae59fbc0829276a4cd557c908baf052f0}{evictLRU} ()
\item 
uint64\_\-t \hyperlink{classX86ISA_1_1TLB_ab150a470cb370c561702b113ede76c7d}{nextSeq} ()
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classX86ISA_1_1TLB_ad54e01e3c0a1613098a76b7f92e5be93}{translateAtomic} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} mode)
\item 
void \hyperlink{classX86ISA_1_1TLB_ae52f7e465748883695d2b4f432a13652}{translateTiming} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{classBaseTLB_1_1Translation}{Translation} $\ast$translation, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} mode)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classX86ISA_1_1TLB_a26658814c6c9034665aae19cf25545bb}{translateFunctional} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} mode)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classX86ISA_1_1TLB_ae199d95c42e036851a8a0543c6d6d2e3}{finalizePhysical} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} mode) const 
\item 
TlbEntry $\ast$ \hyperlink{classX86ISA_1_1TLB_a1b0164809bc96e78b231ff2143eb3cfc}{insert} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vpn, TlbEntry \&entry)
\item 
virtual void \hyperlink{classX86ISA_1_1TLB_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&\hyperlink{namespaceX86ISA_a6b6e6ba763e7eaf46ac5b6372ca98d30}{os})
\item 
virtual void \hyperlink{classX86ISA_1_1TLB_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\item 
virtual \hyperlink{classBaseMasterPort}{BaseMasterPort} $\ast$ \hyperlink{classX86ISA_1_1TLB_a2ea87b216b1f58953a679590672be258}{getMasterPort} ()
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ TlbEntry $\ast$ $>$ \hyperlink{classX86ISA_1_1TLB_ad1a39a8d54f6e4053979f8c24fe5dcfd}{EntryList}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
EntryList::iterator \hyperlink{classX86ISA_1_1TLB_ae73955fcefd34a6fab596ade6c99290f}{lookupIt} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} va, bool update\_\-lru=true)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classX86ISA_1_1TLB_ad195b09fbba19be819ba87ce931fc31d}{translateInt} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classX86ISA_1_1TLB_a8b22251fd759b80bb032b04e7f2fc68a}{translate} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{classBaseTLB_1_1Translation}{Translation} $\ast$translation, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} mode, bool \&delayedResponse, bool timing)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classX86ISA_1_1TLB_a2c2064456d968624c149f8658bcfee32}{configAddress}
\item 
\hyperlink{classX86ISA_1_1Walker}{Walker} $\ast$ \hyperlink{classX86ISA_1_1TLB_a54537e5fcbe2d6f609ca4c90a48a06a8}{walker}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classX86ISA_1_1TLB_ab2c6b258f02add8fdf4cfc7c371dd772}{size}
\item 
TlbEntry $\ast$ \hyperlink{classX86ISA_1_1TLB_a4651b9a4f432960d77d8e3d30175aab3}{tlb}
\item 
\hyperlink{classstd_1_1list}{EntryList} \hyperlink{classX86ISA_1_1TLB_a7c13435dc688d8e4d7600964147b5705}{freeList}
\item 
\hyperlink{classTrie}{TlbEntryTrie} \hyperlink{classX86ISA_1_1TLB_aac73611ce3ddb38006a5c03e6ba91977}{trie}
\item 
uint64\_\-t \hyperlink{classX86ISA_1_1TLB_a5bea8f11255089115ad43ef4d83e7c7f}{lruSeq}
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classX86ISA_1_1TLB_a561951adc2bae72717df4b975c66f02f}{Walker}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classX86ISA_1_1TLB_ad1a39a8d54f6e4053979f8c24fe5dcfd}{
\index{X86ISA::TLB@{X86ISA::TLB}!EntryList@{EntryList}}
\index{EntryList@{EntryList}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{EntryList}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<$TlbEntry $\ast$$>$ {\bf EntryList}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1TLB_ad1a39a8d54f6e4053979f8c24fe5dcfd}
\hypertarget{classX86ISA_1_1TLB_a9122b46075a6970493519b96564e6356}{
\index{X86ISA::TLB@{X86ISA::TLB}!Params@{Params}}
\index{Params@{Params}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef X86TLBParams {\bf Params}}}
\label{classX86ISA_1_1TLB_a9122b46075a6970493519b96564e6356}


\hyperlink{classSimObject_a0f0761d2db586a23bb2a2880b8f387bb}{SimObject}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classX86ISA_1_1TLB_acb886bd3c59f00c21be9ceaaf25dab97}{
\index{X86ISA::TLB@{X86ISA::TLB}!TLB@{TLB}}
\index{TLB@{TLB}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{TLB}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TLB} (const {\bf Params} $\ast$ {\em p})}}
\label{classX86ISA_1_1TLB_acb886bd3c59f00c21be9ceaaf25dab97}



\begin{DoxyCode}
64                         : BaseTLB(p), configAddress(0), size(p->size),
65     lruSeq(0)
66 {
67     if (!size)
68         fatal("TLBs must have a non-zero size.\n");
69     tlb = new TlbEntry[size];
70     std::memset(tlb, 0, sizeof(TlbEntry) * size);
71 
72     for (int x = 0; x < size; x++) {
73         tlb[x].trieHandle = NULL;
74         freeList.push_back(&tlb[x]);
75     }
76 
77     walker = p->walker;
78     walker->setTLB(this);
79 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classX86ISA_1_1TLB_a18477caae4a9699b99ee4f1ebca75c31}{
\index{X86ISA::TLB@{X86ISA::TLB}!demapPage@{demapPage}}
\index{demapPage@{demapPage}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{demapPage}]{\setlength{\rightskip}{0pt plus 5cm}void demapPage ({\bf Addr} {\em va}, \/  uint64\_\-t {\em asn})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1TLB_a18477caae4a9699b99ee4f1ebca75c31}


\hyperlink{classBaseTLB_aff4b9d01b9a4712c699cfb2dd9b3b8cd}{BaseTLB}を実装しています。


\begin{DoxyCode}
166 {
167     TlbEntry *entry = trie.lookup(va);
168     if (entry) {
169         trie.remove(entry->trieHandle);
170         entry->trieHandle = NULL;
171         freeList.push_back(entry);
172     }
173 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1TLB_ae59fbc0829276a4cd557c908baf052f0}{
\index{X86ISA::TLB@{X86ISA::TLB}!evictLRU@{evictLRU}}
\index{evictLRU@{evictLRU}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{evictLRU}]{\setlength{\rightskip}{0pt plus 5cm}void evictLRU ()}}
\label{classX86ISA_1_1TLB_ae59fbc0829276a4cd557c908baf052f0}



\begin{DoxyCode}
83 {
84     // Find the entry with the lowest (and hence least recently updated)
85     // sequence number.
86 
87     unsigned lru = 0;
88     for (unsigned i = 1; i < size; i++) {
89         if (tlb[i].lruSeq < tlb[lru].lruSeq)
90             lru = i;
91     }
92 
93     assert(tlb[lru].trieHandle);
94     trie.remove(tlb[lru].trieHandle);
95     tlb[lru].trieHandle = NULL;
96     freeList.push_back(&tlb[lru]);
97 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1TLB_ae199d95c42e036851a8a0543c6d6d2e3}{
\index{X86ISA::TLB@{X86ISA::TLB}!finalizePhysical@{finalizePhysical}}
\index{finalizePhysical@{finalizePhysical}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{finalizePhysical}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} finalizePhysical ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Mode} {\em mode}) const}}
\label{classX86ISA_1_1TLB_ae199d95c42e036851a8a0543c6d6d2e3}
Do post-\/translation physical address finalization.

Some addresses, for example requests going to the APIC, need post-\/translation updates. Such physical addresses are remapped into a \char`\"{}magic\char`\"{} part of the physical address space by this method.


\begin{DoxyParams}{引数}
\item[{\em req}]\hyperlink{classRequest}{Request} to updated in-\/place. \item[{\em tc}]Thread context that created the request. \item[{\em mode}]\hyperlink{classRequest}{Request} type (read/write/execute). \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A fault on failure, NoFault otherwise. 
\end{DoxyReturn}



\begin{DoxyCode}
231 {
232     Addr paddr = req->getPaddr();
233 
234     // Check for an access to the local APIC
235     if (FullSystem) {
236         LocalApicBase localApicBase =
237             tc->readMiscRegNoEffect(MISCREG_APIC_BASE);
238         AddrRange apicRange(localApicBase.base * PageBytes,
239                             (localApicBase.base + 1) * PageBytes - 1);
240 
241         AddrRange m5opRange(0xFFFF0000, 0xFFFFFFFF);
242 
243         if (apicRange.contains(paddr)) {
244             // The Intel developer's manuals say the below restrictions apply,
245             // but the linux kernel, because of a compiler optimization, breaks
246             // them.
247             /*
248             // Check alignment
249             if (paddr & ((32/8) - 1))
250                 return new GeneralProtection(0);
251             // Check access size
252             if (req->getSize() != (32/8))
253                 return new GeneralProtection(0);
254             */
255             // Force the access to be uncacheable.
256             req->setFlags(Request::UNCACHEABLE);
257             req->setPaddr(x86LocalAPICAddress(tc->contextId(),
258                                               paddr - apicRange.start()));
259         } else if (m5opRange.contains(paddr)) {
260             req->setFlags(Request::MMAPPED_IPR | Request::GENERIC_IPR);
261             req->setPaddr(GenericISA::iprAddressPseudoInst(
262                               (paddr >> 8) & 0xFF,
263                               paddr & 0xFF));
264         }
265     }
266 
267     return NoFault;
268 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1TLB_aca1483a67aee5a91e442f7131d66bcbd}{
\index{X86ISA::TLB@{X86ISA::TLB}!flushAll@{flushAll}}
\index{flushAll@{flushAll}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{flushAll}]{\setlength{\rightskip}{0pt plus 5cm}void flushAll ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1TLB_aca1483a67aee5a91e442f7131d66bcbd}
Remove all entries from the \hyperlink{classX86ISA_1_1TLB}{TLB} 

\hyperlink{classBaseTLB_a5958bc92949a47d1be1088468abdc006}{BaseTLB}を実装しています。


\begin{DoxyCode}
134 {
135     DPRINTF(TLB, "Invalidating all entries.\n");
136     for (unsigned i = 0; i < size; i++) {
137         if (tlb[i].trieHandle) {
138             trie.remove(tlb[i].trieHandle);
139             tlb[i].trieHandle = NULL;
140             freeList.push_back(&tlb[i]);
141         }
142     }
143 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1TLB_a31bf0dd34724a05bf42926ee68e516ef}{
\index{X86ISA::TLB@{X86ISA::TLB}!flushNonGlobal@{flushNonGlobal}}
\index{flushNonGlobal@{flushNonGlobal}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{flushNonGlobal}]{\setlength{\rightskip}{0pt plus 5cm}void flushNonGlobal ()}}
\label{classX86ISA_1_1TLB_a31bf0dd34724a05bf42926ee68e516ef}



\begin{DoxyCode}
153 {
154     DPRINTF(TLB, "Invalidating all non global entries.\n");
155     for (unsigned i = 0; i < size; i++) {
156         if (tlb[i].trieHandle && !tlb[i].global) {
157             trie.remove(tlb[i].trieHandle);
158             tlb[i].trieHandle = NULL;
159             freeList.push_back(&tlb[i]);
160         }
161     }
162 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1TLB_a2ea87b216b1f58953a679590672be258}{
\index{X86ISA::TLB@{X86ISA::TLB}!getMasterPort@{getMasterPort}}
\index{getMasterPort@{getMasterPort}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{getMasterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseMasterPort} $\ast$ getMasterPort ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1TLB_a2ea87b216b1f58953a679590672be258}
Get the table walker master port. This is used for migrating port connections during a CPU \hyperlink{classX86ISA_1_1TLB_a15b6c15c1be2ca4de3e65772a02aa29f}{takeOverFrom()} call. For architectures that do not have a table walker, NULL is returned, hence the use of a pointer rather than a reference. For X86 this method will always return a valid port pointer.

\begin{DoxyReturn}{戻り値}
A pointer to the walker master port 
\end{DoxyReturn}


\hyperlink{classBaseTLB_a5125451589673cb85c7cab06c2ac5434}{BaseTLB}を再定義しています。


\begin{DoxyCode}
490 {
491     return &walker->getMasterPort("port");
492 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1TLB_a2f35a7f4b93d6ec096a0785e0d7113cd}{
\index{X86ISA::TLB@{X86ISA::TLB}!getWalker@{getWalker}}
\index{getWalker@{getWalker}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{getWalker}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Walker} $\ast$ getWalker ()}}
\label{classX86ISA_1_1TLB_a2f35a7f4b93d6ec096a0785e0d7113cd}



\begin{DoxyCode}
443 {
444     return walker;
445 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1TLB_a1b0164809bc96e78b231ff2143eb3cfc}{
\index{X86ISA::TLB@{X86ISA::TLB}!insert@{insert}}
\index{insert@{insert}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{insert}]{\setlength{\rightskip}{0pt plus 5cm}TlbEntry $\ast$ insert ({\bf Addr} {\em vpn}, \/  TlbEntry \& {\em entry})}}
\label{classX86ISA_1_1TLB_a1b0164809bc96e78b231ff2143eb3cfc}



\begin{DoxyCode}
101 {
102     // If somebody beat us to it, just use that existing entry.
103     TlbEntry *newEntry = trie.lookup(vpn);
104     if (newEntry) {
105         assert(newEntry->vaddr == vpn);
106         return newEntry;
107     }
108 
109     if (freeList.empty())
110         evictLRU();
111 
112     newEntry = freeList.front();
113     freeList.pop_front();
114 
115     *newEntry = entry;
116     newEntry->lruSeq = nextSeq();
117     newEntry->vaddr = vpn;
118     newEntry->trieHandle =
119     trie.insert(vpn, TlbEntryTrie::MaxBits - entry.logBytes, newEntry);
120     return newEntry;
121 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1TLB_ab71ae01bf6743de678ebdc212e7bb401}{
\index{X86ISA::TLB@{X86ISA::TLB}!lookup@{lookup}}
\index{lookup@{lookup}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{lookup}]{\setlength{\rightskip}{0pt plus 5cm}TlbEntry $\ast$ lookup ({\bf Addr} {\em va}, \/  bool {\em update\_\-lru} = {\ttfamily true})}}
\label{classX86ISA_1_1TLB_ab71ae01bf6743de678ebdc212e7bb401}



\begin{DoxyCode}
125 {
126     TlbEntry *entry = trie.lookup(va);
127     if (entry && update_lru)
128         entry->lruSeq = nextSeq();
129     return entry;
130 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1TLB_ae73955fcefd34a6fab596ade6c99290f}{
\index{X86ISA::TLB@{X86ISA::TLB}!lookupIt@{lookupIt}}
\index{lookupIt@{lookupIt}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{lookupIt}]{\setlength{\rightskip}{0pt plus 5cm}EntryList::iterator lookupIt ({\bf Addr} {\em va}, \/  bool {\em update\_\-lru} = {\ttfamily true})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1TLB_ae73955fcefd34a6fab596ade6c99290f}
\hypertarget{classX86ISA_1_1TLB_ab150a470cb370c561702b113ede76c7d}{
\index{X86ISA::TLB@{X86ISA::TLB}!nextSeq@{nextSeq}}
\index{nextSeq@{nextSeq}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{nextSeq}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t nextSeq ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1TLB_ab150a470cb370c561702b113ede76c7d}



\begin{DoxyCode}
121         {
122             return ++lruSeq;
123         }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1TLB_a53e036786d17361be4c7320d39c99b84}{
\index{X86ISA::TLB@{X86ISA::TLB}!serialize@{serialize}}
\index{serialize@{serialize}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1TLB_a53e036786d17361be4c7320d39c99b84}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。


\begin{DoxyCode}
449 {
450     // Only store the entries in use.
451     uint32_t _size = size - freeList.size();
452     SERIALIZE_SCALAR(_size);
453     SERIALIZE_SCALAR(lruSeq);
454 
455     uint32_t _count = 0;
456 
457     for (uint32_t x = 0; x < size; x++) {
458         if (tlb[x].trieHandle != NULL) {
459             os << "\n[" << csprintf("%s.Entry%d", name(), _count) << "]\n";
460             tlb[x].serialize(os);
461             _count++;
462         }
463     }
464 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1TLB_ae9a8e1a2483b506a07feeeea766ba43e}{
\index{X86ISA::TLB@{X86ISA::TLB}!setConfigAddress@{setConfigAddress}}
\index{setConfigAddress@{setConfigAddress}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{setConfigAddress}]{\setlength{\rightskip}{0pt plus 5cm}void setConfigAddress ({\bf uint32\_\-t} {\em addr})}}
\label{classX86ISA_1_1TLB_ae9a8e1a2483b506a07feeeea766ba43e}



\begin{DoxyCode}
147 {
148     configAddress = addr;
149 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1TLB_a15b6c15c1be2ca4de3e65772a02aa29f}{
\index{X86ISA::TLB@{X86ISA::TLB}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ({\bf BaseTLB} $\ast$ {\em otlb})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1TLB_a15b6c15c1be2ca4de3e65772a02aa29f}



\begin{DoxyCode}
78 {}
\end{DoxyCode}
\hypertarget{classX86ISA_1_1TLB_a8b22251fd759b80bb032b04e7f2fc68a}{
\index{X86ISA::TLB@{X86ISA::TLB}!translate@{translate}}
\index{translate@{translate}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{translate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translate ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Translation} $\ast$ {\em translation}, \/  {\bf Mode} {\em mode}, \/  bool \& {\em delayedResponse}, \/  bool {\em timing})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1TLB_a8b22251fd759b80bb032b04e7f2fc68a}



\begin{DoxyCode}
273 {
274     uint32_t flags = req->getFlags();
275     int seg = flags & SegmentFlagMask;
276     bool storeCheck = flags & (StoreCheck << FlagShift);
277 
278     delayedResponse = false;
279 
280     // If this is true, we're dealing with a request to a non-memory address
281     // space.
282     if (seg == SEGMENT_REG_MS) {
283         return translateInt(req, tc);
284     }
285 
286     Addr vaddr = req->getVaddr();
287     DPRINTF(TLB, "Translating vaddr %#x.\n", vaddr);
288 
289     HandyM5Reg m5Reg = tc->readMiscRegNoEffect(MISCREG_M5_REG);
290 
291     // If protected mode has been enabled...
292     if (m5Reg.prot) {
293         DPRINTF(TLB, "In protected mode.\n");
294         // If we're not in 64-bit mode, do protection/limit checks
295         if (m5Reg.mode != LongMode) {
296             DPRINTF(TLB, "Not in long mode. Checking segment protection.\n");
297             // Check for a NULL segment selector.
298             if (!(seg == SEGMENT_REG_TSG || seg == SYS_SEGMENT_REG_IDTR ||
299                         seg == SEGMENT_REG_HS || seg == SEGMENT_REG_LS)
300                     && !tc->readMiscRegNoEffect(MISCREG_SEG_SEL(seg)))
301                 return new GeneralProtection(0);
302             bool expandDown = false;
303             SegAttr attr = tc->readMiscRegNoEffect(MISCREG_SEG_ATTR(seg));
304             if (seg >= SEGMENT_REG_ES && seg <= SEGMENT_REG_HS) {
305                 if (!attr.writable && (mode == Write || storeCheck))
306                     return new GeneralProtection(0);
307                 if (!attr.readable && mode == Read)
308                     return new GeneralProtection(0);
309                 expandDown = attr.expandDown;
310 
311             }
312             Addr base = tc->readMiscRegNoEffect(MISCREG_SEG_BASE(seg));
313             Addr limit = tc->readMiscRegNoEffect(MISCREG_SEG_LIMIT(seg));
314             bool sizeOverride = (flags & (AddrSizeFlagBit << FlagShift));
315             unsigned logSize = sizeOverride ? (unsigned)m5Reg.altAddr
316                                             : (unsigned)m5Reg.defAddr;
317             int size = (1 << logSize) * 8;
318             Addr offset = bits(vaddr - base, size - 1, 0);
319             Addr endOffset = offset + req->getSize() - 1;
320             if (expandDown) {
321                 DPRINTF(TLB, "Checking an expand down segment.\n");
322                 warn_once("Expand down segments are untested.\n");
323                 if (offset <= limit || endOffset <= limit)
324                     return new GeneralProtection(0);
325             } else {
326                 if (offset > limit || endOffset > limit)
327                     return new GeneralProtection(0);
328             }
329         }
330         if (m5Reg.submode != SixtyFourBitMode ||
331                 (flags & (AddrSizeFlagBit << FlagShift)))
332             vaddr &= mask(32);
333         // If paging is enabled, do the translation.
334         if (m5Reg.paging) {
335             DPRINTF(TLB, "Paging enabled.\n");
336             // The vaddr already has the segment base applied.
337             TlbEntry *entry = lookup(vaddr);
338             if (!entry) {
339                 if (FullSystem) {
340                     Fault fault = walker->start(tc, translation, req, mode);
341                     if (timing || fault != NoFault) {
342                         // This gets ignored in atomic mode.
343                         delayedResponse = true;
344                         return fault;
345                     }
346                     entry = lookup(vaddr);
347                     assert(entry);
348                 } else {
349                     DPRINTF(TLB, "Handling a TLB miss for "
350                             "address %#x at pc %#x.\n",
351                             vaddr, tc->instAddr());
352 
353                     Process *p = tc->getProcessPtr();
354                     TlbEntry newEntry;
355                     bool success = p->pTable->lookup(vaddr, newEntry);
356                     if (!success && mode != Execute) {
357                         // Check if we just need to grow the stack.
358                         if (p->fixupStackFault(vaddr)) {
359                             // If we did, lookup the entry for the new page.
360                             success = p->pTable->lookup(vaddr, newEntry);
361                         }
362                     }
363                     if (!success) {
364                         return new PageFault(vaddr, true, mode, true, false);
365                     } else {
366                         Addr alignedVaddr = p->pTable->pageAlign(vaddr);
367                         DPRINTF(TLB, "Mapping %#x to %#x\n", alignedVaddr,
368                                 newEntry.pageStart());
369                         entry = insert(alignedVaddr, newEntry);
370                     }
371                     DPRINTF(TLB, "Miss was serviced.\n");
372                 }
373             }
374 
375             DPRINTF(TLB, "Entry found with paddr %#x, "
376                     "doing protection checks.\n", entry->paddr);
377             // Do paging protection checks.
378             bool inUser = (m5Reg.cpl == 3 &&
379                     !(flags & (CPL0FlagBit << FlagShift)));
380             CR0 cr0 = tc->readMiscRegNoEffect(MISCREG_CR0);
381             bool badWrite = (!entry->writable && (inUser || cr0.wp));
382             if ((inUser && !entry->user) || (mode == Write && badWrite)) {
383                 // The page must have been present to get into the TLB in
384                 // the first place. We'll assume the reserved bits are
385                 // fine even though we're not checking them.
386                 return new PageFault(vaddr, true, mode, inUser, false);
387             }
388             if (storeCheck && badWrite) {
389                 // This would fault if this were a write, so return a page
390                 // fault that reflects that happening.
391                 return new PageFault(vaddr, true, Write, inUser, false);
392             }
393 
394             Addr paddr = entry->paddr | (vaddr & mask(entry->logBytes));
395             DPRINTF(TLB, "Translated %#x -> %#x.\n", vaddr, paddr);
396             req->setPaddr(paddr);
397             if (entry->uncacheable)
398                 req->setFlags(Request::UNCACHEABLE);
399         } else {
400             //Use the address which already has segmentation applied.
401             DPRINTF(TLB, "Paging disabled.\n");
402             DPRINTF(TLB, "Translated %#x -> %#x.\n", vaddr, vaddr);
403             req->setPaddr(vaddr);
404         }
405     } else {
406         // Real mode
407         DPRINTF(TLB, "In real mode.\n");
408         DPRINTF(TLB, "Translated %#x -> %#x.\n", vaddr, vaddr);
409         req->setPaddr(vaddr);
410     }
411 
412     return finalizePhysical(req, tc, mode);
413 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1TLB_ad54e01e3c0a1613098a76b7f92e5be93}{
\index{X86ISA::TLB@{X86ISA::TLB}!translateAtomic@{translateAtomic}}
\index{translateAtomic@{translateAtomic}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{translateAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translateAtomic ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Mode} {\em mode})}}
\label{classX86ISA_1_1TLB_ad54e01e3c0a1613098a76b7f92e5be93}



\begin{DoxyCode}
417 {
418     bool delayedResponse;
419     return TLB::translate(req, tc, NULL, mode, delayedResponse, false);
420 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1TLB_a26658814c6c9034665aae19cf25545bb}{
\index{X86ISA::TLB@{X86ISA::TLB}!translateFunctional@{translateFunctional}}
\index{translateFunctional@{translateFunctional}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{translateFunctional}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translateFunctional ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Mode} {\em mode})}}
\label{classX86ISA_1_1TLB_a26658814c6c9034665aae19cf25545bb}
Stub function for compilation support of \hyperlink{classCheckerCPU}{CheckerCPU}. x86 \hyperlink{classX86ISA_1_1ISA}{ISA} does not support \hyperlink{classChecker}{Checker} model at the moment 


\begin{DoxyCode}
436 {
437     panic("Not implemented\n");
438     return NoFault;
439 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1TLB_ad195b09fbba19be819ba87ce931fc31d}{
\index{X86ISA::TLB@{X86ISA::TLB}!translateInt@{translateInt}}
\index{translateInt@{translateInt}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{translateInt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translateInt ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1TLB_ad195b09fbba19be819ba87ce931fc31d}



\begin{DoxyCode}
177 {
178     DPRINTF(TLB, "Addresses references internal memory.\n");
179     Addr vaddr = req->getVaddr();
180     Addr prefix = (vaddr >> 3) & IntAddrPrefixMask;
181     if (prefix == IntAddrPrefixCPUID) {
182         panic("CPUID memory space not yet implemented!\n");
183     } else if (prefix == IntAddrPrefixMSR) {
184         vaddr = (vaddr >> 3) & ~IntAddrPrefixMask;
185         req->setFlags(Request::MMAPPED_IPR);
186 
187         MiscRegIndex regNum;
188         if (!msrAddrToIndex(regNum, vaddr))
189             return new GeneralProtection(0);
190 
191         //The index is multiplied by the size of a MiscReg so that
192         //any memory dependence calculations will not see these as
193         //overlapping.
194         req->setPaddr((Addr)regNum * sizeof(MiscReg));
195         return NoFault;
196     } else if (prefix == IntAddrPrefixIO) {
197         // TODO If CPL > IOPL or in virtual mode, check the I/O permission
198         // bitmap in the TSS.
199 
200         Addr IOPort = vaddr & ~IntAddrPrefixMask;
201         // Make sure the address fits in the expected 16 bit IO address
202         // space.
203         assert(!(IOPort & ~0xFFFF));
204         if (IOPort == 0xCF8 && req->getSize() == 4) {
205             req->setFlags(Request::MMAPPED_IPR);
206             req->setPaddr(MISCREG_PCI_CONFIG_ADDRESS * sizeof(MiscReg));
207         } else if ((IOPort & ~mask(2)) == 0xCFC) {
208             req->setFlags(Request::UNCACHEABLE);
209             Addr configAddress =
210                 tc->readMiscRegNoEffect(MISCREG_PCI_CONFIG_ADDRESS);
211             if (bits(configAddress, 31, 31)) {
212                 req->setPaddr(PhysAddrPrefixPciConfig |
213                         mbits(configAddress, 30, 2) |
214                         (IOPort & mask(2)));
215             } else {
216                 req->setPaddr(PhysAddrPrefixIO | IOPort);
217             }
218         } else {
219             req->setFlags(Request::UNCACHEABLE);
220             req->setPaddr(PhysAddrPrefixIO | IOPort);
221         }
222         return NoFault;
223     } else {
224         panic("Access to unrecognized internal address space %#x.\n",
225                 prefix);
226     }
227 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1TLB_ae52f7e465748883695d2b4f432a13652}{
\index{X86ISA::TLB@{X86ISA::TLB}!translateTiming@{translateTiming}}
\index{translateTiming@{translateTiming}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{translateTiming}]{\setlength{\rightskip}{0pt plus 5cm}void translateTiming ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Translation} $\ast$ {\em translation}, \/  {\bf Mode} {\em mode})}}
\label{classX86ISA_1_1TLB_ae52f7e465748883695d2b4f432a13652}



\begin{DoxyCode}
425 {
426     bool delayedResponse;
427     assert(translation);
428     Fault fault =
429         TLB::translate(req, tc, translation, mode, delayedResponse, true);
430     if (!delayedResponse)
431         translation->finish(fault, req, tc, mode);
432 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1TLB_af22e5d6d660b97db37003ac61ac4ee49}{
\index{X86ISA::TLB@{X86ISA::TLB}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1TLB_af22e5d6d660b97db37003ac61ac4ee49}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。


\begin{DoxyCode}
468 {
469     // Do not allow to restore with a smaller tlb.
470     uint32_t _size;
471     UNSERIALIZE_SCALAR(_size);
472     if (_size > size) {
473         fatal("TLB size less than the one in checkpoint!");
474     }
475 
476     UNSERIALIZE_SCALAR(lruSeq);
477 
478     for (uint32_t x = 0; x < _size; x++) {
479         TlbEntry *newEntry = freeList.front();
480         freeList.pop_front();
481 
482         newEntry->unserialize(cp, csprintf("%s.Entry%d", name(), x));
483         newEntry->trieHandle = trie.insert(newEntry->vaddr,
484             TlbEntryTrie::MaxBits - newEntry->logBytes, newEntry);
485     }
486 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classX86ISA_1_1TLB_a561951adc2bae72717df4b975c66f02f}{
\index{X86ISA::TLB@{X86ISA::TLB}!Walker@{Walker}}
\index{Walker@{Walker}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{Walker}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf Walker}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classX86ISA_1_1TLB_a561951adc2bae72717df4b975c66f02f}


\subsection{変数}
\hypertarget{classX86ISA_1_1TLB_a2c2064456d968624c149f8658bcfee32}{
\index{X86ISA::TLB@{X86ISA::TLB}!configAddress@{configAddress}}
\index{configAddress@{configAddress}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{configAddress}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf configAddress}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1TLB_a2c2064456d968624c149f8658bcfee32}
\hypertarget{classX86ISA_1_1TLB_a7c13435dc688d8e4d7600964147b5705}{
\index{X86ISA::TLB@{X86ISA::TLB}!freeList@{freeList}}
\index{freeList@{freeList}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{freeList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EntryList} {\bf freeList}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1TLB_a7c13435dc688d8e4d7600964147b5705}
\hypertarget{classX86ISA_1_1TLB_a5bea8f11255089115ad43ef4d83e7c7f}{
\index{X86ISA::TLB@{X86ISA::TLB}!lruSeq@{lruSeq}}
\index{lruSeq@{lruSeq}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{lruSeq}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf lruSeq}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1TLB_a5bea8f11255089115ad43ef4d83e7c7f}
\hypertarget{classX86ISA_1_1TLB_ab2c6b258f02add8fdf4cfc7c371dd772}{
\index{X86ISA::TLB@{X86ISA::TLB}!size@{size}}
\index{size@{size}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{size}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf size}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1TLB_ab2c6b258f02add8fdf4cfc7c371dd772}
\hypertarget{classX86ISA_1_1TLB_a4651b9a4f432960d77d8e3d30175aab3}{
\index{X86ISA::TLB@{X86ISA::TLB}!tlb@{tlb}}
\index{tlb@{tlb}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{tlb}]{\setlength{\rightskip}{0pt plus 5cm}TlbEntry$\ast$ {\bf tlb}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1TLB_a4651b9a4f432960d77d8e3d30175aab3}
\hypertarget{classX86ISA_1_1TLB_aac73611ce3ddb38006a5c03e6ba91977}{
\index{X86ISA::TLB@{X86ISA::TLB}!trie@{trie}}
\index{trie@{trie}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{trie}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TlbEntryTrie} {\bf trie}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1TLB_aac73611ce3ddb38006a5c03e6ba91977}
\hypertarget{classX86ISA_1_1TLB_a54537e5fcbe2d6f609ca4c90a48a06a8}{
\index{X86ISA::TLB@{X86ISA::TLB}!walker@{walker}}
\index{walker@{walker}!X86ISA::TLB@{X86ISA::TLB}}
\subsubsection[{walker}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Walker}$\ast$ {\bf walker}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1TLB_a54537e5fcbe2d6f609ca4c90a48a06a8}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/x86/\hyperlink{arch_2x86_2tlb_8hh}{tlb.hh}\item 
arch/x86/\hyperlink{arch_2x86_2tlb_8cc}{tlb.cc}\end{DoxyCompactItemize}
