<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>File&nbsp;GEM5&nbsp;Wrapper: クラス EventQueue</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- 作成： Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>メインページ</span></a></li>
      <li><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>構成</span></a></li>
      <li><a href="classes.html"><span>構成索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>構成メンバ</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>クラス EventQueue</h1><!-- doxytag: class="EventQueue" --><!-- doxytag: inherits="Serializable" -->
<p><code>#include &lt;<a class="el" href="eventq_8hh_source.html">eventq.hh</a>&gt;</code></p>
<div class="dynheader">
EventQueueに対する継承グラフ</div>
<div class="dynsection">
 <div class="center">
  <img src="classEventQueue.gif" usemap="#EventQueue_map" alt=""/>
  <map id="EventQueue_map" name="EventQueue_map">
<area href="classSerializable.html" alt="Serializable" shape="rect" coords="0,0,82,24"/>
</map>
 </div>
</div>

<p><a href="classEventQueue-members.html">すべてのメンバ一覧</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>構成</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue_1_1ScopedMigration.html">ScopedMigration</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue_1_1ScopedRelease.html">ScopedRelease</a></td></tr>
<tr><td colspan="2"><h2>Public メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#a6034f8afa29a6178a4b6d0e371344d0d">EventQueue</a> (const std::string &amp;n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#adbcff144e5e199d332a1352af1798148">name</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#a413b79e026328fa4210d327d1958bd12">name</a> (const std::string &amp;st)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#a6e13c0d68fbc26df6eff27313813b8a4">schedule</a> (<a class="el" href="classEvent.html">Event</a> *event, <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> when, bool global=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#ab1b8fc2b2605fdc1d88bf07a86e1fe07">deschedule</a> (<a class="el" href="classEvent.html">Event</a> *event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#a676294f5f01031f3dfdf956185390db8">reschedule</a> (<a class="el" href="classEvent.html">Event</a> *event, <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> when, bool always=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#ac7fc06f25478db3060a43a096e023243">nextTick</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#abc2f41fbb4828612a2637268ab8ce640">setCurTick</a> (<a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> newVal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#ab9e4d6c1f3218aee0ff70854de959a6c">getCurTick</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Event *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#a95b9c78d6fb18e716e5d13362b609798">serviceOne</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#adc925eabe90846085072915cc6c544c2">serviceEvents</a> (<a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> when)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#ac6e61de369e994009e36f344f99c15ad">empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#a4a4fecb6d7cd9d0b8eb6579eee183af8">dump</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#a66392764e022762d90e80efbee0500b2">debugVerify</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#a2f9d0ed8258183804bc764aa3b859f70">handleAsyncInsertions</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function for moving events from the async_queue to the main queue.  <a href="#a2f9d0ed8258183804bc764aa3b859f70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Event *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#a1c4b36385e86f178f625f84d95cb6778">replaceHead</a> (Event *s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#ad6272f80ae37e8331e3969b3f072a801">serialize</a> (std::ostream &amp;os)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#af22e5d6d660b97db37003ac61ac4ee49">unserialize</a> (<a class="el" href="classCheckpoint.html">Checkpoint</a> *cp, const std::string &amp;section)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd41d8cd98f00b204e9800998ecf8427e"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#aa81aed607133209dade63a226818224d">lock</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#a9278be8203e1c42e2619179882ae4403">unlock</a> ()</td></tr>
<tr><td colspan="2"><h2>Private メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#ad8e469f292d876af9e2ec380e8e7e51e">insert</a> (Event *event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#a3f3ea68ae4a3b85263c9e223efcce2f6">remove</a> (Event *event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#aadb31d9952f03cb2a934f93cac304153">asyncInsert</a> (Event *event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#aac902b23c2f4ad571d6229b56ea09d0b">EventQueue</a> (const <a class="el" href="classEventQueue.html">EventQueue</a> &amp;)</td></tr>
<tr><td colspan="2"><h2>Private 変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#acdd07b78b47375ca2a51a7a956b1697f">objName</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEvent.html">Event</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#a09b29d670564770f8cde7490c4fa4ebb">_curTick</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::mutex *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#a7d6bb496422e204e32492a7012a44b66">async_queue_mutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mutex to protect async queue.  <a href="#a7d6bb496422e204e32492a7012a44b66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1list.html">std::list</a>&lt; <a class="el" href="classEvent.html">Event</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#a9c9b5322e34950b9d27abca2b8207ca9">async_queue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of events added by other threads to this event queue.  <a href="#a9c9b5322e34950b9d27abca2b8207ca9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::mutex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEventQueue.html#acfc3095049c7deadb02a9eee0ec54a13">service_mutex</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>説明</h2>
<p>Queue of events sorted in time order</p>
<p>Events are scheduled (inserted into the event queue) using the <a class="el" href="classEventQueue.html#a6e13c0d68fbc26df6eff27313813b8a4">schedule()</a> method. This method either inserts a <em>synchronous</em> or <em>asynchronous</em> event.</p>
<p>Synchronous events are scheduled using <a class="el" href="classEventQueue.html#a6e13c0d68fbc26df6eff27313813b8a4">schedule()</a> method with the argument 'global' set to false (default). This should only be done from a thread holding the event queue lock (<a class="el" href="classEventQueue.html#acfc3095049c7deadb02a9eee0ec54a13">EventQueue::service_mutex</a>). The lock is always held when an event handler is called, it can therefore always insert events into its own event queue unless it voluntarily releases the lock.</p>
<p>Events can be scheduled across thread (and event queue borders) by either scheduling asynchronous events or taking the target event queue's lock. However, the lock should <em>never</em> be taken directly since this is likely to cause deadlocks. Instead, code that needs to schedule events in other event queues should temporarily release its own queue and lock the new queue. This prevents deadlocks since a single thread never owns more than one event queue lock. This functionality is provided by the <a class="el" href="classEventQueue_1_1ScopedMigration.html">ScopedMigration</a> helper class. Note that temporarily migrating between event queues can make the simulation non-deterministic, it should therefore be limited to cases where that can be tolerated (e.g., handling asynchronous IO or fast-forwarding in KVM).</p>
<p>Asynchronous events can also be scheduled using the normal <a class="el" href="classEventQueue.html#a6e13c0d68fbc26df6eff27313813b8a4">schedule()</a> method with the 'global' parameter set to true. Unlike the previous queue migration strategy, this strategy is fully deterministic. This causes the event to be inserted in a separate queue of asynchronous events (async_queue), which is merged main event queue at the end of each simulation quantum (by calling the <a class="el" href="classEventQueue.html#a2f9d0ed8258183804bc764aa3b859f70" title="Function for moving events from the async_queue to the main queue.">handleAsyncInsertions()</a> method). Note that this implies that such events must happen at least one simulation quantum into the future, otherwise they risk being scheduled in the past by <a class="el" href="classEventQueue.html#a2f9d0ed8258183804bc764aa3b859f70" title="Function for moving events from the async_queue to the main queue.">handleAsyncInsertions()</a>. </p>
<hr/><h2>コンストラクタとデストラクタ</h2>
<a class="anchor" id="aac902b23c2f4ad571d6229b56ea09d0b"></a><!-- doxytag: member="EventQueue::EventQueue" ref="aac902b23c2f4ad571d6229b56ea09d0b" args="(const EventQueue &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEventQueue.html">EventQueue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEventQueue.html">EventQueue</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6034f8afa29a6178a4b6d0e371344d0d"></a><!-- doxytag: member="EventQueue::EventQueue" ref="a6034f8afa29a6178a4b6d0e371344d0d" args="(const std::string &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEventQueue.html">EventQueue</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>関数</h2>
<a class="anchor" id="aadb31d9952f03cb2a934f93cac304153"></a><!-- doxytag: member="EventQueue::asyncInsert" ref="aadb31d9952f03cb2a934f93cac304153" args="(Event *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asyncInsert </td>
          <td>(</td>
          <td class="paramtype">Event *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function for adding events to the async queue. The added events are added to main event queue later. Threads, other than the owning thread, should call this function instead of <a class="el" href="classEventQueue.html#ad8e469f292d876af9e2ec380e8e7e51e">insert()</a>. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00470"></a>00470 {
<a name="l00471"></a>00471     <a class="code" href="classEventQueue.html#a7d6bb496422e204e32492a7012a44b66" title="Mutex to protect async queue.">async_queue_mutex</a>-&gt;lock();
<a name="l00472"></a>00472     <a class="code" href="classEventQueue.html#a9c9b5322e34950b9d27abca2b8207ca9" title="List of events added by other threads to this event queue.">async_queue</a>.push_back(<a class="code" href="namespaceMipsISA.html#aa3b803f4777161a2825178dabfb154f0">event</a>);
<a name="l00473"></a>00473     <a class="code" href="classEventQueue.html#a7d6bb496422e204e32492a7012a44b66" title="Mutex to protect async queue.">async_queue_mutex</a>-&gt;unlock();
<a name="l00474"></a>00474 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a66392764e022762d90e80efbee0500b2"></a><!-- doxytag: member="EventQueue::debugVerify" ref="a66392764e022762d90e80efbee0500b2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool debugVerify </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00366"></a>00366 {
<a name="l00367"></a>00367     m5::hash_map&lt;long, bool&gt; map;
<a name="l00368"></a>00368 
<a name="l00369"></a>00369     <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> time = 0;
<a name="l00370"></a>00370     <span class="keywordtype">short</span> priority = 0;
<a name="l00371"></a>00371 
<a name="l00372"></a>00372     Event *nextBin = <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a>;
<a name="l00373"></a>00373     <span class="keywordflow">while</span> (nextBin) {
<a name="l00374"></a>00374         Event *nextInBin = nextBin;
<a name="l00375"></a>00375         <span class="keywordflow">while</span> (nextInBin) {
<a name="l00376"></a>00376             <span class="keywordflow">if</span> (nextInBin-&gt;when() &lt; time) {
<a name="l00377"></a>00377                 <a class="code" href="cprintf_8hh.html#a46231f0e413d30a2560384d0ae05536b">cprintf</a>(<span class="stringliteral">&quot;time goes backwards!&quot;</span>);
<a name="l00378"></a>00378                 nextInBin-&gt;dump();
<a name="l00379"></a>00379                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00380"></a>00380             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nextInBin-&gt;when() == time &amp;&amp;
<a name="l00381"></a>00381                        nextInBin-&gt;priority() &lt; priority) {
<a name="l00382"></a>00382                 <a class="code" href="cprintf_8hh.html#a46231f0e413d30a2560384d0ae05536b">cprintf</a>(<span class="stringliteral">&quot;priority inverted!&quot;</span>);
<a name="l00383"></a>00383                 nextInBin-&gt;dump();
<a name="l00384"></a>00384                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00385"></a>00385             }
<a name="l00386"></a>00386 
<a name="l00387"></a>00387             <span class="keywordflow">if</span> (map[reinterpret_cast&lt;long&gt;(nextInBin)]) {
<a name="l00388"></a>00388                 <a class="code" href="cprintf_8hh.html#a46231f0e413d30a2560384d0ae05536b">cprintf</a>(<span class="stringliteral">&quot;Node already seen&quot;</span>);
<a name="l00389"></a>00389                 nextInBin-&gt;dump();
<a name="l00390"></a>00390                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00391"></a>00391             }
<a name="l00392"></a>00392             map[<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>(nextInBin)] = <span class="keyword">true</span>;
<a name="l00393"></a>00393 
<a name="l00394"></a>00394             time = nextInBin-&gt;when();
<a name="l00395"></a>00395             priority = nextInBin-&gt;priority();
<a name="l00396"></a>00396 
<a name="l00397"></a>00397             nextInBin = nextInBin-&gt;nextInBin;
<a name="l00398"></a>00398         }
<a name="l00399"></a>00399 
<a name="l00400"></a>00400         nextBin = nextBin-&gt;nextBin;
<a name="l00401"></a>00401     }
<a name="l00402"></a>00402 
<a name="l00403"></a>00403     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00404"></a>00404 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab1b8fc2b2605fdc1d88bf07a86e1fe07"></a><!-- doxytag: member="EventQueue::deschedule" ref="ab1b8fc2b2605fdc1d88bf07a86e1fe07" args="(Event *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deschedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEvent.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deschedule the specified event. Should be called only from the owning thread. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00069"></a>00069 {
<a name="l00070"></a>00070     assert(event-&gt;<a class="code" href="classEvent.html#a9cd69a6b10cb037550943f177a0da688" title="Determine if the current event is scheduled.">scheduled</a>());
<a name="l00071"></a>00071     assert(event-&gt;<a class="code" href="classEvent.html#aa2a7557ebf105cff8a91f2af1511adf0">initialized</a>());
<a name="l00072"></a>00072     assert(!<a class="code" href="eventq_8cc.html#a1a48f421470ff3e6db2b119ab1286b96" title="Current mode of execution: parallel / serial.">inParallelMode</a> || <span class="keyword">this</span> == <a class="code" href="eventq_8hh.html#a64a8603a1af7020a19d30c54152fdcb2">curEventQueue</a>());
<a name="l00073"></a>00073 
<a name="l00074"></a>00074     <span class="keyword">remove</span>(event);
<a name="l00075"></a>00075 
<a name="l00076"></a>00076     <span class="keyword">event</span>-&gt;flags.clear(<a class="code" href="classEventBase.html#aa538a6b12172092ac14b1c53ed0b5623">Event::Squashed</a>);
<a name="l00077"></a>00077     <span class="keyword">event</span>-&gt;flags.clear(<a class="code" href="classEventBase.html#ac1b50e524ba5bdbd010654eae3ef982b">Event::Scheduled</a>);
<a name="l00078"></a>00078 
<a name="l00079"></a>00079     <span class="keywordflow">if</span> (<a class="code" href="trace_8hh.html#af76c9f7776aade1bf9d7dfa8a0c6b341">DTRACE</a>(<a class="code" href="classEvent.html">Event</a>))
<a name="l00080"></a>00080         <span class="keyword">event</span>-&gt;trace(<span class="stringliteral">&quot;descheduled&quot;</span>);
<a name="l00081"></a>00081 
<a name="l00082"></a>00082     <span class="keywordflow">if</span> (event-&gt;<a class="code" href="classEvent.html#aa991e2b209ef26272bf4fd920777bcda">flags</a>.<a class="code" href="classFlags.html#ac976964169b81aaba1d4cbb422f559ca">isSet</a>(<a class="code" href="classEventBase.html#a54ba74dbb445f08c349fc85154f58b97">Event::AutoDelete</a>))
<a name="l00083"></a>00083         <span class="keyword">delete</span> event;
<a name="l00084"></a>00084 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4a4fecb6d7cd9d0b8eb6579eee183af8"></a><!-- doxytag: member="EventQueue::dump" ref="a4a4fecb6d7cd9d0b8eb6579eee183af8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dump </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00341"></a>00341 {
<a name="l00342"></a>00342     <a class="code" href="cprintf_8hh.html#a46231f0e413d30a2560384d0ae05536b">cprintf</a>(<span class="stringliteral">&quot;============================================================\n&quot;</span>);
<a name="l00343"></a>00343     <a class="code" href="cprintf_8hh.html#a46231f0e413d30a2560384d0ae05536b">cprintf</a>(<span class="stringliteral">&quot;EventQueue Dump  (cycle %d)\n&quot;</span>, <a class="code" href="statistics_8hh.html#a7acdccbf0d35ce0c159c0cdd36371b22" title="The universal simulation clock.">curTick</a>());
<a name="l00344"></a>00344     <a class="code" href="cprintf_8hh.html#a46231f0e413d30a2560384d0ae05536b">cprintf</a>(<span class="stringliteral">&quot;------------------------------------------------------------\n&quot;</span>);
<a name="l00345"></a>00345 
<a name="l00346"></a>00346     <span class="keywordflow">if</span> (<a class="code" href="classEventQueue.html#ac6e61de369e994009e36f344f99c15ad">empty</a>())
<a name="l00347"></a>00347         <a class="code" href="cprintf_8hh.html#a46231f0e413d30a2560384d0ae05536b">cprintf</a>(<span class="stringliteral">&quot;&lt;No Events&gt;\n&quot;</span>);
<a name="l00348"></a>00348     <span class="keywordflow">else</span> {
<a name="l00349"></a>00349         Event *nextBin = <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a>;
<a name="l00350"></a>00350         <span class="keywordflow">while</span> (nextBin) {
<a name="l00351"></a>00351             Event *nextInBin = nextBin;
<a name="l00352"></a>00352             <span class="keywordflow">while</span> (nextInBin) {
<a name="l00353"></a>00353                 nextInBin-&gt;dump();
<a name="l00354"></a>00354                 nextInBin = nextInBin-&gt;nextInBin;
<a name="l00355"></a>00355             }
<a name="l00356"></a>00356 
<a name="l00357"></a>00357             nextBin = nextBin-&gt;nextBin;
<a name="l00358"></a>00358         }
<a name="l00359"></a>00359     }
<a name="l00360"></a>00360 
<a name="l00361"></a>00361     <a class="code" href="cprintf_8hh.html#a46231f0e413d30a2560384d0ae05536b">cprintf</a>(<span class="stringliteral">&quot;============================================================\n&quot;</span>);
<a name="l00362"></a>00362 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac6e61de369e994009e36f344f99c15ad"></a><!-- doxytag: member="EventQueue::empty" ref="ac6e61de369e994009e36f344f99c15ad" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00594"></a>00594 { <span class="keywordflow">return</span> <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a> == <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab9e4d6c1f3218aee0ff70854de959a6c"></a><!-- doxytag: member="EventQueue::getCurTick" ref="ab9e4d6c1f3218aee0ff70854de959a6c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> getCurTick </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00568"></a>00568 { <span class="keywordflow">return</span> <a class="code" href="classEventQueue.html#a09b29d670564770f8cde7490c4fa4ebb">_curTick</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2f9d0ed8258183804bc764aa3b859f70"></a><!-- doxytag: member="EventQueue::handleAsyncInsertions" ref="a2f9d0ed8258183804bc764aa3b859f70" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handleAsyncInsertions </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function for moving events from the async_queue to the main queue. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00478"></a>00478 {
<a name="l00479"></a>00479     assert(<span class="keyword">this</span> == <a class="code" href="eventq_8hh.html#a64a8603a1af7020a19d30c54152fdcb2">curEventQueue</a>());
<a name="l00480"></a>00480     <a class="code" href="classEventQueue.html#a7d6bb496422e204e32492a7012a44b66" title="Mutex to protect async queue.">async_queue_mutex</a>-&gt;lock();
<a name="l00481"></a>00481 
<a name="l00482"></a>00482     <span class="keywordflow">while</span> (!<a class="code" href="classEventQueue.html#a9c9b5322e34950b9d27abca2b8207ca9" title="List of events added by other threads to this event queue.">async_queue</a>.empty()) {
<a name="l00483"></a>00483         <a class="code" href="classEventQueue.html#ad8e469f292d876af9e2ec380e8e7e51e">insert</a>(<a class="code" href="classEventQueue.html#a9c9b5322e34950b9d27abca2b8207ca9" title="List of events added by other threads to this event queue.">async_queue</a>.front());
<a name="l00484"></a>00484         <a class="code" href="classEventQueue.html#a9c9b5322e34950b9d27abca2b8207ca9" title="List of events added by other threads to this event queue.">async_queue</a>.pop_front();
<a name="l00485"></a>00485     }
<a name="l00486"></a>00486 
<a name="l00487"></a>00487     <a class="code" href="classEventQueue.html#a7d6bb496422e204e32492a7012a44b66" title="Mutex to protect async queue.">async_queue_mutex</a>-&gt;unlock();
<a name="l00488"></a>00488 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad8e469f292d876af9e2ec380e8e7e51e"></a><!-- doxytag: member="EventQueue::insert" ref="ad8e469f292d876af9e2ec380e8e7e51e" args="(Event *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert </td>
          <td>(</td>
          <td class="paramtype">Event *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert / remove event from the queue. Should only be called by thread operating this queue. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00119"></a>00119 {
<a name="l00120"></a>00120     <span class="comment">// Deal with the head case</span>
<a name="l00121"></a>00121     <span class="keywordflow">if</span> (!<a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a> || *<a class="code" href="namespaceMipsISA.html#aa3b803f4777161a2825178dabfb154f0">event</a> &lt;= *<a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a>) {
<a name="l00122"></a>00122         <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a> = <a class="code" href="classEvent.html#a67dc02b0253a9a268380268612a74b2c">Event::insertBefore</a>(<a class="code" href="namespaceMipsISA.html#aa3b803f4777161a2825178dabfb154f0">event</a>, <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a>);
<a name="l00123"></a>00123         <span class="keywordflow">return</span>;
<a name="l00124"></a>00124     }
<a name="l00125"></a>00125 
<a name="l00126"></a>00126     <span class="comment">// Figure out either which &apos;in bin&apos; list we are on, or where a new list</span>
<a name="l00127"></a>00127     <span class="comment">// needs to be inserted</span>
<a name="l00128"></a>00128     Event *prev = <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a>;
<a name="l00129"></a>00129     Event *curr = <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a>-&gt;nextBin;
<a name="l00130"></a>00130     <span class="keywordflow">while</span> (curr &amp;&amp; *curr &lt; *<a class="code" href="namespaceMipsISA.html#aa3b803f4777161a2825178dabfb154f0">event</a>) {
<a name="l00131"></a>00131         prev = curr;
<a name="l00132"></a>00132         curr = curr-&gt;nextBin;
<a name="l00133"></a>00133     }
<a name="l00134"></a>00134 
<a name="l00135"></a>00135     <span class="comment">// Note: this operation may render all nextBin pointers on the</span>
<a name="l00136"></a>00136     <span class="comment">// prev &apos;in bin&apos; list stale (except for the top one)</span>
<a name="l00137"></a>00137     prev-&gt;nextBin = <a class="code" href="classEvent.html#a67dc02b0253a9a268380268612a74b2c">Event::insertBefore</a>(<a class="code" href="namespaceMipsISA.html#aa3b803f4777161a2825178dabfb154f0">event</a>, curr);
<a name="l00138"></a>00138 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa81aed607133209dade63a226818224d"></a><!-- doxytag: member="EventQueue::lock" ref="aa81aed607133209dade63a226818224d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Provide an interface for locking/unlocking the event queue.</p>
<p>Do NOT use these methods directly unless you really know what you are doing. Incorrect use can easily lead to simulator deadlocks.</p>
<dl class="see"><dt><b>参照:</b></dt><dd><a class="el" href="classEventQueue_1_1ScopedMigration.html">EventQueue::ScopedMigration</a>. </dd>
<dd>
<a class="el" href="classEventQueue_1_1ScopedRelease.html">EventQueue::ScopedRelease</a> </dd>
<dd>
<a class="el" href="classEventQueue.html">EventQueue</a> </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00625"></a>00625 { <a class="code" href="classEventQueue.html#acfc3095049c7deadb02a9eee0ec54a13">service_mutex</a>.lock(); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a413b79e026328fa4210d327d1958bd12"></a><!-- doxytag: member="EventQueue::name" ref="a413b79e026328fa4210d327d1958bd12" args="(const std::string &amp;st)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>st</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00552"></a>00552 { <a class="code" href="classEventQueue.html#acdd07b78b47375ca2a51a7a956b1697f">objName</a> = <a class="code" href="namespaceArmISA.html#ae9ccb60923e03f5112b726ef11e2d299">st</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="adbcff144e5e199d332a1352af1798148"></a><!-- doxytag: member="EventQueue::name" ref="adbcff144e5e199d332a1352af1798148" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string name </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classSerializable.html#a2d319721a65496069642871a52e47056">Serializable</a>を実装しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00551"></a>00551 { <span class="keywordflow">return</span> <a class="code" href="classEventQueue.html#acdd07b78b47375ca2a51a7a956b1697f">objName</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac7fc06f25478db3060a43a096e023243"></a><!-- doxytag: member="EventQueue::nextTick" ref="ac7fc06f25478db3060a43a096e023243" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> nextTick </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00566"></a>00566 { <span class="keywordflow">return</span> <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a>-&gt;<a class="code" href="classEvent.html#a1883243a0117678c5695f2435dcabbdc" title="Get the time that the event is scheduled.">when</a>(); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3f3ea68ae4a3b85263c9e223efcce2f6"></a><!-- doxytag: member="EventQueue::remove" ref="a3f3ea68ae4a3b85263c9e223efcce2f6" args="(Event *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove </td>
          <td>(</td>
          <td class="paramtype">Event *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00173"></a>00173 {
<a name="l00174"></a>00174     <span class="keywordflow">if</span> (<a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a> == <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>)
<a name="l00175"></a>00175         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;event not found!&quot;</span>);
<a name="l00176"></a>00176 
<a name="l00177"></a>00177     assert(<a class="code" href="namespaceMipsISA.html#aa3b803f4777161a2825178dabfb154f0">event</a>-&gt;queue == <span class="keyword">this</span>);
<a name="l00178"></a>00178 
<a name="l00179"></a>00179     <span class="comment">// deal with an event on the head&apos;s &apos;in bin&apos; list (event has the same</span>
<a name="l00180"></a>00180     <span class="comment">// time as the head)</span>
<a name="l00181"></a>00181     <span class="keywordflow">if</span> (*<a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a> == *<a class="code" href="namespaceMipsISA.html#aa3b803f4777161a2825178dabfb154f0">event</a>) {
<a name="l00182"></a>00182         <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a> = <a class="code" href="classEvent.html#a3b97c26403aff54eb1a4e05de0124ea5">Event::removeItem</a>(<a class="code" href="namespaceMipsISA.html#aa3b803f4777161a2825178dabfb154f0">event</a>, <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a>);
<a name="l00183"></a>00183         <span class="keywordflow">return</span>;
<a name="l00184"></a>00184     }
<a name="l00185"></a>00185 
<a name="l00186"></a>00186     <span class="comment">// Find the &apos;in bin&apos; list that this event belongs on</span>
<a name="l00187"></a>00187     Event *prev = <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a>;
<a name="l00188"></a>00188     Event *curr = <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a>-&gt;nextBin;
<a name="l00189"></a>00189     <span class="keywordflow">while</span> (curr &amp;&amp; *curr &lt; *<a class="code" href="namespaceMipsISA.html#aa3b803f4777161a2825178dabfb154f0">event</a>) {
<a name="l00190"></a>00190         prev = curr;
<a name="l00191"></a>00191         curr = curr-&gt;nextBin;
<a name="l00192"></a>00192     }
<a name="l00193"></a>00193 
<a name="l00194"></a>00194     <span class="keywordflow">if</span> (!curr || *curr != *<a class="code" href="namespaceMipsISA.html#aa3b803f4777161a2825178dabfb154f0">event</a>)
<a name="l00195"></a>00195         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;event not found!&quot;</span>);
<a name="l00196"></a>00196 
<a name="l00197"></a>00197     <span class="comment">// curr points to the top item of the the correct &apos;in bin&apos; list, when</span>
<a name="l00198"></a>00198     <span class="comment">// we remove an item, it returns the new top item (which may be</span>
<a name="l00199"></a>00199     <span class="comment">// unchanged)</span>
<a name="l00200"></a>00200     prev-&gt;nextBin = <a class="code" href="classEvent.html#a3b97c26403aff54eb1a4e05de0124ea5">Event::removeItem</a>(<a class="code" href="namespaceMipsISA.html#aa3b803f4777161a2825178dabfb154f0">event</a>, curr);
<a name="l00201"></a>00201 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1c4b36385e86f178f625f84d95cb6778"></a><!-- doxytag: member="EventQueue::replaceHead" ref="a1c4b36385e86f178f625f84d95cb6778" args="(Event *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Event * replaceHead </td>
          <td>(</td>
          <td class="paramtype">Event *&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>function for replacing the head of the event queue, so that a different set of events can run without disturbing events that have already been scheduled. Already scheduled events can be processed by replacing the original head back. USING THIS FUNCTION CAN BE DANGEROUS TO THE HEALTH OF THE SIMULATOR. NOT RECOMMENDED FOR USE. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00408"></a>00408 {
<a name="l00409"></a>00409     Event* <a class="code" href="namespaceArmISA.html#af5dfd7e551f8c5b461816e813dab252f">t</a> = <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a>;
<a name="l00410"></a>00410     <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a> = <a class="code" href="namespaceArmISA.html#afaeb18e17f862d8fcb76dfb68a18854f">s</a>;
<a name="l00411"></a>00411     <span class="keywordflow">return</span> t;
<a name="l00412"></a>00412 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a676294f5f01031f3dfdf956185390db8"></a><!-- doxytag: member="EventQueue::reschedule" ref="a676294f5f01031f3dfdf956185390db8" args="(Event *event, Tick when, bool always=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reschedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEvent.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td>
          <td class="paramname"> <em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>always</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reschedule the specified event. Should be called only from the owning thread. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00088"></a>00088 {
<a name="l00089"></a>00089     assert(when &gt;= <a class="code" href="classEventQueue.html#ab9e4d6c1f3218aee0ff70854de959a6c">getCurTick</a>());
<a name="l00090"></a>00090     assert(always || event-&gt;<a class="code" href="classEvent.html#a9cd69a6b10cb037550943f177a0da688" title="Determine if the current event is scheduled.">scheduled</a>());
<a name="l00091"></a>00091     assert(event-&gt;<a class="code" href="classEvent.html#aa2a7557ebf105cff8a91f2af1511adf0">initialized</a>());
<a name="l00092"></a>00092     assert(!<a class="code" href="eventq_8cc.html#a1a48f421470ff3e6db2b119ab1286b96" title="Current mode of execution: parallel / serial.">inParallelMode</a> || <span class="keyword">this</span> == <a class="code" href="eventq_8hh.html#a64a8603a1af7020a19d30c54152fdcb2">curEventQueue</a>());
<a name="l00093"></a>00093 
<a name="l00094"></a>00094     <span class="keywordflow">if</span> (event-&gt;<a class="code" href="classEvent.html#a9cd69a6b10cb037550943f177a0da688" title="Determine if the current event is scheduled.">scheduled</a>())
<a name="l00095"></a>00095         <span class="keyword">remove</span>(event);
<a name="l00096"></a>00096 
<a name="l00097"></a>00097     <span class="keyword">event</span>-&gt;setWhen(when, <span class="keyword">this</span>);
<a name="l00098"></a>00098     <a class="code" href="classEventQueue.html#ad8e469f292d876af9e2ec380e8e7e51e">insert</a>(event);
<a name="l00099"></a>00099     <span class="keyword">event</span>-&gt;flags.clear(<a class="code" href="classEventBase.html#aa538a6b12172092ac14b1c53ed0b5623">Event::Squashed</a>);
<a name="l00100"></a>00100     <span class="keyword">event</span>-&gt;flags.set(<a class="code" href="classEventBase.html#ac1b50e524ba5bdbd010654eae3ef982b">Event::Scheduled</a>);
<a name="l00101"></a>00101 
<a name="l00102"></a>00102     <span class="keywordflow">if</span> (<a class="code" href="trace_8hh.html#af76c9f7776aade1bf9d7dfa8a0c6b341">DTRACE</a>(<a class="code" href="classEvent.html">Event</a>))
<a name="l00103"></a>00103         <span class="keyword">event</span>-&gt;trace(<span class="stringliteral">&quot;rescheduled&quot;</span>);
<a name="l00104"></a>00104 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6e13c0d68fbc26df6eff27313813b8a4"></a><!-- doxytag: member="EventQueue::schedule" ref="a6e13c0d68fbc26df6eff27313813b8a4" args="(Event *event, Tick when, bool global=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEvent.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td>
          <td class="paramname"> <em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>global</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Schedule the given event on this queue. Safe to call from any thread. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00043"></a>00043 {
<a name="l00044"></a>00044     assert(when &gt;= <a class="code" href="classEventQueue.html#ab9e4d6c1f3218aee0ff70854de959a6c">getCurTick</a>());
<a name="l00045"></a>00045     assert(!event-&gt;<a class="code" href="classEvent.html#a9cd69a6b10cb037550943f177a0da688" title="Determine if the current event is scheduled.">scheduled</a>());
<a name="l00046"></a>00046     assert(event-&gt;<a class="code" href="classEvent.html#aa2a7557ebf105cff8a91f2af1511adf0">initialized</a>());
<a name="l00047"></a>00047 
<a name="l00048"></a>00048     <span class="keyword">event</span>-&gt;setWhen(when, <span class="keyword">this</span>);
<a name="l00049"></a>00049 
<a name="l00050"></a>00050     <span class="comment">// The check below is to make sure of two things</span>
<a name="l00051"></a>00051     <span class="comment">// a. a thread schedules local events on other queues through the asyncq</span>
<a name="l00052"></a>00052     <span class="comment">// b. a thread schedules global events on the asyncq, whether or not</span>
<a name="l00053"></a>00053     <span class="comment">//    this event belongs to this eventq. This is required to maintain</span>
<a name="l00054"></a>00054     <span class="comment">//    a total order amongst the global events. See global_event.{cc,hh}</span>
<a name="l00055"></a>00055     <span class="comment">//    for more explanation.</span>
<a name="l00056"></a>00056     <span class="keywordflow">if</span> (<a class="code" href="eventq_8cc.html#a1a48f421470ff3e6db2b119ab1286b96" title="Current mode of execution: parallel / serial.">inParallelMode</a> &amp;&amp; (<span class="keyword">this</span> != <a class="code" href="eventq_8hh.html#a64a8603a1af7020a19d30c54152fdcb2">curEventQueue</a>() || global)) {
<a name="l00057"></a>00057         <a class="code" href="classEventQueue.html#aadb31d9952f03cb2a934f93cac304153">asyncInsert</a>(event);
<a name="l00058"></a>00058     } <span class="keywordflow">else</span> {
<a name="l00059"></a>00059         <a class="code" href="classEventQueue.html#ad8e469f292d876af9e2ec380e8e7e51e">insert</a>(event);
<a name="l00060"></a>00060     }
<a name="l00061"></a>00061     <span class="keyword">event</span>-&gt;flags.set(<a class="code" href="classEventBase.html#ac1b50e524ba5bdbd010654eae3ef982b">Event::Scheduled</a>);
<a name="l00062"></a>00062 
<a name="l00063"></a>00063     <span class="keywordflow">if</span> (<a class="code" href="trace_8hh.html#af76c9f7776aade1bf9d7dfa8a0c6b341">DTRACE</a>(<a class="code" href="classEvent.html">Event</a>))
<a name="l00064"></a>00064         <span class="keyword">event</span>-&gt;trace(<span class="stringliteral">&quot;scheduled&quot;</span>);
<a name="l00065"></a>00065 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad6272f80ae37e8331e3969b3f072a801"></a><!-- doxytag: member="EventQueue::serialize" ref="ad6272f80ae37e8331e3969b3f072a801" args="(std::ostream &amp;os)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void serialize </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classSerializable.html#ad6272f80ae37e8331e3969b3f072a801">Serializable</a>を再定義しています。</p>

</div>
</div>
<a class="anchor" id="adc925eabe90846085072915cc6c544c2"></a><!-- doxytag: member="EventQueue::serviceEvents" ref="adc925eabe90846085072915cc6c544c2" args="(Tick when)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serviceEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td>
          <td class="paramname"> <em>when</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000091">TODO:</a></b></dt><dd>this assert is a good bug catcher. I need to make it true again. </dd></dl>
</p>

<p><div class="fragment"><pre class="fragment"><a name="l00577"></a>00577     {
<a name="l00578"></a>00578         <span class="keywordflow">while</span> (!<a class="code" href="classEventQueue.html#ac6e61de369e994009e36f344f99c15ad">empty</a>()) {
<a name="l00579"></a>00579             <span class="keywordflow">if</span> (<a class="code" href="classEventQueue.html#ac7fc06f25478db3060a43a096e023243">nextTick</a>() &gt; when)
<a name="l00580"></a>00580                 <span class="keywordflow">break</span>;
<a name="l00581"></a>00581 
<a name="l00586"></a>00586             <span class="comment">//assert(head-&gt;when() &gt;= when &amp;&amp; &quot;event scheduled in the past&quot;);</span>
<a name="l00587"></a>00587             <a class="code" href="classEventQueue.html#a95b9c78d6fb18e716e5d13362b609798">serviceOne</a>();
<a name="l00588"></a>00588         }
<a name="l00589"></a>00589 
<a name="l00590"></a>00590         <a class="code" href="classEventQueue.html#abc2f41fbb4828612a2637268ab8ce640">setCurTick</a>(when);
<a name="l00591"></a>00591     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a95b9c78d6fb18e716e5d13362b609798"></a><!-- doxytag: member="EventQueue::serviceOne" ref="a95b9c78d6fb18e716e5d13362b609798" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Event * serviceOne </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00205"></a>00205 {
<a name="l00206"></a>00206     std::lock_guard&lt;EventQueue&gt; <a class="code" href="classEventQueue.html#aa81aed607133209dade63a226818224d">lock</a>(*<span class="keyword">this</span>);
<a name="l00207"></a>00207     Event *<span class="keyword">event</span> = <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a>;
<a name="l00208"></a>00208     Event *next = <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a>-&gt;nextInBin;
<a name="l00209"></a>00209     <span class="keyword">event</span>-&gt;flags.clear(<a class="code" href="classEventBase.html#ac1b50e524ba5bdbd010654eae3ef982b">Event::Scheduled</a>);
<a name="l00210"></a>00210 
<a name="l00211"></a>00211     <span class="keywordflow">if</span> (next) {
<a name="l00212"></a>00212         <span class="comment">// update the next bin pointer since it could be stale</span>
<a name="l00213"></a>00213         next-&gt;nextBin = <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a>-&gt;nextBin;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215         <span class="comment">// pop the stack</span>
<a name="l00216"></a>00216         <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a> = next;
<a name="l00217"></a>00217     } <span class="keywordflow">else</span> {
<a name="l00218"></a>00218         <span class="comment">// this was the only element on the &apos;in bin&apos; list, so get rid of</span>
<a name="l00219"></a>00219         <span class="comment">// the &apos;in bin&apos; list and point to the next bin list</span>
<a name="l00220"></a>00220         <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a> = <a class="code" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a>-&gt;nextBin;
<a name="l00221"></a>00221     }
<a name="l00222"></a>00222 
<a name="l00223"></a>00223     <span class="comment">// handle action</span>
<a name="l00224"></a>00224     <span class="keywordflow">if</span> (!<a class="code" href="namespaceMipsISA.html#aa3b803f4777161a2825178dabfb154f0">event</a>-&gt;squashed()) {
<a name="l00225"></a>00225         <span class="comment">// forward current cycle to the time when this event occurs.</span>
<a name="l00226"></a>00226         <a class="code" href="classEventQueue.html#abc2f41fbb4828612a2637268ab8ce640">setCurTick</a>(<a class="code" href="namespaceMipsISA.html#aa3b803f4777161a2825178dabfb154f0">event</a>-&gt;when());
<a name="l00227"></a>00227 
<a name="l00228"></a>00228         <span class="keyword">event</span>-&gt;process();
<a name="l00229"></a>00229         <span class="keywordflow">if</span> (<a class="code" href="namespaceMipsISA.html#aa3b803f4777161a2825178dabfb154f0">event</a>-&gt;isExitEvent()) {
<a name="l00230"></a>00230             assert(!<a class="code" href="namespaceMipsISA.html#aa3b803f4777161a2825178dabfb154f0">event</a>-&gt;flags.isSet(<a class="code" href="classEventBase.html#a54ba74dbb445f08c349fc85154f58b97">Event::AutoDelete</a>) ||
<a name="l00231"></a>00231                    !<span class="keyword">event</span>-&gt;flags.isSet(<a class="code" href="classEventBase.html#a3ab0ae5852588928a5c60a6543a3db49">Event::IsMainQueue</a>)); <span class="comment">// would be silly</span>
<a name="l00232"></a>00232             <span class="keywordflow">return</span> <a class="code" href="namespaceMipsISA.html#aa3b803f4777161a2825178dabfb154f0">event</a>;
<a name="l00233"></a>00233         }
<a name="l00234"></a>00234     } <span class="keywordflow">else</span> {
<a name="l00235"></a>00235         <span class="keyword">event</span>-&gt;flags.clear(<a class="code" href="classEventBase.html#aa538a6b12172092ac14b1c53ed0b5623">Event::Squashed</a>);
<a name="l00236"></a>00236     }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238     <span class="keywordflow">if</span> (<a class="code" href="namespaceMipsISA.html#aa3b803f4777161a2825178dabfb154f0">event</a>-&gt;flags.isSet(<a class="code" href="classEventBase.html#a54ba74dbb445f08c349fc85154f58b97">Event::AutoDelete</a>) &amp;&amp; !<span class="keyword">event</span>-&gt;scheduled())
<a name="l00239"></a>00239         <span class="keyword">delete</span> <a class="code" href="namespaceMipsISA.html#aa3b803f4777161a2825178dabfb154f0">event</a>;
<a name="l00240"></a>00240 
<a name="l00241"></a>00241     <span class="keywordflow">return</span> <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00242"></a>00242 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abc2f41fbb4828612a2637268ab8ce640"></a><!-- doxytag: member="EventQueue::setCurTick" ref="abc2f41fbb4828612a2637268ab8ce640" args="(Tick newVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setCurTick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td>
          <td class="paramname"> <em>newVal</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00567"></a>00567 { <a class="code" href="classEventQueue.html#a09b29d670564770f8cde7490c4fa4ebb">_curTick</a> = newVal; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9278be8203e1c42e2619179882ae4403"></a><!-- doxytag: member="EventQueue::unlock" ref="a9278be8203e1c42e2619179882ae4403" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unlock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00626"></a>00626 { <a class="code" href="classEventQueue.html#acfc3095049c7deadb02a9eee0ec54a13">service_mutex</a>.unlock(); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af22e5d6d660b97db37003ac61ac4ee49"></a><!-- doxytag: member="EventQueue::unserialize" ref="af22e5d6d660b97db37003ac61ac4ee49" args="(Checkpoint *cp, const std::string &amp;section)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unserialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCheckpoint.html">Checkpoint</a> *&nbsp;</td>
          <td class="paramname"> <em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>section</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classSerializable.html#af100c4e9feabf3cd918619c88c718387">Serializable</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00325"></a>00325 {
<a name="l00326"></a>00326     <span class="keywordtype">int</span> numEvents;
<a name="l00327"></a>00327     <a class="code" href="serialize_8hh.html#a13d18ccba3d8bcbcd5aab2e37c380bff">UNSERIALIZE_SCALAR</a>(numEvents);
<a name="l00328"></a>00328 
<a name="l00329"></a>00329     std::string eventName;
<a name="l00330"></a>00330     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> = 0; <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> &lt; numEvents; <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>++) {
<a name="l00331"></a>00331         <span class="comment">// get the pointer value associated with the event</span>
<a name="l00332"></a>00332         <a class="code" href="arch_2x86_2types_8cc.html#a2c99d2d69578d585494e1182085cb158">paramIn</a>(cp, section, <a class="code" href="cprintf_8hh.html#ace22d1c39f2df58e593bc49d1613eca2">csprintf</a>(<span class="stringliteral">&quot;event%d&quot;</span>, <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>), eventName);
<a name="l00333"></a>00333 
<a name="l00334"></a>00334         <span class="comment">// create the event based on its pointer value</span>
<a name="l00335"></a>00335         <a class="code" href="classSerializable.html#aeba0ff4f3274e6aa0886adc5af90e371">Serializable::create</a>(cp, eventName);
<a name="l00336"></a>00336     }
<a name="l00337"></a>00337 }
</pre></div></p>

</div>
</div>
<hr/><h2>変数</h2>
<a class="anchor" id="a09b29d670564770f8cde7490c4fa4ebb"></a><!-- doxytag: member="EventQueue::_curTick" ref="a09b29d670564770f8cde7490c4fa4ebb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> <a class="el" href="classEventQueue.html#a09b29d670564770f8cde7490c4fa4ebb">_curTick</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c9b5322e34950b9d27abca2b8207ca9"></a><!-- doxytag: member="EventQueue::async_queue" ref="a9c9b5322e34950b9d27abca2b8207ca9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1list.html">std::list</a>&lt;<a class="el" href="classEvent.html">Event</a>*&gt; <a class="el" href="classEventQueue.html#a9c9b5322e34950b9d27abca2b8207ca9">async_queue</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List of events added by other threads to this event queue. </p>

</div>
</div>
<a class="anchor" id="a7d6bb496422e204e32492a7012a44b66"></a><!-- doxytag: member="EventQueue::async_queue_mutex" ref="a7d6bb496422e204e32492a7012a44b66" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex* <a class="el" href="classEventQueue.html#a7d6bb496422e204e32492a7012a44b66">async_queue_mutex</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mutex to protect async queue. </p>

</div>
</div>
<a class="anchor" id="a08321f57dbffd90b5b365a6d53bb2933"></a><!-- doxytag: member="EventQueue::head" ref="a08321f57dbffd90b5b365a6d53bb2933" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEvent.html">Event</a>* <a class="el" href="classEventQueue.html#a08321f57dbffd90b5b365a6d53bb2933">head</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acdd07b78b47375ca2a51a7a956b1697f"></a><!-- doxytag: member="EventQueue::objName" ref="acdd07b78b47375ca2a51a7a956b1697f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classEventQueue.html#acdd07b78b47375ca2a51a7a956b1697f">objName</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acfc3095049c7deadb02a9eee0ec54a13"></a><!-- doxytag: member="EventQueue::service_mutex" ref="acfc3095049c7deadb02a9eee0ec54a13" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex <a class="el" href="classEventQueue.html#acfc3095049c7deadb02a9eee0ec54a13">service_mutex</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lock protecting event handling.</p>
<p>This lock is always taken when servicing events. It is assumed that the thread scheduling new events (not asynchronous events though) have taken this lock. This is normally done by <a class="el" href="classEventQueue.html#a95b9c78d6fb18e716e5d13362b609798">serviceOne()</a> since new events are typically scheduled as a response to an earlier event.</p>
<p>This lock is intended to be used to temporarily steal an event queue to support inter-thread communication when some deterministic timing can be sacrificed for speed. For example, the KVM CPU can use this support to access devices running in a different thread.</p>
<dl class="see"><dt><b>参照:</b></dt><dd><a class="el" href="classEventQueue_1_1ScopedMigration.html">EventQueue::ScopedMigration</a>. </dd>
<dd>
<a class="el" href="classEventQueue_1_1ScopedRelease.html">EventQueue::ScopedRelease</a> </dd>
<dd>
<a class="el" href="classEventQueue.html#aa81aed607133209dade63a226818224d">EventQueue::lock()</a> </dd>
<dd>
<a class="el" href="classEventQueue.html#a9278be8203e1c42e2619179882ae4403">EventQueue::unlock()</a> </dd></dl>

</div>
</div>
<hr/>このクラスの説明は次のファイルから生成されました:<ul>
<li>sim/<a class="el" href="eventq_8hh_source.html">eventq.hh</a></li>
<li>sim/<a class="el" href="eventq_8cc.html">eventq.cc</a></li>
<li>sim/<a class="el" href="eventq__impl_8hh_source.html">eventq_impl.hh</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>File&nbsp;GEM5&nbsp;Wrapperに対して25 May 2015に生成されました。&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
