\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type}{
\section{クラス Type}
\label{classslicc_1_1symbols_1_1Type_1_1Type}\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
}
Typeに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classslicc_1_1symbols_1_1Type_1_1Type}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_ac775ee34451fdfa742b318538164070e}{\_\-\_\-init\_\-\_\-}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a45a24d63484ab10bacd544457ba77ecb}{isPrimitive}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_aae25790df73780663d6afb3a7262665b}{isNetworkMessage}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a94bbf26edb7ac380f1b61e99fb45ffcf}{isMessage}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a83f4c7e23ed4de9a67fecb39999eeb80}{isBuffer}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a4ecffdf0fe4cb90efbaa76c057a77741}{isInPort}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a2095c07646682ecf212fb564006b19be}{isOutPort}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_aae5f64366a63e72db2c8f64804d9d48d}{isEnumeration}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_acc588405cef959f9be9b93c1ec0f2bf6}{isExternal}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_ac99cb31b54c2509026d0986ed8cee4b0}{isGlobal}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_aaf86a09de159b229b176e309e7435eaf}{isInterface}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a5fd45667498cb27660b6d124a7a6d297}{addDataMember}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_aba05d1e636b4a17dc3fed9f793f31fd3}{dataMemberType}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a4ce953072a7b02c852dbd0346bcc6c68}{methodId}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_ac0ea819ac12c659bd705db3a351250b9}{methodIdAbstract}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_aaa063dc393243eb5ac92a55c327f52de}{statePermPairAdd}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_aee4a8b4b7ae064aa9fa7ba2b8730f4ab}{addMethod}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a8d499326f557cbeadeab18a84e8e0dc6}{addFunc}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a31680a177e9d9fc678268e1723eb3906}{addEnum}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a69d0582bde832d4ff45237ab5ff116bb}{writeCodeFiles}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a8356760e8bd592caebf1bf1311a8f155}{printTypeHH}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a0cbb701d52cf06208a07b0be78c34f20}{printTypeCC}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a68a10b43efa85532b2fc228a09fce916}{printEnumHH}
\item 
def \hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a6c3213bf8871a93a4a2dc1baef9bd3fd}{printEnumCC}
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a4bbd0f8fedcfccc594b11a2023a02baf}{c\_\-ident}
\item 
\hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a77596d09f6f44326ec9319be21ed940b}{abstract\_\-ident}
\item 
\hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a2fe57e2d3d2cba9a3aeba2f629eaa78b}{ident}
\item 
\hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a91c52361042163180aebc6e66c9a64cc}{isMachineType}
\item 
\hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a4f655e08ddc24df9b8a195e4f8bcd05b}{isStateDecl}
\item 
\hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_ab34027f333316c336b0af3882bcc50a1}{statePermPairs}
\item 
\hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a60153280eb566a852b59144dfb05917f}{data\_\-members}
\item 
\hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a33d390b3d71a902ec9fbcd5d2d237619}{methods}
\item 
\hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a2cb6c540c07a402759bab624703ecdb2}{functions}
\item 
\hyperlink{classslicc_1_1symbols_1_1Type_1_1Type_a7f55aaec2cde309a6d7dea2404aadc33}{enums}
\end{DoxyCompactItemize}


\subsection{関数}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_ac775ee34451fdfa742b318538164070e}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!\_\-\_\-init\_\-\_\-@{\_\-\_\-init\_\-\_\-}}
\index{\_\-\_\-init\_\-\_\-@{\_\-\_\-init\_\-\_\-}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{\_\-\_\-init\_\-\_\-}]{\setlength{\rightskip}{0pt plus 5cm}def \_\-\_\-init\_\-\_\- ( {\em self}, \/   {\em table}, \/   {\em ident}, \/   {\em location}, \/   {\em pairs}, \/   {\em machine} = {\ttfamily None})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_ac775ee34451fdfa742b318538164070e}



\begin{DoxyCode}
52                                                                    :
53         super(Type, self).__init__(table, ident, location, pairs)
54         self.c_ident = ident
55         self.abstract_ident = ""
56         if machine:
57             if self.isExternal or self.isPrimitive:
58                 if "external_name" in self:
59                     self.c_ident = self["external_name"]
60             else:
61                 # Append with machine name
62                 self.c_ident = "%s_%s" % (machine, ident)
63 
64         self.pairs.setdefault("desc", "No description avaliable")
65 
66         # check for interface that this Type implements
67         if "interface" in self:
68             interface = self["interface"]
69             if interface in ("Message", "NetworkMessage"):
70                 self["message"] = "yes"
71             if interface == "NetworkMessage":
72                 self["networkmessage"] = "yes"
73 
74         # FIXME - all of the following id comparisons are fragile hacks
75         if self.ident in ("CacheMemory"):
76             self["cache"] = "yes"
77 
78         if self.ident in ("TBETable"):
79             self["tbe"] = "yes"
80 
81         if self.ident == "TimerTable":
82             self["timer"] = "yes"
83 
84         if self.ident == "DirectoryMemory":
85             self["dir"] = "yes"
86 
87         if self.ident == "PersistentTable":
88             self["persistent"] = "yes"
89 
90         if self.ident == "Prefetcher":
91             self["prefetcher"] = "yes"
92 
93         self.isMachineType = (ident == "MachineType")
94 
95         self.isStateDecl = ("state_decl" in self)
96         self.statePermPairs = []
97 
98         self.data_members = orderdict()
99 
100         # Methods
101         self.methods = {}
102         self.functions = {}
103 
104         # Enums
105         self.enums = orderdict()
106 
107     @property
    def isPrimitive(self):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a5fd45667498cb27660b6d124a7a6d297}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!addDataMember@{addDataMember}}
\index{addDataMember@{addDataMember}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{addDataMember}]{\setlength{\rightskip}{0pt plus 5cm}def addDataMember ( {\em self}, \/   {\em ident}, \/   {\em type}, \/   {\em pairs}, \/   {\em init\_\-code})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a5fd45667498cb27660b6d124a7a6d297}



\begin{DoxyCode}
139                                                           :
140         if ident in self.data_members:
141             return False
142 
143         member = DataMember(ident, type, pairs, init_code)
144         self.data_members[ident] = member
145 
146         var = Var(self.symtab, ident, self.location, type,
147                 "m_%s" % ident, {}, None)
148         self.symtab.registerSym(ident, var)
149         return True
150 
    def dataMemberType(self, ident):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a31680a177e9d9fc678268e1723eb3906}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!addEnum@{addEnum}}
\index{addEnum@{addEnum}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{addEnum}]{\setlength{\rightskip}{0pt plus 5cm}def addEnum ( {\em self}, \/   {\em ident}, \/   {\em pairs})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a31680a177e9d9fc678268e1723eb3906}



\begin{DoxyCode}
182                                    :
183         if ident in self.enums:
184             return False
185 
186         self.enums[ident] = Enumeration(ident, pairs)
187 
188         # Add default
189         if "default" not in self:
190             self["default"] = "%s_NUM" % self.c_ident
191 
192         return True
193 
    def writeCodeFiles(self, path, includes):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a8d499326f557cbeadeab18a84e8e0dc6}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!addFunc@{addFunc}}
\index{addFunc@{addFunc}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{addFunc}]{\setlength{\rightskip}{0pt plus 5cm}def addFunc ( {\em self}, \/   {\em func})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a8d499326f557cbeadeab18a84e8e0dc6}



\begin{DoxyCode}
174                            :
175         ident = self.methodId(func.ident, func.param_types)
176         if ident in self.functions:
177             return False
178 
179         self.functions[ident] = func
180         return True
181 
    def addEnum(self, ident, pairs):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_aee4a8b4b7ae064aa9fa7ba2b8730f4ab}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!addMethod@{addMethod}}
\index{addMethod@{addMethod}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{addMethod}]{\setlength{\rightskip}{0pt plus 5cm}def addMethod ( {\em self}, \/   {\em name}, \/   {\em return\_\-type}, \/   {\em param\_\-type\_\-vec})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_aee4a8b4b7ae064aa9fa7ba2b8730f4ab}



\begin{DoxyCode}
163                                                           :
164         ident = self.methodId(name, param_type_vec)
165         if ident in self.methods:
166             return False
167 
168         self.methods[ident] = Method(return_type, param_type_vec)
169         return True
170 
171     # Ideally either this function or the one above should exist. But
172     # methods and functions have different structures right now.
173     # Hence, these are different, at least for the time being.
    def addFunc(self, func):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_aba05d1e636b4a17dc3fed9f793f31fd3}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!dataMemberType@{dataMemberType}}
\index{dataMemberType@{dataMemberType}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{dataMemberType}]{\setlength{\rightskip}{0pt plus 5cm}def dataMemberType ( {\em self}, \/   {\em ident})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_aba05d1e636b4a17dc3fed9f793f31fd3}



\begin{DoxyCode}
151                                    :
152         return self.data_members[ident].type
153 
    def methodId(self, name, param_type_vec):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a83f4c7e23ed4de9a67fecb39999eeb80}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!isBuffer@{isBuffer}}
\index{isBuffer@{isBuffer}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{isBuffer}]{\setlength{\rightskip}{0pt plus 5cm}def isBuffer ( {\em self})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a83f4c7e23ed4de9a67fecb39999eeb80}



\begin{DoxyCode}
117                       :
118         return "buffer" in self
119     @property
    def isInPort(self):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_aae5f64366a63e72db2c8f64804d9d48d}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!isEnumeration@{isEnumeration}}
\index{isEnumeration@{isEnumeration}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{isEnumeration}]{\setlength{\rightskip}{0pt plus 5cm}def isEnumeration ( {\em self})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_aae5f64366a63e72db2c8f64804d9d48d}



\begin{DoxyCode}
126                            :
127         return "enumeration" in self
128     @property
    def isExternal(self):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_acc588405cef959f9be9b93c1ec0f2bf6}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!isExternal@{isExternal}}
\index{isExternal@{isExternal}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{isExternal}]{\setlength{\rightskip}{0pt plus 5cm}def isExternal ( {\em self})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_acc588405cef959f9be9b93c1ec0f2bf6}



\begin{DoxyCode}
129                         :
130         return "external" in self
131     @property
    def isGlobal(self):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_ac99cb31b54c2509026d0986ed8cee4b0}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!isGlobal@{isGlobal}}
\index{isGlobal@{isGlobal}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{isGlobal}]{\setlength{\rightskip}{0pt plus 5cm}def isGlobal ( {\em self})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_ac99cb31b54c2509026d0986ed8cee4b0}



\begin{DoxyCode}
132                       :
133         return "global" in self
134     @property
    def isInterface(self):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a4ecffdf0fe4cb90efbaa76c057a77741}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!isInPort@{isInPort}}
\index{isInPort@{isInPort}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{isInPort}]{\setlength{\rightskip}{0pt plus 5cm}def isInPort ( {\em self})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a4ecffdf0fe4cb90efbaa76c057a77741}



\begin{DoxyCode}
120                       :
121         return "inport" in self
122     @property
    def isOutPort(self):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_aaf86a09de159b229b176e309e7435eaf}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!isInterface@{isInterface}}
\index{isInterface@{isInterface}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{isInterface}]{\setlength{\rightskip}{0pt plus 5cm}def isInterface ( {\em self})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_aaf86a09de159b229b176e309e7435eaf}



\begin{DoxyCode}
135                          :
136         return "interface" in self
137 
138     # Return false on error
    def addDataMember(self, ident, type, pairs, init_code):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a94bbf26edb7ac380f1b61e99fb45ffcf}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!isMessage@{isMessage}}
\index{isMessage@{isMessage}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{isMessage}]{\setlength{\rightskip}{0pt plus 5cm}def isMessage ( {\em self})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a94bbf26edb7ac380f1b61e99fb45ffcf}



\begin{DoxyCode}
114                        :
115         return "message" in self
116     @property
    def isBuffer(self):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_aae25790df73780663d6afb3a7262665b}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!isNetworkMessage@{isNetworkMessage}}
\index{isNetworkMessage@{isNetworkMessage}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{isNetworkMessage}]{\setlength{\rightskip}{0pt plus 5cm}def isNetworkMessage ( {\em self})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_aae25790df73780663d6afb3a7262665b}



\begin{DoxyCode}
111                               :
112         return "networkmessage" in self
113     @property
    def isMessage(self):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a2095c07646682ecf212fb564006b19be}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!isOutPort@{isOutPort}}
\index{isOutPort@{isOutPort}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{isOutPort}]{\setlength{\rightskip}{0pt plus 5cm}def isOutPort ( {\em self})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a2095c07646682ecf212fb564006b19be}



\begin{DoxyCode}
123                        :
124         return "outport" in self
125     @property
    def isEnumeration(self):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a45a24d63484ab10bacd544457ba77ecb}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!isPrimitive@{isPrimitive}}
\index{isPrimitive@{isPrimitive}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{isPrimitive}]{\setlength{\rightskip}{0pt plus 5cm}def isPrimitive ( {\em self})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a45a24d63484ab10bacd544457ba77ecb}



\begin{DoxyCode}
108                          :
109         return "primitive" in self
110     @property
    def isNetworkMessage(self):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a4ce953072a7b02c852dbd0346bcc6c68}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!methodId@{methodId}}
\index{methodId@{methodId}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{methodId}]{\setlength{\rightskip}{0pt plus 5cm}def methodId ( {\em self}, \/   {\em name}, \/   {\em param\_\-type\_\-vec})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a4ce953072a7b02c852dbd0346bcc6c68}



\begin{DoxyCode}
154                                             :
155         return '_'.join([name] + [ pt.c_ident for pt in param_type_vec ])
156 
    def methodIdAbstract(self, name, param_type_vec):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_ac0ea819ac12c659bd705db3a351250b9}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!methodIdAbstract@{methodIdAbstract}}
\index{methodIdAbstract@{methodIdAbstract}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{methodIdAbstract}]{\setlength{\rightskip}{0pt plus 5cm}def methodIdAbstract ( {\em self}, \/   {\em name}, \/   {\em param\_\-type\_\-vec})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_ac0ea819ac12c659bd705db3a351250b9}



\begin{DoxyCode}
157                                                     :
158         return '_'.join([name] + [ pt.abstract_ident for pt in param_type_vec ])
159 
    def statePermPairAdd(self, state_name, perm_name):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a6c3213bf8871a93a4a2dc1baef9bd3fd}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!printEnumCC@{printEnumCC}}
\index{printEnumCC@{printEnumCC}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{printEnumCC}]{\setlength{\rightskip}{0pt plus 5cm}def printEnumCC ( {\em self}, \/   {\em path})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a6c3213bf8871a93a4a2dc1baef9bd3fd}



\begin{DoxyCode}
544                                :
545         code = self.symtab.codeFormatter()
546         code('''
547 /** \\file ${{self.c_ident}}.hh
548  *
549  * Auto generated C++ code started by $__file__:$__line__
550  */
551 
552 #include <cassert>
553 #include <iostream>
554 #include <string>
555 
556 #include "base/misc.hh"
557 #include "mem/protocol/${{self.c_ident}}.hh"
558 
559 using namespace std;
560 
561 ''')
562 
563         if self.isStateDecl:
564             code('''
565 // Code to convert the current state to an access permission
566 AccessPermission ${{self.c_ident}}_to_permission(const ${{self.c_ident}}& obj)
567 {
568     switch(obj) {
569 ''')
570             # For each case
571             code.indent()
572             for statePerm in self.statePermPairs:
573                 code('  case ${{self.c_ident}}_${{statePerm[0]}}:')
574                 code('    return AccessPermission_${{statePerm[1]}};')
575             code.dedent()
576             code ('''
577       default:
578         panic("Unknown state access permission converstion for ${{self.c_ident}}"
      );
579     }
580 }
581 
582 ''')
583 
584         if self.isMachineType:
585             for enum in self.enums.itervalues():
586                 if enum.get("Primary"):
587                     code('#include "mem/protocol/${{enum.ident}}_Controller.hh"')
      
588             code('#include "mem/ruby/system/MachineID.hh"')
589 
590         code('''
591 // Code for output operator
592 ostream&
593 operator<<(ostream& out, const ${{self.c_ident}}& obj)
594 {
595     out << ${{self.c_ident}}_to_string(obj);
596     out << flush;
597     return out;
598 }
599 
600 // Code to convert state to a string
601 string
602 ${{self.c_ident}}_to_string(const ${{self.c_ident}}& obj)
603 {
604     switch(obj) {
605 ''')
606 
607         # For each field
608         code.indent()
609         for enum in self.enums.itervalues():
610             code('  case ${{self.c_ident}}_${{enum.ident}}:')
611             code('    return "${{enum.ident}}";')
612         code.dedent()
613 
614         # Trailer
615         code('''
616       default:
617         panic("Invalid range for type ${{self.c_ident}}");
618     }
619 }
620 
621 // Code to convert from a string to the enumeration
622 ${{self.c_ident}}
623 string_to_${{self.c_ident}}(const string& str)
624 {
625 ''')
626 
627         # For each field
628         start = ""
629         code.indent()
630         for enum in self.enums.itervalues():
631             code('${start}if (str == "${{enum.ident}}") {')
632             code('    return ${{self.c_ident}}_${{enum.ident}};')
633             start = "} else "
634         code.dedent()
635 
636         code('''
637     } else {
638         panic("Invalid string conversion for %s, type ${{self.c_ident}}", str);
639     }
640 }
641 
642 // Code to increment an enumeration type
643 ${{self.c_ident}}&
644 operator++(${{self.c_ident}}& e)
645 {
646     assert(e < ${{self.c_ident}}_NUM);
647     return e = ${{self.c_ident}}(e+1);
648 }
649 ''')
650 
651         # MachineType hack used to set the base level and number of
652         # components for each Machine
653         if self.isMachineType:
654             code('''
655 /** \\brief returns the base vector index for each machine type to be
656   * used by NetDest
657   *
658   * \\return the base vector index for each machine type to be used by NetDest
659   * \\see NetDest.hh
660   */
661 int
662 ${{self.c_ident}}_base_level(const ${{self.c_ident}}& obj)
663 {
664     switch(obj) {
665 ''')
666 
667             # For each field
668             code.indent()
669             for i,enum in enumerate(self.enums.itervalues()):
670                 code('  case ${{self.c_ident}}_${{enum.ident}}:')
671                 code('    return $i;')
672             code.dedent()
673 
674             # total num
675             code('''
676       case ${{self.c_ident}}_NUM:
677         return ${{len(self.enums)}};
678 
679       default:
680         panic("Invalid range for type ${{self.c_ident}}");
681     }
682 }
683 
684 /** \\brief returns the machine type for each base vector index used by NetDest
685  *
686  * \\return the MachineType
687  */
688 MachineType
689 ${{self.c_ident}}_from_base_level(int type)
690 {
691     switch(type) {
692 ''')
693 
694             # For each field
695             code.indent()
696             for i,enum in enumerate(self.enums.itervalues()):
697                 code('  case $i:')
698                 code('    return ${{self.c_ident}}_${{enum.ident}};')
699             code.dedent()
700 
701             # Trailer
702             code('''
703       default:
704         panic("Invalid range for type ${{self.c_ident}}");
705     }
706 }
707 
708 /** \\brief The return value indicates the number of components created
709  * before a particular machine\'s components
710  *
711  * \\return the base number of components for each machine
712  */
713 int
714 ${{self.c_ident}}_base_number(const ${{self.c_ident}}& obj)
715 {
716     int base = 0;
717     switch(obj) {
718 ''')
719 
720             # For each field
721             code.indent()
722             code('  case ${{self.c_ident}}_NUM:')
723             for enum in reversed(self.enums.values()):
724                 # Check if there is a defined machine with this type
725                 if enum.get("Primary"):
726                     code('    base += ${{enum.ident}}_Controller::getNumControlle
      rs();')
727                 else:
728                     code('    base += 0;')
729                 code('  case ${{self.c_ident}}_${{enum.ident}}:')
730             code('    break;')
731             code.dedent()
732 
733             code('''
734       default:
735         panic("Invalid range for type ${{self.c_ident}}");
736     }
737 
738     return base;
739 }
740 
741 /** \\brief returns the total number of components for each machine
742  * \\return the total number of components for each machine
743  */
744 int
745 ${{self.c_ident}}_base_count(const ${{self.c_ident}}& obj)
746 {
747     switch(obj) {
748 ''')
749 
750             # For each field
751             for enum in self.enums.itervalues():
752                 code('case ${{self.c_ident}}_${{enum.ident}}:')
753                 if enum.get("Primary"):
754                     code('return ${{enum.ident}}_Controller::getNumControllers();
      ')
755                 else:
756                     code('return 0;')
757 
758             # total num
759             code('''
760       case ${{self.c_ident}}_NUM:
761       default:
762         panic("Invalid range for type ${{self.c_ident}}");
763     }
764 }
765 ''')
766 
767             for enum in self.enums.itervalues():
768                 if enum.ident == "DMA":
769                     code('''
770 MachineID
771 map_Address_to_DMA(const Address &addr)
772 {
773       MachineID dma = {MachineType_DMA, 0};
774       return dma;
775 }
776 ''')
777 
778                 code('''
779 
780 MachineID
781 get${{enum.ident}}MachineID(NodeID RubyNode)
782 {
783       MachineID mach = {MachineType_${{enum.ident}}, RubyNode};
784       return mach;
785 }
786 ''')
787 
788         # Write the file
789         code.write(path, "%s.cc" % self.c_ident)
790 
__all__ = [ "Type" ]
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a68a10b43efa85532b2fc228a09fce916}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!printEnumHH@{printEnumHH}}
\index{printEnumHH@{printEnumHH}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{printEnumHH}]{\setlength{\rightskip}{0pt plus 5cm}def printEnumHH ( {\em self}, \/   {\em path})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a68a10b43efa85532b2fc228a09fce916}



\begin{DoxyCode}
451                                :
452         code = self.symtab.codeFormatter()
453         code('''
454 /** \\file ${{self.c_ident}}.hh
455  *
456  * Auto generated C++ code started by $__file__:$__line__
457  */
458 
459 #ifndef __${{self.c_ident}}_HH__
460 #define __${{self.c_ident}}_HH__
461 
462 #include <iostream>
463 #include <string>
464 
465 ''')
466         if self.isStateDecl:
467             code('#include "mem/protocol/AccessPermission.hh"')
468 
469         if self.isMachineType:
470             code('#include "base/misc.hh"')
471             code('#include "mem/ruby/common/Address.hh"')
472             code('struct MachineID;')
473 
474         code('''
475 
476 // Class definition
477 /** \\enum ${{self.c_ident}}
478  *  \\brief ${{self.desc}}
479  */
480 enum ${{self.c_ident}} {
481     ${{self.c_ident}}_FIRST,
482 ''')
483 
484         code.indent()
485         # For each field
486         for i,(ident,enum) in enumerate(self.enums.iteritems()):
487             desc = enum.get("desc", "No description avaliable")
488             if i == 0: 
489                 init = ' = %s_FIRST' % self.c_ident 
490             else:
491                 init = ''
492             code('${{self.c_ident}}_${{enum.ident}}$init, /**< $desc */')
493         code.dedent()
494         code('''
495     ${{self.c_ident}}_NUM
496 };
497 
498 // Code to convert from a string to the enumeration
499 ${{self.c_ident}} string_to_${{self.c_ident}}(const std::string& str);
500 
501 // Code to convert state to a string
502 std::string ${{self.c_ident}}_to_string(const ${{self.c_ident}}& obj);
503 
504 // Code to increment an enumeration type
505 ${{self.c_ident}} &operator++(${{self.c_ident}} &e);
506 ''')
507 
508         # MachineType hack used to set the base component id for each Machine
509         if self.isMachineType:
510             code('''
511 int ${{self.c_ident}}_base_level(const ${{self.c_ident}}& obj);
512 MachineType ${{self.c_ident}}_from_base_level(int);
513 int ${{self.c_ident}}_base_number(const ${{self.c_ident}}& obj);
514 int ${{self.c_ident}}_base_count(const ${{self.c_ident}}& obj);
515 ''')
516 
517             for enum in self.enums.itervalues():
518                 if enum.ident == "DMA":
519                     code('''
520 MachineID map_Address_to_DMA(const Address &addr);
521 ''')
522                 code('''
523 
524 MachineID get${{enum.ident}}MachineID(NodeID RubyNode);
525 ''')
526 
527         if self.isStateDecl:
528             code('''
529 
530 // Code to convert the current state to an access permission
531 AccessPermission ${{self.c_ident}}_to_permission(const ${{self.c_ident}}& obj);
532 
533 ''')
534 
535         # Trailer
536         code('''
537 std::ostream& operator<<(std::ostream& out, const ${{self.c_ident}}& obj);
538 
539 #endif // __${{self.c_ident}}_HH__
540 ''')
541 
542         code.write(path, "%s.hh" % self.c_ident)
543 
    def printEnumCC(self, path):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a0cbb701d52cf06208a07b0be78c34f20}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!printTypeCC@{printTypeCC}}
\index{printTypeCC@{printTypeCC}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{printTypeCC}]{\setlength{\rightskip}{0pt plus 5cm}def printTypeCC ( {\em self}, \/   {\em path})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a0cbb701d52cf06208a07b0be78c34f20}



\begin{DoxyCode}
405                                :
406         code = self.symtab.codeFormatter()
407 
408         code('''
409 /** \\file ${{self.c_ident}}.cc
410  *
411  * Auto generated C++ code started by $__file__:$__line__
412  */
413 
414 #include <iostream>
415 
416 #include "mem/protocol/${{self.c_ident}}.hh"
417 #include "mem/ruby/common/Global.hh"
418 #include "mem/ruby/system/System.hh"
419 
420 using namespace std;
421 ''')
422 
423         code('''
424 /** \\brief Print the state of this object */
425 void
426 ${{self.c_ident}}::print(ostream& out) const
427 {
428     out << "[${{self.c_ident}}: ";
429 ''')
430 
431         # For each field
432         code.indent()
433         for dm in self.data_members.values():
434             code('out << "${{dm.ident}} = " << m_${{dm.ident}} << " ";''')
435 
436         if self.isMessage:
437             code('out << "Time = " << g_system_ptr->clockPeriod() * getTime() << 
      " ";')
438         code.dedent()
439 
440         # Trailer
441         code('''
442     out << "]";
443 }''')
444 
445         # print the code for the functions in the type
446         for item in self.functions:
447             code(self.functions[item].generateCode())
448 
449         code.write(path, "%s.cc" % self.c_ident)
450 
    def printEnumHH(self, path):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a8356760e8bd592caebf1bf1311a8f155}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!printTypeHH@{printTypeHH}}
\index{printTypeHH@{printTypeHH}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{printTypeHH}]{\setlength{\rightskip}{0pt plus 5cm}def printTypeHH ( {\em self}, \/   {\em path})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a8356760e8bd592caebf1bf1311a8f155}



\begin{DoxyCode}
206                                :
207         code = self.symtab.codeFormatter()
208         code('''
209 /** \\file ${{self.c_ident}}.hh
210  *
211  *
212  * Auto generated C++ code started by $__file__:$__line__
213  */
214 
215 #ifndef __${{self.c_ident}}_HH__
216 #define __${{self.c_ident}}_HH__
217 
218 #include <iostream>
219 
220 #include "mem/ruby/slicc_interface/RubySlicc_Util.hh"
221 ''')
222 
223         for dm in self.data_members.values():
224             if not dm.type.isPrimitive:
225                 code('#include "mem/protocol/$0.hh"', dm.type.c_ident)
226 
227         parent = ""
228         if "interface" in self:
229             code('#include "mem/protocol/$0.hh"', self["interface"])
230             parent = " :  public %s" % self["interface"]
231 
232         code('''
233 $klass ${{self.c_ident}}$parent
234 {
235   public:
236     ${{self.c_ident}}
237 ''', klass="class")
238 
239         if self.isMessage:
240             code('(Tick curTime) : %s(curTime) {' % self["interface"])
241         else:
242             code('()\n\t\t{')
243 
244         code.indent()
245         if not self.isGlobal:
246             code.indent()
247             for dm in self.data_members.values():
248                 ident = dm.ident
249                 if "default" in dm:
250                     # look for default value
251                     code('m_$ident = ${{dm["default"]}}; // default for this fiel
      d')
252                 elif "default" in dm.type:
253                     # Look for the type default
254                     tid = dm.type.c_ident
255                     code('m_$ident = ${{dm.type["default"]}}; // default value of
       $tid')
256                 else:
257                     code('// m_$ident has no default')
258             code.dedent()
259         code('}')
260 
261         # ******** Copy constructor ********
262         if not self.isGlobal:
263             code('${{self.c_ident}}(const ${{self.c_ident}}&other)')
264 
265             # Call superclass constructor
266             if "interface" in self:
267                 code('    : ${{self["interface"]}}(other)')
268 
269             code('{')
270             code.indent()
271 
272             for dm in self.data_members.values():
273                 code('m_${{dm.ident}} = other.m_${{dm.ident}};')
274 
275             code.dedent()
276             code('}')
277 
278         # ******** Full init constructor ********
279         if not self.isGlobal:
280             params = [ 'const %s& local_%s' % (dm.type.c_ident, dm.ident) \
281                        for dm in self.data_members.itervalues() ]
282             params = ', '.join(params)
283 
284             if self.isMessage:
285                 params = "const Tick curTime, " + params
286 
287             code('${{self.c_ident}}($params)')
288 
289             # Call superclass constructor
290             if "interface" in self:
291                 if self.isMessage:
292                     code('    : ${{self["interface"]}}(curTime)')
293                 else:
294                     code('    : ${{self["interface"]}}()')
295 
296             code('{')
297             code.indent()
298             for dm in self.data_members.values():
299                 code('m_${{dm.ident}} = local_${{dm.ident}};')
300                 if "nextLineCallHack" in dm:
301                     code('m_${{dm.ident}}${{dm["nextLineCallHack"]}};')
302 
303             code.dedent()
304             code('}')
305 
306         # create a clone member
307         code('''
308 ${{self.c_ident}}*
309 clone() const
310 {
311      return new ${{self.c_ident}}(*this);
312 }
313 ''')
314 
315         if not self.isGlobal:
316             # const Get methods for each field
317             code('// Const accessors methods for each field')
318             for dm in self.data_members.values():
319                 code('''
320 /** \\brief Const accessor method for ${{dm.ident}} field.
321  *  \\return ${{dm.ident}} field
322  */
323 const ${{dm.type.c_ident}}&
324 get${{dm.ident}}() const
325 {
326     return m_${{dm.ident}};
327 }
328 ''')
329 
330             # Non-const Get methods for each field
331             code('// Non const Accessors methods for each field')
332             for dm in self.data_members.values():
333                 code('''
334 /** \\brief Non-const accessor method for ${{dm.ident}} field.
335  *  \\return ${{dm.ident}} field
336  */
337 ${{dm.type.c_ident}}&
338 get${{dm.ident}}()
339 {
340     return m_${{dm.ident}};
341 }
342 ''')
343 
344             #Set methods for each field
345             code('// Mutator methods for each field')
346             for dm in self.data_members.values():
347                 code('''
348 /** \\brief Mutator method for ${{dm.ident}} field */
349 void
350 set${{dm.ident}}(const ${{dm.type.c_ident}}& local_${{dm.ident}})
351 {
352     m_${{dm.ident}} = local_${{dm.ident}};
353 }
354 ''')
355 
356         code('void print(std::ostream& out) const;')
357         code.dedent()
358         code('  //private:')
359         code.indent()
360 
361         # Data members for each field
362         for dm in self.data_members.values():
363             if "abstract" not in dm:
364                 const = ""
365                 init = ""
366 
367                 # global structure
368                 if self.isGlobal:
369                     const = "static const "
370 
371                 # init value
372                 if dm.init_code:
373                     # only global structure can have init value here
374                     assert self.isGlobal
375                     init = " = %s" % (dm.init_code)
376 
377                 if "desc" in dm:
378                     code('/** ${{dm["desc"]}} */')
379 
380                 code('$const${{dm.type.c_ident}} m_${{dm.ident}}$init;')
381 
382         # Prototypes for functions defined for the Type
383         for item in self.functions:
384             proto = self.functions[item].prototype
385             if proto:
386                 code('$proto')
387 
388         code.dedent()
389         code('};')
390 
391         code('''
392 inline std::ostream&
393 operator<<(std::ostream& out, const ${{self.c_ident}}& obj)
394 {
395     obj.print(out);
396     out << std::flush;
397     return out;
398 }
399 
400 #endif // __${{self.c_ident}}_HH__
401 ''')
402 
403         code.write(path, "%s.hh" % self.c_ident)
404 
    def printTypeCC(self, path):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_aaa063dc393243eb5ac92a55c327f52de}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!statePermPairAdd@{statePermPairAdd}}
\index{statePermPairAdd@{statePermPairAdd}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{statePermPairAdd}]{\setlength{\rightskip}{0pt plus 5cm}def statePermPairAdd ( {\em self}, \/   {\em state\_\-name}, \/   {\em perm\_\-name})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_aaa063dc393243eb5ac92a55c327f52de}



\begin{DoxyCode}
160                                                      :
161         self.statePermPairs.append([state_name, perm_name])
162 
    def addMethod(self, name, return_type, param_type_vec):
\end{DoxyCode}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a69d0582bde832d4ff45237ab5ff116bb}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!writeCodeFiles@{writeCodeFiles}}
\index{writeCodeFiles@{writeCodeFiles}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{writeCodeFiles}]{\setlength{\rightskip}{0pt plus 5cm}def writeCodeFiles ( {\em self}, \/   {\em path}, \/   {\em includes})}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a69d0582bde832d4ff45237ab5ff116bb}



\begin{DoxyCode}
194                                             :
195         if self.isExternal:
196             # Do nothing
197             pass
198         elif self.isEnumeration:
199             self.printEnumHH(path)
200             self.printEnumCC(path)
201         else:
202             # User defined structs and messages
203             self.printTypeHH(path)
204             self.printTypeCC(path)
205 
    def printTypeHH(self, path):
\end{DoxyCode}


\subsection{変数}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a77596d09f6f44326ec9319be21ed940b}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!abstract\_\-ident@{abstract\_\-ident}}
\index{abstract\_\-ident@{abstract\_\-ident}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{abstract\_\-ident}]{\setlength{\rightskip}{0pt plus 5cm}{\bf abstract\_\-ident}}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a77596d09f6f44326ec9319be21ed940b}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a4bbd0f8fedcfccc594b11a2023a02baf}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!c\_\-ident@{c\_\-ident}}
\index{c\_\-ident@{c\_\-ident}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{c\_\-ident}]{\setlength{\rightskip}{0pt plus 5cm}{\bf c\_\-ident}}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a4bbd0f8fedcfccc594b11a2023a02baf}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a60153280eb566a852b59144dfb05917f}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!data\_\-members@{data\_\-members}}
\index{data\_\-members@{data\_\-members}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{data\_\-members}]{\setlength{\rightskip}{0pt plus 5cm}{\bf data\_\-members}}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a60153280eb566a852b59144dfb05917f}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a7f55aaec2cde309a6d7dea2404aadc33}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!enums@{enums}}
\index{enums@{enums}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{enums}]{\setlength{\rightskip}{0pt plus 5cm}{\bf enums}}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a7f55aaec2cde309a6d7dea2404aadc33}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a2cb6c540c07a402759bab624703ecdb2}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!functions@{functions}}
\index{functions@{functions}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{functions}]{\setlength{\rightskip}{0pt plus 5cm}{\bf functions}}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a2cb6c540c07a402759bab624703ecdb2}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a2fe57e2d3d2cba9a3aeba2f629eaa78b}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!ident@{ident}}
\index{ident@{ident}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{ident}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ident}}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a2fe57e2d3d2cba9a3aeba2f629eaa78b}


\hyperlink{classslicc_1_1symbols_1_1Symbol_1_1Symbol_a2fe57e2d3d2cba9a3aeba2f629eaa78b}{Symbol}を再定義しています。\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a91c52361042163180aebc6e66c9a64cc}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!isMachineType@{isMachineType}}
\index{isMachineType@{isMachineType}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{isMachineType}]{\setlength{\rightskip}{0pt plus 5cm}{\bf isMachineType}}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a91c52361042163180aebc6e66c9a64cc}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a4f655e08ddc24df9b8a195e4f8bcd05b}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!isStateDecl@{isStateDecl}}
\index{isStateDecl@{isStateDecl}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{isStateDecl}]{\setlength{\rightskip}{0pt plus 5cm}{\bf isStateDecl}}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a4f655e08ddc24df9b8a195e4f8bcd05b}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_a33d390b3d71a902ec9fbcd5d2d237619}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!methods@{methods}}
\index{methods@{methods}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{methods}]{\setlength{\rightskip}{0pt plus 5cm}{\bf methods}}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_a33d390b3d71a902ec9fbcd5d2d237619}
\hypertarget{classslicc_1_1symbols_1_1Type_1_1Type_ab34027f333316c336b0af3882bcc50a1}{
\index{slicc::symbols::Type::Type@{slicc::symbols::Type::Type}!statePermPairs@{statePermPairs}}
\index{statePermPairs@{statePermPairs}!slicc::symbols::Type::Type@{slicc::symbols::Type::Type}}
\subsubsection[{statePermPairs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf statePermPairs}}}
\label{classslicc_1_1symbols_1_1Type_1_1Type_ab34027f333316c336b0af3882bcc50a1}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/slicc/symbols/\hyperlink{Type_8py}{Type.py}\end{DoxyCompactItemize}
