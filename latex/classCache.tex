\hypertarget{classCache}{
\section{クラス テンプレート Cache$<$ TagStore $>$}
\label{classCache}\index{Cache@{Cache}}
}


{\ttfamily \#include $<$cache.hh$>$}Cache$<$ TagStore $>$に対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=6cm]{classCache}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classCache_1_1CpuSidePort}{CpuSidePort}
\item 
class \hyperlink{classCache_1_1MemSidePacketQueue}{MemSidePacketQueue}
\item 
class \hyperlink{classCache_1_1MemSidePort}{MemSidePort}
\item 
class \hyperlink{classCache_1_1RubyCache}{RubyCache}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef TagStore::BlkType \hyperlink{classCache_a10db52a1c10bfd238e0e3d37c4560495}{BlkType}
\item 
typedef TagStore::BlkList \hyperlink{classCache_a83744fbcce9e00711343dafa32bcb921}{BlkList}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classCache_a82f0d3b81dc0dc573633d0634508218a}{Cache} (const \hyperlink{classBaseCache_a23c1728f4d2cabb1996560194937d427}{Params} $\ast$p)
\item 
virtual \hyperlink{classCache_a899b8bf120ecc87b59e142f00b2987b0}{$\sim$Cache} ()
\item 
void \hyperlink{classCache_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
virtual void \hyperlink{classCache_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
void \hyperlink{classCache_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classCacheBlkVisitorWrapper}{CacheBlkVisitorWrapper}$<$ \hyperlink{classCache}{Cache}$<$ TagStore $>$, \hyperlink{classCache_a10db52a1c10bfd238e0e3d37c4560495}{BlkType} $>$ \hyperlink{classCache_afe5f62b7007c3a3cf9170e85041b38d8}{WrappedBlkVisitor}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classCache_ae24e0e790eea2373d750eb6642007750}{access} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{classCache_a10db52a1c10bfd238e0e3d37c4560495}{BlkType} $\ast$\&blk, \hyperlink{classCycles}{Cycles} \&lat, \hyperlink{classstd_1_1list}{PacketList} \&\hyperlink{group__CacheStatistics_gace2b37e760e47862f243e4b03c05ef5e}{writebacks})
\item 
void \hyperlink{classCache_a911af8215907296fb2453c696cb89a02}{cmpAndSwap} (\hyperlink{classCache_a10db52a1c10bfd238e0e3d37c4560495}{BlkType} $\ast$blk, \hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{classCache_a10db52a1c10bfd238e0e3d37c4560495}{BlkType} $\ast$ \hyperlink{classCache_a3da8f395921d5519e28d1c60961ae6c5}{allocateBlock} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, bool is\_\-secure, \hyperlink{classstd_1_1list}{PacketList} \&\hyperlink{group__CacheStatistics_gace2b37e760e47862f243e4b03c05ef5e}{writebacks})
\item 
\hyperlink{classCache_a10db52a1c10bfd238e0e3d37c4560495}{BlkType} $\ast$ \hyperlink{classCache_a4943b9a8a4801f454a968416b456dc21}{handleFill} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{classCache_a10db52a1c10bfd238e0e3d37c4560495}{BlkType} $\ast$blk, \hyperlink{classstd_1_1list}{PacketList} \&\hyperlink{group__CacheStatistics_gace2b37e760e47862f243e4b03c05ef5e}{writebacks})
\item 
bool \hyperlink{classCache_a3344d9dd0f83257feab5424e761f31c6}{recvTimingReq} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classCache_a083c4da6cf866d660a126f4174bba7fc}{recvTimingResp} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classCache_aff3031c56fc4947a19695c868bb8233e}{recvTimingSnoopReq} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classCache_a55143a3333ff75d0df66bd6e4eb50fb7}{recvTimingSnoopResp} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classCache_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{recvAtomic} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classCache_a886d584c81ee4e398ff8069907f6e1a5}{recvAtomicSnoop} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classCache_ae764e8af8ed82d5b1e78530e56a16470}{functionalAccess} (\hyperlink{classPacket}{PacketPtr} pkt, bool fromCpuSide)
\item 
void \hyperlink{classCache_a5d5d5944479d29a7bfc183f4b2b6a4fa}{satisfyCpuSideRequest} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{classCache_a10db52a1c10bfd238e0e3d37c4560495}{BlkType} $\ast$blk, bool deferred\_\-response=false, bool pending\_\-downgrade=false)
\item 
bool \hyperlink{classCache_a65c1c67b81573ca17c8ad40e0e6d85d8}{satisfyMSHR} (\hyperlink{classMSHR}{MSHR} $\ast$mshr, \hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{classCache_a10db52a1c10bfd238e0e3d37c4560495}{BlkType} $\ast$blk)
\item 
void \hyperlink{classCache_a87256886a1eea4638abe1b437f4fe226}{doTimingSupplyResponse} (\hyperlink{classPacket}{PacketPtr} req\_\-pkt, uint8\_\-t $\ast$blk\_\-data, bool already\_\-copied, bool pending\_\-inval)
\item 
void \hyperlink{classCache_affa22df454ca8619381018b222c49c2d}{handleSnoop} (\hyperlink{classPacket}{PacketPtr} ptk, \hyperlink{classCache_a10db52a1c10bfd238e0e3d37c4560495}{BlkType} $\ast$blk, bool is\_\-timing, bool is\_\-deferred, bool pending\_\-inval)
\item 
\hyperlink{classPacket}{PacketPtr} \hyperlink{classCache_a4451141787cceb771eec3ea4d4a4a8d4}{writebackBlk} (\hyperlink{classCache_a10db52a1c10bfd238e0e3d37c4560495}{BlkType} $\ast$blk)
\item 
void \hyperlink{classCache_a381272ae5c2cc173adb59cd67a76b458}{memWriteback} ()
\item 
void \hyperlink{classCache_afea64b0aa579c17485db54c6a5c2ede3}{memInvalidate} ()
\item 
bool \hyperlink{classCache_ad66f409af3c387e166ff7ee95169b7b6}{isDirty} () const 
\item 
bool \hyperlink{classCache_a0f9ea802ec68e58830a83fdf795a9b9f}{writebackVisitor} (\hyperlink{classCache_a10db52a1c10bfd238e0e3d37c4560495}{BlkType} \&blk)
\item 
bool \hyperlink{classCache_a0a830cf4879a74de1790653f861c7d93}{invalidateVisitor} (\hyperlink{classCache_a10db52a1c10bfd238e0e3d37c4560495}{BlkType} \&blk)
\item 
void \hyperlink{classCache_af5dfa0f9fd3542f24b728e25a1d658b2}{uncacheableFlush} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classCache_a94c2c174856cbab1e3478cb02ae8ed80}{squash} (int threadNum)
\item 
\hyperlink{classPacket}{PacketPtr} \hyperlink{classCache_a3bdcf30020fcb7b18e1d1f95cc86648e}{getBusPacket} (\hyperlink{classPacket}{PacketPtr} cpu\_\-pkt, \hyperlink{classCache_a10db52a1c10bfd238e0e3d37c4560495}{BlkType} $\ast$blk, bool needsExclusive) const 
\item 
\hyperlink{classMSHR}{MSHR} $\ast$ \hyperlink{classCache_a3ce02537ee4a8918300802fda9b82b47}{getNextMSHR} ()
\item 
\hyperlink{classPacket}{PacketPtr} \hyperlink{classCache_a52bd0127c43c9167c1d092fc060cc472}{getTimingPacket} ()
\item 
void \hyperlink{classCache_ac7fb6ca824d25de54878584fd9dd8162}{markInService} (\hyperlink{classMSHR}{MSHR} $\ast$mshr, \hyperlink{classPacket}{PacketPtr} pkt=0)
\item 
bool \hyperlink{classCache_ac40e843a35136aebfb61fc0c9f57aa27}{outstandingMisses} () const 
\item 
\hyperlink{classCacheBlk}{CacheBlk} $\ast$ \hyperlink{classCache_a4789f9031d3220604c62c0e31a94c539}{findBlock} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, bool is\_\-secure) const 
\item 
bool \hyperlink{classCache_a2a9a72a19c7910262542bc96de2488fb}{inCache} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, bool is\_\-secure) const 
\item 
bool \hyperlink{classCache_a01f08168ad1a2fee8ccff0f562da70de}{inMissQueue} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, bool is\_\-secure) const 
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classCache_a4601a57ba7740776052541f212c29cbd}{nextMSHRReadyTime} () const 
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
TagStore $\ast$ \hyperlink{classCache_adb086ae267638f3864a6b3199f1d01e9}{tags}
\item 
\hyperlink{classBasePrefetcher}{BasePrefetcher} $\ast$ \hyperlink{classCache_a320f5a2352104b9b633113f9045461a3}{prefetcher}
\item 
\hyperlink{classCache_a10db52a1c10bfd238e0e3d37c4560495}{BlkType} $\ast$ \hyperlink{classCache_a0ca2086b66114357dd17032178adce17}{tempBlock}
\item 
const bool \hyperlink{classCache_a9b589ab6323a2796b7ae762dc7236bb5}{doFastWrites}
\item 
const bool \hyperlink{classCache_a146f074bf7af4a70fc378862eab0b15a}{prefetchOnAccess}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classPacket}{PacketPtr} $>$ \hyperlink{classCache_a21da4bea3554874b557428e4cce5d4a4}{pendingDelete}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$class TagStore$>$ class Cache$<$ TagStore $>$}

A template-\/policy based cache. The behavior of the cache can be altered by supplying different template policies. TagStore handles all tag and data storage \begin{DoxySeeAlso}{参照}
TagStore, gem5 Memory System 
\end{DoxySeeAlso}


\subsection{型定義}
\hypertarget{classCache_a83744fbcce9e00711343dafa32bcb921}{
\index{Cache@{Cache}!BlkList@{BlkList}}
\index{BlkList@{BlkList}!Cache@{Cache}}
\subsubsection[{BlkList}]{\setlength{\rightskip}{0pt plus 5cm}typedef TagStore::BlkList {\bf BlkList}}}
\label{classCache_a83744fbcce9e00711343dafa32bcb921}
A typedef for a list of BlkType pointers. \hypertarget{classCache_a10db52a1c10bfd238e0e3d37c4560495}{
\index{Cache@{Cache}!BlkType@{BlkType}}
\index{BlkType@{BlkType}!Cache@{Cache}}
\subsubsection[{BlkType}]{\setlength{\rightskip}{0pt plus 5cm}typedef TagStore::BlkType {\bf BlkType}}}
\label{classCache_a10db52a1c10bfd238e0e3d37c4560495}
Define the type of cache block to use. \hypertarget{classCache_afe5f62b7007c3a3cf9170e85041b38d8}{
\index{Cache@{Cache}!WrappedBlkVisitor@{WrappedBlkVisitor}}
\index{WrappedBlkVisitor@{WrappedBlkVisitor}!Cache@{Cache}}
\subsubsection[{WrappedBlkVisitor}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf CacheBlkVisitorWrapper}$<${\bf Cache}$<$TagStore$>$, {\bf BlkType}$>$ {\bf WrappedBlkVisitor}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCache_afe5f62b7007c3a3cf9170e85041b38d8}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classCache_a82f0d3b81dc0dc573633d0634508218a}{
\index{Cache@{Cache}!Cache@{Cache}}
\index{Cache@{Cache}!Cache@{Cache}}
\subsubsection[{Cache}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cache} (const {\bf Params} $\ast$ {\em p})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCache_a82f0d3b81dc0dc573633d0634508218a}
Instantiates a basic cache object. 


\begin{DoxyCode}
70     : BaseCache(p),
71       tags(dynamic_cast<TagStore*>(p->tags)),
72       prefetcher(p->prefetcher),
73       doFastWrites(true),
74       prefetchOnAccess(p->prefetch_on_access)
75 {
76     tempBlock = new BlkType();
77     tempBlock->data = new uint8_t[blkSize];
78 
79     cpuSidePort = new CpuSidePort(p->name + ".cpu_side", this,
80                                   "CpuSidePort");
81     memSidePort = new MemSidePort(p->name + ".mem_side", this,
82                                   "MemSidePort");
83 
84     tags->setCache(this);
85     if (prefetcher)
86         prefetcher->setCache(this);
87 }
\end{DoxyCode}
\hypertarget{classCache_a899b8bf120ecc87b59e142f00b2987b0}{
\index{Cache@{Cache}!$\sim$Cache@{$\sim$Cache}}
\index{$\sim$Cache@{$\sim$Cache}!Cache@{Cache}}
\subsubsection[{$\sim$Cache}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf Cache} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classCache_a899b8bf120ecc87b59e142f00b2987b0}
Non-\/default destructor is needed to deallocate memory. 


\begin{DoxyCode}
91 {
92     delete [] tempBlock->data;
93     delete tempBlock;
94 
95     delete cpuSidePort;
96     delete memSidePort;
97 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classCache_ae24e0e790eea2373d750eb6642007750}{
\index{Cache@{Cache}!access@{access}}
\index{access@{access}!Cache@{Cache}}
\subsubsection[{access}]{\setlength{\rightskip}{0pt plus 5cm}bool access ({\bf PacketPtr} {\em pkt}, \/  {\bf BlkType} $\ast$\& {\em blk}, \/  {\bf Cycles} \& {\em lat}, \/  {\bf PacketList} \& {\em writebacks})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_ae24e0e790eea2373d750eb6642007750}
Does all the processing necessary to perform the provided request. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]The memory request to perform. \item[{\em blk}]The cache block to be updated. \item[{\em lat}]The latency of the access. \item[{\em writebacks}]List for any writebacks that need to be performed. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Boolean indicating whether the request was satisfied. 
\end{DoxyReturn}



\begin{DoxyCode}
293 {
294     DPRINTF(Cache, "%s for %s address %x size %d\n", __func__,
295             pkt->cmdString(), pkt->getAddr(), pkt->getSize());
296     if (pkt->req->isUncacheable()) {
297         uncacheableFlush(pkt);
298         blk = NULL;
299         lat = hitLatency;
300         return false;
301     }
302 
303     int id = pkt->req->hasContextId() ? pkt->req->contextId() : -1;
304     blk = tags->accessBlock(pkt->getAddr(), pkt->isSecure(), lat, id);
305 
306     DPRINTF(Cache, "%s%s %x (%s) %s %s\n", pkt->cmdString(),
307             pkt->req->isInstFetch() ? " (ifetch)" : "",
308             pkt->getAddr(), pkt->isSecure() ? "s" : "ns",
309             blk ? "hit" : "miss", blk ? blk->print() : "");
310 
311     if (blk != NULL) {
312 
313         if (pkt->needsExclusive() ? blk->isWritable() : blk->isReadable()) {
314             // OK to satisfy access
315             incHitCount(pkt);
316             satisfyCpuSideRequest(pkt, blk);
317             return true;
318         }
319     }
320 
321     // Can't satisfy access normally... either no block (blk == NULL)
322     // or have block but need exclusive & only have shared.
323 
324     // Writeback handling is special case.  We can write the block
325     // into the cache without having a writeable copy (or any copy at
326     // all).
327     if (pkt->cmd == MemCmd::Writeback) {
328         assert(blkSize == pkt->getSize());
329         if (blk == NULL) {
330             // need to do a replacement
331             blk = allocateBlock(pkt->getAddr(), pkt->isSecure(), writebacks);
332             if (blk == NULL) {
333                 // no replaceable block available, give up.
334                 // writeback will be forwarded to next level.
335                 incMissCount(pkt);
336                 return false;
337             }
338             tags->insertBlock(pkt, blk);
339             blk->status = BlkValid | BlkReadable;
340         }
341         std::memcpy(blk->data, pkt->getPtr<uint8_t>(), blkSize);
342         blk->status |= BlkDirty;
343         if (pkt->isSupplyExclusive()) {
344             blk->status |= BlkWritable;
345         }
346         // nothing else to do; writeback doesn't expect response
347         assert(!pkt->needsResponse());
348         DPRINTF(Cache, "%s new state is %s\n", __func__, blk->print());
349         incHitCount(pkt);
350         return true;
351     }
352 
353     incMissCount(pkt);
354 
355     if (blk == NULL && pkt->isLLSC() && pkt->isWrite()) {
356         // complete miss on store conditional... just give up now
357         pkt->req->setExtraData(0);
358         return true;
359     }
360 
361     return false;
362 }
\end{DoxyCode}
\hypertarget{classCache_a3da8f395921d5519e28d1c60961ae6c5}{
\index{Cache@{Cache}!allocateBlock@{allocateBlock}}
\index{allocateBlock@{allocateBlock}!Cache@{Cache}}
\subsubsection[{allocateBlock}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cache}$<$ TagStore $>$::{\bf BlkType} $\ast$ allocateBlock ({\bf Addr} {\em addr}, \/  bool {\em is\_\-secure}, \/  {\bf PacketList} \& {\em writebacks})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a3da8f395921d5519e28d1c60961ae6c5}
Find a block frame for new block at address addr targeting the given security space, assuming that the block is not currently in the cache. Append writebacks if any to provided packet list. Return free block frame. May return NULL if there are no replaceable blocks at the moment. 


\begin{DoxyCode}
1205 {
1206     BlkType *blk = tags->findVictim(addr);
1207 
1208     if (blk->isValid()) {
1209         Addr repl_addr = tags->regenerateBlkAddr(blk->tag, blk->set);
1210         MSHR *repl_mshr = mshrQueue.findMatch(repl_addr, blk->isSecure());
1211         if (repl_mshr) {
1212             // must be an outstanding upgrade request on block
1213             // we're about to replace...
1214             assert(!blk->isWritable());
1215             assert(repl_mshr->needsExclusive());
1216             // too hard to replace block with transient state
1217             // allocation failed, block not inserted
1218             return NULL;
1219         } else {
1220             DPRINTF(Cache, "replacement: replacing %x (%s) with %x (%s): %s\n",
1221                     repl_addr, blk->isSecure() ? "s" : "ns",
1222                     addr, is_secure ? "s" : "ns",
1223                     blk->isDirty() ? "writeback" : "clean");
1224 
1225             if (blk->isDirty()) {
1226                 // Save writeback packet for handling by caller
1227                 writebacks.push_back(writebackBlk(blk));
1228             }
1229         }
1230     }
1231 
1232     return blk;
1233 }
\end{DoxyCode}
\hypertarget{classCache_a911af8215907296fb2453c696cb89a02}{
\index{Cache@{Cache}!cmpAndSwap@{cmpAndSwap}}
\index{cmpAndSwap@{cmpAndSwap}!Cache@{Cache}}
\subsubsection[{cmpAndSwap}]{\setlength{\rightskip}{0pt plus 5cm}void cmpAndSwap ({\bf BlkType} $\ast$ {\em blk}, \/  {\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a911af8215907296fb2453c696cb89a02}
Handle doing the Compare and Swap function for SPARC. 


\begin{DoxyCode}
109 {
110     uint64_t overwrite_val;
111     bool overwrite_mem;
112     uint64_t condition_val64;
113     uint32_t condition_val32;
114 
115     int offset = tags->extractBlkOffset(pkt->getAddr());
116     uint8_t *blk_data = blk->data + offset;
117 
118     assert(sizeof(uint64_t) >= pkt->getSize());
119 
120     overwrite_mem = true;
121     // keep a copy of our possible write value, and copy what is at the
122     // memory address into the packet
123     pkt->writeData((uint8_t *)&overwrite_val);
124     pkt->setData(blk_data);
125 
126     if (pkt->req->isCondSwap()) {
127         if (pkt->getSize() == sizeof(uint64_t)) {
128             condition_val64 = pkt->req->getExtraData();
129             overwrite_mem = !std::memcmp(&condition_val64, blk_data,
130                                          sizeof(uint64_t));
131         } else if (pkt->getSize() == sizeof(uint32_t)) {
132             condition_val32 = (uint32_t)pkt->req->getExtraData();
133             overwrite_mem = !std::memcmp(&condition_val32, blk_data,
134                                          sizeof(uint32_t));
135         } else
136             panic("Invalid size for conditional read/write\n");
137     }
138 
139     if (overwrite_mem) {
140         std::memcpy(blk_data, &overwrite_val, pkt->getSize());
141         blk->status |= BlkDirty;
142     }
143 }
\end{DoxyCode}
\hypertarget{classCache_a87256886a1eea4638abe1b437f4fe226}{
\index{Cache@{Cache}!doTimingSupplyResponse@{doTimingSupplyResponse}}
\index{doTimingSupplyResponse@{doTimingSupplyResponse}!Cache@{Cache}}
\subsubsection[{doTimingSupplyResponse}]{\setlength{\rightskip}{0pt plus 5cm}void doTimingSupplyResponse ({\bf PacketPtr} {\em req\_\-pkt}, \/  uint8\_\-t $\ast$ {\em blk\_\-data}, \/  bool {\em already\_\-copied}, \/  bool {\em pending\_\-inval})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a87256886a1eea4638abe1b437f4fe226}



\begin{DoxyCode}
1325 {
1326     DPRINTF(Cache, "%s for %s address %x size %d\n", __func__,
1327             req_pkt->cmdString(), req_pkt->getAddr(), req_pkt->getSize());
1328     // timing-mode snoop responses require a new packet, unless we
1329     // already made a copy...
1330     PacketPtr pkt = already_copied ? req_pkt : new Packet(req_pkt);
1331     assert(req_pkt->isInvalidate() || pkt->sharedAsserted());
1332     pkt->allocate();
1333     pkt->makeTimingResponse();
1334     // @todo Make someone pay for this
1335     pkt->busFirstWordDelay = pkt->busLastWordDelay = 0;
1336     if (pkt->isRead()) {
1337         pkt->setDataFromBlock(blk_data, blkSize);
1338     }
1339     if (pkt->cmd == MemCmd::ReadResp && pending_inval) {
1340         // Assume we defer a response to a read from a far-away cache
1341         // A, then later defer a ReadExcl from a cache B on the same
1342         // bus as us.  We'll assert MemInhibit in both cases, but in
1343         // the latter case MemInhibit will keep the invalidation from
1344         // reaching cache A.  This special response tells cache A that
1345         // it gets the block to satisfy its read, but must immediately
1346         // invalidate it.
1347         pkt->cmd = MemCmd::ReadRespWithInvalidate;
1348     }
1349     DPRINTF(Cache, "%s created response: %s address %x size %d\n",
1350             __func__, pkt->cmdString(), pkt->getAddr(), pkt->getSize());
1351     memSidePort->schedTimingSnoopResp(pkt, clockEdge(hitLatency));
1352 }
\end{DoxyCode}
\hypertarget{classCache_a4789f9031d3220604c62c0e31a94c539}{
\index{Cache@{Cache}!findBlock@{findBlock}}
\index{findBlock@{findBlock}!Cache@{Cache}}
\subsubsection[{findBlock}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CacheBlk}$\ast$ findBlock ({\bf Addr} {\em addr}, \/  bool {\em is\_\-secure}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a4789f9031d3220604c62c0e31a94c539}



\begin{DoxyCode}
388                                                          {
389         return tags->findBlock(addr, is_secure);
390     }
\end{DoxyCode}
\hypertarget{classCache_ae764e8af8ed82d5b1e78530e56a16470}{
\index{Cache@{Cache}!functionalAccess@{functionalAccess}}
\index{functionalAccess@{functionalAccess}!Cache@{Cache}}
\subsubsection[{functionalAccess}]{\setlength{\rightskip}{0pt plus 5cm}void functionalAccess ({\bf PacketPtr} {\em pkt}, \/  bool {\em fromCpuSide})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_ae764e8af8ed82d5b1e78530e56a16470}
Performs the access specified by the request. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]The request to perform. \item[{\em fromCpuSide}]from the CPU side port or the memory side port \end{DoxyParams}



\begin{DoxyCode}
803 {
804     if (system->bypassCaches()) {
805         // Packets from the memory side are snoop request and
806         // shouldn't happen in bypass mode.
807         assert(fromCpuSide);
808 
809         // The cache should be flushed if we are in cache bypass mode,
810         // so we don't need to check if we need to update anything.
811         memSidePort->sendFunctional(pkt);
812         return;
813     }
814 
815     Addr blk_addr = blockAlign(pkt->getAddr());
816     bool is_secure = pkt->isSecure();
817     BlkType *blk = tags->findBlock(pkt->getAddr(), is_secure);
818     MSHR *mshr = mshrQueue.findMatch(blk_addr, is_secure);
819 
820     pkt->pushLabel(name());
821 
822     CacheBlkPrintWrapper cbpw(blk);
823 
824     // Note that just because an L2/L3 has valid data doesn't mean an
825     // L1 doesn't have a more up-to-date modified copy that still
826     // needs to be found.  As a result we always update the request if
827     // we have it, but only declare it satisfied if we are the owner.
828 
829     // see if we have data at all (owned or otherwise)
830     bool have_data = blk && blk->isValid()
831         && pkt->checkFunctional(&cbpw, blk_addr, is_secure, blkSize,
832                                 blk->data);
833 
834     // data we have is dirty if marked as such or if valid & ownership
835     // pending due to outstanding UpgradeReq
836     bool have_dirty =
837         have_data && (blk->isDirty() ||
838                       (mshr && mshr->inService && mshr->isPendingDirty()));
839 
840     bool done = have_dirty
841         || cpuSidePort->checkFunctional(pkt)
842         || mshrQueue.checkFunctional(pkt, blk_addr)
843         || writeBuffer.checkFunctional(pkt, blk_addr)
844         || memSidePort->checkFunctional(pkt);
845 
846     DPRINTF(Cache, "functional %s %x (%s) %s%s%s\n",
847             pkt->cmdString(), pkt->getAddr(), is_secure ? "s" : "ns",
848             (blk && blk->isValid()) ? "valid " : "",
849             have_data ? "data " : "", done ? "done " : "");
850 
851     // We're leaving the cache, so pop cache->name() label
852     pkt->popLabel();
853 
854     if (done) {
855         pkt->makeResponse();
856     } else {
857         // if it came as a request from the CPU side then make sure it
858         // continues towards the memory side
859         if (fromCpuSide) {
860             memSidePort->sendFunctional(pkt);
861         } else if (forwardSnoops && cpuSidePort->isSnooping()) {
862             // if it came from the memory side, it must be a snoop request
863             // and we should only forward it if we are forwarding snoops
864             cpuSidePort->sendFunctionalSnoop(pkt);
865         }
866     }
867 }
\end{DoxyCode}
\hypertarget{classCache_a3bdcf30020fcb7b18e1d1f95cc86648e}{
\index{Cache@{Cache}!getBusPacket@{getBusPacket}}
\index{getBusPacket@{getBusPacket}!Cache@{Cache}}
\subsubsection[{getBusPacket}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketPtr} getBusPacket ({\bf PacketPtr} {\em cpu\_\-pkt}, \/  {\bf BlkType} $\ast$ {\em blk}, \/  bool {\em needsExclusive}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a3bdcf30020fcb7b18e1d1f95cc86648e}
Generate an appropriate downstream bus request packet for the given parameters. 
\begin{DoxyParams}{引数}
\item[{\em cpu\_\-pkt}]The upstream request that needs to be satisfied. \item[{\em blk}]The block currently in the cache corresponding to cpu\_\-pkt (NULL if none). \item[{\em needsExclusive}]Indicates that an exclusive copy is required even if the request in cpu\_\-pkt doesn't indicate that. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A new \hyperlink{classPacket}{Packet} containing the request, or NULL if the current request in cpu\_\-pkt should just be forwarded on. 
\end{DoxyReturn}



\begin{DoxyCode}
628 {
629     bool blkValid = blk && blk->isValid();
630 
631     if (cpu_pkt->req->isUncacheable()) {
632         //assert(blk == NULL);
633         return NULL;
634     }
635 
636     if (!blkValid &&
637         (cpu_pkt->cmd == MemCmd::Writeback || cpu_pkt->isUpgrade())) {
638         // Writebacks that weren't allocated in access() and upgrades
639         // from upper-level caches that missed completely just go
640         // through.
641         return NULL;
642     }
643 
644     assert(cpu_pkt->needsResponse());
645 
646     MemCmd cmd;
647     // @TODO make useUpgrades a parameter.
648     // Note that ownership protocols require upgrade, otherwise a
649     // write miss on a shared owned block will generate a ReadExcl,
650     // which will clobber the owned copy.
651     const bool useUpgrades = true;
652     if (blkValid && useUpgrades) {
653         // only reason to be here is that blk is shared
654         // (read-only) and we need exclusive
655         assert(needsExclusive && !blk->isWritable());
656         cmd = cpu_pkt->isLLSC() ? MemCmd::SCUpgradeReq : MemCmd::UpgradeReq;
657     } else {
658         // block is invalid
659         cmd = needsExclusive ? MemCmd::ReadExReq : MemCmd::ReadReq;
660     }
661     PacketPtr pkt = new Packet(cpu_pkt->req, cmd, blkSize);
662 
663     pkt->allocate();
664     DPRINTF(Cache, "%s created %s address %x size %d\n",
665             __func__, pkt->cmdString(), pkt->getAddr(), pkt->getSize());
666     return pkt;
667 }
\end{DoxyCode}
\hypertarget{classCache_a3ce02537ee4a8918300802fda9b82b47}{
\index{Cache@{Cache}!getNextMSHR@{getNextMSHR}}
\index{getNextMSHR@{getNextMSHR}!Cache@{Cache}}
\subsubsection[{getNextMSHR}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHR} $\ast$ getNextMSHR ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a3ce02537ee4a8918300802fda9b82b47}
Return the next \hyperlink{classMSHR}{MSHR} to service, either a pending miss from the mshrQueue, a buffered write from the write buffer, or something from the prefetcher. This function is responsible for prioritizing among those sources on the fly. 


\begin{DoxyCode}
1621 {
1622     // Check both MSHR queue and write buffer for potential requests
1623     MSHR *miss_mshr  = mshrQueue.getNextMSHR();
1624     MSHR *write_mshr = writeBuffer.getNextMSHR();
1625 
1626     // Now figure out which one to send... some cases are easy
1627     if (miss_mshr && !write_mshr) {
1628         return miss_mshr;
1629     }
1630     if (write_mshr && !miss_mshr) {
1631         return write_mshr;
1632     }
1633 
1634     if (miss_mshr && write_mshr) {
1635         // We have one of each... normally we favor the miss request
1636         // unless the write buffer is full
1637         if (writeBuffer.isFull() && writeBuffer.inServiceEntries == 0) {
1638             // Write buffer is full, so we'd like to issue a write;
1639             // need to search MSHR queue for conflicting earlier miss.
1640             MSHR *conflict_mshr =
1641                 mshrQueue.findPending(write_mshr->addr, write_mshr->size,
1642                                       write_mshr->isSecure);
1643 
1644             if (conflict_mshr && conflict_mshr->order < write_mshr->order) {
1645                 // Service misses in order until conflict is cleared.
1646                 return conflict_mshr;
1647             }
1648 
1649             // No conflicts; issue write
1650             return write_mshr;
1651         }
1652 
1653         // Write buffer isn't full, but need to check it for
1654         // conflicting earlier writeback
1655         MSHR *conflict_mshr =
1656             writeBuffer.findPending(miss_mshr->addr, miss_mshr->size,
1657                                     miss_mshr->isSecure);
1658         if (conflict_mshr) {
1659             // not sure why we don't check order here... it was in the
1660             // original code but commented out.
1661 
1662             // The only way this happens is if we are
1663             // doing a write and we didn't have permissions
1664             // then subsequently saw a writeback (owned got evicted)
1665             // We need to make sure to perform the writeback first
1666             // To preserve the dirty data, then we can issue the write
1667 
1668             // should we return write_mshr here instead?  I.e. do we
1669             // have to flush writes in order?  I don't think so... not
1670             // for Alpha anyway.  Maybe for x86?
1671             return conflict_mshr;
1672         }
1673 
1674         // No conflicts; issue read
1675         return miss_mshr;
1676     }
1677 
1678     // fall through... no pending requests.  Try a prefetch.
1679     assert(!miss_mshr && !write_mshr);
1680     if (prefetcher && !mshrQueue.isFull()) {
1681         // If we have a miss queue slot, we can try a prefetch
1682         PacketPtr pkt = prefetcher->getPacket();
1683         if (pkt) {
1684             Addr pf_addr = blockAlign(pkt->getAddr());
1685             if (!tags->findBlock(pf_addr, pkt->isSecure()) &&
1686                 !mshrQueue.findMatch(pf_addr, pkt->isSecure()) &&
1687                 !writeBuffer.findMatch(pf_addr, pkt->isSecure())) {
1688                 // Update statistic on number of prefetches issued
1689                 // (hwpf_mshr_misses)
1690                 assert(pkt->req->masterId() < system->maxMasters());
1691                 mshr_misses[pkt->cmdToIndex()][pkt->req->masterId()]++;
1692                 // Don't request bus, since we already have it
1693                 return allocateMissBuffer(pkt, curTick(), false);
1694             } else {
1695                 // free the request and packet
1696                 delete pkt->req;
1697                 delete pkt;
1698             }
1699         }
1700     }
1701 
1702     return NULL;
1703 }
\end{DoxyCode}
\hypertarget{classCache_a52bd0127c43c9167c1d092fc060cc472}{
\index{Cache@{Cache}!getTimingPacket@{getTimingPacket}}
\index{getTimingPacket@{getTimingPacket}!Cache@{Cache}}
\subsubsection[{getTimingPacket}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketPtr} getTimingPacket ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a52bd0127c43c9167c1d092fc060cc472}
Selects an outstanding request to service. Called when the cache gets granted the downstream bus in timing mode. \begin{DoxyReturn}{戻り値}
The request to service, NULL if none found. 
\end{DoxyReturn}



\begin{DoxyCode}
1709 {
1710     MSHR *mshr = getNextMSHR();
1711 
1712     if (mshr == NULL) {
1713         return NULL;
1714     }
1715 
1716     // use request from 1st target
1717     PacketPtr tgt_pkt = mshr->getTarget()->pkt;
1718     PacketPtr pkt = NULL;
1719 
1720     DPRINTF(CachePort, "%s %s for address %x size %d\n", __func__,
1721             tgt_pkt->cmdString(), tgt_pkt->getAddr(), tgt_pkt->getSize());
1722 
1723     if (tgt_pkt->cmd == MemCmd::SCUpgradeFailReq ||
1724         tgt_pkt->cmd == MemCmd::StoreCondFailReq) {
1725         // SCUpgradeReq or StoreCondReq saw invalidation while queued
1726         // in MSHR, so now that we are getting around to processing
1727         // it, just treat it as if we got a failure response
1728         pkt = new Packet(tgt_pkt);
1729         pkt->cmd = MemCmd::UpgradeFailResp;
1730         pkt->senderState = mshr;
1731         pkt->busFirstWordDelay = pkt->busLastWordDelay = 0;
1732         recvTimingResp(pkt);
1733         return NULL;
1734     } else if (mshr->isForwardNoResponse()) {
1735         // no response expected, just forward packet as it is
1736         assert(tags->findBlock(mshr->addr, mshr->isSecure) == NULL);
1737         pkt = tgt_pkt;
1738     } else {
1739         BlkType *blk = tags->findBlock(mshr->addr, mshr->isSecure);
1740 
1741         if (tgt_pkt->cmd == MemCmd::HardPFReq) {
1742             // It might be possible for a writeback to arrive between
1743             // the time the prefetch is placed in the MSHRs and when
1744             // it's selected to send... if so, this assert will catch
1745             // that, and then we'll have to figure out what to do.
1746             assert(blk == NULL);
1747 
1748             // We need to check the caches above us to verify that
1749             // they don't have a copy of this block in the dirty state
1750             // at the moment. Without this check we could get a stale
1751             // copy from memory that might get used in place of the
1752             // dirty one.
1753             Packet snoop_pkt(tgt_pkt, true);
1754             snoop_pkt.setExpressSnoop();
1755             snoop_pkt.senderState = mshr;
1756             cpuSidePort->sendTimingSnoopReq(&snoop_pkt);
1757 
1758             // Check to see if the prefetch was squashed by an upper cache
1759             if (snoop_pkt.prefetchSquashed()) {
1760                 DPRINTF(Cache, "Prefetch squashed by upper cache.  "
1761                                "Deallocating mshr target %#x.\n", mshr->addr);
1762 
1763                 // Deallocate the mshr target
1764                 if (mshr->queue->forceDeallocateTarget(mshr)) {
1765                     // Clear block if this deallocation resulted freed an
1766                     // mshr when all had previously been utilized
1767                     clearBlocked((BlockedCause)(mshr->queue->index));
1768                 }
1769                 return NULL;
1770             }
1771 
1772             if (snoop_pkt.memInhibitAsserted()) {
1773                 markInService(mshr, &snoop_pkt);
1774                 DPRINTF(Cache, "Upward snoop of prefetch for addr"
1775                         " %#x (%s) hit\n",
1776                         tgt_pkt->getAddr(), tgt_pkt->isSecure()? "s": "ns");
1777                 return NULL;
1778             }
1779         }
1780 
1781         pkt = getBusPacket(tgt_pkt, blk, mshr->needsExclusive());
1782 
1783         mshr->isForward = (pkt == NULL);
1784 
1785         if (mshr->isForward) {
1786             // not a cache block request, but a response is expected
1787             // make copy of current packet to forward, keep current
1788             // copy for response handling
1789             pkt = new Packet(tgt_pkt);
1790             pkt->allocate();
1791             if (pkt->isWrite()) {
1792                 pkt->setData(tgt_pkt->getPtr<uint8_t>());
1793             }
1794         }
1795     }
1796 
1797     assert(pkt != NULL);
1798     pkt->senderState = mshr;
1799     return pkt;
1800 }
\end{DoxyCode}
\hypertarget{classCache_a4943b9a8a4801f454a968416b456dc21}{
\index{Cache@{Cache}!handleFill@{handleFill}}
\index{handleFill@{handleFill}!Cache@{Cache}}
\subsubsection[{handleFill}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cache}$<$ TagStore $>$::{\bf BlkType} $\ast$ handleFill ({\bf PacketPtr} {\em pkt}, \/  {\bf BlkType} $\ast$ {\em blk}, \/  {\bf PacketList} \& {\em writebacks})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a4943b9a8a4801f454a968416b456dc21}
Populates a cache block and handles all outstanding requests for the satisfied fill request. This version takes two memory requests. One contains the fill data, the other is an optional target to satisfy. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]The memory request with the fill data. \item[{\em blk}]The cache block if it already exists. \item[{\em writebacks}]List for any writebacks that need to be performed. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Pointer to the new cache block. 
\end{DoxyReturn}



\begin{DoxyCode}
1245 {
1246     Addr addr = pkt->getAddr();
1247     bool is_secure = pkt->isSecure();
1248 #if TRACING_ON
1249     CacheBlk::State old_state = blk ? blk->status : 0;
1250 #endif
1251 
1252     if (blk == NULL) {
1253         // better have read new data...
1254         assert(pkt->hasData());
1255         // need to do a replacement
1256         blk = allocateBlock(addr, is_secure, writebacks);
1257         if (blk == NULL) {
1258             // No replaceable block... just use temporary storage to
1259             // complete the current request and then get rid of it
1260             assert(!tempBlock->isValid());
1261             blk = tempBlock;
1262             tempBlock->set = tags->extractSet(addr);
1263             tempBlock->tag = tags->extractTag(addr);
1264             // @todo: set security state as well...
1265             DPRINTF(Cache, "using temp block for %x (%s)\n", addr,
1266                     is_secure ? "s" : "ns");
1267         } else {
1268             tags->insertBlock(pkt, blk);
1269         }
1270 
1271         // we should never be overwriting a valid block
1272         assert(!blk->isValid());
1273     } else {
1274         // existing block... probably an upgrade
1275         assert(blk->tag == tags->extractTag(addr));
1276         // either we're getting new data or the block should already be valid
1277         assert(pkt->hasData() || blk->isValid());
1278         // don't clear block status... if block is already dirty we
1279         // don't want to lose that
1280     }
1281 
1282     if (is_secure)
1283         blk->status |= BlkSecure;
1284     blk->status |= BlkValid | BlkReadable;
1285 
1286     if (!pkt->sharedAsserted()) {
1287         blk->status |= BlkWritable;
1288         // If we got this via cache-to-cache transfer (i.e., from a
1289         // cache that was an owner) and took away that owner's copy,
1290         // then we need to write it back.  Normally this happens
1291         // anyway as a side effect of getting a copy to write it, but
1292         // there are cases (such as failed store conditionals or
1293         // compare-and-swaps) where we'll demand an exclusive copy but
1294         // end up not writing it.
1295         if (pkt->memInhibitAsserted())
1296             blk->status |= BlkDirty;
1297     }
1298 
1299     DPRINTF(Cache, "Block addr %x (%s) moving from state %x to %s\n",
1300             addr, is_secure ? "s" : "ns", old_state, blk->print());
1301 
1302     // if we got new data, copy it in
1303     if (pkt->isRead()) {
1304         std::memcpy(blk->data, pkt->getPtr<uint8_t>(), blkSize);
1305     }
1306 
1307     blk->whenReady = clockEdge() + responseLatency * clockPeriod() +
1308         pkt->busLastWordDelay;
1309 
1310     return blk;
1311 }
\end{DoxyCode}
\hypertarget{classCache_affa22df454ca8619381018b222c49c2d}{
\index{Cache@{Cache}!handleSnoop@{handleSnoop}}
\index{handleSnoop@{handleSnoop}!Cache@{Cache}}
\subsubsection[{handleSnoop}]{\setlength{\rightskip}{0pt plus 5cm}void handleSnoop ({\bf PacketPtr} {\em ptk}, \/  {\bf BlkType} $\ast$ {\em blk}, \/  bool {\em is\_\-timing}, \/  bool {\em is\_\-deferred}, \/  bool {\em pending\_\-inval})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_affa22df454ca8619381018b222c49c2d}
Sets the blk to the new state. 
\begin{DoxyParams}{引数}
\item[{\em blk}]The cache block being snooped. \item[{\em new\_\-state}]The new coherence state for the block. \end{DoxyParams}



\begin{DoxyCode}
1359 {
1360     DPRINTF(Cache, "%s for %s address %x size %d\n", __func__,
1361             pkt->cmdString(), pkt->getAddr(), pkt->getSize());
1362     // deferred snoops can only happen in timing mode
1363     assert(!(is_deferred && !is_timing));
1364     // pending_inval only makes sense on deferred snoops
1365     assert(!(pending_inval && !is_deferred));
1366     assert(pkt->isRequest());
1367 
1368     // the packet may get modified if we or a forwarded snooper
1369     // responds in atomic mode, so remember a few things about the
1370     // original packet up front
1371     bool invalidate = pkt->isInvalidate();
1372     bool M5_VAR_USED needs_exclusive = pkt->needsExclusive();
1373 
1374     if (forwardSnoops) {
1375         // first propagate snoop upward to see if anyone above us wants to
1376         // handle it.  save & restore packet src since it will get
1377         // rewritten to be relative to cpu-side bus (if any)
1378         bool alreadyResponded = pkt->memInhibitAsserted();
1379         if (is_timing) {
1380             Packet snoopPkt(pkt, true);  // clear flags
1381             snoopPkt.setExpressSnoop();
1382             snoopPkt.pushSenderState(new ForwardResponseRecord(pkt->getSrc()));
1383             // the snoop packet does not need to wait any additional
1384             // time
1385             snoopPkt.busFirstWordDelay = snoopPkt.busLastWordDelay = 0;
1386             cpuSidePort->sendTimingSnoopReq(&snoopPkt);
1387             if (snoopPkt.memInhibitAsserted()) {
1388                 // cache-to-cache response from some upper cache
1389                 assert(!alreadyResponded);
1390                 pkt->assertMemInhibit();
1391             } else {
1392                 delete snoopPkt.popSenderState();
1393             }
1394             if (snoopPkt.sharedAsserted()) {
1395                 pkt->assertShared();
1396             }
1397             // If this request is a prefetch and an
1398             // upper level squashes the prefetch request,
1399             // make sure to propogate the squash to the requester.
1400             if (snoopPkt.prefetchSquashed()) {
1401                 pkt->setPrefetchSquashed();
1402             }
1403         } else {
1404             cpuSidePort->sendAtomicSnoop(pkt);
1405             if (!alreadyResponded && pkt->memInhibitAsserted()) {
1406                 // cache-to-cache response from some upper cache:
1407                 // forward response to original requester
1408                 assert(pkt->isResponse());
1409             }
1410         }
1411     }
1412 
1413      if (!blk || !blk->isValid()) {
1414          DPRINTF(Cache, "%s snoop miss for %s address %x size %d\n",
1415                  __func__, pkt->cmdString(), pkt->getAddr(), pkt->getSize());
1416          return;
1417      } else {
1418         DPRINTF(Cache, "%s snoop hit for %s for address %x size %d, "
1419                 "old state is %s\n", __func__, pkt->cmdString(),
1420                 pkt->getAddr(), pkt->getSize(), blk->print());
1421      }
1422 
1423     // we may end up modifying both the block state and the packet (if
1424     // we respond in atomic mode), so just figure out what to do now
1425     // and then do it later
1426     bool respond = blk->isDirty() && pkt->needsResponse();
1427     bool have_exclusive = blk->isWritable();
1428 
1429     // Invalidate any prefetch's from below that would strip write permissions
1430     // MemCmd::HardPFReq is only observed by upstream caches.  After missing
1431     // above and in it's own cache, a new MemCmd::ReadReq is created that
1432     // downstream caches observe.
1433     if (pkt->cmd == MemCmd::HardPFReq) {
1434         DPRINTF(Cache, "Squashing prefetch from lower cache %#x\n",
1435                 pkt->getAddr());
1436         pkt->setPrefetchSquashed();
1437         return;
1438     }
1439 
1440     if (pkt->isRead() && !invalidate) {
1441         assert(!needs_exclusive);
1442         pkt->assertShared();
1443         int bits_to_clear = BlkWritable;
1444         const bool haveOwnershipState = true; // for now
1445         if (!haveOwnershipState) {
1446             // if we don't support pure ownership (dirty && !writable),
1447             // have to clear dirty bit here, assume memory snarfs data
1448             // on cache-to-cache xfer
1449             bits_to_clear |= BlkDirty;
1450         }
1451         blk->status &= ~bits_to_clear;
1452     }
1453 
1454     if (respond) {
1455         assert(!pkt->memInhibitAsserted());
1456         pkt->assertMemInhibit();
1457         if (have_exclusive) {
1458             pkt->setSupplyExclusive();
1459         }
1460         if (is_timing) {
1461             doTimingSupplyResponse(pkt, blk->data, is_deferred, pending_inval);
1462         } else {
1463             pkt->makeAtomicResponse();
1464             pkt->setDataFromBlock(blk->data, blkSize);
1465         }
1466     } else if (is_timing && is_deferred) {
1467         // if it's a deferred timing snoop then we've made a copy of
1468         // the packet, and so if we're not using that copy to respond
1469         // then we need to delete it here.
1470         delete pkt;
1471     }
1472 
1473     // Do this last in case it deallocates block data or something
1474     // like that
1475     if (invalidate) {
1476         if (blk != tempBlock)
1477             tags->invalidate(blk);
1478         blk->invalidate();
1479     }
1480 
1481     DPRINTF(Cache, "new state is %s\n", blk->print());
1482 }
\end{DoxyCode}
\hypertarget{classCache_a2a9a72a19c7910262542bc96de2488fb}{
\index{Cache@{Cache}!inCache@{inCache}}
\index{inCache@{inCache}!Cache@{Cache}}
\subsubsection[{inCache}]{\setlength{\rightskip}{0pt plus 5cm}bool inCache ({\bf Addr} {\em addr}, \/  bool {\em is\_\-secure}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classCache_a2a9a72a19c7910262542bc96de2488fb}


\hyperlink{classBaseCache_a2ac85ef6d4c6f16111c1da31c2363aa7}{BaseCache}を実装しています。


\begin{DoxyCode}
392                                                   {
393         return (tags->findBlock(addr, is_secure) != 0);
394     }
\end{DoxyCode}
\hypertarget{classCache_a01f08168ad1a2fee8ccff0f562da70de}{
\index{Cache@{Cache}!inMissQueue@{inMissQueue}}
\index{inMissQueue@{inMissQueue}!Cache@{Cache}}
\subsubsection[{inMissQueue}]{\setlength{\rightskip}{0pt plus 5cm}bool inMissQueue ({\bf Addr} {\em addr}, \/  bool {\em is\_\-secure}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classCache_a01f08168ad1a2fee8ccff0f562da70de}


\hyperlink{classBaseCache_abb47bf01a0bb0aa1c4e3d60fc2ca8175}{BaseCache}を実装しています。


\begin{DoxyCode}
396                                                       {
397         return (mshrQueue.findMatch(addr, is_secure) != 0);
398     }
\end{DoxyCode}
\hypertarget{classCache_a0a830cf4879a74de1790653f861c7d93}{
\index{Cache@{Cache}!invalidateVisitor@{invalidateVisitor}}
\index{invalidateVisitor@{invalidateVisitor}!Cache@{Cache}}
\subsubsection[{invalidateVisitor}]{\setlength{\rightskip}{0pt plus 5cm}bool invalidateVisitor ({\bf BlkType} \& {\em blk})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a0a830cf4879a74de1790653f861c7d93}
\hyperlink{classCache}{Cache} block visitor that invalidates all blocks in the cache.

Dirty cache lines will not be written back to memory.

\begin{DoxyReturn}{戻り値}
Always returns true. 
\end{DoxyReturn}



\begin{DoxyCode}
1168 {
1169 
1170     if (blk.isDirty())
1171         warn_once("Invalidating dirty cache lines. Expect things to break.\n");
1172 
1173     if (blk.isValid()) {
1174         assert(!blk.isDirty());
1175         tags->invalidate(dynamic_cast< BlkType *>(&blk));
1176         blk.invalidate();
1177     }
1178 
1179     return true;
1180 }
\end{DoxyCode}
\hypertarget{classCache_ad66f409af3c387e166ff7ee95169b7b6}{
\index{Cache@{Cache}!isDirty@{isDirty}}
\index{isDirty@{isDirty}!Cache@{Cache}}
\subsubsection[{isDirty}]{\setlength{\rightskip}{0pt plus 5cm}bool isDirty () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classCache_ad66f409af3c387e166ff7ee95169b7b6}
Determine if there are any dirty blocks in the cache.

\begin{DoxyReturn}{戻り値}
true if at least one block is dirty, false otherwise. 
\end{DoxyReturn}


\hyperlink{classBaseCache_a373dc1334f26db2ba94e827f3c9adc83}{BaseCache}を実装しています。


\begin{DoxyCode}
1136 {
1137     CacheBlkIsDirtyVisitor<BlkType> visitor;
1138     tags->forEachBlk(visitor);
1139 
1140     return visitor.isDirty();
1141 }
\end{DoxyCode}
\hypertarget{classCache_ac7fb6ca824d25de54878584fd9dd8162}{
\index{Cache@{Cache}!markInService@{markInService}}
\index{markInService@{markInService}!Cache@{Cache}}
\subsubsection[{markInService}]{\setlength{\rightskip}{0pt plus 5cm}void markInService ({\bf MSHR} $\ast$ {\em mshr}, \/  {\bf PacketPtr} {\em pkt} = {\ttfamily 0})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_ac7fb6ca824d25de54878584fd9dd8162}
Marks a request as in service (sent on the bus). This can have side effect since storage for no response commands is deallocated once they are successfully sent. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]The request that was sent on the bus. \end{DoxyParams}



\begin{DoxyCode}
245 {
246     markInServiceInternal(mshr, pkt);
247 #if 0
248         if (mshr->originalCmd == MemCmd::HardPFReq) {
249             DPRINTF(HWPrefetch, "%s:Marking a HW_PF in service\n",
250                     name());
251             //Also clear pending if need be
252             if (!prefetcher->havePending())
253             {
254                 deassertMemSideBusRequest(Request_PF);
255             }
256         }
257 #endif
258 }
\end{DoxyCode}
\hypertarget{classCache_afea64b0aa579c17485db54c6a5c2ede3}{
\index{Cache@{Cache}!memInvalidate@{memInvalidate}}
\index{memInvalidate@{memInvalidate}!Cache@{Cache}}
\subsubsection[{memInvalidate}]{\setlength{\rightskip}{0pt plus 5cm}void memInvalidate ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classCache_afea64b0aa579c17485db54c6a5c2ede3}
Invalidates all blocks in the cache.

Dirty cache lines will not be written back to memory. Make sure to call functionalWriteback() first if you want the to write them to memory. 

\hyperlink{classBaseCache_aeb9356f940fbf8410f41920ee1d5864d}{BaseCache}を実装しています。


\begin{DoxyCode}
1128 {
1129     WrappedBlkVisitor visitor(*this, &Cache<TagStore>::invalidateVisitor);
1130     tags->forEachBlk(visitor);
1131 }
\end{DoxyCode}
\hypertarget{classCache_a381272ae5c2cc173adb59cd67a76b458}{
\index{Cache@{Cache}!memWriteback@{memWriteback}}
\index{memWriteback@{memWriteback}!Cache@{Cache}}
\subsubsection[{memWriteback}]{\setlength{\rightskip}{0pt plus 5cm}void memWriteback ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classCache_a381272ae5c2cc173adb59cd67a76b458}
Write back dirty blocks in the cache using functional accesses. 

\hyperlink{classBaseCache_afd3c83f1883488031612de6c47fcaabb}{BaseCache}を実装しています。


\begin{DoxyCode}
1120 {
1121     WrappedBlkVisitor visitor(*this, &Cache<TagStore>::writebackVisitor);
1122     tags->forEachBlk(visitor);
1123 }
\end{DoxyCode}
\hypertarget{classCache_a4601a57ba7740776052541f212c29cbd}{
\index{Cache@{Cache}!nextMSHRReadyTime@{nextMSHRReadyTime}}
\index{nextMSHRReadyTime@{nextMSHRReadyTime}!Cache@{Cache}}
\subsubsection[{nextMSHRReadyTime}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} nextMSHRReadyTime () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a4601a57ba7740776052541f212c29cbd}
Find next request ready time from among possible sources. 


\begin{DoxyCode}
1806 {
1807     Tick nextReady = std::min(mshrQueue.nextMSHRReadyTime(),
1808                               writeBuffer.nextMSHRReadyTime());
1809 
1810     if (prefetcher) {
1811         nextReady = std::min(nextReady,
1812                              prefetcher->nextPrefetchReadyTime());
1813     }
1814 
1815     return nextReady;
1816 }
\end{DoxyCode}
\hypertarget{classCache_ac40e843a35136aebfb61fc0c9f57aa27}{
\index{Cache@{Cache}!outstandingMisses@{outstandingMisses}}
\index{outstandingMisses@{outstandingMisses}!Cache@{Cache}}
\subsubsection[{outstandingMisses}]{\setlength{\rightskip}{0pt plus 5cm}bool outstandingMisses () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_ac40e843a35136aebfb61fc0c9f57aa27}
Return whether there are any outstanding misses. 


\begin{DoxyCode}
384     {
385         return mshrQueue.allocated != 0;
386     }
\end{DoxyCode}
\hypertarget{classCache_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{
\index{Cache@{Cache}!recvAtomic@{recvAtomic}}
\index{recvAtomic@{recvAtomic}!Cache@{Cache}}
\subsubsection[{recvAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvAtomic ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}
Performs the access specified by the request. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]The request to perform. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
The number of ticks required for the access. 
\end{DoxyReturn}



\begin{DoxyCode}
673 {
674     Cycles lat = hitLatency;
675 
676     // @TODO: make this a parameter
677     bool last_level_cache = false;
678 
679     // Forward the request if the system is in cache bypass mode.
680     if (system->bypassCaches())
681         return ticksToCycles(memSidePort->sendAtomic(pkt));
682 
683     if (pkt->memInhibitAsserted()) {
684         assert(!pkt->req->isUncacheable());
685         // have to invalidate ourselves and any lower caches even if
686         // upper cache will be responding
687         if (pkt->isInvalidate()) {
688             BlkType *blk = tags->findBlock(pkt->getAddr(), pkt->isSecure());
689             if (blk && blk->isValid()) {
690                 tags->invalidate(blk);
691                 blk->invalidate();
692                 DPRINTF(Cache, "rcvd mem-inhibited %s on 0x%x (%s):"
693                         " invalidating\n",
694                         pkt->cmdString(), pkt->getAddr(),
695                         pkt->isSecure() ? "s" : "ns");
696             }
697             if (!last_level_cache) {
698                 DPRINTF(Cache, "forwarding mem-inhibited %s on 0x%x (%s)\n",
699                         pkt->cmdString(), pkt->getAddr(),
700                         pkt->isSecure() ? "s" : "ns");
701                 lat += ticksToCycles(memSidePort->sendAtomic(pkt));
702             }
703         } else {
704             DPRINTF(Cache, "rcvd mem-inhibited %s on 0x%x: not responding\n",
705                     pkt->cmdString(), pkt->getAddr());
706         }
707 
708         return lat * clockPeriod();
709     }
710 
711     // should assert here that there are no outstanding MSHRs or
712     // writebacks... that would mean that someone used an atomic
713     // access in timing mode
714 
715     BlkType *blk = NULL;
716     PacketList writebacks;
717 
718     if (!access(pkt, blk, lat, writebacks)) {
719         // MISS
720         PacketPtr bus_pkt = getBusPacket(pkt, blk, pkt->needsExclusive());
721 
722         bool is_forward = (bus_pkt == NULL);
723 
724         if (is_forward) {
725             // just forwarding the same request to the next level
726             // no local cache operation involved
727             bus_pkt = pkt;
728         }
729 
730         DPRINTF(Cache, "Sending an atomic %s for %x (%s)\n",
731                 bus_pkt->cmdString(), bus_pkt->getAddr(),
732                 bus_pkt->isSecure() ? "s" : "ns");
733 
734 #if TRACING_ON
735         CacheBlk::State old_state = blk ? blk->status : 0;
736 #endif
737 
738         lat += ticksToCycles(memSidePort->sendAtomic(bus_pkt));
739 
740         DPRINTF(Cache, "Receive response: %s for addr %x (%s) in state %i\n",
741                 bus_pkt->cmdString(), bus_pkt->getAddr(),
742                 bus_pkt->isSecure() ? "s" : "ns",
743                 old_state);
744 
745         // If packet was a forward, the response (if any) is already
746         // in place in the bus_pkt == pkt structure, so we don't need
747         // to do anything.  Otherwise, use the separate bus_pkt to
748         // generate response to pkt and then delete it.
749         if (!is_forward) {
750             if (pkt->needsResponse()) {
751                 assert(bus_pkt->isResponse());
752                 if (bus_pkt->isError()) {
753                     pkt->makeAtomicResponse();
754                     pkt->copyError(bus_pkt);
755                 } else if (bus_pkt->isRead() ||
756                            bus_pkt->cmd == MemCmd::UpgradeResp) {
757                     // we're updating cache state to allow us to
758                     // satisfy the upstream request from the cache
759                     blk = handleFill(bus_pkt, blk, writebacks);
760                     satisfyCpuSideRequest(pkt, blk);
761                 } else {
762                     // we're satisfying the upstream request without
763                     // modifying cache state, e.g., a write-through
764                     pkt->makeAtomicResponse();
765                 }
766             }
767             delete bus_pkt;
768         }
769     }
770 
771     // Note that we don't invoke the prefetcher at all in atomic mode.
772     // It's not clear how to do it properly, particularly for
773     // prefetchers that aggressively generate prefetch candidates and
774     // rely on bandwidth contention to throttle them; these will tend
775     // to pollute the cache in atomic mode since there is no bandwidth
776     // contention.  If we ever do want to enable prefetching in atomic
777     // mode, though, this is the place to do it... see timingAccess()
778     // for an example (though we'd want to issue the prefetch(es)
779     // immediately rather than calling requestMemSideBus() as we do
780     // there).
781 
782     // Handle writebacks if needed
783     while (!writebacks.empty()){
784         PacketPtr wbPkt = writebacks.front();
785         memSidePort->sendAtomic(wbPkt);
786         writebacks.pop_front();
787         delete wbPkt;
788     }
789 
790     // We now have the block one way or another (hit or completed miss)
791 
792     if (pkt->needsResponse()) {
793         pkt->makeAtomicResponse();
794     }
795 
796     return lat * clockPeriod();
797 }
\end{DoxyCode}
\hypertarget{classCache_a886d584c81ee4e398ff8069907f6e1a5}{
\index{Cache@{Cache}!recvAtomicSnoop@{recvAtomicSnoop}}
\index{recvAtomicSnoop@{recvAtomicSnoop}!Cache@{Cache}}
\subsubsection[{recvAtomicSnoop}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvAtomicSnoop ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a886d584c81ee4e398ff8069907f6e1a5}
Snoop for the provided request in the cache and return the estimated time taken. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]The memory request to snoop \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
The number of ticks required for the snoop. 
\end{DoxyReturn}



\begin{DoxyCode}
1602 {
1603     // Snoops shouldn't happen when bypassing caches
1604     assert(!system->bypassCaches());
1605 
1606     if (pkt->req->isUncacheable() || pkt->cmd == MemCmd::Writeback) {
1607         // Can't get a hit on an uncacheable address
1608         // Revisit this for multi level coherence
1609         return 0;
1610     }
1611 
1612     BlkType *blk = tags->findBlock(pkt->getAddr(), pkt->isSecure());
1613     handleSnoop(pkt, blk, false, false, false);
1614     return hitLatency * clockPeriod();
1615 }
\end{DoxyCode}
\hypertarget{classCache_a3344d9dd0f83257feab5424e761f31c6}{
\index{Cache@{Cache}!recvTimingReq@{recvTimingReq}}
\index{recvTimingReq@{recvTimingReq}!Cache@{Cache}}
\subsubsection[{recvTimingReq}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingReq ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a3344d9dd0f83257feab5424e761f31c6}
Performs the access specified by the request. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]The request to perform. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
The result of the access. 
\end{DoxyReturn}


\begin{Desc}
\item[\hyperlink{todo__todo000075}{TODO}]temporary hack to deal with memory corruption issue until 4-\/phase transactions are complete \end{Desc}


\begin{Desc}
\item[\hyperlink{todo__todo000076}{TODO}]nominally we should just delete the packet here, however, until 4-\/phase stuff we can't because sending cache is still relying on it \end{Desc}


\begin{Desc}
\item[\hyperlink{todo__todo000077}{TODO}]nominally we should just delete the packet here, however, until 4-\/phase stuff we can't because sending cache is still relying on it \end{Desc}


\hyperlink{classMSHR}{MSHR} hit \begin{DoxyNote}{覚え書き}
writebacks will be checked in \hyperlink{classCache_a3ce02537ee4a8918300802fda9b82b47}{getNextMSHR()} for any conflicting requests to the same block 
\end{DoxyNote}



\begin{DoxyCode}
411 {
412     DPRINTF(CacheTags, "%s tags: %s\n", __func__, tags->print());
413 //@todo Add back in MemDebug Calls
414 //    MemDebug::cacheAccess(pkt);
415 
416 
419     for (int x = 0; x < pendingDelete.size(); x++)
420         delete pendingDelete[x];
421     pendingDelete.clear();
422 
423     // we charge hitLatency for doing just about anything here
424     Tick time = clockEdge(hitLatency);
425 
426     assert(pkt->isRequest());
427 
428     // Just forward the packet if caches are disabled.
429     if (system->bypassCaches()) {
430         memSidePort->sendTimingReq(pkt);
431         return true;
432     }
433 
434     if (pkt->memInhibitAsserted()) {
435         DPRINTF(Cache, "mem inhibited on 0x%x (%s): not responding\n",
436                 pkt->getAddr(), pkt->isSecure() ? "s" : "ns");
437         assert(!pkt->req->isUncacheable());
438         // Special tweak for multilevel coherence: snoop downward here
439         // on invalidates since there may be other caches below here
440         // that have shared copies.  Not necessary if we know that
441         // supplier had exclusive copy to begin with.
442         if (pkt->needsExclusive() && !pkt->isSupplyExclusive()) {
443             Packet *snoopPkt = new Packet(pkt, true);  // clear flags
444             // also reset the bus time that the original packet has
445             // not yet paid for
446             snoopPkt->busFirstWordDelay = snoopPkt->busLastWordDelay = 0;
447             snoopPkt->setExpressSnoop();
448             snoopPkt->assertMemInhibit();
449             memSidePort->sendTimingReq(snoopPkt);
450             // main memory will delete snoopPkt
451         }
452         // since we're the official target but we aren't responding,
453         // delete the packet now.
454 
458         pendingDelete.push_back(pkt);
459         return true;
460     }
461 
462     if (pkt->req->isUncacheable()) {
463         uncacheableFlush(pkt);
464 
465         // @todo: someone should pay for this
466         pkt->busFirstWordDelay = pkt->busLastWordDelay = 0;
467 
468         // writes go in write buffer, reads use MSHR
469         if (pkt->isWrite() && !pkt->isRead()) {
470             allocateWriteBuffer(pkt, time, true);
471         } else {
472             allocateUncachedReadBuffer(pkt, time, true);
473         }
474         assert(pkt->needsResponse()); // else we should delete it here??
475         return true;
476     }
477 
478     Cycles lat = hitLatency;
479     BlkType *blk = NULL;
480     PacketList writebacks;
481 
482     bool satisfied = access(pkt, blk, lat, writebacks);
483 
484 #if 0
485 
487     // If this is a block size write/hint (WH64) allocate the block here
488     // if the coherence protocol allows it.
489     if (!blk && pkt->getSize() >= blkSize && coherence->allowFastWrites() &&
490         (pkt->cmd == MemCmd::WriteReq
491          || pkt->cmd == MemCmd::WriteInvalidateReq) ) {
492         // not outstanding misses, can do this
493         MSHR *outstanding_miss = mshrQueue.findMatch(pkt->getAddr(),
494                                                      pkt->isSecure());
495         if (pkt->cmd == MemCmd::WriteInvalidateReq || !outstanding_miss) {
496             if (outstanding_miss) {
497                 warn("WriteInv doing a fastallocate"
498                      "with an outstanding miss to the same address\n");
499             }
500             blk = handleFill(NULL, pkt, BlkValid | BlkWritable,
501                                    writebacks);
502             ++fastWrites;
503         }
504     }
505 #endif
506 
507     // track time of availability of next prefetch, if any
508     Tick next_pf_time = 0;
509 
510     bool needsResponse = pkt->needsResponse();
511 
512     if (satisfied) {
513         if (prefetcher && (prefetchOnAccess || (blk && blk->wasPrefetched()))) {
514             if (blk)
515                 blk->status &= ~BlkHWPrefetched;
516             next_pf_time = prefetcher->notify(pkt, time);
517         }
518 
519         if (needsResponse) {
520             pkt->makeTimingResponse();
521             // @todo: Make someone pay for this
522             pkt->busFirstWordDelay = pkt->busLastWordDelay = 0;
523             cpuSidePort->schedTimingResp(pkt, clockEdge(lat));
524         } else {
528             pendingDelete.push_back(pkt);
529         }
530     } else {
531         // miss
532 
533         // @todo: Make someone pay for this
534         pkt->busFirstWordDelay = pkt->busLastWordDelay = 0;
535 
536         Addr blk_addr = blockAlign(pkt->getAddr());
537         MSHR *mshr = mshrQueue.findMatch(blk_addr, pkt->isSecure());
538 
539         if (mshr) {
543 
544             //@todo remove hw_pf here
545             assert(pkt->req->masterId() < system->maxMasters());
546             mshr_hits[pkt->cmdToIndex()][pkt->req->masterId()]++;
547             if (mshr->threadNum != 0/*pkt->req->threadId()*/) {
548                 mshr->threadNum = -1;
549             }
550             mshr->allocateTarget(pkt, time, order++);
551             if (mshr->getNumTargets() == numTarget) {
552                 noTargetMSHR = mshr;
553                 setBlocked(Blocked_NoTargets);
554                 // need to be careful with this... if this mshr isn't
555                 // ready yet (i.e. time > curTick()_, we don't want to
556                 // move it ahead of mshrs that are ready
557                 // mshrQueue.moveToFront(mshr);
558             }
559 
560             // We should call the prefetcher reguardless if the request is
561             // satisfied or not, reguardless if the request is in the MSHR or
562             // not.  The request could be a ReadReq hit, but still not
563             // satisfied (potentially because of a prior write to the same
564             // cache line.  So, even when not satisfied, tehre is an MSHR
565             // already allocated for this, we need to let the prefetcher know
566             // about the request
567             if (prefetcher) {
568                 next_pf_time = prefetcher->notify(pkt, time);
569             }
570         } else {
571             // no MSHR
572             assert(pkt->req->masterId() < system->maxMasters());
573             mshr_misses[pkt->cmdToIndex()][pkt->req->masterId()]++;
574             // always mark as cache fill for now... if we implement
575             // no-write-allocate or bypass accesses this will have to
576             // be changed.
577             if (pkt->cmd == MemCmd::Writeback) {
578                 allocateWriteBuffer(pkt, time, true);
579             } else {
580                 if (blk && blk->isValid()) {
581                     // If we have a write miss to a valid block, we
582                     // need to mark the block non-readable.  Otherwise
583                     // if we allow reads while there's an outstanding
584                     // write miss, the read could return stale data
585                     // out of the cache block... a more aggressive
586                     // system could detect the overlap (if any) and
587                     // forward data out of the MSHRs, but we don't do
588                     // that yet.  Note that we do need to leave the
589                     // block valid so that it stays in the cache, in
590                     // case we get an upgrade response (and hence no
591                     // new data) when the write miss completes.
592                     // As long as CPUs do proper store/load forwarding
593                     // internally, and have a sufficiently weak memory
594                     // model, this is probably unnecessary, but at some
595                     // point it must have seemed like we needed it...
596                     assert(pkt->needsExclusive() && !blk->isWritable());
597                     blk->status &= ~BlkReadable;
598                 }
599 
600                 allocateMissBuffer(pkt, time, true);
601             }
602 
603             if (prefetcher) {
604                 next_pf_time = prefetcher->notify(pkt, time);
605             }
606         }
607     }
608 
609     if (next_pf_time != 0)
610         requestMemSideBus(Request_PF, std::max(time, next_pf_time));
611 
612     // copy writebacks to write buffer
613     while (!writebacks.empty()) {
614         PacketPtr wbPkt = writebacks.front();
615         allocateWriteBuffer(wbPkt, time, true);
616         writebacks.pop_front();
617     }
618 
619     return true;
620 }
\end{DoxyCode}
\hypertarget{classCache_a083c4da6cf866d660a126f4174bba7fc}{
\index{Cache@{Cache}!recvTimingResp@{recvTimingResp}}
\index{recvTimingResp@{recvTimingResp}!Cache@{Cache}}
\subsubsection[{recvTimingResp}]{\setlength{\rightskip}{0pt plus 5cm}void recvTimingResp ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a083c4da6cf866d660a126f4174bba7fc}
Handles a response (cache line fill/write ack) from the bus. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]The response packet \end{DoxyParams}



\begin{DoxyCode}
880 {
881     assert(pkt->isResponse());
882 
883     Tick time = clockEdge(hitLatency);
884     MSHR *mshr = dynamic_cast<MSHR*>(pkt->senderState);
885     bool is_error = pkt->isError();
886 
887     assert(mshr);
888 
889     if (is_error) {
890         DPRINTF(Cache, "Cache received packet with error for address %x (%s), "
891                 "cmd: %s\n", pkt->getAddr(), pkt->isSecure() ? "s" : "ns",
892                 pkt->cmdString());
893     }
894 
895     DPRINTF(Cache, "Handling response to %s for address %x (%s)\n",
896             pkt->cmdString(), pkt->getAddr(), pkt->isSecure() ? "s" : "ns");
897 
898     MSHRQueue *mq = mshr->queue;
899     bool wasFull = mq->isFull();
900 
901     if (mshr == noTargetMSHR) {
902         // we always clear at least one target
903         clearBlocked(Blocked_NoTargets);
904         noTargetMSHR = NULL;
905     }
906 
907     // Initial target is used just for stats
908     MSHR::Target *initial_tgt = mshr->getTarget();
909     BlkType *blk = tags->findBlock(pkt->getAddr(), pkt->isSecure());
910     int stats_cmd_idx = initial_tgt->pkt->cmdToIndex();
911     Tick miss_latency = curTick() - initial_tgt->recvTime;
912     PacketList writebacks;
913 
914     if (pkt->req->isUncacheable()) {
915         assert(pkt->req->masterId() < system->maxMasters());
916         mshr_uncacheable_lat[stats_cmd_idx][pkt->req->masterId()] +=
917             miss_latency;
918     } else {
919         assert(pkt->req->masterId() < system->maxMasters());
920         mshr_miss_latency[stats_cmd_idx][pkt->req->masterId()] +=
921             miss_latency;
922     }
923 
924     bool is_fill = !mshr->isForward &&
925         (pkt->isRead() || pkt->cmd == MemCmd::UpgradeResp);
926 
927     if (is_fill && !is_error) {
928         DPRINTF(Cache, "Block for addr %x being updated in Cache\n",
929                 pkt->getAddr());
930 
931         // give mshr a chance to do some dirty work
932         mshr->handleFill(pkt, blk);
933 
934         blk = handleFill(pkt, blk, writebacks);
935         assert(blk != NULL);
936     }
937 
938     // First offset for critical word first calculations
939     int initial_offset = 0;
940 
941     if (mshr->hasTargets()) {
942         initial_offset = mshr->getTarget()->pkt->getOffset(blkSize);
943     }
944 
945     while (mshr->hasTargets()) {
946         MSHR::Target *target = mshr->getTarget();
947 
948         switch (target->source) {
949           case MSHR::Target::FromCPU:
950             Tick completion_time;
951             if (is_fill) {
952                 satisfyCpuSideRequest(target->pkt, blk,
953                                       true, mshr->hasPostDowngrade());
954                 // How many bytes past the first request is this one
955                 int transfer_offset =
956                     target->pkt->getOffset(blkSize) - initial_offset;
957                 if (transfer_offset < 0) {
958                     transfer_offset += blkSize;
959                 }
960 
961                 // If critical word (no offset) return first word time.
962                 // responseLatency is the latency of the return path
963                 // from lower level caches/memory to an upper level cache or
964                 // the core.
965                 completion_time = clockEdge(responseLatency) +
966                     (transfer_offset ? pkt->busLastWordDelay :
967                      pkt->busFirstWordDelay);
968 
969                 assert(!target->pkt->req->isUncacheable());
970 
971                 assert(target->pkt->req->masterId() < system->maxMasters());
972                 missLatency[target->pkt->cmdToIndex()][target->pkt->req->
      masterId()] +=
973                     completion_time - target->recvTime;
974             } else if (pkt->cmd == MemCmd::UpgradeFailResp) {
975                 // failed StoreCond upgrade
976                 assert(target->pkt->cmd == MemCmd::StoreCondReq ||
977                        target->pkt->cmd == MemCmd::StoreCondFailReq ||
978                        target->pkt->cmd == MemCmd::SCUpgradeFailReq);
979                 // responseLatency is the latency of the return path
980                 // from lower level caches/memory to an upper level cache or
981                 // the core.
982                 completion_time = clockEdge(responseLatency) +
983                     pkt->busLastWordDelay;
984                 target->pkt->req->setExtraData(0);
985             } else {
986                 // not a cache fill, just forwarding response
987                 // responseLatency is the latency of the return path
988                 // from lower level cahces/memory to the core.
989                 completion_time = clockEdge(responseLatency) +
990                     pkt->busLastWordDelay;
991                 if (pkt->isRead() && !is_error) {
992                     target->pkt->setData(pkt->getPtr<uint8_t>());
993                 }
994             }
995             target->pkt->makeTimingResponse();
996             // if this packet is an error copy that to the new packet
997             if (is_error)
998                 target->pkt->copyError(pkt);
999             if (target->pkt->cmd == MemCmd::ReadResp &&
1000                 (pkt->isInvalidate() || mshr->hasPostInvalidate())) {
1001                 // If intermediate cache got ReadRespWithInvalidate,
1002                 // propagate that.  Response should not have
1003                 // isInvalidate() set otherwise.
1004                 target->pkt->cmd = MemCmd::ReadRespWithInvalidate;
1005                 DPRINTF(Cache, "%s updated cmd to %s for address %x\n",
1006                         __func__, target->pkt->cmdString(),
1007                         target->pkt->getAddr());
1008             }
1009             // reset the bus additional time as it is now accounted for
1010             target->pkt->busFirstWordDelay = target->pkt->busLastWordDelay = 0;
1011             cpuSidePort->schedTimingResp(target->pkt, completion_time);
1012             break;
1013 
1014           case MSHR::Target::FromPrefetcher:
1015             assert(target->pkt->cmd == MemCmd::HardPFReq);
1016             if (blk)
1017                 blk->status |= BlkHWPrefetched;
1018             delete target->pkt->req;
1019             delete target->pkt;
1020             break;
1021 
1022           case MSHR::Target::FromSnoop:
1023             // I don't believe that a snoop can be in an error state
1024             assert(!is_error);
1025             // response to snoop request
1026             DPRINTF(Cache, "processing deferred snoop...\n");
1027             assert(!(pkt->isInvalidate() && !mshr->hasPostInvalidate()));
1028             handleSnoop(target->pkt, blk, true, true,
1029                         mshr->hasPostInvalidate());
1030             break;
1031 
1032           default:
1033             panic("Illegal target->source enum %d\n", target->source);
1034         }
1035 
1036         mshr->popTarget();
1037     }
1038 
1039     if (blk && blk->isValid()) {
1040         if (pkt->isInvalidate() || mshr->hasPostInvalidate()) {
1041             assert(blk != tempBlock);
1042             tags->invalidate(blk);
1043             blk->invalidate();
1044         } else if (mshr->hasPostDowngrade()) {
1045             blk->status &= ~BlkWritable;
1046         }
1047     }
1048 
1049     if (mshr->promoteDeferredTargets()) {
1050         // avoid later read getting stale data while write miss is
1051         // outstanding.. see comment in timingAccess()
1052         if (blk) {
1053             blk->status &= ~BlkReadable;
1054         }
1055         mq = mshr->queue;
1056         mq->markPending(mshr);
1057         requestMemSideBus((RequestCause)mq->index, clockEdge() +
1058                           pkt->busLastWordDelay);
1059     } else {
1060         mq->deallocate(mshr);
1061         if (wasFull && !mq->isFull()) {
1062             clearBlocked((BlockedCause)mq->index);
1063         }
1064     }
1065 
1066     // copy writebacks to write buffer
1067     while (!writebacks.empty()) {
1068         PacketPtr wbPkt = writebacks.front();
1069         allocateWriteBuffer(wbPkt, time, true);
1070         writebacks.pop_front();
1071     }
1072     // if we used temp block, clear it out
1073     if (blk == tempBlock) {
1074         if (blk->isDirty()) {
1075             allocateWriteBuffer(writebackBlk(blk), time, true);
1076         }
1077         blk->invalidate();
1078     }
1079 
1080     DPRINTF(Cache, "Leaving %s with %s for address %x\n", __func__,
1081             pkt->cmdString(), pkt->getAddr());
1082     delete pkt;
1083 }
\end{DoxyCode}
\hypertarget{classCache_aff3031c56fc4947a19695c868bb8233e}{
\index{Cache@{Cache}!recvTimingSnoopReq@{recvTimingSnoopReq}}
\index{recvTimingSnoopReq@{recvTimingSnoopReq}!Cache@{Cache}}
\subsubsection[{recvTimingSnoopReq}]{\setlength{\rightskip}{0pt plus 5cm}void recvTimingSnoopReq ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_aff3031c56fc4947a19695c868bb8233e}
Snoops bus transactions to maintain coherence. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]The current bus transaction. \end{DoxyParams}



\begin{DoxyCode}
1488 {
1489     DPRINTF(Cache, "%s for %s address %x size %d\n", __func__,
1490             pkt->cmdString(), pkt->getAddr(), pkt->getSize());
1491 
1492     // Snoops shouldn't happen when bypassing caches
1493     assert(!system->bypassCaches());
1494 
1495     // check if the packet is for an address range covered by this
1496     // cache, partly to not waste time looking for it, but also to
1497     // ensure that we only forward the snoop upwards if it is within
1498     // our address ranges
1499     bool in_range = false;
1500     for (AddrRangeList::const_iterator r = addrRanges.begin();
1501          r != addrRanges.end(); ++r) {
1502         if (r->contains(pkt->getAddr())) {
1503             in_range = true;
1504             break;
1505         }
1506     }
1507 
1508     // Note that some deferred snoops don't have requests, since the
1509     // original access may have already completed
1510     if ((pkt->req && pkt->req->isUncacheable()) ||
1511         pkt->cmd == MemCmd::Writeback || !in_range) {
1512         //Can't get a hit on an uncacheable address
1513         //Revisit this for multi level coherence
1514         return;
1515     }
1516 
1517     bool is_secure = pkt->isSecure();
1518     BlkType *blk = tags->findBlock(pkt->getAddr(), is_secure);
1519 
1520     Addr blk_addr = blockAlign(pkt->getAddr());
1521     MSHR *mshr = mshrQueue.findMatch(blk_addr, is_secure);
1522 
1523     // Squash any prefetch requests from below on MSHR hits
1524     if (mshr && pkt->cmd == MemCmd::HardPFReq) {
1525         DPRINTF(Cache, "Squashing prefetch from lower cache on mshr hit %#x\n",
1526                 pkt->getAddr());
1527         pkt->setPrefetchSquashed();
1528         return;
1529     }
1530 
1531     // Let the MSHR itself track the snoop and decide whether we want
1532     // to go ahead and do the regular cache snoop
1533     if (mshr && mshr->handleSnoop(pkt, order++)) {
1534         DPRINTF(Cache, "Deferring snoop on in-service MSHR to blk %x (%s)."
1535                 "mshrs: %s\n", blk_addr, is_secure ? "s" : "ns",
1536                 mshr->print());
1537 
1538         if (mshr->getNumTargets() > numTarget)
1539             warn("allocating bonus target for snoop"); //handle later
1540         return;
1541     }
1542 
1543     //We also need to check the writeback buffers and handle those
1544     std::vector<MSHR *> writebacks;
1545     if (writeBuffer.findMatches(blk_addr, is_secure, writebacks)) {
1546         DPRINTF(Cache, "Snoop hit in writeback to addr: %x (%s)\n",
1547                 pkt->getAddr(), is_secure ? "s" : "ns");
1548 
1549         //Look through writebacks for any non-uncachable writes, use that
1550         if (writebacks.size()) {
1551             // We should only ever find a single match
1552             assert(writebacks.size() == 1);
1553             mshr = writebacks[0];
1554             assert(!mshr->isUncacheable());
1555             assert(mshr->getNumTargets() == 1);
1556             PacketPtr wb_pkt = mshr->getTarget()->pkt;
1557             assert(wb_pkt->cmd == MemCmd::Writeback);
1558 
1559             assert(!pkt->memInhibitAsserted());
1560             pkt->assertMemInhibit();
1561             if (!pkt->needsExclusive()) {
1562                 pkt->assertShared();
1563                 // the writeback is no longer the exclusive copy in the system
1564                 wb_pkt->clearSupplyExclusive();
1565             } else {
1566                 // if we're not asserting the shared line, we need to
1567                 // invalidate our copy.  we'll do that below as long as
1568                 // the packet's invalidate flag is set...
1569                 assert(pkt->isInvalidate());
1570             }
1571             doTimingSupplyResponse(pkt, wb_pkt->getPtr<uint8_t>(),
1572                                    false, false);
1573 
1574             if (pkt->isInvalidate()) {
1575                 // Invalidation trumps our writeback... discard here
1576                 markInService(mshr);
1577                 delete wb_pkt;
1578             }
1579         } // writebacks.size()
1580     }
1581 
1582     // If this was a shared writeback, there may still be
1583     // other shared copies above that require invalidation.
1584     // We could be more selective and return here if the
1585     // request is non-exclusive or if the writeback is
1586     // exclusive.
1587     handleSnoop(pkt, blk, true, false, false);
1588 }
\end{DoxyCode}
\hypertarget{classCache_a55143a3333ff75d0df66bd6e4eb50fb7}{
\index{Cache@{Cache}!recvTimingSnoopResp@{recvTimingSnoopResp}}
\index{recvTimingSnoopResp@{recvTimingSnoopResp}!Cache@{Cache}}
\subsubsection[{recvTimingSnoopResp}]{\setlength{\rightskip}{0pt plus 5cm}void recvTimingSnoopResp ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a55143a3333ff75d0df66bd6e4eb50fb7}
Handle a snoop response. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]Snoop response packet \end{DoxyParams}



\begin{DoxyCode}
378 {
379     DPRINTF(Cache, "%s for %s address %x size %d\n", __func__,
380             pkt->cmdString(), pkt->getAddr(), pkt->getSize());
381     Tick time = clockEdge(hitLatency);
382 
383     assert(pkt->isResponse());
384 
385     // must be cache-to-cache response from upper to lower level
386     ForwardResponseRecord *rec =
387         dynamic_cast<ForwardResponseRecord *>(pkt->senderState);
388     assert(!system->bypassCaches());
389 
390     if (rec == NULL) {
391         assert(pkt->cmd == MemCmd::HardPFResp);
392         // Check if it's a prefetch response and handle it. We shouldn't
393         // get any other kinds of responses without FRRs.
394         DPRINTF(Cache, "Got prefetch response from above for addr %#x (%s)\n",
395                 pkt->getAddr(), pkt->isSecure() ? "s" : "ns");
396         recvTimingResp(pkt);
397         return;
398     }
399 
400     pkt->popSenderState();
401     pkt->setDest(rec->prevSrc);
402     delete rec;
403     // @todo someone should pay for this
404     pkt->busFirstWordDelay = pkt->busLastWordDelay = 0;
405     memSidePort->schedTimingSnoopResp(pkt, time);
406 }
\end{DoxyCode}
\hypertarget{classCache_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{Cache@{Cache}!regStats@{regStats}}
\index{regStats@{regStats}!Cache@{Cache}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classCache_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} stats for this object. 

\hyperlink{classBaseCache_a4dc637449366fcdfc4e764cdf12d9b11}{BaseCache}を再定義しています。


\begin{DoxyCode}
102 {
103     BaseCache::regStats();
104 }
\end{DoxyCode}
\hypertarget{classCache_a5d5d5944479d29a7bfc183f4b2b6a4fa}{
\index{Cache@{Cache}!satisfyCpuSideRequest@{satisfyCpuSideRequest}}
\index{satisfyCpuSideRequest@{satisfyCpuSideRequest}!Cache@{Cache}}
\subsubsection[{satisfyCpuSideRequest}]{\setlength{\rightskip}{0pt plus 5cm}void satisfyCpuSideRequest ({\bf PacketPtr} {\em pkt}, \/  {\bf BlkType} $\ast$ {\em blk}, \/  bool {\em deferred\_\-response} = {\ttfamily false}, \/  bool {\em pending\_\-downgrade} = {\ttfamily false})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a5d5d5944479d29a7bfc183f4b2b6a4fa}



\begin{DoxyCode}
151 {
152     assert(blk && blk->isValid());
153     // Occasionally this is not true... if we are a lower-level cache
154     // satisfying a string of Read and ReadEx requests from
155     // upper-level caches, a Read will mark the block as shared but we
156     // can satisfy a following ReadEx anyway since we can rely on the
157     // Read requester(s) to have buffered the ReadEx snoop and to
158     // invalidate their blocks after receiving them.
159     // assert(!pkt->needsExclusive() || blk->isWritable());
160     assert(pkt->getOffset(blkSize) + pkt->getSize() <= blkSize);
161 
162     // Check RMW operations first since both isRead() and
163     // isWrite() will be true for them
164     if (pkt->cmd == MemCmd::SwapReq) {
165         cmpAndSwap(blk, pkt);
166     } else if (pkt->isWrite()) {
167         if (blk->checkWrite(pkt)) {
168             pkt->writeDataToBlock(blk->data, blkSize);
169             blk->status |= BlkDirty;
170         }
171     } else if (pkt->isRead()) {
172         if (pkt->isLLSC()) {
173             blk->trackLoadLocked(pkt);
174         }
175         pkt->setDataFromBlock(blk->data, blkSize);
176         if (pkt->getSize() == blkSize) {
177             // special handling for coherent block requests from
178             // upper-level caches
179             if (pkt->needsExclusive()) {
180                 // if we have a dirty copy, make sure the recipient
181                 // keeps it marked dirty
182                 if (blk->isDirty()) {
183                     pkt->assertMemInhibit();
184                 }
185                 // on ReadExReq we give up our copy unconditionally
186                 if (blk != tempBlock)
187                     tags->invalidate(blk);
188                 blk->invalidate();
189             } else if (blk->isWritable() && !pending_downgrade
190                       && !pkt->sharedAsserted() && !pkt->req->isInstFetch()) {
191                 // we can give the requester an exclusive copy (by not
192                 // asserting shared line) on a read request if:
193                 // - we have an exclusive copy at this level (& below)
194                 // - we don't have a pending snoop from below
195                 //   signaling another read request
196                 // - no other cache above has a copy (otherwise it
197                 //   would have asseretd shared line on request)
198                 // - we are not satisfying an instruction fetch (this
199                 //   prevents dirty data in the i-cache)
200 
201                 if (blk->isDirty()) {
202                     // special considerations if we're owner:
203                     if (!deferred_response && !isTopLevel) {
204                         // if we are responding immediately and can
205                         // signal that we're transferring ownership
206                         // along with exclusivity, do so
207                         pkt->assertMemInhibit();
208                         blk->status &= ~BlkDirty;
209                     } else {
210                         // if we're responding after our own miss,
211                         // there's a window where the recipient didn't
212                         // know it was getting ownership and may not
213                         // have responded to snoops correctly, so we
214                         // can't pass off ownership *or* exclusivity
215                         pkt->assertShared();
216                     }
217                 }
218             } else {
219                 // otherwise only respond with a shared copy
220                 pkt->assertShared();
221             }
222         }
223     } else {
224         // Not a read or write... must be an upgrade.  it's OK
225         // to just ack those as long as we have an exclusive
226         // copy at this level.
227         assert(pkt->isUpgrade());
228         assert(blk != tempBlock);
229         tags->invalidate(blk);
230         blk->invalidate();
231     }
232 }
\end{DoxyCode}
\hypertarget{classCache_a65c1c67b81573ca17c8ad40e0e6d85d8}{
\index{Cache@{Cache}!satisfyMSHR@{satisfyMSHR}}
\index{satisfyMSHR@{satisfyMSHR}!Cache@{Cache}}
\subsubsection[{satisfyMSHR}]{\setlength{\rightskip}{0pt plus 5cm}bool satisfyMSHR ({\bf MSHR} $\ast$ {\em mshr}, \/  {\bf PacketPtr} {\em pkt}, \/  {\bf BlkType} $\ast$ {\em blk})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCache_a65c1c67b81573ca17c8ad40e0e6d85d8}
\hypertarget{classCache_a53e036786d17361be4c7320d39c99b84}{
\index{Cache@{Cache}!serialize@{serialize}}
\index{serialize@{serialize}!Cache@{Cache}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classCache_a53e036786d17361be4c7320d39c99b84}
serialize the state of the caches We currently don't support checkpointing cache state, so this panics. 

\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。


\begin{DoxyCode}
1821 {
1822     bool dirty(isDirty());
1823 
1824     if (dirty) {
1825         warn("*** The cache still contains dirty data. ***\n");
1826         warn("    Make sure to drain the system using the correct flags.\n");
1827         warn("    This checkpoint will not restore correctly and dirty data in "
1828              "the cache will be lost!\n");
1829     }
1830 
1831     // Since we don't checkpoint the data in the cache, any dirty data
1832     // will be lost when restoring from a checkpoint of a system that
1833     // wasn't drained properly. Flag the checkpoint as invalid if the
1834     // cache contains dirty data.
1835     bool bad_checkpoint(dirty);
1836     SERIALIZE_SCALAR(bad_checkpoint);
1837 }
\end{DoxyCode}
\hypertarget{classCache_a94c2c174856cbab1e3478cb02ae8ed80}{
\index{Cache@{Cache}!squash@{squash}}
\index{squash@{squash}!Cache@{Cache}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash (int {\em threadNum})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a94c2c174856cbab1e3478cb02ae8ed80}
Squash all requests associated with specified thread. intended for use by I-\/cache. 
\begin{DoxyParams}{引数}
\item[{\em threadNum}]The thread to squash. \end{DoxyParams}



\begin{DoxyCode}
264 {
265     bool unblock = false;
266     BlockedCause cause = NUM_BLOCKED_CAUSES;
267 
268     if (noTargetMSHR && noTargetMSHR->threadNum == threadNum) {
269         noTargetMSHR = NULL;
270         unblock = true;
271         cause = Blocked_NoTargets;
272     }
273     if (mshrQueue.isFull()) {
274         unblock = true;
275         cause = Blocked_NoMSHRs;
276     }
277     mshrQueue.squash(threadNum);
278     if (unblock && !mshrQueue.isFull()) {
279         clearBlocked(cause);
280     }
281 }
\end{DoxyCode}
\hypertarget{classCache_af5dfa0f9fd3542f24b728e25a1d658b2}{
\index{Cache@{Cache}!uncacheableFlush@{uncacheableFlush}}
\index{uncacheableFlush@{uncacheableFlush}!Cache@{Cache}}
\subsubsection[{uncacheableFlush}]{\setlength{\rightskip}{0pt plus 5cm}void uncacheableFlush ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_af5dfa0f9fd3542f24b728e25a1d658b2}
Flush a cache line due to an uncacheable memory access to the line.

\begin{DoxyNote}{覚え書き}
This shouldn't normally happen, but we need to handle it since some architecture models don't implement cache maintenance operations. We won't even try to get a decent timing here since the line should have been flushed earlier by a cache maintenance operation. 
\end{DoxyNote}



\begin{DoxyCode}
1185 {
1186     DPRINTF(Cache, "%s%s %x uncacheable\n", pkt->cmdString(),
1187             pkt->req->isInstFetch() ? " (ifetch)" : "",
1188             pkt->getAddr());
1189 
1190     if (pkt->req->isClearLL())
1191         tags->clearLocks();
1192 
1193     BlkType *blk(tags->findBlock(pkt->getAddr(), pkt->isSecure()));
1194     if (blk) {
1195         writebackVisitor(*blk);
1196         invalidateVisitor(*blk);
1197     }
1198 }
\end{DoxyCode}
\hypertarget{classCache_af22e5d6d660b97db37003ac61ac4ee49}{
\index{Cache@{Cache}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!Cache@{Cache}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classCache_af22e5d6d660b97db37003ac61ac4ee49}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。


\begin{DoxyCode}
1842 {
1843     bool bad_checkpoint;
1844     UNSERIALIZE_SCALAR(bad_checkpoint);
1845     if (bad_checkpoint) {
1846         fatal("Restoring from checkpoints with dirty caches is not supported "
1847               "in the classic memory system. Please remove any caches or "
1848               " drain them properly before taking checkpoints.\n");
1849     }
1850 }
\end{DoxyCode}
\hypertarget{classCache_a4451141787cceb771eec3ea4d4a4a8d4}{
\index{Cache@{Cache}!writebackBlk@{writebackBlk}}
\index{writebackBlk@{writebackBlk}!Cache@{Cache}}
\subsubsection[{writebackBlk}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketPtr} writebackBlk ({\bf BlkType} $\ast$ {\em blk})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a4451141787cceb771eec3ea4d4a4a8d4}
Create a writeback request for the given block. 
\begin{DoxyParams}{引数}
\item[{\em blk}]The block to writeback. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
The writeback request for the block. 
\end{DoxyReturn}



\begin{DoxyCode}
1091 {
1092     assert(blk && blk->isValid() && blk->isDirty());
1093 
1094     writebacks[Request::wbMasterId]++;
1095 
1096     Request *writebackReq =
1097         new Request(tags->regenerateBlkAddr(blk->tag, blk->set), blkSize, 0,
1098                 Request::wbMasterId);
1099     if (blk->isSecure())
1100         writebackReq->setFlags(Request::SECURE);
1101 
1102     writebackReq->taskId(blk->task_id);
1103     blk->task_id= ContextSwitchTaskId::Unknown;
1104     blk->tickInserted = curTick();
1105 
1106     PacketPtr writeback = new Packet(writebackReq, MemCmd::Writeback);
1107     if (blk->isWritable()) {
1108         writeback->setSupplyExclusive();
1109     }
1110     writeback->allocate();
1111     std::memcpy(writeback->getPtr<uint8_t>(), blk->data, blkSize);
1112 
1113     blk->status &= ~BlkDirty;
1114     return writeback;
1115 }
\end{DoxyCode}
\hypertarget{classCache_a0f9ea802ec68e58830a83fdf795a9b9f}{
\index{Cache@{Cache}!writebackVisitor@{writebackVisitor}}
\index{writebackVisitor@{writebackVisitor}!Cache@{Cache}}
\subsubsection[{writebackVisitor}]{\setlength{\rightskip}{0pt plus 5cm}bool writebackVisitor ({\bf BlkType} \& {\em blk})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classCache_a0f9ea802ec68e58830a83fdf795a9b9f}
\hyperlink{classCache}{Cache} block visitor that writes back dirty cache blocks using functional writes.

\begin{DoxyReturn}{戻り値}
Always returns true. 
\end{DoxyReturn}



\begin{DoxyCode}
1146 {
1147     if (blk.isDirty()) {
1148         assert(blk.isValid());
1149 
1150         Request request(tags->regenerateBlkAddr(blk.tag, blk.set),
1151                         blkSize, 0, Request::funcMasterId);
1152         request.taskId(blk.task_id);
1153 
1154         Packet packet(&request, MemCmd::WriteReq);
1155         packet.dataStatic(blk.data);
1156 
1157         memSidePort->sendFunctional(&packet);
1158 
1159         blk.status &= ~BlkDirty;
1160     }
1161 
1162     return true;
1163 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classCache_a9b589ab6323a2796b7ae762dc7236bb5}{
\index{Cache@{Cache}!doFastWrites@{doFastWrites}}
\index{doFastWrites@{doFastWrites}!Cache@{Cache}}
\subsubsection[{doFastWrites}]{\setlength{\rightskip}{0pt plus 5cm}const bool {\bf doFastWrites}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCache_a9b589ab6323a2796b7ae762dc7236bb5}
This cache should allocate a block on a line-\/sized write miss. \hypertarget{classCache_a21da4bea3554874b557428e4cce5d4a4}{
\index{Cache@{Cache}!pendingDelete@{pendingDelete}}
\index{pendingDelete@{pendingDelete}!Cache@{Cache}}
\subsubsection[{pendingDelete}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf PacketPtr}$>$ {\bf pendingDelete}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCache_a21da4bea3554874b557428e4cce5d4a4}
\begin{Desc}
\item[\hyperlink{todo__todo000074}{TODO}]this is a temporary workaround until the 4-\/phase code is committed. upstream caches need this packet until true is returned, so hold it for deletion until a subsequent call \end{Desc}
\hypertarget{classCache_a320f5a2352104b9b633113f9045461a3}{
\index{Cache@{Cache}!prefetcher@{prefetcher}}
\index{prefetcher@{prefetcher}!Cache@{Cache}}
\subsubsection[{prefetcher}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BasePrefetcher}$\ast$ {\bf prefetcher}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCache_a320f5a2352104b9b633113f9045461a3}
\hyperlink{classPrefetcher}{Prefetcher} \hypertarget{classCache_a146f074bf7af4a70fc378862eab0b15a}{
\index{Cache@{Cache}!prefetchOnAccess@{prefetchOnAccess}}
\index{prefetchOnAccess@{prefetchOnAccess}!Cache@{Cache}}
\subsubsection[{prefetchOnAccess}]{\setlength{\rightskip}{0pt plus 5cm}const bool {\bf prefetchOnAccess}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCache_a146f074bf7af4a70fc378862eab0b15a}
Notify the prefetcher on every access, not just misses. \hypertarget{classCache_adb086ae267638f3864a6b3199f1d01e9}{
\index{Cache@{Cache}!tags@{tags}}
\index{tags@{tags}!Cache@{Cache}}
\subsubsection[{tags}]{\setlength{\rightskip}{0pt plus 5cm}TagStore$\ast$ {\bf tags}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCache_adb086ae267638f3864a6b3199f1d01e9}
Tag and data Storage \hypertarget{classCache_a0ca2086b66114357dd17032178adce17}{
\index{Cache@{Cache}!tempBlock@{tempBlock}}
\index{tempBlock@{tempBlock}!Cache@{Cache}}
\subsubsection[{tempBlock}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BlkType}$\ast$ {\bf tempBlock}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCache_a0ca2086b66114357dd17032178adce17}
Temporary cache block for occasional transitory use 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/cache/\hyperlink{cache_8hh}{cache.hh}\item 
mem/cache/\hyperlink{cache__impl_8hh}{cache\_\-impl.hh}\end{DoxyCompactItemize}
