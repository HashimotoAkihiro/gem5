\hypertarget{classInstructionQueue}{
\section{クラス テンプレート InstructionQueue$<$ Impl $>$}
\label{classInstructionQueue}\index{InstructionQueue@{InstructionQueue}}
}


{\ttfamily \#include $<$inst\_\-queue.hh$>$}\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classInstructionQueue_1_1FUCompletion}{FUCompletion}
\item 
struct \hyperlink{structInstructionQueue_1_1ListOrderEntry}{ListOrderEntry}
\item 
struct \hyperlink{structInstructionQueue_1_1pqCompare}{pqCompare}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef Impl::O3CPU \hyperlink{classInstructionQueue_a44622cf06940413482836cb62931ac3f}{O3CPU}
\item 
typedef Impl::DynInstPtr \hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}
\item 
typedef Impl::CPUPol::IEW \hyperlink{classInstructionQueue_a23f60a4095b5240dfcb18a4ec40210a9}{IEW}
\item 
typedef Impl::CPUPol::MemDepUnit \hyperlink{classInstructionQueue_a2e16eb5b46c2a1d3fed4c6bd5f99e368}{MemDepUnit}
\item 
typedef Impl::CPUPol::IssueStruct \hyperlink{classInstructionQueue_aa56c7524890b3a6337668c507be0f272}{IssueStruct}
\item 
typedef Impl::CPUPol::TimeStruct \hyperlink{classInstructionQueue_ab6d04a6276f6c61ee6a3a74902e7681b}{TimeStruct}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$::iterator \hyperlink{classInstructionQueue_a184cb829e22cc656acb41864f68f51ea}{ListIt}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classInstructionQueue_a70773a251ef988cdd7b3fa494aed7a72}{InstructionQueue} (\hyperlink{classInstructionQueue_a44622cf06940413482836cb62931ac3f}{O3CPU} $\ast$cpu\_\-ptr, \hyperlink{classInstructionQueue_a23f60a4095b5240dfcb18a4ec40210a9}{IEW} $\ast$iew\_\-ptr, DerivO3CPUParams $\ast$params)
\item 
\hyperlink{classInstructionQueue_a80656aa048fa902ea6e652373a9d4c58}{$\sim$InstructionQueue} ()
\item 
std::string \hyperlink{classInstructionQueue_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classInstructionQueue_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classInstructionQueue_a755ee993c2d4e9d422c37990b15afa37}{resetState} ()
\item 
void \hyperlink{classInstructionQueue_aab96bdacf8bd420402cbb543f994e054}{setActiveThreads} (\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$at\_\-ptr)
\item 
void \hyperlink{classInstructionQueue_a7cbe625b8c47621898e7ca92d70c826b}{setIssueToExecuteQueue} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structIssueStruct}{IssueStruct} $>$ $\ast$i2eQueue)
\item 
void \hyperlink{classInstructionQueue_a2b521ea5f191fff72265f60d4ed5187b}{setTimeBuffer} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$ $\ast$tb\_\-ptr)
\item 
void \hyperlink{classInstructionQueue_a0240eb42fa57fe5d3788093f62b77347}{drainSanityCheck} () const 
\item 
void \hyperlink{classInstructionQueue_a8674059ce345e23aac5086b2c3e24a43}{takeOverFrom} ()
\item 
int \hyperlink{classInstructionQueue_a5d2b0e4e7d98ea4ebd9fb98ac0d91e2f}{entryAmount} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} num\_\-threads)
\item 
void \hyperlink{classInstructionQueue_aaf9a05771a835f9f8d634cef36e24d40}{resetEntries} ()
\item 
unsigned \hyperlink{classInstructionQueue_a028971a565aca048c67ea1c36a6a9d51}{numFreeEntries} ()
\item 
unsigned \hyperlink{classInstructionQueue_acc878f608deead5b5319a6a3f98b50c8}{numFreeEntries} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classInstructionQueue_a3e70330939fdfc4dbc2f60c1a660584d}{isFull} ()
\item 
bool \hyperlink{classInstructionQueue_a30fac732df9b3fda011c7329a112cb31}{isFull} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classInstructionQueue_ae59aad9cee1e45b5817a9d96553e4567}{hasReadyInsts} ()
\item 
void \hyperlink{classInstructionQueue_a786595aecf8ab7aae40868b5ac4a79a7}{insert} (\hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&new\_\-inst)
\item 
void \hyperlink{classInstructionQueue_a4f7523e76440d88096a4eac14f2e0dd3}{insertNonSpec} (\hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&new\_\-inst)
\item 
void \hyperlink{classInstructionQueue_ae556f19566bae9c4f55350eab17abacd}{insertBarrier} (\hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&barr\_\-inst)
\item 
\hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classInstructionQueue_acf940a475d9687f26e8ab8a98c244f08}{getInstToExecute} ()
\item 
\hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classInstructionQueue_ae2aedd3b5257ee38cb5a4e307d2d50a5}{getDeferredMemInstToExecute} ()
\item 
void \hyperlink{classInstructionQueue_ae43022d3677118a4ab40113712045f64}{recordProducer} (\hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classInstructionQueue_ad118e191396cf75b93afd066a6a3f486}{processFUCompletion} (\hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst, int fu\_\-idx)
\item 
void \hyperlink{classInstructionQueue_a3694e72427d3a616808797f9343d1fc4}{scheduleReadyInsts} ()
\item 
void \hyperlink{classInstructionQueue_a15ca5aaeab5bd4c2169ed41bbc7fb79c}{scheduleNonSpec} (const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&inst)
\item 
void \hyperlink{classInstructionQueue_a04f8d2acf3cd0b90a1efc69b528f91bc}{commit} (const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&inst, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid=0)
\item 
int \hyperlink{classInstructionQueue_aab5cfade3ce4bb4addbf52c7464676d9}{wakeDependents} (\hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&completed\_\-inst)
\item 
void \hyperlink{classInstructionQueue_a76bcc078140b3e79923f7b5be8b302fb}{addReadyMemInst} (\hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&ready\_\-inst)
\item 
void \hyperlink{classInstructionQueue_afdf61c4d00a7c48449b14c6f525e3869}{rescheduleMemInst} (\hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&resched\_\-inst)
\item 
void \hyperlink{classInstructionQueue_af6c215567b7a5a496ef245cd86df2e62}{replayMemInst} (\hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&replay\_\-inst)
\item 
void \hyperlink{classInstructionQueue_aad2715729f71f220e9cf9b99515384ca}{completeMemInst} (\hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&completed\_\-inst)
\item 
void \hyperlink{classInstructionQueue_ab1617ebdf253a795f97a7936a598e151}{deferMemInst} (\hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&deferred\_\-inst)
\item 
void \hyperlink{classInstructionQueue_aeea40175042f18a63a90cbbd7dd451bc}{violation} (\hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&store, \hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&faulting\_\-load)
\item 
void \hyperlink{classInstructionQueue_ad33d65c18c323d90695d7c2355b49af9}{squash} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
unsigned \hyperlink{classInstructionQueue_aaf7eb96b7ab2a8240d043b7d82494d15}{getCount} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classInstructionQueue_afc9c0c90c27fe0dc8bd4da915596bc21}{printInsts} ()
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_a80520cf10aa5e634d9e3fb6cdc0aef2f}{intInstQueueReads}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_a095bbdf62a50bf39e824e7187cde5191}{intInstQueueWrites}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_afd00a0a956c7aeab072e57a3927ee148}{intInstQueueWakeupAccesses}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_ac72607fe25b1d8aefd4ca2dda8533bb2}{fpInstQueueReads}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_a462728858d9c7392da1a4e3695a10c3c}{fpInstQueueWrites}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_a666c1c2a3552ee13d2f8185434c9552b}{fpInstQueueWakeupQccesses}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_aec28ae6ca74e00e9b5eb0bd8bb9e1176}{intAluAccesses}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_a1dd5fc6a847750f4294e41e801b47bf4}{fpAluAccesses}
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classInstructionQueue_a6af49ff20e9c3b3f7ef7b8fa74c0e31b}{IQPolicy} \{ \hyperlink{classInstructionQueue_a6af49ff20e9c3b3f7ef7b8fa74c0e31ba96535b1625776102bcc13f7dfb598dcb}{Dynamic}, 
\hyperlink{classInstructionQueue_a6af49ff20e9c3b3f7ef7b8fa74c0e31badd8dfa69b567f90d3f13d819109ab74e}{Partitioned}, 
\hyperlink{classInstructionQueue_a6af49ff20e9c3b3f7ef7b8fa74c0e31ba267544c4de8ecc66bd0fed6310af63be}{Threshold}
 \}
\item 
typedef std::priority\_\-queue$<$ \hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}, \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$, \hyperlink{structInstructionQueue_1_1pqCompare}{pqCompare} $>$ \hyperlink{classInstructionQueue_a60636ae8f3b649078c4f1bdd3b20dcad}{ReadyInstQueue}
\item 
typedef std::map$<$ \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum}, \hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$::iterator \hyperlink{classInstructionQueue_a0e9597437fae9e60d5449933949416ec}{NonSpecMapIt}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{structInstructionQueue_1_1ListOrderEntry}{ListOrderEntry} $>$::iterator \hyperlink{classInstructionQueue_a120a1fba4fe015f7201e896580df164c}{ListOrderIt}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classInstructionQueue_a06cf52c4f09162bea03ec848f247151a}{doSquash} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classInstructionQueue_aa1de4a5c314cc1d0efaf045e05e47165}{addToOrderList} (OpClass op\_\-class)
\item 
void \hyperlink{classInstructionQueue_ae4cc92176e08b27989bb2838e4e32b1c}{moveToYoungerInst} (\hyperlink{classInstructionQueue_a120a1fba4fe015f7201e896580df164c}{ListOrderIt} age\_\-order\_\-it)
\item 
bool \hyperlink{classInstructionQueue_abeb630fedb38de020599d2a1abd4b02d}{addToDependents} (\hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&new\_\-inst)
\item 
void \hyperlink{classInstructionQueue_af89be5ea301621fdfb44941b4db60339}{addToProducers} (\hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&new\_\-inst)
\item 
void \hyperlink{classInstructionQueue_a7e3f1fa43ca939ed6fd9b3abcc47f06e}{addIfReady} (\hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
int \hyperlink{classInstructionQueue_ab654970f03abd90f0c397bba8e218bc9}{countInsts} ()
\item 
void \hyperlink{classInstructionQueue_a3d1dae45e8e0b5cf7c1f4f8c796d070e}{dumpLists} ()
\item 
void \hyperlink{classInstructionQueue_a80587b4fe043bbe1995536cb3b361588}{dumpInsts} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classInstructionQueue_a44622cf06940413482836cb62931ac3f}{O3CPU} $\ast$ \hyperlink{classInstructionQueue_a1379cf882a12ac6fc9eba5da7c84b18b}{cpu}
\item 
MemInterface $\ast$ \hyperlink{classInstructionQueue_a22dc8294eecb144fbdd951d2e32e9330}{dcacheInterface}
\item 
\hyperlink{classInstructionQueue_a23f60a4095b5240dfcb18a4ec40210a9}{IEW} $\ast$ \hyperlink{classInstructionQueue_a4e9ef25d8913b270d432be4bbfe4965c}{iewStage}
\item 
\hyperlink{classMemDepUnit}{MemDepUnit} \hyperlink{classInstructionQueue_a8cb80ccbf6ed6c1029c6d9ebeaa40f6e}{memDepUnit} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structIssueStruct}{IssueStruct} $>$ $\ast$ \hyperlink{classInstructionQueue_af5c55240e63d9a13358eede4eb5352f1}{issueToExecuteQueue}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$ $\ast$ \hyperlink{classInstructionQueue_a83f9ee976e732665aeb08dbc19acfd45}{timeBuffer}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classInstructionQueue_a0055a92bd94eda21c2641d46ff013dac}{fromCommit}
\item 
\hyperlink{classFUPool}{FUPool} $\ast$ \hyperlink{classInstructionQueue_a480782fc1cfd21fd9748b26f2a08b97a}{fuPool}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classInstructionQueue_a7f2828a4f877a4a4d4b85a6788536b82}{instList} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classInstructionQueue_a494cb455333d9f34ee4a3ab8ca5e50fd}{instsToExecute}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classInstructionQueue_a6ea0c1a972364b789a8b6831cf7828cf}{deferredMemInsts}
\item 
\hyperlink{classInstructionQueue_a60636ae8f3b649078c4f1bdd3b20dcad}{ReadyInstQueue} \hyperlink{classInstructionQueue_a84f7fc18dadb9ea3ef6ed7dd9f375c46}{readyInsts} \mbox{[}\hyperlink{op__class_8hh_a5e0e351c8afca390ef0a05a7dbb68b1b}{Num\_\-OpClasses}\mbox{]}
\item 
std::map$<$ \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum}, \hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classInstructionQueue_ac0ba4d07026aaf6386c001a68d059cbf}{nonSpecInsts}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{structInstructionQueue_1_1ListOrderEntry}{ListOrderEntry} $>$ \hyperlink{classInstructionQueue_afd5860c9cc9c225411df38dd3dc89b87}{listOrder}
\item 
bool \hyperlink{classInstructionQueue_abd5388bcfcc78ba7299f0178672b4ac2}{queueOnList} \mbox{[}\hyperlink{op__class_8hh_a5e0e351c8afca390ef0a05a7dbb68b1b}{Num\_\-OpClasses}\mbox{]}
\item 
\hyperlink{classInstructionQueue_a120a1fba4fe015f7201e896580df164c}{ListOrderIt} \hyperlink{classInstructionQueue_ac6c2d86489eaee465f91586553c3593f}{readyIt} \mbox{[}\hyperlink{op__class_8hh_a5e0e351c8afca390ef0a05a7dbb68b1b}{Num\_\-OpClasses}\mbox{]}
\item 
\hyperlink{classDependencyGraph}{DependencyGraph}$<$ \hyperlink{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classInstructionQueue_a23fbbb46c9bdd183c06095cc0398fdc4}{dependGraph}
\item 
\hyperlink{classInstructionQueue_a6af49ff20e9c3b3f7ef7b8fa74c0e31b}{IQPolicy} \hyperlink{classInstructionQueue_a558c2854c6103193667179fa6ac0ac20}{iqPolicy}
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classInstructionQueue_a88377f855dbf5adeeecb06b5bb821d35}{numThreads}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$ \hyperlink{classInstructionQueue_af6eaea53db532812052f71bf0380dab5}{activeThreads}
\item 
unsigned \hyperlink{classInstructionQueue_ac638062ba1de6609f143c5ee3a601109}{count} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
unsigned \hyperlink{classInstructionQueue_a51e5f9f0cb40d61e95b1518f1be90b73}{maxEntries} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
unsigned \hyperlink{classInstructionQueue_ac2281ff630f82397bda33269f4ee8796}{freeEntries}
\item 
unsigned \hyperlink{classInstructionQueue_a325de474a9f6652329339d9fc2ea09c0}{numEntries}
\item 
unsigned \hyperlink{classInstructionQueue_ab3c3a8cd00248d9cd6acad330da902a7}{totalWidth}
\item 
unsigned \hyperlink{classInstructionQueue_a0d2a78a8e887f06150904000b2beb6cd}{numPhysRegs}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classInstructionQueue_a6b6fe1148ed7c40758e45f351c375552}{commitToIEWDelay}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classInstructionQueue_a97d5a7e4630ad1d017909f7504b9ec32}{squashedSeqNum} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ bool $>$ \hyperlink{classInstructionQueue_a61aeb86b87d1e105337b5a8973ce61f3}{regScoreboard}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_a435e1ce10c3a7f54a60941e583adeb09}{iqInstsAdded}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_adf890a08fae50ea8249171b07c40adac}{iqNonSpecInstsAdded}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_accc6261a817718dbb727c65f310df357}{iqInstsIssued}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_a735f2023e70e53b7889a3a316bd3d57f}{iqIntInstsIssued}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_aa9f2fa124c9f0b4b22461b6717449d9a}{iqFloatInstsIssued}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_a928f22a2c6ce592adc40e5242c9d6572}{iqBranchInstsIssued}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_a5e7d55d3f07e86e389ca3a715766e108}{iqMemInstsIssued}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_ad234890bc414fffe7ed71840c51be5cb}{iqMiscInstsIssued}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_ac91799c895e5aff3af0afdbd7691a163}{iqSquashedInstsIssued}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_a8312e8984bcfab5a77de40e1738103db}{iqSquashedInstsExamined}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_a4398b6005b81008bd163bbba78dfd929}{iqSquashedOperandsExamined}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstructionQueue_a6c0b47431b6e84536fd9bb61624d6d97}{iqSquashedNonSpecRemoved}
\item 
\hyperlink{classStats_1_1Distribution}{Stats::Distribution} \hyperlink{classInstructionQueue_a90810f5beb7dff46f4b45f96620474b6}{numIssuedDist}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classInstructionQueue_a92266bfdbc9a6de5005fc3f1654e0b3e}{statFuBusy}
\item 
\hyperlink{classStats_1_1Vector2d}{Stats::Vector2d} \hyperlink{classInstructionQueue_abb8998de49604769ec252fbd0ac1ed2b}{statIssuedInstType}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classInstructionQueue_a6a9ed0564894e83d4c3c5784f667c5e0}{issueRate}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classInstructionQueue_a54dbf1e1683507aefb83115910feb26b}{fuBusy}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classInstructionQueue_ab1ecb3744ca63dcec2b9b7d80c319c69}{fuBusyRate}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$class Impl$>$ class InstructionQueue$<$ Impl $>$}

A standard instruction queue class. It holds ready instructions, in order, in seperate priority queues to facilitate the scheduling of instructions. The IQ uses a separate linked list to track dependencies. Similar to the rename map and the free list, it expects that floating point registers have their indices start after the integer registers (ie with 96 int and 96 fp registers, regs 0-\/95 are integer and 96-\/191 are fp). This remains true even for both logical and physical register indices. The IQ depends on the memory dependence unit to track when memory operations are ready in terms of ordering; register dependencies are tracked normally. Right now the IQ also handles the execution timing; this is mainly to allow back-\/to-\/back scheduling without requiring IEW to be able to peek into the IQ. At the end of the execution latency, the instruction is put into the queue to execute, where it will have the execute() function called on it. \begin{Desc}
\item[\hyperlink{todo__todo000030}{TODO}]: Make IQ able to handle multiple FU pools. \end{Desc}


\subsection{型定義}
\hypertarget{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}{
\index{InstructionQueue@{InstructionQueue}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!InstructionQueue@{InstructionQueue}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInstPtr {\bf DynInstPtr}}}
\label{classInstructionQueue_a028ce10889c5f6450239d9e9a7347976}
\hypertarget{classInstructionQueue_a23f60a4095b5240dfcb18a4ec40210a9}{
\index{InstructionQueue@{InstructionQueue}!IEW@{IEW}}
\index{IEW@{IEW}!InstructionQueue@{InstructionQueue}}
\subsubsection[{IEW}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::CPUPol::IEW {\bf IEW}}}
\label{classInstructionQueue_a23f60a4095b5240dfcb18a4ec40210a9}
\hypertarget{classInstructionQueue_aa56c7524890b3a6337668c507be0f272}{
\index{InstructionQueue@{InstructionQueue}!IssueStruct@{IssueStruct}}
\index{IssueStruct@{IssueStruct}!InstructionQueue@{InstructionQueue}}
\subsubsection[{IssueStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::CPUPol::IssueStruct {\bf IssueStruct}}}
\label{classInstructionQueue_aa56c7524890b3a6337668c507be0f272}
\hypertarget{classInstructionQueue_a184cb829e22cc656acb41864f68f51ea}{
\index{InstructionQueue@{InstructionQueue}!ListIt@{ListIt}}
\index{ListIt@{ListIt}!InstructionQueue@{InstructionQueue}}
\subsubsection[{ListIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf DynInstPtr}$>$::iterator {\bf ListIt}}}
\label{classInstructionQueue_a184cb829e22cc656acb41864f68f51ea}
\hypertarget{classInstructionQueue_a120a1fba4fe015f7201e896580df164c}{
\index{InstructionQueue@{InstructionQueue}!ListOrderIt@{ListOrderIt}}
\index{ListOrderIt@{ListOrderIt}!InstructionQueue@{InstructionQueue}}
\subsubsection[{ListOrderIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf ListOrderEntry}$>$::iterator {\bf ListOrderIt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a120a1fba4fe015f7201e896580df164c}
\hypertarget{classInstructionQueue_a2e16eb5b46c2a1d3fed4c6bd5f99e368}{
\index{InstructionQueue@{InstructionQueue}!MemDepUnit@{MemDepUnit}}
\index{MemDepUnit@{MemDepUnit}!InstructionQueue@{InstructionQueue}}
\subsubsection[{MemDepUnit}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::CPUPol::MemDepUnit {\bf MemDepUnit}}}
\label{classInstructionQueue_a2e16eb5b46c2a1d3fed4c6bd5f99e368}
\hypertarget{classInstructionQueue_a0e9597437fae9e60d5449933949416ec}{
\index{InstructionQueue@{InstructionQueue}!NonSpecMapIt@{NonSpecMapIt}}
\index{NonSpecMapIt@{NonSpecMapIt}!InstructionQueue@{InstructionQueue}}
\subsubsection[{NonSpecMapIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef std::map$<${\bf InstSeqNum}, {\bf DynInstPtr}$>$::iterator {\bf NonSpecMapIt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a0e9597437fae9e60d5449933949416ec}
\hypertarget{classInstructionQueue_a44622cf06940413482836cb62931ac3f}{
\index{InstructionQueue@{InstructionQueue}!O3CPU@{O3CPU}}
\index{O3CPU@{O3CPU}!InstructionQueue@{InstructionQueue}}
\subsubsection[{O3CPU}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::O3CPU {\bf O3CPU}}}
\label{classInstructionQueue_a44622cf06940413482836cb62931ac3f}
\hypertarget{classInstructionQueue_a60636ae8f3b649078c4f1bdd3b20dcad}{
\index{InstructionQueue@{InstructionQueue}!ReadyInstQueue@{ReadyInstQueue}}
\index{ReadyInstQueue@{ReadyInstQueue}!InstructionQueue@{InstructionQueue}}
\subsubsection[{ReadyInstQueue}]{\setlength{\rightskip}{0pt plus 5cm}typedef std::priority\_\-queue$<${\bf DynInstPtr}, {\bf std::vector}$<${\bf DynInstPtr}$>$, {\bf pqCompare}$>$ {\bf ReadyInstQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a60636ae8f3b649078c4f1bdd3b20dcad}
\hypertarget{classInstructionQueue_ab6d04a6276f6c61ee6a3a74902e7681b}{
\index{InstructionQueue@{InstructionQueue}!TimeStruct@{TimeStruct}}
\index{TimeStruct@{TimeStruct}!InstructionQueue@{InstructionQueue}}
\subsubsection[{TimeStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::CPUPol::TimeStruct {\bf TimeStruct}}}
\label{classInstructionQueue_ab6d04a6276f6c61ee6a3a74902e7681b}


\subsection{列挙型}
\hypertarget{classInstructionQueue_a6af49ff20e9c3b3f7ef7b8fa74c0e31b}{
\index{InstructionQueue@{InstructionQueue}!IQPolicy@{IQPolicy}}
\index{IQPolicy@{IQPolicy}!InstructionQueue@{InstructionQueue}}
\subsubsection[{IQPolicy}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf IQPolicy}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a6af49ff20e9c3b3f7ef7b8fa74c0e31b}
IQ \hyperlink{classResource}{Resource} Sharing Policy \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Dynamic@{Dynamic}!InstructionQueue@{InstructionQueue}}\index{InstructionQueue@{InstructionQueue}!Dynamic@{Dynamic}}\item[{\em 
\hypertarget{classInstructionQueue_a6af49ff20e9c3b3f7ef7b8fa74c0e31ba96535b1625776102bcc13f7dfb598dcb}{
Dynamic}
\label{classInstructionQueue_a6af49ff20e9c3b3f7ef7b8fa74c0e31ba96535b1625776102bcc13f7dfb598dcb}
}]\index{Partitioned@{Partitioned}!InstructionQueue@{InstructionQueue}}\index{InstructionQueue@{InstructionQueue}!Partitioned@{Partitioned}}\item[{\em 
\hypertarget{classInstructionQueue_a6af49ff20e9c3b3f7ef7b8fa74c0e31badd8dfa69b567f90d3f13d819109ab74e}{
Partitioned}
\label{classInstructionQueue_a6af49ff20e9c3b3f7ef7b8fa74c0e31badd8dfa69b567f90d3f13d819109ab74e}
}]\index{Threshold@{Threshold}!InstructionQueue@{InstructionQueue}}\index{InstructionQueue@{InstructionQueue}!Threshold@{Threshold}}\item[{\em 
\hypertarget{classInstructionQueue_a6af49ff20e9c3b3f7ef7b8fa74c0e31ba267544c4de8ecc66bd0fed6310af63be}{
Threshold}
\label{classInstructionQueue_a6af49ff20e9c3b3f7ef7b8fa74c0e31ba267544c4de8ecc66bd0fed6310af63be}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
385                   {
386         Dynamic,
387         Partitioned,
388         Threshold
389     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classInstructionQueue_a70773a251ef988cdd7b3fa494aed7a72}{
\index{InstructionQueue@{InstructionQueue}!InstructionQueue@{InstructionQueue}}
\index{InstructionQueue@{InstructionQueue}!InstructionQueue@{InstructionQueue}}
\subsubsection[{InstructionQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstructionQueue} ({\bf O3CPU} $\ast$ {\em cpu\_\-ptr}, \/  {\bf IEW} $\ast$ {\em iew\_\-ptr}, \/  DerivO3CPUParams $\ast$ {\em params})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a70773a251ef988cdd7b3fa494aed7a72}
Constructs an IQ. 


\begin{DoxyCode}
89     : cpu(cpu_ptr),
90       iewStage(iew_ptr),
91       fuPool(params->fuPool),
92       numEntries(params->numIQEntries),
93       totalWidth(params->issueWidth),
94       commitToIEWDelay(params->commitToIEWDelay)
95 {
96     assert(fuPool);
97 
98     numThreads = params->numThreads;
99 
100     // Set the number of total physical registers
101     numPhysRegs = params->numPhysIntRegs + params->numPhysFloatRegs +
102         params->numPhysCCRegs;
103 
104     //Create an entry for each physical register within the
105     //dependency graph.
106     dependGraph.resize(numPhysRegs);
107 
108     // Resize the register scoreboard.
109     regScoreboard.resize(numPhysRegs);
110 
111     //Initialize Mem Dependence Units
112     for (ThreadID tid = 0; tid < numThreads; tid++) {
113         memDepUnit[tid].init(params, tid);
114         memDepUnit[tid].setIQ(this);
115     }
116 
117     resetState();
118 
119     std::string policy = params->smtIQPolicy;
120 
121     //Convert string to lowercase
122     std::transform(policy.begin(), policy.end(), policy.begin(),
123                    (int(*)(int)) tolower);
124 
125     //Figure out resource sharing policy
126     if (policy == "dynamic") {
127         iqPolicy = Dynamic;
128 
129         //Set Max Entries to Total ROB Capacity
130         for (ThreadID tid = 0; tid < numThreads; tid++) {
131             maxEntries[tid] = numEntries;
132         }
133 
134     } else if (policy == "partitioned") {
135         iqPolicy = Partitioned;
136 
137         //@todo:make work if part_amt doesnt divide evenly.
138         int part_amt = numEntries / numThreads;
139 
140         //Divide ROB up evenly
141         for (ThreadID tid = 0; tid < numThreads; tid++) {
142             maxEntries[tid] = part_amt;
143         }
144 
145         DPRINTF(IQ, "IQ sharing policy set to Partitioned:"
146                 "%i entries per thread.\n",part_amt);
147     } else if (policy == "threshold") {
148         iqPolicy = Threshold;
149 
150         double threshold =  (double)params->smtIQThreshold / 100;
151 
152         int thresholdIQ = (int)((double)threshold * numEntries);
153 
154         //Divide up by threshold amount
155         for (ThreadID tid = 0; tid < numThreads; tid++) {
156             maxEntries[tid] = thresholdIQ;
157         }
158 
159         DPRINTF(IQ, "IQ sharing policy set to Threshold:"
160                 "%i entries per thread.\n",thresholdIQ);
161    } else {
162        assert(0 && "Invalid IQ Sharing Policy.Options Are:{Dynamic,"
163               "Partitioned, Threshold}");
164    }
165 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a80656aa048fa902ea6e652373a9d4c58}{
\index{InstructionQueue@{InstructionQueue}!$\sim$InstructionQueue@{$\sim$InstructionQueue}}
\index{$\sim$InstructionQueue@{$\sim$InstructionQueue}!InstructionQueue@{InstructionQueue}}
\subsubsection[{$\sim$InstructionQueue}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf InstructionQueue} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a80656aa048fa902ea6e652373a9d4c58}
Destructs the IQ. 


\begin{DoxyCode}
169 {
170     dependGraph.reset();
171 #ifdef DEBUG
172     cprintf("Nodes traversed: %i, removed: %i\n",
173             dependGraph.nodesTraversed, dependGraph.nodesRemoved);
174 #endif
175 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classInstructionQueue_a7e3f1fa43ca939ed6fd9b3abcc47f06e}{
\index{InstructionQueue@{InstructionQueue}!addIfReady@{addIfReady}}
\index{addIfReady@{addIfReady}!InstructionQueue@{InstructionQueue}}
\subsubsection[{addIfReady}]{\setlength{\rightskip}{0pt plus 5cm}void addIfReady ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classInstructionQueue_a7e3f1fa43ca939ed6fd9b3abcc47f06e}
Moves an instruction to the ready queue if it is ready. 


\begin{DoxyCode}
1327 {
1328     // If the instruction now has all of its source registers
1329     // available, then add it to the list of ready instructions.
1330     if (inst->readyToIssue()) {
1331 
1332         //Add the instruction to the proper ready list.
1333         if (inst->isMemRef()) {
1334 
1335             DPRINTF(IQ, "Checking if memory instruction can issue.\n");
1336 
1337             // Message to the mem dependence unit that this instruction has
1338             // its registers ready.
1339             memDepUnit[inst->threadNumber].regsReady(inst);
1340 
1341             return;
1342         }
1343 
1344         OpClass op_class = inst->opClass();
1345 
1346         DPRINTF(IQ, "Instruction is ready to issue, putting it onto "
1347                 "the ready list, PC %s opclass:%i [sn:%lli].\n",
1348                 inst->pcState(), op_class, inst->seqNum);
1349 
1350         readyInsts[op_class].push(inst);
1351 
1352         // Will need to reorder the list if either a queue is not on the list,
1353         // or it has an older instruction than last time.
1354         if (!queueOnList[op_class]) {
1355             addToOrderList(op_class);
1356         } else if (readyInsts[op_class].top()->seqNum  <
1357                    (*readyIt[op_class]).oldestInst) {
1358             listOrder.erase(readyIt[op_class]);
1359             addToOrderList(op_class);
1360         }
1361     }
1362 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a76bcc078140b3e79923f7b5be8b302fb}{
\index{InstructionQueue@{InstructionQueue}!addReadyMemInst@{addReadyMemInst}}
\index{addReadyMemInst@{addReadyMemInst}!InstructionQueue@{InstructionQueue}}
\subsubsection[{addReadyMemInst}]{\setlength{\rightskip}{0pt plus 5cm}void addReadyMemInst ({\bf DynInstPtr} \& {\em ready\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a76bcc078140b3e79923f7b5be8b302fb}
Adds a ready memory instruction to the ready list. 


\begin{DoxyCode}
1017 {
1018     OpClass op_class = ready_inst->opClass();
1019 
1020     readyInsts[op_class].push(ready_inst);
1021 
1022     // Will need to reorder the list if either a queue is not on the list,
1023     // or it has an older instruction than last time.
1024     if (!queueOnList[op_class]) {
1025         addToOrderList(op_class);
1026     } else if (readyInsts[op_class].top()->seqNum  <
1027                (*readyIt[op_class]).oldestInst) {
1028         listOrder.erase(readyIt[op_class]);
1029         addToOrderList(op_class);
1030     }
1031 
1032     DPRINTF(IQ, "Instruction is ready to issue, putting it onto "
1033             "the ready list, PC %s opclass:%i [sn:%lli].\n",
1034             ready_inst->pcState(), op_class, ready_inst->seqNum);
1035 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_abeb630fedb38de020599d2a1abd4b02d}{
\index{InstructionQueue@{InstructionQueue}!addToDependents@{addToDependents}}
\index{addToDependents@{addToDependents}!InstructionQueue@{InstructionQueue}}
\subsubsection[{addToDependents}]{\setlength{\rightskip}{0pt plus 5cm}bool addToDependents ({\bf DynInstPtr} \& {\em new\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classInstructionQueue_abeb630fedb38de020599d2a1abd4b02d}
Adds an instruction to the dependency graph, as a consumer. 


\begin{DoxyCode}
1245 {
1246     // Loop through the instruction's source registers, adding
1247     // them to the dependency list if they are not ready.
1248     int8_t total_src_regs = new_inst->numSrcRegs();
1249     bool return_val = false;
1250 
1251     for (int src_reg_idx = 0;
1252          src_reg_idx < total_src_regs;
1253          src_reg_idx++)
1254     {
1255         // Only add it to the dependency graph if it's not ready.
1256         if (!new_inst->isReadySrcRegIdx(src_reg_idx)) {
1257             PhysRegIndex src_reg = new_inst->renamedSrcRegIdx(src_reg_idx);
1258 
1259             // Check the IQ's scoreboard to make sure the register
1260             // hasn't become ready while the instruction was in flight
1261             // between stages.  Only if it really isn't ready should
1262             // it be added to the dependency graph.
1263             if (src_reg >= numPhysRegs) {
1264                 continue;
1265             } else if (!regScoreboard[src_reg]) {
1266                 DPRINTF(IQ, "Instruction PC %s has src reg %i that "
1267                         "is being added to the dependency chain.\n",
1268                         new_inst->pcState(), src_reg);
1269 
1270                 dependGraph.insert(src_reg, new_inst);
1271 
1272                 // Change the return value to indicate that something
1273                 // was added to the dependency graph.
1274                 return_val = true;
1275             } else {
1276                 DPRINTF(IQ, "Instruction PC %s has src reg %i that "
1277                         "became ready before it reached the IQ.\n",
1278                         new_inst->pcState(), src_reg);
1279                 // Mark a register ready within the instruction.
1280                 new_inst->markSrcRegReady(src_reg_idx);
1281             }
1282         }
1283     }
1284 
1285     return return_val;
1286 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_aa1de4a5c314cc1d0efaf045e05e47165}{
\index{InstructionQueue@{InstructionQueue}!addToOrderList@{addToOrderList}}
\index{addToOrderList@{addToOrderList}!InstructionQueue@{InstructionQueue}}
\subsubsection[{addToOrderList}]{\setlength{\rightskip}{0pt plus 5cm}void addToOrderList (OpClass {\em op\_\-class})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classInstructionQueue_aa1de4a5c314cc1d0efaf045e05e47165}
Add an op class to the age order list. 


\begin{DoxyCode}
655 {
656     assert(!readyInsts[op_class].empty());
657 
658     ListOrderEntry queue_entry;
659 
660     queue_entry.queueType = op_class;
661 
662     queue_entry.oldestInst = readyInsts[op_class].top()->seqNum;
663 
664     ListOrderIt list_it = listOrder.begin();
665     ListOrderIt list_end_it = listOrder.end();
666 
667     while (list_it != list_end_it) {
668         if ((*list_it).oldestInst > queue_entry.oldestInst) {
669             break;
670         }
671 
672         list_it++;
673     }
674 
675     readyIt[op_class] = listOrder.insert(list_it, queue_entry);
676     queueOnList[op_class] = true;
677 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_af89be5ea301621fdfb44941b4db60339}{
\index{InstructionQueue@{InstructionQueue}!addToProducers@{addToProducers}}
\index{addToProducers@{addToProducers}!InstructionQueue@{InstructionQueue}}
\subsubsection[{addToProducers}]{\setlength{\rightskip}{0pt plus 5cm}void addToProducers ({\bf DynInstPtr} \& {\em new\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classInstructionQueue_af89be5ea301621fdfb44941b4db60339}
Adds an instruction to the dependency graph, as a producer. 


\begin{DoxyCode}
1291 {
1292     // Nothing really needs to be marked when an instruction becomes
1293     // the producer of a register's value, but for convenience a ptr
1294     // to the producing instruction will be placed in the head node of
1295     // the dependency links.
1296     int8_t total_dest_regs = new_inst->numDestRegs();
1297 
1298     for (int dest_reg_idx = 0;
1299          dest_reg_idx < total_dest_regs;
1300          dest_reg_idx++)
1301     {
1302         PhysRegIndex dest_reg = new_inst->renamedDestRegIdx(dest_reg_idx);
1303 
1304         // Instructions that use the misc regs will have a reg number
1305         // higher than the normal physical registers.  In this case these
1306         // registers are not renamed, and there is no need to track
1307         // dependencies as these instructions must be executed at commit.
1308         if (dest_reg >= numPhysRegs) {
1309             continue;
1310         }
1311 
1312         if (!dependGraph.empty(dest_reg)) {
1313             dependGraph.dump();
1314             panic("Dependency graph %i not empty!", dest_reg);
1315         }
1316 
1317         dependGraph.setInst(dest_reg, new_inst);
1318 
1319         // Mark the scoreboard to say it's not yet ready.
1320         regScoreboard[dest_reg] = false;
1321     }
1322 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a04f8d2acf3cd0b90a1efc69b528f91bc}{
\index{InstructionQueue@{InstructionQueue}!commit@{commit}}
\index{commit@{commit}!InstructionQueue@{InstructionQueue}}
\subsubsection[{commit}]{\setlength{\rightskip}{0pt plus 5cm}void commit (const {\bf InstSeqNum} \& {\em inst}, \/  {\bf ThreadID} {\em tid} = {\ttfamily 0})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a04f8d2acf3cd0b90a1efc69b528f91bc}
Commits all instructions up to and including the given sequence number, for a specific thread. 


\begin{DoxyCode}
917 {
918     DPRINTF(IQ, "[tid:%i]: Committing instructions older than [sn:%i]\n",
919             tid,inst);
920 
921     ListIt iq_it = instList[tid].begin();
922 
923     while (iq_it != instList[tid].end() &&
924            (*iq_it)->seqNum <= inst) {
925         ++iq_it;
926         instList[tid].pop_front();
927     }
928 
929     assert(freeEntries == (numEntries - countInsts()));
930 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_aad2715729f71f220e9cf9b99515384ca}{
\index{InstructionQueue@{InstructionQueue}!completeMemInst@{completeMemInst}}
\index{completeMemInst@{completeMemInst}!InstructionQueue@{InstructionQueue}}
\subsubsection[{completeMemInst}]{\setlength{\rightskip}{0pt plus 5cm}void completeMemInst ({\bf DynInstPtr} \& {\em completed\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_aad2715729f71f220e9cf9b99515384ca}
Completes a memory operation. 


\begin{DoxyCode}
1061 {
1062     ThreadID tid = completed_inst->threadNumber;
1063 
1064     DPRINTF(IQ, "Completing mem instruction PC: %s [sn:%lli]\n",
1065             completed_inst->pcState(), completed_inst->seqNum);
1066 
1067     ++freeEntries;
1068 
1069     completed_inst->memOpDone(true);
1070 
1071     memDepUnit[tid].completed(completed_inst);
1072     count[tid]--;
1073 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_ab654970f03abd90f0c397bba8e218bc9}{
\index{InstructionQueue@{InstructionQueue}!countInsts@{countInsts}}
\index{countInsts@{countInsts}!InstructionQueue@{InstructionQueue}}
\subsubsection[{countInsts}]{\setlength{\rightskip}{0pt plus 5cm}int countInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classInstructionQueue_ab654970f03abd90f0c397bba8e218bc9}
Debugging function to count how many entries are in the IQ. It does a linear walk through the instructions, so do not call this function during normal execution. 


\begin{DoxyCode}
1367 {
1368 #if 0
1369     //ksewell:This works but definitely could use a cleaner write
1370     //with a more intuitive way of counting. Right now it's
1371     //just brute force ....
1372     // Change the #if if you want to use this method.
1373     int total_insts = 0;
1374 
1375     for (ThreadID tid = 0; tid < numThreads; ++tid) {
1376         ListIt count_it = instList[tid].begin();
1377 
1378         while (count_it != instList[tid].end()) {
1379             if (!(*count_it)->isSquashed() && !(*count_it)->isSquashedInIQ()) {
1380                 if (!(*count_it)->isIssued()) {
1381                     ++total_insts;
1382                 } else if ((*count_it)->isMemRef() &&
1383                            !(*count_it)->memOpDone) {
1384                     // Loads that have not been marked as executed still count
1385                     // towards the total instructions.
1386                     ++total_insts;
1387                 }
1388             }
1389 
1390             ++count_it;
1391         }
1392     }
1393 
1394     return total_insts;
1395 #else
1396     return numEntries - freeEntries;
1397 #endif
1398 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_ab1617ebdf253a795f97a7936a598e151}{
\index{InstructionQueue@{InstructionQueue}!deferMemInst@{deferMemInst}}
\index{deferMemInst@{deferMemInst}!InstructionQueue@{InstructionQueue}}
\subsubsection[{deferMemInst}]{\setlength{\rightskip}{0pt plus 5cm}void deferMemInst ({\bf DynInstPtr} \& {\em deferred\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_ab1617ebdf253a795f97a7936a598e151}
Defers a memory instruction when its DTB translation incurs a hw page table walk. 


\begin{DoxyCode}
1078 {
1079     deferredMemInsts.push_back(deferred_inst);
1080 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a06cf52c4f09162bea03ec848f247151a}{
\index{InstructionQueue@{InstructionQueue}!doSquash@{doSquash}}
\index{doSquash@{doSquash}!InstructionQueue@{InstructionQueue}}
\subsubsection[{doSquash}]{\setlength{\rightskip}{0pt plus 5cm}void doSquash ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classInstructionQueue_a06cf52c4f09162bea03ec848f247151a}
Does the actual squashing. 


\begin{DoxyCode}
1129 {
1130     // Start at the tail.
1131     ListIt squash_it = instList[tid].end();
1132     --squash_it;
1133 
1134     DPRINTF(IQ, "[tid:%i]: Squashing until sequence number %i!\n",
1135             tid, squashedSeqNum[tid]);
1136 
1137     // Squash any instructions younger than the squashed sequence number
1138     // given.
1139     while (squash_it != instList[tid].end() &&
1140            (*squash_it)->seqNum > squashedSeqNum[tid]) {
1141 
1142         DynInstPtr squashed_inst = (*squash_it);
1143         squashed_inst->isFloating() ? fpInstQueueWrites++ : intInstQueueWrites++;
      
1144 
1145         // Only handle the instruction if it actually is in the IQ and
1146         // hasn't already been squashed in the IQ.
1147         if (squashed_inst->threadNumber != tid ||
1148             squashed_inst->isSquashedInIQ()) {
1149             --squash_it;
1150             continue;
1151         }
1152 
1153         if (!squashed_inst->isIssued() ||
1154             (squashed_inst->isMemRef() &&
1155              !squashed_inst->memOpDone())) {
1156 
1157             DPRINTF(IQ, "[tid:%i]: Instruction [sn:%lli] PC %s squashed.\n",
1158                     tid, squashed_inst->seqNum, squashed_inst->pcState());
1159 
1160             bool is_acq_rel = squashed_inst->isMemBarrier() &&
1161                          (squashed_inst->isLoad() ||
1162                            (squashed_inst->isStore() &&
1163                              !squashed_inst->isStoreConditional()));
1164 
1165             // Remove the instruction from the dependency list.
1166             if (is_acq_rel ||
1167                 (!squashed_inst->isNonSpeculative() &&
1168                  !squashed_inst->isStoreConditional() &&
1169                  !squashed_inst->isMemBarrier() &&
1170                  !squashed_inst->isWriteBarrier())) {
1171 
1172                 for (int src_reg_idx = 0;
1173                      src_reg_idx < squashed_inst->numSrcRegs();
1174                      src_reg_idx++)
1175                 {
1176                     PhysRegIndex src_reg =
1177                         squashed_inst->renamedSrcRegIdx(src_reg_idx);
1178 
1179                     // Only remove it from the dependency graph if it
1180                     // was placed there in the first place.
1181 
1182                     // Instead of doing a linked list traversal, we
1183                     // can just remove these squashed instructions
1184                     // either at issue time, or when the register is
1185                     // overwritten.  The only downside to this is it
1186                     // leaves more room for error.
1187 
1188                     if (!squashed_inst->isReadySrcRegIdx(src_reg_idx) &&
1189                         src_reg < numPhysRegs) {
1190                         dependGraph.remove(src_reg, squashed_inst);
1191                     }
1192 
1193 
1194                     ++iqSquashedOperandsExamined;
1195                 }
1196             } else if (!squashed_inst->isStoreConditional() ||
1197                        !squashed_inst->isCompleted()) {
1198                 NonSpecMapIt ns_inst_it =
1199                     nonSpecInsts.find(squashed_inst->seqNum);
1200 
1201                 // we remove non-speculative instructions from
1202                 // nonSpecInsts already when they are ready, and so we
1203                 // cannot always expect to find them
1204                 if (ns_inst_it == nonSpecInsts.end()) {
1205                     // loads that became ready but stalled on a
1206                     // blocked cache are alreayd removed from
1207                     // nonSpecInsts, and have not faulted
1208                     assert(squashed_inst->getFault() != NoFault ||
1209                            squashed_inst->isMemRef());
1210                 } else {
1211 
1212                     (*ns_inst_it).second = NULL;
1213 
1214                     nonSpecInsts.erase(ns_inst_it);
1215 
1216                     ++iqSquashedNonSpecRemoved;
1217                 }
1218             }
1219 
1220             // Might want to also clear out the head of the dependency graph.
1221 
1222             // Mark it as squashed within the IQ.
1223             squashed_inst->setSquashedInIQ();
1224 
1225             // @todo: Remove this hack where several statuses are set so the
1226             // inst will flow through the rest of the pipeline.
1227             squashed_inst->setIssued();
1228             squashed_inst->setCanCommit();
1229             squashed_inst->clearInIQ();
1230 
1231             //Update Thread IQ Count
1232             count[squashed_inst->threadNumber]--;
1233 
1234             ++freeEntries;
1235         }
1236 
1237         instList[tid].erase(squash_it--);
1238         ++iqSquashedInstsExamined;
1239     }
1240 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a0240eb42fa57fe5d3788093f62b77347}{
\index{InstructionQueue@{InstructionQueue}!drainSanityCheck@{drainSanityCheck}}
\index{drainSanityCheck@{drainSanityCheck}!InstructionQueue@{InstructionQueue}}
\subsubsection[{drainSanityCheck}]{\setlength{\rightskip}{0pt plus 5cm}void drainSanityCheck () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a0240eb42fa57fe5d3788093f62b77347}
Perform sanity checks after a drain. 


\begin{DoxyCode}
444 {
445     assert(dependGraph.empty());
446     assert(instsToExecute.empty());
447     for (ThreadID tid = 0; tid < numThreads; ++tid)
448         memDepUnit[tid].drainSanityCheck();
449 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a80587b4fe043bbe1995536cb3b361588}{
\index{InstructionQueue@{InstructionQueue}!dumpInsts@{dumpInsts}}
\index{dumpInsts@{dumpInsts}!InstructionQueue@{InstructionQueue}}
\subsubsection[{dumpInsts}]{\setlength{\rightskip}{0pt plus 5cm}void dumpInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classInstructionQueue_a80587b4fe043bbe1995536cb3b361588}
Debugging function to dump out all instructions that are in the IQ. 


\begin{DoxyCode}
1446 {
1447     for (ThreadID tid = 0; tid < numThreads; ++tid) {
1448         int num = 0;
1449         int valid_num = 0;
1450         ListIt inst_list_it = instList[tid].begin();
1451 
1452         while (inst_list_it != instList[tid].end()) {
1453             cprintf("Instruction:%i\n", num);
1454             if (!(*inst_list_it)->isSquashed()) {
1455                 if (!(*inst_list_it)->isIssued()) {
1456                     ++valid_num;
1457                     cprintf("Count:%i\n", valid_num);
1458                 } else if ((*inst_list_it)->isMemRef() &&
1459                            !(*inst_list_it)->memOpDone()) {
1460                     // Loads that have not been marked as executed
1461                     // still count towards the total instructions.
1462                     ++valid_num;
1463                     cprintf("Count:%i\n", valid_num);
1464                 }
1465             }
1466 
1467             cprintf("PC: %s\n[sn:%lli]\n[tid:%i]\n"
1468                     "Issued:%i\nSquashed:%i\n",
1469                     (*inst_list_it)->pcState(),
1470                     (*inst_list_it)->seqNum,
1471                     (*inst_list_it)->threadNumber,
1472                     (*inst_list_it)->isIssued(),
1473                     (*inst_list_it)->isSquashed());
1474 
1475             if ((*inst_list_it)->isMemRef()) {
1476                 cprintf("MemOpDone:%i\n", (*inst_list_it)->memOpDone());
1477             }
1478 
1479             cprintf("\n");
1480 
1481             inst_list_it++;
1482             ++num;
1483         }
1484     }
1485 
1486     cprintf("Insts to Execute list:\n");
1487 
1488     int num = 0;
1489     int valid_num = 0;
1490     ListIt inst_list_it = instsToExecute.begin();
1491 
1492     while (inst_list_it != instsToExecute.end())
1493     {
1494         cprintf("Instruction:%i\n",
1495                 num);
1496         if (!(*inst_list_it)->isSquashed()) {
1497             if (!(*inst_list_it)->isIssued()) {
1498                 ++valid_num;
1499                 cprintf("Count:%i\n", valid_num);
1500             } else if ((*inst_list_it)->isMemRef() &&
1501                        !(*inst_list_it)->memOpDone()) {
1502                 // Loads that have not been marked as executed
1503                 // still count towards the total instructions.
1504                 ++valid_num;
1505                 cprintf("Count:%i\n", valid_num);
1506             }
1507         }
1508 
1509         cprintf("PC: %s\n[sn:%lli]\n[tid:%i]\n"
1510                 "Issued:%i\nSquashed:%i\n",
1511                 (*inst_list_it)->pcState(),
1512                 (*inst_list_it)->seqNum,
1513                 (*inst_list_it)->threadNumber,
1514                 (*inst_list_it)->isIssued(),
1515                 (*inst_list_it)->isSquashed());
1516 
1517         if ((*inst_list_it)->isMemRef()) {
1518             cprintf("MemOpDone:%i\n", (*inst_list_it)->memOpDone());
1519         }
1520 
1521         cprintf("\n");
1522 
1523         inst_list_it++;
1524         ++num;
1525     }
1526 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a3d1dae45e8e0b5cf7c1f4f8c796d070e}{
\index{InstructionQueue@{InstructionQueue}!dumpLists@{dumpLists}}
\index{dumpLists@{dumpLists}!InstructionQueue@{InstructionQueue}}
\subsubsection[{dumpLists}]{\setlength{\rightskip}{0pt plus 5cm}void dumpLists ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classInstructionQueue_a3d1dae45e8e0b5cf7c1f4f8c796d070e}
Debugging function to dump all the list sizes, as well as print out the list of nonspeculative instructions. Should not be used in any other capacity, but it has no harmful sideaffects. 


\begin{DoxyCode}
1403 {
1404     for (int i = 0; i < Num_OpClasses; ++i) {
1405         cprintf("Ready list %i size: %i\n", i, readyInsts[i].size());
1406 
1407         cprintf("\n");
1408     }
1409 
1410     cprintf("Non speculative list size: %i\n", nonSpecInsts.size());
1411 
1412     NonSpecMapIt non_spec_it = nonSpecInsts.begin();
1413     NonSpecMapIt non_spec_end_it = nonSpecInsts.end();
1414 
1415     cprintf("Non speculative list: ");
1416 
1417     while (non_spec_it != non_spec_end_it) {
1418         cprintf("%s [sn:%lli]", (*non_spec_it).second->pcState(),
1419                 (*non_spec_it).second->seqNum);
1420         ++non_spec_it;
1421     }
1422 
1423     cprintf("\n");
1424 
1425     ListOrderIt list_order_it = listOrder.begin();
1426     ListOrderIt list_order_end_it = listOrder.end();
1427     int i = 1;
1428 
1429     cprintf("List order: ");
1430 
1431     while (list_order_it != list_order_end_it) {
1432         cprintf("%i OpClass:%i [sn:%lli] ", i, (*list_order_it).queueType,
1433                 (*list_order_it).oldestInst);
1434 
1435         ++list_order_it;
1436         ++i;
1437     }
1438 
1439     cprintf("\n");
1440 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a5d2b0e4e7d98ea4ebd9fb98ac0d91e2f}{
\index{InstructionQueue@{InstructionQueue}!entryAmount@{entryAmount}}
\index{entryAmount@{entryAmount}!InstructionQueue@{InstructionQueue}}
\subsubsection[{entryAmount}]{\setlength{\rightskip}{0pt plus 5cm}int entryAmount ({\bf ThreadID} {\em num\_\-threads})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a5d2b0e4e7d98ea4ebd9fb98ac0d91e2f}
Number of entries needed for given amount of threads. 


\begin{DoxyCode}
461 {
462     if (iqPolicy == Partitioned) {
463         return numEntries / num_threads;
464     } else {
465         return 0;
466     }
467 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_aaf7eb96b7ab2a8240d043b7d82494d15}{
\index{InstructionQueue@{InstructionQueue}!getCount@{getCount}}
\index{getCount@{getCount}!InstructionQueue@{InstructionQueue}}
\subsubsection[{getCount}]{\setlength{\rightskip}{0pt plus 5cm}unsigned getCount ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_aaf7eb96b7ab2a8240d043b7d82494d15}
Returns the number of used entries for a thread. 


\begin{DoxyCode}
255 { return count[tid]; };
\end{DoxyCode}
\hypertarget{classInstructionQueue_ae2aedd3b5257ee38cb5a4e307d2d50a5}{
\index{InstructionQueue@{InstructionQueue}!getDeferredMemInstToExecute@{getDeferredMemInstToExecute}}
\index{getDeferredMemInstToExecute@{getDeferredMemInstToExecute}!InstructionQueue@{InstructionQueue}}
\subsubsection[{getDeferredMemInstToExecute}]{\setlength{\rightskip}{0pt plus 5cm}Impl::DynInstPtr getDeferredMemInstToExecute ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_ae2aedd3b5257ee38cb5a4e307d2d50a5}
Returns a memory instruction that was referred due to a delayed DTB translation if it is now ready to execute. 


\begin{DoxyCode}
1085 {
1086     for (ListIt it = deferredMemInsts.begin(); it != deferredMemInsts.end();
1087          ++it) {
1088         if ((*it)->translationCompleted() || (*it)->isSquashed()) {
1089             DynInstPtr ret = *it;
1090             deferredMemInsts.erase(it);
1091             return ret;
1092         }
1093     }
1094     return NULL;
1095 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_acf940a475d9687f26e8ab8a98c244f08}{
\index{InstructionQueue@{InstructionQueue}!getInstToExecute@{getInstToExecute}}
\index{getInstToExecute@{getInstToExecute}!InstructionQueue@{InstructionQueue}}
\subsubsection[{getInstToExecute}]{\setlength{\rightskip}{0pt plus 5cm}Impl::DynInstPtr getInstToExecute ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_acf940a475d9687f26e8ab8a98c244f08}
Returns the oldest scheduled instruction, and removes it from the list of instructions waiting to execute. 


\begin{DoxyCode}
640 {
641     assert(!instsToExecute.empty());
642     DynInstPtr inst = instsToExecute.front();
643     instsToExecute.pop_front();
644     if (inst->isFloating()){
645         fpInstQueueReads++;
646     } else {
647         intInstQueueReads++;
648     }
649     return inst;
650 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_ae59aad9cee1e45b5817a9d96553e4567}{
\index{InstructionQueue@{InstructionQueue}!hasReadyInsts@{hasReadyInsts}}
\index{hasReadyInsts@{hasReadyInsts}!InstructionQueue@{InstructionQueue}}
\subsubsection[{hasReadyInsts}]{\setlength{\rightskip}{0pt plus 5cm}bool hasReadyInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_ae59aad9cee1e45b5817a9d96553e4567}
Returns if there are any ready instructions in the IQ. 


\begin{DoxyCode}
533 {
534     if (!listOrder.empty()) {
535         return true;
536     }
537 
538     for (int i = 0; i < Num_OpClasses; ++i) {
539         if (!readyInsts[i].empty()) {
540             return true;
541         }
542     }
543 
544     return false;
545 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a786595aecf8ab7aae40868b5ac4a79a7}{
\index{InstructionQueue@{InstructionQueue}!insert@{insert}}
\index{insert@{insert}!InstructionQueue@{InstructionQueue}}
\subsubsection[{insert}]{\setlength{\rightskip}{0pt plus 5cm}void insert ({\bf DynInstPtr} \& {\em new\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a786595aecf8ab7aae40868b5ac4a79a7}
Inserts a new instruction into the IQ. 


\begin{DoxyCode}
550 {
551     new_inst->isFloating() ? fpInstQueueWrites++ : intInstQueueWrites++;
552     // Make sure the instruction is valid
553     assert(new_inst);
554 
555     DPRINTF(IQ, "Adding instruction [sn:%lli] PC %s to the IQ.\n",
556             new_inst->seqNum, new_inst->pcState());
557 
558     assert(freeEntries != 0);
559 
560     instList[new_inst->threadNumber].push_back(new_inst);
561 
562     --freeEntries;
563 
564     new_inst->setInIQ();
565 
566     // Look through its source registers (physical regs), and mark any
567     // dependencies.
568     addToDependents(new_inst);
569 
570     // Have this instruction set itself as the producer of its destination
571     // register(s).
572     addToProducers(new_inst);
573 
574     if (new_inst->isMemRef()) {
575         memDepUnit[new_inst->threadNumber].insert(new_inst);
576     } else {
577         addIfReady(new_inst);
578     }
579 
580     ++iqInstsAdded;
581 
582     count[new_inst->threadNumber]++;
583 
584     assert(freeEntries == (numEntries - countInsts()));
585 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_ae556f19566bae9c4f55350eab17abacd}{
\index{InstructionQueue@{InstructionQueue}!insertBarrier@{insertBarrier}}
\index{insertBarrier@{insertBarrier}!InstructionQueue@{InstructionQueue}}
\subsubsection[{insertBarrier}]{\setlength{\rightskip}{0pt plus 5cm}void insertBarrier ({\bf DynInstPtr} \& {\em barr\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_ae556f19566bae9c4f55350eab17abacd}
Inserts a memory or write barrier into the IQ to make sure loads and stores are ordered properly. 


\begin{DoxyCode}
631 {
632     memDepUnit[barr_inst->threadNumber].insertBarrier(barr_inst);
633 
634     insertNonSpec(barr_inst);
635 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a4f7523e76440d88096a4eac14f2e0dd3}{
\index{InstructionQueue@{InstructionQueue}!insertNonSpec@{insertNonSpec}}
\index{insertNonSpec@{insertNonSpec}!InstructionQueue@{InstructionQueue}}
\subsubsection[{insertNonSpec}]{\setlength{\rightskip}{0pt plus 5cm}void insertNonSpec ({\bf DynInstPtr} \& {\em new\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a4f7523e76440d88096a4eac14f2e0dd3}
Inserts a new, non-\/speculative instruction into the IQ. 


\begin{DoxyCode}
590 {
591     // @todo: Clean up this code; can do it by setting inst as unable
592     // to issue, then calling normal insert on the inst.
593     new_inst->isFloating() ? fpInstQueueWrites++ : intInstQueueWrites++;
594 
595     assert(new_inst);
596 
597     nonSpecInsts[new_inst->seqNum] = new_inst;
598 
599     DPRINTF(IQ, "Adding non-speculative instruction [sn:%lli] PC %s "
600             "to the IQ.\n",
601             new_inst->seqNum, new_inst->pcState());
602 
603     assert(freeEntries != 0);
604 
605     instList[new_inst->threadNumber].push_back(new_inst);
606 
607     --freeEntries;
608 
609     new_inst->setInIQ();
610 
611     // Have this instruction set itself as the producer of its destination
612     // register(s).
613     addToProducers(new_inst);
614 
615     // If it's a memory instruction, add it to the memory dependency
616     // unit.
617     if (new_inst->isMemRef()) {
618         memDepUnit[new_inst->threadNumber].insertNonSpec(new_inst);
619     }
620 
621     ++iqNonSpecInstsAdded;
622 
623     count[new_inst->threadNumber]++;
624 
625     assert(freeEntries == (numEntries - countInsts()));
626 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a30fac732df9b3fda011c7329a112cb31}{
\index{InstructionQueue@{InstructionQueue}!isFull@{isFull}}
\index{isFull@{isFull}!InstructionQueue@{InstructionQueue}}
\subsubsection[{isFull}]{\setlength{\rightskip}{0pt plus 5cm}bool isFull ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a30fac732df9b3fda011c7329a112cb31}
Returns whether or not the IQ is full for a specific thread. 


\begin{DoxyCode}
522 {
523     if (numFreeEntries(tid) == 0) {
524         return(true);
525     } else {
526         return(false);
527     }
528 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a3e70330939fdfc4dbc2f60c1a660584d}{
\index{InstructionQueue@{InstructionQueue}!isFull@{isFull}}
\index{isFull@{isFull}!InstructionQueue@{InstructionQueue}}
\subsubsection[{isFull}]{\setlength{\rightskip}{0pt plus 5cm}bool isFull ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a3e70330939fdfc4dbc2f60c1a660584d}
Returns whether or not the IQ is full. 


\begin{DoxyCode}
511 {
512     if (freeEntries == 0) {
513         return(true);
514     } else {
515         return(false);
516     }
517 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_ae4cc92176e08b27989bb2838e4e32b1c}{
\index{InstructionQueue@{InstructionQueue}!moveToYoungerInst@{moveToYoungerInst}}
\index{moveToYoungerInst@{moveToYoungerInst}!InstructionQueue@{InstructionQueue}}
\subsubsection[{moveToYoungerInst}]{\setlength{\rightskip}{0pt plus 5cm}void moveToYoungerInst ({\bf ListOrderIt} {\em age\_\-order\_\-it})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classInstructionQueue_ae4cc92176e08b27989bb2838e4e32b1c}
Called when the oldest instruction has been removed from a ready queue; this places that ready queue into the proper spot in the age order list. 


\begin{DoxyCode}
682 {
683     // Get iterator of next item on the list
684     // Delete the original iterator
685     // Determine if the next item is either the end of the list or younger
686     // than the new instruction.  If so, then add in a new iterator right here.
687     // If not, then move along.
688     ListOrderEntry queue_entry;
689     OpClass op_class = (*list_order_it).queueType;
690     ListOrderIt next_it = list_order_it;
691 
692     ++next_it;
693 
694     queue_entry.queueType = op_class;
695     queue_entry.oldestInst = readyInsts[op_class].top()->seqNum;
696 
697     while (next_it != listOrder.end() &&
698            (*next_it).oldestInst < queue_entry.oldestInst) {
699         ++next_it;
700     }
701 
702     readyIt[op_class] = listOrder.insert(next_it, queue_entry);
703 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{InstructionQueue@{InstructionQueue}!name@{name}}
\index{name@{name}!InstructionQueue@{InstructionQueue}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a37627d5d5bba7f4a8690c71c2ab3cb07}
Returns the name of the IQ. 


\begin{DoxyCode}
180 {
181     return cpu->name() + ".iq";
182 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_acc878f608deead5b5319a6a3f98b50c8}{
\index{InstructionQueue@{InstructionQueue}!numFreeEntries@{numFreeEntries}}
\index{numFreeEntries@{numFreeEntries}!InstructionQueue@{InstructionQueue}}
\subsubsection[{numFreeEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned numFreeEntries ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_acc878f608deead5b5319a6a3f98b50c8}
Returns number of free entries for a thread. 


\begin{DoxyCode}
502 {
503     return maxEntries[tid] - count[tid];
504 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a028971a565aca048c67ea1c36a6a9d51}{
\index{InstructionQueue@{InstructionQueue}!numFreeEntries@{numFreeEntries}}
\index{numFreeEntries@{numFreeEntries}!InstructionQueue@{InstructionQueue}}
\subsubsection[{numFreeEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned numFreeEntries ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a028971a565aca048c67ea1c36a6a9d51}
Returns total number of free entries. 


\begin{DoxyCode}
495 {
496     return freeEntries;
497 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_afc9c0c90c27fe0dc8bd4da915596bc21}{
\index{InstructionQueue@{InstructionQueue}!printInsts@{printInsts}}
\index{printInsts@{printInsts}!InstructionQueue@{InstructionQueue}}
\subsubsection[{printInsts}]{\setlength{\rightskip}{0pt plus 5cm}void printInsts ()}}
\label{classInstructionQueue_afc9c0c90c27fe0dc8bd4da915596bc21}
\hyperlink{namespaceDebug}{Debug} function to print all instructions. \hypertarget{classInstructionQueue_ad118e191396cf75b93afd066a6a3f486}{
\index{InstructionQueue@{InstructionQueue}!processFUCompletion@{processFUCompletion}}
\index{processFUCompletion@{processFUCompletion}!InstructionQueue@{InstructionQueue}}
\subsubsection[{processFUCompletion}]{\setlength{\rightskip}{0pt plus 5cm}void processFUCompletion ({\bf DynInstPtr} \& {\em inst}, \/  int {\em fu\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_ad118e191396cf75b93afd066a6a3f486}
\hyperlink{classProcess}{Process} FU completion event. 


\begin{DoxyCode}
708 {
709     DPRINTF(IQ, "Processing FU completion [sn:%lli]\n", inst->seqNum);
710     assert(!cpu->switchedOut());
711     // The CPU could have been sleeping until this op completed (*extremely*
712     // long latency op).  Wake it if it was.  This may be overkill.
713     iewStage->wakeCPU();
714 
715     if (fu_idx > -1)
716         fuPool->freeUnitNextCycle(fu_idx);
717 
718     // @todo: Ensure that these FU Completions happen at the beginning
719     // of a cycle, otherwise they could add too many instructions to
720     // the queue.
721     issueToExecuteQueue->access(-1)->size++;
722     instsToExecute.push_back(inst);
723 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_ae43022d3677118a4ab40113712045f64}{
\index{InstructionQueue@{InstructionQueue}!recordProducer@{recordProducer}}
\index{recordProducer@{recordProducer}!InstructionQueue@{InstructionQueue}}
\subsubsection[{recordProducer}]{\setlength{\rightskip}{0pt plus 5cm}void recordProducer ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_ae43022d3677118a4ab40113712045f64}
Records the instruction as the producer of a register without adding it to the rest of the IQ. 


\begin{DoxyCode}
201     { addToProducers(inst); }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{InstructionQueue@{InstructionQueue}!regStats@{regStats}}
\index{regStats@{regStats}!InstructionQueue@{InstructionQueue}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a4dc637449366fcdfc4e764cdf12d9b11}
Registers statistics. 


\begin{DoxyCode}
187 {
188     using namespace Stats;
189     iqInstsAdded
190         .name(name() + ".iqInstsAdded")
191         .desc("Number of instructions added to the IQ (excludes non-spec)")
192         .prereq(iqInstsAdded);
193 
194     iqNonSpecInstsAdded
195         .name(name() + ".iqNonSpecInstsAdded")
196         .desc("Number of non-speculative instructions added to the IQ")
197         .prereq(iqNonSpecInstsAdded);
198 
199     iqInstsIssued
200         .name(name() + ".iqInstsIssued")
201         .desc("Number of instructions issued")
202         .prereq(iqInstsIssued);
203 
204     iqIntInstsIssued
205         .name(name() + ".iqIntInstsIssued")
206         .desc("Number of integer instructions issued")
207         .prereq(iqIntInstsIssued);
208 
209     iqFloatInstsIssued
210         .name(name() + ".iqFloatInstsIssued")
211         .desc("Number of float instructions issued")
212         .prereq(iqFloatInstsIssued);
213 
214     iqBranchInstsIssued
215         .name(name() + ".iqBranchInstsIssued")
216         .desc("Number of branch instructions issued")
217         .prereq(iqBranchInstsIssued);
218 
219     iqMemInstsIssued
220         .name(name() + ".iqMemInstsIssued")
221         .desc("Number of memory instructions issued")
222         .prereq(iqMemInstsIssued);
223 
224     iqMiscInstsIssued
225         .name(name() + ".iqMiscInstsIssued")
226         .desc("Number of miscellaneous instructions issued")
227         .prereq(iqMiscInstsIssued);
228 
229     iqSquashedInstsIssued
230         .name(name() + ".iqSquashedInstsIssued")
231         .desc("Number of squashed instructions issued")
232         .prereq(iqSquashedInstsIssued);
233 
234     iqSquashedInstsExamined
235         .name(name() + ".iqSquashedInstsExamined")
236         .desc("Number of squashed instructions iterated over during squash;"
237               " mainly for profiling")
238         .prereq(iqSquashedInstsExamined);
239 
240     iqSquashedOperandsExamined
241         .name(name() + ".iqSquashedOperandsExamined")
242         .desc("Number of squashed operands that are examined and possibly "
243               "removed from graph")
244         .prereq(iqSquashedOperandsExamined);
245 
246     iqSquashedNonSpecRemoved
247         .name(name() + ".iqSquashedNonSpecRemoved")
248         .desc("Number of squashed non-spec instructions that were removed")
249         .prereq(iqSquashedNonSpecRemoved);
250 /*
251     queueResDist
252         .init(Num_OpClasses, 0, 99, 2)
253         .name(name() + ".IQ:residence:")
254         .desc("cycles from dispatch to issue")
255         .flags(total | pdf | cdf )
256         ;
257     for (int i = 0; i < Num_OpClasses; ++i) {
258         queueResDist.subname(i, opClassStrings[i]);
259     }
260 */
261     numIssuedDist
262         .init(0,totalWidth,1)
263         .name(name() + ".issued_per_cycle")
264         .desc("Number of insts issued each cycle")
265         .flags(pdf)
266         ;
267 /*
268     dist_unissued
269         .init(Num_OpClasses+2)
270         .name(name() + ".unissued_cause")
271         .desc("Reason ready instruction not issued")
272         .flags(pdf | dist)
273         ;
274     for (int i=0; i < (Num_OpClasses + 2); ++i) {
275         dist_unissued.subname(i, unissued_names[i]);
276     }
277 */
278     statIssuedInstType
279         .init(numThreads,Enums::Num_OpClass)
280         .name(name() + ".FU_type")
281         .desc("Type of FU issued")
282         .flags(total | pdf | dist)
283         ;
284     statIssuedInstType.ysubnames(Enums::OpClassStrings);
285 
286     //
287     //  How long did instructions for a particular FU type wait prior to issue
288     //
289 /*
290     issueDelayDist
291         .init(Num_OpClasses,0,99,2)
292         .name(name() + ".")
293         .desc("cycles from operands ready to issue")
294         .flags(pdf | cdf)
295         ;
296 
297     for (int i=0; i<Num_OpClasses; ++i) {
298         std::stringstream subname;
299         subname << opClassStrings[i] << "_delay";
300         issueDelayDist.subname(i, subname.str());
301     }
302 */
303     issueRate
304         .name(name() + ".rate")
305         .desc("Inst issue rate")
306         .flags(total)
307         ;
308     issueRate = iqInstsIssued / cpu->numCycles;
309 
310     statFuBusy
311         .init(Num_OpClasses)
312         .name(name() + ".fu_full")
313         .desc("attempts to use FU when none available")
314         .flags(pdf | dist)
315         ;
316     for (int i=0; i < Num_OpClasses; ++i) {
317         statFuBusy.subname(i, Enums::OpClassStrings[i]);
318     }
319 
320     fuBusy
321         .init(numThreads)
322         .name(name() + ".fu_busy_cnt")
323         .desc("FU busy when requested")
324         .flags(total)
325         ;
326 
327     fuBusyRate
328         .name(name() + ".fu_busy_rate")
329         .desc("FU busy rate (busy events/executed inst)")
330         .flags(total)
331         ;
332     fuBusyRate = fuBusy / iqInstsIssued;
333 
334     for (ThreadID tid = 0; tid < numThreads; tid++) {
335         // Tell mem dependence unit to reg stats as well.
336         memDepUnit[tid].regStats();
337     }
338 
339     intInstQueueReads
340         .name(name() + ".int_inst_queue_reads")
341         .desc("Number of integer instruction queue reads")
342         .flags(total);
343 
344     intInstQueueWrites
345         .name(name() + ".int_inst_queue_writes")
346         .desc("Number of integer instruction queue writes")
347         .flags(total);
348 
349     intInstQueueWakeupAccesses
350         .name(name() + ".int_inst_queue_wakeup_accesses")
351         .desc("Number of integer instruction queue wakeup accesses")
352         .flags(total);
353 
354     fpInstQueueReads
355         .name(name() + ".fp_inst_queue_reads")
356         .desc("Number of floating instruction queue reads")
357         .flags(total);
358 
359     fpInstQueueWrites
360         .name(name() + ".fp_inst_queue_writes")
361         .desc("Number of floating instruction queue writes")
362         .flags(total);
363 
364     fpInstQueueWakeupQccesses
365         .name(name() + ".fp_inst_queue_wakeup_accesses")
366         .desc("Number of floating instruction queue wakeup accesses")
367         .flags(total);
368 
369     intAluAccesses
370         .name(name() + ".int_alu_accesses")
371         .desc("Number of integer alu accesses")
372         .flags(total);
373 
374     fpAluAccesses
375         .name(name() + ".fp_alu_accesses")
376         .desc("Number of floating point alu accesses")
377         .flags(total);
378 
379 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_af6c215567b7a5a496ef245cd86df2e62}{
\index{InstructionQueue@{InstructionQueue}!replayMemInst@{replayMemInst}}
\index{replayMemInst@{replayMemInst}!InstructionQueue@{InstructionQueue}}
\subsubsection[{replayMemInst}]{\setlength{\rightskip}{0pt plus 5cm}void replayMemInst ({\bf DynInstPtr} \& {\em replay\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_af6c215567b7a5a496ef245cd86df2e62}
Replays a memory instruction. It must be rescheduled first. 


\begin{DoxyCode}
1054 {
1055     memDepUnit[replay_inst->threadNumber].replay(replay_inst);
1056 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_afdf61c4d00a7c48449b14c6f525e3869}{
\index{InstructionQueue@{InstructionQueue}!rescheduleMemInst@{rescheduleMemInst}}
\index{rescheduleMemInst@{rescheduleMemInst}!InstructionQueue@{InstructionQueue}}
\subsubsection[{rescheduleMemInst}]{\setlength{\rightskip}{0pt plus 5cm}void rescheduleMemInst ({\bf DynInstPtr} \& {\em resched\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_afdf61c4d00a7c48449b14c6f525e3869}
Reschedules a memory instruction. It will be ready to issue once \hyperlink{classInstructionQueue_af6c215567b7a5a496ef245cd86df2e62}{replayMemInst()} is called. 


\begin{DoxyCode}
1040 {
1041     DPRINTF(IQ, "Rescheduling mem inst [sn:%lli]\n", resched_inst->seqNum);
1042 
1043     // Reset DTB translation state
1044     resched_inst->translationStarted(false);
1045     resched_inst->translationCompleted(false);
1046 
1047     resched_inst->clearCanIssue();
1048     memDepUnit[resched_inst->threadNumber].reschedule(resched_inst);
1049 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_aaf9a05771a835f9f8d634cef36e24d40}{
\index{InstructionQueue@{InstructionQueue}!resetEntries@{resetEntries}}
\index{resetEntries@{resetEntries}!InstructionQueue@{InstructionQueue}}
\subsubsection[{resetEntries}]{\setlength{\rightskip}{0pt plus 5cm}void resetEntries ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_aaf9a05771a835f9f8d634cef36e24d40}
Resets max entries for all threads. 


\begin{DoxyCode}
473 {
474     if (iqPolicy != Dynamic || numThreads > 1) {
475         int active_threads = activeThreads->size();
476 
477         list<ThreadID>::iterator threads = activeThreads->begin();
478         list<ThreadID>::iterator end = activeThreads->end();
479 
480         while (threads != end) {
481             ThreadID tid = *threads++;
482 
483             if (iqPolicy == Partitioned) {
484                 maxEntries[tid] = numEntries / active_threads;
485             } else if(iqPolicy == Threshold && active_threads == 1) {
486                 maxEntries[tid] = numEntries;
487             }
488         }
489     }
490 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a755ee993c2d4e9d422c37990b15afa37}{
\index{InstructionQueue@{InstructionQueue}!resetState@{resetState}}
\index{resetState@{resetState}!InstructionQueue@{InstructionQueue}}
\subsubsection[{resetState}]{\setlength{\rightskip}{0pt plus 5cm}void resetState ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a755ee993c2d4e9d422c37990b15afa37}
Resets all instruction queue state. 


\begin{DoxyCode}
384 {
385     //Initialize thread IQ counts
386     for (ThreadID tid = 0; tid <numThreads; tid++) {
387         count[tid] = 0;
388         instList[tid].clear();
389     }
390 
391     // Initialize the number of free IQ entries.
392     freeEntries = numEntries;
393 
394     // Note that in actuality, the registers corresponding to the logical
395     // registers start off as ready.  However this doesn't matter for the
396     // IQ as the instruction should have been correctly told if those
397     // registers are ready in rename.  Thus it can all be initialized as
398     // unready.
399     for (int i = 0; i < numPhysRegs; ++i) {
400         regScoreboard[i] = false;
401     }
402 
403     for (ThreadID tid = 0; tid < numThreads; ++tid) {
404         squashedSeqNum[tid] = 0;
405     }
406 
407     for (int i = 0; i < Num_OpClasses; ++i) {
408         while (!readyInsts[i].empty())
409             readyInsts[i].pop();
410         queueOnList[i] = false;
411         readyIt[i] = listOrder.end();
412     }
413     nonSpecInsts.clear();
414     listOrder.clear();
415     deferredMemInsts.clear();
416 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a15ca5aaeab5bd4c2169ed41bbc7fb79c}{
\index{InstructionQueue@{InstructionQueue}!scheduleNonSpec@{scheduleNonSpec}}
\index{scheduleNonSpec@{scheduleNonSpec}!InstructionQueue@{InstructionQueue}}
\subsubsection[{scheduleNonSpec}]{\setlength{\rightskip}{0pt plus 5cm}void scheduleNonSpec (const {\bf InstSeqNum} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a15ca5aaeab5bd4c2169ed41bbc7fb79c}
Schedules a single specific non-\/speculative instruction. 


\begin{DoxyCode}
889 {
890     DPRINTF(IQ, "Marking nonspeculative instruction [sn:%lli] as ready "
891             "to execute.\n", inst);
892 
893     NonSpecMapIt inst_it = nonSpecInsts.find(inst);
894 
895     assert(inst_it != nonSpecInsts.end());
896 
897     ThreadID tid = (*inst_it).second->threadNumber;
898 
899     (*inst_it).second->setAtCommit();
900 
901     (*inst_it).second->setCanIssue();
902 
903     if (!(*inst_it).second->isMemRef()) {
904         addIfReady((*inst_it).second);
905     } else {
906         memDepUnit[tid].nonSpecInstReady((*inst_it).second);
907     }
908 
909     (*inst_it).second = NULL;
910 
911     nonSpecInsts.erase(inst_it);
912 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a3694e72427d3a616808797f9343d1fc4}{
\index{InstructionQueue@{InstructionQueue}!scheduleReadyInsts@{scheduleReadyInsts}}
\index{scheduleReadyInsts@{scheduleReadyInsts}!InstructionQueue@{InstructionQueue}}
\subsubsection[{scheduleReadyInsts}]{\setlength{\rightskip}{0pt plus 5cm}void scheduleReadyInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a3694e72427d3a616808797f9343d1fc4}
Schedules ready instructions, adding the ready ones (oldest first) to the queue to execute. 


\begin{DoxyCode}
731 {
732     DPRINTF(IQ, "Attempting to schedule ready instructions from "
733             "the IQ.\n");
734 
735     IssueStruct *i2e_info = issueToExecuteQueue->access(0);
736 
737     DynInstPtr deferred_mem_inst;
738     int total_deferred_mem_issued = 0;
739     while (total_deferred_mem_issued < totalWidth &&
740            (deferred_mem_inst = getDeferredMemInstToExecute()) != 0) {
741         issueToExecuteQueue->access(0)->size++;
742         instsToExecute.push_back(deferred_mem_inst);
743         total_deferred_mem_issued++;
744     }
745 
746     // Have iterator to head of the list
747     // While I haven't exceeded bandwidth or reached the end of the list,
748     // Try to get a FU that can do what this op needs.
749     // If successful, change the oldestInst to the new top of the list, put
750     // the queue in the proper place in the list.
751     // Increment the iterator.
752     // This will avoid trying to schedule a certain op class if there are no
753     // FUs that handle it.
754     ListOrderIt order_it = listOrder.begin();
755     ListOrderIt order_end_it = listOrder.end();
756     int total_issued = 0;
757 
758     while (total_issued < (totalWidth - total_deferred_mem_issued) &&
759            iewStage->canIssue() &&
760            order_it != order_end_it) {
761         OpClass op_class = (*order_it).queueType;
762 
763         assert(!readyInsts[op_class].empty());
764 
765         DynInstPtr issuing_inst = readyInsts[op_class].top();
766 
767         issuing_inst->isFloating() ? fpInstQueueReads++ : intInstQueueReads++;
768 
769         assert(issuing_inst->seqNum == (*order_it).oldestInst);
770 
771         if (issuing_inst->isSquashed()) {
772             readyInsts[op_class].pop();
773 
774             if (!readyInsts[op_class].empty()) {
775                 moveToYoungerInst(order_it);
776             } else {
777                 readyIt[op_class] = listOrder.end();
778                 queueOnList[op_class] = false;
779             }
780 
781             listOrder.erase(order_it++);
782 
783             ++iqSquashedInstsIssued;
784 
785             continue;
786         }
787 
788         int idx = -2;
789         Cycles op_latency = Cycles(1);
790         ThreadID tid = issuing_inst->threadNumber;
791 
792         if (op_class != No_OpClass) {
793             idx = fuPool->getUnit(op_class);
794             issuing_inst->isFloating() ? fpAluAccesses++ : intAluAccesses++;
795             if (idx > -1) {
796                 op_latency = fuPool->getOpLatency(op_class);
797             }
798         }
799 
800         // If we have an instruction that doesn't require a FU, or a
801         // valid FU, then schedule for execution.
802         if (idx == -2 || idx != -1) {
803             if (op_latency == Cycles(1)) {
804                 i2e_info->size++;
805                 instsToExecute.push_back(issuing_inst);
806 
807                 // Add the FU onto the list of FU's to be freed next
808                 // cycle if we used one.
809                 if (idx >= 0)
810                     fuPool->freeUnitNextCycle(idx);
811             } else {
812                 Cycles issue_latency = fuPool->getIssueLatency(op_class);
813                 // Generate completion event for the FU
814                 FUCompletion *execution = new FUCompletion(issuing_inst,
815                                                            idx, this);
816 
817                 cpu->schedule(execution,
818                               cpu->clockEdge(Cycles(op_latency - 1)));
819 
820                 // @todo: Enforce that issue_latency == 1 or op_latency
821                 if (issue_latency > Cycles(1)) {
822                     // If FU isn't pipelined, then it must be freed
823                     // upon the execution completing.
824                     execution->setFreeFU();
825                 } else {
826                     // Add the FU onto the list of FU's to be freed next cycle.
827                     fuPool->freeUnitNextCycle(idx);
828                 }
829             }
830 
831             DPRINTF(IQ, "Thread %i: Issuing instruction PC %s "
832                     "[sn:%lli]\n",
833                     tid, issuing_inst->pcState(),
834                     issuing_inst->seqNum);
835 
836             readyInsts[op_class].pop();
837 
838             if (!readyInsts[op_class].empty()) {
839                 moveToYoungerInst(order_it);
840             } else {
841                 readyIt[op_class] = listOrder.end();
842                 queueOnList[op_class] = false;
843             }
844 
845             issuing_inst->setIssued();
846             ++total_issued;
847 
848 #if TRACING_ON
849             issuing_inst->issueTick = curTick() - issuing_inst->fetchTick;
850 #endif
851 
852             if (!issuing_inst->isMemRef()) {
853                 // Memory instructions can not be freed from the IQ until they
854                 // complete.
855                 ++freeEntries;
856                 count[tid]--;
857                 issuing_inst->clearInIQ();
858             } else {
859                 memDepUnit[tid].issue(issuing_inst);
860             }
861 
862             listOrder.erase(order_it++);
863             statIssuedInstType[tid][op_class]++;
864             iewStage->incrWb(issuing_inst->seqNum);
865         } else {
866             statFuBusy[op_class]++;
867             fuBusy[tid]++;
868             ++order_it;
869         }
870     }
871 
872     numIssuedDist.sample(total_issued);
873     iqInstsIssued+= total_issued;
874 
875     // If we issued any instructions, tell the CPU we had activity.
876     // @todo If the way deferred memory instructions are handeled due to
877     // translation changes then the deferredMemInsts condition should be removed
878     // from the code below.
879     if (total_issued || total_deferred_mem_issued || deferredMemInsts.size()) {
880         cpu->activityThisCycle();
881     } else {
882         DPRINTF(IQ, "Not able to schedule any instructions.\n");
883     }
884 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_aab96bdacf8bd420402cbb543f994e054}{
\index{InstructionQueue@{InstructionQueue}!setActiveThreads@{setActiveThreads}}
\index{setActiveThreads@{setActiveThreads}!InstructionQueue@{InstructionQueue}}
\subsubsection[{setActiveThreads}]{\setlength{\rightskip}{0pt plus 5cm}void setActiveThreads ({\bf std::list}$<$ {\bf ThreadID} $>$ $\ast$ {\em at\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_aab96bdacf8bd420402cbb543f994e054}
Sets active threads list. 


\begin{DoxyCode}
421 {
422     activeThreads = at_ptr;
423 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a7cbe625b8c47621898e7ca92d70c826b}{
\index{InstructionQueue@{InstructionQueue}!setIssueToExecuteQueue@{setIssueToExecuteQueue}}
\index{setIssueToExecuteQueue@{setIssueToExecuteQueue}!InstructionQueue@{InstructionQueue}}
\subsubsection[{setIssueToExecuteQueue}]{\setlength{\rightskip}{0pt plus 5cm}void setIssueToExecuteQueue ({\bf TimeBuffer}$<$ {\bf IssueStruct} $>$ $\ast$ {\em i2eQueue})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a7cbe625b8c47621898e7ca92d70c826b}
Sets the timer buffer between issue and execute. 


\begin{DoxyCode}
428 {
429       issueToExecuteQueue = i2e_ptr;
430 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a2b521ea5f191fff72265f60d4ed5187b}{
\index{InstructionQueue@{InstructionQueue}!setTimeBuffer@{setTimeBuffer}}
\index{setTimeBuffer@{setTimeBuffer}!InstructionQueue@{InstructionQueue}}
\subsubsection[{setTimeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}void setTimeBuffer ({\bf TimeBuffer}$<$ {\bf TimeStruct} $>$ $\ast$ {\em tb\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a2b521ea5f191fff72265f60d4ed5187b}
Sets the global time buffer. 


\begin{DoxyCode}
435 {
436     timeBuffer = tb_ptr;
437 
438     fromCommit = timeBuffer->getWire(-commitToIEWDelay);
439 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_ad33d65c18c323d90695d7c2355b49af9}{
\index{InstructionQueue@{InstructionQueue}!squash@{squash}}
\index{squash@{squash}!InstructionQueue@{InstructionQueue}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_ad33d65c18c323d90695d7c2355b49af9}
Squashes instructions for a thread. Squashing information is obtained from the time buffer. 


\begin{DoxyCode}
1109 {
1110     DPRINTF(IQ, "[tid:%i]: Starting to squash instructions in "
1111             "the IQ.\n", tid);
1112 
1113     // Read instruction sequence number of last instruction out of the
1114     // time buffer.
1115     squashedSeqNum[tid] = fromCommit->commitInfo[tid].doneSeqNum;
1116 
1117     // Call doSquash if there are insts in the IQ
1118     if (count[tid] > 0) {
1119         doSquash(tid);
1120     }
1121 
1122     // Also tell the memory dependence unit to squash.
1123     memDepUnit[tid].squash(squashedSeqNum[tid], tid);
1124 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_a8674059ce345e23aac5086b2c3e24a43}{
\index{InstructionQueue@{InstructionQueue}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!InstructionQueue@{InstructionQueue}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_a8674059ce345e23aac5086b2c3e24a43}
Takes over execution from another CPU's thread. 


\begin{DoxyCode}
454 {
455     resetState();
456 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_aeea40175042f18a63a90cbbd7dd451bc}{
\index{InstructionQueue@{InstructionQueue}!violation@{violation}}
\index{violation@{violation}!InstructionQueue@{InstructionQueue}}
\subsubsection[{violation}]{\setlength{\rightskip}{0pt plus 5cm}void violation ({\bf DynInstPtr} \& {\em store}, \/  {\bf DynInstPtr} \& {\em faulting\_\-load})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_aeea40175042f18a63a90cbbd7dd451bc}
Indicates an ordering violation between a store and a load. 


\begin{DoxyCode}
1101 {
1102     intInstQueueWrites++;
1103     memDepUnit[store->threadNumber].violation(store, faulting_load);
1104 }
\end{DoxyCode}
\hypertarget{classInstructionQueue_aab5cfade3ce4bb4addbf52c7464676d9}{
\index{InstructionQueue@{InstructionQueue}!wakeDependents@{wakeDependents}}
\index{wakeDependents@{wakeDependents}!InstructionQueue@{InstructionQueue}}
\subsubsection[{wakeDependents}]{\setlength{\rightskip}{0pt plus 5cm}int wakeDependents ({\bf DynInstPtr} \& {\em completed\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstructionQueue_aab5cfade3ce4bb4addbf52c7464676d9}
Wakes all dependents of a completed instruction. 


\begin{DoxyCode}
935 {
936     int dependents = 0;
937 
938     // The instruction queue here takes care of both floating and int ops
939     if (completed_inst->isFloating()) {
940         fpInstQueueWakeupQccesses++;
941     } else {
942         intInstQueueWakeupAccesses++;
943     }
944 
945     DPRINTF(IQ, "Waking dependents of completed instruction.\n");
946 
947     assert(!completed_inst->isSquashed());
948 
949     // Tell the memory dependence unit to wake any dependents on this
950     // instruction if it is a memory instruction.  Also complete the memory
951     // instruction at this point since we know it executed without issues.
952     // @todo: Might want to rename "completeMemInst" to something that
953     // indicates that it won't need to be replayed, and call this
954     // earlier.  Might not be a big deal.
955     if (completed_inst->isMemRef()) {
956         memDepUnit[completed_inst->threadNumber].wakeDependents(completed_inst);
957         completeMemInst(completed_inst);
958     } else if (completed_inst->isMemBarrier() ||
959                completed_inst->isWriteBarrier()) {
960         memDepUnit[completed_inst->threadNumber].completeBarrier(completed_inst);
      
961     }
962 
963     for (int dest_reg_idx = 0;
964          dest_reg_idx < completed_inst->numDestRegs();
965          dest_reg_idx++)
966     {
967         PhysRegIndex dest_reg =
968             completed_inst->renamedDestRegIdx(dest_reg_idx);
969 
970         // Special case of uniq or control registers.  They are not
971         // handled by the IQ and thus have no dependency graph entry.
972         // @todo Figure out a cleaner way to handle this.
973         if (dest_reg >= numPhysRegs) {
974             DPRINTF(IQ, "dest_reg :%d, numPhysRegs: %d\n", dest_reg,
975                     numPhysRegs);
976             continue;
977         }
978 
979         DPRINTF(IQ, "Waking any dependents on register %i.\n",
980                 (int) dest_reg);
981 
982         //Go through the dependency chain, marking the registers as
983         //ready within the waiting instructions.
984         DynInstPtr dep_inst = dependGraph.pop(dest_reg);
985 
986         while (dep_inst) {
987             DPRINTF(IQ, "Waking up a dependent instruction, [sn:%lli] "
988                     "PC %s.\n", dep_inst->seqNum, dep_inst->pcState());
989 
990             // Might want to give more information to the instruction
991             // so that it knows which of its source registers is
992             // ready.  However that would mean that the dependency
993             // graph entries would need to hold the src_reg_idx.
994             dep_inst->markSrcRegReady();
995 
996             addIfReady(dep_inst);
997 
998             dep_inst = dependGraph.pop(dest_reg);
999 
1000             ++dependents;
1001         }
1002 
1003         // Reset the head node now that all of its dependents have
1004         // been woken up.
1005         assert(dependGraph.empty(dest_reg));
1006         dependGraph.clearInst(dest_reg);
1007 
1008         // Mark the scoreboard as having that register ready.
1009         regScoreboard[dest_reg] = true;
1010     }
1011     return dependents;
1012 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classInstructionQueue_af6eaea53db532812052f71bf0380dab5}{
\index{InstructionQueue@{InstructionQueue}!activeThreads@{activeThreads}}
\index{activeThreads@{activeThreads}!InstructionQueue@{InstructionQueue}}
\subsubsection[{activeThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf ThreadID}$>$$\ast$ {\bf activeThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_af6eaea53db532812052f71bf0380dab5}
Pointer to list of active threads. \hypertarget{classInstructionQueue_a6b6fe1148ed7c40758e45f351c375552}{
\index{InstructionQueue@{InstructionQueue}!commitToIEWDelay@{commitToIEWDelay}}
\index{commitToIEWDelay@{commitToIEWDelay}!InstructionQueue@{InstructionQueue}}
\subsubsection[{commitToIEWDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf commitToIEWDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a6b6fe1148ed7c40758e45f351c375552}
Delay between commit stage and the IQ. \begin{Desc}
\item[\hyperlink{todo__todo000032}{TODO}]: Make there be a distinction between the delays within IEW. \end{Desc}
\hypertarget{classInstructionQueue_ac638062ba1de6609f143c5ee3a601109}{
\index{InstructionQueue@{InstructionQueue}!count@{count}}
\index{count@{count}!InstructionQueue@{InstructionQueue}}
\subsubsection[{count}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf count}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_ac638062ba1de6609f143c5ee3a601109}
Per Thread IQ count \hypertarget{classInstructionQueue_a1379cf882a12ac6fc9eba5da7c84b18b}{
\index{InstructionQueue@{InstructionQueue}!cpu@{cpu}}
\index{cpu@{cpu}!InstructionQueue@{InstructionQueue}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf O3CPU}$\ast$ {\bf cpu}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a1379cf882a12ac6fc9eba5da7c84b18b}
Pointer to the CPU. \hypertarget{classInstructionQueue_a22dc8294eecb144fbdd951d2e32e9330}{
\index{InstructionQueue@{InstructionQueue}!dcacheInterface@{dcacheInterface}}
\index{dcacheInterface@{dcacheInterface}!InstructionQueue@{InstructionQueue}}
\subsubsection[{dcacheInterface}]{\setlength{\rightskip}{0pt plus 5cm}MemInterface$\ast$ {\bf dcacheInterface}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a22dc8294eecb144fbdd951d2e32e9330}
\hyperlink{classCache}{Cache} interface. \hypertarget{classInstructionQueue_a6ea0c1a972364b789a8b6831cf7828cf}{
\index{InstructionQueue@{InstructionQueue}!deferredMemInsts@{deferredMemInsts}}
\index{deferredMemInsts@{deferredMemInsts}!InstructionQueue@{InstructionQueue}}
\subsubsection[{deferredMemInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf deferredMemInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a6ea0c1a972364b789a8b6831cf7828cf}
List of instructions waiting for their DTB translation to complete (hw page table walk in progress). \hypertarget{classInstructionQueue_a23fbbb46c9bdd183c06095cc0398fdc4}{
\index{InstructionQueue@{InstructionQueue}!dependGraph@{dependGraph}}
\index{dependGraph@{dependGraph}!InstructionQueue@{InstructionQueue}}
\subsubsection[{dependGraph}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DependencyGraph}$<${\bf DynInstPtr}$>$ {\bf dependGraph}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a23fbbb46c9bdd183c06095cc0398fdc4}
\hypertarget{classInstructionQueue_a1dd5fc6a847750f4294e41e801b47bf4}{
\index{InstructionQueue@{InstructionQueue}!fpAluAccesses@{fpAluAccesses}}
\index{fpAluAccesses@{fpAluAccesses}!InstructionQueue@{InstructionQueue}}
\subsubsection[{fpAluAccesses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fpAluAccesses}}}
\label{classInstructionQueue_a1dd5fc6a847750f4294e41e801b47bf4}
\hypertarget{classInstructionQueue_ac72607fe25b1d8aefd4ca2dda8533bb2}{
\index{InstructionQueue@{InstructionQueue}!fpInstQueueReads@{fpInstQueueReads}}
\index{fpInstQueueReads@{fpInstQueueReads}!InstructionQueue@{InstructionQueue}}
\subsubsection[{fpInstQueueReads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fpInstQueueReads}}}
\label{classInstructionQueue_ac72607fe25b1d8aefd4ca2dda8533bb2}
\hypertarget{classInstructionQueue_a666c1c2a3552ee13d2f8185434c9552b}{
\index{InstructionQueue@{InstructionQueue}!fpInstQueueWakeupQccesses@{fpInstQueueWakeupQccesses}}
\index{fpInstQueueWakeupQccesses@{fpInstQueueWakeupQccesses}!InstructionQueue@{InstructionQueue}}
\subsubsection[{fpInstQueueWakeupQccesses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fpInstQueueWakeupQccesses}}}
\label{classInstructionQueue_a666c1c2a3552ee13d2f8185434c9552b}
\hypertarget{classInstructionQueue_a462728858d9c7392da1a4e3695a10c3c}{
\index{InstructionQueue@{InstructionQueue}!fpInstQueueWrites@{fpInstQueueWrites}}
\index{fpInstQueueWrites@{fpInstQueueWrites}!InstructionQueue@{InstructionQueue}}
\subsubsection[{fpInstQueueWrites}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fpInstQueueWrites}}}
\label{classInstructionQueue_a462728858d9c7392da1a4e3695a10c3c}
\hypertarget{classInstructionQueue_ac2281ff630f82397bda33269f4ee8796}{
\index{InstructionQueue@{InstructionQueue}!freeEntries@{freeEntries}}
\index{freeEntries@{freeEntries}!InstructionQueue@{InstructionQueue}}
\subsubsection[{freeEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf freeEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_ac2281ff630f82397bda33269f4ee8796}
Number of free IQ entries left. \hypertarget{classInstructionQueue_a0055a92bd94eda21c2641d46ff013dac}{
\index{InstructionQueue@{InstructionQueue}!fromCommit@{fromCommit}}
\index{fromCommit@{fromCommit}!InstructionQueue@{InstructionQueue}}
\subsubsection[{fromCommit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf fromCommit}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a0055a92bd94eda21c2641d46ff013dac}
\hyperlink{classWire}{Wire} to read information from timebuffer. \hypertarget{classInstructionQueue_a54dbf1e1683507aefb83115910feb26b}{
\index{InstructionQueue@{InstructionQueue}!fuBusy@{fuBusy}}
\index{fuBusy@{fuBusy}!InstructionQueue@{InstructionQueue}}
\subsubsection[{fuBusy}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf fuBusy}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a54dbf1e1683507aefb83115910feb26b}
Number of times the FU was busy. \hypertarget{classInstructionQueue_ab1ecb3744ca63dcec2b9b7d80c319c69}{
\index{InstructionQueue@{InstructionQueue}!fuBusyRate@{fuBusyRate}}
\index{fuBusyRate@{fuBusyRate}!InstructionQueue@{InstructionQueue}}
\subsubsection[{fuBusyRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf fuBusyRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_ab1ecb3744ca63dcec2b9b7d80c319c69}
Number of times the FU was busy per instruction issued. \hypertarget{classInstructionQueue_a480782fc1cfd21fd9748b26f2a08b97a}{
\index{InstructionQueue@{InstructionQueue}!fuPool@{fuPool}}
\index{fuPool@{fuPool}!InstructionQueue@{InstructionQueue}}
\subsubsection[{fuPool}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FUPool}$\ast$ {\bf fuPool}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a480782fc1cfd21fd9748b26f2a08b97a}
Function unit pool. \hypertarget{classInstructionQueue_a4e9ef25d8913b270d432be4bbfe4965c}{
\index{InstructionQueue@{InstructionQueue}!iewStage@{iewStage}}
\index{iewStage@{iewStage}!InstructionQueue@{InstructionQueue}}
\subsubsection[{iewStage}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IEW}$\ast$ {\bf iewStage}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a4e9ef25d8913b270d432be4bbfe4965c}
Pointer to IEW stage. \hypertarget{classInstructionQueue_a7f2828a4f877a4a4d4b85a6788536b82}{
\index{InstructionQueue@{InstructionQueue}!instList@{instList}}
\index{instList@{instList}!InstructionQueue@{InstructionQueue}}
\subsubsection[{instList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf instList}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a7f2828a4f877a4a4d4b85a6788536b82}
List of all the instructions in the IQ (some of which may be issued). \hypertarget{classInstructionQueue_a494cb455333d9f34ee4a3ab8ca5e50fd}{
\index{InstructionQueue@{InstructionQueue}!instsToExecute@{instsToExecute}}
\index{instsToExecute@{instsToExecute}!InstructionQueue@{InstructionQueue}}
\subsubsection[{instsToExecute}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf instsToExecute}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a494cb455333d9f34ee4a3ab8ca5e50fd}
List of instructions that are ready to be executed. \hypertarget{classInstructionQueue_aec28ae6ca74e00e9b5eb0bd8bb9e1176}{
\index{InstructionQueue@{InstructionQueue}!intAluAccesses@{intAluAccesses}}
\index{intAluAccesses@{intAluAccesses}!InstructionQueue@{InstructionQueue}}
\subsubsection[{intAluAccesses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf intAluAccesses}}}
\label{classInstructionQueue_aec28ae6ca74e00e9b5eb0bd8bb9e1176}
\hypertarget{classInstructionQueue_a80520cf10aa5e634d9e3fb6cdc0aef2f}{
\index{InstructionQueue@{InstructionQueue}!intInstQueueReads@{intInstQueueReads}}
\index{intInstQueueReads@{intInstQueueReads}!InstructionQueue@{InstructionQueue}}
\subsubsection[{intInstQueueReads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf intInstQueueReads}}}
\label{classInstructionQueue_a80520cf10aa5e634d9e3fb6cdc0aef2f}
\hypertarget{classInstructionQueue_afd00a0a956c7aeab072e57a3927ee148}{
\index{InstructionQueue@{InstructionQueue}!intInstQueueWakeupAccesses@{intInstQueueWakeupAccesses}}
\index{intInstQueueWakeupAccesses@{intInstQueueWakeupAccesses}!InstructionQueue@{InstructionQueue}}
\subsubsection[{intInstQueueWakeupAccesses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf intInstQueueWakeupAccesses}}}
\label{classInstructionQueue_afd00a0a956c7aeab072e57a3927ee148}
\hypertarget{classInstructionQueue_a095bbdf62a50bf39e824e7187cde5191}{
\index{InstructionQueue@{InstructionQueue}!intInstQueueWrites@{intInstQueueWrites}}
\index{intInstQueueWrites@{intInstQueueWrites}!InstructionQueue@{InstructionQueue}}
\subsubsection[{intInstQueueWrites}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf intInstQueueWrites}}}
\label{classInstructionQueue_a095bbdf62a50bf39e824e7187cde5191}
\hypertarget{classInstructionQueue_a928f22a2c6ce592adc40e5242c9d6572}{
\index{InstructionQueue@{InstructionQueue}!iqBranchInstsIssued@{iqBranchInstsIssued}}
\index{iqBranchInstsIssued@{iqBranchInstsIssued}!InstructionQueue@{InstructionQueue}}
\subsubsection[{iqBranchInstsIssued}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqBranchInstsIssued}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a928f22a2c6ce592adc40e5242c9d6572}
Stat for number of branch instructions issued. \hypertarget{classInstructionQueue_aa9f2fa124c9f0b4b22461b6717449d9a}{
\index{InstructionQueue@{InstructionQueue}!iqFloatInstsIssued@{iqFloatInstsIssued}}
\index{iqFloatInstsIssued@{iqFloatInstsIssued}!InstructionQueue@{InstructionQueue}}
\subsubsection[{iqFloatInstsIssued}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqFloatInstsIssued}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_aa9f2fa124c9f0b4b22461b6717449d9a}
Stat for number of floating point instructions issued. \hypertarget{classInstructionQueue_a435e1ce10c3a7f54a60941e583adeb09}{
\index{InstructionQueue@{InstructionQueue}!iqInstsAdded@{iqInstsAdded}}
\index{iqInstsAdded@{iqInstsAdded}!InstructionQueue@{InstructionQueue}}
\subsubsection[{iqInstsAdded}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqInstsAdded}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a435e1ce10c3a7f54a60941e583adeb09}
Stat for number of instructions added. \hypertarget{classInstructionQueue_accc6261a817718dbb727c65f310df357}{
\index{InstructionQueue@{InstructionQueue}!iqInstsIssued@{iqInstsIssued}}
\index{iqInstsIssued@{iqInstsIssued}!InstructionQueue@{InstructionQueue}}
\subsubsection[{iqInstsIssued}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqInstsIssued}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_accc6261a817718dbb727c65f310df357}
\hypertarget{classInstructionQueue_a735f2023e70e53b7889a3a316bd3d57f}{
\index{InstructionQueue@{InstructionQueue}!iqIntInstsIssued@{iqIntInstsIssued}}
\index{iqIntInstsIssued@{iqIntInstsIssued}!InstructionQueue@{InstructionQueue}}
\subsubsection[{iqIntInstsIssued}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqIntInstsIssued}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a735f2023e70e53b7889a3a316bd3d57f}
Stat for number of integer instructions issued. \hypertarget{classInstructionQueue_a5e7d55d3f07e86e389ca3a715766e108}{
\index{InstructionQueue@{InstructionQueue}!iqMemInstsIssued@{iqMemInstsIssued}}
\index{iqMemInstsIssued@{iqMemInstsIssued}!InstructionQueue@{InstructionQueue}}
\subsubsection[{iqMemInstsIssued}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqMemInstsIssued}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a5e7d55d3f07e86e389ca3a715766e108}
Stat for number of memory instructions issued. \hypertarget{classInstructionQueue_ad234890bc414fffe7ed71840c51be5cb}{
\index{InstructionQueue@{InstructionQueue}!iqMiscInstsIssued@{iqMiscInstsIssued}}
\index{iqMiscInstsIssued@{iqMiscInstsIssued}!InstructionQueue@{InstructionQueue}}
\subsubsection[{iqMiscInstsIssued}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqMiscInstsIssued}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_ad234890bc414fffe7ed71840c51be5cb}
Stat for number of miscellaneous instructions issued. \hypertarget{classInstructionQueue_adf890a08fae50ea8249171b07c40adac}{
\index{InstructionQueue@{InstructionQueue}!iqNonSpecInstsAdded@{iqNonSpecInstsAdded}}
\index{iqNonSpecInstsAdded@{iqNonSpecInstsAdded}!InstructionQueue@{InstructionQueue}}
\subsubsection[{iqNonSpecInstsAdded}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqNonSpecInstsAdded}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_adf890a08fae50ea8249171b07c40adac}
Stat for number of non-\/speculative instructions added. \hypertarget{classInstructionQueue_a558c2854c6103193667179fa6ac0ac20}{
\index{InstructionQueue@{InstructionQueue}!iqPolicy@{iqPolicy}}
\index{iqPolicy@{iqPolicy}!InstructionQueue@{InstructionQueue}}
\subsubsection[{iqPolicy}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IQPolicy} {\bf iqPolicy}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a558c2854c6103193667179fa6ac0ac20}
IQ sharing policy for SMT. \hypertarget{classInstructionQueue_a8312e8984bcfab5a77de40e1738103db}{
\index{InstructionQueue@{InstructionQueue}!iqSquashedInstsExamined@{iqSquashedInstsExamined}}
\index{iqSquashedInstsExamined@{iqSquashedInstsExamined}!InstructionQueue@{InstructionQueue}}
\subsubsection[{iqSquashedInstsExamined}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqSquashedInstsExamined}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a8312e8984bcfab5a77de40e1738103db}
Stat for number of squashed instructions examined when squashing. \hypertarget{classInstructionQueue_ac91799c895e5aff3af0afdbd7691a163}{
\index{InstructionQueue@{InstructionQueue}!iqSquashedInstsIssued@{iqSquashedInstsIssued}}
\index{iqSquashedInstsIssued@{iqSquashedInstsIssued}!InstructionQueue@{InstructionQueue}}
\subsubsection[{iqSquashedInstsIssued}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqSquashedInstsIssued}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_ac91799c895e5aff3af0afdbd7691a163}
Stat for number of squashed instructions that were ready to issue. \hypertarget{classInstructionQueue_a6c0b47431b6e84536fd9bb61624d6d97}{
\index{InstructionQueue@{InstructionQueue}!iqSquashedNonSpecRemoved@{iqSquashedNonSpecRemoved}}
\index{iqSquashedNonSpecRemoved@{iqSquashedNonSpecRemoved}!InstructionQueue@{InstructionQueue}}
\subsubsection[{iqSquashedNonSpecRemoved}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqSquashedNonSpecRemoved}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a6c0b47431b6e84536fd9bb61624d6d97}
Stat for number of non-\/speculative instructions removed due to a squash. \hypertarget{classInstructionQueue_a4398b6005b81008bd163bbba78dfd929}{
\index{InstructionQueue@{InstructionQueue}!iqSquashedOperandsExamined@{iqSquashedOperandsExamined}}
\index{iqSquashedOperandsExamined@{iqSquashedOperandsExamined}!InstructionQueue@{InstructionQueue}}
\subsubsection[{iqSquashedOperandsExamined}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqSquashedOperandsExamined}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a4398b6005b81008bd163bbba78dfd929}
Stat for number of squashed instruction operands examined when squashing. \hypertarget{classInstructionQueue_a6a9ed0564894e83d4c3c5784f667c5e0}{
\index{InstructionQueue@{InstructionQueue}!issueRate@{issueRate}}
\index{issueRate@{issueRate}!InstructionQueue@{InstructionQueue}}
\subsubsection[{issueRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf issueRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a6a9ed0564894e83d4c3c5784f667c5e0}
Number of instructions issued per cycle. \hypertarget{classInstructionQueue_af5c55240e63d9a13358eede4eb5352f1}{
\index{InstructionQueue@{InstructionQueue}!issueToExecuteQueue@{issueToExecuteQueue}}
\index{issueToExecuteQueue@{issueToExecuteQueue}!InstructionQueue@{InstructionQueue}}
\subsubsection[{issueToExecuteQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf IssueStruct}$>$$\ast$ {\bf issueToExecuteQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_af5c55240e63d9a13358eede4eb5352f1}
The queue to the execute stage. Issued instructions will be written into it. \hypertarget{classInstructionQueue_afd5860c9cc9c225411df38dd3dc89b87}{
\index{InstructionQueue@{InstructionQueue}!listOrder@{listOrder}}
\index{listOrder@{listOrder}!InstructionQueue@{InstructionQueue}}
\subsubsection[{listOrder}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf ListOrderEntry}$>$ {\bf listOrder}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_afd5860c9cc9c225411df38dd3dc89b87}
List that contains the age order of the oldest instruction of each ready queue. Used to select the oldest instruction available among op classes. \begin{Desc}
\item[\hyperlink{todo__todo000031}{TODO}]: Might be better to just move these entries around instead of creating new ones every time the position changes due to an instruction issuing. Not sure \hyperlink{classstd_1_1list}{std::list} supports this. \end{Desc}
\hypertarget{classInstructionQueue_a51e5f9f0cb40d61e95b1518f1be90b73}{
\index{InstructionQueue@{InstructionQueue}!maxEntries@{maxEntries}}
\index{maxEntries@{maxEntries}!InstructionQueue@{InstructionQueue}}
\subsubsection[{maxEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf maxEntries}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a51e5f9f0cb40d61e95b1518f1be90b73}
Max IQ Entries Per Thread \hypertarget{classInstructionQueue_a8cb80ccbf6ed6c1029c6d9ebeaa40f6e}{
\index{InstructionQueue@{InstructionQueue}!memDepUnit@{memDepUnit}}
\index{memDepUnit@{memDepUnit}!InstructionQueue@{InstructionQueue}}
\subsubsection[{memDepUnit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemDepUnit} {\bf memDepUnit}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a8cb80ccbf6ed6c1029c6d9ebeaa40f6e}
The memory dependence unit, which tracks/predicts memory dependences between instructions. \hypertarget{classInstructionQueue_ac0ba4d07026aaf6386c001a68d059cbf}{
\index{InstructionQueue@{InstructionQueue}!nonSpecInsts@{nonSpecInsts}}
\index{nonSpecInsts@{nonSpecInsts}!InstructionQueue@{InstructionQueue}}
\subsubsection[{nonSpecInsts}]{\setlength{\rightskip}{0pt plus 5cm}std::map$<${\bf InstSeqNum}, {\bf DynInstPtr}$>$ {\bf nonSpecInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_ac0ba4d07026aaf6386c001a68d059cbf}
List of non-\/speculative instructions that will be scheduled once the IQ gets a signal from commit. While it's redundant to have the key be a part of the value (the sequence number is stored inside of DynInst), when these instructions are woken up only the sequence number will be available. Thus it is most efficient to be able to search by the sequence number alone. \hypertarget{classInstructionQueue_a325de474a9f6652329339d9fc2ea09c0}{
\index{InstructionQueue@{InstructionQueue}!numEntries@{numEntries}}
\index{numEntries@{numEntries}!InstructionQueue@{InstructionQueue}}
\subsubsection[{numEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf numEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a325de474a9f6652329339d9fc2ea09c0}
The number of entries in the instruction queue. \hypertarget{classInstructionQueue_a90810f5beb7dff46f4b45f96620474b6}{
\index{InstructionQueue@{InstructionQueue}!numIssuedDist@{numIssuedDist}}
\index{numIssuedDist@{numIssuedDist}!InstructionQueue@{InstructionQueue}}
\subsubsection[{numIssuedDist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Distribution} {\bf numIssuedDist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a90810f5beb7dff46f4b45f96620474b6}
Distribution of number of instructions in the queue. \begin{Desc}
\item[\hyperlink{todo__todo000033}{TODO}]: Need to create struct to track the entry time for each instruction. \end{Desc}
Distribution of the number of instructions issued. \hypertarget{classInstructionQueue_a0d2a78a8e887f06150904000b2beb6cd}{
\index{InstructionQueue@{InstructionQueue}!numPhysRegs@{numPhysRegs}}
\index{numPhysRegs@{numPhysRegs}!InstructionQueue@{InstructionQueue}}
\subsubsection[{numPhysRegs}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf numPhysRegs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a0d2a78a8e887f06150904000b2beb6cd}
The number of physical registers in the CPU. \hypertarget{classInstructionQueue_a88377f855dbf5adeeecb06b5bb821d35}{
\index{InstructionQueue@{InstructionQueue}!numThreads@{numThreads}}
\index{numThreads@{numThreads}!InstructionQueue@{InstructionQueue}}
\subsubsection[{numThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} {\bf numThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a88377f855dbf5adeeecb06b5bb821d35}
Number of Total Threads \hypertarget{classInstructionQueue_abd5388bcfcc78ba7299f0178672b4ac2}{
\index{InstructionQueue@{InstructionQueue}!queueOnList@{queueOnList}}
\index{queueOnList@{queueOnList}!InstructionQueue@{InstructionQueue}}
\subsubsection[{queueOnList}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf queueOnList}\mbox{[}{\bf Num\_\-OpClasses}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_abd5388bcfcc78ba7299f0178672b4ac2}
Tracks if each ready queue is on the age order list. \hypertarget{classInstructionQueue_a84f7fc18dadb9ea3ef6ed7dd9f375c46}{
\index{InstructionQueue@{InstructionQueue}!readyInsts@{readyInsts}}
\index{readyInsts@{readyInsts}!InstructionQueue@{InstructionQueue}}
\subsubsection[{readyInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ReadyInstQueue} {\bf readyInsts}\mbox{[}{\bf Num\_\-OpClasses}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a84f7fc18dadb9ea3ef6ed7dd9f375c46}
List of ready instructions, per op class. They are separated by op class to allow for easy mapping to FUs. \hypertarget{classInstructionQueue_ac6c2d86489eaee465f91586553c3593f}{
\index{InstructionQueue@{InstructionQueue}!readyIt@{readyIt}}
\index{readyIt@{readyIt}!InstructionQueue@{InstructionQueue}}
\subsubsection[{readyIt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ListOrderIt} {\bf readyIt}\mbox{[}{\bf Num\_\-OpClasses}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_ac6c2d86489eaee465f91586553c3593f}
Iterators of each ready queue. Points to their spot in the age order list. \hypertarget{classInstructionQueue_a61aeb86b87d1e105337b5a8973ce61f3}{
\index{InstructionQueue@{InstructionQueue}!regScoreboard@{regScoreboard}}
\index{regScoreboard@{regScoreboard}!InstructionQueue@{InstructionQueue}}
\subsubsection[{regScoreboard}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<$bool$>$ {\bf regScoreboard}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a61aeb86b87d1e105337b5a8973ce61f3}
A cache of the recently woken registers. It is 1 if the register has been woken up recently, and 0 if the register has been added to the dependency graph and has not yet received its value. It is basically a secondary scoreboard, and should pretty much mirror the scoreboard that exists in the rename map. \hypertarget{classInstructionQueue_a97d5a7e4630ad1d017909f7504b9ec32}{
\index{InstructionQueue@{InstructionQueue}!squashedSeqNum@{squashedSeqNum}}
\index{squashedSeqNum@{squashedSeqNum}!InstructionQueue@{InstructionQueue}}
\subsubsection[{squashedSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf squashedSeqNum}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a97d5a7e4630ad1d017909f7504b9ec32}
The sequence number of the squashed instruction. \hypertarget{classInstructionQueue_a92266bfdbc9a6de5005fc3f1654e0b3e}{
\index{InstructionQueue@{InstructionQueue}!statFuBusy@{statFuBusy}}
\index{statFuBusy@{statFuBusy}!InstructionQueue@{InstructionQueue}}
\subsubsection[{statFuBusy}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf statFuBusy}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a92266bfdbc9a6de5005fc3f1654e0b3e}
Distribution of the cycles it takes to issue an instruction. \begin{Desc}
\item[\hyperlink{todo__todo000034}{TODO}]: Need to create struct to track the ready time for each instruction. \end{Desc}
Number of times an instruction could not be issued because a FU was busy. \hypertarget{classInstructionQueue_abb8998de49604769ec252fbd0ac1ed2b}{
\index{InstructionQueue@{InstructionQueue}!statIssuedInstType@{statIssuedInstType}}
\index{statIssuedInstType@{statIssuedInstType}!InstructionQueue@{InstructionQueue}}
\subsubsection[{statIssuedInstType}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector2d} {\bf statIssuedInstType}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_abb8998de49604769ec252fbd0ac1ed2b}
Stat for total number issued for each instruction type. \hypertarget{classInstructionQueue_a83f9ee976e732665aeb08dbc19acfd45}{
\index{InstructionQueue@{InstructionQueue}!timeBuffer@{timeBuffer}}
\index{timeBuffer@{timeBuffer}!InstructionQueue@{InstructionQueue}}
\subsubsection[{timeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$$\ast$ {\bf timeBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_a83f9ee976e732665aeb08dbc19acfd45}
The backwards time buffer. \hypertarget{classInstructionQueue_ab3c3a8cd00248d9cd6acad330da902a7}{
\index{InstructionQueue@{InstructionQueue}!totalWidth@{totalWidth}}
\index{totalWidth@{totalWidth}!InstructionQueue@{InstructionQueue}}
\subsubsection[{totalWidth}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf totalWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstructionQueue_ab3c3a8cd00248d9cd6acad330da902a7}
The total number of instructions that can be issued in one cycle. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/o3/\hyperlink{o3_2inst__queue_8hh}{inst\_\-queue.hh}\item 
cpu/o3/\hyperlink{o3_2inst__queue__impl_8hh}{inst\_\-queue\_\-impl.hh}\end{DoxyCompactItemize}
