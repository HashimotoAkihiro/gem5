\hypertarget{structTimeBufStruct_1_1commitComm}{
\section{構造体 commitComm}
\label{structTimeBufStruct_1_1commitComm}\index{TimeBufStruct::commitComm@{TimeBufStruct::commitComm}}
}


{\ttfamily \#include $<$comm.hh$>$}\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
TheISA::PCState \hyperlink{structTimeBufStruct_1_1commitComm_ad3585c83b0eac985107aa5a86e43e1b4}{pc}
\item 
\hyperlink{structTimeBufStruct_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{structTimeBufStruct_1_1commitComm_a30072968ccd286f8f546aa26eb2c5c33}{mispredictInst}
\item 
\hyperlink{structTimeBufStruct_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{structTimeBufStruct_1_1commitComm_afa5fc700e0c019c77c06164b8aa9367d}{squashInst}
\begin{DoxyCompactList}\small\item\em Instruction that caused the a non-\/mispredict squash. \item\end{DoxyCompactList}\item 
\hyperlink{structTimeBufStruct_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{structTimeBufStruct_1_1commitComm_a45b8aff83b2d4696abea3583a02ea31e}{uncachedLoad}
\begin{DoxyCompactList}\small\item\em Hack for now to send back an uncached access to the IEW stage. \item\end{DoxyCompactList}\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{structTimeBufStruct_1_1commitComm_a2109aaf648ce5c87f53ac688b4e51db1}{nonSpecSeqNum}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{structTimeBufStruct_1_1commitComm_a45920c1d79a22b1320274c5f53504654}{doneSeqNum}
\item 
unsigned \hyperlink{structTimeBufStruct_1_1commitComm_a87a4648b43fbb12beaf408d684fff6dc}{freeROBEntries}
\begin{DoxyCompactList}\small\item\em Tell Rename how many free entries it has in the \hyperlink{classROB}{ROB}. \item\end{DoxyCompactList}\item 
bool \hyperlink{structTimeBufStruct_1_1commitComm_a61b7f55a2e0399c2eee9f78204b37d8c}{squash}
\item 
bool \hyperlink{structTimeBufStruct_1_1commitComm_a897a27c9efdd9f32d97a34a08a529cfc}{robSquashing}
\item 
bool \hyperlink{structTimeBufStruct_1_1commitComm_a7947bc5bf9b7709eeb835c213e0d6c36}{usedROB}
\begin{DoxyCompactList}\small\item\em Rename should re-\/read number of free rob entries. \item\end{DoxyCompactList}\item 
bool \hyperlink{structTimeBufStruct_1_1commitComm_a145243270bb508720c507e02ad0a8e6a}{emptyROB}
\begin{DoxyCompactList}\small\item\em Notify Rename that the \hyperlink{classROB}{ROB} is empty. \item\end{DoxyCompactList}\item 
bool \hyperlink{structTimeBufStruct_1_1commitComm_abea53a673db4866c41444561cbc6dac0}{branchTaken}
\begin{DoxyCompactList}\small\item\em Was the branch taken or not. \item\end{DoxyCompactList}\item 
bool \hyperlink{structTimeBufStruct_1_1commitComm_a310de3efc6b60f47de5792d2b00d0840}{interruptPending}
\begin{DoxyCompactList}\small\item\em If an interrupt is pending and fetch should stall. \item\end{DoxyCompactList}\item 
bool \hyperlink{structTimeBufStruct_1_1commitComm_a695ef2b5d408e6ca8b4a3019293ec106}{clearInterrupt}
\begin{DoxyCompactList}\small\item\em If the interrupt ended up being cleared before being handled. \item\end{DoxyCompactList}\item 
bool \hyperlink{structTimeBufStruct_1_1commitComm_aab896ca9f63476ee85c0cac2bbff0811}{uncached}
\begin{DoxyCompactList}\small\item\em Hack for now to send back an uncached access to the IEW stage. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{template$<$class Impl$>$ struct TimeBufStruct$<$ Impl $>$::commitComm}



\subsection{変数}
\hypertarget{structTimeBufStruct_1_1commitComm_abea53a673db4866c41444561cbc6dac0}{
\index{TimeBufStruct::commitComm@{TimeBufStruct::commitComm}!branchTaken@{branchTaken}}
\index{branchTaken@{branchTaken}!TimeBufStruct::commitComm@{TimeBufStruct::commitComm}}
\subsubsection[{branchTaken}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf branchTaken}}}
\label{structTimeBufStruct_1_1commitComm_abea53a673db4866c41444561cbc6dac0}


Was the branch taken or not. \hypertarget{structTimeBufStruct_1_1commitComm_a695ef2b5d408e6ca8b4a3019293ec106}{
\index{TimeBufStruct::commitComm@{TimeBufStruct::commitComm}!clearInterrupt@{clearInterrupt}}
\index{clearInterrupt@{clearInterrupt}!TimeBufStruct::commitComm@{TimeBufStruct::commitComm}}
\subsubsection[{clearInterrupt}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf clearInterrupt}}}
\label{structTimeBufStruct_1_1commitComm_a695ef2b5d408e6ca8b4a3019293ec106}


If the interrupt ended up being cleared before being handled. \hypertarget{structTimeBufStruct_1_1commitComm_a45920c1d79a22b1320274c5f53504654}{
\index{TimeBufStruct::commitComm@{TimeBufStruct::commitComm}!doneSeqNum@{doneSeqNum}}
\index{doneSeqNum@{doneSeqNum}!TimeBufStruct::commitComm@{TimeBufStruct::commitComm}}
\subsubsection[{doneSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf doneSeqNum}}}
\label{structTimeBufStruct_1_1commitComm_a45920c1d79a22b1320274c5f53504654}
Represents the instruction that has either been retired or squashed. Similar to having a single bus that broadcasts the retired or squashed sequence number. \hypertarget{structTimeBufStruct_1_1commitComm_a145243270bb508720c507e02ad0a8e6a}{
\index{TimeBufStruct::commitComm@{TimeBufStruct::commitComm}!emptyROB@{emptyROB}}
\index{emptyROB@{emptyROB}!TimeBufStruct::commitComm@{TimeBufStruct::commitComm}}
\subsubsection[{emptyROB}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf emptyROB}}}
\label{structTimeBufStruct_1_1commitComm_a145243270bb508720c507e02ad0a8e6a}


Notify Rename that the \hyperlink{classROB}{ROB} is empty. \hypertarget{structTimeBufStruct_1_1commitComm_a87a4648b43fbb12beaf408d684fff6dc}{
\index{TimeBufStruct::commitComm@{TimeBufStruct::commitComm}!freeROBEntries@{freeROBEntries}}
\index{freeROBEntries@{freeROBEntries}!TimeBufStruct::commitComm@{TimeBufStruct::commitComm}}
\subsubsection[{freeROBEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf freeROBEntries}}}
\label{structTimeBufStruct_1_1commitComm_a87a4648b43fbb12beaf408d684fff6dc}


Tell Rename how many free entries it has in the \hyperlink{classROB}{ROB}. \hypertarget{structTimeBufStruct_1_1commitComm_a310de3efc6b60f47de5792d2b00d0840}{
\index{TimeBufStruct::commitComm@{TimeBufStruct::commitComm}!interruptPending@{interruptPending}}
\index{interruptPending@{interruptPending}!TimeBufStruct::commitComm@{TimeBufStruct::commitComm}}
\subsubsection[{interruptPending}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf interruptPending}}}
\label{structTimeBufStruct_1_1commitComm_a310de3efc6b60f47de5792d2b00d0840}


If an interrupt is pending and fetch should stall. \hypertarget{structTimeBufStruct_1_1commitComm_a30072968ccd286f8f546aa26eb2c5c33}{
\index{TimeBufStruct::commitComm@{TimeBufStruct::commitComm}!mispredictInst@{mispredictInst}}
\index{mispredictInst@{mispredictInst}!TimeBufStruct::commitComm@{TimeBufStruct::commitComm}}
\subsubsection[{mispredictInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf mispredictInst}}}
\label{structTimeBufStruct_1_1commitComm_a30072968ccd286f8f546aa26eb2c5c33}
Provide fetch the instruction that mispredicted, if this pointer is not-\/null a misprediction occured \hypertarget{structTimeBufStruct_1_1commitComm_a2109aaf648ce5c87f53ac688b4e51db1}{
\index{TimeBufStruct::commitComm@{TimeBufStruct::commitComm}!nonSpecSeqNum@{nonSpecSeqNum}}
\index{nonSpecSeqNum@{nonSpecSeqNum}!TimeBufStruct::commitComm@{TimeBufStruct::commitComm}}
\subsubsection[{nonSpecSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf nonSpecSeqNum}}}
\label{structTimeBufStruct_1_1commitComm_a2109aaf648ce5c87f53ac688b4e51db1}
Communication specifically to the IQ to tell the IQ that it can schedule a non-\/speculative instruction. \hypertarget{structTimeBufStruct_1_1commitComm_ad3585c83b0eac985107aa5a86e43e1b4}{
\index{TimeBufStruct::commitComm@{TimeBufStruct::commitComm}!pc@{pc}}
\index{pc@{pc}!TimeBufStruct::commitComm@{TimeBufStruct::commitComm}}
\subsubsection[{pc}]{\setlength{\rightskip}{0pt plus 5cm}TheISA::PCState {\bf pc}}}
\label{structTimeBufStruct_1_1commitComm_ad3585c83b0eac985107aa5a86e43e1b4}
The pc of the next instruction to execute. This is the next instruction for a branch mispredict, but the same instruction for order violation and the like \hypertarget{structTimeBufStruct_1_1commitComm_a897a27c9efdd9f32d97a34a08a529cfc}{
\index{TimeBufStruct::commitComm@{TimeBufStruct::commitComm}!robSquashing@{robSquashing}}
\index{robSquashing@{robSquashing}!TimeBufStruct::commitComm@{TimeBufStruct::commitComm}}
\subsubsection[{robSquashing}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf robSquashing}}}
\label{structTimeBufStruct_1_1commitComm_a897a27c9efdd9f32d97a34a08a529cfc}
\hypertarget{structTimeBufStruct_1_1commitComm_a61b7f55a2e0399c2eee9f78204b37d8c}{
\index{TimeBufStruct::commitComm@{TimeBufStruct::commitComm}!squash@{squash}}
\index{squash@{squash}!TimeBufStruct::commitComm@{TimeBufStruct::commitComm}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf squash}}}
\label{structTimeBufStruct_1_1commitComm_a61b7f55a2e0399c2eee9f78204b37d8c}
\hypertarget{structTimeBufStruct_1_1commitComm_afa5fc700e0c019c77c06164b8aa9367d}{
\index{TimeBufStruct::commitComm@{TimeBufStruct::commitComm}!squashInst@{squashInst}}
\index{squashInst@{squashInst}!TimeBufStruct::commitComm@{TimeBufStruct::commitComm}}
\subsubsection[{squashInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf squashInst}}}
\label{structTimeBufStruct_1_1commitComm_afa5fc700e0c019c77c06164b8aa9367d}


Instruction that caused the a non-\/mispredict squash. \hypertarget{structTimeBufStruct_1_1commitComm_aab896ca9f63476ee85c0cac2bbff0811}{
\index{TimeBufStruct::commitComm@{TimeBufStruct::commitComm}!uncached@{uncached}}
\index{uncached@{uncached}!TimeBufStruct::commitComm@{TimeBufStruct::commitComm}}
\subsubsection[{uncached}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf uncached}}}
\label{structTimeBufStruct_1_1commitComm_aab896ca9f63476ee85c0cac2bbff0811}


Hack for now to send back an uncached access to the IEW stage. \hypertarget{structTimeBufStruct_1_1commitComm_a45b8aff83b2d4696abea3583a02ea31e}{
\index{TimeBufStruct::commitComm@{TimeBufStruct::commitComm}!uncachedLoad@{uncachedLoad}}
\index{uncachedLoad@{uncachedLoad}!TimeBufStruct::commitComm@{TimeBufStruct::commitComm}}
\subsubsection[{uncachedLoad}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf uncachedLoad}}}
\label{structTimeBufStruct_1_1commitComm_a45b8aff83b2d4696abea3583a02ea31e}


Hack for now to send back an uncached access to the IEW stage. \hypertarget{structTimeBufStruct_1_1commitComm_a7947bc5bf9b7709eeb835c213e0d6c36}{
\index{TimeBufStruct::commitComm@{TimeBufStruct::commitComm}!usedROB@{usedROB}}
\index{usedROB@{usedROB}!TimeBufStruct::commitComm@{TimeBufStruct::commitComm}}
\subsubsection[{usedROB}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf usedROB}}}
\label{structTimeBufStruct_1_1commitComm_a7947bc5bf9b7709eeb835c213e0d6c36}


Rename should re-\/read number of free rob entries. 

この構造体の説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/o3/\hyperlink{o3_2comm_8hh}{comm.hh}\end{DoxyCompactItemize}
