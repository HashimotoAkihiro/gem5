\hypertarget{classNetworkInterface__d}{
\section{クラス NetworkInterface\_\-d}
\label{classNetworkInterface__d}\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}}
}


{\ttfamily \#include $<$NetworkInterface\_\-d.hh$>$}NetworkInterface\_\-dに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4cm]{classNetworkInterface__d}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef GarnetNetworkInterface\_\-dParams \hyperlink{classNetworkInterface__d_ab6c40ec3be0502fd09ea61583eecc26a}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classNetworkInterface__d_a1f5049c73c6c9b05ac58d9ec59df057c}{NetworkInterface\_\-d} (const \hyperlink{classNetworkInterface__d_ab6c40ec3be0502fd09ea61583eecc26a}{Params} $\ast$p)
\item 
\hyperlink{classNetworkInterface__d_aba1b0a4c820667bc51ff0bd8b9e599bd}{$\sim$NetworkInterface\_\-d} ()
\item 
void \hyperlink{classNetworkInterface__d_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
void \hyperlink{classNetworkInterface__d_adbdbe0df8be4baa68257ae0a5badfd2e}{addInPort} (\hyperlink{classNetworkLink__d}{NetworkLink\_\-d} $\ast$in\_\-link, \hyperlink{classCreditLink__d}{CreditLink\_\-d} $\ast$credit\_\-link)
\item 
void \hyperlink{classNetworkInterface__d_a8bb6c70f88a9da2c9adab0d72a2e6e3f}{addOutPort} (\hyperlink{classNetworkLink__d}{NetworkLink\_\-d} $\ast$out\_\-link, \hyperlink{classCreditLink__d}{CreditLink\_\-d} $\ast$credit\_\-link)
\item 
void \hyperlink{classNetworkInterface__d_ae674290a26ecbd622c5160e38e8a4fe9}{wakeup} ()
\item 
void \hyperlink{classNetworkInterface__d_abb78e667f7f184a1989354ba522d32a9}{addNode} (\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMessageBuffer}{MessageBuffer} $\ast$ $>$ \&inNode, \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMessageBuffer}{MessageBuffer} $\ast$ $>$ \&outNode)
\item 
void \hyperlink{classNetworkInterface__d_ac55fe386a101fbae38c716067c9966a0}{print} (std::ostream \&out) const 
\item 
int \hyperlink{classNetworkInterface__d_ae73de77352867d272505f41222809e17}{get\_\-vnet} (int vc)
\item 
void \hyperlink{classNetworkInterface__d_adb63d5adcd3ba8d6d0c6336d7b716243}{init\_\-net\_\-ptr} (\hyperlink{classGarnetNetwork__d}{GarnetNetwork\_\-d} $\ast$net\_\-ptr)
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classNetworkInterface__d_aba9037f662122b5f2e85647d35670e5c}{functionalWrite} (\hyperlink{classPacket}{Packet} $\ast$)
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classNetworkInterface__d_a12a9945591ab6cd27b4cf0df84786cf8}{flitisizeMessage} (\hyperlink{classRefCountingPtr}{MsgPtr} msg\_\-ptr, int vnet)
\item 
int \hyperlink{classNetworkInterface__d_ab27658cc3136de94d2d08c78ac499aff}{calculateVC} (int vnet)
\item 
void \hyperlink{classNetworkInterface__d_a0b5091af4210988da9a7eeb44e5691e4}{scheduleOutputLink} ()
\item 
void \hyperlink{classNetworkInterface__d_af954e8e2150e2ce2e1b87081bbd9c678}{checkReschedule} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classGarnetNetwork__d}{GarnetNetwork\_\-d} $\ast$ \hyperlink{classNetworkInterface__d_a9534b7843922554d9c1b429e50a11e6d}{m\_\-net\_\-ptr}
\item 
int \hyperlink{classNetworkInterface__d_af4cc96182e80059859793d92cb3dd769}{m\_\-virtual\_\-networks}
\item 
int \hyperlink{classNetworkInterface__d_a2e1a9213321dfa0386cdedaf6fc22996}{m\_\-num\_\-vcs}
\item 
int \hyperlink{classNetworkInterface__d_a2d66b8cad5144408ed492eeff4d37c2f}{m\_\-vc\_\-per\_\-vnet}
\item 
\hyperlink{TypeDefines_8hh_a83c14b4ae37e80071f6b3506a6c46151}{NodeID} \hyperlink{classNetworkInterface__d_aaed4e1d0badfbd8b21e43869898ed184}{m\_\-id}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classOutVcState__d}{OutVcState\_\-d} $\ast$ $>$ \hyperlink{classNetworkInterface__d_aadaadc7a32b7bf67a8c953eb3e9a13c7}{m\_\-out\_\-vc\_\-state}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ int $>$ \hyperlink{classNetworkInterface__d_a4e31a4f4aad8462157e797cdb1e3e00c}{m\_\-vc\_\-allocator}
\item 
int \hyperlink{classNetworkInterface__d_a4e50d04fbae98d5e7eac566ab56f4227}{m\_\-vc\_\-round\_\-robin}
\item 
\hyperlink{classflitBuffer__d}{flitBuffer\_\-d} $\ast$ \hyperlink{classNetworkInterface__d_aaf13976ec6e83029468aab14cef7c812}{outSrcQueue}
\item 
\hyperlink{classflitBuffer__d}{flitBuffer\_\-d} $\ast$ \hyperlink{classNetworkInterface__d_ab387c0eedaf4adb3f05beb4433c2e033}{creditQueue}
\item 
\hyperlink{classNetworkLink__d}{NetworkLink\_\-d} $\ast$ \hyperlink{classNetworkInterface__d_a32c70d9a8a19282b4cc9094e6b94c96f}{inNetLink}
\item 
\hyperlink{classNetworkLink__d}{NetworkLink\_\-d} $\ast$ \hyperlink{classNetworkInterface__d_ac6b53ee37454b0be010596ffff96d307}{outNetLink}
\item 
\hyperlink{classCreditLink__d}{CreditLink\_\-d} $\ast$ \hyperlink{classNetworkInterface__d_a8439db4fc7b7271dfca6bf98b13036a4}{m\_\-credit\_\-link}
\item 
\hyperlink{classCreditLink__d}{CreditLink\_\-d} $\ast$ \hyperlink{classNetworkInterface__d_a586e9d61fe6b52622d7589a756560ec6}{m\_\-ni\_\-credit\_\-link}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classflitBuffer__d}{flitBuffer\_\-d} $\ast$ $>$ \hyperlink{classNetworkInterface__d_a364f3f4326fe3dc25234b260deecf659}{m\_\-ni\_\-buffers}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classTime}{Time} $>$ \hyperlink{classNetworkInterface__d_a6dec698d5050bbeb09ab70f9ea7df75c}{m\_\-ni\_\-enqueue\_\-time}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMessageBuffer}{MessageBuffer} $\ast$ $>$ \hyperlink{classNetworkInterface__d_a933eda70266204185e6bc2a65f0add98}{inNode\_\-ptr}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMessageBuffer}{MessageBuffer} $\ast$ $>$ \hyperlink{classNetworkInterface__d_aff22e632df88a83fbcbac281efec0dcc}{outNode\_\-ptr}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classNetworkInterface__d_ab6c40ec3be0502fd09ea61583eecc26a}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!Params@{Params}}
\index{Params@{Params}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef GarnetNetworkInterface\_\-dParams {\bf Params}}}
\label{classNetworkInterface__d_ab6c40ec3be0502fd09ea61583eecc26a}


\hyperlink{classSimObject_a0f0761d2db586a23bb2a2880b8f387bb}{SimObject}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classNetworkInterface__d_a1f5049c73c6c9b05ac58d9ec59df057c}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!NetworkInterface\_\-d@{NetworkInterface\_\-d}}
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{NetworkInterface\_\-d}]{\setlength{\rightskip}{0pt plus 5cm}{\bf NetworkInterface\_\-d} (const {\bf Params} $\ast$ {\em p})}}
\label{classNetworkInterface__d_a1f5049c73c6c9b05ac58d9ec59df057c}



\begin{DoxyCode}
46     : ClockedObject(p), Consumer(this)
47 {
48     m_id = p->id;
49     m_virtual_networks  = p->virt_nets;
50     m_vc_per_vnet = p->vcs_per_vnet;
51     m_num_vcs = m_vc_per_vnet*m_virtual_networks;
52 
53     m_vc_round_robin = 0;
54     m_ni_buffers.resize(m_num_vcs);
55     m_ni_enqueue_time.resize(m_num_vcs);
56     inNode_ptr.resize(m_virtual_networks);
57     outNode_ptr.resize(m_virtual_networks);
58     creditQueue = new flitBuffer_d();
59 
60     // instantiating the NI flit buffers
61     for (int i = 0; i < m_num_vcs; i++) {
62         m_ni_buffers[i] = new flitBuffer_d();
63         m_ni_enqueue_time[i] = INFINITE_;
64     }
65 
66     m_vc_allocator.resize(m_virtual_networks); // 1 allocator per vnet
67     for (int i = 0; i < m_virtual_networks; i++) {
68         m_vc_allocator[i] = 0;
69     }
70 }
\end{DoxyCode}
\hypertarget{classNetworkInterface__d_aba1b0a4c820667bc51ff0bd8b9e599bd}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!$\sim$NetworkInterface\_\-d@{$\sim$NetworkInterface\_\-d}}
\index{$\sim$NetworkInterface\_\-d@{$\sim$NetworkInterface\_\-d}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{$\sim$NetworkInterface\_\-d}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf NetworkInterface\_\-d} ()}}
\label{classNetworkInterface__d_aba1b0a4c820667bc51ff0bd8b9e599bd}



\begin{DoxyCode}
81 {
82     deletePointers(m_out_vc_state);
83     deletePointers(m_ni_buffers);
84     delete creditQueue;
85     delete outSrcQueue;
86 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classNetworkInterface__d_adbdbe0df8be4baa68257ae0a5badfd2e}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!addInPort@{addInPort}}
\index{addInPort@{addInPort}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{addInPort}]{\setlength{\rightskip}{0pt plus 5cm}void addInPort ({\bf NetworkLink\_\-d} $\ast$ {\em in\_\-link}, \/  {\bf CreditLink\_\-d} $\ast$ {\em credit\_\-link})}}
\label{classNetworkInterface__d_adbdbe0df8be4baa68257ae0a5badfd2e}



\begin{DoxyCode}
91 {
92     inNetLink = in_link;
93     in_link->setLinkConsumer(this);
94     m_ni_credit_link = credit_link;
95     credit_link->setSourceQueue(creditQueue);
96 }
\end{DoxyCode}
\hypertarget{classNetworkInterface__d_abb78e667f7f184a1989354ba522d32a9}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!addNode@{addNode}}
\index{addNode@{addNode}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{addNode}]{\setlength{\rightskip}{0pt plus 5cm}void addNode ({\bf std::vector}$<$ {\bf MessageBuffer} $\ast$ $>$ \& {\em inNode}, \/  {\bf std::vector}$<$ {\bf MessageBuffer} $\ast$ $>$ \& {\em outNode})}}
\label{classNetworkInterface__d_abb78e667f7f184a1989354ba522d32a9}



\begin{DoxyCode}
113 {
114     assert(in.size() == m_virtual_networks);
115     inNode_ptr = in;
116     outNode_ptr = out;
117     for (int j = 0; j < m_virtual_networks; j++) {
118 
119         // the protocol injects messages into the NI
120         inNode_ptr[j]->setConsumer(this);
121         inNode_ptr[j]->setReceiver(this);
122         outNode_ptr[j]->setSender(this);
123     }
124 }
\end{DoxyCode}
\hypertarget{classNetworkInterface__d_a8bb6c70f88a9da2c9adab0d72a2e6e3f}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!addOutPort@{addOutPort}}
\index{addOutPort@{addOutPort}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{addOutPort}]{\setlength{\rightskip}{0pt plus 5cm}void addOutPort ({\bf NetworkLink\_\-d} $\ast$ {\em out\_\-link}, \/  {\bf CreditLink\_\-d} $\ast$ {\em credit\_\-link})}}
\label{classNetworkInterface__d_a8bb6c70f88a9da2c9adab0d72a2e6e3f}



\begin{DoxyCode}
101 {
102     m_credit_link = credit_link;
103     credit_link->setLinkConsumer(this);
104 
105     outNetLink = out_link;
106     outSrcQueue = new flitBuffer_d();
107     out_link->setSourceQueue(outSrcQueue);
108 }
\end{DoxyCode}
\hypertarget{classNetworkInterface__d_ab27658cc3136de94d2d08c78ac499aff}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!calculateVC@{calculateVC}}
\index{calculateVC@{calculateVC}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{calculateVC}]{\setlength{\rightskip}{0pt plus 5cm}int calculateVC (int {\em vnet})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_ab27658cc3136de94d2d08c78ac499aff}



\begin{DoxyCode}
192 {
193         for (int i = 0; i < m_vc_per_vnet; i++) {
194                 int delta = m_vc_allocator[vnet];
195                 m_vc_allocator[vnet]++;
196                 if(m_vc_allocator[vnet] == m_vc_per_vnet)
197                         m_vc_allocator[vnet] = 0;
198 
199                 if (m_out_vc_state[(vnet*m_vc_per_vnet) + delta]->isInState(
200                     IDLE_, curCycle())) {
201                         return ((vnet*m_vc_per_vnet) + delta);
202                 }
203         }
204         return -1;
205 }
\end{DoxyCode}
\hypertarget{classNetworkInterface__d_af954e8e2150e2ce2e1b87081bbd9c678}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!checkReschedule@{checkReschedule}}
\index{checkReschedule@{checkReschedule}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{checkReschedule}]{\setlength{\rightskip}{0pt plus 5cm}void checkReschedule ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_af954e8e2150e2ce2e1b87081bbd9c678}



\begin{DoxyCode}
353 {
354     for (int vnet = 0; vnet < m_virtual_networks; vnet++) {
355         if (inNode_ptr[vnet]->isReady()) { // Is there a message waiting
356             scheduleEvent(Cycles(1));
357             return;
358         }
359     }
360     for (int vc = 0; vc < m_num_vcs; vc++) {
361         if (m_ni_buffers[vc]->isReady(curCycle() + Cycles(1))) {
362             scheduleEvent(Cycles(1));
363             return;
364         }
365     }
366 }
\end{DoxyCode}
\hypertarget{classNetworkInterface__d_a12a9945591ab6cd27b4cf0df84786cf8}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!flitisizeMessage@{flitisizeMessage}}
\index{flitisizeMessage@{flitisizeMessage}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{flitisizeMessage}]{\setlength{\rightskip}{0pt plus 5cm}bool flitisizeMessage ({\bf MsgPtr} {\em msg\_\-ptr}, \/  int {\em vnet})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_a12a9945591ab6cd27b4cf0df84786cf8}



\begin{DoxyCode}
128 {
129     NetworkMessage *net_msg_ptr = safe_cast<NetworkMessage *>(msg_ptr.get());
130     NetDest net_msg_dest = net_msg_ptr->getInternalDestination();
131 
132     // gets all the destinations associated with this message.
133     vector<NodeID> dest_nodes = net_msg_dest.getAllDest();
134 
135     // Number of flits is dependent on the link bandwidth available.
136     // This is expressed in terms of bytes/cycle or the flit size
137     int num_flits = (int) ceil((double) m_net_ptr->MessageSizeType_to_int(
138         net_msg_ptr->getMessageSize())/m_net_ptr->getNiFlitSize());
139 
140     // loop to convert all multicast messages into unicast messages
141     for (int ctr = 0; ctr < dest_nodes.size(); ctr++) {
142 
143         // this will return a free output virtual channel
144         int vc = calculateVC(vnet);
145 
146         if (vc == -1) {
147             return false ;
148         }
149         MsgPtr new_msg_ptr = msg_ptr->clone();
150         NodeID destID = dest_nodes[ctr];
151 
152         NetworkMessage *new_net_msg_ptr =
153             safe_cast<NetworkMessage *>(new_msg_ptr.get());
154         if (dest_nodes.size() > 1) {
155             NetDest personal_dest;
156             for (int m = 0; m < (int) MachineType_NUM; m++) {
157                 if ((destID >= MachineType_base_number((MachineType) m)) &&
158                     destID < MachineType_base_number((MachineType) (m+1))) {
159                     // calculating the NetDest associated with this destID
160                     personal_dest.clear();
161                     personal_dest.add((MachineID) {(MachineType) m, (destID -
162                         MachineType_base_number((MachineType) m))});
163                     new_net_msg_ptr->getInternalDestination() = personal_dest;
164                     break;
165                 }
166             }
167             net_msg_dest.removeNetDest(personal_dest);
168             // removing the destination from the original message to reflect
169             // that a message with this particular destination has been
170             // flitisized and an output vc is acquired
171             net_msg_ptr->getInternalDestination().removeNetDest(personal_dest);
172         }
173 
174         for (int i = 0; i < num_flits; i++) {
175             m_net_ptr->increment_injected_flits(vnet);
176             flit_d *fl = new flit_d(i, vc, vnet, num_flits, new_msg_ptr,
177                 curCycle());
178 
179             fl->set_delay(curCycle() - ticksToCycles(msg_ptr->getTime()));
180             m_ni_buffers[vc]->insert(fl);
181         }
182 
183         m_ni_enqueue_time[vc] = curCycle();
184         m_out_vc_state[vc]->setState(ACTIVE_, curCycle());
185     }
186     return true ;
187 }
\end{DoxyCode}
\hypertarget{classNetworkInterface__d_aba9037f662122b5f2e85647d35670e5c}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!functionalWrite@{functionalWrite}}
\index{functionalWrite@{functionalWrite}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{functionalWrite}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} functionalWrite ({\bf Packet} $\ast$ {\em pkt})}}
\label{classNetworkInterface__d_aba9037f662122b5f2e85647d35670e5c}



\begin{DoxyCode}
376 {
377     uint32_t num_functional_writes = 0;
378     for (unsigned int i  = 0; i < m_num_vcs; ++i) {
379         num_functional_writes += m_ni_buffers[i]->functionalWrite(pkt);
380     }
381 
382     num_functional_writes += outSrcQueue->functionalWrite(pkt);
383     return num_functional_writes;
384 }
\end{DoxyCode}
\hypertarget{classNetworkInterface__d_ae73de77352867d272505f41222809e17}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!get\_\-vnet@{get\_\-vnet}}
\index{get\_\-vnet@{get\_\-vnet}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{get\_\-vnet}]{\setlength{\rightskip}{0pt plus 5cm}int get\_\-vnet (int {\em vc})}}
\label{classNetworkInterface__d_ae73de77352867d272505f41222809e17}



\begin{DoxyCode}
342 {
343     for (int i = 0; i < m_virtual_networks; i++) {
344         if (vc >= (i*m_vc_per_vnet) && vc < ((i+1)*m_vc_per_vnet)) {
345             return i;
346         }
347     }
348     fatal("Could not determine vc");
349 }
\end{DoxyCode}
\hypertarget{classNetworkInterface__d_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!init@{init}}
\index{init@{init}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classNetworkInterface__d_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classNetworkInterface__d_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{SimObject}を再定義しています。


\begin{DoxyCode}
74 {
75     for (int i = 0; i < m_num_vcs; i++) {
76         m_out_vc_state.push_back(new OutVcState_d(i, m_net_ptr));
77     }
78 }
\end{DoxyCode}
\hypertarget{classNetworkInterface__d_adb63d5adcd3ba8d6d0c6336d7b716243}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!init\_\-net\_\-ptr@{init\_\-net\_\-ptr}}
\index{init\_\-net\_\-ptr@{init\_\-net\_\-ptr}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{init\_\-net\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}void init\_\-net\_\-ptr ({\bf GarnetNetwork\_\-d} $\ast$ {\em net\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classNetworkInterface__d_adb63d5adcd3ba8d6d0c6336d7b716243}



\begin{DoxyCode}
67 { m_net_ptr = net_ptr; }
\end{DoxyCode}
\hypertarget{classNetworkInterface__d_ac55fe386a101fbae38c716067c9966a0}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!print@{print}}
\index{print@{print}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}void print (std::ostream \& {\em out}) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classNetworkInterface__d_ac55fe386a101fbae38c716067c9966a0}


\hyperlink{classConsumer_a3ea5f7af5db62cc24f4e40df9ea5c971}{Consumer}を実装しています。


\begin{DoxyCode}
370 {
371     out << "[Network Interface]";
372 }
\end{DoxyCode}
\hypertarget{classNetworkInterface__d_a0b5091af4210988da9a7eeb44e5691e4}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!scheduleOutputLink@{scheduleOutputLink}}
\index{scheduleOutputLink@{scheduleOutputLink}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{scheduleOutputLink}]{\setlength{\rightskip}{0pt plus 5cm}void scheduleOutputLink ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_a0b5091af4210988da9a7eeb44e5691e4}
This function looks at the NI buffers if some buffer has flits which are ready to traverse the link in the next cycle, and the downstream output vc associated with this \hyperlink{classflit}{flit} has buffers left, the link is scheduled for the next cycle 


\begin{DoxyCode}
289 {
290     int vc = m_vc_round_robin;
291     m_vc_round_robin++;
292     if (m_vc_round_robin == m_num_vcs)
293         m_vc_round_robin = 0;
294 
295     for (int i = 0; i < m_num_vcs; i++) {
296         vc++;
297         if (vc == m_num_vcs)
298             vc = 0;
299 
300         // model buffer backpressure
301         if (m_ni_buffers[vc]->isReady(curCycle()) &&
302             m_out_vc_state[vc]->has_credits()) {
303 
304             bool is_candidate_vc = true;
305             int t_vnet = get_vnet(vc);
306             int vc_base = t_vnet * m_vc_per_vnet;
307 
308             if (m_net_ptr->isVNetOrdered(t_vnet)) {
309                 for (int vc_offset = 0; vc_offset < m_vc_per_vnet;
310                      vc_offset++) {
311                     int t_vc = vc_base + vc_offset;
312                     if (m_ni_buffers[t_vc]->isReady(curCycle())) {
313                         if (m_ni_enqueue_time[t_vc] < m_ni_enqueue_time[vc]) {
314                             is_candidate_vc = false;
315                             break;
316                         }
317                     }
318                 }
319             }
320             if (!is_candidate_vc)
321                 continue;
322 
323             m_out_vc_state[vc]->decrement_credit();
324             // Just removing the flit
325             flit_d *t_flit = m_ni_buffers[vc]->getTopFlit();
326             t_flit->set_time(curCycle() + Cycles(1));
327             outSrcQueue->insert(t_flit);
328             // schedule the out link
329             outNetLink->scheduleEventAbsolute(clockEdge(Cycles(1)));
330 
331             if (t_flit->get_type() == TAIL_ ||
332                t_flit->get_type() == HEAD_TAIL_) {
333                 m_ni_enqueue_time[vc] = INFINITE_;
334             }
335             return;
336         }
337     }
338 }
\end{DoxyCode}
\hypertarget{classNetworkInterface__d_ae674290a26ecbd622c5160e38e8a4fe9}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!wakeup@{wakeup}}
\index{wakeup@{wakeup}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{wakeup}]{\setlength{\rightskip}{0pt plus 5cm}void wakeup ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classNetworkInterface__d_ae674290a26ecbd622c5160e38e8a4fe9}


\hyperlink{classConsumer_a623e3e7d1b1c725d70009f7b01a421b9}{Consumer}を実装しています。


\begin{DoxyCode}
219 {
220     DPRINTF(RubyNetwork, "m_id: %d woke up at time: %lld", m_id, curCycle());
221 
222     MsgPtr msg_ptr;
223 
224     // Checking for messages coming from the protocol
225     // can pick up a message/cycle for each virtual net
226     for (int vnet = 0; vnet < m_virtual_networks; vnet++) {
227         while (inNode_ptr[vnet]->isReady()) { // Is there a message waiting
228             msg_ptr = inNode_ptr[vnet]->peekMsgPtr();
229             if (flitisizeMessage(msg_ptr, vnet)) {
230                 inNode_ptr[vnet]->dequeue();
231             } else {
232                 break;
233             }
234         }
235     }
236 
237     scheduleOutputLink();
238     checkReschedule();
239 
240     /*********** Picking messages destined for this NI **********/
241 
242     if (inNetLink->isReady(curCycle())) {
243         flit_d *t_flit = inNetLink->consumeLink();
244         bool free_signal = false;
245         if (t_flit->get_type() == TAIL_ || t_flit->get_type() == HEAD_TAIL_) {
246             free_signal = true;
247 
248             outNode_ptr[t_flit->get_vnet()]->enqueue(
249                 t_flit->get_msg_ptr(), Cycles(1));
250         }
251         // Simply send a credit back since we are not buffering
252         // this flit in the NI
253         flit_d *credit_flit = new flit_d(t_flit->get_vc(), free_signal,
254                                          curCycle());
255         creditQueue->insert(credit_flit);
256         m_ni_credit_link->
257             scheduleEventAbsolute(clockEdge(Cycles(1)));
258 
259         int vnet = t_flit->get_vnet();
260         m_net_ptr->increment_received_flits(vnet);
261         Cycles network_delay = curCycle() - t_flit->get_enqueue_time();
262         Cycles queueing_delay = t_flit->get_delay();
263 
264         m_net_ptr->increment_network_latency(network_delay, vnet);
265         m_net_ptr->increment_queueing_latency(queueing_delay, vnet);
266         delete t_flit;
267     }
268 
269     /****************** Checking for credit link *******/
270 
271     if (m_credit_link->isReady(curCycle())) {
272         flit_d *t_flit = m_credit_link->consumeLink();
273         m_out_vc_state[t_flit->get_vc()]->increment_credit();
274         if (t_flit->is_free_signal()) {
275             m_out_vc_state[t_flit->get_vc()]->setState(IDLE_, curCycle());
276         }
277         delete t_flit;
278     }
279 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classNetworkInterface__d_ab387c0eedaf4adb3f05beb4433c2e033}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!creditQueue@{creditQueue}}
\index{creditQueue@{creditQueue}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{creditQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf flitBuffer\_\-d}$\ast$ {\bf creditQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_ab387c0eedaf4adb3f05beb4433c2e033}
\hypertarget{classNetworkInterface__d_a32c70d9a8a19282b4cc9094e6b94c96f}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!inNetLink@{inNetLink}}
\index{inNetLink@{inNetLink}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{inNetLink}]{\setlength{\rightskip}{0pt plus 5cm}{\bf NetworkLink\_\-d}$\ast$ {\bf inNetLink}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_a32c70d9a8a19282b4cc9094e6b94c96f}
\hypertarget{classNetworkInterface__d_a933eda70266204185e6bc2a65f0add98}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!inNode\_\-ptr@{inNode\_\-ptr}}
\index{inNode\_\-ptr@{inNode\_\-ptr}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{inNode\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf MessageBuffer} $\ast$$>$ {\bf inNode\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_a933eda70266204185e6bc2a65f0add98}
\hypertarget{classNetworkInterface__d_a8439db4fc7b7271dfca6bf98b13036a4}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!m\_\-credit\_\-link@{m\_\-credit\_\-link}}
\index{m\_\-credit\_\-link@{m\_\-credit\_\-link}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{m\_\-credit\_\-link}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CreditLink\_\-d}$\ast$ {\bf m\_\-credit\_\-link}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_a8439db4fc7b7271dfca6bf98b13036a4}
\hypertarget{classNetworkInterface__d_aaed4e1d0badfbd8b21e43869898ed184}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!m\_\-id@{m\_\-id}}
\index{m\_\-id@{m\_\-id}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{m\_\-id}]{\setlength{\rightskip}{0pt plus 5cm}{\bf NodeID} {\bf m\_\-id}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_aaed4e1d0badfbd8b21e43869898ed184}
\hypertarget{classNetworkInterface__d_a9534b7843922554d9c1b429e50a11e6d}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!m\_\-net\_\-ptr@{m\_\-net\_\-ptr}}
\index{m\_\-net\_\-ptr@{m\_\-net\_\-ptr}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{m\_\-net\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf GarnetNetwork\_\-d}$\ast$ {\bf m\_\-net\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_a9534b7843922554d9c1b429e50a11e6d}
\hypertarget{classNetworkInterface__d_a364f3f4326fe3dc25234b260deecf659}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!m\_\-ni\_\-buffers@{m\_\-ni\_\-buffers}}
\index{m\_\-ni\_\-buffers@{m\_\-ni\_\-buffers}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{m\_\-ni\_\-buffers}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf flitBuffer\_\-d} $\ast$$>$ {\bf m\_\-ni\_\-buffers}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_a364f3f4326fe3dc25234b260deecf659}
\hypertarget{classNetworkInterface__d_a586e9d61fe6b52622d7589a756560ec6}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!m\_\-ni\_\-credit\_\-link@{m\_\-ni\_\-credit\_\-link}}
\index{m\_\-ni\_\-credit\_\-link@{m\_\-ni\_\-credit\_\-link}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{m\_\-ni\_\-credit\_\-link}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CreditLink\_\-d}$\ast$ {\bf m\_\-ni\_\-credit\_\-link}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_a586e9d61fe6b52622d7589a756560ec6}
\hypertarget{classNetworkInterface__d_a6dec698d5050bbeb09ab70f9ea7df75c}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!m\_\-ni\_\-enqueue\_\-time@{m\_\-ni\_\-enqueue\_\-time}}
\index{m\_\-ni\_\-enqueue\_\-time@{m\_\-ni\_\-enqueue\_\-time}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{m\_\-ni\_\-enqueue\_\-time}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf Time}$>$ {\bf m\_\-ni\_\-enqueue\_\-time}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_a6dec698d5050bbeb09ab70f9ea7df75c}
\hypertarget{classNetworkInterface__d_a2e1a9213321dfa0386cdedaf6fc22996}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!m\_\-num\_\-vcs@{m\_\-num\_\-vcs}}
\index{m\_\-num\_\-vcs@{m\_\-num\_\-vcs}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{m\_\-num\_\-vcs}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-num\_\-vcs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_a2e1a9213321dfa0386cdedaf6fc22996}
\hypertarget{classNetworkInterface__d_aadaadc7a32b7bf67a8c953eb3e9a13c7}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!m\_\-out\_\-vc\_\-state@{m\_\-out\_\-vc\_\-state}}
\index{m\_\-out\_\-vc\_\-state@{m\_\-out\_\-vc\_\-state}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{m\_\-out\_\-vc\_\-state}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf OutVcState\_\-d} $\ast$$>$ {\bf m\_\-out\_\-vc\_\-state}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_aadaadc7a32b7bf67a8c953eb3e9a13c7}
\hypertarget{classNetworkInterface__d_a4e31a4f4aad8462157e797cdb1e3e00c}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!m\_\-vc\_\-allocator@{m\_\-vc\_\-allocator}}
\index{m\_\-vc\_\-allocator@{m\_\-vc\_\-allocator}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{m\_\-vc\_\-allocator}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<$int$>$ {\bf m\_\-vc\_\-allocator}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_a4e31a4f4aad8462157e797cdb1e3e00c}
\hypertarget{classNetworkInterface__d_a2d66b8cad5144408ed492eeff4d37c2f}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!m\_\-vc\_\-per\_\-vnet@{m\_\-vc\_\-per\_\-vnet}}
\index{m\_\-vc\_\-per\_\-vnet@{m\_\-vc\_\-per\_\-vnet}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{m\_\-vc\_\-per\_\-vnet}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-vc\_\-per\_\-vnet}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_a2d66b8cad5144408ed492eeff4d37c2f}
\hypertarget{classNetworkInterface__d_a4e50d04fbae98d5e7eac566ab56f4227}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!m\_\-vc\_\-round\_\-robin@{m\_\-vc\_\-round\_\-robin}}
\index{m\_\-vc\_\-round\_\-robin@{m\_\-vc\_\-round\_\-robin}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{m\_\-vc\_\-round\_\-robin}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-vc\_\-round\_\-robin}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_a4e50d04fbae98d5e7eac566ab56f4227}
\hypertarget{classNetworkInterface__d_af4cc96182e80059859793d92cb3dd769}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!m\_\-virtual\_\-networks@{m\_\-virtual\_\-networks}}
\index{m\_\-virtual\_\-networks@{m\_\-virtual\_\-networks}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{m\_\-virtual\_\-networks}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-virtual\_\-networks}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_af4cc96182e80059859793d92cb3dd769}
\hypertarget{classNetworkInterface__d_ac6b53ee37454b0be010596ffff96d307}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!outNetLink@{outNetLink}}
\index{outNetLink@{outNetLink}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{outNetLink}]{\setlength{\rightskip}{0pt plus 5cm}{\bf NetworkLink\_\-d}$\ast$ {\bf outNetLink}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_ac6b53ee37454b0be010596ffff96d307}
\hypertarget{classNetworkInterface__d_aff22e632df88a83fbcbac281efec0dcc}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!outNode\_\-ptr@{outNode\_\-ptr}}
\index{outNode\_\-ptr@{outNode\_\-ptr}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{outNode\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf MessageBuffer} $\ast$$>$ {\bf outNode\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_aff22e632df88a83fbcbac281efec0dcc}
\hypertarget{classNetworkInterface__d_aaf13976ec6e83029468aab14cef7c812}{
\index{NetworkInterface\_\-d@{NetworkInterface\_\-d}!outSrcQueue@{outSrcQueue}}
\index{outSrcQueue@{outSrcQueue}!NetworkInterface_d@{NetworkInterface\_\-d}}
\subsubsection[{outSrcQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf flitBuffer\_\-d}$\ast$ {\bf outSrcQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface__d_aaf13976ec6e83029468aab14cef7c812}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/ruby/network/garnet/fixed-\/pipeline/\hyperlink{NetworkInterface__d_8hh}{NetworkInterface\_\-d.hh}\item 
mem/ruby/network/garnet/fixed-\/pipeline/\hyperlink{NetworkInterface__d_8cc}{NetworkInterface\_\-d.cc}\end{DoxyCompactItemize}
