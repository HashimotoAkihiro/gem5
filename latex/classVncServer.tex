\hypertarget{classVncServer}{
\section{クラス VncServer}
\label{classVncServer}\index{VncServer@{VncServer}}
}


{\ttfamily \#include $<$vncserver.hh$>$}VncServerに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4cm]{classVncServer}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classVncServer_1_1DataEvent}{DataEvent}
\item 
struct \hyperlink{structVncServer_1_1FrameBufferRect}{FrameBufferRect}
\item 
struct \hyperlink{structVncServer_1_1FrameBufferUpdate}{FrameBufferUpdate}
\item 
class \hyperlink{classVncServer_1_1ListenEvent}{ListenEvent}
\item 
struct \hyperlink{structVncServer_1_1ServerCutText}{ServerCutText}
\item 
struct \hyperlink{structVncServer_1_1ServerInitMsg}{ServerInitMsg}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{group__VncConstants_ga98f897c5a38e76e2cc7fea4d87083a84}{ServerMessages} \{ \hyperlink{group__VncConstants_gga98f897c5a38e76e2cc7fea4d87083a84afb5f87db0a4610309f486463de5388b7}{ServerFrameBufferUpdate} =  0, 
\hyperlink{group__VncConstants_gga98f897c5a38e76e2cc7fea4d87083a84aba175e2ce5c7225c9945f1e133857c07}{ServerSetColorMapEntries} =  1, 
\hyperlink{group__VncConstants_gga98f897c5a38e76e2cc7fea4d87083a84a32aadc1d2674e65c0f598a2727945b8d}{ServerBell} =  2, 
\hyperlink{group__VncConstants_gga98f897c5a38e76e2cc7fea4d87083a84ad80502eb07cc53ade0e84460d0c39e7c}{ServerCutText} =  3
 \}
\item 
enum \hyperlink{group__VncConstants_ga0b9039f87c8a2980c4a6ab14b511760a}{EncodingTypes} \{ \hyperlink{group__VncConstants_gga0b9039f87c8a2980c4a6ab14b511760aa2929e8976a78e5a5e8829beae2a7e69e}{EncodingRaw} =  0, 
\hyperlink{group__VncConstants_gga0b9039f87c8a2980c4a6ab14b511760aac66141a54bb407b18d3ab26e779bc4a8}{EncodingCopyRect} =  1, 
\hyperlink{group__VncConstants_gga0b9039f87c8a2980c4a6ab14b511760aa2e2676a7c0aac5891c51c5d4325453f7}{EncodingHextile} =  5, 
\hyperlink{group__VncConstants_gga0b9039f87c8a2980c4a6ab14b511760aa81cbe670fb7e962f4721e74d55bc66e5}{EncodingDesktopSize} =  -\/223
 \}
\item 
enum \hyperlink{group__VncConstants_ga0aa77c5c19bd1f953c90f0cae8c61a9a}{MouseEvents} \{ \hyperlink{group__VncConstants_gga0aa77c5c19bd1f953c90f0cae8c61a9aa13ee718768549ed254378457536bfd63}{MouseLeftButton} =  0x1, 
\hyperlink{group__VncConstants_gga0aa77c5c19bd1f953c90f0cae8c61a9aa9722dcc9b50f713f587a1b046e108b27}{MouseRightButton} =  0x2, 
\hyperlink{group__VncConstants_gga0aa77c5c19bd1f953c90f0cae8c61a9aaa93c27c34acd42cdc9e28a8f668d87dd}{MouseMiddleButton} =  0x4
 \}
\item 
enum \hyperlink{group__VncConstants_gacdd867d72142510ce53521a63a062f9b}{ConnectionState} \{ \par
\hyperlink{group__VncConstants_ggacdd867d72142510ce53521a63a062f9ba79cc83bc90b4f683fb2495d4487662ea}{WaitForProtocolVersion}, 
\hyperlink{group__VncConstants_ggacdd867d72142510ce53521a63a062f9ba198ea2412a93ac253bf8e4406a8fb06c}{WaitForSecurityResponse}, 
\hyperlink{group__VncConstants_ggacdd867d72142510ce53521a63a062f9ba78e807adbaddb74b84dea34150fab20e}{WaitForClientInit}, 
\hyperlink{group__VncConstants_ggacdd867d72142510ce53521a63a062f9badd4438c090c589c90c368d163c4edbd9}{InitializationPhase}, 
\par
\hyperlink{group__VncConstants_ggacdd867d72142510ce53521a63a062f9ba6302b1455052baff1528e67e95db429a}{NormalPhase}
 \}
\item 
typedef VncServerParams \hyperlink{classVncServer_a9bc94e8c47d227e70719e2f0b14d23d8}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \hyperlink{group__VncConstants_ga36bab5b0163b272b816361d6214c3f14}{vncVersion} () const 
\item 
\hyperlink{classVncServer_a0438267d56345e85e9422a89bea5c886}{VncServer} (const \hyperlink{classVncServer_a9bc94e8c47d227e70719e2f0b14d23d8}{Params} $\ast$p)
\item 
\hyperlink{classVncServer_a13ae0e928ec930d77353cb1bd42e36a1}{$\sim$VncServer} ()
\item 
void \hyperlink{classVncServer_a92a590790db6444ca7a79eaf5fbcb0d9}{setDirty} ()
\item 
void \hyperlink{classVncServer_a9abef13e07371ccf4a89883649f1bcc5}{setFrameBufferParams} (\hyperlink{classVideoConvert_a46c8a310cf4c094f8c80e1cb8dc1f911}{VideoConvert::Mode} mode, uint16\_\-t width, uint16\_\-t height)
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structVncServer_1_1ServerInitMsg}{VncServer::ServerInitMsg} \hyperlink{group__VncConstants_ga2f0a8a1f1c40593e1e01ce4b8087d792}{M5\_\-ATTR\_\-PACKED}
\item 
struct \hyperlink{structVncServer_1_1FrameBufferUpdate}{VncServer::FrameBufferUpdate} \hyperlink{group__VncConstants_ga357314e013d6289c7d085fadd56a290c}{M5\_\-ATTR\_\-PACKED}
\item 
struct \hyperlink{structVncServer_1_1FrameBufferRect}{VncServer::FrameBufferRect} \hyperlink{group__VncConstants_gab34a91a8552f4b2f7e2806b835f39780}{M5\_\-ATTR\_\-PACKED}
\item 
struct \hyperlink{structVncServer_1_1ServerCutText}{VncServer::ServerCutText} \hyperlink{group__VncConstants_gac782a3823c0bb07395a234047394d59e}{M5\_\-ATTR\_\-PACKED}
\end{DoxyCompactItemize}
\subsection*{Static Public 変数}
\begin{DoxyCompactItemize}
\item 
static const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{group__VncConstants_ga0adb6517a8a2c8403f7aff85bad3dfa5}{AuthInvalid} = 0
\item 
static const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{group__VncConstants_gabc058a28bda6e015dbafe8bbfbddb821}{AuthNone} = 1
\item 
static const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{group__VncConstants_ga6d4127ee4f24603d9a0c7e3257b04ca3}{VncOK} = 0
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classVncServer_ac0c44c1417536740ffc2cf33117027cf}{listen} (int port)
\item 
void \hyperlink{classVncServer_aadb9f3b844fb4cf98288cd3c60a3af91}{accept} ()
\item 
void \hyperlink{classVncServer_a6617ba3e856d8b24979a2a44e5417172}{data} ()
\item 
void \hyperlink{classVncServer_ac295bade8aee589f6718dfa79edc2a34}{detach} ()
\item 
void \hyperlink{classVncServer_a3531045d065c2aa1aaf5a225e2337e80}{sendError} (const char $\ast$error\_\-msg)
\item 
size\_\-t \hyperlink{classVncServer_a9f8a094b410fa145da19663f83f241e3}{read} (uint8\_\-t $\ast$buf, size\_\-t len)
\item 
size\_\-t \hyperlink{classVncServer_ab265cdc9659b04aafe0b93e866024a6d}{read1} (uint8\_\-t $\ast$buf, size\_\-t len)
\item 
{\footnotesize template$<$typename T $>$ }\\size\_\-t \hyperlink{classVncServer_a09f96768306b6f498cf39d32962a853d}{read} (T $\ast$val)
\item 
size\_\-t \hyperlink{classVncServer_a215d71301eb6ae0ebffc5d2f8fe4a140}{write} (const uint8\_\-t $\ast$buf, size\_\-t len)
\item 
{\footnotesize template$<$typename T $>$ }\\size\_\-t \hyperlink{classVncServer_aefa1c03e3a1158303080d2702de2a11e}{write} (T $\ast$val)
\item 
size\_\-t \hyperlink{classVncServer_add50e5436017b9c2f1e0d11c9476bf1b}{write} (const char $\ast$str)
\item 
void \hyperlink{classVncServer_aee7430db7799cf4e0bac388671be878d}{checkProtocolVersion} ()
\item 
void \hyperlink{classVncServer_ad4122a39071b5fd462e19418a432ed31}{checkSecurity} ()
\item 
void \hyperlink{classVncServer_a0d7d773b4b3948da49ae2ecd00f985d5}{sendServerInit} ()
\item 
void \hyperlink{classVncServer_a6ad4e22608f77193eb9cddb1c8b20703}{sendError} (std::string error\_\-msg)
\item 
void \hyperlink{classVncServer_a12fdf8396c8fe33bb93e66d7491fb497}{sendFrameBufferUpdate} ()
\item 
void \hyperlink{classVncServer_ad52ea030be3bb8b536f8a7f87b709319}{setPixelFormat} ()
\item 
void \hyperlink{classVncServer_a840599118004b7df093bd78b6a21e56b}{setEncodings} ()
\item 
void \hyperlink{classVncServer_a83f5ce82a666e5b948e2a14b430633ce}{requestFbUpdate} ()
\item 
void \hyperlink{classVncServer_adce913e2d5283f60780d7becd1d3e44b}{recvKeyboardInput} ()
\item 
void \hyperlink{classVncServer_a95d4cde3a9b92bbac5871d8b475eedd3}{recvPointerInput} ()
\item 
void \hyperlink{classVncServer_a7ee4399f42b127e68135272ff77815c2}{recvCutText} ()
\item 
void \hyperlink{classVncServer_a046eae8a3566418d4f03a95de5d1af13}{sendFrameBufferResized} ()
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classVncServer_1_1ListenEvent}{ListenEvent} $\ast$ \hyperlink{classVncServer_ad7f258b1b869b6152bc5040c38b79d39}{listenEvent}
\item 
\hyperlink{classVncServer_1_1DataEvent}{DataEvent} $\ast$ \hyperlink{classVncServer_a7a8501aba170bc353fe057e372612b93}{dataEvent}
\item 
int \hyperlink{classVncServer_a7106e2abc437ad981830d14176d15f09}{number}
\item 
int \hyperlink{classVncServer_ab9f945d843e004fbbb155b7709051470}{dataFd}
\item 
\hyperlink{classListenSocket}{ListenSocket} \hyperlink{classVncServer_acf9ea448b26a541b4a197f1ca92f700b}{listener}
\item 
\hyperlink{group__VncConstants_gacdd867d72142510ce53521a63a062f9b}{ConnectionState} \hyperlink{classVncServer_ad0bc1d6a87b76d47489ca919f3ae51ca}{curState}
\item 
bool \hyperlink{classVncServer_ab2b958eb553dde858c8737b57614e87d}{sendUpdate}
\item 
\hyperlink{structVncInput_1_1PixelFormat}{PixelFormat} \hyperlink{classVncServer_a126e69cd1de897ecc9b84e858e4809c7}{pixelFormat}
\item 
bool \hyperlink{classVncServer_a1286ea1dbf0c332e14ccfc0267de405e}{supportsRawEnc}
\item 
bool \hyperlink{classVncServer_a68ae35695f8a6dcd68d9ff80dee28736}{supportsResizeEnc}
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classVncServer_a9465cdda0008b0e7b7f9ac919cd9cca6}{ListenEvent}
\item 
class \hyperlink{classVncServer_a8a93830b802d4fc8562fa54ead43b1f9}{DataEvent}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classVncServer_a9bc94e8c47d227e70719e2f0b14d23d8}{
\index{VncServer@{VncServer}!Params@{Params}}
\index{Params@{Params}!VncServer@{VncServer}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef VncServerParams {\bf Params}}}
\label{classVncServer_a9bc94e8c47d227e70719e2f0b14d23d8}


\hyperlink{classVncInput_a33249bc76b6a23eda274363d6f466b79}{VncInput}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classVncServer_a0438267d56345e85e9422a89bea5c886}{
\index{VncServer@{VncServer}!VncServer@{VncServer}}
\index{VncServer@{VncServer}!VncServer@{VncServer}}
\subsubsection[{VncServer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf VncServer} (const {\bf Params} $\ast$ {\em p})}}
\label{classVncServer_a0438267d56345e85e9422a89bea5c886}
\hyperlink{classVncServer}{VncServer} 


\begin{DoxyCode}
108     : VncInput(p), listenEvent(NULL), dataEvent(NULL), number(p->number),
109       dataFd(-1), sendUpdate(false)
110 {
111     if (p->port)
112         listen(p->port);
113 
114     curState = WaitForProtocolVersion;
115 
116     // currently we only support this one pixel format
117     // unpacked 32bit rgb (rgb888 + 8 bits of nothing/alpha)
118     // keep it around for telling the client and making
119     // sure the client cooperates
120     pixelFormat.bpp = 32;
121     pixelFormat.depth = 24;
122     pixelFormat.bigendian = 0;
123     pixelFormat.truecolor = 1;
124     pixelFormat.redmax = 0xff;
125     pixelFormat.greenmax = 0xff;
126     pixelFormat.bluemax = 0xff;
127     pixelFormat.redshift = 16;
128     pixelFormat.greenshift = 8;
129     pixelFormat.blueshift = 0;
130 
131     DPRINTF(VNC, "Vnc server created at port %d\n", p->port);
132 }
\end{DoxyCode}
\hypertarget{classVncServer_a13ae0e928ec930d77353cb1bd42e36a1}{
\index{VncServer@{VncServer}!$\sim$VncServer@{$\sim$VncServer}}
\index{$\sim$VncServer@{$\sim$VncServer}!VncServer@{VncServer}}
\subsubsection[{$\sim$VncServer}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf VncServer} ()}}
\label{classVncServer_a13ae0e928ec930d77353cb1bd42e36a1}



\begin{DoxyCode}
135 {
136     if (dataFd != -1)
137         ::close(dataFd);
138 
139     if (listenEvent)
140         delete listenEvent;
141 
142     if (dataEvent)
143         delete dataEvent;
144 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classVncServer_aadb9f3b844fb4cf98288cd3c60a3af91}{
\index{VncServer@{VncServer}!accept@{accept}}
\index{accept@{accept}!VncServer@{VncServer}}
\subsubsection[{accept}]{\setlength{\rightskip}{0pt plus 5cm}void accept ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_aadb9f3b844fb4cf98288cd3c60a3af91}



\begin{DoxyCode}
176 {
177     // As a consequence of being called from the PollQueue, we might
178     // have been called from a different thread. Migrate to "our"
179     // thread.
180     EventQueue::ScopedMigration migrate(eventQueue());
181 
182     if (!listener.islistening())
183         panic("%s: cannot accept a connection if not listening!", name());
184 
185     int fd = listener.accept(true);
186     if (dataFd != -1) {
187         char message[] = "vnc server already attached!\n";
188         atomic_write(fd, message, sizeof(message));
189         ::close(fd);
190         return;
191     }
192 
193     dataFd = fd;
194 
195     // Send our version number to the client
196     write((uint8_t*)vncVersion(), strlen(vncVersion()));
197 
198     // read the client response
199     dataEvent = new DataEvent(this, dataFd, POLLIN);
200     pollQueue.schedule(dataEvent);
201 
202     inform("VNC client attached\n");
203 }
\end{DoxyCode}
\hypertarget{classVncServer_aee7430db7799cf4e0bac388671be878d}{
\index{VncServer@{VncServer}!checkProtocolVersion@{checkProtocolVersion}}
\index{checkProtocolVersion@{checkProtocolVersion}!VncServer@{VncServer}}
\subsubsection[{checkProtocolVersion}]{\setlength{\rightskip}{0pt plus 5cm}void checkProtocolVersion ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_aee7430db7799cf4e0bac388671be878d}
\hyperlink{classCheck}{Check} the client's protocol verion for compatibility and send the security types we support 


\begin{DoxyCode}
369 {
370     assert(curState == WaitForProtocolVersion);
371 
372     size_t len M5_VAR_USED;
373     char version_string[13];
374 
375     // Null terminate the message so it's easier to work with
376     version_string[12] = 0;
377 
378     len = read((uint8_t*)version_string, 12);
379     assert(len == 12);
380 
381     uint32_t major, minor;
382 
383     // Figure out the major/minor numbers
384     if (sscanf(version_string, "RFB %03d.%03d\n", &major, &minor) != 2) {
385         warn(" Malformed protocol version %s\n", version_string);
386         sendError("Malformed protocol version\n");
387         detach();
388     }
389 
390     DPRINTF(VNC, "Client request protocol version %d.%d\n", major, minor);
391 
392     // If it's not 3.X we don't support it
393     if (major != 3 || minor < 2) {
394         warn("Unsupported VNC client version... disconnecting\n");
395         uint8_t err = AuthInvalid;
396         write(&err);
397         detach();
398     }
399     // Auth is different based on version number
400     if (minor < 7) {
401         uint32_t sec_type = htobe((uint32_t)AuthNone);
402         write(&sec_type);
403     } else {
404         uint8_t sec_cnt = 1;
405         uint8_t sec_type = htobe((uint8_t)AuthNone);
406         write(&sec_cnt);
407         write(&sec_type);
408     }
409 
410     // Wait for client to respond
411     curState = WaitForSecurityResponse;
412 }
\end{DoxyCode}
\hypertarget{classVncServer_ad4122a39071b5fd462e19418a432ed31}{
\index{VncServer@{VncServer}!checkSecurity@{checkSecurity}}
\index{checkSecurity@{checkSecurity}!VncServer@{VncServer}}
\subsubsection[{checkSecurity}]{\setlength{\rightskip}{0pt plus 5cm}void checkSecurity ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_ad4122a39071b5fd462e19418a432ed31}
\hyperlink{classCheck}{Check} that the security exchange was successful 


\begin{DoxyCode}
416 {
417     assert(curState == WaitForSecurityResponse);
418 
419     uint8_t security_type;
420     size_t len M5_VAR_USED = read(&security_type);
421 
422     assert(len == 1);
423 
424     if (security_type != AuthNone) {
425         warn("Unknown VNC security type\n");
426         sendError("Unknown security type\n");
427     }
428 
429     DPRINTF(VNC, "Sending security auth OK\n");
430 
431     uint32_t success = htobe(VncOK);
432     write(&success);
433     curState = WaitForClientInit;
434 }
\end{DoxyCode}
\hypertarget{classVncServer_a6617ba3e856d8b24979a2a44e5417172}{
\index{VncServer@{VncServer}!data@{data}}
\index{data@{data}!VncServer@{VncServer}}
\subsubsection[{data}]{\setlength{\rightskip}{0pt plus 5cm}void data ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_a6617ba3e856d8b24979a2a44e5417172}



\begin{DoxyCode}
208 {
209     // We have new data, see if we can handle it
210     size_t len;
211     DPRINTF(VNC, "Vnc client message recieved\n");
212 
213     switch (curState) {
214       case WaitForProtocolVersion:
215         checkProtocolVersion();
216         break;
217       case WaitForSecurityResponse:
218         checkSecurity();
219         break;
220       case WaitForClientInit:
221         // Don't care about shared, just need to read it out of the socket
222         uint8_t shared;
223         len = read(&shared);
224         assert(len == 1);
225 
226         // Send our idea of the frame buffer
227         sendServerInit();
228 
229         break;
230       case NormalPhase:
231         uint8_t message_type;
232         len = read(&message_type);
233         if (!len) {
234             detach();
235             return;
236         }
237         assert(len == 1);
238 
239         switch (message_type) {
240           case ClientSetPixelFormat:
241             setPixelFormat();
242             break;
243           case ClientSetEncodings:
244             setEncodings();
245             break;
246           case ClientFrameBufferUpdate:
247             requestFbUpdate();
248             break;
249           case ClientKeyEvent:
250             recvKeyboardInput();
251             break;
252           case ClientPointerEvent:
253             recvPointerInput();
254             break;
255           case ClientCutText:
256             recvCutText();
257             break;
258           default:
259             panic("Unimplemented message type recv from client: %d\n",
260                   message_type);
261             break;
262         }
263         break;
264       default:
265         panic("Unknown vnc server state\n");
266     }
267 }
\end{DoxyCode}
\hypertarget{classVncServer_ac295bade8aee589f6718dfa79edc2a34}{
\index{VncServer@{VncServer}!detach@{detach}}
\index{detach@{detach}!VncServer@{VncServer}}
\subsubsection[{detach}]{\setlength{\rightskip}{0pt plus 5cm}void detach ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_ac295bade8aee589f6718dfa79edc2a34}



\begin{DoxyCode}
341 {
342     if (dataFd != -1) {
343         ::close(dataFd);
344         dataFd = -1;
345     }
346 
347     if (!dataEvent || !dataEvent->queued())
348         return;
349 
350     pollQueue.remove(dataEvent);
351     delete dataEvent;
352     dataEvent = NULL;
353     curState = WaitForProtocolVersion;
354 
355     inform("VNC client detached\n");
356     DPRINTF(VNC, "detach vnc client %d\n", number);
357 }
\end{DoxyCode}
\hypertarget{classVncServer_ac0c44c1417536740ffc2cf33117027cf}{
\index{VncServer@{VncServer}!listen@{listen}}
\index{listen@{listen}!VncServer@{VncServer}}
\subsubsection[{listen}]{\setlength{\rightskip}{0pt plus 5cm}void listen (int {\em port})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_ac0c44c1417536740ffc2cf33117027cf}



\begin{DoxyCode}
150 {
151     if (ListenSocket::allDisabled()) {
152         warn_once("Sockets disabled, not accepting vnc client connections");
153         return;
154     }
155 
156     while (!listener.listen(port, true)) {
157         DPRINTF(VNC,
158                 "can't bind address vnc server port %d in use PID %d\n",
159                 port, getpid());
160         port++;
161     }
162 
163     int p1, p2;
164     p2 = name().rfind('.') - 1;
165     p1 = name().rfind('.', p2);
166     ccprintf(cerr, "Listening for %s connection on port %d\n",
167              name().substr(p1 + 1, p2 - p1), port);
168 
169     listenEvent = new ListenEvent(this, listener.getfd(), POLLIN);
170     pollQueue.schedule(listenEvent);
171 }
\end{DoxyCode}
\hypertarget{classVncServer_a09f96768306b6f498cf39d32962a853d}{
\index{VncServer@{VncServer}!read@{read}}
\index{read@{read}!VncServer@{VncServer}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}size\_\-t read (T $\ast$ {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classVncServer_a09f96768306b6f498cf39d32962a853d}
Templated version of the read function above to read simple data to the client 
\begin{DoxyParams}{引数}
\item[{\em val}]data to recv from the client \end{DoxyParams}



\begin{DoxyCode}
305 {
306     return read((uint8_t*)val, sizeof(T));
307 }
\end{DoxyCode}
\hypertarget{classVncServer_a9f8a094b410fa145da19663f83f241e3}{
\index{VncServer@{VncServer}!read@{read}}
\index{read@{read}!VncServer@{VncServer}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}size\_\-t read (uint8\_\-t $\ast$ {\em buf}, \/  size\_\-t {\em len})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_a9f8a094b410fa145da19663f83f241e3}
Read some data from the client 
\begin{DoxyParams}{引数}
\item[{\em buf}]the data to read \item[{\em len}]the amount of data to read \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
length read 
\end{DoxyReturn}



\begin{DoxyCode}
273 {
274     if (dataFd < 0)
275         panic("vnc not properly attached.\n");
276 
277     size_t ret;
278     do {
279         ret = ::read(dataFd, buf, len);
280     } while (ret == -1 && errno == EINTR);
281 
282 
283     if (ret <= 0){
284         DPRINTF(VNC, "Read failed.\n");
285         detach();
286         return 0;
287     }
288 
289     return ret;
290 }
\end{DoxyCode}
\hypertarget{classVncServer_ab265cdc9659b04aafe0b93e866024a6d}{
\index{VncServer@{VncServer}!read1@{read1}}
\index{read1@{read1}!VncServer@{VncServer}}
\subsubsection[{read1}]{\setlength{\rightskip}{0pt plus 5cm}size\_\-t read1 (uint8\_\-t $\ast$ {\em buf}, \/  size\_\-t {\em len})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_ab265cdc9659b04aafe0b93e866024a6d}
Read len -\/1 bytes from the client into the buffer provided + 1 assert that we read enough bytes. This function exists to handle reading all of the protocol structs above when we've already read the first byte which describes which one we're reading 
\begin{DoxyParams}{引数}
\item[{\em buf}]the address of the buffer to add one to and read data into \item[{\em len}]the amount of data + 1 to read \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
length read 
\end{DoxyReturn}



\begin{DoxyCode}
294 {
295     size_t read_len M5_VAR_USED;
296     read_len = read(buf + 1, len - 1);
297     assert(read_len == len - 1);
298     return read_len;
299 }
\end{DoxyCode}
\hypertarget{classVncServer_a7ee4399f42b127e68135272ff77815c2}{
\index{VncServer@{VncServer}!recvCutText@{recvCutText}}
\index{recvCutText@{recvCutText}!VncServer@{VncServer}}
\subsubsection[{recvCutText}]{\setlength{\rightskip}{0pt plus 5cm}void recvCutText ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_a7ee4399f42b127e68135272ff77815c2}
Receive message from client that there is text in it's paste buffer. This is a no-\/op at the moment, but perhaps we would want to be able to paste it at some point. 


\begin{DoxyCode}
581 {
582     DPRINTF(VNC, "Received client copy buffer message\n");
583 
584     ClientCutTextMessage cct;
585     read1((uint8_t*)&cct, sizeof(ClientCutTextMessage));
586 
587     char str[1025];
588     size_t data_len = betoh(cct.length);
589     DPRINTF(VNC, "String length %d\n", data_len);
590     while (data_len > 0) {
591         size_t len;
592         size_t bytes_to_read = data_len > 1024 ? 1024 : data_len;
593         len = read((uint8_t*)&str, bytes_to_read);
594         str[bytes_to_read] = 0;
595         data_len -= len;
596         assert(data_len >= 0);
597         DPRINTF(VNC, "Buffer: %s\n", str);
598     }
599 
600 }
\end{DoxyCode}
\hypertarget{classVncServer_adce913e2d5283f60780d7becd1d3e44b}{
\index{VncServer@{VncServer}!recvKeyboardInput@{recvKeyboardInput}}
\index{recvKeyboardInput@{recvKeyboardInput}!VncServer@{VncServer}}
\subsubsection[{recvKeyboardInput}]{\setlength{\rightskip}{0pt plus 5cm}void recvKeyboardInput ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_adce913e2d5283f60780d7becd1d3e44b}
Receive message from client providing new keyboard input 


\begin{DoxyCode}
549 {
550     DPRINTF(VNC, "Received keyboard input from client\n");
551     KeyEventMessage kem;
552     read1((uint8_t*)&kem, sizeof(KeyEventMessage));
553 
554     kem.key = betoh(kem.key);
555     DPRINTF(VNC, " -- received key code %d (%s)\n", kem.key, kem.down_flag ?
556             "down" : "up");
557 
558     if (keyboard)
559         keyboard->keyPress(kem.key, kem.down_flag);
560 }
\end{DoxyCode}
\hypertarget{classVncServer_a95d4cde3a9b92bbac5871d8b475eedd3}{
\index{VncServer@{VncServer}!recvPointerInput@{recvPointerInput}}
\index{recvPointerInput@{recvPointerInput}!VncServer@{VncServer}}
\subsubsection[{recvPointerInput}]{\setlength{\rightskip}{0pt plus 5cm}void recvPointerInput ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_a95d4cde3a9b92bbac5871d8b475eedd3}
Recv message from client providing new mouse movement or button click 


\begin{DoxyCode}
564 {
565     DPRINTF(VNC, "Received pointer input from client\n");
566     PointerEventMessage pem;
567 
568     read1((uint8_t*)&pem, sizeof(PointerEventMessage));;
569 
570     pem.x = betoh(pem.x);
571     pem.y = betoh(pem.y);
572     DPRINTF(VNC, " -- pointer at x = %d y = %d buttons = %#x\n", pem.x, pem.y,
573             pem.button_mask);
574 
575     if (mouse)
576         mouse->mouseAt(pem.x, pem.y, pem.button_mask);
577 }
\end{DoxyCode}
\hypertarget{classVncServer_a83f5ce82a666e5b948e2a14b430633ce}{
\index{VncServer@{VncServer}!requestFbUpdate@{requestFbUpdate}}
\index{requestFbUpdate@{requestFbUpdate}!VncServer@{VncServer}}
\subsubsection[{requestFbUpdate}]{\setlength{\rightskip}{0pt plus 5cm}void requestFbUpdate ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_a83f5ce82a666e5b948e2a14b430633ce}
Receive message from client asking for updated frame buffer 


\begin{DoxyCode}
530 {
531     DPRINTF(VNC, "Received frame buffer update request from client\n");
532 
533     FrameBufferUpdateReq fbr;
534     read1((uint8_t*)&fbr, sizeof(FrameBufferUpdateReq));
535 
536     fbr.x = betoh(fbr.x);
537     fbr.y = betoh(fbr.y);
538     fbr.width = betoh(fbr.width);
539     fbr.height = betoh(fbr.height);
540 
541     DPRINTF(VNC, " -- x = %d y = %d w = %d h = %d\n", fbr.x, fbr.y, fbr.width,
542             fbr.height);
543 
544     sendFrameBufferUpdate();
545 }
\end{DoxyCode}
\hypertarget{classVncServer_a6ad4e22608f77193eb9cddb1c8b20703}{
\index{VncServer@{VncServer}!sendError@{sendError}}
\index{sendError@{sendError}!VncServer@{VncServer}}
\subsubsection[{sendError}]{\setlength{\rightskip}{0pt plus 5cm}void sendError (std::string {\em error\_\-msg})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_a6ad4e22608f77193eb9cddb1c8b20703}
Send an error message to the client when something goes wrong 
\begin{DoxyParams}{引数}
\item[{\em error\_\-msg}]error to send \end{DoxyParams}
\hypertarget{classVncServer_a3531045d065c2aa1aaf5a225e2337e80}{
\index{VncServer@{VncServer}!sendError@{sendError}}
\index{sendError@{sendError}!VncServer@{VncServer}}
\subsubsection[{sendError}]{\setlength{\rightskip}{0pt plus 5cm}void sendError (const char $\ast$ {\em error\_\-msg})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_a3531045d065c2aa1aaf5a225e2337e80}
vnc client Interface Send an error message to the client 
\begin{DoxyParams}{引数}
\item[{\em error\_\-msg}]text to send describing the error \end{DoxyParams}



\begin{DoxyCode}
361 {
362    uint32_t len = strlen(error_msg);
363    write(&len);
364    write(error_msg);
365 }
\end{DoxyCode}
\hypertarget{classVncServer_a046eae8a3566418d4f03a95de5d1af13}{
\index{VncServer@{VncServer}!sendFrameBufferResized@{sendFrameBufferResized}}
\index{sendFrameBufferResized@{sendFrameBufferResized}!VncServer@{VncServer}}
\subsubsection[{sendFrameBufferResized}]{\setlength{\rightskip}{0pt plus 5cm}void sendFrameBufferResized ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_a046eae8a3566418d4f03a95de5d1af13}
Tell the client that the frame buffer resized. This happens when the simulated system changes video modes (E.g. X11 starts). 


\begin{DoxyCode}
652 {
653     assert(fbPtr && dataFd > 0 && curState == NormalPhase);
654     DPRINTF(VNC, "Sending framebuffer resize\n");
655 
656     FrameBufferUpdate fbu;
657     FrameBufferRect fbr;
658 
659     fbu.type = ServerFrameBufferUpdate;
660     fbu.num_rects = 1;
661     fbr.x = 0;
662     fbr.y = 0;
663     fbr.width = videoWidth();
664     fbr.height = videoHeight();
665     fbr.encoding = EncodingDesktopSize;
666 
667     // fix up endian
668     fbu.num_rects = htobe(fbu.num_rects);
669     fbr.x = htobe(fbr.x);
670     fbr.y = htobe(fbr.y);
671     fbr.width = htobe(fbr.width);
672     fbr.height = htobe(fbr.height);
673     fbr.encoding = htobe(fbr.encoding);
674 
675     // send headers to client
676     write(&fbu);
677     write(&fbr);
678 
679     // No actual data is sent in this message
680 }
\end{DoxyCode}
\hypertarget{classVncServer_a12fdf8396c8fe33bb93e66d7491fb497}{
\index{VncServer@{VncServer}!sendFrameBufferUpdate@{sendFrameBufferUpdate}}
\index{sendFrameBufferUpdate@{sendFrameBufferUpdate}!VncServer@{VncServer}}
\subsubsection[{sendFrameBufferUpdate}]{\setlength{\rightskip}{0pt plus 5cm}void sendFrameBufferUpdate ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_a12fdf8396c8fe33bb93e66d7491fb497}
Send a updated frame buffer to the client. \begin{Desc}
\item[\hyperlink{todo__todo000011}{TODO}]this doesn't do anything smart and just sends the entire image \end{Desc}



\begin{DoxyCode}
605 {
606 
607     if (!fbPtr || dataFd <= 0 || curState != NormalPhase || !sendUpdate) {
608         DPRINTF(VNC, "NOT sending framebuffer update\n");
609         return;
610     }
611 
612     assert(vc);
613 
614     // The client will request data constantly, unless we throttle it
615     sendUpdate = false;
616 
617     DPRINTF(VNC, "Sending framebuffer update\n");
618 
619     FrameBufferUpdate fbu;
620     FrameBufferRect fbr;
621 
622     fbu.type = ServerFrameBufferUpdate;
623     fbu.num_rects = 1;
624     fbr.x = 0;
625     fbr.y = 0;
626     fbr.width = videoWidth();
627     fbr.height = videoHeight();
628     fbr.encoding = EncodingRaw;
629 
630     // fix up endian
631     fbu.num_rects = htobe(fbu.num_rects);
632     fbr.x = htobe(fbr.x);
633     fbr.y = htobe(fbr.y);
634     fbr.width = htobe(fbr.width);
635     fbr.height = htobe(fbr.height);
636     fbr.encoding = htobe(fbr.encoding);
637 
638     // send headers to client
639     write(&fbu);
640     write(&fbr);
641 
642     assert(fbPtr);
643 
644     uint8_t *tmp = vc->convert(fbPtr);
645     write(tmp, videoWidth() * videoHeight() * sizeof(uint32_t));
646     delete [] tmp;
647 
648 }
\end{DoxyCode}
\hypertarget{classVncServer_a0d7d773b4b3948da49ae2ecd00f985d5}{
\index{VncServer@{VncServer}!sendServerInit@{sendServerInit}}
\index{sendServerInit@{sendServerInit}!VncServer@{VncServer}}
\subsubsection[{sendServerInit}]{\setlength{\rightskip}{0pt plus 5cm}void sendServerInit ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_a0d7d773b4b3948da49ae2ecd00f985d5}
Send client our idea about what the frame buffer looks like 


\begin{DoxyCode}
438 {
439     ServerInitMsg msg;
440 
441     DPRINTF(VNC, "Sending server init message to client\n");
442 
443     msg.fbWidth = htobe(videoWidth());
444     msg.fbHeight = htobe(videoHeight());
445 
446     msg.px.bpp = htobe(pixelFormat.bpp);
447     msg.px.depth = htobe(pixelFormat.depth);
448     msg.px.bigendian = htobe(pixelFormat.bigendian);
449     msg.px.truecolor = htobe(pixelFormat.truecolor);
450     msg.px.redmax = htobe(pixelFormat.redmax);
451     msg.px.greenmax = htobe(pixelFormat.greenmax);
452     msg.px.bluemax = htobe(pixelFormat.bluemax);
453     msg.px.redshift = htobe(pixelFormat.redshift);
454     msg.px.greenshift = htobe(pixelFormat.greenshift);
455     msg.px.blueshift = htobe(pixelFormat.blueshift);
456     memset(msg.px.padding, 0, 3);
457     msg.namelen = 2;
458     msg.namelen = htobe(msg.namelen);
459     memcpy(msg.name, "M5", 2);
460 
461     write(&msg);
462     curState = NormalPhase;
463 }
\end{DoxyCode}
\hypertarget{classVncServer_a92a590790db6444ca7a79eaf5fbcb0d9}{
\index{VncServer@{VncServer}!setDirty@{setDirty}}
\index{setDirty@{setDirty}!VncServer@{VncServer}}
\subsubsection[{setDirty}]{\setlength{\rightskip}{0pt plus 5cm}void setDirty ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classVncServer_a92a590790db6444ca7a79eaf5fbcb0d9}
The frame buffer uses this call to notify the vnc server that the frame buffer has been updated and a new image needs to be sent to the client 

\hyperlink{classVncInput_ad7eac728ea55298c7691e7d1c165719b}{VncInput}を再定義しています。


\begin{DoxyCode}
315     {
316         VncInput::setDirty();
317         sendUpdate = true;
318         sendFrameBufferUpdate();
319     }
\end{DoxyCode}
\hypertarget{classVncServer_a840599118004b7df093bd78b6a21e56b}{
\index{VncServer@{VncServer}!setEncodings@{setEncodings}}
\index{setEncodings@{setEncodings}!VncServer@{VncServer}}
\subsubsection[{setEncodings}]{\setlength{\rightskip}{0pt plus 5cm}void setEncodings ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_a840599118004b7df093bd78b6a21e56b}
Receive encodings message from client and process it. 


\begin{DoxyCode}
496 {
497     DPRINTF(VNC, "Received supported encodings from client\n");
498 
499     PixelEncodingsMessage pem;
500     read1((uint8_t*)&pem, sizeof(PixelEncodingsMessage));
501 
502     pem.num_encodings = betoh(pem.num_encodings);
503 
504     DPRINTF(VNC, " -- %d encoding present\n", pem.num_encodings);
505     supportsRawEnc = supportsResizeEnc = false;
506 
507     for (int x = 0; x < pem.num_encodings; x++) {
508         int32_t encoding;
509         size_t len M5_VAR_USED;
510         len = read(&encoding);
511         assert(len == sizeof(encoding));
512         DPRINTF(VNC, " -- supports %d\n", betoh(encoding));
513 
514         switch (betoh(encoding)) {
515           case EncodingRaw:
516             supportsRawEnc = true;
517             break;
518           case EncodingDesktopSize:
519             supportsResizeEnc = true;
520             break;
521         }
522     }
523 
524     if (!supportsRawEnc)
525         fatal("VNC clients must always support raw encoding\n");
526 }
\end{DoxyCode}
\hypertarget{classVncServer_a9abef13e07371ccf4a89883649f1bcc5}{
\index{VncServer@{VncServer}!setFrameBufferParams@{setFrameBufferParams}}
\index{setFrameBufferParams@{setFrameBufferParams}!VncServer@{VncServer}}
\subsubsection[{setFrameBufferParams}]{\setlength{\rightskip}{0pt plus 5cm}void setFrameBufferParams ({\bf VideoConvert::Mode} {\em mode}, \/  uint16\_\-t {\em width}, \/  uint16\_\-t {\em height})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classVncServer_a9abef13e07371ccf4a89883649f1bcc5}
\hyperlink{classSet}{Set} the mode of the data the frame buffer will be sending us 
\begin{DoxyParams}{引数}
\item[{\em mode}]the mode \end{DoxyParams}


\hyperlink{classVncInput_a9abef13e07371ccf4a89883649f1bcc5}{VncInput}を再定義しています。


\begin{DoxyCode}
685 {
686     VncInput::setFrameBufferParams(mode, width, height);
687 
688     if (mode != videoMode || width != videoWidth() || height != videoHeight()) {
689         if (dataFd > 0 && fbPtr && curState == NormalPhase) {
690             if (supportsResizeEnc)
691                 sendFrameBufferResized();
692             else
693                 // The frame buffer changed size and we can't update the client
694                 detach();
695         }
696     }
697 }
\end{DoxyCode}
\hypertarget{classVncServer_ad52ea030be3bb8b536f8a7f87b709319}{
\index{VncServer@{VncServer}!setPixelFormat@{setPixelFormat}}
\index{setPixelFormat@{setPixelFormat}!VncServer@{VncServer}}
\subsubsection[{setPixelFormat}]{\setlength{\rightskip}{0pt plus 5cm}void setPixelFormat ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_ad52ea030be3bb8b536f8a7f87b709319}
Receive pixel foramt message from client and process it. 


\begin{DoxyCode}
467 {
468     DPRINTF(VNC, "Received pixel format from client message\n");
469 
470     PixelFormatMessage pfm;
471     read1((uint8_t*)&pfm, sizeof(PixelFormatMessage));
472 
473     DPRINTF(VNC, " -- bpp = %d; depth = %d; be = %d\n", pfm.px.bpp,
474             pfm.px.depth, pfm.px.bigendian);
475     DPRINTF(VNC, " -- true color = %d red,green,blue max = %d,%d,%d\n",
476             pfm.px.truecolor, betoh(pfm.px.redmax), betoh(pfm.px.greenmax),
477                 betoh(pfm.px.bluemax));
478     DPRINTF(VNC, " -- red,green,blue shift = %d,%d,%d\n", pfm.px.redshift,
479             pfm.px.greenshift, pfm.px.blueshift);
480 
481     if (betoh(pfm.px.bpp) != pixelFormat.bpp ||
482         betoh(pfm.px.depth) != pixelFormat.depth ||
483         betoh(pfm.px.bigendian) != pixelFormat.bigendian ||
484         betoh(pfm.px.truecolor) != pixelFormat.truecolor ||
485         betoh(pfm.px.redmax) != pixelFormat.redmax ||
486         betoh(pfm.px.greenmax) != pixelFormat.greenmax ||
487         betoh(pfm.px.bluemax) != pixelFormat.bluemax ||
488         betoh(pfm.px.redshift) != pixelFormat.redshift ||
489         betoh(pfm.px.greenshift) != pixelFormat.greenshift ||
490         betoh(pfm.px.blueshift) != pixelFormat.blueshift)
491         fatal("VNC client doesn't support true color raw encoding\n");
492 }
\end{DoxyCode}
\hypertarget{classVncServer_add50e5436017b9c2f1e0d11c9476bf1b}{
\index{VncServer@{VncServer}!write@{write}}
\index{write@{write}!VncServer@{VncServer}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}size\_\-t write (const char $\ast$ {\em str})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_add50e5436017b9c2f1e0d11c9476bf1b}
Send a string to the client 
\begin{DoxyParams}{引数}
\item[{\em str}]string to transmit \end{DoxyParams}



\begin{DoxyCode}
334 {
335     return write((uint8_t*)str, strlen(str));
336 }
\end{DoxyCode}
\hypertarget{classVncServer_aefa1c03e3a1158303080d2702de2a11e}{
\index{VncServer@{VncServer}!write@{write}}
\index{write@{write}!VncServer@{VncServer}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}size\_\-t write (T $\ast$ {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classVncServer_aefa1c03e3a1158303080d2702de2a11e}
Templated version of the write function above to write simple data to the client 
\begin{DoxyParams}{引数}
\item[{\em val}]data to send to the client \end{DoxyParams}



\begin{DoxyCode}
328 {
329     return write((uint8_t*)val, sizeof(T));
330 }
\end{DoxyCode}
\hypertarget{classVncServer_a215d71301eb6ae0ebffc5d2f8fe4a140}{
\index{VncServer@{VncServer}!write@{write}}
\index{write@{write}!VncServer@{VncServer}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}size\_\-t write (const uint8\_\-t $\ast$ {\em buf}, \/  size\_\-t {\em len})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_a215d71301eb6ae0ebffc5d2f8fe4a140}
Write a buffer to the client. 
\begin{DoxyParams}{引数}
\item[{\em buf}]buffer to send \item[{\em len}]length of the buffer \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of bytes sent 
\end{DoxyReturn}



\begin{DoxyCode}
312 {
313     if (dataFd < 0)
314         panic("Vnc client not properly attached.\n");
315 
316     ssize_t ret;
317     ret = atomic_write(dataFd, buf, len);
318 
319     if (ret < len)
320         detach();
321 
322     return ret;
323 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classVncServer_a8a93830b802d4fc8562fa54ead43b1f9}{
\index{VncServer@{VncServer}!DataEvent@{DataEvent}}
\index{DataEvent@{DataEvent}!VncServer@{VncServer}}
\subsubsection[{DataEvent}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf DataEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classVncServer_a8a93830b802d4fc8562fa54ead43b1f9}
\hypertarget{classVncServer_a9465cdda0008b0e7b7f9ac919cd9cca6}{
\index{VncServer@{VncServer}!ListenEvent@{ListenEvent}}
\index{ListenEvent@{ListenEvent}!VncServer@{VncServer}}
\subsubsection[{ListenEvent}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf ListenEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classVncServer_a9465cdda0008b0e7b7f9ac919cd9cca6}


\subsection{変数}
\hypertarget{classVncServer_ad0bc1d6a87b76d47489ca919f3ae51ca}{
\index{VncServer@{VncServer}!curState@{curState}}
\index{curState@{curState}!VncServer@{VncServer}}
\subsubsection[{curState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ConnectionState} {\bf curState}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_ad0bc1d6a87b76d47489ca919f3ae51ca}
The rfb prototol state the connection is in \hypertarget{classVncServer_a7a8501aba170bc353fe057e372612b93}{
\index{VncServer@{VncServer}!dataEvent@{dataEvent}}
\index{dataEvent@{dataEvent}!VncServer@{VncServer}}
\subsubsection[{dataEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DataEvent}$\ast$ {\bf dataEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_a7a8501aba170bc353fe057e372612b93}
\hypertarget{classVncServer_ab9f945d843e004fbbb155b7709051470}{
\index{VncServer@{VncServer}!dataFd@{dataFd}}
\index{dataFd@{dataFd}!VncServer@{VncServer}}
\subsubsection[{dataFd}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf dataFd}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_ab9f945d843e004fbbb155b7709051470}
\hypertarget{classVncServer_acf9ea448b26a541b4a197f1ca92f700b}{
\index{VncServer@{VncServer}!listener@{listener}}
\index{listener@{listener}!VncServer@{VncServer}}
\subsubsection[{listener}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ListenSocket} {\bf listener}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_acf9ea448b26a541b4a197f1ca92f700b}
\hypertarget{classVncServer_ad7f258b1b869b6152bc5040c38b79d39}{
\index{VncServer@{VncServer}!listenEvent@{listenEvent}}
\index{listenEvent@{listenEvent}!VncServer@{VncServer}}
\subsubsection[{listenEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ListenEvent}$\ast$ {\bf listenEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_ad7f258b1b869b6152bc5040c38b79d39}
\hypertarget{classVncServer_a7106e2abc437ad981830d14176d15f09}{
\index{VncServer@{VncServer}!number@{number}}
\index{number@{number}!VncServer@{VncServer}}
\subsubsection[{number}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf number}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_a7106e2abc437ad981830d14176d15f09}
\hypertarget{classVncServer_a126e69cd1de897ecc9b84e858e4809c7}{
\index{VncServer@{VncServer}!pixelFormat@{pixelFormat}}
\index{pixelFormat@{pixelFormat}!VncServer@{VncServer}}
\subsubsection[{pixelFormat}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PixelFormat} {\bf pixelFormat}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_a126e69cd1de897ecc9b84e858e4809c7}
The one and only pixel format we support \hypertarget{classVncServer_ab2b958eb553dde858c8737b57614e87d}{
\index{VncServer@{VncServer}!sendUpdate@{sendUpdate}}
\index{sendUpdate@{sendUpdate}!VncServer@{VncServer}}
\subsubsection[{sendUpdate}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf sendUpdate}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_ab2b958eb553dde858c8737b57614e87d}
An update needs to be sent to the client. Without doing this the client will constantly request data that is pointless \hypertarget{classVncServer_a1286ea1dbf0c332e14ccfc0267de405e}{
\index{VncServer@{VncServer}!supportsRawEnc@{supportsRawEnc}}
\index{supportsRawEnc@{supportsRawEnc}!VncServer@{VncServer}}
\subsubsection[{supportsRawEnc}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf supportsRawEnc}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_a1286ea1dbf0c332e14ccfc0267de405e}
If the vnc client supports receiving raw data. It always should \hypertarget{classVncServer_a68ae35695f8a6dcd68d9ff80dee28736}{
\index{VncServer@{VncServer}!supportsResizeEnc@{supportsResizeEnc}}
\index{supportsResizeEnc@{supportsResizeEnc}!VncServer@{VncServer}}
\subsubsection[{supportsResizeEnc}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf supportsResizeEnc}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classVncServer_a68ae35695f8a6dcd68d9ff80dee28736}
If the vnc client supports the desktop resize command 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
base/vnc/\hyperlink{vncserver_8hh}{vncserver.hh}\item 
base/vnc/\hyperlink{vncserver_8cc}{vncserver.cc}\end{DoxyCompactItemize}
