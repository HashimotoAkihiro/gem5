<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>File&nbsp;GEM5&nbsp;Wrapper: クラス X86KvmCPU</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- 作成： Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>メインページ</span></a></li>
      <li><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>構成</span></a></li>
      <li><a href="classes.html"><span>構成索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>構成メンバ</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>クラス X86KvmCPU</h1><!-- doxytag: class="X86KvmCPU" --><!-- doxytag: inherits="BaseKvmCPU" -->
<p><code>#include &lt;<a class="el" href="x86__cpu_8hh_source.html">x86_cpu.hh</a>&gt;</code></p>
<div class="dynheader">
X86KvmCPUに対する継承グラフ</div>
<div class="dynsection">
 <div class="center">
  <img src="classX86KvmCPU.gif" usemap="#X86KvmCPU_map" alt=""/>
  <map id="X86KvmCPU_map" name="X86KvmCPU_map">
<area href="classBaseKvmCPU.html" alt="BaseKvmCPU" shape="rect" coords="0,56,89,80"/>
<area href="classBaseCPU.html" alt="BaseCPU" shape="rect" coords="0,0,89,24"/>
</map>
 </div>
</div>

<p><a href="classX86KvmCPU-members.html">すべてのメンバ一覧</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>構成</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU_1_1X86KvmCPU.html">X86KvmCPU</a></td></tr>
<tr><td colspan="2"><h2>Public メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a775cadafe573db795406b498b53cff43">X86KvmCPU</a> (X86KvmCPUParams *params)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#ad55c9b8bef2361530e30e7f3eb1a58c1">~X86KvmCPU</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#aecc7d8debf54990ffeaaed5bac7d7d81">startup</a> ()</td></tr>
<tr><td colspan="2"><h2>Protected 型</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; struct <br class="typebreak"/>
kvm_msr_entry &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#aa498445286177d1e3901b007c40f52c9">KvmMSRVector</a></td></tr>
<tr><td colspan="2"><h2>Protected メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#aed3dbd0c0bf26d82ee56367a3f350506">kvmRun</a> (<a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> ticks)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a405afc17ad0dee3b816012ce909b2b6f">kvmRunDrain</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#afae1f96b6b1a482f400cd925b8709325">kvmRunWrapper</a> (<a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> ticks)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#abcad2a22057ba48360b17b978f694b48">getHostCycles</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstd_1_1vector.html">Kvm::MSRIndexVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#abab51da6ec6a0f14d2dde6b0857b7b34">getMsrIntersection</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a93c6e8c82dfb63c7039f0cbf064fae5d">updateKvmState</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#adbd5e38eae7c8c3021f2c4f430b399fd">updateThreadContext</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a7f9a05aa2521efe15d995cad6a739aa5">deliverInterrupts</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a404fbd80d6676724d026a932b2258dc7">handleKvmExitIO</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a405e34c9d079e8823ac2a1ca0e816a47">handleKvmExitIRQWindowOpen</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a1d97c7e0665d576bb463335078bb02ec">archIsDrained</a> () const </td></tr>
<tr><td colspan="2"><h2>Private メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#adcec996536ccdb020b08a11d61a47d44">updateCPUID</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a58452f4681b53990ff7470d1884ac13c">handleIOMiscReg32</a> (int miscreg)</td></tr>
<tr><td colspan="2"><h2>Private 変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRequest.html">Request</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#ab9e917350d26247b9eb4153e891f348a">io_req</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">Kvm::MSRIndexVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#aa0f07c7b56f9fd1e68e7ebdc2e3a9428">cachedMsrIntersection</a></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpd41d8cd98f00b204e9800998ecf8427e"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#ab7c96fcfb73a6d3ca276a6dce2ee76bb">haveDebugRegs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#ac0fd3f6d7cf7fa1132de384a5953228c">haveXSave</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#ab966ae6cc1b380746dcb2713f2559e65">useXSave</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#acb9f794b9c9ccc1422b1b5ba9e4823b6">haveXCRs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#accd2600060dbaee3a3b41aed4034c63c">dump</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#aa1a18283b9b8e7cb68c16a67fec2259c">dumpFpuRegs</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#af077d8e3ed2e320aa9a94718f0757a37">dumpIntRegs</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a8a8d697d582ced238ec0dfca97be2a75">dumpSpecRegs</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a90a32da18747ec95f59f6042fa5b448d">dumpDebugRegs</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a80e6ff34faeb5d05343e77809a203ec8">dumpXCRs</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a84c89612fa5d62bf131915036e99c8ee">dumpXSave</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#ab17603ee90366735647c3ed5407e23ec">dumpVCpuEvents</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#ad68abbbf4ef33ea6b6ed643fee2c13e6">dumpMSRs</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#ae1aa75790696eb8780d159812f607921">setCPUID</a> (const struct kvm_cpuid2 &amp;cpuid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a6782fae08bf69ed6903f49bfbee81566">setCPUID</a> (const <a class="el" href="classstd_1_1vector.html">Kvm::CPUIDVector</a> &amp;cpuid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a37c723660e4a4aa0ebb42ee498df990b">setMSRs</a> (const struct kvm_msrs &amp;msrs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#acc0ac79f886623c5e0ce73b393402148">setMSRs</a> (const <a class="el" href="classstd_1_1vector.html">KvmMSRVector</a> &amp;msrs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#aee0c514e035c18531c33ea1219e621bf">getMSRs</a> (struct kvm_msrs &amp;msrs) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a3d32029e1dfb4da512897794d56e9fc8">setMSR</a> (<a class="el" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> index, uint64_t value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#ad242a06d6443c10c74eac568fb44fcfe">getMSR</a> (<a class="el" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a62688c8626ebb350e3748a2cd1fa44a8">getDebugRegisters</a> (struct kvm_debugregs &amp;regs) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a0c0b94046f41e2b83c8f224e9f227d0f">setDebugRegisters</a> (const struct kvm_debugregs &amp;regs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a6744a04655bbdcee8aa24919573d8698">getXCRs</a> (struct kvm_xcrs &amp;regs) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a929420a323cb83ab21bdf3efa22edd24">setXCRs</a> (const struct kvm_xcrs &amp;regs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#af9f89d561ce9170ad89e6582071c1169">getXSave</a> (struct kvm_xsave &amp;xsave) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#aa05e7c39fbe7374815b387728b7de06d">setXSave</a> (const struct kvm_xsave &amp;xsave)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a7c08fc9f9ab36f8eda2a3cfe6c234635">getVCpuEvents</a> (struct kvm_vcpu_events &amp;events) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a70cfa7f84580af5396fbc82f540c8a5b">setVCpuEvents</a> (const struct kvm_vcpu_events &amp;events)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a54e3879c7bcd8aac9d1b88350e7674fe">updateKvmStateRegs</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#af58754cb34827756e0e0fc8474c54a8e">updateKvmStateSRegs</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a1c8ff9ec0ad33f11a2212a37e2a79f6c">updateKvmStateFPU</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a3eccabf97e73ee194068ee37c2422c50">updateKvmStateFPULegacy</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#aa1d3c8572c67dd0c4457ba46307f35f1">updateKvmStateFPUXSave</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#ad04202aafaacd818cf2621c5a31926c1">updateKvmStateMSRs</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a3e652bccdd2770630eb4e7bfb0b31b5e">updateThreadContextRegs</a> (const struct kvm_regs &amp;regs, const struct kvm_sregs &amp;sregs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#aaca63820cd695ae9a2d1bafa76f2ebf6">updateThreadContextSRegs</a> (const struct kvm_sregs &amp;sregs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a1f9b85cc469eb72bbf377872c1404c1e">updateThreadContextFPU</a> (const struct kvm_fpu &amp;fpu)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#a64c8d7da4ee94fdaeb4e61d7106c01cf">updateThreadContextXSave</a> (const struct kvm_xsave &amp;kxsave)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classX86KvmCPU.html#ad0f81dc69ee0b095b4c9eeec4491ed39">updateThreadContextMSRs</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>説明</h2>
<p>x86 implementation of a KVM-based hardware virtualized CPU. </p>
<hr/><h2>型定義</h2>
<a class="anchor" id="aa498445286177d1e3901b007c40f52c9"></a><!-- doxytag: member="X86KvmCPU::KvmMSRVector" ref="aa498445286177d1e3901b007c40f52c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;struct kvm_msr_entry&gt; <a class="el" href="classstd_1_1vector.html">KvmMSRVector</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>コンストラクタとデストラクタ</h2>
<a class="anchor" id="a775cadafe573db795406b498b53cff43"></a><!-- doxytag: member="X86KvmCPU::X86KvmCPU" ref="a775cadafe573db795406b498b53cff43" args="(X86KvmCPUParams *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classX86KvmCPU_1_1X86KvmCPU.html">X86KvmCPU</a> </td>
          <td>(</td>
          <td class="paramtype">X86KvmCPUParams *&nbsp;</td>
          <td class="paramname"> <em>params</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00519"></a>00519     : <a class="code" href="classBaseKvmCPU.html#a9eb0b030bd0367a335c97b465d98f01c">BaseKvmCPU</a>(params),
<a name="l00520"></a>00520       <a class="code" href="classX86KvmCPU.html#ab966ae6cc1b380746dcb2713f2559e65">useXSave</a>(params-&gt;useXSave)
<a name="l00521"></a>00521 {
<a name="l00522"></a>00522     <a class="code" href="classKvm.html">Kvm</a> &amp;kvm(<a class="code" href="classBaseKvmCPU.html#a6b8ecd9ec419f0cbe3c1047be643fe08">vm</a>.<a class="code" href="classKvmVM.html#a4169de9bdb8aa1afbeed2acc231dbb7f">kvm</a>);
<a name="l00523"></a>00523 
<a name="l00524"></a>00524     <span class="keywordflow">if</span> (!kvm.capSetTSSAddress())
<a name="l00525"></a>00525         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Missing capability (KVM_CAP_SET_TSS_ADDR)\n&quot;</span>);
<a name="l00526"></a>00526     <span class="keywordflow">if</span> (!kvm.capExtendedCPUID())
<a name="l00527"></a>00527         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Missing capability (KVM_CAP_EXT_CPUID)\n&quot;</span>);
<a name="l00528"></a>00528     <span class="keywordflow">if</span> (!kvm.capUserNMI())
<a name="l00529"></a>00529         <a class="code" href="base_2misc_8hh.html#a8224a361dddd2ad59b411982e5ea746f">warn</a>(<span class="stringliteral">&quot;KVM: Missing capability (KVM_CAP_USER_NMI)\n&quot;</span>);
<a name="l00530"></a>00530     <span class="keywordflow">if</span> (!kvm.capVCPUEvents())
<a name="l00531"></a>00531         <a class="code" href="base_2misc_8hh.html#a8224a361dddd2ad59b411982e5ea746f">warn</a>(<span class="stringliteral">&quot;KVM: Missing capability (KVM_CAP_VCPU_EVENTS)\n&quot;</span>);
<a name="l00532"></a>00532 
<a name="l00533"></a>00533     <a class="code" href="classX86KvmCPU.html#ab7c96fcfb73a6d3ca276a6dce2ee76bb">haveDebugRegs</a> = kvm.capDebugRegs();
<a name="l00534"></a>00534     <a class="code" href="classX86KvmCPU.html#ac0fd3f6d7cf7fa1132de384a5953228c">haveXSave</a> = kvm.capXSave();
<a name="l00535"></a>00535     <a class="code" href="classX86KvmCPU.html#acb9f794b9c9ccc1422b1b5ba9e4823b6">haveXCRs</a> = kvm.capXCRs();
<a name="l00536"></a>00536 
<a name="l00537"></a>00537     <span class="keywordflow">if</span> (<a class="code" href="classX86KvmCPU.html#ab966ae6cc1b380746dcb2713f2559e65">useXSave</a> &amp;&amp; !<a class="code" href="classX86KvmCPU.html#ac0fd3f6d7cf7fa1132de384a5953228c">haveXSave</a>) {
<a name="l00538"></a>00538         <a class="code" href="base_2misc_8hh.html#a8224a361dddd2ad59b411982e5ea746f">warn</a>(<span class="stringliteral">&quot;KVM: XSAVE not supported by host. MXCSR synchronization might be &quot;</span>
<a name="l00539"></a>00539              <span class="stringliteral">&quot;unreliable due to kernel bugs.\n&quot;</span>);
<a name="l00540"></a>00540         <a class="code" href="classX86KvmCPU.html#ab966ae6cc1b380746dcb2713f2559e65">useXSave</a> = <span class="keyword">false</span>;
<a name="l00541"></a>00541     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="classX86KvmCPU.html#ab966ae6cc1b380746dcb2713f2559e65">useXSave</a>) {
<a name="l00542"></a>00542         <a class="code" href="base_2misc_8hh.html#a8224a361dddd2ad59b411982e5ea746f">warn</a>(<span class="stringliteral">&quot;KVM: XSave FPU/SIMD synchronization disabled by user.\n&quot;</span>);
<a name="l00543"></a>00543     }
<a name="l00544"></a>00544 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad55c9b8bef2361530e30e7f3eb1a58c1"></a><!-- doxytag: member="X86KvmCPU::~X86KvmCPU" ref="ad55c9b8bef2361530e30e7f3eb1a58c1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classX86KvmCPU_1_1X86KvmCPU.html">X86KvmCPU</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00547"></a>00547 {
<a name="l00548"></a>00548 }
</pre></div></p>

</div>
</div>
<hr/><h2>関数</h2>
<a class="anchor" id="a1d97c7e0665d576bb463335078bb02ec"></a><!-- doxytag: member="X86KvmCPU::archIsDrained" ref="a1d97c7e0665d576bb463335078bb02ec" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool archIsDrained </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classCheck.html">Check</a> if there are pending events in the vCPU that prevents it from being drained.</p>
<p>There are cases after interrupt injection where the interrupt is still pending in the guest. This method detects such cases and requests additional draining.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>False if there are pending events in the guest, True otherwise. </dd></dl>

<p><a class="el" href="classBaseKvmCPU.html#a4ee4cbdc5d3315fd8016b44d3e77abd5">BaseKvmCPU</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l01380"></a>01380 {
<a name="l01381"></a>01381     <span class="keyword">struct </span>kvm_vcpu_events events;
<a name="l01382"></a>01382 
<a name="l01383"></a>01383     <a class="code" href="classX86KvmCPU.html#a7c08fc9f9ab36f8eda2a3cfe6c234635">getVCpuEvents</a>(events);
<a name="l01384"></a>01384 
<a name="l01385"></a>01385     <span class="comment">// We could probably handle this in a by re-inserting interrupts</span>
<a name="l01386"></a>01386     <span class="comment">// that are pending into gem5 on a drain. However, that would</span>
<a name="l01387"></a>01387     <span class="comment">// probably be tricky to do reliably, so we&apos;ll just prevent a</span>
<a name="l01388"></a>01388     <span class="comment">// drain if there is anything pending in the</span>
<a name="l01389"></a>01389     <span class="comment">// guest. X86KvmCPU::kvmRunDrain() minimizes the amount of code</span>
<a name="l01390"></a>01390     <span class="comment">// executed in the guest by requesting an interrupt window if</span>
<a name="l01391"></a>01391     <span class="comment">// there are pending interrupts.</span>
<a name="l01392"></a>01392     <span class="keyword">const</span> <span class="keywordtype">bool</span> pending_events(events.exception.injected ||
<a name="l01393"></a>01393                               events.interrupt.injected ||
<a name="l01394"></a>01394                               events.nmi.injected || events.nmi.pending);
<a name="l01395"></a>01395 
<a name="l01396"></a>01396     <span class="keywordflow">if</span> (pending_events) {
<a name="l01397"></a>01397         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;archIsDrained: Pending events: %s %s %s %s\n&quot;</span>,
<a name="l01398"></a>01398                 events.exception.injected ? <span class="stringliteral">&quot;exception&quot;</span> : <span class="stringliteral">&quot;&quot;</span>,
<a name="l01399"></a>01399                 events.interrupt.injected ? <span class="stringliteral">&quot;interrupt&quot;</span> : <span class="stringliteral">&quot;&quot;</span>,
<a name="l01400"></a>01400                 events.nmi.injected ? <span class="stringliteral">&quot;nmi[i]&quot;</span> : <span class="stringliteral">&quot;&quot;</span>,
<a name="l01401"></a>01401                 events.nmi.pending ? <span class="stringliteral">&quot;nmi[p]&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);
<a name="l01402"></a>01402     }
<a name="l01403"></a>01403 
<a name="l01404"></a>01404     <span class="keywordflow">return</span> !pending_events;
<a name="l01405"></a>01405 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7f9a05aa2521efe15d995cad6a739aa5"></a><!-- doxytag: member="X86KvmCPU::deliverInterrupts" ref="a7f9a05aa2521efe15d995cad6a739aa5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deliverInterrupts </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inject pending interrupts from gem5 into the virtual CPU. </p>

<p><div class="fragment"><pre class="fragment"><a name="l01136"></a>01136 {
<a name="l01137"></a>01137     <a class="code" href="classRefCountingPtr.html">Fault</a> fault;
<a name="l01138"></a>01138 
<a name="l01139"></a>01139     <a class="code" href="classBaseKvmCPU.html#a5d4ee3823af24f9210efb370a4c8ce93">syncThreadContext</a>();
<a name="l01140"></a>01140 
<a name="l01141"></a>01141     {
<a name="l01142"></a>01142         <span class="comment">// Migrate to the interrupt controller&apos;s thread to get the</span>
<a name="l01143"></a>01143         <span class="comment">// interrupt. Even though the individual methods are safe to</span>
<a name="l01144"></a>01144         <span class="comment">// call across threads, we might still lose interrupts unless</span>
<a name="l01145"></a>01145         <span class="comment">// they are getInterrupt() and updateIntrInfo() are called</span>
<a name="l01146"></a>01146         <span class="comment">// atomically.</span>
<a name="l01147"></a>01147         <a class="code" href="classEventQueue_1_1ScopedMigration.html">EventQueue::ScopedMigration</a> migrate(<a class="code" href="classBaseCPU.html#abb9c3a7eae9af33c74d2c7da98a171bd">interrupts</a>-&gt;eventQueue());
<a name="l01148"></a>01148         fault = <a class="code" href="classBaseCPU.html#abb9c3a7eae9af33c74d2c7da98a171bd">interrupts</a>-&gt;getInterrupt(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>);
<a name="l01149"></a>01149         <a class="code" href="classBaseCPU.html#abb9c3a7eae9af33c74d2c7da98a171bd">interrupts</a>-&gt;updateIntrInfo(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>);
<a name="l01150"></a>01150     }
<a name="l01151"></a>01151 
<a name="l01152"></a>01152     <a class="code" href="classX86ISA_1_1X86Interrupt.html">X86Interrupt</a> *x86int(dynamic_cast&lt;X86Interrupt *&gt;(fault.get()));
<a name="l01153"></a>01153     <span class="keywordflow">if</span> (dynamic_cast&lt;NonMaskableInterrupt *&gt;(fault.get())) {
<a name="l01154"></a>01154         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmInt, <span class="stringliteral">&quot;Delivering NMI\n&quot;</span>);
<a name="l01155"></a>01155         <a class="code" href="group__KvmInterrupts.html#gabc700469cba2d4bba666902e552e7c2e">kvmNonMaskableInterrupt</a>();
<a name="l01156"></a>01156     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;InitInterrupt *&gt;(fault.get())) {
<a name="l01157"></a>01157         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmInt, <span class="stringliteral">&quot;INIT interrupt\n&quot;</span>);
<a name="l01158"></a>01158         fault.get()-&gt;invoke(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>);
<a name="l01159"></a>01159         <span class="comment">// Delay the kvm state update since we won&apos;t enter KVM on this</span>
<a name="l01160"></a>01160         <span class="comment">// tick.</span>
<a name="l01161"></a>01161         <a class="code" href="classBaseKvmCPU.html#a8d712456c8dd8a9842aa40a69dbc27dd">threadContextDirty</a> = <span class="keyword">true</span>;
<a name="l01162"></a>01162         <span class="comment">// HACK: gem5 doesn&apos;t actually have any BIOS code, which means</span>
<a name="l01163"></a>01163         <span class="comment">// that we need to halt the thread and wait for a startup</span>
<a name="l01164"></a>01164         <span class="comment">// interrupt before restarting the thread. The simulated CPUs</span>
<a name="l01165"></a>01165         <span class="comment">// use the same kind of hack using a microcode routine.</span>
<a name="l01166"></a>01166         <a class="code" href="classBaseKvmCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a3605b58fb45d69d498721bc2f2a14b1c" title="Set the status to Suspended.">suspend</a>();
<a name="l01167"></a>01167     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;StartupInterrupt *&gt;(fault.get())) {
<a name="l01168"></a>01168         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmInt, <span class="stringliteral">&quot;STARTUP interrupt\n&quot;</span>);
<a name="l01169"></a>01169         fault.get()-&gt;invoke(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>);
<a name="l01170"></a>01170         <span class="comment">// The kvm state is assumed to have been updated when entering</span>
<a name="l01171"></a>01171         <span class="comment">// kvmRun(), so we need to update manually it here.</span>
<a name="l01172"></a>01172         <a class="code" href="classX86KvmCPU.html#a93c6e8c82dfb63c7039f0cbf064fae5d">updateKvmState</a>();
<a name="l01173"></a>01173     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x86int) {
<a name="l01174"></a>01174         <span class="keyword">struct </span>kvm_interrupt kvm_int;
<a name="l01175"></a>01175         kvm_int.irq = x86int-&gt;getVector();
<a name="l01176"></a>01176 
<a name="l01177"></a>01177         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmInt, <span class="stringliteral">&quot;Delivering interrupt: %s (%u)\n&quot;</span>,
<a name="l01178"></a>01178                 fault-&gt;name(), kvm_int.irq);
<a name="l01179"></a>01179 
<a name="l01180"></a>01180         <a class="code" href="group__KvmInterrupts.html#ga16b8f95e3f70098952604e6b8a121679">kvmInterrupt</a>(kvm_int);
<a name="l01181"></a>01181     } <span class="keywordflow">else</span> {
<a name="l01182"></a>01182         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Unknown interrupt type\n&quot;</span>);
<a name="l01183"></a>01183     }
<a name="l01184"></a>01184 
<a name="l01185"></a>01185 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="accd2600060dbaee3a3b41aed4034c63c"></a><!-- doxytag: member="X86KvmCPU::dump" ref="accd2600060dbaee3a3b41aed4034c63c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dump </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classBaseKvmCPU.html#accd2600060dbaee3a3b41aed4034c63c">BaseKvmCPU</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00568"></a>00568 {
<a name="l00569"></a>00569     <a class="code" href="classX86KvmCPU.html#af077d8e3ed2e320aa9a94718f0757a37">dumpIntRegs</a>();
<a name="l00570"></a>00570     <span class="keywordflow">if</span> (<a class="code" href="classX86KvmCPU.html#ab966ae6cc1b380746dcb2713f2559e65">useXSave</a>)
<a name="l00571"></a>00571         <a class="code" href="classX86KvmCPU.html#a84c89612fa5d62bf131915036e99c8ee">dumpXSave</a>();
<a name="l00572"></a>00572     <span class="keywordflow">else</span>
<a name="l00573"></a>00573         <a class="code" href="classX86KvmCPU.html#aa1a18283b9b8e7cb68c16a67fec2259c">dumpFpuRegs</a>();
<a name="l00574"></a>00574     <a class="code" href="classX86KvmCPU.html#a8a8d697d582ced238ec0dfca97be2a75">dumpSpecRegs</a>();
<a name="l00575"></a>00575     <a class="code" href="classX86KvmCPU.html#a90a32da18747ec95f59f6042fa5b448d">dumpDebugRegs</a>();
<a name="l00576"></a>00576     <a class="code" href="classX86KvmCPU.html#a80e6ff34faeb5d05343e77809a203ec8">dumpXCRs</a>();
<a name="l00577"></a>00577     <a class="code" href="classX86KvmCPU.html#ab17603ee90366735647c3ed5407e23ec">dumpVCpuEvents</a>();
<a name="l00578"></a>00578     <a class="code" href="classX86KvmCPU.html#ad68abbbf4ef33ea6b6ed643fee2c13e6">dumpMSRs</a>();
<a name="l00579"></a>00579 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a90a32da18747ec95f59f6042fa5b448d"></a><!-- doxytag: member="X86KvmCPU::dumpDebugRegs" ref="a90a32da18747ec95f59f6042fa5b448d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dumpDebugRegs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00607"></a>00607 {
<a name="l00608"></a>00608     <span class="keywordflow">if</span> (<a class="code" href="classX86KvmCPU.html#ab7c96fcfb73a6d3ca276a6dce2ee76bb">haveDebugRegs</a>) {
<a name="l00609"></a>00609 <span class="preprocessor">#ifdef KVM_GET_DEBUGREGS</span>
<a name="l00610"></a>00610 <span class="preprocessor"></span>        <span class="keyword">struct </span>kvm_debugregs dregs;
<a name="l00611"></a>00611         <a class="code" href="classX86KvmCPU.html#a62688c8626ebb350e3748a2cd1fa44a8">getDebugRegisters</a>(dregs);
<a name="l00612"></a>00612         <a class="code" href="x86__cpu_8cc.html#ac071f56204bac6717fe834e758908929">dumpKvm</a>(dregs);
<a name="l00613"></a>00613 <span class="preprocessor">#endif</span>
<a name="l00614"></a>00614 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
<a name="l00615"></a>00615         <a class="code" href="base_2misc_8hh.html#ae7d790080fa18103d7582effff570b9e">inform</a>(<span class="stringliteral">&quot;Debug registers not supported by kernel.\n&quot;</span>);
<a name="l00616"></a>00616     }
<a name="l00617"></a>00617 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa1a18283b9b8e7cb68c16a67fec2259c"></a><!-- doxytag: member="X86KvmCPU::dumpFpuRegs" ref="aa1a18283b9b8e7cb68c16a67fec2259c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dumpFpuRegs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00583"></a>00583 {
<a name="l00584"></a>00584     <span class="keyword">struct </span>kvm_fpu fpu;
<a name="l00585"></a>00585     <a class="code" href="classBaseKvmCPU.html#a9fdafd736b7b9ef041b6c3e4768a61d6">getFPUState</a>(fpu);
<a name="l00586"></a>00586     <a class="code" href="x86__cpu_8cc.html#ac071f56204bac6717fe834e758908929">dumpKvm</a>(fpu);
<a name="l00587"></a>00587 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af077d8e3ed2e320aa9a94718f0757a37"></a><!-- doxytag: member="X86KvmCPU::dumpIntRegs" ref="af077d8e3ed2e320aa9a94718f0757a37" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dumpIntRegs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00591"></a>00591 {
<a name="l00592"></a>00592     <span class="keyword">struct </span>kvm_regs regs;
<a name="l00593"></a>00593     <a class="code" href="classBaseKvmCPU.html#a422ac5896dab3bae0379fa65831e3778">getRegisters</a>(regs);
<a name="l00594"></a>00594     <a class="code" href="x86__cpu_8cc.html#ac071f56204bac6717fe834e758908929">dumpKvm</a>(regs);
<a name="l00595"></a>00595 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad68abbbf4ef33ea6b6ed643fee2c13e6"></a><!-- doxytag: member="X86KvmCPU::dumpMSRs" ref="ad68abbbf4ef33ea6b6ed643fee2c13e6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dumpMSRs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00653"></a>00653 {
<a name="l00654"></a>00654     <span class="keyword">const</span> <a class="code" href="classstd_1_1vector.html">Kvm::MSRIndexVector</a> &amp;supported_msrs(<a class="code" href="classBaseKvmCPU.html#a6b8ecd9ec419f0cbe3c1047be643fe08">vm</a>.<a class="code" href="classKvmVM.html#a4169de9bdb8aa1afbeed2acc231dbb7f">kvm</a>.<a class="code" href="classKvm.html#a3ae50dd2ddc035995d7578481b35e877">getSupportedMSRs</a>());
<a name="l00655"></a>00655     std::unique_ptr&lt;struct kvm_msrs&gt; msrs(
<a name="l00656"></a>00656         newVarStruct&lt;struct kvm_msrs, struct kvm_msr_entry&gt;(
<a name="l00657"></a>00657             supported_msrs.size()));
<a name="l00658"></a>00658 
<a name="l00659"></a>00659     msrs-&gt;nmsrs = supported_msrs.size();
<a name="l00660"></a>00660     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> = 0; <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> &lt; supported_msrs.size(); ++<a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>) {
<a name="l00661"></a>00661         <span class="keyword">struct </span>kvm_msr_entry &amp;<a class="code" href="namespaceArmISA.html#a55520507919005a961edbe8b177f3bba">e</a>(msrs-&gt;entries[<a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>]);
<a name="l00662"></a>00662         <a class="code" href="namespaceArmISA.html#a55520507919005a961edbe8b177f3bba">e</a>.index = supported_msrs[<a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>];
<a name="l00663"></a>00663         <a class="code" href="namespaceArmISA.html#a55520507919005a961edbe8b177f3bba">e</a>.reserved = 0;
<a name="l00664"></a>00664         <a class="code" href="namespaceArmISA.html#a55520507919005a961edbe8b177f3bba">e</a>.data = 0;
<a name="l00665"></a>00665     }
<a name="l00666"></a>00666     <a class="code" href="classX86KvmCPU.html#aee0c514e035c18531c33ea1219e621bf">getMSRs</a>(*msrs.get());
<a name="l00667"></a>00667 
<a name="l00668"></a>00668     <a class="code" href="x86__cpu_8cc.html#ac071f56204bac6717fe834e758908929">dumpKvm</a>(*msrs.get());
<a name="l00669"></a>00669 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8a8d697d582ced238ec0dfca97be2a75"></a><!-- doxytag: member="X86KvmCPU::dumpSpecRegs" ref="a8a8d697d582ced238ec0dfca97be2a75" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dumpSpecRegs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00599"></a>00599 {
<a name="l00600"></a>00600     <span class="keyword">struct </span>kvm_sregs sregs;
<a name="l00601"></a>00601     <a class="code" href="classBaseKvmCPU.html#a5b5f3c0a541efb9b8567a5e835421c15">getSpecialRegisters</a>(sregs);
<a name="l00602"></a>00602     <a class="code" href="x86__cpu_8cc.html#ac071f56204bac6717fe834e758908929">dumpKvm</a>(sregs);
<a name="l00603"></a>00603 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab17603ee90366735647c3ed5407e23ec"></a><!-- doxytag: member="X86KvmCPU::dumpVCpuEvents" ref="ab17603ee90366735647c3ed5407e23ec" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dumpVCpuEvents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00645"></a>00645 {
<a name="l00646"></a>00646     <span class="keyword">struct </span>kvm_vcpu_events events;
<a name="l00647"></a>00647     <a class="code" href="classX86KvmCPU.html#a7c08fc9f9ab36f8eda2a3cfe6c234635">getVCpuEvents</a>(events);
<a name="l00648"></a>00648     <a class="code" href="x86__cpu_8cc.html#ac071f56204bac6717fe834e758908929">dumpKvm</a>(events);
<a name="l00649"></a>00649 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a80e6ff34faeb5d05343e77809a203ec8"></a><!-- doxytag: member="X86KvmCPU::dumpXCRs" ref="a80e6ff34faeb5d05343e77809a203ec8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dumpXCRs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00621"></a>00621 {
<a name="l00622"></a>00622     <span class="keywordflow">if</span> (<a class="code" href="classX86KvmCPU.html#acb9f794b9c9ccc1422b1b5ba9e4823b6">haveXCRs</a>) {
<a name="l00623"></a>00623         <span class="keyword">struct </span>kvm_xcrs xcrs;
<a name="l00624"></a>00624         <a class="code" href="classX86KvmCPU.html#a6744a04655bbdcee8aa24919573d8698">getXCRs</a>(xcrs);
<a name="l00625"></a>00625         <a class="code" href="x86__cpu_8cc.html#ac071f56204bac6717fe834e758908929">dumpKvm</a>(xcrs);
<a name="l00626"></a>00626     } <span class="keywordflow">else</span> {
<a name="l00627"></a>00627         <a class="code" href="base_2misc_8hh.html#ae7d790080fa18103d7582effff570b9e">inform</a>(<span class="stringliteral">&quot;XCRs not supported by kernel.\n&quot;</span>);
<a name="l00628"></a>00628     }
<a name="l00629"></a>00629 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a84c89612fa5d62bf131915036e99c8ee"></a><!-- doxytag: member="X86KvmCPU::dumpXSave" ref="a84c89612fa5d62bf131915036e99c8ee" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dumpXSave </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00633"></a>00633 {
<a name="l00634"></a>00634     <span class="keywordflow">if</span> (<a class="code" href="classX86KvmCPU.html#ac0fd3f6d7cf7fa1132de384a5953228c">haveXSave</a>) {
<a name="l00635"></a>00635         <span class="keyword">struct </span>kvm_xsave xsave;
<a name="l00636"></a>00636         <a class="code" href="classX86KvmCPU.html#af9f89d561ce9170ad89e6582071c1169">getXSave</a>(xsave);
<a name="l00637"></a>00637         <a class="code" href="x86__cpu_8cc.html#ac071f56204bac6717fe834e758908929">dumpKvm</a>(xsave);
<a name="l00638"></a>00638     } <span class="keywordflow">else</span> {
<a name="l00639"></a>00639         <a class="code" href="base_2misc_8hh.html#ae7d790080fa18103d7582effff570b9e">inform</a>(<span class="stringliteral">&quot;XSave not supported by kernel.\n&quot;</span>);
<a name="l00640"></a>00640     }
<a name="l00641"></a>00641 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a62688c8626ebb350e3748a2cd1fa44a8"></a><!-- doxytag: member="X86KvmCPU::getDebugRegisters" ref="a62688c8626ebb350e3748a2cd1fa44a8" args="(struct kvm_debugregs &amp;regs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getDebugRegisters </td>
          <td>(</td>
          <td class="paramtype">struct kvm_debugregs &amp;&nbsp;</td>
          <td class="paramname"> <em>regs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wrappers around KVM's state transfer methods. </p>

<p><div class="fragment"><pre class="fragment"><a name="l01562"></a>01562 {
<a name="l01563"></a>01563 <span class="preprocessor">#ifdef KVM_GET_DEBUGREGS</span>
<a name="l01564"></a>01564 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_GET_DEBUGREGS, &amp;regs) == -1)
<a name="l01565"></a>01565         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to get guest debug registers\n&quot;</span>);
<a name="l01566"></a>01566 <span class="preprocessor">#else</span>
<a name="l01567"></a>01567 <span class="preprocessor"></span>    <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Unsupported getDebugRegisters call.\n&quot;</span>);
<a name="l01568"></a>01568 <span class="preprocessor">#endif</span>
<a name="l01569"></a>01569 <span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="abcad2a22057ba48360b17b978f694b48"></a><!-- doxytag: member="X86KvmCPU::getHostCycles" ref="abcad2a22057ba48360b17b978f694b48" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t getHostCycles </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the value of the hardware cycle counter in the guest.</p>
<p>This method is supposed to return the total number of cycles executed in hardware mode relative to some arbitrary point in the past. It's mainly used when estimating the number of cycles actually executed by the CPU in <a class="el" href="classX86KvmCPU.html#aed3dbd0c0bf26d82ee56367a3f350506">kvmRun()</a>. The default behavior of this method is to use the cycles performance counter, but some architectures may want to use internal registers instead.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Number of host cycles executed relative to an undefined point in the past. </dd></dl>

<p><a class="el" href="classBaseKvmCPU.html#abcad2a22057ba48360b17b978f694b48">BaseKvmCPU</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l01279"></a>01279 {
<a name="l01280"></a>01280     <span class="keywordflow">return</span> <a class="code" href="classX86KvmCPU.html#ad242a06d6443c10c74eac568fb44fcfe">getMSR</a>(<a class="code" href="x86__cpu_8cc.html#a48a07da9eda1a7054027cbbd5701f7cc">MSR_TSC</a>);
<a name="l01281"></a>01281 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad242a06d6443c10c74eac568fb44fcfe"></a><!-- doxytag: member="X86KvmCPU::getMSR" ref="ad242a06d6443c10c74eac568fb44fcfe" args="(uint32_t index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t getMSR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l01525"></a>01525 {
<a name="l01526"></a>01526     std::unique_ptr&lt;struct kvm_msrs&gt; kvm_msrs(
<a name="l01527"></a>01527         newVarStruct&lt;struct kvm_msrs, struct kvm_msr_entry&gt;(1));
<a name="l01528"></a>01528     <span class="keyword">struct </span>kvm_msr_entry &amp;entry(kvm_msrs-&gt;entries[0]);
<a name="l01529"></a>01529 
<a name="l01530"></a>01530     kvm_msrs-&gt;nmsrs = 1;
<a name="l01531"></a>01531     entry.index = <a class="code" href="namespaceMipsISA.html#ae6714ce3c5ef82205cecbd410556edf3">index</a>;
<a name="l01532"></a>01532     entry.reserved = 0;
<a name="l01533"></a>01533     entry.data = 0;
<a name="l01534"></a>01534 
<a name="l01535"></a>01535     <a class="code" href="classX86KvmCPU.html#aee0c514e035c18531c33ea1219e621bf">getMSRs</a>(*kvm_msrs.get());
<a name="l01536"></a>01536     <span class="keywordflow">return</span> entry.data;
<a name="l01537"></a>01537 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abab51da6ec6a0f14d2dde6b0857b7b34"></a><!-- doxytag: member="X86KvmCPU::getMsrIntersection" ref="abab51da6ec6a0f14d2dde6b0857b7b34" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstd_1_1vector.html">Kvm::MSRIndexVector</a> &amp; getMsrIntersection </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a list of MSRs supported by both gem5 and KVM.</p>
<dl class="note"><dt><b>覚え書き:</b></dt><dd>This method uses an internal cache and only generates the MSR list once.</dd></dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>reference to a list of msr indices </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l01541"></a>01541 {
<a name="l01542"></a>01542     <span class="keywordflow">if</span> (<a class="code" href="classX86KvmCPU.html#aa0f07c7b56f9fd1e68e7ebdc2e3a9428">cachedMsrIntersection</a>.empty()) {
<a name="l01543"></a>01543         <span class="keyword">const</span> <a class="code" href="classstd_1_1vector.html">Kvm::MSRIndexVector</a> &amp;kvm_msrs(<a class="code" href="classBaseKvmCPU.html#a6b8ecd9ec419f0cbe3c1047be643fe08">vm</a>.<a class="code" href="classKvmVM.html#a4169de9bdb8aa1afbeed2acc231dbb7f">kvm</a>.<a class="code" href="classKvm.html#a3ae50dd2ddc035995d7578481b35e877">getSupportedMSRs</a>());
<a name="l01544"></a>01544 
<a name="l01545"></a>01545         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classKvm.html">Kvm</a>, <span class="stringliteral">&quot;kvm-x86: Updating MSR intersection\n&quot;</span>);
<a name="l01546"></a>01546         <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = kvm_msrs.cbegin(); it != kvm_msrs.cend(); ++it) {
<a name="l01547"></a>01547             <span class="keywordflow">if</span> (<a class="code" href="namespaceX86ISA.html#a668a095a9f8f9c629c5b12ff0bb8a721">X86ISA::msrMap</a>.find(*it) != <a class="code" href="namespaceX86ISA.html#a668a095a9f8f9c629c5b12ff0bb8a721">X86ISA::msrMap</a>.end()) {
<a name="l01548"></a>01548                 <a class="code" href="classX86KvmCPU.html#aa0f07c7b56f9fd1e68e7ebdc2e3a9428">cachedMsrIntersection</a>.push_back(*it);
<a name="l01549"></a>01549                 <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(<a class="code" href="classKvm.html">Kvm</a>, <span class="stringliteral">&quot;kvm-x86: Adding MSR 0x%x\n&quot;</span>, *it);
<a name="l01550"></a>01550             } <span class="keywordflow">else</span> {
<a name="l01551"></a>01551                 <a class="code" href="base_2misc_8hh.html#a8224a361dddd2ad59b411982e5ea746f">warn</a>(<span class="stringliteral">&quot;kvm-x86: MSR (0x%x) unsupported by gem5. Skipping.\n&quot;</span>,
<a name="l01552"></a>01552                      *it);
<a name="l01553"></a>01553             }
<a name="l01554"></a>01554         }
<a name="l01555"></a>01555     }
<a name="l01556"></a>01556 
<a name="l01557"></a>01557     <span class="keywordflow">return</span> <a class="code" href="classX86KvmCPU.html#aa0f07c7b56f9fd1e68e7ebdc2e3a9428">cachedMsrIntersection</a>;
<a name="l01558"></a>01558 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aee0c514e035c18531c33ea1219e621bf"></a><!-- doxytag: member="X86KvmCPU::getMSRs" ref="aee0c514e035c18531c33ea1219e621bf" args="(struct kvm_msrs &amp;msrs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getMSRs </td>
          <td>(</td>
          <td class="paramtype">struct kvm_msrs &amp;&nbsp;</td>
          <td class="paramname"> <em>msrs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l01501"></a>01501 {
<a name="l01502"></a>01502     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_GET_MSRS, (<span class="keywordtype">void</span> *)&amp;msrs) == -1)
<a name="l01503"></a>01503         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to get guest MSRs (errno: %i)\n&quot;</span>,
<a name="l01504"></a>01504               errno);
<a name="l01505"></a>01505 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7c08fc9f9ab36f8eda2a3cfe6c234635"></a><!-- doxytag: member="X86KvmCPU::getVCpuEvents" ref="a7c08fc9f9ab36f8eda2a3cfe6c234635" args="(struct kvm_vcpu_events &amp;events) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getVCpuEvents </td>
          <td>(</td>
          <td class="paramtype">struct kvm_vcpu_events &amp;&nbsp;</td>
          <td class="paramname"> <em>events</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l01613"></a>01613 {
<a name="l01614"></a>01614     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_GET_VCPU_EVENTS, &amp;events) == -1)
<a name="l01615"></a>01615         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to get guest debug registers\n&quot;</span>);
<a name="l01616"></a>01616 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6744a04655bbdcee8aa24919573d8698"></a><!-- doxytag: member="X86KvmCPU::getXCRs" ref="a6744a04655bbdcee8aa24919573d8698" args="(struct kvm_xcrs &amp;regs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getXCRs </td>
          <td>(</td>
          <td class="paramtype">struct kvm_xcrs &amp;&nbsp;</td>
          <td class="paramname"> <em>regs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l01584"></a>01584 {
<a name="l01585"></a>01585     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_GET_XCRS, &amp;regs) == -1)
<a name="l01586"></a>01586         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to get guest debug registers\n&quot;</span>);
<a name="l01587"></a>01587 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af9f89d561ce9170ad89e6582071c1169"></a><!-- doxytag: member="X86KvmCPU::getXSave" ref="af9f89d561ce9170ad89e6582071c1169" args="(struct kvm_xsave &amp;xsave) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getXSave </td>
          <td>(</td>
          <td class="paramtype">struct kvm_xsave &amp;&nbsp;</td>
          <td class="paramname"> <em>xsave</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l01598"></a>01598 {
<a name="l01599"></a>01599     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_GET_XSAVE, &amp;xsave) == -1)
<a name="l01600"></a>01600         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to get guest debug registers\n&quot;</span>);
<a name="l01601"></a>01601 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a58452f4681b53990ff7470d1884ac13c"></a><!-- doxytag: member="X86KvmCPU::handleIOMiscReg32" ref="a58452f4681b53990ff7470d1884ac13c" args="(int miscreg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handleIOMiscReg32 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>miscreg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handle a 32-bit IO access that should be mapped to a MiscReg.</p>
<dl class="note"><dt><b>覚え書き:</b></dt><dd>This method can only be called on when handling IO after a KVM_EXIT_IO.</dd></dl>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>miscreg</em>&nbsp;</td><td><a class="el" href="classRegister.html">Register</a> to map the current IO access to. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l01285"></a>01285 {
<a name="l01286"></a>01286     <span class="keyword">struct </span>kvm_run &amp;kvm_run(*<a class="code" href="classBaseKvmCPU.html#ae544593d8bd3763ec6cf4cc7d0fd614b">getKvmRunState</a>());
<a name="l01287"></a>01287     <span class="keyword">const</span> uint16_t port(kvm_run.io.port);
<a name="l01288"></a>01288 
<a name="l01289"></a>01289     assert(kvm_run.exit_reason == KVM_EXIT_IO);
<a name="l01290"></a>01290 
<a name="l01291"></a>01291     <span class="keywordflow">if</span> (kvm_run.io.size != 4) {
<a name="l01292"></a>01292         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;Unexpected IO size (%u) for address 0x%x.\n&quot;</span>,
<a name="l01293"></a>01293               kvm_run.io.size, port);
<a name="l01294"></a>01294     }
<a name="l01295"></a>01295 
<a name="l01296"></a>01296     <span class="keywordflow">if</span> (kvm_run.io.count != 1) {
<a name="l01297"></a>01297         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;Unexpected IO count (%u) for address 0x%x.\n&quot;</span>,
<a name="l01298"></a>01298               kvm_run.io.count, port);
<a name="l01299"></a>01299     }
<a name="l01300"></a>01300 
<a name="l01301"></a>01301     <a class="code" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> *data((<a class="code" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> *)<a class="code" href="classBaseKvmCPU.html#a0e5c1a55b7cce45487f5778ee272acdf">getGuestData</a>(kvm_run.io.data_offset));
<a name="l01302"></a>01302     <span class="keywordflow">if</span> (kvm_run.io.direction == KVM_EXIT_IO_OUT)
<a name="l01303"></a>01303         <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a074166dc2fe3c4aea3ad588ed9883c51">setMiscReg</a>(miscreg, *data);
<a name="l01304"></a>01304     <span class="keywordflow">else</span>
<a name="l01305"></a>01305         *data = <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a93c9c97261cb7289d5976b8222f70c4c">readMiscRegNoEffect</a>(miscreg);
<a name="l01306"></a>01306 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a404fbd80d6676724d026a932b2258dc7"></a><!-- doxytag: member="X86KvmCPU::handleKvmExitIO" ref="a404fbd80d6676724d026a932b2258dc7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> handleKvmExitIO </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handle x86 legacy IO (in/out) </p>

<p><a class="el" href="classBaseKvmCPU.html#a404fbd80d6676724d026a932b2258dc7">BaseKvmCPU</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l01310"></a>01310 {
<a name="l01311"></a>01311     <span class="keyword">struct </span>kvm_run &amp;kvm_run(*<a class="code" href="classBaseKvmCPU.html#ae544593d8bd3763ec6cf4cc7d0fd614b">getKvmRunState</a>());
<a name="l01312"></a>01312     <span class="keywordtype">bool</span> isWrite(kvm_run.io.direction == KVM_EXIT_IO_OUT);
<a name="l01313"></a>01313     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *guestData(<a class="code" href="classBaseKvmCPU.html#a0e5c1a55b7cce45487f5778ee272acdf">getGuestData</a>(kvm_run.io.data_offset));
<a name="l01314"></a>01314     <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> delay(0);
<a name="l01315"></a>01315     uint16_t port(kvm_run.io.port);
<a name="l01316"></a>01316     <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> pAddr;
<a name="l01317"></a>01317     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="namespaceX86ISA.html#a668f84c330035fdb72824eb18e09cd09">count</a>(kvm_run.io.count);
<a name="l01318"></a>01318 
<a name="l01319"></a>01319     assert(kvm_run.io.direction == KVM_EXIT_IO_IN ||
<a name="l01320"></a>01320            kvm_run.io.direction == KVM_EXIT_IO_OUT);
<a name="l01321"></a>01321 
<a name="l01322"></a>01322     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmIO, <span class="stringliteral">&quot;KVM-x86: Handling IO instruction (%s) (port: 0x%x)\n&quot;</span>,
<a name="l01323"></a>01323             (isWrite ? <span class="stringliteral">&quot;out&quot;</span> : <span class="stringliteral">&quot;in&quot;</span>), kvm_run.io.port);
<a name="l01324"></a>01324 
<a name="l01325"></a>01325     <span class="comment">/* Vanilla gem5 handles PCI discovery in the TLB(!). Since we</span>
<a name="l01326"></a>01326 <span class="comment">     * don&apos;t use the TLB component, we need to intercept and handle</span>
<a name="l01327"></a>01327 <span class="comment">     * the PCI configuration space IO ports here.</span>
<a name="l01328"></a>01328 <span class="comment">     *</span>
<a name="l01329"></a>01329 <span class="comment">     * The IO port PCI discovery mechanism uses one address register</span>
<a name="l01330"></a>01330 <span class="comment">     * and one data register. We map the address register to a misc</span>
<a name="l01331"></a>01331 <span class="comment">     * reg and use that to re-route data register accesses to the</span>
<a name="l01332"></a>01332 <span class="comment">     * right location in the PCI configuration space.</span>
<a name="l01333"></a>01333 <span class="comment">     */</span>
<a name="l01334"></a>01334     <span class="keywordflow">if</span> (port == <a class="code" href="x86__cpu_8cc.html#aa249f80ee7382ea304af9e36af7e7b36">IO_PCI_CONF_ADDR</a>) {
<a name="l01335"></a>01335         <a class="code" href="classX86KvmCPU.html#a58452f4681b53990ff7470d1884ac13c">handleIOMiscReg32</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67af11ef3cfce8ebc43fb6ee1e09fc4aa95">MISCREG_PCI_CONFIG_ADDRESS</a>);
<a name="l01336"></a>01336         <span class="keywordflow">return</span> 0;
<a name="l01337"></a>01337     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((port &amp; ~0x3) == <a class="code" href="x86__cpu_8cc.html#a5242fcbaf586dae287efe4163b97c019">IO_PCI_CONF_DATA_BASE</a>) {
<a name="l01338"></a>01338         <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> pciConfigAddr(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a93c9c97261cb7289d5976b8222f70c4c">readMiscRegNoEffect</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67af11ef3cfce8ebc43fb6ee1e09fc4aa95">MISCREG_PCI_CONFIG_ADDRESS</a>));
<a name="l01339"></a>01339         <span class="keywordflow">if</span> (pciConfigAddr &amp; 0x80000000) {
<a name="l01340"></a>01340             pAddr = <a class="code" href="namespaceX86ISA.html#a5b68d0901ef27939565621f528be9b94">X86ISA::x86PciConfigAddress</a>((pciConfigAddr &amp; 0x7ffffffc) |
<a name="l01341"></a>01341                                                 (port &amp; 0x3));
<a name="l01342"></a>01342         } <span class="keywordflow">else</span> {
<a name="l01343"></a>01343             pAddr = <a class="code" href="namespaceX86ISA.html#afaa9240a3523dc80cfb1ecfba872f27e">X86ISA::x86IOAddress</a>(port);
<a name="l01344"></a>01344         }
<a name="l01345"></a>01345     } <span class="keywordflow">else</span> {
<a name="l01346"></a>01346         pAddr = <a class="code" href="namespaceX86ISA.html#afaa9240a3523dc80cfb1ecfba872f27e">X86ISA::x86IOAddress</a>(port);
<a name="l01347"></a>01347     }
<a name="l01348"></a>01348 
<a name="l01349"></a>01349     <a class="code" href="classX86KvmCPU.html#ab9e917350d26247b9eb4153e891f348a">io_req</a>.<a class="code" href="classRequest.html#aeefca2329f8f252cd5c17463dc7f8fda">setPhys</a>(pAddr, kvm_run.io.size, <a class="code" href="classRequest.html#a0fc1d6bc92a0567b05130468e04f05f8">Request::UNCACHEABLE</a>,
<a name="l01350"></a>01350                    dataMasterId());
<a name="l01351"></a>01351 
<a name="l01352"></a>01352     <span class="keyword">const</span> <a class="code" href="classMemCmd.html">MemCmd</a> cmd(isWrite ? <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153aa5ec34a7e56b23ff12c9b819519d168a">MemCmd::WriteReq</a> : <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a96120c772a9cb695fe62ca81ec93a53b">MemCmd::ReadReq</a>);
<a name="l01353"></a>01353     <span class="comment">// Temporarily lock and migrate to the event queue of the</span>
<a name="l01354"></a>01354     <span class="comment">// VM. This queue is assumed to &quot;own&quot; all devices we need to</span>
<a name="l01355"></a>01355     <span class="comment">// access if running in multi-core mode.</span>
<a name="l01356"></a>01356     <a class="code" href="classEventQueue_1_1ScopedMigration.html">EventQueue::ScopedMigration</a> migrate(<a class="code" href="classBaseKvmCPU.html#a6b8ecd9ec419f0cbe3c1047be643fe08">vm</a>.<a class="code" href="classEventManager.html#ad6e91e91036b003cf3661959078e677f">eventQueue</a>());
<a name="l01357"></a>01357     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> = 0; <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> &lt; <a class="code" href="namespaceX86ISA.html#a668f84c330035fdb72824eb18e09cd09">count</a>; ++<a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>) {
<a name="l01358"></a>01358         <a class="code" href="classPacket.html">Packet</a> pkt(&amp;<a class="code" href="classX86KvmCPU.html#ab9e917350d26247b9eb4153e891f348a">io_req</a>, cmd);
<a name="l01359"></a>01359 
<a name="l01360"></a>01360         pkt.dataStatic(guestData);
<a name="l01361"></a>01361         delay += <a class="code" href="classBaseKvmCPU.html#a3f709bd88ed61bca6788f8cc3cda97cb">dataPort</a>.<a class="code" href="classMasterPort.html#a49fe5ebde5a0349bff76527b969b7643">sendAtomic</a>(&amp;pkt);
<a name="l01362"></a>01362 
<a name="l01363"></a>01363         guestData += kvm_run.io.size;
<a name="l01364"></a>01364     }
<a name="l01365"></a>01365 
<a name="l01366"></a>01366     <span class="keywordflow">return</span> delay;
<a name="l01367"></a>01367 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a405e34c9d079e8823ac2a1ca0e816a47"></a><!-- doxytag: member="X86KvmCPU::handleKvmExitIRQWindowOpen" ref="a405e34c9d079e8823ac2a1ca0e816a47" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> handleKvmExitIRQWindowOpen </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The guest exited because an interrupt window was requested</p>
<p>The guest exited because an interrupt window was requested (request_interrupt_window in the kvm_run structure was set to 1 before calling kvmRun) and it is now ready to receive</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Number of ticks spent servicing the IRQ </dd></dl>

<p><a class="el" href="classBaseKvmCPU.html#a405e34c9d079e8823ac2a1ca0e816a47">BaseKvmCPU</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l01371"></a>01371 {
<a name="l01372"></a>01372     <span class="comment">// We don&apos;t need to do anything here since this is caught the next</span>
<a name="l01373"></a>01373     <span class="comment">// time we execute kvmRun(). We still overload the exit event to</span>
<a name="l01374"></a>01374     <span class="comment">// silence the warning about an unhandled exit event.</span>
<a name="l01375"></a>01375     <span class="keywordflow">return</span> 0;
<a name="l01376"></a>01376 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aed3dbd0c0bf26d82ee56367a3f350506"></a><!-- doxytag: member="X86KvmCPU::kvmRun" ref="aed3dbd0c0bf26d82ee56367a3f350506" args="(Tick ticks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> kvmRun </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td>
          <td class="paramname"> <em>ticks</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classRequest.html">Request</a> KVM to run the guest for a given number of ticks. The method returns the approximate number of ticks executed.</p>
<dl class="note"><dt><b>覚え書き:</b></dt><dd>The returned number of ticks can be both larger or smaller than the requested number of ticks. A smaller number can, for example, occur when the guest executes MMIO. A larger number is typically due to performance counter inaccuracies.</dd>
<dd>
This method is virtual in order to allow implementations to check for architecture specific events (e.g., interrupts) before entering the VM.</dd>
<dd>
It is the response of the caller (normally <a class="el" href="classBaseKvmCPU.html#a873dd91783f9efb4a590aded1f70d6b0">tick()</a>) to make sure that the KVM state is synchronized and that the TC is invalidated after entering KVM.</dd>
<dd>
This method does not normally cause any state transitions. However, if it may suspend the CPU by suspending the thread, which leads to a transition to the Idle state. In such a case, kvm <em>must not</em> be entered.</dd></dl>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ticks</em>&nbsp;</td><td>Number of ticks to execute, set to 0 to exit immediately after finishing pending operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Number of ticks executed (see note) </dd></dl>

<p><a class="el" href="classBaseKvmCPU.html#aed3dbd0c0bf26d82ee56367a3f350506">BaseKvmCPU</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l01189"></a>01189 {
<a name="l01190"></a>01190     <span class="keyword">struct </span>kvm_run &amp;kvm_run(*<a class="code" href="classBaseKvmCPU.html#ae544593d8bd3763ec6cf4cc7d0fd614b">getKvmRunState</a>());
<a name="l01191"></a>01191 
<a name="l01192"></a>01192     <span class="keywordflow">if</span> (<a class="code" href="classBaseCPU.html#abb9c3a7eae9af33c74d2c7da98a171bd">interrupts</a>-&gt;checkInterruptsRaw()) {
<a name="l01193"></a>01193         <span class="keywordflow">if</span> (<a class="code" href="classBaseCPU.html#abb9c3a7eae9af33c74d2c7da98a171bd">interrupts</a>-&gt;hasPendingUnmaskable()) {
<a name="l01194"></a>01194             <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmInt,
<a name="l01195"></a>01195                     <span class="stringliteral">&quot;Delivering unmaskable interrupt.\n&quot;</span>);
<a name="l01196"></a>01196             <a class="code" href="classBaseKvmCPU.html#a5d4ee3823af24f9210efb370a4c8ce93">syncThreadContext</a>();
<a name="l01197"></a>01197             <a class="code" href="classX86KvmCPU.html#a7f9a05aa2521efe15d995cad6a739aa5">deliverInterrupts</a>();
<a name="l01198"></a>01198         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (kvm_run.ready_for_interrupt_injection) {
<a name="l01199"></a>01199             <span class="comment">// KVM claims that it is ready for an interrupt. It might</span>
<a name="l01200"></a>01200             <span class="comment">// be lying if we just updated rflags and disabled</span>
<a name="l01201"></a>01201             <span class="comment">// interrupts (e.g., by doing a CPU handover). Let&apos;s sync</span>
<a name="l01202"></a>01202             <span class="comment">// the thread context and check if there are /really/</span>
<a name="l01203"></a>01203             <span class="comment">// interrupts that should be delivered now.</span>
<a name="l01204"></a>01204             <a class="code" href="classBaseKvmCPU.html#a5d4ee3823af24f9210efb370a4c8ce93">syncThreadContext</a>();
<a name="l01205"></a>01205             <span class="keywordflow">if</span> (<a class="code" href="classBaseCPU.html#abb9c3a7eae9af33c74d2c7da98a171bd">interrupts</a>-&gt;checkInterrupts(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>)) {
<a name="l01206"></a>01206                 <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmInt,
<a name="l01207"></a>01207                         <span class="stringliteral">&quot;M5 has pending interrupts, delivering interrupt.\n&quot;</span>);
<a name="l01208"></a>01208 
<a name="l01209"></a>01209                 <a class="code" href="classX86KvmCPU.html#a7f9a05aa2521efe15d995cad6a739aa5">deliverInterrupts</a>();
<a name="l01210"></a>01210             } <span class="keywordflow">else</span> {
<a name="l01211"></a>01211                 <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmInt,
<a name="l01212"></a>01212                         <span class="stringliteral">&quot;Interrupt delivery delayed due to KVM confusion.\n&quot;</span>);
<a name="l01213"></a>01213                 kvm_run.request_interrupt_window = 1;
<a name="l01214"></a>01214             }
<a name="l01215"></a>01215         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!kvm_run.request_interrupt_window) {
<a name="l01216"></a>01216             <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmInt,
<a name="l01217"></a>01217                     <span class="stringliteral">&quot;M5 has pending interrupts, requesting interrupt &quot;</span>
<a name="l01218"></a>01218                     <span class="stringliteral">&quot;window.\n&quot;</span>);
<a name="l01219"></a>01219             kvm_run.request_interrupt_window = 1;
<a name="l01220"></a>01220         }
<a name="l01221"></a>01221     } <span class="keywordflow">else</span> {
<a name="l01222"></a>01222         kvm_run.request_interrupt_window = 0;
<a name="l01223"></a>01223     }
<a name="l01224"></a>01224 
<a name="l01225"></a>01225     <span class="comment">// The CPU might have been suspended as a result of the INIT</span>
<a name="l01226"></a>01226     <span class="comment">// interrupt delivery hack. In that case, don&apos;t enter into KVM.</span>
<a name="l01227"></a>01227     <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> == <a class="code" href="classBaseKvmCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>)
<a name="l01228"></a>01228         <span class="keywordflow">return</span> 0;
<a name="l01229"></a>01229     <span class="keywordflow">else</span>
<a name="l01230"></a>01230         <span class="keywordflow">return</span> <a class="code" href="classX86KvmCPU.html#afae1f96b6b1a482f400cd925b8709325">kvmRunWrapper</a>(ticks);
<a name="l01231"></a>01231 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a405afc17ad0dee3b816012ce909b2b6f"></a><!-- doxytag: member="X86KvmCPU::kvmRunDrain" ref="a405afc17ad0dee3b816012ce909b2b6f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> kvmRunDrain </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Run the virtual CPU until draining completes.</p>
<p>In addition to the base functionality provided by <a class="el" href="classBaseKvmCPU.html#a405afc17ad0dee3b816012ce909b2b6f">BaseKvmCPU::kvmRunDrain()</a>, this method handles x86-specific cases where there are pending interrupt events in the virtual CPU. These are handled by requesting an interrupt window if interrupts are pending (causing the vCPU to execute until interrupts can be delivered again).</p>
<dl class="see"><dt><b>参照:</b></dt><dd><a class="el" href="classBaseKvmCPU.html#a405afc17ad0dee3b816012ce909b2b6f">BaseKvmCPU::kvmRunDrain()</a> </dd>
<dd>
<a class="el" href="classX86KvmCPU.html#a1d97c7e0665d576bb463335078bb02ec">archIsDrained()</a></dd></dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Number of ticks executed </dd></dl>

<p><a class="el" href="classBaseKvmCPU.html#a405afc17ad0dee3b816012ce909b2b6f">BaseKvmCPU</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l01235"></a>01235 {
<a name="l01236"></a>01236     <span class="keyword">struct </span>kvm_run &amp;kvm_run(*<a class="code" href="classBaseKvmCPU.html#ae544593d8bd3763ec6cf4cc7d0fd614b">getKvmRunState</a>());
<a name="l01237"></a>01237 
<a name="l01238"></a>01238     <span class="keywordflow">if</span> (!<a class="code" href="classX86KvmCPU.html#a1d97c7e0665d576bb463335078bb02ec">archIsDrained</a>()) {
<a name="l01239"></a>01239         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;kvmRunDrain: Architecture code isn&apos;t drained\n&quot;</span>);
<a name="l01240"></a>01240 
<a name="l01241"></a>01241         <span class="comment">// Tell KVM to find a suitable place to deliver interrupts. This</span>
<a name="l01242"></a>01242         <span class="comment">// should ensure that pending interrupts have been delivered and</span>
<a name="l01243"></a>01243         <span class="comment">// things are reasonably consistent (i.e., no interrupts pending</span>
<a name="l01244"></a>01244         <span class="comment">// in the guest).</span>
<a name="l01245"></a>01245         kvm_run.request_interrupt_window = 1;
<a name="l01246"></a>01246 
<a name="l01247"></a>01247         <span class="comment">// Limit the run to 1 millisecond. That is hopefully enough to</span>
<a name="l01248"></a>01248         <span class="comment">// reach an interrupt window. Otherwise, we&apos;ll just try again</span>
<a name="l01249"></a>01249         <span class="comment">// later.</span>
<a name="l01250"></a>01250         <span class="keywordflow">return</span> <a class="code" href="classX86KvmCPU.html#afae1f96b6b1a482f400cd925b8709325">kvmRunWrapper</a>(1 * <a class="code" href="namespaceSimClock_1_1Float.html#ac0c30c1e98c242e3e868c424886912e5" title="millisecond">SimClock::Float::ms</a>);
<a name="l01251"></a>01251     } <span class="keywordflow">else</span> {
<a name="l01252"></a>01252         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;kvmRunDrain: Delivering pending IO\n&quot;</span>);
<a name="l01253"></a>01253 
<a name="l01254"></a>01254         <span class="keywordflow">return</span> <a class="code" href="classX86KvmCPU.html#afae1f96b6b1a482f400cd925b8709325">kvmRunWrapper</a>(0);
<a name="l01255"></a>01255     }
<a name="l01256"></a>01256 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="afae1f96b6b1a482f400cd925b8709325"></a><!-- doxytag: member="X86KvmCPU::kvmRunWrapper" ref="afae1f96b6b1a482f400cd925b8709325" args="(Tick ticks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> kvmRunWrapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td>
          <td class="paramname"> <em>ticks</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wrapper that synchronizes state in kvm_run </p>

<p><div class="fragment"><pre class="fragment"><a name="l01260"></a>01260 {
<a name="l01261"></a>01261     <span class="keyword">struct </span>kvm_run &amp;kvm_run(*<a class="code" href="classBaseKvmCPU.html#ae544593d8bd3763ec6cf4cc7d0fd614b">getKvmRunState</a>());
<a name="l01262"></a>01262 
<a name="l01263"></a>01263     <span class="comment">// Synchronize the APIC base and CR8 here since they are present</span>
<a name="l01264"></a>01264     <span class="comment">// in the kvm_run struct, which makes the synchronization really</span>
<a name="l01265"></a>01265     <span class="comment">// cheap.</span>
<a name="l01266"></a>01266     kvm_run.apic_base = <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a6888f4bff21e34892e59654ea80073b2">readMiscReg</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67aa140419207c4efa0ada78f30ac3e5589">MISCREG_APIC_BASE</a>);
<a name="l01267"></a>01267     kvm_run.cr8 = <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a6888f4bff21e34892e59654ea80073b2">readMiscReg</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67a57090203dc471731ffa4ac498cc41078">MISCREG_CR8</a>);
<a name="l01268"></a>01268 
<a name="l01269"></a>01269     <span class="keyword">const</span> <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> run_ticks(<a class="code" href="classBaseKvmCPU.html#aed3dbd0c0bf26d82ee56367a3f350506">BaseKvmCPU::kvmRun</a>(ticks));
<a name="l01270"></a>01270 
<a name="l01271"></a>01271     <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a074166dc2fe3c4aea3ad588ed9883c51">setMiscReg</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67aa140419207c4efa0ada78f30ac3e5589">MISCREG_APIC_BASE</a>, kvm_run.apic_base);
<a name="l01272"></a>01272     kvm_run.cr8 = <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a6888f4bff21e34892e59654ea80073b2">readMiscReg</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67a57090203dc471731ffa4ac498cc41078">MISCREG_CR8</a>);
<a name="l01273"></a>01273 
<a name="l01274"></a>01274     <span class="keywordflow">return</span> run_ticks;
<a name="l01275"></a>01275 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6782fae08bf69ed6903f49bfbee81566"></a><!-- doxytag: member="X86KvmCPU::setCPUID" ref="a6782fae08bf69ed6903f49bfbee81566" args="(const Kvm::CPUIDVector &amp;cpuid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setCPUID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1vector.html">Kvm::CPUIDVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cpuid</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l01469"></a>01469 {
<a name="l01470"></a>01470     std::unique_ptr&lt;struct kvm_cpuid2&gt; kvm_cpuid(
<a name="l01471"></a>01471         newVarStruct&lt;struct kvm_cpuid2, struct kvm_cpuid_entry2&gt;(cpuid.size()));
<a name="l01472"></a>01472 
<a name="l01473"></a>01473     kvm_cpuid-&gt;nent = cpuid.size();
<a name="l01474"></a>01474     std::copy(cpuid.begin(), cpuid.end(), kvm_cpuid-&gt;entries);
<a name="l01475"></a>01475 
<a name="l01476"></a>01476     <a class="code" href="classX86KvmCPU.html#ae1aa75790696eb8780d159812f607921">setCPUID</a>(*kvm_cpuid);
<a name="l01477"></a>01477 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae1aa75790696eb8780d159812f607921"></a><!-- doxytag: member="X86KvmCPU::setCPUID" ref="ae1aa75790696eb8780d159812f607921" args="(const struct kvm_cpuid2 &amp;cpuid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setCPUID </td>
          <td>(</td>
          <td class="paramtype">const struct kvm_cpuid2 &amp;&nbsp;</td>
          <td class="paramname"> <em>cpuid</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Methods to access CPUID information using the extended API. Only available if <a class="el" href="classKvm.html#a6db5aefbe1a9535f5124ef07a04e23a5">Kvm::capExtendedCPUID()</a> is true. </p>

<p><div class="fragment"><pre class="fragment"><a name="l01461"></a>01461 {
<a name="l01462"></a>01462     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_SET_CPUID2, (<span class="keywordtype">void</span> *)&amp;<a class="code" href="namespaceMipsISA.html#ad8c57e94aa3e790a8d7259e5b798123b">cpuid</a>) == -1)
<a name="l01463"></a>01463         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to set guest CPUID2 (errno: %i)\n&quot;</span>,
<a name="l01464"></a>01464               errno);
<a name="l01465"></a>01465 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0c0b94046f41e2b83c8f224e9f227d0f"></a><!-- doxytag: member="X86KvmCPU::setDebugRegisters" ref="a0c0b94046f41e2b83c8f224e9f227d0f" args="(const struct kvm_debugregs &amp;regs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setDebugRegisters </td>
          <td>(</td>
          <td class="paramtype">const struct kvm_debugregs &amp;&nbsp;</td>
          <td class="paramname"> <em>regs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l01573"></a>01573 {
<a name="l01574"></a>01574 <span class="preprocessor">#ifdef KVM_SET_DEBUGREGS</span>
<a name="l01575"></a>01575 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_SET_DEBUGREGS, (<span class="keywordtype">void</span> *)&amp;regs) == -1)
<a name="l01576"></a>01576         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to set guest debug registers\n&quot;</span>);
<a name="l01577"></a>01577 <span class="preprocessor">#else</span>
<a name="l01578"></a>01578 <span class="preprocessor"></span>    <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Unsupported setDebugRegisters call.\n&quot;</span>);
<a name="l01579"></a>01579 <span class="preprocessor">#endif</span>
<a name="l01580"></a>01580 <span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3d32029e1dfb4da512897794d56e9fc8"></a><!-- doxytag: member="X86KvmCPU::setMSR" ref="a3d32029e1dfb4da512897794d56e9fc8" args="(uint32_t index, uint64_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setMSR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l01510"></a>01510 {
<a name="l01511"></a>01511     std::unique_ptr&lt;struct kvm_msrs&gt; kvm_msrs(
<a name="l01512"></a>01512         newVarStruct&lt;struct kvm_msrs, struct kvm_msr_entry&gt;(1));
<a name="l01513"></a>01513     <span class="keyword">struct </span>kvm_msr_entry &amp;entry(kvm_msrs-&gt;entries[0]);
<a name="l01514"></a>01514 
<a name="l01515"></a>01515     kvm_msrs-&gt;nmsrs = 1;
<a name="l01516"></a>01516     entry.index = <a class="code" href="namespaceMipsISA.html#ae6714ce3c5ef82205cecbd410556edf3">index</a>;
<a name="l01517"></a>01517     entry.reserved = 0;
<a name="l01518"></a>01518     entry.data = <a class="code" href="namespacegenini.html#a7e5f482a3a8a4f98bd1a9c124485f572">value</a>;
<a name="l01519"></a>01519 
<a name="l01520"></a>01520     <a class="code" href="classX86KvmCPU.html#a37c723660e4a4aa0ebb42ee498df990b">setMSRs</a>(*kvm_msrs.get());
<a name="l01521"></a>01521 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="acc0ac79f886623c5e0ce73b393402148"></a><!-- doxytag: member="X86KvmCPU::setMSRs" ref="acc0ac79f886623c5e0ce73b393402148" args="(const KvmMSRVector &amp;msrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setMSRs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1vector.html">KvmMSRVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>msrs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l01489"></a>01489 {
<a name="l01490"></a>01490     std::unique_ptr&lt;struct kvm_msrs&gt; kvm_msrs(
<a name="l01491"></a>01491         newVarStruct&lt;struct kvm_msrs, struct kvm_msr_entry&gt;(msrs.size()));
<a name="l01492"></a>01492 
<a name="l01493"></a>01493     kvm_msrs-&gt;nmsrs = msrs.size();
<a name="l01494"></a>01494     std::copy(msrs.begin(), msrs.end(), kvm_msrs-&gt;entries);
<a name="l01495"></a>01495 
<a name="l01496"></a>01496     <a class="code" href="classX86KvmCPU.html#a37c723660e4a4aa0ebb42ee498df990b">setMSRs</a>(*kvm_msrs);
<a name="l01497"></a>01497 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a37c723660e4a4aa0ebb42ee498df990b"></a><!-- doxytag: member="X86KvmCPU::setMSRs" ref="a37c723660e4a4aa0ebb42ee498df990b" args="(const struct kvm_msrs &amp;msrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setMSRs </td>
          <td>(</td>
          <td class="paramtype">const struct kvm_msrs &amp;&nbsp;</td>
          <td class="paramname"> <em>msrs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Methods to access MSRs in the guest. </p>

<p><div class="fragment"><pre class="fragment"><a name="l01481"></a>01481 {
<a name="l01482"></a>01482     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_SET_MSRS, (<span class="keywordtype">void</span> *)&amp;msrs) == -1)
<a name="l01483"></a>01483         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to set guest MSRs (errno: %i)\n&quot;</span>,
<a name="l01484"></a>01484               errno);
<a name="l01485"></a>01485 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a70cfa7f84580af5396fbc82f540c8a5b"></a><!-- doxytag: member="X86KvmCPU::setVCpuEvents" ref="a70cfa7f84580af5396fbc82f540c8a5b" args="(const struct kvm_vcpu_events &amp;events)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setVCpuEvents </td>
          <td>(</td>
          <td class="paramtype">const struct kvm_vcpu_events &amp;&nbsp;</td>
          <td class="paramname"> <em>events</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l01620"></a>01620 {
<a name="l01621"></a>01621     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_SET_VCPU_EVENTS, (<span class="keywordtype">void</span> *)&amp;events) == -1)
<a name="l01622"></a>01622         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to set guest debug registers\n&quot;</span>);
<a name="l01623"></a>01623 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a929420a323cb83ab21bdf3efa22edd24"></a><!-- doxytag: member="X86KvmCPU::setXCRs" ref="a929420a323cb83ab21bdf3efa22edd24" args="(const struct kvm_xcrs &amp;regs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setXCRs </td>
          <td>(</td>
          <td class="paramtype">const struct kvm_xcrs &amp;&nbsp;</td>
          <td class="paramname"> <em>regs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l01591"></a>01591 {
<a name="l01592"></a>01592     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_SET_XCRS, (<span class="keywordtype">void</span> *)&amp;regs) == -1)
<a name="l01593"></a>01593         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to set guest debug registers\n&quot;</span>);
<a name="l01594"></a>01594 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa05e7c39fbe7374815b387728b7de06d"></a><!-- doxytag: member="X86KvmCPU::setXSave" ref="aa05e7c39fbe7374815b387728b7de06d" args="(const struct kvm_xsave &amp;xsave)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setXSave </td>
          <td>(</td>
          <td class="paramtype">const struct kvm_xsave &amp;&nbsp;</td>
          <td class="paramname"> <em>xsave</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l01605"></a>01605 {
<a name="l01606"></a>01606     <span class="keywordflow">if</span> (<a class="code" href="group__KvmIoctl.html#ga106fe09b5e87d6c14884f8ffff7b338a">ioctl</a>(KVM_SET_XSAVE, (<span class="keywordtype">void</span> *)&amp;xsave) == -1)
<a name="l01607"></a>01607         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;KVM: Failed to set guest debug registers\n&quot;</span>);
<a name="l01608"></a>01608 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aecc7d8debf54990ffeaaed5bac7d7d81"></a><!-- doxytag: member="X86KvmCPU::startup" ref="aecc7d8debf54990ffeaaed5bac7d7d81" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void startup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classBaseKvmCPU.html#aecc7d8debf54990ffeaaed5bac7d7d81">BaseKvmCPU</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00552"></a>00552 {
<a name="l00553"></a>00553     <a class="code" href="classX86KvmCPU.html#aecc7d8debf54990ffeaaed5bac7d7d81">BaseKvmCPU::startup</a>();
<a name="l00554"></a>00554 
<a name="l00555"></a>00555     <a class="code" href="classX86KvmCPU.html#adcec996536ccdb020b08a11d61a47d44">updateCPUID</a>();
<a name="l00556"></a>00556 
<a name="l00557"></a>00557     <a class="code" href="classX86KvmCPU.html#ab9e917350d26247b9eb4153e891f348a">io_req</a>.<a class="code" href="classRequest.html#a40574dadf22fb92b4966eb9815da7575">setThreadContext</a>(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a5a3ce3f955d2ec16ac6f2aa21e42f3a0">contextId</a>(), 0);
<a name="l00558"></a>00558 
<a name="l00559"></a>00559     <span class="comment">// TODO: Do we need to create an identity mapped TSS area? We</span>
<a name="l00560"></a>00560     <span class="comment">// should call kvm.vm.setTSSAddress() here in that case. It should</span>
<a name="l00561"></a>00561     <span class="comment">// only be needed for old versions of the virtualization</span>
<a name="l00562"></a>00562     <span class="comment">// extensions. We should make sure that the identity range is</span>
<a name="l00563"></a>00563     <span class="comment">// reserved in the e820 memory map in that case.</span>
<a name="l00564"></a>00564 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="adcec996536ccdb020b08a11d61a47d44"></a><!-- doxytag: member="X86KvmCPU::updateCPUID" ref="adcec996536ccdb020b08a11d61a47d44" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateCPUID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transfer gem5's CPUID values into the virtual CPU. </p>

<p><div class="fragment"><pre class="fragment"><a name="l01425"></a>01425 {
<a name="l01426"></a>01426     <a class="code" href="classstd_1_1vector.html">Kvm::CPUIDVector</a> m5_supported;
<a name="l01427"></a>01427 
<a name="l01428"></a>01428     <span class="comment">/* TODO: We currently don&apos;t support any of the functions that</span>
<a name="l01429"></a>01429 <span class="comment">     * iterate through data structures in the CPU using an index. It&apos;s</span>
<a name="l01430"></a>01430 <span class="comment">     * currently not a problem since M5 doesn&apos;t expose any of them at</span>
<a name="l01431"></a>01431 <span class="comment">     * the moment.</span>
<a name="l01432"></a>01432 <span class="comment">     */</span>
<a name="l01433"></a>01433 
<a name="l01434"></a>01434     <span class="comment">/* Basic features */</span>
<a name="l01435"></a>01435     <a class="code" href="structX86ISA_1_1CpuidResult.html">CpuidResult</a> func0;
<a name="l01436"></a>01436     <a class="code" href="namespaceX86ISA.html#a1cf7354b42b56aa483040caaa06d7be4">X86ISA::doCpuid</a>(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>, 0x0, 0, func0);
<a name="l01437"></a>01437     <span class="keywordflow">for</span> (<a class="code" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> function = 0; function &lt;= func0.<a class="code" href="structX86ISA_1_1CpuidResult.html#afae317c0ec04889d6c9452dc30711975">rax</a>; ++function) {
<a name="l01438"></a>01438         <a class="code" href="structX86ISA_1_1CpuidResult.html">CpuidResult</a> <a class="code" href="namespaceMipsISA.html#ad8c57e94aa3e790a8d7259e5b798123b">cpuid</a>;
<a name="l01439"></a>01439         <a class="code" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> idx(0);
<a name="l01440"></a>01440 
<a name="l01441"></a>01441         <a class="code" href="namespaceX86ISA.html#a1cf7354b42b56aa483040caaa06d7be4">X86ISA::doCpuid</a>(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>, function, idx, cpuid);
<a name="l01442"></a>01442         m5_supported.push_back(<a class="code" href="x86__cpu_8cc.html#a8e529a8d690941d970b53028ee411ec2">makeKvmCpuid</a>(function, idx, cpuid));
<a name="l01443"></a>01443     }
<a name="l01444"></a>01444 
<a name="l01445"></a>01445     <span class="comment">/* Extended features */</span>
<a name="l01446"></a>01446     <a class="code" href="structX86ISA_1_1CpuidResult.html">CpuidResult</a> efunc0;
<a name="l01447"></a>01447     <a class="code" href="namespaceX86ISA.html#a1cf7354b42b56aa483040caaa06d7be4">X86ISA::doCpuid</a>(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>, 0x80000000, 0, efunc0);
<a name="l01448"></a>01448     <span class="keywordflow">for</span> (<a class="code" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> function = 0x80000000; function &lt;= efunc0.<a class="code" href="structX86ISA_1_1CpuidResult.html#afae317c0ec04889d6c9452dc30711975">rax</a>; ++function) {
<a name="l01449"></a>01449         <a class="code" href="structX86ISA_1_1CpuidResult.html">CpuidResult</a> cpuid;
<a name="l01450"></a>01450         <a class="code" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> idx(0);
<a name="l01451"></a>01451 
<a name="l01452"></a>01452         <a class="code" href="namespaceX86ISA.html#a1cf7354b42b56aa483040caaa06d7be4">X86ISA::doCpuid</a>(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>, function, idx, cpuid);
<a name="l01453"></a>01453         m5_supported.push_back(<a class="code" href="x86__cpu_8cc.html#a8e529a8d690941d970b53028ee411ec2">makeKvmCpuid</a>(function, idx, cpuid));
<a name="l01454"></a>01454     }
<a name="l01455"></a>01455 
<a name="l01456"></a>01456     <a class="code" href="classX86KvmCPU.html#ae1aa75790696eb8780d159812f607921">setCPUID</a>(m5_supported);
<a name="l01457"></a>01457 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a93c6e8c82dfb63c7039f0cbf064fae5d"></a><!-- doxytag: member="X86KvmCPU::updateKvmState" ref="a93c6e8c82dfb63c7039f0cbf064fae5d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateKvmState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update the KVM state from the current thread context</p>
<p>The base CPU calls this method before starting the guest CPU when the contextDirty flag is set. The architecture dependent CPU implementation is expected to update all guest state (registers, special registers, and FPU state). </p>

<p><a class="el" href="classBaseKvmCPU.html#a48817be7bf03ef44cc5114ecf4df9b27">BaseKvmCPU</a>を実装しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00673"></a>00673 {
<a name="l00674"></a>00674     <a class="code" href="classX86KvmCPU.html#a54e3879c7bcd8aac9d1b88350e7674fe">updateKvmStateRegs</a>();
<a name="l00675"></a>00675     <a class="code" href="classX86KvmCPU.html#af58754cb34827756e0e0fc8474c54a8e">updateKvmStateSRegs</a>();
<a name="l00676"></a>00676     <a class="code" href="classX86KvmCPU.html#a1c8ff9ec0ad33f11a2212a37e2a79f6c">updateKvmStateFPU</a>();
<a name="l00677"></a>00677     <a class="code" href="classX86KvmCPU.html#ad04202aafaacd818cf2621c5a31926c1">updateKvmStateMSRs</a>();
<a name="l00678"></a>00678 
<a name="l00679"></a>00679     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmContext, <span class="stringliteral">&quot;X86KvmCPU::updateKvmState():\n&quot;</span>);
<a name="l00680"></a>00680     <span class="keywordflow">if</span> (<a class="code" href="trace_8hh.html#af76c9f7776aade1bf9d7dfa8a0c6b341">DTRACE</a>(KvmContext))
<a name="l00681"></a>00681         <a class="code" href="classX86KvmCPU.html#accd2600060dbaee3a3b41aed4034c63c">dump</a>();
<a name="l00682"></a>00682 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1c8ff9ec0ad33f11a2212a37e2a79f6c"></a><!-- doxytag: member="X86KvmCPU::updateKvmStateFPU" ref="a1c8ff9ec0ad33f11a2212a37e2a79f6c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateKvmStateFPU </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update FPU and SIMD registers</p>
<p>This method uses the appropriate (depending on availability and user configuration) kernel API by calling <a class="el" href="classX86KvmCPU.html#a3eccabf97e73ee194068ee37c2422c50">updateKvmStateFPULegacy()</a> or <a class="el" href="classX86KvmCPU.html#aa1d3c8572c67dd0c4457ba46307f35f1">updateKvmStateFPUXSave()</a>.</p>
<dl class="see"><dt><b>参照:</b></dt><dd><a class="el" href="classX86KvmCPU.html#a3eccabf97e73ee194068ee37c2422c50">updateKvmStateFPULegacy()</a> </dd>
<dd>
<a class="el" href="classX86KvmCPU.html#aa1d3c8572c67dd0c4457ba46307f35f1">updateKvmStateFPUXSave()</a> </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00907"></a>00907 {
<a name="l00908"></a>00908     <span class="keywordflow">if</span> (<a class="code" href="classX86KvmCPU.html#ab966ae6cc1b380746dcb2713f2559e65">useXSave</a>)
<a name="l00909"></a>00909         <a class="code" href="classX86KvmCPU.html#aa1d3c8572c67dd0c4457ba46307f35f1">updateKvmStateFPUXSave</a>();
<a name="l00910"></a>00910     <span class="keywordflow">else</span>
<a name="l00911"></a>00911         <a class="code" href="classX86KvmCPU.html#a3eccabf97e73ee194068ee37c2422c50">updateKvmStateFPULegacy</a>();
<a name="l00912"></a>00912 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3eccabf97e73ee194068ee37c2422c50"></a><!-- doxytag: member="X86KvmCPU::updateKvmStateFPULegacy" ref="a3eccabf97e73ee194068ee37c2422c50" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateKvmStateFPULegacy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update FPU and SIMD registers using the legacy API</p>
<dl class="note"><dt><b>覚え書き:</b></dt><dd>This method should normally only be called by <a class="el" href="classX86KvmCPU.html#a1c8ff9ec0ad33f11a2212a37e2a79f6c">updateKvmStateFPU()</a> which automatically chooses between available APIs. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00858"></a>00858 {
<a name="l00859"></a>00859     <span class="keyword">struct </span>kvm_fpu fpu;
<a name="l00860"></a>00860 
<a name="l00861"></a>00861     <span class="comment">// There is some padding in the FP registers, so we&apos;d better zero</span>
<a name="l00862"></a>00862     <span class="comment">// the whole struct.</span>
<a name="l00863"></a>00863     memset(&amp;fpu, 0, <span class="keyword">sizeof</span>(fpu));
<a name="l00864"></a>00864 
<a name="l00865"></a>00865     <a class="code" href="x86__cpu_8cc.html#af4646df895fd6ad546cfecaa85e782b7">updateKvmStateFPUCommon</a>(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>, fpu);
<a name="l00866"></a>00866 
<a name="l00867"></a>00867     <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a93c9c97261cb7289d5976b8222f70c4c">readMiscRegNoEffect</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67ac5bcbd25eb560d0d3d6f06b645e39beb">MISCREG_FISEG</a>))
<a name="l00868"></a>00868         <a class="code" href="base_2misc_8hh.html#abb243c15dfbeedf4ae64aa213f4f18c7">warn_once</a>(<span class="stringliteral">&quot;MISCREG_FISEG is non-zero.\n&quot;</span>);
<a name="l00869"></a>00869 
<a name="l00870"></a>00870     fpu.last_ip = <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a93c9c97261cb7289d5976b8222f70c4c">readMiscRegNoEffect</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67a121b73c40eb70a2a9c1354b57586f06e">MISCREG_FIOFF</a>);
<a name="l00871"></a>00871 
<a name="l00872"></a>00872     <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a93c9c97261cb7289d5976b8222f70c4c">readMiscRegNoEffect</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67a2e12b574e8a93bb82790999af16b87a0">MISCREG_FOSEG</a>))
<a name="l00873"></a>00873         <a class="code" href="base_2misc_8hh.html#abb243c15dfbeedf4ae64aa213f4f18c7">warn_once</a>(<span class="stringliteral">&quot;MISCREG_FOSEG is non-zero.\n&quot;</span>);
<a name="l00874"></a>00874 
<a name="l00875"></a>00875     fpu.last_dp = <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a93c9c97261cb7289d5976b8222f70c4c">readMiscRegNoEffect</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67abd62775859320efc4c0996116c7b2d03">MISCREG_FOOFF</a>);
<a name="l00876"></a>00876 
<a name="l00877"></a>00877     <a class="code" href="classBaseKvmCPU.html#a31b5d1e73edb46a17fa0a8ddd29e7604">setFPUState</a>(fpu);
<a name="l00878"></a>00878 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa1d3c8572c67dd0c4457ba46307f35f1"></a><!-- doxytag: member="X86KvmCPU::updateKvmStateFPUXSave" ref="aa1d3c8572c67dd0c4457ba46307f35f1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateKvmStateFPUXSave </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update FPU and SIMD registers using the XSave API</p>
<dl class="note"><dt><b>覚え書き:</b></dt><dd>This method should normally only be called by <a class="el" href="classX86KvmCPU.html#a1c8ff9ec0ad33f11a2212a37e2a79f6c">updateKvmStateFPU()</a> which automatically chooses between available APIs. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00882"></a>00882 {
<a name="l00883"></a>00883     <span class="keyword">struct </span>kvm_xsave kxsave;
<a name="l00884"></a>00884     <a class="code" href="structFXSave.html">FXSave</a> &amp;xsave(*(<a class="code" href="structFXSave.html">FXSave</a> *)kxsave.region);
<a name="l00885"></a>00885 
<a name="l00886"></a>00886     <span class="comment">// There is some padding and reserved fields in the structure, so</span>
<a name="l00887"></a>00887     <span class="comment">// we&apos;d better zero the whole thing.</span>
<a name="l00888"></a>00888     memset(&amp;kxsave, 0, <span class="keyword">sizeof</span>(kxsave));
<a name="l00889"></a>00889 
<a name="l00890"></a>00890     <a class="code" href="x86__cpu_8cc.html#af4646df895fd6ad546cfecaa85e782b7">updateKvmStateFPUCommon</a>(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>, xsave);
<a name="l00891"></a>00891 
<a name="l00892"></a>00892     <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a93c9c97261cb7289d5976b8222f70c4c">readMiscRegNoEffect</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67ac5bcbd25eb560d0d3d6f06b645e39beb">MISCREG_FISEG</a>))
<a name="l00893"></a>00893         <a class="code" href="base_2misc_8hh.html#abb243c15dfbeedf4ae64aa213f4f18c7">warn_once</a>(<span class="stringliteral">&quot;MISCREG_FISEG is non-zero.\n&quot;</span>);
<a name="l00894"></a>00894 
<a name="l00895"></a>00895     xsave.ctrl64.fpu_ip = <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a93c9c97261cb7289d5976b8222f70c4c">readMiscRegNoEffect</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67a121b73c40eb70a2a9c1354b57586f06e">MISCREG_FIOFF</a>);
<a name="l00896"></a>00896 
<a name="l00897"></a>00897     <span class="keywordflow">if</span> (<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a93c9c97261cb7289d5976b8222f70c4c">readMiscRegNoEffect</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67a2e12b574e8a93bb82790999af16b87a0">MISCREG_FOSEG</a>))
<a name="l00898"></a>00898         <a class="code" href="base_2misc_8hh.html#abb243c15dfbeedf4ae64aa213f4f18c7">warn_once</a>(<span class="stringliteral">&quot;MISCREG_FOSEG is non-zero.\n&quot;</span>);
<a name="l00899"></a>00899 
<a name="l00900"></a>00900     xsave.ctrl64.fpu_dp = <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a93c9c97261cb7289d5976b8222f70c4c">readMiscRegNoEffect</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67abd62775859320efc4c0996116c7b2d03">MISCREG_FOOFF</a>);
<a name="l00901"></a>00901 
<a name="l00902"></a>00902     <a class="code" href="classX86KvmCPU.html#aa05e7c39fbe7374815b387728b7de06d">setXSave</a>(kxsave);
<a name="l00903"></a>00903 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad04202aafaacd818cf2621c5a31926c1"></a><!-- doxytag: member="X86KvmCPU::updateKvmStateMSRs" ref="ad04202aafaacd818cf2621c5a31926c1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateKvmStateMSRs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update MSR registers </p>

<p><div class="fragment"><pre class="fragment"><a name="l00916"></a>00916 {
<a name="l00917"></a>00917     <a class="code" href="classX86KvmCPU.html#aa498445286177d1e3901b007c40f52c9">KvmMSRVector</a> msrs;
<a name="l00918"></a>00918 
<a name="l00919"></a>00919     <span class="keyword">const</span> <a class="code" href="classstd_1_1vector.html">Kvm::MSRIndexVector</a> &amp;indices(<a class="code" href="classX86KvmCPU.html#abab51da6ec6a0f14d2dde6b0857b7b34">getMsrIntersection</a>());
<a name="l00920"></a>00920 
<a name="l00921"></a>00921     <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = indices.cbegin(); it != indices.cend(); ++it) {
<a name="l00922"></a>00922         <span class="keyword">struct </span>kvm_msr_entry <a class="code" href="namespaceArmISA.html#a55520507919005a961edbe8b177f3bba">e</a>;
<a name="l00923"></a>00923 
<a name="l00924"></a>00924         <a class="code" href="namespaceArmISA.html#a55520507919005a961edbe8b177f3bba">e</a>.index = *it;
<a name="l00925"></a>00925         <a class="code" href="namespaceArmISA.html#a55520507919005a961edbe8b177f3bba">e</a>.reserved = 0;
<a name="l00926"></a>00926         <a class="code" href="namespaceArmISA.html#a55520507919005a961edbe8b177f3bba">e</a>.data = <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a6888f4bff21e34892e59654ea80073b2">readMiscReg</a>(<a class="code" href="namespaceX86ISA.html#a668a095a9f8f9c629c5b12ff0bb8a721">msrMap</a>.at(*it));
<a name="l00927"></a>00927         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmContext, <span class="stringliteral">&quot;Adding MSR: idx: 0x%x, data: 0x%x\n&quot;</span>,
<a name="l00928"></a>00928                 <a class="code" href="namespaceArmISA.html#a55520507919005a961edbe8b177f3bba">e</a>.index, <a class="code" href="namespaceArmISA.html#a55520507919005a961edbe8b177f3bba">e</a>.data);
<a name="l00929"></a>00929 
<a name="l00930"></a>00930         msrs.push_back(<a class="code" href="namespaceArmISA.html#a55520507919005a961edbe8b177f3bba">e</a>);
<a name="l00931"></a>00931     }
<a name="l00932"></a>00932 
<a name="l00933"></a>00933     <a class="code" href="classX86KvmCPU.html#a37c723660e4a4aa0ebb42ee498df990b">setMSRs</a>(msrs);
<a name="l00934"></a>00934 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a54e3879c7bcd8aac9d1b88350e7674fe"></a><!-- doxytag: member="X86KvmCPU::updateKvmStateRegs" ref="a54e3879c7bcd8aac9d1b88350e7674fe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateKvmStateRegs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Support routines to update the state of the KVM CPU from gem5's state representation. Update integer registers </p>

<p><div class="fragment"><pre class="fragment"><a name="l00686"></a>00686 {
<a name="l00687"></a>00687     <span class="keyword">struct </span>kvm_regs regs;
<a name="l00688"></a>00688 
<a name="l00689"></a>00689 <span class="preprocessor">#define APPLY_IREG(kreg, mreg) regs.kreg = tc-&gt;readIntReg(mreg)</span>
<a name="l00690"></a>00690 <span class="preprocessor"></span>    <a class="code" href="x86__cpu_8cc.html#a1b70a9e03d3e57124b5ec691a3de8720">FOREACH_IREG</a>();
<a name="l00691"></a>00691 <span class="preprocessor">#undef APPLY_IREG</span>
<a name="l00692"></a>00692 <span class="preprocessor"></span>
<a name="l00693"></a>00693     regs.rip = <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a899644592f5027a7951cfd87b1c548a2">instAddr</a>() - <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a6888f4bff21e34892e59654ea80073b2">readMiscReg</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67a60be9e9eab83bbcfe1b0c55eafaaabcd">MISCREG_CS_BASE</a>);
<a name="l00694"></a>00694 
<a name="l00695"></a>00695     <span class="comment">/* You might think that setting regs.rflags to the contents</span>
<a name="l00696"></a>00696 <span class="comment">     * MISCREG_RFLAGS here would suffice. In that case you&apos;re</span>
<a name="l00697"></a>00697 <span class="comment">     * mistaken. We need to reconstruct it from a bunch of ucode</span>
<a name="l00698"></a>00698 <span class="comment">     * registers and wave a dead chicken over it (aka mask out and set</span>
<a name="l00699"></a>00699 <span class="comment">     * reserved bits) to get it to work.</span>
<a name="l00700"></a>00700 <span class="comment">     */</span>
<a name="l00701"></a>00701     regs.rflags = <a class="code" href="namespaceX86ISA.html#ab5e0d51a18a3bce3397edd01a4b51492">X86ISA::getRFlags</a>(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>);
<a name="l00702"></a>00702 
<a name="l00703"></a>00703     <a class="code" href="classBaseKvmCPU.html#a104d34588afdf9e14607bad09f01bd53">setRegisters</a>(regs);
<a name="l00704"></a>00704 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af58754cb34827756e0e0fc8474c54a8e"></a><!-- doxytag: member="X86KvmCPU::updateKvmStateSRegs" ref="af58754cb34827756e0e0fc8474c54a8e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateKvmStateSRegs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update control registers (CRx, segments, etc.) </p>

<p><div class="fragment"><pre class="fragment"><a name="l00753"></a>00753 {
<a name="l00754"></a>00754     <span class="keyword">struct </span>kvm_sregs sregs;
<a name="l00755"></a>00755 
<a name="l00756"></a>00756 <span class="preprocessor">#define APPLY_SREG(kreg, mreg) sregs.kreg = tc-&gt;readMiscRegNoEffect(mreg)</span>
<a name="l00757"></a>00757 <span class="preprocessor"></span><span class="preprocessor">#define APPLY_SEGMENT(kreg, idx) setKvmSegmentReg(tc, sregs.kreg, idx)</span>
<a name="l00758"></a>00758 <span class="preprocessor"></span><span class="preprocessor">#define APPLY_DTABLE(kreg, idx) setKvmDTableReg(tc, sregs.kreg, idx)</span>
<a name="l00759"></a>00759 <span class="preprocessor"></span>
<a name="l00760"></a>00760     <a class="code" href="x86__cpu_8cc.html#aa90701ca0a4e8e76a8fe2e712b1435a2">FOREACH_SREG</a>();
<a name="l00761"></a>00761     <a class="code" href="x86__cpu_8cc.html#a9687b0de58e7126c4e4bfa5396205bfe">FOREACH_SEGMENT</a>();
<a name="l00762"></a>00762     <a class="code" href="x86__cpu_8cc.html#ad8b16766eca6fa646fa2cc82fbd44cb7">FOREACH_DTABLE</a>();
<a name="l00763"></a>00763 
<a name="l00764"></a>00764 <span class="preprocessor">#undef APPLY_SREG</span>
<a name="l00765"></a>00765 <span class="preprocessor"></span><span class="preprocessor">#undef APPLY_SEGMENT</span>
<a name="l00766"></a>00766 <span class="preprocessor"></span><span class="preprocessor">#undef APPLY_DTABLE</span>
<a name="l00767"></a>00767 <span class="preprocessor"></span>
<a name="l00768"></a>00768     <span class="comment">// Clear the interrupt bitmap</span>
<a name="l00769"></a>00769     memset(&amp;sregs.interrupt_bitmap, 0, <span class="keyword">sizeof</span>(sregs.interrupt_bitmap));
<a name="l00770"></a>00770 
<a name="l00771"></a>00771     <span class="comment">// VMX requires CS, SS, DS, ES, FS, and GS to have the accessed</span>
<a name="l00772"></a>00772     <span class="comment">// bit in the type field set.</span>
<a name="l00773"></a>00773     <a class="code" href="x86__cpu_8cc.html#a0dd1c17ee1639164887df8dae4a46861">forceSegAccessed</a>(sregs.cs);
<a name="l00774"></a>00774     <a class="code" href="x86__cpu_8cc.html#a0dd1c17ee1639164887df8dae4a46861">forceSegAccessed</a>(sregs.ss);
<a name="l00775"></a>00775     <a class="code" href="x86__cpu_8cc.html#a0dd1c17ee1639164887df8dae4a46861">forceSegAccessed</a>(sregs.ds);
<a name="l00776"></a>00776     <a class="code" href="x86__cpu_8cc.html#a0dd1c17ee1639164887df8dae4a46861">forceSegAccessed</a>(sregs.es);
<a name="l00777"></a>00777     <a class="code" href="x86__cpu_8cc.html#a0dd1c17ee1639164887df8dae4a46861">forceSegAccessed</a>(sregs.fs);
<a name="l00778"></a>00778     <a class="code" href="x86__cpu_8cc.html#a0dd1c17ee1639164887df8dae4a46861">forceSegAccessed</a>(sregs.gs);
<a name="l00779"></a>00779 
<a name="l00780"></a>00780     <span class="comment">// There are currently some cases where the active task isn&apos;t</span>
<a name="l00781"></a>00781     <span class="comment">// marked as busy. This is illegal in VMX, so we force it to busy.</span>
<a name="l00782"></a>00782     <span class="keywordflow">if</span> (sregs.tr.type == <a class="code" href="x86__cpu_8cc.html#ab981dfcf0b109de1740a5684d6eed5d8">SEG_SYS_TYPE_TSS_AVAILABLE</a>) {
<a name="l00783"></a>00783         <a class="code" href="base_2misc_8hh.html#a3ac67e8755a9cc9c3bf9e84e0f221458">hack</a>(<span class="stringliteral">&quot;tr.type (%i) is not busy. Forcing the busy bit.\n&quot;</span>,
<a name="l00784"></a>00784              sregs.tr.type);
<a name="l00785"></a>00785         sregs.tr.type = <a class="code" href="x86__cpu_8cc.html#a7dbae927888360923f7d7dbb529a3668">SEG_SYS_TYPE_TSS_BUSY</a>;
<a name="l00786"></a>00786     }
<a name="l00787"></a>00787 
<a name="l00788"></a>00788     <span class="comment">// VMX requires the DPL of SS and CS to be the same for</span>
<a name="l00789"></a>00789     <span class="comment">// non-conforming code segments. It seems like m5 doesn&apos;t set the</span>
<a name="l00790"></a>00790     <span class="comment">// DPL of SS correctly when taking interrupts, so we need to fix</span>
<a name="l00791"></a>00791     <span class="comment">// that here.</span>
<a name="l00792"></a>00792     <span class="keywordflow">if</span> ((sregs.cs.type == <a class="code" href="x86__cpu_8cc.html#a4a17e8eb656d44e302e42eaad4ed7d55">SEG_CS_TYPE_ACCESSED</a> ||
<a name="l00793"></a>00793          sregs.cs.type == <a class="code" href="x86__cpu_8cc.html#a64546b78e0c66406e0c585251017e97d">SEG_CS_TYPE_READ_ACCESSED</a>) &amp;&amp;
<a name="l00794"></a>00794         sregs.cs.dpl != sregs.ss.dpl) {
<a name="l00795"></a>00795 
<a name="l00796"></a>00796         <a class="code" href="base_2misc_8hh.html#a3ac67e8755a9cc9c3bf9e84e0f221458">hack</a>(<span class="stringliteral">&quot;CS.DPL (%i) != SS.DPL (%i): Forcing SS.DPL to %i\n&quot;</span>,
<a name="l00797"></a>00797              sregs.cs.dpl, sregs.ss.dpl, sregs.cs.dpl);
<a name="l00798"></a>00798         sregs.ss.dpl = sregs.cs.dpl;
<a name="l00799"></a>00799     }
<a name="l00800"></a>00800 
<a name="l00801"></a>00801     <span class="comment">// Do checks after fixing up the state to avoid getting excessive</span>
<a name="l00802"></a>00802     <span class="comment">// amounts of warnings.</span>
<a name="l00803"></a>00803     RFLAGS rflags_nocc(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a6888f4bff21e34892e59654ea80073b2">readMiscReg</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67a65884426f637d3beaa386e8cacb215c3">MISCREG_RFLAGS</a>));
<a name="l00804"></a>00804     <span class="keywordflow">if</span> (!rflags_nocc.vm) {
<a name="l00805"></a>00805         <span class="comment">// Do segment verification if the CPU isn&apos;t entering virtual</span>
<a name="l00806"></a>00806         <span class="comment">// 8086 mode.  We currently assume that unrestricted guest</span>
<a name="l00807"></a>00807         <span class="comment">// mode is available.</span>
<a name="l00808"></a>00808 
<a name="l00809"></a>00809 <span class="preprocessor">#define APPLY_SEGMENT(kreg, idx) \</span>
<a name="l00810"></a>00810 <span class="preprocessor">        checkSeg(# kreg, idx + MISCREG_SEG_SEL_BASE, sregs.kreg, sregs)</span>
<a name="l00811"></a>00811 <span class="preprocessor"></span>
<a name="l00812"></a>00812         <a class="code" href="x86__cpu_8cc.html#a9687b0de58e7126c4e4bfa5396205bfe">FOREACH_SEGMENT</a>();
<a name="l00813"></a>00813 <span class="preprocessor">#undef APPLY_SEGMENT</span>
<a name="l00814"></a>00814 <span class="preprocessor"></span>    }
<a name="l00815"></a>00815 
<a name="l00816"></a>00816     <a class="code" href="classBaseKvmCPU.html#aefaac43fa62903f42a68a637083d5f09">setSpecialRegisters</a>(sregs);
<a name="l00817"></a>00817 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="adbd5e38eae7c8c3021f2c4f430b399fd"></a><!-- doxytag: member="X86KvmCPU::updateThreadContext" ref="adbd5e38eae7c8c3021f2c4f430b399fd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateThreadContext </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update the current thread context with the KVM state</p>
<p>The base CPU after the guest updates any of the KVM state. In practice, this happens after kvmRun is called. The architecture dependent code is expected to read the state of the guest CPU and update gem5's thread state. </p>

<p><a class="el" href="classBaseKvmCPU.html#ac47bfb587580ca76050e0c9bc753c10d">BaseKvmCPU</a>を実装しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00938"></a>00938 {
<a name="l00939"></a>00939     <span class="keyword">struct </span>kvm_regs regs;
<a name="l00940"></a>00940     <span class="keyword">struct </span>kvm_sregs sregs;
<a name="l00941"></a>00941 
<a name="l00942"></a>00942     <a class="code" href="classBaseKvmCPU.html#a422ac5896dab3bae0379fa65831e3778">getRegisters</a>(regs);
<a name="l00943"></a>00943     <a class="code" href="classBaseKvmCPU.html#a5b5f3c0a541efb9b8567a5e835421c15">getSpecialRegisters</a>(sregs);
<a name="l00944"></a>00944 
<a name="l00945"></a>00945     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmContext, <span class="stringliteral">&quot;X86KvmCPU::updateThreadContext():\n&quot;</span>);
<a name="l00946"></a>00946     <span class="keywordflow">if</span> (<a class="code" href="trace_8hh.html#af76c9f7776aade1bf9d7dfa8a0c6b341">DTRACE</a>(KvmContext))
<a name="l00947"></a>00947         <a class="code" href="classX86KvmCPU.html#accd2600060dbaee3a3b41aed4034c63c">dump</a>();
<a name="l00948"></a>00948 
<a name="l00949"></a>00949     <a class="code" href="classX86KvmCPU.html#a3e652bccdd2770630eb4e7bfb0b31b5e">updateThreadContextRegs</a>(regs, sregs);
<a name="l00950"></a>00950     <a class="code" href="classX86KvmCPU.html#aaca63820cd695ae9a2d1bafa76f2ebf6">updateThreadContextSRegs</a>(sregs);
<a name="l00951"></a>00951     <span class="keywordflow">if</span> (<a class="code" href="classX86KvmCPU.html#ab966ae6cc1b380746dcb2713f2559e65">useXSave</a>) {
<a name="l00952"></a>00952         <span class="keyword">struct </span>kvm_xsave xsave;
<a name="l00953"></a>00953         <a class="code" href="classX86KvmCPU.html#af9f89d561ce9170ad89e6582071c1169">getXSave</a>(xsave);
<a name="l00954"></a>00954 
<a name="l00955"></a>00955        <a class="code" href="classX86KvmCPU.html#a64c8d7da4ee94fdaeb4e61d7106c01cf">updateThreadContextXSave</a>(xsave);
<a name="l00956"></a>00956     } <span class="keywordflow">else</span> {
<a name="l00957"></a>00957         <span class="keyword">struct </span>kvm_fpu fpu;
<a name="l00958"></a>00958         <a class="code" href="classBaseKvmCPU.html#a9fdafd736b7b9ef041b6c3e4768a61d6">getFPUState</a>(fpu);
<a name="l00959"></a>00959 
<a name="l00960"></a>00960         <a class="code" href="classX86KvmCPU.html#a1f9b85cc469eb72bbf377872c1404c1e">updateThreadContextFPU</a>(fpu);
<a name="l00961"></a>00961     }
<a name="l00962"></a>00962     <a class="code" href="classX86KvmCPU.html#ad0f81dc69ee0b095b4c9eeec4491ed39">updateThreadContextMSRs</a>();
<a name="l00963"></a>00963 
<a name="l00964"></a>00964     <span class="comment">// The M5 misc reg caches some values from other</span>
<a name="l00965"></a>00965     <span class="comment">// registers. Writing to it with side effects causes it to be</span>
<a name="l00966"></a>00966     <span class="comment">// updated from its source registers.</span>
<a name="l00967"></a>00967     <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a074166dc2fe3c4aea3ad588ed9883c51">setMiscReg</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67a82930abd37514e1c9a8ca58861ae5fe5">MISCREG_M5_REG</a>, 0);
<a name="l00968"></a>00968 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1f9b85cc469eb72bbf377872c1404c1e"></a><!-- doxytag: member="X86KvmCPU::updateThreadContextFPU" ref="a1f9b85cc469eb72bbf377872c1404c1e" args="(const struct kvm_fpu &amp;fpu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateThreadContextFPU </td>
          <td>(</td>
          <td class="paramtype">const struct kvm_fpu &amp;&nbsp;</td>
          <td class="paramname"> <em>fpu</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update FPU and SIMD registers using the legacy API </p>

<p><div class="fragment"><pre class="fragment"><a name="l01082"></a>01082 {
<a name="l01083"></a>01083     <a class="code" href="x86__cpu_8cc.html#a313c58fe9310f894c07dda533fde7fbb">updateThreadContextFPUCommon</a>(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>, fpu);
<a name="l01084"></a>01084 
<a name="l01085"></a>01085     <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a2987c1ff22ebdf6cdf354a31462bdbfb">setMiscRegNoEffect</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67ac5bcbd25eb560d0d3d6f06b645e39beb">MISCREG_FISEG</a>, 0);
<a name="l01086"></a>01086     <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a2987c1ff22ebdf6cdf354a31462bdbfb">setMiscRegNoEffect</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67a121b73c40eb70a2a9c1354b57586f06e">MISCREG_FIOFF</a>, fpu.last_ip);
<a name="l01087"></a>01087     <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a2987c1ff22ebdf6cdf354a31462bdbfb">setMiscRegNoEffect</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67a2e12b574e8a93bb82790999af16b87a0">MISCREG_FOSEG</a>, 0);
<a name="l01088"></a>01088     <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a2987c1ff22ebdf6cdf354a31462bdbfb">setMiscRegNoEffect</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67abd62775859320efc4c0996116c7b2d03">MISCREG_FOOFF</a>, fpu.last_dp);
<a name="l01089"></a>01089 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad0f81dc69ee0b095b4c9eeec4491ed39"></a><!-- doxytag: member="X86KvmCPU::updateThreadContextMSRs" ref="ad0f81dc69ee0b095b4c9eeec4491ed39" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateThreadContextMSRs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update MSR registers </p>

<p><div class="fragment"><pre class="fragment"><a name="l01106"></a>01106 {
<a name="l01107"></a>01107     <span class="keyword">const</span> <a class="code" href="classstd_1_1vector.html">Kvm::MSRIndexVector</a> &amp;msrs(<a class="code" href="classX86KvmCPU.html#abab51da6ec6a0f14d2dde6b0857b7b34">getMsrIntersection</a>());
<a name="l01108"></a>01108 
<a name="l01109"></a>01109     std::unique_ptr&lt;struct kvm_msrs&gt; kvm_msrs(
<a name="l01110"></a>01110         newVarStruct&lt;struct kvm_msrs, struct kvm_msr_entry&gt;(msrs.size()));
<a name="l01111"></a>01111     <span class="keyword">struct </span>kvm_msr_entry *entry;
<a name="l01112"></a>01112 
<a name="l01113"></a>01113     <span class="comment">// Create a list of MSRs to read</span>
<a name="l01114"></a>01114     kvm_msrs-&gt;nmsrs = msrs.size();
<a name="l01115"></a>01115     entry = &amp;kvm_msrs-&gt;entries[0];
<a name="l01116"></a>01116     <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = msrs.cbegin(); it != msrs.cend(); ++it, ++entry) {
<a name="l01117"></a>01117         entry-&gt;index = *it;
<a name="l01118"></a>01118         entry-&gt;reserved = 0;
<a name="l01119"></a>01119         entry-&gt;data = 0;
<a name="l01120"></a>01120     }
<a name="l01121"></a>01121 
<a name="l01122"></a>01122     <a class="code" href="classX86KvmCPU.html#aee0c514e035c18531c33ea1219e621bf">getMSRs</a>(*kvm_msrs.get());
<a name="l01123"></a>01123 
<a name="l01124"></a>01124     <span class="comment">// Update M5&apos;s state</span>
<a name="l01125"></a>01125     entry = &amp;kvm_msrs-&gt;entries[0];
<a name="l01126"></a>01126     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> = 0; <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> &lt; kvm_msrs-&gt;nmsrs; ++<a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>, ++entry) {
<a name="l01127"></a>01127         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(KvmContext, <span class="stringliteral">&quot;Setting M5 MSR: idx: 0x%x, data: 0x%x\n&quot;</span>,
<a name="l01128"></a>01128                 entry-&gt;index, entry-&gt;data);
<a name="l01129"></a>01129 
<a name="l01130"></a>01130         <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a074166dc2fe3c4aea3ad588ed9883c51">setMiscReg</a>(<a class="code" href="namespaceX86ISA.html#a668a095a9f8f9c629c5b12ff0bb8a721">X86ISA::msrMap</a>.<a class="code" href="namespaceMipsISA.html#aae45d89ef33df5ae6cb969bb4b58f429">at</a>(entry-&gt;index), entry-&gt;data);
<a name="l01131"></a>01131     }
<a name="l01132"></a>01132 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3e652bccdd2770630eb4e7bfb0b31b5e"></a><!-- doxytag: member="X86KvmCPU::updateThreadContextRegs" ref="a3e652bccdd2770630eb4e7bfb0b31b5e" args="(const struct kvm_regs &amp;regs, const struct kvm_sregs &amp;sregs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateThreadContextRegs </td>
          <td>(</td>
          <td class="paramtype">const struct kvm_regs &amp;&nbsp;</td>
          <td class="paramname"> <em>regs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct kvm_sregs &amp;&nbsp;</td>
          <td class="paramname"> <em>sregs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Support routines to update the state of gem5's thread context from KVM's state representation. Update integer registers </p>

<p><div class="fragment"><pre class="fragment"><a name="l00973"></a>00973 {
<a name="l00974"></a>00974 <span class="preprocessor">#define APPLY_IREG(kreg, mreg) tc-&gt;setIntReg(mreg, regs.kreg)</span>
<a name="l00975"></a>00975 <span class="preprocessor"></span>
<a name="l00976"></a>00976     <a class="code" href="x86__cpu_8cc.html#a1b70a9e03d3e57124b5ec691a3de8720">FOREACH_IREG</a>();
<a name="l00977"></a>00977 
<a name="l00978"></a>00978 <span class="preprocessor">#undef APPLY_IREG</span>
<a name="l00979"></a>00979 <span class="preprocessor"></span>
<a name="l00980"></a>00980     <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a1aaca26c0732d2191edbde1477d7ec13">pcState</a>(<a class="code" href="namespaceAlphaISA.html#af780de49982ecf691215cac9b9dfc615">PCState</a>(regs.rip + sregs.cs.base));
<a name="l00981"></a>00981 
<a name="l00982"></a>00982     <span class="comment">// Flags are spread out across multiple semi-magic registers so we</span>
<a name="l00983"></a>00983     <span class="comment">// need some special care when updating them.</span>
<a name="l00984"></a>00984     <a class="code" href="namespaceX86ISA.html#afcfb8527ec900004ecda24cd03b0b2a9">X86ISA::setRFlags</a>(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>, regs.rflags);
<a name="l00985"></a>00985 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aaca63820cd695ae9a2d1bafa76f2ebf6"></a><!-- doxytag: member="X86KvmCPU::updateThreadContextSRegs" ref="aaca63820cd695ae9a2d1bafa76f2ebf6" args="(const struct kvm_sregs &amp;sregs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateThreadContextSRegs </td>
          <td>(</td>
          <td class="paramtype">const struct kvm_sregs &amp;&nbsp;</td>
          <td class="paramname"> <em>sregs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update control registers (CRx, segments, etc.) </p>

<p><div class="fragment"><pre class="fragment"><a name="l01026"></a>01026 {
<a name="l01027"></a>01027     assert(<a class="code" href="classBaseKvmCPU.html#ae544593d8bd3763ec6cf4cc7d0fd614b">getKvmRunState</a>()-&gt;apic_base == sregs.apic_base);
<a name="l01028"></a>01028     assert(<a class="code" href="classBaseKvmCPU.html#ae544593d8bd3763ec6cf4cc7d0fd614b">getKvmRunState</a>()-&gt;cr8 == sregs.cr8);
<a name="l01029"></a>01029 
<a name="l01030"></a>01030 <span class="preprocessor">#define APPLY_SREG(kreg, mreg) tc-&gt;setMiscRegNoEffect(mreg, sregs.kreg)</span>
<a name="l01031"></a>01031 <span class="preprocessor"></span><span class="preprocessor">#define APPLY_SEGMENT(kreg, idx) setContextSegment(tc, sregs.kreg, idx)</span>
<a name="l01032"></a>01032 <span class="preprocessor"></span><span class="preprocessor">#define APPLY_DTABLE(kreg, idx) setContextSegment(tc, sregs.kreg, idx)</span>
<a name="l01033"></a>01033 <span class="preprocessor"></span>    <a class="code" href="x86__cpu_8cc.html#aa90701ca0a4e8e76a8fe2e712b1435a2">FOREACH_SREG</a>();
<a name="l01034"></a>01034     <a class="code" href="x86__cpu_8cc.html#a9687b0de58e7126c4e4bfa5396205bfe">FOREACH_SEGMENT</a>();
<a name="l01035"></a>01035     <a class="code" href="x86__cpu_8cc.html#ad8b16766eca6fa646fa2cc82fbd44cb7">FOREACH_DTABLE</a>();
<a name="l01036"></a>01036 <span class="preprocessor">#undef APPLY_SREG</span>
<a name="l01037"></a>01037 <span class="preprocessor"></span><span class="preprocessor">#undef APPLY_SEGMENT</span>
<a name="l01038"></a>01038 <span class="preprocessor"></span><span class="preprocessor">#undef APPLY_DTABLE</span>
<a name="l01039"></a>01039 <span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a64c8d7da4ee94fdaeb4e61d7106c01cf"></a><!-- doxytag: member="X86KvmCPU::updateThreadContextXSave" ref="a64c8d7da4ee94fdaeb4e61d7106c01cf" args="(const struct kvm_xsave &amp;kxsave)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateThreadContextXSave </td>
          <td>(</td>
          <td class="paramtype">const struct kvm_xsave &amp;&nbsp;</td>
          <td class="paramname"> <em>kxsave</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update FPU and SIMD registers using the XSave API </p>

<p><div class="fragment"><pre class="fragment"><a name="l01093"></a>01093 {
<a name="l01094"></a>01094     <span class="keyword">const</span> <a class="code" href="structFXSave.html">FXSave</a> &amp;xsave(*(<span class="keyword">const</span> <a class="code" href="structFXSave.html">FXSave</a> *)kxsave.region);
<a name="l01095"></a>01095 
<a name="l01096"></a>01096     <a class="code" href="x86__cpu_8cc.html#a313c58fe9310f894c07dda533fde7fbb">updateThreadContextFPUCommon</a>(<a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>, xsave);
<a name="l01097"></a>01097 
<a name="l01098"></a>01098     <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a2987c1ff22ebdf6cdf354a31462bdbfb">setMiscRegNoEffect</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67ac5bcbd25eb560d0d3d6f06b645e39beb">MISCREG_FISEG</a>, 0);
<a name="l01099"></a>01099     <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a2987c1ff22ebdf6cdf354a31462bdbfb">setMiscRegNoEffect</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67a121b73c40eb70a2a9c1354b57586f06e">MISCREG_FIOFF</a>, xsave.ctrl64.fpu_ip);
<a name="l01100"></a>01100     <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a2987c1ff22ebdf6cdf354a31462bdbfb">setMiscRegNoEffect</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67a2e12b574e8a93bb82790999af16b87a0">MISCREG_FOSEG</a>, 0);
<a name="l01101"></a>01101     <a class="code" href="classBaseKvmCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>-&gt;<a class="code" href="classThreadContext.html#a2987c1ff22ebdf6cdf354a31462bdbfb">setMiscRegNoEffect</a>(<a class="code" href="namespaceX86ISA.html#a1e522017e015d4c7efd6b2360143aa67abd62775859320efc4c0996116c7b2d03">MISCREG_FOOFF</a>, xsave.ctrl64.fpu_dp);
<a name="l01102"></a>01102 }
</pre></div></p>

</div>
</div>
<hr/><h2>変数</h2>
<a class="anchor" id="aa0f07c7b56f9fd1e68e7ebdc2e3a9428"></a><!-- doxytag: member="X86KvmCPU::cachedMsrIntersection" ref="aa0f07c7b56f9fd1e68e7ebdc2e3a9428" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">Kvm::MSRIndexVector</a> <a class="el" href="classX86KvmCPU.html#aa0f07c7b56f9fd1e68e7ebdc2e3a9428">cachedMsrIntersection</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cached intersection of supported MSRs </p>

</div>
</div>
<a class="anchor" id="ab7c96fcfb73a6d3ca276a6dce2ee76bb"></a><!-- doxytag: member="X86KvmCPU::haveDebugRegs" ref="ab7c96fcfb73a6d3ca276a6dce2ee76bb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classX86KvmCPU.html#ab7c96fcfb73a6d3ca276a6dce2ee76bb">haveDebugRegs</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classKvm.html#a4e15b92a17300f1d37ceca6e4a984086">Kvm::capDebugRegs()</a> available? </p>

</div>
</div>
<a class="anchor" id="acb9f794b9c9ccc1422b1b5ba9e4823b6"></a><!-- doxytag: member="X86KvmCPU::haveXCRs" ref="acb9f794b9c9ccc1422b1b5ba9e4823b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classX86KvmCPU.html#acb9f794b9c9ccc1422b1b5ba9e4823b6">haveXCRs</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classKvm.html#aa9b34836edde016c16df3006fb33b0a9">Kvm::capXCRs()</a> available? </p>

</div>
</div>
<a class="anchor" id="ac0fd3f6d7cf7fa1132de384a5953228c"></a><!-- doxytag: member="X86KvmCPU::haveXSave" ref="ac0fd3f6d7cf7fa1132de384a5953228c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classX86KvmCPU.html#ac0fd3f6d7cf7fa1132de384a5953228c">haveXSave</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classKvm.html#a9c6bbe65d43e3f2708723fc21f00b4cd">Kvm::capXSave()</a> available? </p>

</div>
</div>
<a class="anchor" id="ab9e917350d26247b9eb4153e891f348a"></a><!-- doxytag: member="X86KvmCPU::io_req" ref="ab9e917350d26247b9eb4153e891f348a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRequest.html">Request</a> <a class="el" href="classX86KvmCPU.html#ab9e917350d26247b9eb4153e891f348a">io_req</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reusable IO request </p>

</div>
</div>
<a class="anchor" id="ab966ae6cc1b380746dcb2713f2559e65"></a><!-- doxytag: member="X86KvmCPU::useXSave" ref="ab966ae6cc1b380746dcb2713f2559e65" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classX86KvmCPU.html#ab966ae6cc1b380746dcb2713f2559e65">useXSave</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Should the XSave interface be used to sync the FPU and SIMD registers? </p>

</div>
</div>
<hr/>このクラスの説明は次のファイルから生成されました:<ul>
<li>cpu/kvm/<a class="el" href="x86__cpu_8hh_source.html">x86_cpu.hh</a></li>
<li>cpu/kvm/<a class="el" href="x86__cpu_8cc.html">x86_cpu.cc</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>File&nbsp;GEM5&nbsp;Wrapperに対して25 May 2015に生成されました。&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
