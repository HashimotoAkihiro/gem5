\hypertarget{classMemoryVector}{
\section{クラス MemoryVector}
\label{classMemoryVector}\index{MemoryVector@{MemoryVector}}
}


{\ttfamily \#include $<$MemoryVector.hh$>$}\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMemoryVector_a0d69cc0d03dd90dec0a42a02f80e6fc3}{MemoryVector} ()
\item 
\hyperlink{classMemoryVector_a8dabb961f3dfab673f3231af344f0c52}{MemoryVector} (\hyperlink{TypeDefines_8hh_a29940ae63ec06c9998bba873e25407ad}{uint64} size)
\item 
\hyperlink{classMemoryVector_adb36a662a886ad8dd3877a5989aacdbc}{$\sim$MemoryVector} ()
\item 
void \hyperlink{classMemoryVector_a6da191301b562078e345bd2b6399a9a1}{resize} (\hyperlink{TypeDefines_8hh_a29940ae63ec06c9998bba873e25407ad}{uint64} size)
\item 
void \hyperlink{classMemoryVector_a8ec391c8b51d1738602ab13bc1d4c78e}{write} (const \hyperlink{classAddress}{Address} \&paddr, uint8\_\-t $\ast$data, int len)
\item 
uint8\_\-t $\ast$ \hyperlink{classMemoryVector_a7752d5bff6be1de2b0e44953b0de5fea}{read} (const \hyperlink{classAddress}{Address} \&paddr, uint8\_\-t $\ast$data, int len)
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classMemoryVector_a8b98a578a2b3755a5a07c42ff4475c24}{collatePages} (uint8\_\-t $\ast$\&raw\_\-data)
\item 
void \hyperlink{classMemoryVector_a7e181ccf8a5d687b45d21ec056af0897}{populatePages} (uint8\_\-t $\ast$raw\_\-data)
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
uint8\_\-t $\ast$ \hyperlink{classMemoryVector_aa84e71fe0f01161f74d3430956f10390}{getBlockPtr} (const \hyperlink{classAddress}{PhysAddress} \&addr)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{TypeDefines_8hh_a29940ae63ec06c9998bba873e25407ad}{uint64} \hyperlink{classMemoryVector_ac0071dd217f86f00bbd71d9d0d4eb257}{m\_\-size}
\item 
uint8\_\-t $\ast$$\ast$ \hyperlink{classMemoryVector_a80e2fa6a21a7254c7956f4956a151faa}{m\_\-pages}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classMemoryVector_a388f518731020bfb575b5e4e6267fc5a}{m\_\-num\_\-pages}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classMemoryVector_a0db9bff4ff55b605292f796dd7aae285}{m\_\-page\_\-offset\_\-mask}
\end{DoxyCompactItemize}
\subsection*{Static Private 変数}
\begin{DoxyCompactItemize}
\item 
static const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classMemoryVector_adece9379840adc8842e99cea5f24e4f2}{PAGE\_\-SIZE} = 4096
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classMemoryVector_a40907c9241cfbaf58daf0c9c7a4a9edd}{DirectoryMemory}
\end{DoxyCompactItemize}


\subsection{説明}
\hyperlink{classMemoryVector}{MemoryVector} holds memory data (DRAM only) 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classMemoryVector_a0d69cc0d03dd90dec0a42a02f80e6fc3}{
\index{MemoryVector@{MemoryVector}!MemoryVector@{MemoryVector}}
\index{MemoryVector@{MemoryVector}!MemoryVector@{MemoryVector}}
\subsubsection[{MemoryVector}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemoryVector} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemoryVector_a0d69cc0d03dd90dec0a42a02f80e6fc3}



\begin{DoxyCode}
68     : m_page_offset_mask(4095)
69 {
70     m_size = 0;
71     m_num_pages = 0;
72     m_pages = NULL;
73 }
\end{DoxyCode}
\hypertarget{classMemoryVector_a8dabb961f3dfab673f3231af344f0c52}{
\index{MemoryVector@{MemoryVector}!MemoryVector@{MemoryVector}}
\index{MemoryVector@{MemoryVector}!MemoryVector@{MemoryVector}}
\subsubsection[{MemoryVector}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemoryVector} ({\bf uint64} {\em size})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemoryVector_a8dabb961f3dfab673f3231af344f0c52}



\begin{DoxyCode}
77     : m_page_offset_mask(4095)
78 {
79     resize(size);
80 }
\end{DoxyCode}
\hypertarget{classMemoryVector_adb36a662a886ad8dd3877a5989aacdbc}{
\index{MemoryVector@{MemoryVector}!$\sim$MemoryVector@{$\sim$MemoryVector}}
\index{$\sim$MemoryVector@{$\sim$MemoryVector}!MemoryVector@{MemoryVector}}
\subsubsection[{$\sim$MemoryVector}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf MemoryVector} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemoryVector_adb36a662a886ad8dd3877a5989aacdbc}



\begin{DoxyCode}
84 {
85     for (int i = 0; i < m_num_pages; i++) {
86         if (m_pages[i] != 0) {
87             delete [] m_pages[i];
88         }
89     }
90     delete [] m_pages;
91 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classMemoryVector_a8b98a578a2b3755a5a07c42ff4475c24}{
\index{MemoryVector@{MemoryVector}!collatePages@{collatePages}}
\index{collatePages@{collatePages}!MemoryVector@{MemoryVector}}
\subsubsection[{collatePages}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} collatePages (uint8\_\-t $\ast$\& {\em raw\_\-data})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemoryVector_a8b98a578a2b3755a5a07c42ff4475c24}
Function for collating all the pages of the physical memory together. In case a pointer for a page is NULL, this page needs only a single byte to represent that the pointer is NULL. Otherwise, it needs 1 + PAGE\_\-SIZE bytes. The first represents that the page pointer is not NULL, and rest of the bytes represent the data on the page. 


\begin{DoxyCode}
171 {
172     uint32_t num_zero_pages = 0;
173     uint32_t data_size = 0;
174 
175     for (uint32_t i = 0;i < m_num_pages; ++i)
176     {
177         if (m_pages[i] == 0) num_zero_pages++;
178     }
179 
180     raw_data = new uint8_t[sizeof(uint32_t) /* number of pages*/ +
181                            m_num_pages /* whether the page is all zeros */ +
182                            PAGE_SIZE * (m_num_pages - num_zero_pages)];
183 
184     /* Write the number of pages to be stored. */
185     memcpy(raw_data, &m_num_pages, sizeof(uint32_t));
186     data_size = sizeof(uint32_t);
187 
188     DPRINTF(RubyCacheTrace, "collating %d pages\n", m_num_pages);
189 
190     for (uint32_t i = 0;i < m_num_pages; ++i)
191     {
192         if (m_pages[i] == 0) {
193             raw_data[data_size] = 0;
194         } else {
195             raw_data[data_size] = 1;
196             memcpy(raw_data + data_size + 1, m_pages[i], PAGE_SIZE);
197             data_size += PAGE_SIZE;
198         }
199         data_size += 1;
200     }
201 
202     return data_size;
203 }
\end{DoxyCode}
\hypertarget{classMemoryVector_aa84e71fe0f01161f74d3430956f10390}{
\index{MemoryVector@{MemoryVector}!getBlockPtr@{getBlockPtr}}
\index{getBlockPtr@{getBlockPtr}!MemoryVector@{MemoryVector}}
\subsubsection[{getBlockPtr}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t $\ast$ getBlockPtr (const {\bf PhysAddress} \& {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classMemoryVector_aa84e71fe0f01161f74d3430956f10390}



\begin{DoxyCode}
152 {
153     uint32_t page_num = paddr.getAddress() >> 12;
154     if (m_pages[page_num] == 0) {
155         m_pages[page_num] = new uint8_t[PAGE_SIZE];
156         memset(m_pages[page_num], 0, PAGE_SIZE);
157     }
158     return &m_pages[page_num][paddr.getAddress()&m_page_offset_mask];
159 }
\end{DoxyCode}
\hypertarget{classMemoryVector_a7e181ccf8a5d687b45d21ec056af0897}{
\index{MemoryVector@{MemoryVector}!populatePages@{populatePages}}
\index{populatePages@{populatePages}!MemoryVector@{MemoryVector}}
\subsubsection[{populatePages}]{\setlength{\rightskip}{0pt plus 5cm}void populatePages (uint8\_\-t $\ast$ {\em raw\_\-data})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemoryVector_a7e181ccf8a5d687b45d21ec056af0897}
Function for populating the pages of the memory using the available raw data. Each page has a byte associate with it, which represents whether the page was NULL or not, when all the pages were collated. The function assumes that the number of pages in the memory are same as those that were recorded in the checkpoint. 


\begin{DoxyCode}
214 {
215     uint32_t data_size = 0;
216     uint32_t num_pages = 0;
217 
218     /* Read the number of pages that were stored. */
219     memcpy(&num_pages, raw_data, sizeof(uint32_t));
220     data_size = sizeof(uint32_t);
221     assert(num_pages == m_num_pages);
222 
223     DPRINTF(RubyCacheTrace, "Populating %d pages\n", num_pages);
224 
225     for (uint32_t i = 0;i < m_num_pages; ++i)
226     {
227         assert(m_pages[i] == 0);
228         if (raw_data[data_size] != 0) {
229             m_pages[i] = new uint8_t[PAGE_SIZE];
230             memcpy(m_pages[i], raw_data + data_size + 1, PAGE_SIZE);
231             data_size += PAGE_SIZE;
232         }
233         data_size += 1;
234     }
235 }
\end{DoxyCode}
\hypertarget{classMemoryVector_a7752d5bff6be1de2b0e44953b0de5fea}{
\index{MemoryVector@{MemoryVector}!read@{read}}
\index{read@{read}!MemoryVector@{MemoryVector}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t $\ast$ read (const {\bf Address} \& {\em paddr}, \/  uint8\_\-t $\ast$ {\em data}, \/  int {\em len})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemoryVector_a7752d5bff6be1de2b0e44953b0de5fea}



\begin{DoxyCode}
138 {
139     assert(paddr.getAddress() + len <= m_size);
140     uint32_t page_num = paddr.getAddress() >> 12;
141     if (m_pages[page_num] == 0) {
142         memset(data, 0, len);
143     } else {
144         memcpy(data, &m_pages[page_num][paddr.getAddress()&m_page_offset_mask],
145                len);
146     }
147     return data;
148 }
\end{DoxyCode}
\hypertarget{classMemoryVector_a6da191301b562078e345bd2b6399a9a1}{
\index{MemoryVector@{MemoryVector}!resize@{resize}}
\index{resize@{resize}!MemoryVector@{MemoryVector}}
\subsubsection[{resize}]{\setlength{\rightskip}{0pt plus 5cm}void resize ({\bf uint64} {\em size})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemoryVector_a6da191301b562078e345bd2b6399a9a1}



\begin{DoxyCode}
95 {
96     if (m_pages != NULL){
97         for (int i = 0; i < m_num_pages; i++) {
98             if (m_pages[i] != 0) {
99                 delete [] m_pages[i];
100             }
101         }
102         delete [] m_pages;
103     }
104     m_size = size;
105     assert(size%PAGE_SIZE == 0);
106     m_num_pages = size >> 12;
107     m_pages = new uint8_t*[m_num_pages];
108     memset(m_pages, 0, m_num_pages * sizeof(uint8_t*));
109 }
\end{DoxyCode}
\hypertarget{classMemoryVector_a8ec391c8b51d1738602ab13bc1d4c78e}{
\index{MemoryVector@{MemoryVector}!write@{write}}
\index{write@{write}!MemoryVector@{MemoryVector}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}void write (const {\bf Address} \& {\em paddr}, \/  uint8\_\-t $\ast$ {\em data}, \/  int {\em len})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemoryVector_a8ec391c8b51d1738602ab13bc1d4c78e}



\begin{DoxyCode}
113 {
114     assert(paddr.getAddress() + len <= m_size);
115     uint32_t page_num = paddr.getAddress() >> 12;
116     if (m_pages[page_num] == 0) {
117         bool all_zeros = true;
118         for (int i = 0; i < len;i++) {
119             if (data[i] != 0) {
120                 all_zeros = false;
121                 break;
122             }
123         }
124         if (all_zeros)
125             return;
126         m_pages[page_num] = new uint8_t[PAGE_SIZE];
127         memset(m_pages[page_num], 0, PAGE_SIZE);
128         uint32_t offset = paddr.getAddress() & m_page_offset_mask;
129         memcpy(&m_pages[page_num][offset], data, len);
130     } else {
131         memcpy(&m_pages[page_num][paddr.getAddress()&m_page_offset_mask],
132                data, len);
133     }
134 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classMemoryVector_a40907c9241cfbaf58daf0c9c7a4a9edd}{
\index{MemoryVector@{MemoryVector}!DirectoryMemory@{DirectoryMemory}}
\index{DirectoryMemory@{DirectoryMemory}!MemoryVector@{MemoryVector}}
\subsubsection[{DirectoryMemory}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf DirectoryMemory}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classMemoryVector_a40907c9241cfbaf58daf0c9c7a4a9edd}


\subsection{変数}
\hypertarget{classMemoryVector_a388f518731020bfb575b5e4e6267fc5a}{
\index{MemoryVector@{MemoryVector}!m\_\-num\_\-pages@{m\_\-num\_\-pages}}
\index{m\_\-num\_\-pages@{m\_\-num\_\-pages}!MemoryVector@{MemoryVector}}
\subsubsection[{m\_\-num\_\-pages}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf m\_\-num\_\-pages}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemoryVector_a388f518731020bfb575b5e4e6267fc5a}
\hypertarget{classMemoryVector_a0db9bff4ff55b605292f796dd7aae285}{
\index{MemoryVector@{MemoryVector}!m\_\-page\_\-offset\_\-mask@{m\_\-page\_\-offset\_\-mask}}
\index{m\_\-page\_\-offset\_\-mask@{m\_\-page\_\-offset\_\-mask}!MemoryVector@{MemoryVector}}
\subsubsection[{m\_\-page\_\-offset\_\-mask}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf m\_\-page\_\-offset\_\-mask}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemoryVector_a0db9bff4ff55b605292f796dd7aae285}
\hypertarget{classMemoryVector_a80e2fa6a21a7254c7956f4956a151faa}{
\index{MemoryVector@{MemoryVector}!m\_\-pages@{m\_\-pages}}
\index{m\_\-pages@{m\_\-pages}!MemoryVector@{MemoryVector}}
\subsubsection[{m\_\-pages}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t$\ast$$\ast$ {\bf m\_\-pages}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemoryVector_a80e2fa6a21a7254c7956f4956a151faa}
\hypertarget{classMemoryVector_ac0071dd217f86f00bbd71d9d0d4eb257}{
\index{MemoryVector@{MemoryVector}!m\_\-size@{m\_\-size}}
\index{m\_\-size@{m\_\-size}!MemoryVector@{MemoryVector}}
\subsubsection[{m\_\-size}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint64} {\bf m\_\-size}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemoryVector_ac0071dd217f86f00bbd71d9d0d4eb257}
\hypertarget{classMemoryVector_adece9379840adc8842e99cea5f24e4f2}{
\index{MemoryVector@{MemoryVector}!PAGE\_\-SIZE@{PAGE\_\-SIZE}}
\index{PAGE\_\-SIZE@{PAGE\_\-SIZE}!MemoryVector@{MemoryVector}}
\subsubsection[{PAGE\_\-SIZE}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf PAGE\_\-SIZE} = 4096\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classMemoryVector_adece9379840adc8842e99cea5f24e4f2}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/ruby/system/\hyperlink{MemoryVector_8hh}{MemoryVector.hh}\end{DoxyCompactItemize}
