\hypertarget{classArmISA_1_1FpOp}{
\section{クラス FpOp}
\label{classArmISA_1_1FpOp}\index{ArmISA::FpOp@{ArmISA::FpOp}}
}


{\ttfamily \#include $<$vfp.hh$>$}FpOpに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=12cm]{classArmISA_1_1FpOp}
\end{center}
\end{figure}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classArmISA_1_1FpOp_ad806871f6f7f01a9f4f4f4326f6d3f70}{FpOp} (const char $\ast$mnem, \hyperlink{classStaticInst_a5605d4fc727eae9e595325c90c0ec108}{ExtMachInst} \_\-machInst, OpClass \_\-\_\-opClass)
\item 
virtual float \hyperlink{classArmISA_1_1FpOp_ae6e7fab9137bf946035338c924967bde}{doOp} (float op1, float op2) const 
\item 
virtual float \hyperlink{classArmISA_1_1FpOp_aec4d44856f9781717b36125acfcc45d3}{doOp} (float op1) const 
\item 
virtual double \hyperlink{classArmISA_1_1FpOp_a42bfa4e0c737bc1df68d12362d927535}{doOp} (double op1, double op2) const 
\item 
virtual double \hyperlink{classArmISA_1_1FpOp_ad1ec33e89716d3410e023846aaab378e}{doOp} (double op1) const 
\item 
double \hyperlink{classArmISA_1_1FpOp_a8b883fad84db432c4e6291c8db223e5e}{dbl} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} low, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} high) const 
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classArmISA_1_1FpOp_af317a029a04e1eb855f20b3c76aa2d79}{dblLow} (double val) const 
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classArmISA_1_1FpOp_a0a20a848b3881593f6250834f4c4e53d}{dblHi} (double val) const 
\item 
{\footnotesize template$<$class fpType $>$ }\\fpType \hyperlink{classArmISA_1_1FpOp_a0bb9efaddc2b7ac41cd08d497657e092}{processNans} (FPSCR \&fpscr, bool \&done, bool defaultNan, fpType op1, fpType op2) const 
\item 
{\footnotesize template$<$class fpType $>$ }\\fpType \hyperlink{classArmISA_1_1FpOp_a90767d472cab7e40d318351bf1aa8c12}{ternaryOp} (FPSCR \&fpscr, fpType op1, fpType op2, fpType op3, fpType($\ast$func)(fpType, fpType, fpType), bool flush, bool defaultNan, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{namespaceArmISA_a6a8214ac21eb2991c2975c0380f64b82}{rMode}) const 
\item 
{\footnotesize template$<$class fpType $>$ }\\fpType \hyperlink{classArmISA_1_1FpOp_acd464f48fab5cc85b99d2f45897149ba}{binaryOp} (FPSCR \&fpscr, fpType op1, fpType op2, fpType($\ast$func)(fpType, fpType), bool flush, bool defaultNan, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{namespaceArmISA_a6a8214ac21eb2991c2975c0380f64b82}{rMode}) const 
\item 
{\footnotesize template$<$class fpType $>$ }\\fpType \hyperlink{classArmISA_1_1FpOp_a0129111f707a89446f721aafe6b11748}{unaryOp} (FPSCR \&fpscr, fpType op1, fpType($\ast$func)(fpType), bool flush, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{namespaceArmISA_a6a8214ac21eb2991c2975c0380f64b82}{rMode}) const 
\item 
void \hyperlink{classArmISA_1_1FpOp_af04cd01429462d48e635f3e01ced6257}{advancePC} (PCState \&pcState) const 
\item 
float \hyperlink{classArmISA_1_1FpOp_a9a613f482c9fae6ba0296c19fe21a40d}{fpSqrt} (FPSCR fpscr, float x) const 
\item 
double \hyperlink{classArmISA_1_1FpOp_add67ed9b4396f7bde492ceaaf6af403d}{fpSqrt} (FPSCR fpscr, double x) const 
\end{DoxyCompactItemize}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classArmISA_1_1FpOp_ad806871f6f7f01a9f4f4f4326f6d3f70}{
\index{ArmISA::FpOp@{ArmISA::FpOp}!FpOp@{FpOp}}
\index{FpOp@{FpOp}!ArmISA::FpOp@{ArmISA::FpOp}}
\subsubsection[{FpOp}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FpOp} (const char $\ast$ {\em mnem}, \/  {\bf ExtMachInst} {\em \_\-machInst}, \/  OpClass {\em \_\-\_\-opClass})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classArmISA_1_1FpOp_ad806871f6f7f01a9f4f4f4326f6d3f70}



\begin{DoxyCode}
780                                                                      :
781         PredOp(mnem, _machInst, __opClass)
782     {}

\end{DoxyCode}


\subsection{関数}
\hypertarget{classArmISA_1_1FpOp_af04cd01429462d48e635f3e01ced6257}{
\index{ArmISA::FpOp@{ArmISA::FpOp}!advancePC@{advancePC}}
\index{advancePC@{advancePC}!ArmISA::FpOp@{ArmISA::FpOp}}
\subsubsection[{advancePC}]{\setlength{\rightskip}{0pt plus 5cm}void advancePC (PCState \& {\em pcState}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classArmISA_1_1FpOp_af04cd01429462d48e635f3e01ced6257}


\hyperlink{classArmISA_1_1ArmStaticInst_af04cd01429462d48e635f3e01ced6257}{ArmStaticInst}を再定義しています。


\begin{DoxyCode}
852     {
853         if (flags[IsLastMicroop]) {
854             pcState.uEnd();
855         } else if (flags[IsMicroop]) {
856             pcState.uAdvance();
857         } else {
858             pcState.advance();
859         }
860     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1FpOp_acd464f48fab5cc85b99d2f45897149ba}{
\index{ArmISA::FpOp@{ArmISA::FpOp}!binaryOp@{binaryOp}}
\index{binaryOp@{binaryOp}!ArmISA::FpOp@{ArmISA::FpOp}}
\subsubsection[{binaryOp}]{\setlength{\rightskip}{0pt plus 5cm}fpType binaryOp (FPSCR \& {\em fpscr}, \/  fpType {\em op1}, \/  fpType {\em op2}, \/  fpType($\ast$)(fpType, fpType) {\em func}, \/  bool {\em flush}, \/  bool {\em defaultNan}, \/  {\bf uint32\_\-t} {\em rMode}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classArmISA_1_1FpOp_acd464f48fab5cc85b99d2f45897149ba}



\begin{DoxyCode}
1006 {
1007     const bool single = (sizeof(fpType) == sizeof(float));
1008     fpType junk = 0.0;
1009 
1010     if (flush && flushToZero(op1, op2))
1011         fpscr.idc = 1;
1012     VfpSavedState state = prepFpState(rMode);
1013     __asm__ __volatile__ ("" : "=m" (op1), "=m" (op2), "=m" (state)
1014                              : "m" (op1), "m" (op2), "m" (state));
1015     fpType dest = func(op1, op2);
1016     __asm__ __volatile__ ("" : "=m" (dest) : "m" (dest));
1017 
1018     // Get NAN behavior right. This varies between x86 and ARM.
1019     if (std::isnan(dest)) {
1020         const uint64_t qnan =
1021             single ? 0x7fc00000 : ULL(0x7ff8000000000000);
1022         const bool nan1 = std::isnan(op1);
1023         const bool nan2 = std::isnan(op2);
1024         const bool signal1 = nan1 && ((fpToBits(op1) & qnan) != qnan);
1025         const bool signal2 = nan2 && ((fpToBits(op2) & qnan) != qnan);
1026         if ((!nan1 && !nan2) || (defaultNan == 1)) {
1027             dest = bitsToFp(qnan, junk);
1028         } else if (signal1) {
1029             dest = bitsToFp(fpToBits(op1) | qnan, junk);
1030         } else if (signal2) {
1031             dest = bitsToFp(fpToBits(op2) | qnan, junk);
1032         } else if (nan1) {
1033             dest = op1;
1034         } else if (nan2) {
1035             dest = op2;
1036         }
1037     } else if (flush && flushToZero(dest)) {
1038         feraiseexcept(FeUnderflow);
1039     } else if ((
1040                 (single && (dest == bitsToFp(0x00800000, junk) ||
1041                      dest == bitsToFp(0x80800000, junk))) ||
1042                 (!single &&
1043                     (dest == bitsToFp(ULL(0x0010000000000000), junk) ||
1044                      dest == bitsToFp(ULL(0x8010000000000000), junk)))
1045                ) && rMode != VfpRoundZero) {
1046         /*
1047          * Correct for the fact that underflow is detected -before- rounding
1048          * in ARM and -after- rounding in x86.
1049          */
1050         fesetround(FeRoundZero);
1051         __asm__ __volatile__ ("" : "=m" (op1), "=m" (op2)
1052                                  : "m" (op1), "m" (op2));
1053         fpType temp = func(op1, op2);
1054         __asm__ __volatile__ ("" : "=m" (temp) : "m" (temp));
1055         if (flush && flushToZero(temp)) {
1056             dest = temp;
1057         }
1058     }
1059     finishVfp(fpscr, state, flush);
1060     return dest;
1061 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1FpOp_a8b883fad84db432c4e6291c8db223e5e}{
\index{ArmISA::FpOp@{ArmISA::FpOp}!dbl@{dbl}}
\index{dbl@{dbl}!ArmISA::FpOp@{ArmISA::FpOp}}
\subsubsection[{dbl}]{\setlength{\rightskip}{0pt plus 5cm}double dbl ({\bf uint32\_\-t} {\em low}, \/  {\bf uint32\_\-t} {\em high}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classArmISA_1_1FpOp_a8b883fad84db432c4e6291c8db223e5e}



\begin{DoxyCode}
810     {
811         double junk = 0.0;
812         return bitsToFp((uint64_t)low | ((uint64_t)high << 32), junk);
813     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1FpOp_a0a20a848b3881593f6250834f4c4e53d}{
\index{ArmISA::FpOp@{ArmISA::FpOp}!dblHi@{dblHi}}
\index{dblHi@{dblHi}!ArmISA::FpOp@{ArmISA::FpOp}}
\subsubsection[{dblHi}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} dblHi (double {\em val}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classArmISA_1_1FpOp_a0a20a848b3881593f6250834f4c4e53d}



\begin{DoxyCode}
823     {
824         return fpToBits(val) >> 32;
825     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1FpOp_af317a029a04e1eb855f20b3c76aa2d79}{
\index{ArmISA::FpOp@{ArmISA::FpOp}!dblLow@{dblLow}}
\index{dblLow@{dblLow}!ArmISA::FpOp@{ArmISA::FpOp}}
\subsubsection[{dblLow}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} dblLow (double {\em val}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classArmISA_1_1FpOp_af317a029a04e1eb855f20b3c76aa2d79}



\begin{DoxyCode}
817     {
818         return fpToBits(val);
819     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1FpOp_ad1ec33e89716d3410e023846aaab378e}{
\index{ArmISA::FpOp@{ArmISA::FpOp}!doOp@{doOp}}
\index{doOp@{doOp}!ArmISA::FpOp@{ArmISA::FpOp}}
\subsubsection[{doOp}]{\setlength{\rightskip}{0pt plus 5cm}virtual double doOp (double {\em op1}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classArmISA_1_1FpOp_ad1ec33e89716d3410e023846aaab378e}



\begin{DoxyCode}
804     {
805         panic("Unimplemented version of doOp called.\n");
806     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1FpOp_a42bfa4e0c737bc1df68d12362d927535}{
\index{ArmISA::FpOp@{ArmISA::FpOp}!doOp@{doOp}}
\index{doOp@{doOp}!ArmISA::FpOp@{ArmISA::FpOp}}
\subsubsection[{doOp}]{\setlength{\rightskip}{0pt plus 5cm}virtual double doOp (double {\em op1}, \/  double {\em op2}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classArmISA_1_1FpOp_a42bfa4e0c737bc1df68d12362d927535}



\begin{DoxyCode}
798     {
799         panic("Unimplemented version of doOp called.\n");
800     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1FpOp_aec4d44856f9781717b36125acfcc45d3}{
\index{ArmISA::FpOp@{ArmISA::FpOp}!doOp@{doOp}}
\index{doOp@{doOp}!ArmISA::FpOp@{ArmISA::FpOp}}
\subsubsection[{doOp}]{\setlength{\rightskip}{0pt plus 5cm}virtual float doOp (float {\em op1}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classArmISA_1_1FpOp_aec4d44856f9781717b36125acfcc45d3}



\begin{DoxyCode}
792     {
793         panic("Unimplemented version of doOp called.\n");
794     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1FpOp_ae6e7fab9137bf946035338c924967bde}{
\index{ArmISA::FpOp@{ArmISA::FpOp}!doOp@{doOp}}
\index{doOp@{doOp}!ArmISA::FpOp@{ArmISA::FpOp}}
\subsubsection[{doOp}]{\setlength{\rightskip}{0pt plus 5cm}virtual float doOp (float {\em op1}, \/  float {\em op2}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classArmISA_1_1FpOp_ae6e7fab9137bf946035338c924967bde}



\begin{DoxyCode}
786     {
787         panic("Unimplemented version of doOp called.\n");
788     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1FpOp_add67ed9b4396f7bde492ceaaf6af403d}{
\index{ArmISA::FpOp@{ArmISA::FpOp}!fpSqrt@{fpSqrt}}
\index{fpSqrt@{fpSqrt}!ArmISA::FpOp@{ArmISA::FpOp}}
\subsubsection[{fpSqrt}]{\setlength{\rightskip}{0pt plus 5cm}double fpSqrt (FPSCR {\em fpscr}, \/  double {\em x}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classArmISA_1_1FpOp_add67ed9b4396f7bde492ceaaf6af403d}



\begin{DoxyCode}
872     {
873 
874         return unaryOp(fpscr,x,sqrt,fpscr.fz,fpscr.rMode);
875 
876     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1FpOp_a9a613f482c9fae6ba0296c19fe21a40d}{
\index{ArmISA::FpOp@{ArmISA::FpOp}!fpSqrt@{fpSqrt}}
\index{fpSqrt@{fpSqrt}!ArmISA::FpOp@{ArmISA::FpOp}}
\subsubsection[{fpSqrt}]{\setlength{\rightskip}{0pt plus 5cm}float fpSqrt (FPSCR {\em fpscr}, \/  float {\em x}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classArmISA_1_1FpOp_a9a613f482c9fae6ba0296c19fe21a40d}



\begin{DoxyCode}
864     {
865 
866         return unaryOp(fpscr,x,sqrtf,fpscr.fz,fpscr.rMode);
867 
868     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1FpOp_a0bb9efaddc2b7ac41cd08d497657e092}{
\index{ArmISA::FpOp@{ArmISA::FpOp}!processNans@{processNans}}
\index{processNans@{processNans}!ArmISA::FpOp@{ArmISA::FpOp}}
\subsubsection[{processNans}]{\setlength{\rightskip}{0pt plus 5cm}fpType processNans (FPSCR \& {\em fpscr}, \/  bool \& {\em done}, \/  bool {\em defaultNan}, \/  fpType {\em op1}, \/  fpType {\em op2}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classArmISA_1_1FpOp_a0bb9efaddc2b7ac41cd08d497657e092}



\begin{DoxyCode}
883 {
884     done = true;
885     fpType junk = 0.0;
886     fpType dest = 0.0;
887     const bool single = (sizeof(fpType) == sizeof(float));
888     const uint64_t qnan =
889         single ? 0x7fc00000 : ULL(0x7ff8000000000000);
890     const bool nan1 = std::isnan(op1);
891     const bool nan2 = std::isnan(op2);
892     const bool signal1 = nan1 && ((fpToBits(op1) & qnan) != qnan);
893     const bool signal2 = nan2 && ((fpToBits(op2) & qnan) != qnan);
894     if (nan1 || nan2) {
895         if (defaultNan) {
896             dest = bitsToFp(qnan, junk);
897         }  else if (signal1) {
898             dest = bitsToFp(fpToBits(op1) | qnan, junk);
899         } else if (signal2) {
900             dest = bitsToFp(fpToBits(op2) | qnan, junk);
901         } else if (nan1) {
902             dest = op1;
903         } else if (nan2) {
904             dest = op2;
905         }
906         if (signal1 || signal2) {
907             fpscr.ioc = 1;
908         }
909     } else {
910         done = false;
911     }
912     return dest;
913 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1FpOp_a90767d472cab7e40d318351bf1aa8c12}{
\index{ArmISA::FpOp@{ArmISA::FpOp}!ternaryOp@{ternaryOp}}
\index{ternaryOp@{ternaryOp}!ArmISA::FpOp@{ArmISA::FpOp}}
\subsubsection[{ternaryOp}]{\setlength{\rightskip}{0pt plus 5cm}fpType ternaryOp (FPSCR \& {\em fpscr}, \/  fpType {\em op1}, \/  fpType {\em op2}, \/  fpType {\em op3}, \/  fpType($\ast$)(fpType, fpType, fpType) {\em func}, \/  bool {\em flush}, \/  bool {\em defaultNan}, \/  {\bf uint32\_\-t} {\em rMode}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classArmISA_1_1FpOp_a90767d472cab7e40d318351bf1aa8c12}



\begin{DoxyCode}
928 {
929     const bool single = (sizeof(fpType) == sizeof(float));
930     fpType junk = 0.0;
931 
932     if (flush && (flushToZero(op1, op2) || flushToZero(op3)))
933         fpscr.idc = 1;
934     VfpSavedState state = prepFpState(rMode);
935     __asm__ __volatile__ ("" : "=m" (op1), "=m" (op2), "=m" (op3), "=m" (state)
936                              :  "m" (op1),  "m" (op2),  "m" (op3),  "m" (state));
      
937     fpType dest = func(op1, op2, op3);
938     __asm__ __volatile__ ("" : "=m" (dest) : "m" (dest));
939 
940     int fpClass = std::fpclassify(dest);
941     // Get NAN behavior right. This varies between x86 and ARM.
942     if (fpClass == FP_NAN) {
943         const uint64_t qnan =
944             single ? 0x7fc00000 : ULL(0x7ff8000000000000);
945         const bool nan1 = std::isnan(op1);
946         const bool nan2 = std::isnan(op2);
947         const bool nan3 = std::isnan(op3);
948         const bool signal1 = nan1 && ((fpToBits(op1) & qnan) != qnan);
949         const bool signal2 = nan2 && ((fpToBits(op2) & qnan) != qnan);
950         const bool signal3 = nan3 && ((fpToBits(op3) & qnan) != qnan);
951         if ((!nan1 && !nan2 && !nan3) || (defaultNan == 1)) {
952             dest = bitsToFp(qnan, junk);
953         } else if (signal1) {
954             dest = bitsToFp(fpToBits(op1) | qnan, junk);
955         } else if (signal2) {
956             dest = bitsToFp(fpToBits(op2) | qnan, junk);
957         } else if (signal3) {
958             dest = bitsToFp(fpToBits(op3) | qnan, junk);
959         } else if (nan1) {
960             dest = op1;
961         } else if (nan2) {
962             dest = op2;
963         } else if (nan3) {
964             dest = op3;
965         }
966     } else if (flush && flushToZero(dest)) {
967         feraiseexcept(FeUnderflow);
968     } else if ((
969                 (single && (dest == bitsToFp(0x00800000, junk) ||
970                      dest == bitsToFp(0x80800000, junk))) ||
971                 (!single &&
972                     (dest == bitsToFp(ULL(0x0010000000000000), junk) ||
973                      dest == bitsToFp(ULL(0x8010000000000000), junk)))
974                ) && rMode != VfpRoundZero) {
975         /*
976          * Correct for the fact that underflow is detected -before- rounding
977          * in ARM and -after- rounding in x86.
978          */
979         fesetround(FeRoundZero);
980         __asm__ __volatile__ ("" : "=m" (op1), "=m" (op2), "=m" (op3)
981                                  :  "m" (op1),  "m" (op2),  "m" (op3));
982         fpType temp = func(op1, op2, op2);
983         __asm__ __volatile__ ("" : "=m" (temp) : "m" (temp));
984         if (flush && flushToZero(temp)) {
985             dest = temp;
986         }
987     }
988     finishVfp(fpscr, state, flush);
989     return dest;
990 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1FpOp_a0129111f707a89446f721aafe6b11748}{
\index{ArmISA::FpOp@{ArmISA::FpOp}!unaryOp@{unaryOp}}
\index{unaryOp@{unaryOp}!ArmISA::FpOp@{ArmISA::FpOp}}
\subsubsection[{unaryOp}]{\setlength{\rightskip}{0pt plus 5cm}fpType unaryOp (FPSCR \& {\em fpscr}, \/  fpType {\em op1}, \/  fpType($\ast$)(fpType) {\em func}, \/  bool {\em flush}, \/  {\bf uint32\_\-t} {\em rMode}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classArmISA_1_1FpOp_a0129111f707a89446f721aafe6b11748}



\begin{DoxyCode}
1076 {
1077     const bool single = (sizeof(fpType) == sizeof(float));
1078     fpType junk = 0.0;
1079 
1080     if (flush && flushToZero(op1))
1081         fpscr.idc = 1;
1082     VfpSavedState state = prepFpState(rMode);
1083     __asm__ __volatile__ ("" : "=m" (op1), "=m" (state)
1084                              : "m" (op1), "m" (state));
1085     fpType dest = func(op1);
1086     __asm__ __volatile__ ("" : "=m" (dest) : "m" (dest));
1087 
1088     // Get NAN behavior right. This varies between x86 and ARM.
1089     if (std::isnan(dest)) {
1090         const uint64_t qnan =
1091             single ? 0x7fc00000 : ULL(0x7ff8000000000000);
1092         const bool nan = std::isnan(op1);
1093         if (!nan || fpscr.dn == 1) {
1094             dest = bitsToFp(qnan, junk);
1095         } else if (nan) {
1096             dest = bitsToFp(fpToBits(op1) | qnan, junk);
1097         }
1098     } else if (flush && flushToZero(dest)) {
1099         feraiseexcept(FeUnderflow);
1100     } else if ((
1101                 (single && (dest == bitsToFp(0x00800000, junk) ||
1102                      dest == bitsToFp(0x80800000, junk))) ||
1103                 (!single &&
1104                     (dest == bitsToFp(ULL(0x0010000000000000), junk) ||
1105                      dest == bitsToFp(ULL(0x8010000000000000), junk)))
1106                ) && rMode != VfpRoundZero) {
1107         /*
1108          * Correct for the fact that underflow is detected -before- rounding
1109          * in ARM and -after- rounding in x86.
1110          */
1111         fesetround(FeRoundZero);
1112         __asm__ __volatile__ ("" : "=m" (op1) : "m" (op1));
1113         fpType temp = func(op1);
1114         __asm__ __volatile__ ("" : "=m" (temp) : "m" (temp));
1115         if (flush && flushToZero(temp)) {
1116             dest = temp;
1117         }
1118     }
1119     finishVfp(fpscr, state, flush);
1120     return dest;
1121 }
\end{DoxyCode}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/arm/insts/\hyperlink{vfp_8hh}{vfp.hh}\item 
arch/arm/insts/\hyperlink{vfp_8cc}{vfp.cc}\end{DoxyCompactItemize}
