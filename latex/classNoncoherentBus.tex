\hypertarget{classNoncoherentBus}{
\section{クラス NoncoherentBus}
\label{classNoncoherentBus}\index{NoncoherentBus@{NoncoherentBus}}
}


{\ttfamily \#include $<$noncoherent\_\-bus.hh$>$}NoncoherentBusに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=6cm]{classNoncoherentBus}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classNoncoherentBus_1_1NoncoherentBusMasterPort}{NoncoherentBusMasterPort}
\item 
class \hyperlink{classNoncoherentBus_1_1NoncoherentBusSlavePort}{NoncoherentBusSlavePort}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classNoncoherentBus_a12760c9f0ef395e273e820a9d1db9cd9}{NoncoherentBus} (const NoncoherentBusParams $\ast$p)
\item 
virtual \hyperlink{classNoncoherentBus_a80310b44cba4493123399310722fd6e6}{$\sim$NoncoherentBus} ()
\item 
unsigned int \hyperlink{classNoncoherentBus_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)
\item 
virtual void \hyperlink{classNoncoherentBus_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classNoncoherentBus_a7040fa8d9fb24afb9f4fe245b135da19}{dataThroughBus}
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classBaseBus_1_1Layer}{Layer}$<$ \hyperlink{classSlavePort}{SlavePort}, \hyperlink{classMasterPort}{MasterPort} $>$ \hyperlink{classNoncoherentBus_ae15f02c0dca186fbfbd2f7b732e5b441}{ReqLayer}
\item 
typedef \hyperlink{classBaseBus_1_1Layer}{Layer}$<$ \hyperlink{classMasterPort}{MasterPort}, \hyperlink{classSlavePort}{SlavePort} $>$ \hyperlink{classNoncoherentBus_a40797c56ea5eaf481f56dfdc3ab1b399}{RespLayer}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
virtual bool \hyperlink{classNoncoherentBus_a8e2d7ccc3adb605e763f2bd1c64e5128}{recvTimingReq} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} slave\_\-port\_\-id)
\item 
virtual bool \hyperlink{classNoncoherentBus_a47ba09f9a3b3998cac9c14ab596a7515}{recvTimingResp} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} master\_\-port\_\-id)
\item 
void \hyperlink{classNoncoherentBus_a96f9cd33bfb9a8b7fb2b25078eaf75a1}{recvRetry} (\hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} master\_\-port\_\-id)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classNoncoherentBus_ab0e34155d341f5561834eca8e4c97759}{recvAtomic} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} slave\_\-port\_\-id)
\item 
void \hyperlink{classNoncoherentBus_a5cdfa7d369ba37394403d3c2bd5cf6d1}{recvFunctional} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} slave\_\-port\_\-id)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classBaseBus_1_1Layer}{ReqLayer} $\ast$ $>$ \hyperlink{classNoncoherentBus_ab124575386549f77de080cd9fcaf2ba0}{reqLayers}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classBaseBus_1_1Layer}{RespLayer} $\ast$ $>$ \hyperlink{classNoncoherentBus_a2f42dda70e78f1e5e9574f11b465d173}{respLayers}
\end{DoxyCompactItemize}


\subsection{説明}
A non-\/coherent bus connects a number of non-\/snooping masters and slaves, and routes the request and response packets based on the address. The request packets issued by the master connected to a non-\/coherent bus could still snoop in caches attached to a coherent bus, as is the case with the I/O bus and memory bus in most system configurations. No snoops will, however, reach any master on the non-\/coherent bus itself.

The non-\/coherent bus can be used as a template for modelling PCI, PCIe, and non-\/coherent AMBA and OCP buses, and is typically used for the I/O buses. 

\subsection{型定義}
\hypertarget{classNoncoherentBus_ae15f02c0dca186fbfbd2f7b732e5b441}{
\index{NoncoherentBus@{NoncoherentBus}!ReqLayer@{ReqLayer}}
\index{ReqLayer@{ReqLayer}!NoncoherentBus@{NoncoherentBus}}
\subsubsection[{ReqLayer}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Layer}$<${\bf SlavePort},{\bf MasterPort}$>$ {\bf ReqLayer}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classNoncoherentBus_ae15f02c0dca186fbfbd2f7b732e5b441}
Declare the layers of this bus, one vector for requests and one for responses. \hypertarget{classNoncoherentBus_a40797c56ea5eaf481f56dfdc3ab1b399}{
\index{NoncoherentBus@{NoncoherentBus}!RespLayer@{RespLayer}}
\index{RespLayer@{RespLayer}!NoncoherentBus@{NoncoherentBus}}
\subsubsection[{RespLayer}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Layer}$<${\bf MasterPort},{\bf SlavePort}$>$ {\bf RespLayer}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classNoncoherentBus_a40797c56ea5eaf481f56dfdc3ab1b399}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classNoncoherentBus_a12760c9f0ef395e273e820a9d1db9cd9}{
\index{NoncoherentBus@{NoncoherentBus}!NoncoherentBus@{NoncoherentBus}}
\index{NoncoherentBus@{NoncoherentBus}!NoncoherentBus@{NoncoherentBus}}
\subsubsection[{NoncoherentBus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf NoncoherentBus} (const NoncoherentBusParams $\ast$ {\em p})}}
\label{classNoncoherentBus_a12760c9f0ef395e273e820a9d1db9cd9}



\begin{DoxyCode}
58     : BaseBus(p)
59 {
60     // create the ports based on the size of the master and slave
61     // vector ports, and the presence of the default port, the ports
62     // are enumerated starting from zero
63     for (int i = 0; i < p->port_master_connection_count; ++i) {
64         std::string portName = csprintf("%s.master[%d]", name(), i);
65         MasterPort* bp = new NoncoherentBusMasterPort(portName, *this, i);
66         masterPorts.push_back(bp);
67         reqLayers.push_back(new ReqLayer(*bp, *this,
68                                          csprintf(".reqLayer%d", i)));
69     }
70 
71     // see if we have a default slave device connected and if so add
72     // our corresponding master port
73     if (p->port_default_connection_count) {
74         defaultPortID = masterPorts.size();
75         std::string portName = name() + ".default";
76         MasterPort* bp = new NoncoherentBusMasterPort(portName, *this,
77                                                       defaultPortID);
78         masterPorts.push_back(bp);
79         reqLayers.push_back(new ReqLayer(*bp, *this, csprintf(".reqLayer%d",
80                                                               defaultPortID)));
81     }
82 
83     // create the slave ports, once again starting at zero
84     for (int i = 0; i < p->port_slave_connection_count; ++i) {
85         std::string portName = csprintf("%s.slave[%d]", name(), i);
86         SlavePort* bp = new NoncoherentBusSlavePort(portName, *this, i);
87         slavePorts.push_back(bp);
88         respLayers.push_back(new RespLayer(*bp, *this,
89                                            csprintf(".respLayer%d", i)));
90     }
91 
92     clearPortCache();
93 }
\end{DoxyCode}
\hypertarget{classNoncoherentBus_a80310b44cba4493123399310722fd6e6}{
\index{NoncoherentBus@{NoncoherentBus}!$\sim$NoncoherentBus@{$\sim$NoncoherentBus}}
\index{$\sim$NoncoherentBus@{$\sim$NoncoherentBus}!NoncoherentBus@{NoncoherentBus}}
\subsubsection[{$\sim$NoncoherentBus}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf NoncoherentBus} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classNoncoherentBus_a80310b44cba4493123399310722fd6e6}



\begin{DoxyCode}
96 {
97     for (auto l = reqLayers.begin(); l != reqLayers.end(); ++l)
98         delete *l;
99     for (auto l = respLayers.begin(); l != respLayers.end(); ++l)
100         delete *l;
101 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classNoncoherentBus_aa8a18d230dba7a674ac8a0b4f35bc36a}{
\index{NoncoherentBus@{NoncoherentBus}!drain@{drain}}
\index{drain@{drain}!NoncoherentBus@{NoncoherentBus}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em drainManger})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classNoncoherentBus_aa8a18d230dba7a674ac8a0b4f35bc36a}
Provide a default implementation of the drain interface that simply returns 0 (draining completed) and sets the drain state to Drained. 

\hyperlink{classBaseBus_ac8c1510f7e1591e75a5c79b4b873f6b4}{BaseBus}を実装しています。


\begin{DoxyCode}
268 {
269     // sum up the individual layers
270     unsigned int total = 0;
271     for (auto l = reqLayers.begin(); l != reqLayers.end(); ++l)
272         total += (*l)->drain(dm);
273     for (auto l = respLayers.begin(); l != respLayers.end(); ++l)
274         total += (*l)->drain(dm);
275     return total;
276 }
\end{DoxyCode}
\hypertarget{classNoncoherentBus_ab0e34155d341f5561834eca8e4c97759}{
\index{NoncoherentBus@{NoncoherentBus}!recvAtomic@{recvAtomic}}
\index{recvAtomic@{recvAtomic}!NoncoherentBus@{NoncoherentBus}}
\subsubsection[{recvAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvAtomic ({\bf PacketPtr} {\em pkt}, \/  {\bf PortID} {\em slave\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classNoncoherentBus_ab0e34155d341f5561834eca8e4c97759}
Function called by the port when the bus is recieving a Atomic transaction. 


\begin{DoxyCode}
225 {
226     DPRINTF(NoncoherentBus, "recvAtomic: packet src %s addr 0x%x cmd %s\n",
227             slavePorts[slave_port_id]->name(), pkt->getAddr(),
228             pkt->cmdString());
229 
230     // add the request data
231     dataThroughBus += pkt->hasData() ? pkt->getSize() : 0;
232 
233     // determine the destination port
234     PortID dest_id = findPort(pkt->getAddr());
235 
236     // forward the request to the appropriate destination
237     Tick response_latency = masterPorts[dest_id]->sendAtomic(pkt);
238 
239     // add the response data
240     if (pkt->isResponse())
241         dataThroughBus += pkt->hasData() ? pkt->getSize() : 0;
242 
243     // @todo: Not setting first-word time
244     pkt->busLastWordDelay = response_latency;
245     return response_latency;
246 }
\end{DoxyCode}
\hypertarget{classNoncoherentBus_a5cdfa7d369ba37394403d3c2bd5cf6d1}{
\index{NoncoherentBus@{NoncoherentBus}!recvFunctional@{recvFunctional}}
\index{recvFunctional@{recvFunctional}!NoncoherentBus@{NoncoherentBus}}
\subsubsection[{recvFunctional}]{\setlength{\rightskip}{0pt plus 5cm}void recvFunctional ({\bf PacketPtr} {\em pkt}, \/  {\bf PortID} {\em slave\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classNoncoherentBus_a5cdfa7d369ba37394403d3c2bd5cf6d1}
Function called by the port when the bus is recieving a Functional transaction. 


\begin{DoxyCode}
250 {
251     if (!pkt->isPrint()) {
252         // don't do DPRINTFs on PrintReq as it clutters up the output
253         DPRINTF(NoncoherentBus,
254                 "recvFunctional: packet src %s addr 0x%x cmd %s\n",
255                 slavePorts[slave_port_id]->name(), pkt->getAddr(),
256                 pkt->cmdString());
257     }
258 
259     // determine the destination port
260     PortID dest_id = findPort(pkt->getAddr());
261 
262     // forward the request to the appropriate destination
263     masterPorts[dest_id]->sendFunctional(pkt);
264 }
\end{DoxyCode}
\hypertarget{classNoncoherentBus_a96f9cd33bfb9a8b7fb2b25078eaf75a1}{
\index{NoncoherentBus@{NoncoherentBus}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!NoncoherentBus@{NoncoherentBus}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetry ({\bf PortID} {\em master\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classNoncoherentBus_a96f9cd33bfb9a8b7fb2b25078eaf75a1}
Timing function called by port when it is once again able to process requests. 


\begin{DoxyCode}
216 {
217     // responses never block on forwarding them, so the retry will
218     // always be coming from a port to which we tried to forward a
219     // request
220     reqLayers[master_port_id]->recvRetry();
221 }
\end{DoxyCode}
\hypertarget{classNoncoherentBus_a8e2d7ccc3adb605e763f2bd1c64e5128}{
\index{NoncoherentBus@{NoncoherentBus}!recvTimingReq@{recvTimingReq}}
\index{recvTimingReq@{recvTimingReq}!NoncoherentBus@{NoncoherentBus}}
\subsubsection[{recvTimingReq}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingReq ({\bf PacketPtr} {\em pkt}, \/  {\bf PortID} {\em slave\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classNoncoherentBus_a8e2d7ccc3adb605e763f2bd1c64e5128}
Function called by the port when the bus is recieving a Timing request packet. 


\begin{DoxyCode}
105 {
106     // determine the source port based on the id
107     SlavePort *src_port = slavePorts[slave_port_id];
108 
109     // we should never see express snoops on a non-coherent bus
110     assert(!pkt->isExpressSnoop());
111 
112     // determine the destination based on the address
113     PortID master_port_id = findPort(pkt->getAddr());
114 
115     // test if the bus should be considered occupied for the current
116     // port
117     if (!reqLayers[master_port_id]->tryTiming(src_port)) {
118         DPRINTF(NoncoherentBus, "recvTimingReq: src %s %s 0x%x BUSY\n",
119                 src_port->name(), pkt->cmdString(), pkt->getAddr());
120         return false;
121     }
122 
123     DPRINTF(NoncoherentBus, "recvTimingReq: src %s %s 0x%x\n",
124             src_port->name(), pkt->cmdString(), pkt->getAddr());
125 
126     // store size and command as they might be modified when
127     // forwarding the packet
128     unsigned int pkt_size = pkt->hasData() ? pkt->getSize() : 0;
129     unsigned int pkt_cmd = pkt->cmdToIndex();
130 
131     // set the source port for routing of the response
132     pkt->setSrc(slave_port_id);
133 
134     calcPacketTiming(pkt);
135     Tick packetFinishTime = pkt->busLastWordDelay + curTick();
136 
137     // since it is a normal request, attempt to send the packet
138     bool success = masterPorts[master_port_id]->sendTimingReq(pkt);
139 
140     if (!success)  {
141         // inhibited packets should never be forced to retry
142         assert(!pkt->memInhibitAsserted());
143 
144         DPRINTF(NoncoherentBus, "recvTimingReq: src %s %s 0x%x RETRY\n",
145                 src_port->name(), pkt->cmdString(), pkt->getAddr());
146 
147         // undo the calculation so we can check for 0 again
148         pkt->busFirstWordDelay = pkt->busLastWordDelay = 0;
149 
150         // occupy until the header is sent
151         reqLayers[master_port_id]->failedTiming(src_port,
152                                                 clockEdge(headerCycles));
153 
154         return false;
155     }
156 
157     reqLayers[master_port_id]->succeededTiming(packetFinishTime);
158 
159     // stats updates
160     dataThroughBus += pkt_size;
161     pktCount[slave_port_id][master_port_id]++;
162     totPktSize[slave_port_id][master_port_id] += pkt_size;
163     transDist[pkt_cmd]++;
164 
165     return true;
166 }
\end{DoxyCode}
\hypertarget{classNoncoherentBus_a47ba09f9a3b3998cac9c14ab596a7515}{
\index{NoncoherentBus@{NoncoherentBus}!recvTimingResp@{recvTimingResp}}
\index{recvTimingResp@{recvTimingResp}!NoncoherentBus@{NoncoherentBus}}
\subsubsection[{recvTimingResp}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingResp ({\bf PacketPtr} {\em pkt}, \/  {\bf PortID} {\em master\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classNoncoherentBus_a47ba09f9a3b3998cac9c14ab596a7515}
Function called by the port when the bus is recieving a Timing response packet. 


\begin{DoxyCode}
170 {
171     // determine the source port based on the id
172     MasterPort *src_port = masterPorts[master_port_id];
173 
174     // determine the destination based on what is stored in the packet
175     PortID slave_port_id = pkt->getDest();
176 
177     // test if the bus should be considered occupied for the current
178     // port
179     if (!respLayers[slave_port_id]->tryTiming(src_port)) {
180         DPRINTF(NoncoherentBus, "recvTimingResp: src %s %s 0x%x BUSY\n",
181                 src_port->name(), pkt->cmdString(), pkt->getAddr());
182         return false;
183     }
184 
185     DPRINTF(NoncoherentBus, "recvTimingResp: src %s %s 0x%x\n",
186             src_port->name(), pkt->cmdString(), pkt->getAddr());
187 
188     // store size and command as they might be modified when
189     // forwarding the packet
190     unsigned int pkt_size = pkt->hasData() ? pkt->getSize() : 0;
191     unsigned int pkt_cmd = pkt->cmdToIndex();
192 
193     calcPacketTiming(pkt);
194     Tick packetFinishTime = pkt->busLastWordDelay + curTick();
195 
196     // send the packet through the destination slave port
197     bool success M5_VAR_USED = slavePorts[slave_port_id]->sendTimingResp(pkt);
198 
199     // currently it is illegal to block responses... can lead to
200     // deadlock
201     assert(success);
202 
203     respLayers[slave_port_id]->succeededTiming(packetFinishTime);
204 
205     // stats updates
206     dataThroughBus += pkt_size;
207     pktCount[slave_port_id][master_port_id]++;
208     totPktSize[slave_port_id][master_port_id] += pkt_size;
209     transDist[pkt_cmd]++;
210 
211     return true;
212 }
\end{DoxyCode}
\hypertarget{classNoncoherentBus_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{NoncoherentBus@{NoncoherentBus}!regStats@{regStats}}
\index{regStats@{regStats}!NoncoherentBus@{NoncoherentBus}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classNoncoherentBus_a4dc637449366fcdfc4e764cdf12d9b11}
stats 

\hyperlink{classBaseBus_a4dc637449366fcdfc4e764cdf12d9b11}{BaseBus}を再定義しています。


\begin{DoxyCode}
286 {
287     // register the stats of the base class and our two bus layers
288     BaseBus::regStats();
289     for (auto l = reqLayers.begin(); l != reqLayers.end(); ++l)
290         (*l)->regStats();
291     for (auto l = respLayers.begin(); l != respLayers.end(); ++l)
292         (*l)->regStats();
293 
294     dataThroughBus
295         .name(name() + ".data_through_bus")
296         .desc("Total data (bytes)")
297         ;
298 
299     throughput
300         .name(name() + ".throughput")
301         .desc("Throughput (bytes/s)")
302         .precision(0)
303         ;
304 
305     throughput = dataThroughBus / simSeconds;
306 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classNoncoherentBus_a7040fa8d9fb24afb9f4fe245b135da19}{
\index{NoncoherentBus@{NoncoherentBus}!dataThroughBus@{dataThroughBus}}
\index{dataThroughBus@{dataThroughBus}!NoncoherentBus@{NoncoherentBus}}
\subsubsection[{dataThroughBus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf dataThroughBus}}}
\label{classNoncoherentBus_a7040fa8d9fb24afb9f4fe245b135da19}
\hypertarget{classNoncoherentBus_ab124575386549f77de080cd9fcaf2ba0}{
\index{NoncoherentBus@{NoncoherentBus}!reqLayers@{reqLayers}}
\index{reqLayers@{reqLayers}!NoncoherentBus@{NoncoherentBus}}
\subsubsection[{reqLayers}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf ReqLayer}$\ast$$>$ {\bf reqLayers}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classNoncoherentBus_ab124575386549f77de080cd9fcaf2ba0}
\hypertarget{classNoncoherentBus_a2f42dda70e78f1e5e9574f11b465d173}{
\index{NoncoherentBus@{NoncoherentBus}!respLayers@{respLayers}}
\index{respLayers@{respLayers}!NoncoherentBus@{NoncoherentBus}}
\subsubsection[{respLayers}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf RespLayer}$\ast$$>$ {\bf respLayers}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classNoncoherentBus_a2f42dda70e78f1e5e9574f11b465d173}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{noncoherent__bus_8hh}{noncoherent\_\-bus.hh}\item 
mem/\hyperlink{noncoherent__bus_8cc}{noncoherent\_\-bus.cc}\end{DoxyCompactItemize}
