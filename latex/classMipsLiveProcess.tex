\hypertarget{classMipsLiveProcess}{
\section{クラス MipsLiveProcess}
\label{classMipsLiveProcess}\index{MipsLiveProcess@{MipsLiveProcess}}
}


{\ttfamily \#include $<$process.hh$>$}MipsLiveProcessに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4.55285cm]{classMipsLiveProcess}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{namespaceMipsISA_adf027691dfdcdef6002693b1e033700d}{MipsISA::IntReg} \hyperlink{classMipsLiveProcess_ae30d5e2e0fa415fc951786462325dde3}{getSyscallArg} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc, int \&i)
\item 
void \hyperlink{classMipsLiveProcess_a032ac505186d9587516a73cdc17f4c0d}{setSyscallArg} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc, int i, \hyperlink{namespaceMipsISA_adf027691dfdcdef6002693b1e033700d}{MipsISA::IntReg} val)
\item 
void \hyperlink{classMipsLiveProcess_aaefd02663c1eae206b851290d9276a5e}{setSyscallReturn} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{classSyscallReturn}{SyscallReturn} return\_\-value)
\item 
\hyperlink{namespaceMipsISA_adf027691dfdcdef6002693b1e033700d}{MipsISA::IntReg} \hyperlink{classMipsLiveProcess_ae30d5e2e0fa415fc951786462325dde3}{getSyscallArg} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc, int \&i)
\item 
void \hyperlink{classMipsLiveProcess_a032ac505186d9587516a73cdc17f4c0d}{setSyscallArg} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc, int i, \hyperlink{namespaceMipsISA_adf027691dfdcdef6002693b1e033700d}{MipsISA::IntReg} val)
\item 
void \hyperlink{classMipsLiveProcess_aaefd02663c1eae206b851290d9276a5e}{setSyscallReturn} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{classSyscallReturn}{SyscallReturn} return\_\-value)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMipsLiveProcess_a57e08c5387f25b28fe0c146b0d7c8ab2}{MipsLiveProcess} (LiveProcessParams $\ast$params, \hyperlink{classObjectFile}{ObjectFile} $\ast$\hyperlink{classLiveProcess_ab6cfcfa7903c66267b3e0351c3caa809}{objFile})
\item 
void \hyperlink{classMipsLiveProcess_a3c34ea9b29f410748d4435a667484924}{initState} ()
\item 
{\footnotesize template$<$class IntType $>$ }\\void \hyperlink{classMipsLiveProcess_a2415a441aed245469460cac91152385e}{argsInit} (int pageSize)
\item 
\hyperlink{classMipsLiveProcess_a57e08c5387f25b28fe0c146b0d7c8ab2}{MipsLiveProcess} (LiveProcessParams $\ast$params, \hyperlink{classObjectFile}{ObjectFile} $\ast$\hyperlink{classLiveProcess_ab6cfcfa7903c66267b3e0351c3caa809}{objFile})
\item 
void \hyperlink{classMipsLiveProcess_a3c34ea9b29f410748d4435a667484924}{initState} ()
\item 
{\footnotesize template$<$class IntType $>$ }\\void \hyperlink{classMipsLiveProcess_a2415a441aed245469460cac91152385e}{argsInit} (int pageSize)
\end{DoxyCompactItemize}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classMipsLiveProcess_a57e08c5387f25b28fe0c146b0d7c8ab2}{
\index{MipsLiveProcess@{MipsLiveProcess}!MipsLiveProcess@{MipsLiveProcess}}
\index{MipsLiveProcess@{MipsLiveProcess}!MipsLiveProcess@{MipsLiveProcess}}
\subsubsection[{MipsLiveProcess}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MipsLiveProcess} (LiveProcessParams $\ast$ {\em params}, \/  {\bf ObjectFile} $\ast$ {\em objFile})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMipsLiveProcess_a57e08c5387f25b28fe0c146b0d7c8ab2}



\begin{DoxyCode}
50     : LiveProcess(params, objFile)
51 {
52     // Set up stack. On MIPS, stack starts at the top of kuseg
53     // user address space. MIPS stack grows down from here
54     stack_base = 0x7FFFFFFF;
55 
56     // Set pointer for next thread stack.  Reserve 8M for main stack.
57     next_thread_stack_base = stack_base - (8 * 1024 * 1024);
58 
59     // Set up break point (Top of Heap)
60     brk_point = objFile->dataBase() + objFile->dataSize() + objFile->bssSize();
61     brk_point = roundUp(brk_point, VMPageSize);
62 
63     // Set up region for mmaps.  Start it 1GB above the top of the heap.
64     mmap_start = mmap_end = brk_point + 0x40000000L;
65 }
\end{DoxyCode}
\hypertarget{classMipsLiveProcess_a57e08c5387f25b28fe0c146b0d7c8ab2}{
\index{MipsLiveProcess@{MipsLiveProcess}!MipsLiveProcess@{MipsLiveProcess}}
\index{MipsLiveProcess@{MipsLiveProcess}!MipsLiveProcess@{MipsLiveProcess}}
\subsubsection[{MipsLiveProcess}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MipsLiveProcess} (LiveProcessParams $\ast$ {\em params}, \/  {\bf ObjectFile} $\ast$ {\em objFile})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMipsLiveProcess_a57e08c5387f25b28fe0c146b0d7c8ab2}


\subsection{関数}
\hypertarget{classMipsLiveProcess_a2415a441aed245469460cac91152385e}{
\index{MipsLiveProcess@{MipsLiveProcess}!argsInit@{argsInit}}
\index{argsInit@{argsInit}!MipsLiveProcess@{MipsLiveProcess}}
\subsubsection[{argsInit}]{\setlength{\rightskip}{0pt plus 5cm}void argsInit (int {\em pageSize})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classMipsLiveProcess_a2415a441aed245469460cac91152385e}
\hypertarget{classMipsLiveProcess_a2415a441aed245469460cac91152385e}{
\index{MipsLiveProcess@{MipsLiveProcess}!argsInit@{argsInit}}
\index{argsInit@{argsInit}!MipsLiveProcess@{MipsLiveProcess}}
\subsubsection[{argsInit}]{\setlength{\rightskip}{0pt plus 5cm}void argsInit (int {\em pageSize})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classMipsLiveProcess_a2415a441aed245469460cac91152385e}



\begin{DoxyCode}
78 {
79     int intSize = sizeof(IntType);
80 
81     // load object file into target memory
82     objFile->loadSections(initVirtMem);
83 
84     typedef AuxVector<IntType> auxv_t;
85     std::vector<auxv_t> auxv;
86 
87     ElfObject * elfObject = dynamic_cast<ElfObject *>(objFile);
88     if (elfObject)
89     {
90         // Set the system page size
91         auxv.push_back(auxv_t(M5_AT_PAGESZ, MipsISA::VMPageSize));
92         // Set the frequency at which time() increments
93         auxv.push_back(auxv_t(M5_AT_CLKTCK, 100));
94         // For statically linked executables, this is the virtual
95         // address of the program header tables if they appear in the
96         // executable image.
97         auxv.push_back(auxv_t(M5_AT_PHDR, elfObject->programHeaderTable()));
98         DPRINTF(Loader, "auxv at PHDR %08p\n", elfObject->programHeaderTable());
99         // This is the size of a program header entry from the elf file.
100         auxv.push_back(auxv_t(M5_AT_PHENT, elfObject->programHeaderSize()));
101         // This is the number of program headers from the original elf file.
102         auxv.push_back(auxv_t(M5_AT_PHNUM, elfObject->programHeaderCount()));
103         //The entry point to the program
104         auxv.push_back(auxv_t(M5_AT_ENTRY, objFile->entryPoint()));
105         //Different user and group IDs
106         auxv.push_back(auxv_t(M5_AT_UID, uid()));
107         auxv.push_back(auxv_t(M5_AT_EUID, euid()));
108         auxv.push_back(auxv_t(M5_AT_GID, gid()));
109         auxv.push_back(auxv_t(M5_AT_EGID, egid()));
110     }
111 
112     // Calculate how much space we need for arg & env & auxv arrays.
113     int argv_array_size = intSize * (argv.size() + 1);
114     int envp_array_size = intSize * (envp.size() + 1);
115     int auxv_array_size = intSize * 2 * (auxv.size() + 1);
116 
117     int arg_data_size = 0;
118     for (vector<string>::size_type i = 0; i < argv.size(); ++i) {
119         arg_data_size += argv[i].size() + 1;
120     }
121     int env_data_size = 0;
122     for (vector<string>::size_type i = 0; i < envp.size(); ++i) {
123         env_data_size += envp[i].size() + 1;
124     }
125 
126     int space_needed =
127         argv_array_size +
128         envp_array_size +
129         auxv_array_size +
130         arg_data_size +
131         env_data_size;
132 
133     // set bottom of stack
134     stack_min = stack_base - space_needed;
135     // align it
136     stack_min = roundDown(stack_min, pageSize);
137     stack_size = stack_base - stack_min;
138     // map memory
139     allocateMem(stack_min, roundUp(stack_size, pageSize));
140 
141     // map out initial stack contents
142     IntType argv_array_base = stack_min + intSize; // room for argc
143     IntType envp_array_base = argv_array_base + argv_array_size;
144     IntType auxv_array_base = envp_array_base + envp_array_size;
145     IntType arg_data_base = auxv_array_base + auxv_array_size;
146     IntType env_data_base = arg_data_base + arg_data_size;
147 
148     // write contents to stack
149     IntType argc = argv.size();
150 
151     argc = htog((IntType)argc);
152 
153     initVirtMem.writeBlob(stack_min, (uint8_t*)&argc, intSize);
154 
155     copyStringArray(argv, argv_array_base, arg_data_base, initVirtMem);
156 
157     copyStringArray(envp, envp_array_base, env_data_base, initVirtMem);
158 
159     // Copy the aux vector
160     for (typename vector<auxv_t>::size_type x = 0; x < auxv.size(); x++) {
161         initVirtMem.writeBlob(auxv_array_base + x * 2 * intSize,
162                 (uint8_t*)&(auxv[x].a_type), intSize);
163         initVirtMem.writeBlob(auxv_array_base + (x * 2 + 1) * intSize,
164                 (uint8_t*)&(auxv[x].a_val), intSize);
165     }
166 
167     // Write out the terminating zeroed auxilliary vector
168     for (unsigned i = 0; i < 2; i++) {
169         const IntType zero = 0;
170         const Addr addr = auxv_array_base + 2 * intSize * (auxv.size() + i);
171         initVirtMem.writeBlob(addr, (uint8_t*)&zero, intSize);
172     }
173 
174     ThreadContext *tc = system->getThreadContext(contextIds[0]);
175 
176     setSyscallArg(tc, 0, argc);
177     setSyscallArg(tc, 1, argv_array_base);
178     tc->setIntReg(StackPointerReg, stack_min);
179 
180     tc->pcState(objFile->entryPoint());
181 }
\end{DoxyCode}
\hypertarget{classMipsLiveProcess_ae30d5e2e0fa415fc951786462325dde3}{
\index{MipsLiveProcess@{MipsLiveProcess}!getSyscallArg@{getSyscallArg}}
\index{getSyscallArg@{getSyscallArg}!MipsLiveProcess@{MipsLiveProcess}}
\subsubsection[{getSyscallArg}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MipsISA::IntReg} getSyscallArg ({\bf ThreadContext} $\ast$ {\em tc}, \/  int \& {\em i})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classMipsLiveProcess_ae30d5e2e0fa415fc951786462325dde3}


\hyperlink{classLiveProcess_aa001ff57ec460026facb89ba19c7bf96}{LiveProcess}を実装しています。\hypertarget{classMipsLiveProcess_ae30d5e2e0fa415fc951786462325dde3}{
\index{MipsLiveProcess@{MipsLiveProcess}!getSyscallArg@{getSyscallArg}}
\index{getSyscallArg@{getSyscallArg}!MipsLiveProcess@{MipsLiveProcess}}
\subsubsection[{getSyscallArg}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MipsISA::IntReg} getSyscallArg ({\bf ThreadContext} $\ast$ {\em tc}, \/  int \& {\em i})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classMipsLiveProcess_ae30d5e2e0fa415fc951786462325dde3}


\hyperlink{classLiveProcess_aa001ff57ec460026facb89ba19c7bf96}{LiveProcess}を実装しています。


\begin{DoxyCode}
186 {
187     assert(i < 6);
188     return tc->readIntReg(FirstArgumentReg + i++);
189 }
\end{DoxyCode}
\hypertarget{classMipsLiveProcess_a3c34ea9b29f410748d4435a667484924}{
\index{MipsLiveProcess@{MipsLiveProcess}!initState@{initState}}
\index{initState@{initState}!MipsLiveProcess@{MipsLiveProcess}}
\subsubsection[{initState}]{\setlength{\rightskip}{0pt plus 5cm}void initState ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classMipsLiveProcess_a3c34ea9b29f410748d4435a667484924}
\hyperlink{classMipsLiveProcess_a3c34ea9b29f410748d4435a667484924}{initState()} is called on each \hyperlink{classSimObject}{SimObject} when $\ast$not$\ast$ restoring from a checkpoint. This provides a hook for state initializations that are only required for a \char`\"{}cold start\char`\"{}. 

\hyperlink{classProcess_a3c34ea9b29f410748d4435a667484924}{Process}を再定義しています。\hypertarget{classMipsLiveProcess_a3c34ea9b29f410748d4435a667484924}{
\index{MipsLiveProcess@{MipsLiveProcess}!initState@{initState}}
\index{initState@{initState}!MipsLiveProcess@{MipsLiveProcess}}
\subsubsection[{initState}]{\setlength{\rightskip}{0pt plus 5cm}void initState ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classMipsLiveProcess_a3c34ea9b29f410748d4435a667484924}
\hyperlink{classMipsLiveProcess_a3c34ea9b29f410748d4435a667484924}{initState()} is called on each \hyperlink{classSimObject}{SimObject} when $\ast$not$\ast$ restoring from a checkpoint. This provides a hook for state initializations that are only required for a \char`\"{}cold start\char`\"{}. 

\hyperlink{classProcess_a3c34ea9b29f410748d4435a667484924}{Process}を再定義しています。


\begin{DoxyCode}
69 {
70     LiveProcess::initState();
71 
72     argsInit<uint32_t>(VMPageSize);
73 }
\end{DoxyCode}
\hypertarget{classMipsLiveProcess_a032ac505186d9587516a73cdc17f4c0d}{
\index{MipsLiveProcess@{MipsLiveProcess}!setSyscallArg@{setSyscallArg}}
\index{setSyscallArg@{setSyscallArg}!MipsLiveProcess@{MipsLiveProcess}}
\subsubsection[{setSyscallArg}]{\setlength{\rightskip}{0pt plus 5cm}void setSyscallArg ({\bf ThreadContext} $\ast$ {\em tc}, \/  int {\em i}, \/  {\bf MipsISA::IntReg} {\em val})}}
\label{classMipsLiveProcess_a032ac505186d9587516a73cdc17f4c0d}
\hypertarget{classMipsLiveProcess_a032ac505186d9587516a73cdc17f4c0d}{
\index{MipsLiveProcess@{MipsLiveProcess}!setSyscallArg@{setSyscallArg}}
\index{setSyscallArg@{setSyscallArg}!MipsLiveProcess@{MipsLiveProcess}}
\subsubsection[{setSyscallArg}]{\setlength{\rightskip}{0pt plus 5cm}void setSyscallArg ({\bf ThreadContext} $\ast$ {\em tc}, \/  int {\em i}, \/  {\bf MipsISA::IntReg} {\em val})}}
\label{classMipsLiveProcess_a032ac505186d9587516a73cdc17f4c0d}



\begin{DoxyCode}
194 {
195     assert(i < 6);
196     tc->setIntReg(FirstArgumentReg + i, val);
197 }
\end{DoxyCode}
\hypertarget{classMipsLiveProcess_aaefd02663c1eae206b851290d9276a5e}{
\index{MipsLiveProcess@{MipsLiveProcess}!setSyscallReturn@{setSyscallReturn}}
\index{setSyscallReturn@{setSyscallReturn}!MipsLiveProcess@{MipsLiveProcess}}
\subsubsection[{setSyscallReturn}]{\setlength{\rightskip}{0pt plus 5cm}void setSyscallReturn ({\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf SyscallReturn} {\em return\_\-value})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classMipsLiveProcess_aaefd02663c1eae206b851290d9276a5e}


\hyperlink{classLiveProcess_a5955e790542b86589b9fd75df24ec2d3}{LiveProcess}を実装しています。\hypertarget{classMipsLiveProcess_aaefd02663c1eae206b851290d9276a5e}{
\index{MipsLiveProcess@{MipsLiveProcess}!setSyscallReturn@{setSyscallReturn}}
\index{setSyscallReturn@{setSyscallReturn}!MipsLiveProcess@{MipsLiveProcess}}
\subsubsection[{setSyscallReturn}]{\setlength{\rightskip}{0pt plus 5cm}void setSyscallReturn ({\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf SyscallReturn} {\em return\_\-value})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classMipsLiveProcess_aaefd02663c1eae206b851290d9276a5e}


\hyperlink{classLiveProcess_a5955e790542b86589b9fd75df24ec2d3}{LiveProcess}を実装しています。


\begin{DoxyCode}
201 {
202     if (sysret.successful()) {
203         // no error
204         tc->setIntReg(SyscallSuccessReg, 0);
205         tc->setIntReg(ReturnValueReg, sysret.returnValue());
206     } else {
207         // got an error, return details
208         tc->setIntReg(SyscallSuccessReg, (IntReg) -1);
209         tc->setIntReg(ReturnValueReg, sysret.errnoValue());
210     }
211 }
\end{DoxyCode}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/mips/\hyperlink{arch_2mips_2process_8hh}{process.hh}\item 
arch/miqs/\hyperlink{arch_2miqs_2process_8hh}{process.hh}\item 
arch/mips/\hyperlink{arch_2mips_2process_8cc}{process.cc}\item 
arch/miqs/\hyperlink{arch_2miqs_2process_8cc}{process.cc}\end{DoxyCompactItemize}
