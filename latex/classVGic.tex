\hypertarget{classVGic}{
\section{クラス VGic}
\label{classVGic}\index{VGic@{VGic}}
}


{\ttfamily \#include $<$vgic.hh$>$}VGicに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=6cm]{classVGic}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classVGic_1_1PostVIntEvent}{PostVIntEvent}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef VGicParams \hyperlink{classVGic_aba305d5be632386ad18939cafec46fee}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
const \hyperlink{classVGic_aba305d5be632386ad18939cafec46fee}{Params} $\ast$ \hyperlink{classVGic_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{classVGic_a8c1d925f2ffb272c08d5a830d171877e}{VGic} (const \hyperlink{classVGic_aba305d5be632386ad18939cafec46fee}{Params} $\ast$p)
\item 
virtual \hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classVGic_a36cf113d5e5e091ebddb32306c098fae}{getAddrRanges} () const 
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classVGic_a613ec7d5e1ec64f8d21fec78ae8e568e}{read} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classVGic_a4cefab464e72b5dd42c003a0a4341802}{write} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual void \hyperlink{classVGic_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classVGic_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classVGic_a1e2e8270e48d9bf2f00ad8e46726eced}{BitUnion32} (ListReg) Bitfield$<$ 31 $>$ HW
\item 
\hyperlink{classVGic_aa0158cd1ea3c86fc81b16a8d77b8520b}{EndBitUnion} (ListReg) BitUnion32(HCR) Bitfield$<$ 31
\item 
\hyperlink{classVGic_ab5911b67b4abc330297af4d4c7e24204}{EndBitUnion} (HCR) BitUnion32(VCTLR) Bitfield$<$ 9 $>$ EOImode
\item 
\hyperlink{classVGic_a6fc0955a2336f0716e82db0f8ede0101}{EndBitUnion} (VCTLR) struct vcpuIntData
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classVGic_ae1f51e39d49a7c6129c9092a9fc1f304}{readVCpu} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classVGic_a45a7fc6132e09486475eca0302ab4981}{readCtrl} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classVGic_a289d8279acf224a8745658b053b0c16c}{writeVCpu} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classVGic_ab75ecb383e0dfa786c92077803100348}{writeCtrl} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classVGic_aa1847a7ae392ebc8637b9ab5d25c4c4b}{updateIntState} (int ctx\_\-id)
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classVGic_aef2af82ff4c26ce727729ce60f587ee3}{getMISR} (struct vcpuIntData $\ast$vid)
\item 
void \hyperlink{classVGic_a8974d873942f37d74bede520fc0d1f1a}{postVInt} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} cpu, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} when)
\item 
void \hyperlink{classVGic_a483dd48f21752d469dcd36f3e331184a}{unPostVInt} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} cpu)
\item 
void \hyperlink{classVGic_ad86c8e2cfb589fee04dfc050013963af}{postMaintInt} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} cpu)
\item 
void \hyperlink{classVGic_ae2afe0f63a211fe5f6cc56bbe8b4d79a}{unPostMaintInt} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} cpu)
\item 
unsigned int \hyperlink{classVGic_ae75cd8cf3bee8ac63664bc65d393bee8}{lrPending} (struct vcpuIntData $\ast$vid)
\item 
unsigned int \hyperlink{classVGic_acd87d736497b629fc35abea04a8d838e}{lrValid} (struct vcpuIntData $\ast$vid)
\item 
int \hyperlink{classVGic_ac8cda0aa85dee9a4e2f352b46d5efea8}{findHighestPendingLR} (struct vcpuIntData $\ast$vid)
\item 
int \hyperlink{classVGic_a8498dbf7b539714834568e7284487cbe}{findLRForVIRQ} (struct vcpuIntData $\ast$vid, int virq, int vcpu)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classVGic_1_1PostVIntEvent}{PostVIntEvent} $\ast$ \hyperlink{classVGic_a391a6d3a21ceaa229791a17f58d2e0ae}{postVIntEvent} \mbox{[}\hyperlink{classVGic_abdf6630d700683c52d9cd03f11d660ac}{VGIC\_\-CPU\_\-MAX}\mbox{]}
\item 
bool \hyperlink{classVGic_afc202b126ba5621ec4dae742b51889d0}{maintIntPosted} \mbox{[}\hyperlink{classVGic_abdf6630d700683c52d9cd03f11d660ac}{VGIC\_\-CPU\_\-MAX}\mbox{]}
\item 
bool \hyperlink{classVGic_a4108a1761c811efd10f4bd705fab8581}{vIntPosted} \mbox{[}\hyperlink{classVGic_abdf6630d700683c52d9cd03f11d660ac}{VGIC\_\-CPU\_\-MAX}\mbox{]}
\item 
\hyperlink{classPlatform}{Platform} $\ast$ \hyperlink{classVGic_a75b48f1787959a4617f2a599d7c09aab}{platform}
\item 
\hyperlink{classBaseGic}{BaseGic} $\ast$ \hyperlink{classVGic_a2e2266dca56928f63667e994933169ee}{gic}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classVGic_a6967a675bb97fef5858618111567aba0}{vcpuAddr}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classVGic_a382afc2ed37622bb0da354e863a9c121}{hvAddr}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classVGic_ac8e969635a78ab9ab123904ccca434cc}{pioDelay}
\item 
int \hyperlink{classVGic_a39c00dce99eb5fe8a22703e2286661f5}{maintInt}
\item 
Bitfield$<$ 30 $>$ \hyperlink{classVGic_a8c9d4553eb4294402cbe8b77c7be7d43}{Grp1}
\item 
Bitfield$<$ 29, 28 $>$ \hyperlink{classVGic_a4ad4e2a479baf0de8e8cdcb0c84276db}{State}
\item 
Bitfield$<$ 27, 23 $>$ \hyperlink{classVGic_a26c7f4132225aed6b8d4356c1601d689}{Priority}
\item 
Bitfield$<$ 19 $>$ \hyperlink{classVGic_ace587c95d7c7ae411d6f8791e02acfb0}{EOI}
\item 
Bitfield$<$ 12, 10 $>$ \hyperlink{classVGic_af2592449a23aee37bc8cf6be36d2efc3}{CpuID}
\item 
Bitfield$<$ 9, 0 $>$ \hyperlink{classVGic_a309cc4782346e985de8920752d7caf2a}{VirtualID}
\item 
\hyperlink{classVGic_a76289f30955e28466cc690ccf6001e61}{EOICount}
\item 
Bitfield$<$ 7 $>$ \hyperlink{classVGic_a3055f44714481212195dd4c9b77302ee}{VGrp1DIE}
\item 
Bitfield$<$ 6 $>$ \hyperlink{classVGic_ad5d876b0f8095008474757f67bf975e4}{VGrp1EIE}
\item 
Bitfield$<$ 5 $>$ \hyperlink{classVGic_affc0c4742ef1d61df5a0e8e8b2cee33b}{VGrp0DIE}
\item 
Bitfield$<$ 4 $>$ \hyperlink{classVGic_a76012350e6bb46dfdc7240afc726d949}{VGrp0EIE}
\item 
Bitfield$<$ 3 $>$ \hyperlink{classVGic_aa24f9f3124265bcdf1cea24165b2b0b9}{NPIE}
\item 
Bitfield$<$ 2 $>$ \hyperlink{classVGic_ab0faa2c980aa53ef7c92002af04c332b}{LRENPIE}
\item 
Bitfield$<$ 1 $>$ \hyperlink{classVGic_a0adbea6aeb62d30f03ddc9a25fe11b40}{UIE}
\item 
Bitfield$<$ 0 $>$ \hyperlink{classVGic_a6c33fee90de41b22938ac6bf2bbf0b37}{En}
\item 
Bitfield$<$ 4 $>$ \hyperlink{classVGic_a08a6b10064e3d9e0c614063665d33c54}{CPBR}
\item 
Bitfield$<$ 3 $>$ \hyperlink{classVGic_afa8693ab3b402c4d83774143fa804e3b}{FIQEn}
\item 
Bitfield$<$ 2 $>$ \hyperlink{classVGic_a66b61167f5695385dad02f2b536d0184}{AckCtl}
\item 
Bitfield$<$ 1 $>$ \hyperlink{classVGic_abd1b3356359eb92893a437944f5a292f}{EnGrp1}
\item 
struct vcpuIntData \hyperlink{classVGic_a98b5031733bb2cb7d20cf68a3a1ac460}{vcpuData} \mbox{[}\hyperlink{classVGic_abdf6630d700683c52d9cd03f11d660ac}{VGIC\_\-CPU\_\-MAX}\mbox{]}
\end{DoxyCompactItemize}
\subsection*{Static Private 変数}
\begin{DoxyCompactItemize}
\item 
static const int \hyperlink{classVGic_abdf6630d700683c52d9cd03f11d660ac}{VGIC\_\-CPU\_\-MAX} = 256
\item 
static const int \hyperlink{classVGic_a4729ce082ccbd9fef9a9131c6b194204}{NUM\_\-LR} = 4
\item 
static const int \hyperlink{classVGic_a85a1239e9b48c54a4342993df2743e13}{GICH\_\-SIZE} = 0x200
\item 
static const int \hyperlink{classVGic_a2ca8a33991e94727efb46a8bba9e1e2a}{GICH\_\-REG\_\-SIZE} = 0x2000
\item 
static const int \hyperlink{classVGic_a05157a03988a41b46b78b6d9d5a49bf6}{GICH\_\-HCR} = 0x000
\item 
static const int \hyperlink{classVGic_ac1961ca86b5c402d101577a495694f42}{GICH\_\-VTR} = 0x004
\item 
static const int \hyperlink{classVGic_a10bf121a0b670d835ede0ba151cb62bd}{GICH\_\-VMCR} = 0x008
\item 
static const int \hyperlink{classVGic_a8f6ba28cb22381782c786778de9236a7}{GICH\_\-MISR} = 0x010
\item 
static const int \hyperlink{classVGic_a6377986cfc790adf7f3274de63f840a5}{GICH\_\-EISR0} = 0x020
\item 
static const int \hyperlink{classVGic_ad2d40266f69c1beee09c888281738df1}{GICH\_\-EISR1} = 0x024
\item 
static const int \hyperlink{classVGic_af16152e073dd9ed6e6ce3515c99301c9}{GICH\_\-ELSR0} = 0x030
\item 
static const int \hyperlink{classVGic_a1dc31e7d69166471775d43e3729228b4}{GICH\_\-ELSR1} = 0x034
\item 
static const int \hyperlink{classVGic_ae799770adf4da02abcc790d891238aec}{GICH\_\-APR0} = 0x0f0
\item 
static const int \hyperlink{classVGic_a75e35ac1eddd88a77229bf915b48273f}{GICH\_\-LR0} = 0x100
\item 
static const int \hyperlink{classVGic_ace36c2959f314bca6c1f53ef7b471011}{GICH\_\-LR1} = 0x104
\item 
static const int \hyperlink{classVGic_a58f68d484460b5ba7753425a306db71e}{GICH\_\-LR2} = 0x108
\item 
static const int \hyperlink{classVGic_a630c33972a6516ce8617656424902292}{GICH\_\-LR3} = 0x10c
\item 
static const int \hyperlink{classVGic_a327649260109afc17ff86a3a8371cb95}{GICV\_\-SIZE} = 0x2000
\item 
static const int \hyperlink{classVGic_ab4280dfa561ca960d58d341662849f7b}{GICV\_\-CTLR} = 0x000
\item 
static const int \hyperlink{classVGic_a25c57288ef4b1aad4afbc584a92b8391}{GICV\_\-PMR} = 0x004
\item 
static const int \hyperlink{classVGic_ab87c04cb10d6d7d4dc9bfdb41e67bd55}{GICV\_\-BPR} = 0x008
\item 
static const int \hyperlink{classVGic_a132fc471769307b51fb6ee13cd852835}{GICV\_\-IAR} = 0x00c
\item 
static const int \hyperlink{classVGic_ae75c9bc58bd94b6dfc83ecc0ea89e767}{GICV\_\-EOIR} = 0x010
\item 
static const int \hyperlink{classVGic_a1f4656693af03dc9ad24b55cf12eaaca}{GICV\_\-RPR} = 0x014
\item 
static const int \hyperlink{classVGic_adeb087954f3f7141cc49dd6236b4aa4c}{GICV\_\-HPPIR} = 0x018
\item 
static const int \hyperlink{classVGic_ac2262138aebc47d7e32b347f6cb580a6}{GICV\_\-ABPR} = 0x01c
\item 
static const int \hyperlink{classVGic_a471e427964bbc593aee5f4ce918b6ce2}{GICV\_\-AIAR} = 0x020
\item 
static const int \hyperlink{classVGic_a91ec09125f0759c2d32fa7bba32f3b03}{GICV\_\-AEOIR} = 0x024
\item 
static const int \hyperlink{classVGic_a95e1cf51d24aa765e82dd89f10321062}{GICV\_\-AHPPIR} = 0x028
\item 
static const int \hyperlink{classVGic_aa0efd17f14c57d720c184ee92b83ee05}{GICV\_\-APR0} = 0x0d0
\item 
static const int \hyperlink{classVGic_a40aac9b1ed27436f1ef04ff0f4b03f66}{GICV\_\-IIDR} = 0x0fc
\item 
static const int \hyperlink{classVGic_a806d487cfebc43c0536726f39a340463}{GICV\_\-DIR} = 0x1000
\item 
static const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classVGic_a0494deefa99c7f4fd9b8f3ee52a56cee}{LR\_\-PENDING} = 1
\item 
static const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classVGic_a8c71200f07eaae9cd4292f5c4438ec0b}{LR\_\-ACTIVE} = 2
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classVGic_aba305d5be632386ad18939cafec46fee}{
\index{VGic@{VGic}!Params@{Params}}
\index{Params@{Params}!VGic@{VGic}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef VGicParams {\bf Params}}}
\label{classVGic_aba305d5be632386ad18939cafec46fee}


\hyperlink{classPioDevice_a9cdbda5b5cc24147ce82b7d07bf03cd1}{PioDevice}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classVGic_a8c1d925f2ffb272c08d5a830d171877e}{
\index{VGic@{VGic}!VGic@{VGic}}
\index{VGic@{VGic}!VGic@{VGic}}
\subsubsection[{VGic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf VGic} (const {\bf Params} $\ast$ {\em p})}}
\label{classVGic_a8c1d925f2ffb272c08d5a830d171877e}



\begin{DoxyCode}
50     : PioDevice(p), platform(p->platform), gic(p->gic), vcpuAddr(p->vcpu_addr),
51       hvAddr(p->hv_addr), pioDelay(p->pio_delay),
52       maintInt(p->ppint)
53 {
54     for (int x = 0; x < VGIC_CPU_MAX; x++) {
55         postVIntEvent[x] = new PostVIntEvent(x, p->platform);
56         maintIntPosted[x] = false;
57         vIntPosted[x] = false;
58     }
59     for (int c = 0; c < VGIC_CPU_MAX; c++) {
60         memset(&vcpuData[c], 0, sizeof(struct vcpuIntData));
61     }
62     assert(sys->numRunningContexts() <= VGIC_CPU_MAX);
63 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classVGic_a1e2e8270e48d9bf2f00ad8e46726eced}{
\index{VGic@{VGic}!BitUnion32@{BitUnion32}}
\index{BitUnion32@{BitUnion32}!VGic@{VGic}}
\subsubsection[{BitUnion32}]{\setlength{\rightskip}{0pt plus 5cm}BitUnion32 (ListReg)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a1e2e8270e48d9bf2f00ad8e46726eced}
\hypertarget{classVGic_a6fc0955a2336f0716e82db0f8ede0101}{
\index{VGic@{VGic}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!VGic@{VGic}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion (VCTLR)\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classVGic_a6fc0955a2336f0716e82db0f8ede0101}



\begin{DoxyCode}
165                        {
166         ListReg LR[NUM_LR];
167         VCTLR vctrl;
168 
169         HCR hcr;
170         uint64_t eisr;
171 
172         /* Host info, guest info (should be 100% accessible via GICH_* regs!) */
173         uint8_t VMGrp0En;
174         uint8_t VMGrp1En;
175         uint8_t VMAckCtl;
176         uint8_t VMFiqEn;
177         uint8_t VMCBPR;
178         uint8_t VEM;
179         uint8_t VMABP;
180         uint8_t VMBP;
181         uint8_t VMPriMask;
182     };
\end{DoxyCode}
\hypertarget{classVGic_ab5911b67b4abc330297af4d4c7e24204}{
\index{VGic@{VGic}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!VGic@{VGic}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion (HCR)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_ab5911b67b4abc330297af4d4c7e24204}
\hypertarget{classVGic_aa0158cd1ea3c86fc81b16a8d77b8520b}{
\index{VGic@{VGic}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!VGic@{VGic}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion (ListReg)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_aa0158cd1ea3c86fc81b16a8d77b8520b}
\hypertarget{classVGic_ac8cda0aa85dee9a4e2f352b46d5efea8}{
\index{VGic@{VGic}!findHighestPendingLR@{findHighestPendingLR}}
\index{findHighestPendingLR@{findHighestPendingLR}!VGic@{VGic}}
\subsubsection[{findHighestPendingLR}]{\setlength{\rightskip}{0pt plus 5cm}int findHighestPendingLR (struct vcpuIntData $\ast$ {\em vid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classVGic_ac8cda0aa85dee9a4e2f352b46d5efea8}
Returns LR index or -\/1 if none pending 


\begin{DoxyCode}
238     {
239         unsigned int prio = 0xff;
240         int p = -1;
241         for (int i = 0; i < NUM_LR; i++) {
242             if ((vid->LR[i].State & LR_PENDING) && (vid->LR[i].Priority < prio)) 
      {
243                 p = i;
244                 prio = vid->LR[i].Priority;
245             }
246         }
247         return p;
248     }
\end{DoxyCode}
\hypertarget{classVGic_a8498dbf7b539714834568e7284487cbe}{
\index{VGic@{VGic}!findLRForVIRQ@{findLRForVIRQ}}
\index{findLRForVIRQ@{findLRForVIRQ}!VGic@{VGic}}
\subsubsection[{findLRForVIRQ}]{\setlength{\rightskip}{0pt plus 5cm}int findLRForVIRQ (struct vcpuIntData $\ast$ {\em vid}, \/  int {\em virq}, \/  int {\em vcpu})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classVGic_a8498dbf7b539714834568e7284487cbe}



\begin{DoxyCode}
251     {
252         for (int i = 0; i < NUM_LR; i++) {
253             if (vid->LR[i].State &&
254                 vid->LR[i].VirtualID == virq &&
255                 vid->LR[i].CpuID == vcpu)
256                 return i;
257         }
258         return -1;
259     }
\end{DoxyCode}
\hypertarget{classVGic_a36cf113d5e5e091ebddb32306c098fae}{
\index{VGic@{VGic}!getAddrRanges@{getAddrRanges}}
\index{getAddrRanges@{getAddrRanges}!VGic@{VGic}}
\subsubsection[{getAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRangeList} getAddrRanges () const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classVGic_a36cf113d5e5e091ebddb32306c098fae}
Every PIO device is obliged to provide an implementation that returns the address ranges the device responds to.

\begin{DoxyReturn}{戻り値}
a list of non-\/overlapping address ranges 
\end{DoxyReturn}


\hyperlink{classPioDevice_a6e967f8921e80748eb2be35b6b481a7e}{PioDevice}を実装しています。


\begin{DoxyCode}
436 {
437     AddrRangeList ranges;
438     ranges.push_back(RangeSize(hvAddr, GICH_REG_SIZE));
439     ranges.push_back(RangeSize(vcpuAddr, GICV_SIZE));
440     return ranges;
441 }
\end{DoxyCode}
\hypertarget{classVGic_aef2af82ff4c26ce727729ce60f587ee3}{
\index{VGic@{VGic}!getMISR@{getMISR}}
\index{getMISR@{getMISR}!VGic@{VGic}}
\subsubsection[{getMISR}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} getMISR (struct vcpuIntData $\ast$ {\em vid})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_aef2af82ff4c26ce727729ce60f587ee3}



\begin{DoxyCode}
345 {
346     return (!!vid->hcr.VGrp1DIE && !vid->VMGrp1En ? 0x80 : 0) |
347         (!!vid->hcr.VGrp1EIE &&  vid->VMGrp1En ? 0x40 : 0) |
348         (!!vid->hcr.VGrp0DIE && !vid->VMGrp0En ? 0x20 : 0) |
349         (!!vid->hcr.VGrp0EIE &&  vid->VMGrp0En ? 0x10 : 0) |
350         (!!vid->hcr.NPIE && !lrPending(vid) ? 0x08 : 0) |
351         (!!vid->hcr.LRENPIE && vid->hcr.EOICount ? 0x04 : 0) |
352         (!!vid->hcr.UIE && lrValid(vid) <= 1 ? 0x02 : 0) |
353         (vid->eisr ? 0x01 : 0);
354 }
\end{DoxyCode}
\hypertarget{classVGic_ae75cd8cf3bee8ac63664bc65d393bee8}{
\index{VGic@{VGic}!lrPending@{lrPending}}
\index{lrPending@{lrPending}!VGic@{VGic}}
\subsubsection[{lrPending}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int lrPending (struct vcpuIntData $\ast$ {\em vid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classVGic_ae75cd8cf3bee8ac63664bc65d393bee8}



\begin{DoxyCode}
218     {
219         unsigned int pend = 0;
220         for (int i = 0; i < NUM_LR; i++) {
221             if (vid->LR[i].State & LR_PENDING)
222                 pend++;
223         }
224         return pend;
225     }
\end{DoxyCode}
\hypertarget{classVGic_acd87d736497b629fc35abea04a8d838e}{
\index{VGic@{VGic}!lrValid@{lrValid}}
\index{lrValid@{lrValid}!VGic@{VGic}}
\subsubsection[{lrValid}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int lrValid (struct vcpuIntData $\ast$ {\em vid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classVGic_acd87d736497b629fc35abea04a8d838e}



\begin{DoxyCode}
227     {
228         unsigned int valid = 0;
229         for (int i = 0; i < NUM_LR; i++) {
230             if (vid->LR[i].State)
231                 valid++;
232         }
233         return valid;
234     }
\end{DoxyCode}
\hypertarget{classVGic_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{VGic@{VGic}!params@{params}}
\index{params@{params}!VGic@{VGic}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classVGic_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classPioDevice_acd3c3feb78ae7a8f88fe0f110a718dff}{PioDevice}を再定義しています。


\begin{DoxyCode}
190     {
191         return dynamic_cast<const Params *>(_params);
192     }
\end{DoxyCode}
\hypertarget{classVGic_ad86c8e2cfb589fee04dfc050013963af}{
\index{VGic@{VGic}!postMaintInt@{postMaintInt}}
\index{postMaintInt@{postMaintInt}!VGic@{VGic}}
\subsubsection[{postMaintInt}]{\setlength{\rightskip}{0pt plus 5cm}void postMaintInt ({\bf uint32\_\-t} {\em cpu})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_ad86c8e2cfb589fee04dfc050013963af}



\begin{DoxyCode}
373 {
374     DPRINTF(VGIC, "Posting maintenance PPI to GIC/cpu%d\n", cpu);
375     // Linux DT configures this as Level.
376     gic->sendPPInt(maintInt, cpu);
377 }
\end{DoxyCode}
\hypertarget{classVGic_a8974d873942f37d74bede520fc0d1f1a}{
\index{VGic@{VGic}!postVInt@{postVInt}}
\index{postVInt@{postVInt}!VGic@{VGic}}
\subsubsection[{postVInt}]{\setlength{\rightskip}{0pt plus 5cm}void postVInt ({\bf uint32\_\-t} {\em cpu}, \/  {\bf Tick} {\em when})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a8974d873942f37d74bede520fc0d1f1a}



\begin{DoxyCode}
358 {
359     DPRINTF(VGIC, "Posting VIRQ to %d\n", cpu);
360     if (!(postVIntEvent[cpu]->scheduled()))
361         eventq->schedule(postVIntEvent[cpu], when);
362 }
\end{DoxyCode}
\hypertarget{classVGic_a613ec7d5e1ec64f8d21fec78ae8e568e}{
\index{VGic@{VGic}!read@{read}}
\index{read@{read}!VGic@{VGic}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} read ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classVGic_a613ec7d5e1ec64f8d21fec78ae8e568e}
Pure virtual function that the device must implement. Called when a read command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_a842312590432036092c422c87a442358}{PioDevice}を実装しています。


\begin{DoxyCode}
67 {
68     Addr addr = pkt->getAddr();
69 
70     if (addr >= vcpuAddr && addr < vcpuAddr + GICV_SIZE)
71         return readVCpu(pkt);
72     else if (addr >= hvAddr && addr < hvAddr + GICH_REG_SIZE)
73         return readCtrl(pkt);
74     else
75         panic("Read to unknown address %#x\n", pkt->getAddr());
76 }
\end{DoxyCode}
\hypertarget{classVGic_a45a7fc6132e09486475eca0302ab4981}{
\index{VGic@{VGic}!readCtrl@{readCtrl}}
\index{readCtrl@{readCtrl}!VGic@{VGic}}
\subsubsection[{readCtrl}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} readCtrl ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a45a7fc6132e09486475eca0302ab4981}



\begin{DoxyCode}
138 {
139     Addr daddr = pkt->getAddr() - hvAddr;
140     pkt->allocate();
141 
142     int ctx_id = pkt->req->contextId();
143 
144     DPRINTF(VGIC, "VGIC HVCtrl read register %#x\n", daddr);
145 
146     /* Munge the address: 0-0xfff is the usual space banked by requester CPU.
147      * Anything > that is 0x200-sized slices of 'per CPU' regs.
148      */
149     if (daddr & ~0x1ff) {
150         ctx_id = (daddr >> 9);
151         if (ctx_id > 8)
152             panic("VGIC: Weird unbanked hv ctrl address %#x!\n", daddr);
153         daddr &= ~0x1ff;
154     }
155     assert(ctx_id < VGIC_CPU_MAX);
156     struct vcpuIntData *vid = &vcpuData[ctx_id];
157 
158     switch (daddr) {
159       case GICH_HCR:
160         pkt->set<uint32_t>(vid->hcr);
161         break;
162 
163       case GICH_VTR:
164         pkt->set<uint32_t>(0x44000000 | (NUM_LR - 1));
165         break;
166 
167       case GICH_VMCR:
168         pkt->set<uint32_t>(
169             ((uint32_t)vid->VMPriMask << 27) |
170             ((uint32_t)vid->VMBP << 21) |
171             ((uint32_t)vid->VMABP << 18) |
172             ((uint32_t)vid->VEM << 9) |
173             ((uint32_t)vid->VMCBPR << 4) |
174             ((uint32_t)vid->VMFiqEn << 3) |
175             ((uint32_t)vid->VMAckCtl << 2) |
176             ((uint32_t)vid->VMGrp1En << 1) |
177             ((uint32_t)vid->VMGrp0En << 0)
178             );
179         break;
180 
181       case GICH_MISR:
182         pkt->set<uint32_t>(getMISR(vid));
183         break;
184 
185       case GICH_EISR0:
186         pkt->set<uint32_t>(vid->eisr & 0xffffffff);
187         break;
188 
189       case GICH_EISR1:
190         pkt->set<uint32_t>(vid->eisr >> 32);
191         break;
192 
193       case GICH_ELSR0: {
194           uint32_t bm = 0;
195           for (int i = 0; i < ((NUM_LR < 32) ? NUM_LR : 32); i++) {
196               if (!vid->LR[i].State)
197                   bm |= 1 << i;
198           }
199           pkt->set<uint32_t>(bm);
200       } break;
201 
202       case GICH_ELSR1: {
203           uint32_t bm = 0;
204           for (int i = 32; i < NUM_LR; i++) {
205               if (!vid->LR[i].State)
206                   bm |= 1 << (i-32);
207           }
208           pkt->set<uint32_t>(bm);
209       } break;
210 
211       case GICH_APR0:
212         warn_once("VGIC GICH_APR read!\n");
213         pkt->set<uint32_t>(0);
214         break;
215 
216       case GICH_LR0:
217       case GICH_LR1:
218       case GICH_LR2:
219       case GICH_LR3:
220         pkt->set<uint32_t>(vid->LR[(daddr - GICH_LR0) >> 2]);
221         break;
222 
223       default:
224         panic("VGIC HVCtrl read of bad address %#x\n", daddr);
225     }
226 
227     pkt->makeAtomicResponse();
228     return pioDelay;
229 }
\end{DoxyCode}
\hypertarget{classVGic_ae1f51e39d49a7c6129c9092a9fc1f304}{
\index{VGic@{VGic}!readVCpu@{readVCpu}}
\index{readVCpu@{readVCpu}!VGic@{VGic}}
\subsubsection[{readVCpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} readVCpu ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_ae1f51e39d49a7c6129c9092a9fc1f304}



\begin{DoxyCode}
93 {
94     Addr daddr = pkt->getAddr() - vcpuAddr;
95     pkt->allocate();
96 
97     int ctx_id = pkt->req->contextId();
98     assert(ctx_id < VGIC_CPU_MAX);
99     struct vcpuIntData *vid = &vcpuData[ctx_id];
100 
101     DPRINTF(VGIC, "VGIC VCPU read register %#x\n", daddr);
102 
103     switch (daddr) {
104       case GICV_CTLR:
105         pkt->set<uint32_t>(vid->vctrl);
106         break;
107       case GICV_IAR: {
108           int i = findHighestPendingLR(vid);
109           if (i < 0 || !vid->vctrl.En) {
110               pkt->set<uint32_t>(1023); // "No int" marker
111           } else {
112               ListReg *lr = &vid->LR[i];
113 
114               pkt->set<uint32_t>(lr->VirtualID |
115                                  (((int)lr->CpuID) << 10));
116               // We don't support auto-EOI of HW interrupts via real GIC!
117               // Fortunately, KVM doesn't use this.  How about Xen...? Ulp!
118               if (lr->HW)
119                   panic("VGIC does not support 'HW' List Register feature (LR %#x
      )!\n",
120                         *lr);
121               lr->State = LR_ACTIVE;
122               DPRINTF(VGIC, "Consumed interrupt %d (cpu%d) from LR%d (EOI%d)\n",
123                       lr->VirtualID, lr->CpuID, i, lr->EOI);
124           }
125       } break;
126       default:
127         panic("VGIC VCPU read of bad address %#x\n", daddr);
128     }
129 
130     updateIntState(ctx_id);
131 
132     pkt->makeAtomicResponse();
133     return pioDelay;
134 }
\end{DoxyCode}
\hypertarget{classVGic_a53e036786d17361be4c7320d39c99b84}{
\index{VGic@{VGic}!serialize@{serialize}}
\index{serialize@{serialize}!VGic@{VGic}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classVGic_a53e036786d17361be4c7320d39c99b84}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。


\begin{DoxyCode}
445 {
446     Tick interrupt_time[VGIC_CPU_MAX];
447     for (uint32_t cpu = 0; cpu < VGIC_CPU_MAX; cpu++) {
448         interrupt_time[cpu] = 0;
449         if (postVIntEvent[cpu]->scheduled()) {
450             interrupt_time[cpu] = postVIntEvent[cpu]->when();
451         }
452     }
453 
454     DPRINTF(Checkpoint, "Serializing VGIC\n");
455 
456     SERIALIZE_ARRAY(interrupt_time, VGIC_CPU_MAX);
457     SERIALIZE_ARRAY(maintIntPosted, VGIC_CPU_MAX);
458     SERIALIZE_ARRAY(vIntPosted, VGIC_CPU_MAX);
459     SERIALIZE_SCALAR(vcpuAddr);
460     SERIALIZE_SCALAR(hvAddr);
461     SERIALIZE_SCALAR(pioDelay);
462     SERIALIZE_SCALAR(maintInt);
463 
464     for (uint32_t cpu = 0; cpu < VGIC_CPU_MAX; cpu++) {
465         nameOut(os, csprintf("%s.vcpuData%d", name(), cpu));
466         uint32_t vctrl_val = vcpuData[cpu].vctrl;
467         SERIALIZE_SCALAR(vctrl_val);
468         uint32_t hcr_val = vcpuData[cpu].hcr;
469         SERIALIZE_SCALAR(hcr_val);
470         uint64_t eisr_val = vcpuData[cpu].eisr;
471         SERIALIZE_SCALAR(eisr_val);
472         uint8_t VMGrp0En_val = vcpuData[cpu].VMGrp0En;
473         SERIALIZE_SCALAR(VMGrp0En_val);
474         uint8_t VMGrp1En_val = vcpuData[cpu].VMGrp1En;
475         SERIALIZE_SCALAR(VMGrp1En_val);
476         uint8_t VMAckCtl_val = vcpuData[cpu].VMAckCtl;
477         SERIALIZE_SCALAR(VMAckCtl_val);
478         uint8_t VMFiqEn_val = vcpuData[cpu].VMFiqEn;
479         SERIALIZE_SCALAR(VMFiqEn_val);
480         uint8_t VMCBPR_val = vcpuData[cpu].VMCBPR;
481         SERIALIZE_SCALAR(VMCBPR_val);
482         uint8_t VEM_val = vcpuData[cpu].VEM;
483         SERIALIZE_SCALAR(VEM_val);
484         uint8_t VMABP_val = vcpuData[cpu].VMABP;
485         SERIALIZE_SCALAR(VMABP_val);
486         uint8_t VMBP_val = vcpuData[cpu].VMBP;
487         SERIALIZE_SCALAR(VMBP_val);
488         uint8_t VMPriMask_val = vcpuData[cpu].VMPriMask;
489         SERIALIZE_SCALAR(VMPriMask_val);
490 
491         for (int i = 0; i < NUM_LR; i++) {
492             uint32_t lr = vcpuData[cpu].LR[i];
493             nameOut(os, csprintf("%s.vcpuData%d.LR%d", name(), cpu, i));
494             SERIALIZE_SCALAR(lr);
495         }
496     }
497 }
\end{DoxyCode}
\hypertarget{classVGic_ae2afe0f63a211fe5f6cc56bbe8b4d79a}{
\index{VGic@{VGic}!unPostMaintInt@{unPostMaintInt}}
\index{unPostMaintInt@{unPostMaintInt}!VGic@{VGic}}
\subsubsection[{unPostMaintInt}]{\setlength{\rightskip}{0pt plus 5cm}void unPostMaintInt ({\bf uint32\_\-t} {\em cpu})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_ae2afe0f63a211fe5f6cc56bbe8b4d79a}



\begin{DoxyCode}
381 {
382     DPRINTF(VGIC, "Unposting maintenance PPI to GIC/cpu%d\n", cpu);
383     gic->clearPPInt(maintInt, cpu);
384 }
\end{DoxyCode}
\hypertarget{classVGic_a483dd48f21752d469dcd36f3e331184a}{
\index{VGic@{VGic}!unPostVInt@{unPostVInt}}
\index{unPostVInt@{unPostVInt}!VGic@{VGic}}
\subsubsection[{unPostVInt}]{\setlength{\rightskip}{0pt plus 5cm}void unPostVInt ({\bf uint32\_\-t} {\em cpu})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a483dd48f21752d469dcd36f3e331184a}



\begin{DoxyCode}
366 {
367     DPRINTF(VGIC, "Unposting VIRQ to %d\n", cpu);
368     platform->intrctrl->clear(cpu, ArmISA::INT_VIRT_IRQ, 0);
369 }
\end{DoxyCode}
\hypertarget{classVGic_af22e5d6d660b97db37003ac61ac4ee49}{
\index{VGic@{VGic}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!VGic@{VGic}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classVGic_af22e5d6d660b97db37003ac61ac4ee49}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。


\begin{DoxyCode}
500 {
501     DPRINTF(Checkpoint, "Unserializing Arm GIC\n");
502 
503     Tick interrupt_time[VGIC_CPU_MAX];
504     UNSERIALIZE_ARRAY(interrupt_time, VGIC_CPU_MAX);
505     for (uint32_t cpu = 0; cpu < VGIC_CPU_MAX; cpu++) {
506         if (interrupt_time[cpu])
507             schedule(postVIntEvent[cpu], interrupt_time[cpu]);
508 
509         uint32_t tmp;
510         paramIn(cp, csprintf("%s.vcpuData%d", section, cpu),
511                 "vctrl_val", tmp);
512         vcpuData[cpu].vctrl = tmp;
513         paramIn(cp, csprintf("%s.vcpuData%d", section, cpu),
514                 "hcr_val", tmp);
515         vcpuData[cpu].hcr = tmp;
516         paramIn(cp, csprintf("%s.vcpuData%d", section, cpu),
517                 "eisr_val", vcpuData[cpu].eisr);
518         paramIn(cp, csprintf("%s.vcpuData%d", section, cpu),
519                 "VMGrp0En_val", vcpuData[cpu].VMGrp0En);
520         paramIn(cp, csprintf("%s.vcpuData%d", section, cpu),
521                 "VMGrp1En_val", vcpuData[cpu].VMGrp1En);
522         paramIn(cp, csprintf("%s.vcpuData%d", section, cpu),
523                 "VMAckCtl_val", vcpuData[cpu].VMAckCtl);
524         paramIn(cp, csprintf("%s.vcpuData%d", section, cpu),
525                 "VMFiqEn_val", vcpuData[cpu].VMFiqEn);
526         paramIn(cp, csprintf("%s.vcpuData%d", section, cpu),
527                 "VMCBPR_val", vcpuData[cpu].VMCBPR);
528         paramIn(cp, csprintf("%s.vcpuData%d", section, cpu),
529                 "VEM_val", vcpuData[cpu].VEM);
530         paramIn(cp, csprintf("%s.vcpuData%d", section, cpu),
531                 "VMABP_val", vcpuData[cpu].VMABP);
532         paramIn(cp, csprintf("%s.vcpuData%d", section, cpu),
533                 "VMPriMask_val", vcpuData[cpu].VMPriMask);
534 
535         for (int i = 0; i < NUM_LR; i++) {
536             paramIn(cp, csprintf("%s.vcpuData%d.LR%d", section, cpu, i),
537                     "lr", tmp);
538             vcpuData[cpu].LR[i] = tmp;
539         }
540     }
541     UNSERIALIZE_ARRAY(maintIntPosted, VGIC_CPU_MAX);
542     UNSERIALIZE_ARRAY(vIntPosted, VGIC_CPU_MAX);
543     UNSERIALIZE_SCALAR(vcpuAddr);
544     UNSERIALIZE_SCALAR(hvAddr);
545     UNSERIALIZE_SCALAR(pioDelay);
546     UNSERIALIZE_SCALAR(maintInt);
547 }
\end{DoxyCode}
\hypertarget{classVGic_aa1847a7ae392ebc8637b9ab5d25c4c4b}{
\index{VGic@{VGic}!updateIntState@{updateIntState}}
\index{updateIntState@{updateIntState}!VGic@{VGic}}
\subsubsection[{updateIntState}]{\setlength{\rightskip}{0pt plus 5cm}void updateIntState (int {\em ctx\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_aa1847a7ae392ebc8637b9ab5d25c4c4b}



\begin{DoxyCode}
391 {
392     // @todo This should update APRs!
393 
394     // Build EISR contents:
395     // (Cached so that regs can read them without messing about again)
396     struct vcpuIntData *tvid = &vcpuData[ctx_id];
397 
398     tvid->eisr = 0;
399     for (int i = 0; i < NUM_LR; i++) {
400         if (!tvid->LR[i].State && tvid->LR[i].EOI) {
401             tvid->eisr |= 1 << i;
402         }
403     }
404 
405     assert(sys->numRunningContexts() <= VGIC_CPU_MAX);
406     for (int i = 0; i < sys->numRunningContexts(); i++) {
407         struct vcpuIntData *vid = &vcpuData[i];
408         // Are any LRs active that weren't before?
409         if (!vIntPosted[i]) {
410             if (lrPending(vid) && vid->vctrl.En) {
411                 vIntPosted[i] = true;
412                 postVInt(i, curTick() + 1);
413             }
414         } else if (!lrPending(vid)) {
415             vIntPosted[i] = false;
416             unPostVInt(i);
417         }
418 
419         // Any maintenance ints to send?
420         if (!maintIntPosted[i]) {
421             if (vid->hcr.En && getMISR(vid)) {
422                 maintIntPosted[i] = true;
423                 postMaintInt(i);
424             }
425         } else {
426             if (!vid->hcr.En || !getMISR(vid)) {
427                 unPostMaintInt(i);
428                 maintIntPosted[i] = false;
429             }
430         }
431     }
432 }
\end{DoxyCode}
\hypertarget{classVGic_a4cefab464e72b5dd42c003a0a4341802}{
\index{VGic@{VGic}!write@{write}}
\index{write@{write}!VGic@{VGic}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} write ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classVGic_a4cefab464e72b5dd42c003a0a4341802}
Pure virtual function that the device must implement. Called when a write command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_afe8371668d023bb2516b286e5e399b6f}{PioDevice}を実装しています。


\begin{DoxyCode}
80 {
81     Addr addr = pkt->getAddr();
82 
83     if (addr >= vcpuAddr && addr < vcpuAddr + GICV_SIZE)
84         return writeVCpu(pkt);
85     else if (addr >= hvAddr && addr < hvAddr + GICH_REG_SIZE)
86         return writeCtrl(pkt);
87     else
88         panic("Write to unknown address %#x\n", pkt->getAddr());
89 }
\end{DoxyCode}
\hypertarget{classVGic_ab75ecb383e0dfa786c92077803100348}{
\index{VGic@{VGic}!writeCtrl@{writeCtrl}}
\index{writeCtrl@{writeCtrl}!VGic@{VGic}}
\subsubsection[{writeCtrl}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} writeCtrl ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_ab75ecb383e0dfa786c92077803100348}



\begin{DoxyCode}
281 {
282     Addr daddr = pkt->getAddr() - hvAddr;
283     pkt->allocate();
284 
285     int ctx_id = pkt->req->contextId();
286 
287     DPRINTF(VGIC, "VGIC HVCtrl write register %#x <= %#x\n", daddr, pkt->get<
      uint32_t>());
288 
289     /* Munge the address: 0-0xfff is the usual space banked by requester CPU.
290      * Anything > that is 0x200-sized slices of 'per CPU' regs.
291      */
292     if (daddr & ~0x1ff) {
293         ctx_id = (daddr >> 9);
294         if (ctx_id > 8)
295             panic("VGIC: Weird unbanked hv ctrl address %#x!\n", daddr);
296         daddr &= ~0x1ff;
297     }
298     assert(ctx_id < VGIC_CPU_MAX);
299     struct vcpuIntData *vid = &vcpuData[ctx_id];
300 
301     switch (daddr) {
302       case GICH_HCR:
303         vid->hcr = pkt->get<uint32_t>();
304         // update int state
305         break;
306 
307       case GICH_VMCR: {
308           uint32_t d = pkt->get<uint32_t>();
309           vid->VMPriMask = d >> 27;
310           vid->VMBP = (d >> 21) & 7;
311           vid->VMABP = (d >> 18) & 7;
312           vid->VEM = (d >> 9) & 1;
313           vid->VMCBPR = (d >> 4) & 1;
314           vid->VMFiqEn = (d >> 3) & 1;
315           vid->VMAckCtl = (d >> 2) & 1;
316           vid->VMGrp1En = (d >> 1) & 1;
317           vid->VMGrp0En = d & 1;
318       } break;
319 
320       case GICH_APR0:
321         warn_once("VGIC GICH_APR0 written, ignored\n");
322         break;
323 
324       case GICH_LR0:
325       case GICH_LR1:
326       case GICH_LR2:
327       case GICH_LR3:
328         vid->LR[(daddr - GICH_LR0) >> 2] = pkt->get<uint32_t>();
329         // update int state
330         break;
331 
332       default:
333         panic("VGIC HVCtrl write to bad address %#x\n", daddr);
334     }
335 
336     updateIntState(ctx_id);
337 
338     pkt->makeAtomicResponse();
339     return pioDelay;
340 }
\end{DoxyCode}
\hypertarget{classVGic_a289d8279acf224a8745658b053b0c16c}{
\index{VGic@{VGic}!writeVCpu@{writeVCpu}}
\index{writeVCpu@{writeVCpu}!VGic@{VGic}}
\subsubsection[{writeVCpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} writeVCpu ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a289d8279acf224a8745658b053b0c16c}



\begin{DoxyCode}
233 {
234     Addr daddr = pkt->getAddr() - vcpuAddr;
235     pkt->allocate();
236 
237     int ctx_id = pkt->req->contextId();
238     assert(ctx_id < VGIC_CPU_MAX);
239     struct vcpuIntData *vid = &vcpuData[ctx_id];
240 
241     DPRINTF(VGIC, "VGIC VCPU write register %#x <= %#x\n", daddr, pkt->get<
      uint32_t>());
242 
243     switch (daddr) {
244       case GICV_CTLR:
245         vid->vctrl = pkt->get<uint32_t>();
246         break;
247       case GICV_PMR:
248         vid->VMPriMask = pkt->get<uint32_t>();
249         break;
250       case GICV_EOIR: {
251           // We don't handle the split EOI-then-DIR mode.  Linux (guest)
252           // doesn't need it though.
253           assert(!vid->vctrl.EOImode);
254           uint32_t w = pkt->get<uint32_t>();
255           unsigned int virq = w & 0x3ff;
256           unsigned int vcpu = (w >> 10) & 7;
257           int i = findLRForVIRQ(vid, virq, vcpu);
258           if (i < 0) {
259               DPRINTF(VGIC, "EOIR: No LR for irq %d(cpu%d)\n", virq, vcpu);
260           } else {
261               DPRINTF(VGIC, "EOIR: Found LR%d for irq %d(cpu%d)\n", i, virq, vcpu
      );
262               ListReg *lr = &vid->LR[i];
263               lr->State = 0;
264               // Maintenance interrupt -- via eisr -- is flagged when
265               // LRs have EOI=1 and State=INVALID!
266           }
267       } break;
268       default:
269         panic("VGIC VCPU write %#x to unk address %#x\n", pkt->get<uint32_t>(), d
      addr);
270     }
271 
272     // This updates the EISRs and flags IRQs:
273     updateIntState(ctx_id);
274 
275     pkt->makeAtomicResponse();
276     return pioDelay;
277 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classVGic_a66b61167f5695385dad02f2b536d0184}{
\index{VGic@{VGic}!AckCtl@{AckCtl}}
\index{AckCtl@{AckCtl}!VGic@{VGic}}
\subsubsection[{AckCtl}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$2$>$ {\bf AckCtl}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a66b61167f5695385dad02f2b536d0184}
\hypertarget{classVGic_a08a6b10064e3d9e0c614063665d33c54}{
\index{VGic@{VGic}!CPBR@{CPBR}}
\index{CPBR@{CPBR}!VGic@{VGic}}
\subsubsection[{CPBR}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$4$>$ {\bf CPBR}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a08a6b10064e3d9e0c614063665d33c54}
\hypertarget{classVGic_af2592449a23aee37bc8cf6be36d2efc3}{
\index{VGic@{VGic}!CpuID@{CpuID}}
\index{CpuID@{CpuID}!VGic@{VGic}}
\subsubsection[{CpuID}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$12,10$>$ {\bf CpuID}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_af2592449a23aee37bc8cf6be36d2efc3}
\hypertarget{classVGic_a6c33fee90de41b22938ac6bf2bbf0b37}{
\index{VGic@{VGic}!En@{En}}
\index{En@{En}!VGic@{VGic}}
\subsubsection[{En}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$ 0 $>$ {\bf En}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a6c33fee90de41b22938ac6bf2bbf0b37}
\hypertarget{classVGic_abd1b3356359eb92893a437944f5a292f}{
\index{VGic@{VGic}!EnGrp1@{EnGrp1}}
\index{EnGrp1@{EnGrp1}!VGic@{VGic}}
\subsubsection[{EnGrp1}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$1$>$ {\bf EnGrp1}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_abd1b3356359eb92893a437944f5a292f}
\hypertarget{classVGic_ace587c95d7c7ae411d6f8791e02acfb0}{
\index{VGic@{VGic}!EOI@{EOI}}
\index{EOI@{EOI}!VGic@{VGic}}
\subsubsection[{EOI}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$19$>$ {\bf EOI}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_ace587c95d7c7ae411d6f8791e02acfb0}
\hypertarget{classVGic_a76289f30955e28466cc690ccf6001e61}{
\index{VGic@{VGic}!EOICount@{EOICount}}
\index{EOICount@{EOICount}!VGic@{VGic}}
\subsubsection[{EOICount}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EOICount}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a76289f30955e28466cc690ccf6001e61}
\hypertarget{classVGic_afa8693ab3b402c4d83774143fa804e3b}{
\index{VGic@{VGic}!FIQEn@{FIQEn}}
\index{FIQEn@{FIQEn}!VGic@{VGic}}
\subsubsection[{FIQEn}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$3$>$ {\bf FIQEn}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_afa8693ab3b402c4d83774143fa804e3b}
\hypertarget{classVGic_a2e2266dca56928f63667e994933169ee}{
\index{VGic@{VGic}!gic@{gic}}
\index{gic@{gic}!VGic@{VGic}}
\subsubsection[{gic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseGic}$\ast$ {\bf gic}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a2e2266dca56928f63667e994933169ee}
\hypertarget{classVGic_ae799770adf4da02abcc790d891238aec}{
\index{VGic@{VGic}!GICH\_\-APR0@{GICH\_\-APR0}}
\index{GICH\_\-APR0@{GICH\_\-APR0}!VGic@{VGic}}
\subsubsection[{GICH\_\-APR0}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICH\_\-APR0} = 0x0f0\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_ae799770adf4da02abcc790d891238aec}
\hypertarget{classVGic_a6377986cfc790adf7f3274de63f840a5}{
\index{VGic@{VGic}!GICH\_\-EISR0@{GICH\_\-EISR0}}
\index{GICH\_\-EISR0@{GICH\_\-EISR0}!VGic@{VGic}}
\subsubsection[{GICH\_\-EISR0}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICH\_\-EISR0} = 0x020\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a6377986cfc790adf7f3274de63f840a5}
\hypertarget{classVGic_ad2d40266f69c1beee09c888281738df1}{
\index{VGic@{VGic}!GICH\_\-EISR1@{GICH\_\-EISR1}}
\index{GICH\_\-EISR1@{GICH\_\-EISR1}!VGic@{VGic}}
\subsubsection[{GICH\_\-EISR1}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICH\_\-EISR1} = 0x024\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_ad2d40266f69c1beee09c888281738df1}
\hypertarget{classVGic_af16152e073dd9ed6e6ce3515c99301c9}{
\index{VGic@{VGic}!GICH\_\-ELSR0@{GICH\_\-ELSR0}}
\index{GICH\_\-ELSR0@{GICH\_\-ELSR0}!VGic@{VGic}}
\subsubsection[{GICH\_\-ELSR0}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICH\_\-ELSR0} = 0x030\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_af16152e073dd9ed6e6ce3515c99301c9}
\hypertarget{classVGic_a1dc31e7d69166471775d43e3729228b4}{
\index{VGic@{VGic}!GICH\_\-ELSR1@{GICH\_\-ELSR1}}
\index{GICH\_\-ELSR1@{GICH\_\-ELSR1}!VGic@{VGic}}
\subsubsection[{GICH\_\-ELSR1}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICH\_\-ELSR1} = 0x034\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a1dc31e7d69166471775d43e3729228b4}
\hypertarget{classVGic_a05157a03988a41b46b78b6d9d5a49bf6}{
\index{VGic@{VGic}!GICH\_\-HCR@{GICH\_\-HCR}}
\index{GICH\_\-HCR@{GICH\_\-HCR}!VGic@{VGic}}
\subsubsection[{GICH\_\-HCR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICH\_\-HCR} = 0x000\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a05157a03988a41b46b78b6d9d5a49bf6}
\hypertarget{classVGic_a75e35ac1eddd88a77229bf915b48273f}{
\index{VGic@{VGic}!GICH\_\-LR0@{GICH\_\-LR0}}
\index{GICH\_\-LR0@{GICH\_\-LR0}!VGic@{VGic}}
\subsubsection[{GICH\_\-LR0}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICH\_\-LR0} = 0x100\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a75e35ac1eddd88a77229bf915b48273f}
\hypertarget{classVGic_ace36c2959f314bca6c1f53ef7b471011}{
\index{VGic@{VGic}!GICH\_\-LR1@{GICH\_\-LR1}}
\index{GICH\_\-LR1@{GICH\_\-LR1}!VGic@{VGic}}
\subsubsection[{GICH\_\-LR1}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICH\_\-LR1} = 0x104\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_ace36c2959f314bca6c1f53ef7b471011}
\hypertarget{classVGic_a58f68d484460b5ba7753425a306db71e}{
\index{VGic@{VGic}!GICH\_\-LR2@{GICH\_\-LR2}}
\index{GICH\_\-LR2@{GICH\_\-LR2}!VGic@{VGic}}
\subsubsection[{GICH\_\-LR2}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICH\_\-LR2} = 0x108\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a58f68d484460b5ba7753425a306db71e}
\hypertarget{classVGic_a630c33972a6516ce8617656424902292}{
\index{VGic@{VGic}!GICH\_\-LR3@{GICH\_\-LR3}}
\index{GICH\_\-LR3@{GICH\_\-LR3}!VGic@{VGic}}
\subsubsection[{GICH\_\-LR3}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICH\_\-LR3} = 0x10c\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a630c33972a6516ce8617656424902292}
\hypertarget{classVGic_a8f6ba28cb22381782c786778de9236a7}{
\index{VGic@{VGic}!GICH\_\-MISR@{GICH\_\-MISR}}
\index{GICH\_\-MISR@{GICH\_\-MISR}!VGic@{VGic}}
\subsubsection[{GICH\_\-MISR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICH\_\-MISR} = 0x010\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a8f6ba28cb22381782c786778de9236a7}
\hypertarget{classVGic_a2ca8a33991e94727efb46a8bba9e1e2a}{
\index{VGic@{VGic}!GICH\_\-REG\_\-SIZE@{GICH\_\-REG\_\-SIZE}}
\index{GICH\_\-REG\_\-SIZE@{GICH\_\-REG\_\-SIZE}!VGic@{VGic}}
\subsubsection[{GICH\_\-REG\_\-SIZE}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICH\_\-REG\_\-SIZE} = 0x2000\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a2ca8a33991e94727efb46a8bba9e1e2a}
\hypertarget{classVGic_a85a1239e9b48c54a4342993df2743e13}{
\index{VGic@{VGic}!GICH\_\-SIZE@{GICH\_\-SIZE}}
\index{GICH\_\-SIZE@{GICH\_\-SIZE}!VGic@{VGic}}
\subsubsection[{GICH\_\-SIZE}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICH\_\-SIZE} = 0x200\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a85a1239e9b48c54a4342993df2743e13}
\hypertarget{classVGic_a10bf121a0b670d835ede0ba151cb62bd}{
\index{VGic@{VGic}!GICH\_\-VMCR@{GICH\_\-VMCR}}
\index{GICH\_\-VMCR@{GICH\_\-VMCR}!VGic@{VGic}}
\subsubsection[{GICH\_\-VMCR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICH\_\-VMCR} = 0x008\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a10bf121a0b670d835ede0ba151cb62bd}
\hypertarget{classVGic_ac1961ca86b5c402d101577a495694f42}{
\index{VGic@{VGic}!GICH\_\-VTR@{GICH\_\-VTR}}
\index{GICH\_\-VTR@{GICH\_\-VTR}!VGic@{VGic}}
\subsubsection[{GICH\_\-VTR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICH\_\-VTR} = 0x004\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_ac1961ca86b5c402d101577a495694f42}
\hypertarget{classVGic_ac2262138aebc47d7e32b347f6cb580a6}{
\index{VGic@{VGic}!GICV\_\-ABPR@{GICV\_\-ABPR}}
\index{GICV\_\-ABPR@{GICV\_\-ABPR}!VGic@{VGic}}
\subsubsection[{GICV\_\-ABPR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICV\_\-ABPR} = 0x01c\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_ac2262138aebc47d7e32b347f6cb580a6}
\hypertarget{classVGic_a91ec09125f0759c2d32fa7bba32f3b03}{
\index{VGic@{VGic}!GICV\_\-AEOIR@{GICV\_\-AEOIR}}
\index{GICV\_\-AEOIR@{GICV\_\-AEOIR}!VGic@{VGic}}
\subsubsection[{GICV\_\-AEOIR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICV\_\-AEOIR} = 0x024\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a91ec09125f0759c2d32fa7bba32f3b03}
\hypertarget{classVGic_a95e1cf51d24aa765e82dd89f10321062}{
\index{VGic@{VGic}!GICV\_\-AHPPIR@{GICV\_\-AHPPIR}}
\index{GICV\_\-AHPPIR@{GICV\_\-AHPPIR}!VGic@{VGic}}
\subsubsection[{GICV\_\-AHPPIR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICV\_\-AHPPIR} = 0x028\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a95e1cf51d24aa765e82dd89f10321062}
\hypertarget{classVGic_a471e427964bbc593aee5f4ce918b6ce2}{
\index{VGic@{VGic}!GICV\_\-AIAR@{GICV\_\-AIAR}}
\index{GICV\_\-AIAR@{GICV\_\-AIAR}!VGic@{VGic}}
\subsubsection[{GICV\_\-AIAR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICV\_\-AIAR} = 0x020\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a471e427964bbc593aee5f4ce918b6ce2}
\hypertarget{classVGic_aa0efd17f14c57d720c184ee92b83ee05}{
\index{VGic@{VGic}!GICV\_\-APR0@{GICV\_\-APR0}}
\index{GICV\_\-APR0@{GICV\_\-APR0}!VGic@{VGic}}
\subsubsection[{GICV\_\-APR0}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICV\_\-APR0} = 0x0d0\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_aa0efd17f14c57d720c184ee92b83ee05}
\hypertarget{classVGic_ab87c04cb10d6d7d4dc9bfdb41e67bd55}{
\index{VGic@{VGic}!GICV\_\-BPR@{GICV\_\-BPR}}
\index{GICV\_\-BPR@{GICV\_\-BPR}!VGic@{VGic}}
\subsubsection[{GICV\_\-BPR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICV\_\-BPR} = 0x008\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_ab87c04cb10d6d7d4dc9bfdb41e67bd55}
\hypertarget{classVGic_ab4280dfa561ca960d58d341662849f7b}{
\index{VGic@{VGic}!GICV\_\-CTLR@{GICV\_\-CTLR}}
\index{GICV\_\-CTLR@{GICV\_\-CTLR}!VGic@{VGic}}
\subsubsection[{GICV\_\-CTLR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICV\_\-CTLR} = 0x000\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_ab4280dfa561ca960d58d341662849f7b}
\hypertarget{classVGic_a806d487cfebc43c0536726f39a340463}{
\index{VGic@{VGic}!GICV\_\-DIR@{GICV\_\-DIR}}
\index{GICV\_\-DIR@{GICV\_\-DIR}!VGic@{VGic}}
\subsubsection[{GICV\_\-DIR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICV\_\-DIR} = 0x1000\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a806d487cfebc43c0536726f39a340463}
\hypertarget{classVGic_ae75c9bc58bd94b6dfc83ecc0ea89e767}{
\index{VGic@{VGic}!GICV\_\-EOIR@{GICV\_\-EOIR}}
\index{GICV\_\-EOIR@{GICV\_\-EOIR}!VGic@{VGic}}
\subsubsection[{GICV\_\-EOIR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICV\_\-EOIR} = 0x010\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_ae75c9bc58bd94b6dfc83ecc0ea89e767}
\hypertarget{classVGic_adeb087954f3f7141cc49dd6236b4aa4c}{
\index{VGic@{VGic}!GICV\_\-HPPIR@{GICV\_\-HPPIR}}
\index{GICV\_\-HPPIR@{GICV\_\-HPPIR}!VGic@{VGic}}
\subsubsection[{GICV\_\-HPPIR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICV\_\-HPPIR} = 0x018\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_adeb087954f3f7141cc49dd6236b4aa4c}
\hypertarget{classVGic_a132fc471769307b51fb6ee13cd852835}{
\index{VGic@{VGic}!GICV\_\-IAR@{GICV\_\-IAR}}
\index{GICV\_\-IAR@{GICV\_\-IAR}!VGic@{VGic}}
\subsubsection[{GICV\_\-IAR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICV\_\-IAR} = 0x00c\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a132fc471769307b51fb6ee13cd852835}
\hypertarget{classVGic_a40aac9b1ed27436f1ef04ff0f4b03f66}{
\index{VGic@{VGic}!GICV\_\-IIDR@{GICV\_\-IIDR}}
\index{GICV\_\-IIDR@{GICV\_\-IIDR}!VGic@{VGic}}
\subsubsection[{GICV\_\-IIDR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICV\_\-IIDR} = 0x0fc\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a40aac9b1ed27436f1ef04ff0f4b03f66}
\hypertarget{classVGic_a25c57288ef4b1aad4afbc584a92b8391}{
\index{VGic@{VGic}!GICV\_\-PMR@{GICV\_\-PMR}}
\index{GICV\_\-PMR@{GICV\_\-PMR}!VGic@{VGic}}
\subsubsection[{GICV\_\-PMR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICV\_\-PMR} = 0x004\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a25c57288ef4b1aad4afbc584a92b8391}
\hypertarget{classVGic_a1f4656693af03dc9ad24b55cf12eaaca}{
\index{VGic@{VGic}!GICV\_\-RPR@{GICV\_\-RPR}}
\index{GICV\_\-RPR@{GICV\_\-RPR}!VGic@{VGic}}
\subsubsection[{GICV\_\-RPR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICV\_\-RPR} = 0x014\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a1f4656693af03dc9ad24b55cf12eaaca}
\hypertarget{classVGic_a327649260109afc17ff86a3a8371cb95}{
\index{VGic@{VGic}!GICV\_\-SIZE@{GICV\_\-SIZE}}
\index{GICV\_\-SIZE@{GICV\_\-SIZE}!VGic@{VGic}}
\subsubsection[{GICV\_\-SIZE}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf GICV\_\-SIZE} = 0x2000\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a327649260109afc17ff86a3a8371cb95}
\hypertarget{classVGic_a8c9d4553eb4294402cbe8b77c7be7d43}{
\index{VGic@{VGic}!Grp1@{Grp1}}
\index{Grp1@{Grp1}!VGic@{VGic}}
\subsubsection[{Grp1}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$30$>$ {\bf Grp1}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a8c9d4553eb4294402cbe8b77c7be7d43}
\hypertarget{classVGic_a382afc2ed37622bb0da354e863a9c121}{
\index{VGic@{VGic}!hvAddr@{hvAddr}}
\index{hvAddr@{hvAddr}!VGic@{VGic}}
\subsubsection[{hvAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf hvAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a382afc2ed37622bb0da354e863a9c121}
\hypertarget{classVGic_a8c71200f07eaae9cd4292f5c4438ec0b}{
\index{VGic@{VGic}!LR\_\-ACTIVE@{LR\_\-ACTIVE}}
\index{LR\_\-ACTIVE@{LR\_\-ACTIVE}!VGic@{VGic}}
\subsubsection[{LR\_\-ACTIVE}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf LR\_\-ACTIVE} = 2\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a8c71200f07eaae9cd4292f5c4438ec0b}
\hypertarget{classVGic_a0494deefa99c7f4fd9b8f3ee52a56cee}{
\index{VGic@{VGic}!LR\_\-PENDING@{LR\_\-PENDING}}
\index{LR\_\-PENDING@{LR\_\-PENDING}!VGic@{VGic}}
\subsubsection[{LR\_\-PENDING}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf LR\_\-PENDING} = 1\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a0494deefa99c7f4fd9b8f3ee52a56cee}
\hypertarget{classVGic_ab0faa2c980aa53ef7c92002af04c332b}{
\index{VGic@{VGic}!LRENPIE@{LRENPIE}}
\index{LRENPIE@{LRENPIE}!VGic@{VGic}}
\subsubsection[{LRENPIE}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$2$>$ {\bf LRENPIE}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_ab0faa2c980aa53ef7c92002af04c332b}
\hypertarget{classVGic_a39c00dce99eb5fe8a22703e2286661f5}{
\index{VGic@{VGic}!maintInt@{maintInt}}
\index{maintInt@{maintInt}!VGic@{VGic}}
\subsubsection[{maintInt}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf maintInt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a39c00dce99eb5fe8a22703e2286661f5}
\hypertarget{classVGic_afc202b126ba5621ec4dae742b51889d0}{
\index{VGic@{VGic}!maintIntPosted@{maintIntPosted}}
\index{maintIntPosted@{maintIntPosted}!VGic@{VGic}}
\subsubsection[{maintIntPosted}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf maintIntPosted}\mbox{[}{\bf VGIC\_\-CPU\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_afc202b126ba5621ec4dae742b51889d0}
\hypertarget{classVGic_aa24f9f3124265bcdf1cea24165b2b0b9}{
\index{VGic@{VGic}!NPIE@{NPIE}}
\index{NPIE@{NPIE}!VGic@{VGic}}
\subsubsection[{NPIE}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$3$>$ {\bf NPIE}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_aa24f9f3124265bcdf1cea24165b2b0b9}
\hypertarget{classVGic_a4729ce082ccbd9fef9a9131c6b194204}{
\index{VGic@{VGic}!NUM\_\-LR@{NUM\_\-LR}}
\index{NUM\_\-LR@{NUM\_\-LR}!VGic@{VGic}}
\subsubsection[{NUM\_\-LR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf NUM\_\-LR} = 4\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_a4729ce082ccbd9fef9a9131c6b194204}
\hypertarget{classVGic_ac8e969635a78ab9ab123904ccca434cc}{
\index{VGic@{VGic}!pioDelay@{pioDelay}}
\index{pioDelay@{pioDelay}!VGic@{VGic}}
\subsubsection[{pioDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf pioDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_ac8e969635a78ab9ab123904ccca434cc}
\hypertarget{classVGic_a75b48f1787959a4617f2a599d7c09aab}{
\index{VGic@{VGic}!platform@{platform}}
\index{platform@{platform}!VGic@{VGic}}
\subsubsection[{platform}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Platform}$\ast$ {\bf platform}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a75b48f1787959a4617f2a599d7c09aab}
\hypertarget{classVGic_a391a6d3a21ceaa229791a17f58d2e0ae}{
\index{VGic@{VGic}!postVIntEvent@{postVIntEvent}}
\index{postVIntEvent@{postVIntEvent}!VGic@{VGic}}
\subsubsection[{postVIntEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PostVIntEvent}$\ast$ {\bf postVIntEvent}\mbox{[}{\bf VGIC\_\-CPU\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a391a6d3a21ceaa229791a17f58d2e0ae}
\hypertarget{classVGic_a26c7f4132225aed6b8d4356c1601d689}{
\index{VGic@{VGic}!Priority@{Priority}}
\index{Priority@{Priority}!VGic@{VGic}}
\subsubsection[{Priority}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$27,23$>$ {\bf Priority}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a26c7f4132225aed6b8d4356c1601d689}
\hypertarget{classVGic_a4ad4e2a479baf0de8e8cdcb0c84276db}{
\index{VGic@{VGic}!State@{State}}
\index{State@{State}!VGic@{VGic}}
\subsubsection[{State}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$29,28$>$ {\bf State}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a4ad4e2a479baf0de8e8cdcb0c84276db}
Object drain/handover states

An object starts out in the Running state. When the simulator prepares to take a snapshot or prepares a CPU for handover, it calls the \hyperlink{classPioDevice_a6bf479c521c7c3eb473822d953275b26}{drain()} method to transfer the object into the Draining or Drained state. If any object enters the Draining state (\hyperlink{classPioDevice_a6bf479c521c7c3eb473822d953275b26}{drain()} returning $>$0), simulation continues until it all objects have entered the Drained state.

Before resuming simulation, the simulator calls \hyperlink{namespacem5_1_1simulate_a2985608bac11887a6ae3df9b068b10fe}{resume()} to transfer the object to the Running state.

\begin{DoxyNote}{覚え書き}
Even though the state of an object (visible to the rest of the world through getState()) could be used to determine if all objects have entered the Drained state, the protocol is actually a bit more elaborate. See \hyperlink{classPioDevice_a6bf479c521c7c3eb473822d953275b26}{drain()} for details. 
\end{DoxyNote}


\hyperlink{classDrainable_a5d74787dedbc4e11c1ab15bf487e61f8}{Drainable}を再定義しています。\hypertarget{classVGic_a0adbea6aeb62d30f03ddc9a25fe11b40}{
\index{VGic@{VGic}!UIE@{UIE}}
\index{UIE@{UIE}!VGic@{VGic}}
\subsubsection[{UIE}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$1$>$ {\bf UIE}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a0adbea6aeb62d30f03ddc9a25fe11b40}
\hypertarget{classVGic_a6967a675bb97fef5858618111567aba0}{
\index{VGic@{VGic}!vcpuAddr@{vcpuAddr}}
\index{vcpuAddr@{vcpuAddr}!VGic@{VGic}}
\subsubsection[{vcpuAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf vcpuAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a6967a675bb97fef5858618111567aba0}
\hypertarget{classVGic_a98b5031733bb2cb7d20cf68a3a1ac460}{
\index{VGic@{VGic}!vcpuData@{vcpuData}}
\index{vcpuData@{vcpuData}!VGic@{VGic}}
\subsubsection[{vcpuData}]{\setlength{\rightskip}{0pt plus 5cm}struct vcpuIntData {\bf vcpuData}\mbox{[}{\bf VGIC\_\-CPU\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}read, private\mbox{]}}}}
\label{classVGic_a98b5031733bb2cb7d20cf68a3a1ac460}
\hypertarget{classVGic_abdf6630d700683c52d9cd03f11d660ac}{
\index{VGic@{VGic}!VGIC\_\-CPU\_\-MAX@{VGIC\_\-CPU\_\-MAX}}
\index{VGIC\_\-CPU\_\-MAX@{VGIC\_\-CPU\_\-MAX}!VGic@{VGic}}
\subsubsection[{VGIC\_\-CPU\_\-MAX}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf VGIC\_\-CPU\_\-MAX} = 256\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classVGic_abdf6630d700683c52d9cd03f11d660ac}
\hypertarget{classVGic_affc0c4742ef1d61df5a0e8e8b2cee33b}{
\index{VGic@{VGic}!VGrp0DIE@{VGrp0DIE}}
\index{VGrp0DIE@{VGrp0DIE}!VGic@{VGic}}
\subsubsection[{VGrp0DIE}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$5$>$ {\bf VGrp0DIE}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_affc0c4742ef1d61df5a0e8e8b2cee33b}
\hypertarget{classVGic_a76012350e6bb46dfdc7240afc726d949}{
\index{VGic@{VGic}!VGrp0EIE@{VGrp0EIE}}
\index{VGrp0EIE@{VGrp0EIE}!VGic@{VGic}}
\subsubsection[{VGrp0EIE}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$4$>$ {\bf VGrp0EIE}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a76012350e6bb46dfdc7240afc726d949}
\hypertarget{classVGic_a3055f44714481212195dd4c9b77302ee}{
\index{VGic@{VGic}!VGrp1DIE@{VGrp1DIE}}
\index{VGrp1DIE@{VGrp1DIE}!VGic@{VGic}}
\subsubsection[{VGrp1DIE}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$7$>$ {\bf VGrp1DIE}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a3055f44714481212195dd4c9b77302ee}
\hypertarget{classVGic_ad5d876b0f8095008474757f67bf975e4}{
\index{VGic@{VGic}!VGrp1EIE@{VGrp1EIE}}
\index{VGrp1EIE@{VGrp1EIE}!VGic@{VGic}}
\subsubsection[{VGrp1EIE}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$6$>$ {\bf VGrp1EIE}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_ad5d876b0f8095008474757f67bf975e4}
\hypertarget{classVGic_a4108a1761c811efd10f4bd705fab8581}{
\index{VGic@{VGic}!vIntPosted@{vIntPosted}}
\index{vIntPosted@{vIntPosted}!VGic@{VGic}}
\subsubsection[{vIntPosted}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf vIntPosted}\mbox{[}{\bf VGIC\_\-CPU\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a4108a1761c811efd10f4bd705fab8581}
\hypertarget{classVGic_a309cc4782346e985de8920752d7caf2a}{
\index{VGic@{VGic}!VirtualID@{VirtualID}}
\index{VirtualID@{VirtualID}!VGic@{VGic}}
\subsubsection[{VirtualID}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$9,0$>$ {\bf VirtualID}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classVGic_a309cc4782346e985de8920752d7caf2a}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/arm/\hyperlink{vgic_8hh}{vgic.hh}\item 
dev/arm/\hyperlink{vgic_8cc}{vgic.cc}\end{DoxyCompactItemize}
