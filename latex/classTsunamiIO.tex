\hypertarget{classTsunamiIO}{
\section{クラス TsunamiIO}
\label{classTsunamiIO}\index{TsunamiIO@{TsunamiIO}}
}


{\ttfamily \#include $<$tsunami\_\-io.hh$>$}TsunamiIOに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=7cm]{classTsunamiIO}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classTsunamiIO_1_1RTC}{RTC}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef TsunamiIOParams \hyperlink{classTsunamiIO_a46efefdf21511fe3655f4589444a8479}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classTsunamiIO_ae7d31c6aab76d9d4e74e5e7227337651}{frequency} () const 
\item 
\hyperlink{classTsunamiIO_a8efaf6e7ccc23f00c50f96eb2cefc742}{TsunamiIO} (const \hyperlink{classTsunamiIO_a46efefdf21511fe3655f4589444a8479}{Params} $\ast$p)
\item 
const \hyperlink{classTsunamiIO_a46efefdf21511fe3655f4589444a8479}{Params} $\ast$ \hyperlink{classTsunamiIO_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classTsunamiIO_a613ec7d5e1ec64f8d21fec78ae8e568e}{read} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classTsunamiIO_a4cefab464e72b5dd42c003a0a4341802}{write} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classTsunamiIO_a4b01cbf1b633d5c31fdf43b661f222e1}{postPIC} (uint8\_\-t bitvector)
\item 
void \hyperlink{classTsunamiIO_ac1aa8cd6747e47946be3f85d914a6e69}{clearPIC} (uint8\_\-t bitvector)
\item 
virtual void \hyperlink{classTsunamiIO_ad6272f80ae37e8331e3969b3f072a801}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classTsunamiIO_af100c4e9feabf3cd918619c88c718387}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
uint8\_\-t \hyperlink{classTsunamiIO_adaf4809f6b77e7cde58780f5f451a6e4}{mask1}
\item 
uint8\_\-t \hyperlink{classTsunamiIO_a474e49c245ff8b6dc57653a9cd7f64dc}{mask2}
\item 
uint8\_\-t \hyperlink{classTsunamiIO_a9237c26b42f96e5e4ad44839abdf85ce}{mode1}
\item 
uint8\_\-t \hyperlink{classTsunamiIO_af51e3a81fa6352c9fbc24d5bc03d843f}{mode2}
\item 
uint8\_\-t \hyperlink{classTsunamiIO_a8472e2cd6c519d77f7b7ab878a42fa40}{picr}
\item 
bool \hyperlink{classTsunamiIO_ab72d9ca48cf8b7b897799490833c4b5e}{picInterrupting}
\item 
\hyperlink{classTsunami}{Tsunami} $\ast$ \hyperlink{classTsunamiIO_aa178467f241f875a068722413f62ec20}{tsunami}
\item 
\hyperlink{classIntel8254Timer}{Intel8254Timer} \hyperlink{classTsunamiIO_a0447f4b0ded66f26d3ce882c29d1125e}{pitimer}
\item 
\hyperlink{classTsunamiIO_1_1RTC}{RTC} \hyperlink{classTsunamiIO_afa7e240c7456eaf5ef27ee8be3a23bd4}{rtc}
\item 
uint8\_\-t \hyperlink{classTsunamiIO_a4603c0adbe60021db8e6d488b0366d75}{rtcAddr}
\item 
uint16\_\-t \hyperlink{classTsunamiIO_ac2f6e48e9ea7cdd01d0d4855725107d6}{timerData}
\end{DoxyCompactItemize}


\subsection{説明}
\hyperlink{classTsunami}{Tsunami} I/O device is a catch all for all the south bridge stuff we care to implement. 

\subsection{型定義}
\hypertarget{classTsunamiIO_a46efefdf21511fe3655f4589444a8479}{
\index{TsunamiIO@{TsunamiIO}!Params@{Params}}
\index{Params@{Params}!TsunamiIO@{TsunamiIO}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef TsunamiIOParams {\bf Params}}}
\label{classTsunamiIO_a46efefdf21511fe3655f4589444a8479}


\hyperlink{classBasicPioDevice_a2845515ac6467f10540747053c8a0449}{BasicPioDevice}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classTsunamiIO_a8efaf6e7ccc23f00c50f96eb2cefc742}{
\index{TsunamiIO@{TsunamiIO}!TsunamiIO@{TsunamiIO}}
\index{TsunamiIO@{TsunamiIO}!TsunamiIO@{TsunamiIO}}
\subsubsection[{TsunamiIO}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TsunamiIO} (const {\bf Params} $\ast$ {\em p})}}
\label{classTsunamiIO_a8efaf6e7ccc23f00c50f96eb2cefc742}
Initialize all the data for devices supported by \hyperlink{classTsunami}{Tsunami} I/O. 
\begin{DoxyParams}{引数}
\item[{\em p}]pointer to Params struct \end{DoxyParams}



\begin{DoxyCode}
72     : BasicPioDevice(p, 0x100), tsunami(p->tsunami),
73       pitimer(this, p->name + "pitimer"), rtc(p->name + ".rtc", p)
74 {
75     // set the back pointer from tsunami to myself
76     tsunami->io = this;
77 
78     timerData = 0;
79     picr = 0;
80     picInterrupting = false;
81 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classTsunamiIO_ac1aa8cd6747e47946be3f85d914a6e69}{
\index{TsunamiIO@{TsunamiIO}!clearPIC@{clearPIC}}
\index{clearPIC@{clearPIC}!TsunamiIO@{TsunamiIO}}
\subsubsection[{clearPIC}]{\setlength{\rightskip}{0pt plus 5cm}void clearPIC (uint8\_\-t {\em bitvector})}}
\label{classTsunamiIO_ac1aa8cd6747e47946be3f85d914a6e69}
Clear a posted interrupt 
\begin{DoxyParams}{引数}
\item[{\em bitvector}]interrupt to clear \end{DoxyParams}



\begin{DoxyCode}
246 {
247     //PIC2 Is not implemented, because nothing of interest there
248     picr &= ~bitvector;
249     if (!(picr & mask1)) {
250         tsunami->cchip->clearDRIR(55);
251         DPRINTF(Tsunami, "clearing pic interrupt to cchip\n");
252     }
253 }
\end{DoxyCode}
\hypertarget{classTsunamiIO_ae7d31c6aab76d9d4e74e5e7227337651}{
\index{TsunamiIO@{TsunamiIO}!frequency@{frequency}}
\index{frequency@{frequency}!TsunamiIO@{TsunamiIO}}
\subsubsection[{frequency}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} frequency () const}}
\label{classTsunamiIO_ae7d31c6aab76d9d4e74e5e7227337651}
Return the freqency of the \hyperlink{classTsunamiIO_1_1RTC}{RTC} \begin{DoxyReturn}{戻り値}
interrupt rate of the \hyperlink{classTsunamiIO_1_1RTC}{RTC} 
\end{DoxyReturn}


\hyperlink{classClockedObject_a47ad0ff313f0dcb63b8223b1f11d49d8}{ClockedObject}を再定義しています。


\begin{DoxyCode}
85 {
86     return SimClock::Frequency / params()->frequency;
87 }
\end{DoxyCode}
\hypertarget{classTsunamiIO_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{TsunamiIO@{TsunamiIO}!params@{params}}
\index{params@{params}!TsunamiIO@{TsunamiIO}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classTsunamiIO_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classBasicPioDevice_acd3c3feb78ae7a8f88fe0f110a718dff}{BasicPioDevice}を再定義しています。


\begin{DoxyCode}
122     {
123         return dynamic_cast<const Params *>(_params);
124     }
\end{DoxyCode}
\hypertarget{classTsunamiIO_a4b01cbf1b633d5c31fdf43b661f222e1}{
\index{TsunamiIO@{TsunamiIO}!postPIC@{postPIC}}
\index{postPIC@{postPIC}!TsunamiIO@{TsunamiIO}}
\subsubsection[{postPIC}]{\setlength{\rightskip}{0pt plus 5cm}void postPIC (uint8\_\-t {\em bitvector})}}
\label{classTsunamiIO_a4b01cbf1b633d5c31fdf43b661f222e1}
Post an PIC interrupt to the CPU via the CChip 
\begin{DoxyParams}{引数}
\item[{\em bitvector}]interrupt to post. \end{DoxyParams}



\begin{DoxyCode}
235 {
236     //PIC2 Is not implemented, because nothing of interest there
237     picr |= bitvector;
238     if (picr & mask1) {
239         tsunami->cchip->postDRIR(55);
240         DPRINTF(Tsunami, "posting pic interrupt to cchip\n");
241     }
242 }
\end{DoxyCode}
\hypertarget{classTsunamiIO_a613ec7d5e1ec64f8d21fec78ae8e568e}{
\index{TsunamiIO@{TsunamiIO}!read@{read}}
\index{read@{read}!TsunamiIO@{TsunamiIO}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} read ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTsunamiIO_a613ec7d5e1ec64f8d21fec78ae8e568e}
Pure virtual function that the device must implement. Called when a read command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_a842312590432036092c422c87a442358}{PioDevice}を実装しています。


\begin{DoxyCode}
91 {
92     assert(pkt->getAddr() >= pioAddr && pkt->getAddr() < pioAddr + pioSize);
93 
94     Addr daddr = pkt->getAddr() - pioAddr;
95 
96     DPRINTF(Tsunami, "io read  va=%#x size=%d IOPorrt=%#x\n", pkt->getAddr(),
97             pkt->getSize(), daddr);
98 
99     pkt->allocate();
100 
101     if (pkt->getSize() == sizeof(uint8_t)) {
102         switch(daddr) {
103           // PIC1 mask read
104           case TSDEV_PIC1_MASK:
105             pkt->set(~mask1);
106             break;
107           case TSDEV_PIC2_MASK:
108             pkt->set(~mask2);
109             break;
110           case TSDEV_PIC1_ISR:
111               // !!! If this is modified 64bit case needs to be too
112               // Pal code has to do a 64 bit physical read because there is
113               // no load physical byte instruction
114               pkt->set(picr);
115               break;
116           case TSDEV_PIC2_ISR:
117               // PIC2 not implemnted... just return 0
118               pkt->set(0x00);
119               break;
120           case TSDEV_TMR0_DATA:
121             pkt->set(pitimer.readCounter(0));
122             break;
123           case TSDEV_TMR1_DATA:
124             pkt->set(pitimer.readCounter(1));
125             break;
126           case TSDEV_TMR2_DATA:
127             pkt->set(pitimer.readCounter(2));
128             break;
129           case TSDEV_RTC_DATA:
130             pkt->set(rtc.readData(rtcAddr));
131             break;
132           case TSDEV_CTRL_PORTB:
133             if (pitimer.outputHigh(2))
134                 pkt->set(PORTB_SPKR_HIGH);
135             else
136                 pkt->set(0x00);
137             break;
138           default:
139             panic("I/O Read - va%#x size %d\n", pkt->getAddr(), pkt->getSize());
140         }
141     } else if (pkt->getSize() == sizeof(uint64_t)) {
142         if (daddr == TSDEV_PIC1_ISR)
143             pkt->set<uint64_t>(picr);
144         else
145            panic("I/O Read - invalid addr - va %#x size %d\n",
146                    pkt->getAddr(), pkt->getSize());
147     } else {
148        panic("I/O Read - invalid size - va %#x size %d\n", pkt->getAddr(), pkt->
      getSize());
149     }
150     pkt->makeAtomicResponse();
151     return pioDelay;
152 }
\end{DoxyCode}
\hypertarget{classTsunamiIO_ad6272f80ae37e8331e3969b3f072a801}{
\index{TsunamiIO@{TsunamiIO}!serialize@{serialize}}
\index{serialize@{serialize}!TsunamiIO@{TsunamiIO}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}virtual void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTsunamiIO_ad6272f80ae37e8331e3969b3f072a801}
Serialize this object to the given output stream. 
\begin{DoxyParams}{引数}
\item[{\em os}]The stream to serialize to. \end{DoxyParams}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。\hypertarget{classTsunamiIO_af100c4e9feabf3cd918619c88c718387}{
\index{TsunamiIO@{TsunamiIO}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!TsunamiIO@{TsunamiIO}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}virtual void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTsunamiIO_af100c4e9feabf3cd918619c88c718387}
Reconstruct the state of this object from a checkpoint. 
\begin{DoxyParams}{引数}
\item[{\em \hyperlink{namespacecp}{cp}}]The checkpoint use. \item[{\em section}]The section name of this object \end{DoxyParams}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。\hypertarget{classTsunamiIO_a4cefab464e72b5dd42c003a0a4341802}{
\index{TsunamiIO@{TsunamiIO}!write@{write}}
\index{write@{write}!TsunamiIO@{TsunamiIO}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} write ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTsunamiIO_a4cefab464e72b5dd42c003a0a4341802}
Pure virtual function that the device must implement. Called when a write command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_afe8371668d023bb2516b286e5e399b6f}{PioDevice}を実装しています。


\begin{DoxyCode}
156 {
157     assert(pkt->getAddr() >= pioAddr && pkt->getAddr() < pioAddr + pioSize);
158     Addr daddr = pkt->getAddr() - pioAddr;
159 
160     DPRINTF(Tsunami, "io write - va=%#x size=%d IOPort=%#x Data=%#x\n",
161             pkt->getAddr(), pkt->getSize(), pkt->getAddr() & 0xfff, (uint32_t)pkt
      ->get<uint8_t>());
162 
163     assert(pkt->getSize() == sizeof(uint8_t));
164 
165     switch(daddr) {
166       case TSDEV_PIC1_MASK:
167         mask1 = ~(pkt->get<uint8_t>());
168         if ((picr & mask1) && !picInterrupting) {
169             picInterrupting = true;
170             tsunami->cchip->postDRIR(55);
171             DPRINTF(Tsunami, "posting pic interrupt to cchip\n");
172         }
173         if ((!(picr & mask1)) && picInterrupting) {
174             picInterrupting = false;
175             tsunami->cchip->clearDRIR(55);
176             DPRINTF(Tsunami, "clearing pic interrupt\n");
177         }
178         break;
179       case TSDEV_PIC2_MASK:
180         mask2 = pkt->get<uint8_t>();
181         //PIC2 Not implemented to interrupt
182         break;
183       case TSDEV_PIC1_ACK:
184         // clear the interrupt on the PIC
185         picr &= ~(1 << (pkt->get<uint8_t>() & 0xF));
186         if (!(picr & mask1))
187             tsunami->cchip->clearDRIR(55);
188         break;
189       case TSDEV_DMA1_MODE:
190         mode1 = pkt->get<uint8_t>();
191         break;
192       case TSDEV_DMA2_MODE:
193         mode2 = pkt->get<uint8_t>();
194         break;
195       case TSDEV_TMR0_DATA:
196         pitimer.writeCounter(0, pkt->get<uint8_t>());
197         break;
198       case TSDEV_TMR1_DATA:
199         pitimer.writeCounter(1, pkt->get<uint8_t>());
200         break;
201       case TSDEV_TMR2_DATA:
202         pitimer.writeCounter(2, pkt->get<uint8_t>());
203         break;
204       case TSDEV_TMR_CTRL:
205         pitimer.writeControl(pkt->get<uint8_t>());
206         break;
207       case TSDEV_RTC_ADDR:
208         rtcAddr = pkt->get<uint8_t>();
209         break;
210       case TSDEV_RTC_DATA:
211         rtc.writeData(rtcAddr, pkt->get<uint8_t>());
212         break;
213       case TSDEV_KBD:
214       case TSDEV_DMA1_CMND:
215       case TSDEV_DMA2_CMND:
216       case TSDEV_DMA1_MMASK:
217       case TSDEV_DMA2_MMASK:
218       case TSDEV_PIC2_ACK:
219       case TSDEV_DMA1_RESET:
220       case TSDEV_DMA2_RESET:
221       case TSDEV_DMA1_MASK:
222       case TSDEV_DMA2_MASK:
223       case TSDEV_CTRL_PORTB:
224         break;
225       default:
226         panic("I/O Write - va%#x size %d data %#x\n", pkt->getAddr(), pkt->
      getSize(), pkt->get<uint8_t>());
227     }
228 
229     pkt->makeAtomicResponse();
230     return pioDelay;
231 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classTsunamiIO_adaf4809f6b77e7cde58780f5f451a6e4}{
\index{TsunamiIO@{TsunamiIO}!mask1@{mask1}}
\index{mask1@{mask1}!TsunamiIO@{TsunamiIO}}
\subsubsection[{mask1}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf mask1}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiIO_adaf4809f6b77e7cde58780f5f451a6e4}
Mask of the PIC1 \hypertarget{classTsunamiIO_a474e49c245ff8b6dc57653a9cd7f64dc}{
\index{TsunamiIO@{TsunamiIO}!mask2@{mask2}}
\index{mask2@{mask2}!TsunamiIO@{TsunamiIO}}
\subsubsection[{mask2}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf mask2}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiIO_a474e49c245ff8b6dc57653a9cd7f64dc}
Mask of the PIC2 \hypertarget{classTsunamiIO_a9237c26b42f96e5e4ad44839abdf85ce}{
\index{TsunamiIO@{TsunamiIO}!mode1@{mode1}}
\index{mode1@{mode1}!TsunamiIO@{TsunamiIO}}
\subsubsection[{mode1}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf mode1}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiIO_a9237c26b42f96e5e4ad44839abdf85ce}
Mode of PIC1. Not used for anything \hypertarget{classTsunamiIO_af51e3a81fa6352c9fbc24d5bc03d843f}{
\index{TsunamiIO@{TsunamiIO}!mode2@{mode2}}
\index{mode2@{mode2}!TsunamiIO@{TsunamiIO}}
\subsubsection[{mode2}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf mode2}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiIO_af51e3a81fa6352c9fbc24d5bc03d843f}
Mode of PIC2. Not used for anything \hypertarget{classTsunamiIO_ab72d9ca48cf8b7b897799490833c4b5e}{
\index{TsunamiIO@{TsunamiIO}!picInterrupting@{picInterrupting}}
\index{picInterrupting@{picInterrupting}!TsunamiIO@{TsunamiIO}}
\subsubsection[{picInterrupting}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf picInterrupting}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiIO_ab72d9ca48cf8b7b897799490833c4b5e}
Is the pic interrupting right now or not. \hypertarget{classTsunamiIO_a8472e2cd6c519d77f7b7ab878a42fa40}{
\index{TsunamiIO@{TsunamiIO}!picr@{picr}}
\index{picr@{picr}!TsunamiIO@{TsunamiIO}}
\subsubsection[{picr}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf picr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiIO_a8472e2cd6c519d77f7b7ab878a42fa40}
Raw PIC interrupt register before masking \hypertarget{classTsunamiIO_a0447f4b0ded66f26d3ce882c29d1125e}{
\index{TsunamiIO@{TsunamiIO}!pitimer@{pitimer}}
\index{pitimer@{pitimer}!TsunamiIO@{TsunamiIO}}
\subsubsection[{pitimer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Intel8254Timer} {\bf pitimer}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiIO_a0447f4b0ded66f26d3ce882c29d1125e}
Intel 8253 Periodic Interval Timer \hypertarget{classTsunamiIO_afa7e240c7456eaf5ef27ee8be3a23bd4}{
\index{TsunamiIO@{TsunamiIO}!rtc@{rtc}}
\index{rtc@{rtc}!TsunamiIO@{TsunamiIO}}
\subsubsection[{rtc}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RTC} {\bf rtc}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiIO_afa7e240c7456eaf5ef27ee8be3a23bd4}
\hypertarget{classTsunamiIO_a4603c0adbe60021db8e6d488b0366d75}{
\index{TsunamiIO@{TsunamiIO}!rtcAddr@{rtcAddr}}
\index{rtcAddr@{rtcAddr}!TsunamiIO@{TsunamiIO}}
\subsubsection[{rtcAddr}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf rtcAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiIO_a4603c0adbe60021db8e6d488b0366d75}
\hypertarget{classTsunamiIO_ac2f6e48e9ea7cdd01d0d4855725107d6}{
\index{TsunamiIO@{TsunamiIO}!timerData@{timerData}}
\index{timerData@{timerData}!TsunamiIO@{TsunamiIO}}
\subsubsection[{timerData}]{\setlength{\rightskip}{0pt plus 5cm}uint16\_\-t {\bf timerData}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiIO_ac2f6e48e9ea7cdd01d0d4855725107d6}
The interval is set via two writes to the PIT. This variable contains a flag as to how many writes have happened, and the time so far. \hypertarget{classTsunamiIO_aa178467f241f875a068722413f62ec20}{
\index{TsunamiIO@{TsunamiIO}!tsunami@{tsunami}}
\index{tsunami@{tsunami}!TsunamiIO@{TsunamiIO}}
\subsubsection[{tsunami}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tsunami}$\ast$ {\bf tsunami}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiIO_aa178467f241f875a068722413f62ec20}
A pointer to the \hyperlink{classTsunami}{Tsunami} device which be belong to 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/alpha/\hyperlink{tsunami__io_8hh}{tsunami\_\-io.hh}\item 
dev/alpha/\hyperlink{tsunami__io_8cc}{tsunami\_\-io.cc}\end{DoxyCompactItemize}
