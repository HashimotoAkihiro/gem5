\hypertarget{classBaseBus_1_1Layer}{
\section{クラス テンプレート Layer$<$ SrcType, DstType $>$}
\label{classBaseBus_1_1Layer}\index{BaseBus::Layer@{BaseBus::Layer}}
}


{\ttfamily \#include $<$bus.hh$>$}Layer$<$ SrcType, DstType $>$に対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classBaseBus_1_1Layer}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classBaseBus_1_1Layer_a1206f14a8687ddf9256407d185fed584}{Layer} (DstType \&\_\-port, \hyperlink{classBaseBus}{BaseBus} \&\_\-bus, const std::string \&\hyperlink{classBaseBus_1_1Layer_aaf2ed934b37cbbd236fdd1b01a5f5005}{\_\-name})
\item 
unsigned int \hyperlink{classBaseBus_1_1Layer_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)
\item 
const std::string \hyperlink{classBaseBus_1_1Layer_a6490f765a824ced1cc94979609fe7e07}{name} () const 
\item 
bool \hyperlink{classBaseBus_1_1Layer_a903a48e7e621bc5add3149fdce906bc7}{tryTiming} (SrcType $\ast$src\_\-port)
\item 
void \hyperlink{classBaseBus_1_1Layer_a63792ad682fd60a25e2896f83452e877}{succeededTiming} (\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} busy\_\-time)
\item 
void \hyperlink{classBaseBus_1_1Layer_a024ba069e31ed6c6b68dc003c9613bc2}{failedTiming} (SrcType $\ast$src\_\-port, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} busy\_\-time)
\item 
void \hyperlink{classBaseBus_1_1Layer_aa31a4364e1cce5c7aee0703fa8e289eb}{occupyLayer} (\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} until)
\item 
void \hyperlink{classBaseBus_1_1Layer_ae589ae2847102aa65e86ebc70414fea3}{retryWaiting} ()
\item 
void \hyperlink{classBaseBus_1_1Layer_a29cb5a4f98063ce6e9210eacbdb35298}{recvRetry} ()
\item 
void \hyperlink{classBaseBus_1_1Layer_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classBaseBus_1_1Layer_a5d74787dedbc4e11c1ab15bf487e61f8}{State} \{ \hyperlink{classBaseBus_1_1Layer_a5d74787dedbc4e11c1ab15bf487e61f8afd6a0e4343048b10646dd2976cc5ad18}{IDLE}, 
\hyperlink{classBaseBus_1_1Layer_a5d74787dedbc4e11c1ab15bf487e61f8aa6e504d57ec9777faa0185fbd3b93b97}{BUSY}, 
\hyperlink{classBaseBus_1_1Layer_a5d74787dedbc4e11c1ab15bf487e61f8a76d44342c42b85edbde0cae33f14c5de}{RETRY}
 \}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classBaseBus_1_1Layer_a8f18de03b5e7510ac8a47a698bd673e3}{releaseLayer} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
DstType \& \hyperlink{classBaseBus_1_1Layer_afb40502d9466732dadd57056e653d8f9}{port}
\item 
\hyperlink{classBaseBus}{BaseBus} \& \hyperlink{classBaseBus_1_1Layer_ad7d5bc8ce3d9e2ce16633178b4feb387}{bus}
\item 
std::string \hyperlink{classBaseBus_1_1Layer_aaf2ed934b37cbbd236fdd1b01a5f5005}{\_\-name}
\item 
\hyperlink{classBaseBus_1_1Layer_a5d74787dedbc4e11c1ab15bf487e61f8}{State} \hyperlink{classBaseBus_1_1Layer_a876b486d3a5241a126bd5751c5f70f79}{state}
\item 
\hyperlink{classDrainManager}{DrainManager} $\ast$ \hyperlink{classBaseBus_1_1Layer_a329b71fb934a93312ca0aacbf5a3f982}{drainManager}
\item 
\hyperlink{classstd_1_1deque}{std::deque}$<$ SrcType $\ast$ $>$ \hyperlink{classBaseBus_1_1Layer_a8db23e62d084ba779ff42aacec39065d}{waitingForLayer}
\item 
SrcType $\ast$ \hyperlink{classBaseBus_1_1Layer_a982a229cbb75d7774cb62aebcec3ee9f}{retryingPort}
\item 
SrcType $\ast$ \hyperlink{classBaseBus_1_1Layer_ab8ea7bd13cb34352f935d08c989ab5e8}{waitingForPeer}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classBaseBus_1_1Layer}{Layer},\&Layer::releaseLayer $>$ \hyperlink{classBaseBus_1_1Layer_a69eab40ac3f909ccc29d20e8dbdc022e}{releaseEvent}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBaseBus_1_1Layer_a4bdb9e419f12a845feff7f1c7923a75f}{occupancy}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classBaseBus_1_1Layer_a04353589e0e920909d3ceb8e73abb7ac}{utilization}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$typename SrcType, typename DstType$>$ class BaseBus::Layer$<$ SrcType, DstType $>$}

A bus layer is an internal bus structure with its own flow control and arbitration. Hence, a single-\/layer bus mimics a traditional off-\/chip tri-\/state bus (like PCI), where only one set of wires are shared. For on-\/chip buses, a good starting point is to have three layers, for requests, responses, and snoop responses respectively (snoop requests are instantaneous and do not need any flow control or arbitration). This case is similar to AHB and some OCP configurations.

As a further extensions beyond the three-\/layer bus, a future multi-\/layer bus has with one layer per connected slave port provides a full or partial crossbar, like AXI, OCP, PCIe etc.

The template parameter, PortClass, indicates the destination port type for the bus. The retry list holds either master ports or slave ports, depending on the direction of the layer. Thus, a request layer has a retry list containing slave ports, whereas a response layer holds master ports. 

\subsection{列挙型}
\hypertarget{classBaseBus_1_1Layer_a5d74787dedbc4e11c1ab15bf487e61f8}{
\index{BaseBus::Layer@{BaseBus::Layer}!State@{State}}
\index{State@{State}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{State}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf State}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseBus_1_1Layer_a5d74787dedbc4e11c1ab15bf487e61f8}
We declare an enum to track the state of the bus layer. The starting point is an idle state where the bus layer is waiting for a packet to arrive. Upon arrival, the bus layer transitions to the busy state, where it remains either until the packet transfer is done, or the header time is spent. Once the bus layer leaves the busy state, it can either go back to idle, if no packets have arrived while it was busy, or the bus layer goes on to retry the first port in waitingForLayer. A similar transition takes place from idle to retry if the bus layer receives a retry from one of its connected ports. The retry state lasts until the port in questions calls sendTiming and returns control to the bus layer, or goes to a busy state if the port does not immediately react to the retry by calling sendTiming. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{IDLE@{IDLE}!BaseBus::Layer@{BaseBus::Layer}}\index{BaseBus::Layer@{BaseBus::Layer}!IDLE@{IDLE}}\item[{\em 
\hypertarget{classBaseBus_1_1Layer_a5d74787dedbc4e11c1ab15bf487e61f8afd6a0e4343048b10646dd2976cc5ad18}{
IDLE}
\label{classBaseBus_1_1Layer_a5d74787dedbc4e11c1ab15bf487e61f8afd6a0e4343048b10646dd2976cc5ad18}
}]\index{BUSY@{BUSY}!BaseBus::Layer@{BaseBus::Layer}}\index{BaseBus::Layer@{BaseBus::Layer}!BUSY@{BUSY}}\item[{\em 
\hypertarget{classBaseBus_1_1Layer_a5d74787dedbc4e11c1ab15bf487e61f8aa6e504d57ec9777faa0185fbd3b93b97}{
BUSY}
\label{classBaseBus_1_1Layer_a5d74787dedbc4e11c1ab15bf487e61f8aa6e504d57ec9777faa0185fbd3b93b97}
}]\index{RETRY@{RETRY}!BaseBus::Layer@{BaseBus::Layer}}\index{BaseBus::Layer@{BaseBus::Layer}!RETRY@{RETRY}}\item[{\em 
\hypertarget{classBaseBus_1_1Layer_a5d74787dedbc4e11c1ab15bf487e61f8a76d44342c42b85edbde0cae33f14c5de}{
RETRY}
\label{classBaseBus_1_1Layer_a5d74787dedbc4e11c1ab15bf487e61f8a76d44342c42b85edbde0cae33f14c5de}
}]\end{description}
\end{Desc}



\hyperlink{classDrainable_a5d74787dedbc4e11c1ab15bf487e61f8}{Drainable}を再定義しています。


\begin{DoxyCode}
209 { IDLE, BUSY, RETRY };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classBaseBus_1_1Layer_a1206f14a8687ddf9256407d185fed584}{
\index{BaseBus::Layer@{BaseBus::Layer}!Layer@{Layer}}
\index{Layer@{Layer}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{Layer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Layer} (DstType \& {\em \_\-port}, \/  {\bf BaseBus} \& {\em \_\-bus}, \/  const std::string \& {\em \_\-name})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseBus_1_1Layer_a1206f14a8687ddf9256407d185fed584}
Create a bus layer and give it a name. The bus layer uses the bus an event manager.


\begin{DoxyParams}{引数}
\item[{\em \_\-port}]destination port the layer converges at \item[{\em \_\-bus}]the bus this layer belongs to \item[{\em \_\-name}]the layer's name \end{DoxyParams}



\begin{DoxyCode}
137                                                                :
138     port(_port), bus(_bus), _name(_name), state(IDLE), drainManager(NULL),
139     retryingPort(NULL), waitingForPeer(NULL),
140     releaseEvent(this)
141 {
142 }

\end{DoxyCode}


\subsection{関数}
\hypertarget{classBaseBus_1_1Layer_aa8a18d230dba7a674ac8a0b4f35bc36a}{
\index{BaseBus::Layer@{BaseBus::Layer}!drain@{drain}}
\index{drain@{drain}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em dm})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classBaseBus_1_1Layer_aa8a18d230dba7a674ac8a0b4f35bc36a}
Drain according to the normal semantics, so that the bus can tell the layer to drain, and pass an event to signal back when drained.


\begin{DoxyParams}{引数}
\item[{\em de}]drain event to call once drained\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
1 if busy or waiting to retry, or 0 if idle 
\end{DoxyReturn}


\hyperlink{classDrainable_a1ed42c14f2f622ea6b0df3865e89c8b4}{Drainable}を実装しています。


\begin{DoxyCode}
587 {
588     //We should check that we're not "doing" anything, and that noone is
589     //waiting. We might be idle but have someone waiting if the device we
590     //contacted for a retry didn't actually retry.
591     if (state != IDLE) {
592         DPRINTF(Drain, "Bus not drained\n");
593         drainManager = dm;
594         return 1;
595     }
596     return 0;
597 }
\end{DoxyCode}
\hypertarget{classBaseBus_1_1Layer_a024ba069e31ed6c6b68dc003c9613bc2}{
\index{BaseBus::Layer@{BaseBus::Layer}!failedTiming@{failedTiming}}
\index{failedTiming@{failedTiming}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{failedTiming}]{\setlength{\rightskip}{0pt plus 5cm}void failedTiming (SrcType $\ast$ {\em src\_\-port}, \/  {\bf Tick} {\em busy\_\-time})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseBus_1_1Layer_a024ba069e31ed6c6b68dc003c9613bc2}
Deal with a destination port not accepting a packet by potentially adding the source port to the retry list (if not already at the front) and occupying the bus layer accordingly.


\begin{DoxyParams}{引数}
\item[{\em src\_\-port}]Source port \item[{\em busy\_\-time}]\hyperlink{classTime}{Time} to spend as a result of a failed send \end{DoxyParams}



\begin{DoxyCode}
215 {
216     // ensure no one got in between and tried to send something to
217     // this port
218     assert(waitingForPeer == NULL);
219 
220     // if the source port is the current retrying one or not, we have
221     // failed in forwarding and should track that we are now waiting
222     // for the peer to send a retry
223     waitingForPeer = src_port;
224 
225     // we should have gone from idle or retry to busy in the tryTiming
226     // test
227     assert(state == BUSY);
228 
229     // occupy the bus accordingly
230     occupyLayer(busy_time);
231 }
\end{DoxyCode}
\hypertarget{classBaseBus_1_1Layer_a6490f765a824ced1cc94979609fe7e07}{
\index{BaseBus::Layer@{BaseBus::Layer}!name@{name}}
\index{name@{name}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}const std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseBus_1_1Layer_a6490f765a824ced1cc94979609fe7e07}
Get the bus layer's name 


\begin{DoxyCode}
126 { return bus.name() + _name; }
\end{DoxyCode}
\hypertarget{classBaseBus_1_1Layer_aa31a4364e1cce5c7aee0703fa8e289eb}{
\index{BaseBus::Layer@{BaseBus::Layer}!occupyLayer@{occupyLayer}}
\index{occupyLayer@{occupyLayer}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{occupyLayer}]{\setlength{\rightskip}{0pt plus 5cm}void occupyLayer ({\bf Tick} {\em until})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseBus_1_1Layer_aa31a4364e1cce5c7aee0703fa8e289eb}
Occupy the bus layer until until 


\begin{DoxyCode}
146 {
147     // ensure the state is busy at this point, as the bus should
148     // transition from idle as soon as it has decided to forward the
149     // packet to prevent any follow-on calls to sendTiming seeing an
150     // unoccupied bus
151     assert(state == BUSY);
152 
153     // until should never be 0 as express snoops never occupy the bus
154     assert(until != 0);
155     bus.schedule(releaseEvent, until);
156 
157     // account for the occupied ticks
158     occupancy += until - curTick();
159 
160     DPRINTF(BaseBus, "The bus is now busy from tick %d to %d\n",
161             curTick(), until);
162 }
\end{DoxyCode}
\hypertarget{classBaseBus_1_1Layer_a29cb5a4f98063ce6e9210eacbdb35298}{
\index{BaseBus::Layer@{BaseBus::Layer}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetry ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseBus_1_1Layer_a29cb5a4f98063ce6e9210eacbdb35298}
Handle a retry from a neighbouring module. This wraps retryWaiting by verifying that there are ports waiting before calling retryWaiting. 


\begin{DoxyCode}
295 {
296     // we should never get a retry without having failed to forward
297     // something to this port
298     assert(waitingForPeer != NULL);
299 
300     // add the port where the failed packet originated to the front of
301     // the waiting ports for the layer, this allows us to call retry
302     // on the port immediately if the bus layer is idle
303     waitingForLayer.push_front(waitingForPeer);
304 
305     // we are no longer waiting for the peer
306     waitingForPeer = NULL;
307 
308     // if the bus layer is idle, retry this port straight away, if we
309     // are busy, then simply let the port wait for its turn
310     if (state == IDLE) {
311         retryWaiting();
312     } else {
313         assert(state == BUSY);
314     }
315 }
\end{DoxyCode}
\hypertarget{classBaseBus_1_1Layer_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{BaseBus::Layer@{BaseBus::Layer}!regStats@{regStats}}
\index{regStats@{regStats}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseBus_1_1Layer_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} stats for the layer 


\begin{DoxyCode}
602 {
603     using namespace Stats;
604 
605     occupancy
606         .name(name() + ".occupancy")
607         .desc("Layer occupancy (ticks)")
608         .flags(nozero);
609 
610     utilization
611         .name(name() + ".utilization")
612         .desc("Layer utilization (%)")
613         .precision(1)
614         .flags(nozero);
615 
616     utilization = 100 * occupancy / simTicks;
617 }
\end{DoxyCode}
\hypertarget{classBaseBus_1_1Layer_a8f18de03b5e7510ac8a47a698bd673e3}{
\index{BaseBus::Layer@{BaseBus::Layer}!releaseLayer@{releaseLayer}}
\index{releaseLayer@{releaseLayer}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{releaseLayer}]{\setlength{\rightskip}{0pt plus 5cm}void releaseLayer ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classBaseBus_1_1Layer_a8f18de03b5e7510ac8a47a698bd673e3}
Release the bus layer after being occupied and return to an idle state where we proceed to send a retry to any potential waiting port, or drain if asked to do so. 


\begin{DoxyCode}
236 {
237     // releasing the bus means we should now be idle
238     assert(state == BUSY);
239     assert(!releaseEvent.scheduled());
240 
241     // update the state
242     state = IDLE;
243 
244     // bus layer is now idle, so if someone is waiting we can retry
245     if (!waitingForLayer.empty()) {
246         retryWaiting();
247     } else if (waitingForPeer == NULL && drainManager) {
248         DPRINTF(Drain, "Bus done draining, signaling drain manager\n");
249         //If we weren't able to drain before, do it now.
250         drainManager->signalDrainDone();
251         // Clear the drain event once we're done with it.
252         drainManager = NULL;
253     }
254 }
\end{DoxyCode}
\hypertarget{classBaseBus_1_1Layer_ae589ae2847102aa65e86ebc70414fea3}{
\index{BaseBus::Layer@{BaseBus::Layer}!retryWaiting@{retryWaiting}}
\index{retryWaiting@{retryWaiting}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{retryWaiting}]{\setlength{\rightskip}{0pt plus 5cm}void retryWaiting ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseBus_1_1Layer_ae589ae2847102aa65e86ebc70414fea3}
Send a retry to the port at the head of waitingForLayer. The caller must ensure that the list is not empty. 


\begin{DoxyCode}
259 {
260     // this should never be called with no one waiting
261     assert(!waitingForLayer.empty());
262 
263     // we always go to retrying from idle
264     assert(state == IDLE);
265 
266     // update the state
267     state = RETRY;
268 
269     // set the retrying port to the front of the retry list and pop it
270     // off the list
271     assert(retryingPort == NULL);
272     retryingPort = waitingForLayer.front();
273     waitingForLayer.pop_front();
274 
275     // tell the port to retry, which in some cases ends up calling the
276     // bus
277     retryingPort->sendRetry();
278 
279     // If the bus is still in the retry state, sendTiming wasn't
280     // called in zero time (e.g. the cache does this), burn a cycle
281     if (state == RETRY) {
282         // update the state to busy and reset the retrying port, we
283         // have done our bit and sent the retry
284         state = BUSY;
285         retryingPort = NULL;
286 
287         // occupy the bus layer until the next cycle ends
288         occupyLayer(bus.clockEdge(Cycles(1)));
289     }
290 }
\end{DoxyCode}
\hypertarget{classBaseBus_1_1Layer_a63792ad682fd60a25e2896f83452e877}{
\index{BaseBus::Layer@{BaseBus::Layer}!succeededTiming@{succeededTiming}}
\index{succeededTiming@{succeededTiming}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{succeededTiming}]{\setlength{\rightskip}{0pt plus 5cm}void succeededTiming ({\bf Tick} {\em busy\_\-time})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseBus_1_1Layer_a63792ad682fd60a25e2896f83452e877}
Deal with a destination port accepting a packet by potentially removing the source port from the retry list (if retrying) and occupying the bus layer accordingly.


\begin{DoxyParams}{引数}
\item[{\em busy\_\-time}]\hyperlink{classTime}{Time} to spend as a result of a successful send \end{DoxyParams}



\begin{DoxyCode}
202 {
203     // we should have gone from idle or retry to busy in the tryTiming
204     // test
205     assert(state == BUSY);
206 
207     // occupy the bus accordingly
208     occupyLayer(busy_time);
209 }
\end{DoxyCode}
\hypertarget{classBaseBus_1_1Layer_a903a48e7e621bc5add3149fdce906bc7}{
\index{BaseBus::Layer@{BaseBus::Layer}!tryTiming@{tryTiming}}
\index{tryTiming@{tryTiming}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{tryTiming}]{\setlength{\rightskip}{0pt plus 5cm}bool tryTiming (SrcType $\ast$ {\em src\_\-port})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseBus_1_1Layer_a903a48e7e621bc5add3149fdce906bc7}
Determine if the bus layer accepts a packet from a specific port. If not, the port in question is also added to the retry list. In either case the state of the layer is updated accordingly.


\begin{DoxyParams}{引数}
\item[{\em port}]Source port presenting the packet\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
True if the bus layer accepts the packet 
\end{DoxyReturn}



\begin{DoxyCode}
167 {
168     // if we are in the retry state, we will not see anything but the
169     // retrying port (or in the case of the snoop ports the snoop
170     // response port that mirrors the actual slave port) as we leave
171     // this state again in zero time if the peer does not immediately
172     // call the bus when receiving the retry
173 
174     // first we see if the layer is busy, next we check if the
175     // destination port is already engaged in a transaction waiting
176     // for a retry from the peer
177     if (state == BUSY || waitingForPeer != NULL) {
178         // the port should not be waiting already
179         assert(std::find(waitingForLayer.begin(), waitingForLayer.end(),
180                          src_port) == waitingForLayer.end());
181 
182         // put the port at the end of the retry list waiting for the
183         // layer to be freed up (and in the case of a busy peer, for
184         // that transaction to go through, and then the bus to free
185         // up)
186         waitingForLayer.push_back(src_port);
187         return false;
188     }
189 
190     // update the state to busy
191     state = BUSY;
192 
193     // reset the retrying port
194     retryingPort = NULL;
195 
196     return true;
197 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classBaseBus_1_1Layer_aaf2ed934b37cbbd236fdd1b01a5f5005}{
\index{BaseBus::Layer@{BaseBus::Layer}!\_\-name@{\_\-name}}
\index{\_\-name@{\_\-name}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{\_\-name}]{\setlength{\rightskip}{0pt plus 5cm}std::string {\bf \_\-name}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseBus_1_1Layer_aaf2ed934b37cbbd236fdd1b01a5f5005}
A name for this layer. \hypertarget{classBaseBus_1_1Layer_ad7d5bc8ce3d9e2ce16633178b4feb387}{
\index{BaseBus::Layer@{BaseBus::Layer}!bus@{bus}}
\index{bus@{bus}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{bus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseBus}\& {\bf bus}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseBus_1_1Layer_ad7d5bc8ce3d9e2ce16633178b4feb387}
The bus this layer is a part of. \hypertarget{classBaseBus_1_1Layer_a329b71fb934a93312ca0aacbf5a3f982}{
\index{BaseBus::Layer@{BaseBus::Layer}!drainManager@{drainManager}}
\index{drainManager@{drainManager}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{drainManager}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DrainManager}$\ast$ {\bf drainManager}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseBus_1_1Layer_a329b71fb934a93312ca0aacbf5a3f982}
manager to signal when drained \hypertarget{classBaseBus_1_1Layer_a4bdb9e419f12a845feff7f1c7923a75f}{
\index{BaseBus::Layer@{BaseBus::Layer}!occupancy@{occupancy}}
\index{occupancy@{occupancy}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{occupancy}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf occupancy}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseBus_1_1Layer_a4bdb9e419f12a845feff7f1c7923a75f}
\hyperlink{namespaceStats}{Stats} for occupancy and utilization. These stats capture the time the bus spends in the busy state and are thus only relevant when the memory system is in timing mode. \hypertarget{classBaseBus_1_1Layer_afb40502d9466732dadd57056e653d8f9}{
\index{BaseBus::Layer@{BaseBus::Layer}!port@{port}}
\index{port@{port}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{port}]{\setlength{\rightskip}{0pt plus 5cm}DstType\& {\bf port}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseBus_1_1Layer_afb40502d9466732dadd57056e653d8f9}
The destination port this layer converges at. \hypertarget{classBaseBus_1_1Layer_a69eab40ac3f909ccc29d20e8dbdc022e}{
\index{BaseBus::Layer@{BaseBus::Layer}!releaseEvent@{releaseEvent}}
\index{releaseEvent@{releaseEvent}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{releaseEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf Layer}, \&Layer::releaseLayer$>$ {\bf releaseEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseBus_1_1Layer_a69eab40ac3f909ccc29d20e8dbdc022e}
event used to schedule a release of the layer \hypertarget{classBaseBus_1_1Layer_a982a229cbb75d7774cb62aebcec3ee9f}{
\index{BaseBus::Layer@{BaseBus::Layer}!retryingPort@{retryingPort}}
\index{retryingPort@{retryingPort}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{retryingPort}]{\setlength{\rightskip}{0pt plus 5cm}SrcType$\ast$ {\bf retryingPort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseBus_1_1Layer_a982a229cbb75d7774cb62aebcec3ee9f}
\hyperlink{classPort}{Port} that we are currently in the process of telling to retry a previously failed attempt to perform a timing transaction. This is a valid port when in the retry state, and NULL when in busy or idle. \hypertarget{classBaseBus_1_1Layer_a876b486d3a5241a126bd5751c5f70f79}{
\index{BaseBus::Layer@{BaseBus::Layer}!state@{state}}
\index{state@{state}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{state}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} {\bf state}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseBus_1_1Layer_a876b486d3a5241a126bd5751c5f70f79}
track the state of the bus layer \hypertarget{classBaseBus_1_1Layer_a04353589e0e920909d3ceb8e73abb7ac}{
\index{BaseBus::Layer@{BaseBus::Layer}!utilization@{utilization}}
\index{utilization@{utilization}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{utilization}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf utilization}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseBus_1_1Layer_a04353589e0e920909d3ceb8e73abb7ac}
\hypertarget{classBaseBus_1_1Layer_a8db23e62d084ba779ff42aacec39065d}{
\index{BaseBus::Layer@{BaseBus::Layer}!waitingForLayer@{waitingForLayer}}
\index{waitingForLayer@{waitingForLayer}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{waitingForLayer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::deque}$<$SrcType$\ast$$>$ {\bf waitingForLayer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseBus_1_1Layer_a8db23e62d084ba779ff42aacec39065d}
A deque of ports that retry should be called on because the original send was delayed due to a busy layer. \hypertarget{classBaseBus_1_1Layer_ab8ea7bd13cb34352f935d08c989ab5e8}{
\index{BaseBus::Layer@{BaseBus::Layer}!waitingForPeer@{waitingForPeer}}
\index{waitingForPeer@{waitingForPeer}!BaseBus::Layer@{BaseBus::Layer}}
\subsubsection[{waitingForPeer}]{\setlength{\rightskip}{0pt plus 5cm}SrcType$\ast$ {\bf waitingForPeer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseBus_1_1Layer_ab8ea7bd13cb34352f935d08c989ab5e8}
Track who is waiting for the retry when receiving it from a peer. If no port is waiting NULL is stored. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{bus_8hh}{bus.hh}\item 
mem/\hyperlink{bus_8cc}{bus.cc}\end{DoxyCompactItemize}
