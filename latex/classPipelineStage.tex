\hypertarget{classPipelineStage}{
\section{クラス PipelineStage}
\label{classPipelineStage}\index{PipelineStage@{PipelineStage}}
}


{\ttfamily \#include $<$pipeline\_\-stage.hh$>$}PipelineStageに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classPipelineStage}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structPipelineStage_1_1Stalls}{Stalls}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classPipelineStage_add44b42ba3608b213fc0986c4aee6018}{StageStatus} \{ \hyperlink{classPipelineStage_add44b42ba3608b213fc0986c4aee6018a26bd8444261cc58df7a86753c79d2520}{Active}, 
\hyperlink{classPipelineStage_add44b42ba3608b213fc0986c4aee6018a969c924a722daf6334fca64346092ae6}{Inactive}
 \}
\item 
enum \hyperlink{classPipelineStage_ae2739961013a00cede621d4d72f2173c}{ThreadStatus} \{ \par
\hyperlink{classPipelineStage_ae2739961013a00cede621d4d72f2173ca2f5f2c4a8c4f4f0519d503dcdfbf55cb}{Running}, 
\hyperlink{classPipelineStage_ae2739961013a00cede621d4d72f2173cad3fa9ae9431d6cb1772f9d9df48cab19}{Idle}, 
\hyperlink{classPipelineStage_ae2739961013a00cede621d4d72f2173ca19a48e232b72697e4bb7ea1b6075ed49}{StartSquash}, 
\hyperlink{classPipelineStage_ae2739961013a00cede621d4d72f2173ca22a648855197e326dc88f548634c0ec7}{Squashing}, 
\par
\hyperlink{classPipelineStage_ae2739961013a00cede621d4d72f2173ca9463ee9b8700258a1019b4b9d2d77a30}{Blocked}, 
\hyperlink{classPipelineStage_ae2739961013a00cede621d4d72f2173caf2a3acf850890cb1651bc41dcbacb7e0}{Unblocking}, 
\hyperlink{classPipelineStage_ae2739961013a00cede621d4d72f2173ca84d11a0919e33ccd274f5f0f82006fa6}{MemWaitResponse}, 
\hyperlink{classPipelineStage_ae2739961013a00cede621d4d72f2173caf98795b778c51c0111a0d4982b178200}{MemWaitRetry}, 
\par
\hyperlink{classPipelineStage_ae2739961013a00cede621d4d72f2173ca1883fc473d33feb95a8ea53164e91d0e}{MemAccessComplete}
 \}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classPipelineStage_a30721921ff32a2c7bc0e01c472c8c935}{PipelineStage} (\hyperlink{classPipelineStage_aa14874985381292db0aea05d1c8a122c}{Params} $\ast$params, unsigned stage\_\-num)
\item 
virtual \hyperlink{classPipelineStage_a5045b86dad0c4a626861dc2aa1c59180}{$\sim$PipelineStage} ()
\item 
void \hyperlink{classPipelineStage_a66db401ca5ea7de9fe7ca057d5eeb53c}{init} (\hyperlink{classPipelineStage_aa14874985381292db0aea05d1c8a122c}{Params} $\ast$params)
\item 
std::string \hyperlink{classPipelineStage_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classPipelineStage_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classPipelineStage_a6fd0f914e19bcfb6d9f28e537ad956d5}{setCPU} (\hyperlink{classInOrderCPU}{InOrderCPU} $\ast$cpu\_\-ptr)
\item 
void \hyperlink{classPipelineStage_a2b521ea5f191fff72265f60d4ed5187b}{setTimeBuffer} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$ $\ast$tb\_\-ptr)
\item 
void \hyperlink{classPipelineStage_aff9a9995beb69e92bbcf40c780c17b93}{setPrevStageQueue} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structInterStageStruct}{InterStageStruct} $>$ $\ast$prev\_\-stage\_\-ptr)
\item 
void \hyperlink{classPipelineStage_ace33f1daf903e9438330807405092e20}{setNextStageQueue} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structInterStageStruct}{InterStageStruct} $>$ $\ast$next\_\-stage\_\-ptr)
\item 
void \hyperlink{classPipelineStage_aab96bdacf8bd420402cbb543f994e054}{setActiveThreads} (\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$at\_\-ptr)
\item 
bool \hyperlink{classPipelineStage_ab6e550d3e889847f642fa2205c6e12fd}{nextStageQueueValid} (int stage\_\-num)
\item 
bool \hyperlink{classPipelineStage_ab8e0f4a73d5a3ab9fe269f3c36d97e4f}{isBlocked} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classPipelineStage_a05f299b443f8cc73a93d61572edc0218}{switchOut} ()
\item 
virtual void \hyperlink{classPipelineStage_a8674059ce345e23aac5086b2c3e24a43}{takeOverFrom} ()
\item 
void \hyperlink{classPipelineStage_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\item 
void \hyperlink{classPipelineStage_af11246f186567b60383a2ff1d4bcf27c}{setResStall} (\hyperlink{classResourceRequest}{ResReqPtr} res\_\-req, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classPipelineStage_a71090c4bc5fc055eb0ea621cb65fddc8}{unsetResStall} (\hyperlink{classResourceRequest}{ResReqPtr} res\_\-req, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classPipelineStage_af5bd22ce78c3a8bafb5b91b7b70e8a41}{removeStalls} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
int \hyperlink{classPipelineStage_a4623e7080104807616729bb5504b76ce}{stageBufferAvail} ()
\item 
void \hyperlink{classPipelineStage_a687aa4600423bb30ecf3bb1da6cd6000}{activateThread} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classPipelineStage_a9c19142b0bc2ce7b7a6593a5190cebc7}{setupSquash} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
virtual void \hyperlink{classPipelineStage_a960b60a46045a5363df0c263f0f43902}{squashDueToMemStall} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} seq\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
virtual void \hyperlink{classPipelineStage_aee9dc23de90acd20200641407a3bd1da}{squash} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} squash\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classPipelineStage_adbce9d3c16239dca0ffd19bc176ea258}{squashPrevStageInsts} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} squash\_\-seq\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classPipelineStage_a80587b4fe043bbe1995536cb3b361588}{dumpInsts} ()
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classPipelineStage_a728ac6e701ecba86ee9e8d15ae07d53f}{fromNextStages}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classPipelineStage_ad270a1de154f2e748a16880469c9baea}{toPrevStages}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structInterStageStruct}{InterStageStruct} $>$ $\ast$ \hyperlink{classPipelineStage_af54931163e4bdb38a1295065af735582}{prevStageQueue}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structInterStageStruct}{InterStageStruct} $>$::wire \hyperlink{classPipelineStage_a560e9ae4ad5991a1789e95d33f59503b}{prevStage}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structInterStageStruct}{InterStageStruct} $>$ $\ast$ \hyperlink{classPipelineStage_aa6321826776981dc0e21fbdeefe52016}{nextStageQueue}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structInterStageStruct}{InterStageStruct} $>$::wire \hyperlink{classPipelineStage_a7a06bbc61668c11d11fde945df559f55}{nextStage}
\item 
bool \hyperlink{classPipelineStage_abb343738ea92390af4fbc30bc718d1bc}{prevStageValid}
\item 
bool \hyperlink{classPipelineStage_a74cfb32df253cbcbf5d70e6523492d2d}{nextStageValid}
\item 
bool \hyperlink{classPipelineStage_a97808a9870039f4168da10ecfb5dc472}{idle}
\item 
\hyperlink{structPipelineStage_1_1Stalls}{Stalls} \hyperlink{classPipelineStage_aa7522ea079359a7730812c7091dbb4a5}{stalls} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classPipelineStage_a42e0f4c18fdb8ef7504f5c45d697fb14}{idleCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classPipelineStage_af9addd340a133c2f4add363a3055b019}{runCycles}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classPipelineStage_a04353589e0e920909d3ceb8e73abb7ac}{utilization}
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{namespaceThePipeline_ab62ca16eeca26566ad2422b5df4943ce}{ThePipeline::Params} \hyperlink{classPipelineStage_aa14874985381292db0aea05d1c8a122c}{Params}
\item 
typedef \hyperlink{classRefCountingPtr}{ThePipeline::DynInstPtr} \hyperlink{classPipelineStage_af9d0c8a46736ba6aa2d8bb94da1a5e73}{DynInstPtr}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classPipelineStage_a0782fca2c80ef367ee914d464584ab20}{processStage} (bool \&status\_\-change)
\item 
void \hyperlink{classPipelineStage_a3e391d45d3f6411be62510f3b23105c9}{processThread} (bool \&status\_\-change, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
virtual void \hyperlink{classPipelineStage_a4120d7c6b83eb82877f4d21109c105ba}{processInsts} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classPipelineStage_ac8bd857e45d0b201ea328b6ea8bcb890}{processInstSchedule} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, int \&reqs\_\-processed)
\item 
bool \hyperlink{classPipelineStage_a4666632f247a5d92380cb32d6e286c75}{canSendInstToStage} (unsigned stage\_\-num)
\item 
bool \hyperlink{classPipelineStage_a3a5710b990e95498611464d54c90dcf1}{sendInstToNextStage} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
int \hyperlink{classPipelineStage_a112431820c072831aa16794d42dc25e4}{skidSize} ()
\item 
bool \hyperlink{classPipelineStage_afe3e2673d17dd5c568862ef5ae68b4d8}{skidsEmpty} ()
\item 
void \hyperlink{classPipelineStage_a4bb9486757ce225941aaaf759b357a57}{updateStatus} ()
\item 
void \hyperlink{classPipelineStage_a9ff2aa32ab0f40674cb3518108d62f8e}{sortInsts} ()
\item 
void \hyperlink{classPipelineStage_ad65c9f053a6038ac8c34c34bfe9a88c3}{readStallSignals} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classPipelineStage_af77f2bf38a75182c65e633b9fdf295d2}{checkSignalsAndUpdate} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classPipelineStage_a6ba4f2f95d991f5be818dabf7500feed}{checkStall} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid) const 
\item 
bool \hyperlink{classPipelineStage_ab03996f3423928a0e84dc3df7fd493f2}{prevStageInstsValid} ()
\item 
bool \hyperlink{classPipelineStage_ad1993925abd15d3fb59fde2ccfa3d678}{block} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classPipelineStage_aee83987cebca092f91d7328291e7d40f}{blockDueToBuffer} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classPipelineStage_a9cc3b95f6969935f78c0158aa5145021}{unblock} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
unsigned \hyperlink{classPipelineStage_afc0a9a26d747553fd1fd8e698a8e7029}{stageNum}
\item 
unsigned \hyperlink{classPipelineStage_a51d98139f56a84585e4cb68e3cd67a1c}{stageWidth}
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classPipelineStage_a88377f855dbf5adeeecb06b5bb821d35}{numThreads}
\item 
\hyperlink{classPipelineStage_add44b42ba3608b213fc0986c4aee6018}{StageStatus} \hyperlink{classPipelineStage_a4530a0391410036c939865008a53f356}{\_\-status}
\item 
\hyperlink{classPipelineStage_ae2739961013a00cede621d4d72f2173c}{ThreadStatus} \hyperlink{classPipelineStage_af95a0e3fe4e1c0a168cc3c74869a4816}{stageStatus} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
\hyperlink{classInOrderCPU}{InOrderCPU} $\ast$ \hyperlink{classPipelineStage_a41d682c28d0f49e04393c52815808782}{cpu}
\item 
\hyperlink{classTrace_1_1InOrderTrace}{Trace::InOrderTrace} $\ast$ \hyperlink{classPipelineStage_af3ad9be2b464186b902b5ca568b6d439}{tracer}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$ \hyperlink{classPipelineStage_af6eaea53db532812052f71bf0380dab5}{activeThreads}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classRefCountingPtr}{DynInstPtr} $>$ \hyperlink{classPipelineStage_a693e4a546dfc51b4e402fe75e73e812e}{switchedOutBuffer}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ bool $>$ \hyperlink{classPipelineStage_a09a91d6926260c8037374f0b646a62ee}{switchedOutValid}
\item 
unsigned \hyperlink{classPipelineStage_a4ac908fc89a76ee30c0af235353b6c2f}{instsProcessed}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classRefCountingPtr}{DynInstPtr} $>$ \hyperlink{classPipelineStage_ad02ffed1611064a60befad18c5d428ef}{skidBuffer} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
\hyperlink{classRefCountingPtr}{DynInstPtr} \hyperlink{classPipelineStage_a09dc4a08ace7d6e74531ffff1ba5d905}{dummyBufferInst}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classPipelineStage_ab949b1ea7ed96a92d473eeaa17348bed}{bdelayDoneSeqNum} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
bool \hyperlink{classPipelineStage_ac364a786221f4a1741023dc82bc834f9}{squashAfterDelaySlot} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
\hyperlink{classRefCountingPtr}{DynInstPtr} \hyperlink{classPipelineStage_a2313a835690e0d98e53b1aa69754bb1f}{squashInst} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
unsigned \hyperlink{classPipelineStage_a8b3bf50b9e561c023857979eaf326bee}{stageBufferMax}
\item 
bool \hyperlink{classPipelineStage_a2c7e870d4babdac0dc91fc7ffabd0f3d}{wroteToTimeBuffer}
\item 
unsigned \hyperlink{classPipelineStage_ab6a826f43ca871b277e724aa148d1816}{toNextStageIndex}
\item 
int \hyperlink{classPipelineStage_ac171ebbc339fe3c1b91878034586b7a5}{lastStallingStage} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$ $\ast$ \hyperlink{classPipelineStage_a83f9ee976e732665aeb08dbc19acfd45}{timeBuffer}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classPipelineStage_af9d0c8a46736ba6aa2d8bb94da1a5e73}{
\index{PipelineStage@{PipelineStage}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!PipelineStage@{PipelineStage}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf ThePipeline::DynInstPtr} {\bf DynInstPtr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_af9d0c8a46736ba6aa2d8bb94da1a5e73}
\hypertarget{classPipelineStage_aa14874985381292db0aea05d1c8a122c}{
\index{PipelineStage@{PipelineStage}!Params@{Params}}
\index{Params@{Params}!PipelineStage@{PipelineStage}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf ThePipeline::Params} {\bf Params}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_aa14874985381292db0aea05d1c8a122c}


\subsection{列挙型}
\hypertarget{classPipelineStage_add44b42ba3608b213fc0986c4aee6018}{
\index{PipelineStage@{PipelineStage}!StageStatus@{StageStatus}}
\index{StageStatus@{StageStatus}!PipelineStage@{PipelineStage}}
\subsubsection[{StageStatus}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf StageStatus}}}
\label{classPipelineStage_add44b42ba3608b213fc0986c4aee6018}
Overall stage status. Used to determine if the CPU can deschedule itself due to a lack of activity. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Active@{Active}!PipelineStage@{PipelineStage}}\index{PipelineStage@{PipelineStage}!Active@{Active}}\item[{\em 
\hypertarget{classPipelineStage_add44b42ba3608b213fc0986c4aee6018a26bd8444261cc58df7a86753c79d2520}{
Active}
\label{classPipelineStage_add44b42ba3608b213fc0986c4aee6018a26bd8444261cc58df7a86753c79d2520}
}]\index{Inactive@{Inactive}!PipelineStage@{PipelineStage}}\index{PipelineStage@{PipelineStage}!Inactive@{Inactive}}\item[{\em 
\hypertarget{classPipelineStage_add44b42ba3608b213fc0986c4aee6018a969c924a722daf6334fca64346092ae6}{
Inactive}
\label{classPipelineStage_add44b42ba3608b213fc0986c4aee6018a969c924a722daf6334fca64346092ae6}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
57                      {
58         Active,
59         Inactive
60     };
\end{DoxyCode}
\hypertarget{classPipelineStage_ae2739961013a00cede621d4d72f2173c}{
\index{PipelineStage@{PipelineStage}!ThreadStatus@{ThreadStatus}}
\index{ThreadStatus@{ThreadStatus}!PipelineStage@{PipelineStage}}
\subsubsection[{ThreadStatus}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ThreadStatus}}}
\label{classPipelineStage_ae2739961013a00cede621d4d72f2173c}
Individual thread status. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Running@{Running}!PipelineStage@{PipelineStage}}\index{PipelineStage@{PipelineStage}!Running@{Running}}\item[{\em 
\hypertarget{classPipelineStage_ae2739961013a00cede621d4d72f2173ca2f5f2c4a8c4f4f0519d503dcdfbf55cb}{
Running}
\label{classPipelineStage_ae2739961013a00cede621d4d72f2173ca2f5f2c4a8c4f4f0519d503dcdfbf55cb}
}]\index{Idle@{Idle}!PipelineStage@{PipelineStage}}\index{PipelineStage@{PipelineStage}!Idle@{Idle}}\item[{\em 
\hypertarget{classPipelineStage_ae2739961013a00cede621d4d72f2173cad3fa9ae9431d6cb1772f9d9df48cab19}{
Idle}
\label{classPipelineStage_ae2739961013a00cede621d4d72f2173cad3fa9ae9431d6cb1772f9d9df48cab19}
}]\index{StartSquash@{StartSquash}!PipelineStage@{PipelineStage}}\index{PipelineStage@{PipelineStage}!StartSquash@{StartSquash}}\item[{\em 
\hypertarget{classPipelineStage_ae2739961013a00cede621d4d72f2173ca19a48e232b72697e4bb7ea1b6075ed49}{
StartSquash}
\label{classPipelineStage_ae2739961013a00cede621d4d72f2173ca19a48e232b72697e4bb7ea1b6075ed49}
}]\index{Squashing@{Squashing}!PipelineStage@{PipelineStage}}\index{PipelineStage@{PipelineStage}!Squashing@{Squashing}}\item[{\em 
\hypertarget{classPipelineStage_ae2739961013a00cede621d4d72f2173ca22a648855197e326dc88f548634c0ec7}{
Squashing}
\label{classPipelineStage_ae2739961013a00cede621d4d72f2173ca22a648855197e326dc88f548634c0ec7}
}]\index{Blocked@{Blocked}!PipelineStage@{PipelineStage}}\index{PipelineStage@{PipelineStage}!Blocked@{Blocked}}\item[{\em 
\hypertarget{classPipelineStage_ae2739961013a00cede621d4d72f2173ca9463ee9b8700258a1019b4b9d2d77a30}{
Blocked}
\label{classPipelineStage_ae2739961013a00cede621d4d72f2173ca9463ee9b8700258a1019b4b9d2d77a30}
}]\index{Unblocking@{Unblocking}!PipelineStage@{PipelineStage}}\index{PipelineStage@{PipelineStage}!Unblocking@{Unblocking}}\item[{\em 
\hypertarget{classPipelineStage_ae2739961013a00cede621d4d72f2173caf2a3acf850890cb1651bc41dcbacb7e0}{
Unblocking}
\label{classPipelineStage_ae2739961013a00cede621d4d72f2173caf2a3acf850890cb1651bc41dcbacb7e0}
}]\index{MemWaitResponse@{MemWaitResponse}!PipelineStage@{PipelineStage}}\index{PipelineStage@{PipelineStage}!MemWaitResponse@{MemWaitResponse}}\item[{\em 
\hypertarget{classPipelineStage_ae2739961013a00cede621d4d72f2173ca84d11a0919e33ccd274f5f0f82006fa6}{
MemWaitResponse}
\label{classPipelineStage_ae2739961013a00cede621d4d72f2173ca84d11a0919e33ccd274f5f0f82006fa6}
}]\index{MemWaitRetry@{MemWaitRetry}!PipelineStage@{PipelineStage}}\index{PipelineStage@{PipelineStage}!MemWaitRetry@{MemWaitRetry}}\item[{\em 
\hypertarget{classPipelineStage_ae2739961013a00cede621d4d72f2173caf98795b778c51c0111a0d4982b178200}{
MemWaitRetry}
\label{classPipelineStage_ae2739961013a00cede621d4d72f2173caf98795b778c51c0111a0d4982b178200}
}]\index{MemAccessComplete@{MemAccessComplete}!PipelineStage@{PipelineStage}}\index{PipelineStage@{PipelineStage}!MemAccessComplete@{MemAccessComplete}}\item[{\em 
\hypertarget{classPipelineStage_ae2739961013a00cede621d4d72f2173ca1883fc473d33feb95a8ea53164e91d0e}{
MemAccessComplete}
\label{classPipelineStage_ae2739961013a00cede621d4d72f2173ca1883fc473d33feb95a8ea53164e91d0e}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
63                       {
64         Running,
65         Idle,
66         StartSquash,
67         Squashing,
68         Blocked,
69         Unblocking,
70         MemWaitResponse,
71         MemWaitRetry,
72         MemAccessComplete
73     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classPipelineStage_a30721921ff32a2c7bc0e01c472c8c935}{
\index{PipelineStage@{PipelineStage}!PipelineStage@{PipelineStage}}
\index{PipelineStage@{PipelineStage}!PipelineStage@{PipelineStage}}
\subsubsection[{PipelineStage}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PipelineStage} ({\bf Params} $\ast$ {\em params}, \/  unsigned {\em stage\_\-num})}}
\label{classPipelineStage_a30721921ff32a2c7bc0e01c472c8c935}



\begin{DoxyCode}
47     : stageNum(stage_num), stageWidth(params->stageWidth),
48       numThreads(ThePipeline::MaxThreads), _status(Inactive),
49       stageBufferMax(params->stageWidth),
50       prevStageValid(false), nextStageValid(false), idle(false)
51 {
52     init(params);
53 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a5045b86dad0c4a626861dc2aa1c59180}{
\index{PipelineStage@{PipelineStage}!$\sim$PipelineStage@{$\sim$PipelineStage}}
\index{$\sim$PipelineStage@{$\sim$PipelineStage}!PipelineStage@{PipelineStage}}
\subsubsection[{$\sim$PipelineStage}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf PipelineStage} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPipelineStage_a5045b86dad0c4a626861dc2aa1c59180}



\begin{DoxyCode}
56 {
57    for(ThreadID tid = 0; tid < numThreads; tid++) {
58        skidBuffer[tid].clear();
59        stalls[tid].resources.clear();
60    }
61 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classPipelineStage_a687aa4600423bb30ecf3bb1da6cd6000}{
\index{PipelineStage@{PipelineStage}!activateThread@{activateThread}}
\index{activateThread@{activateThread}!PipelineStage@{PipelineStage}}
\subsubsection[{activateThread}]{\setlength{\rightskip}{0pt plus 5cm}void activateThread ({\bf ThreadID} {\em tid})}}
\label{classPipelineStage_a687aa4600423bb30ecf3bb1da6cd6000}



\begin{DoxyCode}
540 {    
541     if (cpu->threadModel == InOrderCPU::SwitchOnCacheMiss) {
542         if (!switchedOutValid[tid]) {
543             DPRINTF(InOrderStage, "[tid:%i] No instruction available in "
544                     "switch out buffer.\n", tid);        
545         } else {
546             DynInstPtr inst = switchedOutBuffer[tid];
547 
548             DPRINTF(InOrderStage,"[tid:%i]: Re-Inserting [sn:%lli] PC:%s into"
549                     " stage skidBuffer %i\n", tid, inst->seqNum,
550                     inst->pcState(), inst->threadNumber);
551 
552             // Make instruction available for pipeline processing
553             skidBuffer[tid].push_back(inst);
554 
555             // Update PC so that we start fetching after this instruction to
556             // prevent "double"-execution of instructions
557             cpu->resPool->scheduleEvent((InOrderCPU::CPUEventType)
558                                         ResourcePool::UpdateAfterContextSwitch, 
559                                         inst, Cycles(0), 0, tid);
560 
561             // Clear switchout buffer
562             switchedOutBuffer[tid] = NULL;
563             switchedOutValid[tid] = false;            
564 
565             // Update any CPU stats based off context switches
566             cpu->updateContextSwitchStats();            
567         }        
568     }
569     
570 }
\end{DoxyCode}
\hypertarget{classPipelineStage_ad1993925abd15d3fb59fde2ccfa3d678}{
\index{PipelineStage@{PipelineStage}!block@{block}}
\index{block@{block}!PipelineStage@{PipelineStage}}
\subsubsection[{block}]{\setlength{\rightskip}{0pt plus 5cm}bool block ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_ad1993925abd15d3fb59fde2ccfa3d678}
Switches stage to blocking, and signals back that stage has become blocked. \begin{DoxyReturn}{戻り値}
Returns true if there is a status change. 
\end{DoxyReturn}



\begin{DoxyCode}
286 {
287     DPRINTF(InOrderStage, "[tid:%d]: Blocking, sending block signal back to "
288             "previous stages.\n", tid);
289 
290     // If the stage status is blocked or unblocking then stage has not yet
291     // signalled fetch to unblock. In that case, there is no need to tell
292     // fetch to block.
293     if (stageStatus[tid] != Blocked) {
294         if (stageStatus[tid] != Unblocking) {
295             wroteToTimeBuffer = true;
296         }
297 
298         stageStatus[tid] = Blocked;
299 
300         if (prevStageValid) {
301             DPRINTF(InOrderStage, "[tid:%d]: Stage %i setting block signal.\n",
302                     tid, stageNum);
303             toPrevStages->stageBlock[stageNum][tid] = true;
304         }
305 
306         return true;
307     }
308 
309 
310     return false;
311 }
\end{DoxyCode}
\hypertarget{classPipelineStage_aee83987cebca092f91d7328291e7d40f}{
\index{PipelineStage@{PipelineStage}!blockDueToBuffer@{blockDueToBuffer}}
\index{blockDueToBuffer@{blockDueToBuffer}!PipelineStage@{PipelineStage}}
\subsubsection[{blockDueToBuffer}]{\setlength{\rightskip}{0pt plus 5cm}void blockDueToBuffer ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_aee83987cebca092f91d7328291e7d40f}



\begin{DoxyCode}
315 {
316     DPRINTF(InOrderStage, "[tid:%d]: Blocking instructions from passing to "
317             "next stage.\n", tid);
318 
319     if (stageStatus[tid] != Blocked) {
320         if (stageStatus[tid] != Unblocking) {
321             wroteToTimeBuffer = true;
322         }
323 
324         // Set the status to Blocked.
325         stageStatus[tid] = Blocked;
326     }
327 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a4666632f247a5d92380cb32d6e286c75}{
\index{PipelineStage@{PipelineStage}!canSendInstToStage@{canSendInstToStage}}
\index{canSendInstToStage@{canSendInstToStage}!PipelineStage@{PipelineStage}}
\subsubsection[{canSendInstToStage}]{\setlength{\rightskip}{0pt plus 5cm}bool canSendInstToStage (unsigned {\em stage\_\-num})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a4666632f247a5d92380cb32d6e286c75}
Is there room in the next stage buffer for this instruction? 


\begin{DoxyCode}
458 {
459     bool buffer_avail = false;
460 
461     if (cpu->pipelineStage[stage_num]->prevStageValid) {
462         buffer_avail = cpu->pipelineStage[stage_num]->stageBufferAvail() -
463             cpu->pipelineStage[stage_num-1]->nextStage->insts.size() >= 1;
464     }
465 
466     if (!buffer_avail && nextStageQueueValid(stage_num)) {
467         DPRINTF(InOrderStall, "STALL: No room in stage %i buffer.\n", 
468                 stageNum + 1);
469     }
470 
471     return buffer_avail;
472 }
\end{DoxyCode}
\hypertarget{classPipelineStage_af77f2bf38a75182c65e633b9fdf295d2}{
\index{PipelineStage@{PipelineStage}!checkSignalsAndUpdate@{checkSignalsAndUpdate}}
\index{checkSignalsAndUpdate@{checkSignalsAndUpdate}!PipelineStage@{PipelineStage}}
\subsubsection[{checkSignalsAndUpdate}]{\setlength{\rightskip}{0pt plus 5cm}bool checkSignalsAndUpdate ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_af77f2bf38a75182c65e633b9fdf295d2}
Checks all input signals and updates stage's status appropriately. 


\begin{DoxyCode}
661 {
662     // Check if there's a squash signal, squash if there is.
663     // Check stall signals, block if necessary.
664     // If status was blocked
665     //     Check if stall conditions have passed
666     //         if so then go to unblocking
667     // If status was Squashing
668     //     check if squashing is not high.  Switch to running this cycle.
669 
670     // Update the per thread stall statuses.
671     readStallSignals(tid);
672 
673     // Check for squash from later pipeline stages
674     for (int stage_idx=stageNum; stage_idx < NumStages; stage_idx++) {
675         if (fromNextStages->stageInfo[stage_idx][tid].squash) {
676             DPRINTF(InOrderStage, "[tid:%u]: Squashing instructions due to "
677                     "squash from stage %u.\n", tid, stage_idx);
678             InstSeqNum squash_seq_num = fromNextStages->
679                 stageInfo[stage_idx][tid].doneSeqNum;
680             squash(squash_seq_num, tid);
681             break; //return true;
682         }
683     }
684 
685     if (checkStall(tid)) {
686         return block(tid);
687     }
688 
689     if (stageStatus[tid] == Blocked) {
690         DPRINTF(InOrderStage, "[tid:%u]: Done blocking, switching to "
691                 "unblocking.\n", tid);
692 
693         stageStatus[tid] = Unblocking;
694 
695         unblock(tid);
696 
697         return true;
698     }
699 
700     if (stageStatus[tid] == Squashing) {
701         if (!skidBuffer[tid].empty()) {
702             DPRINTF(InOrderStage, "[tid:%u]: Done squashing, switching to "
703                     "unblocking.\n", tid);
704 
705             stageStatus[tid] = Unblocking;
706         } else {
707             // Switch status to running if stage isn't being told to block or
708             // squash this cycle.
709             DPRINTF(InOrderStage, "[tid:%u]: Done squashing, switching to "
710                     "running.\n", tid);
711 
712             stageStatus[tid] = Running;
713         }
714 
715         return true;
716     }
717 
718     // If we've reached this point, we have not gotten any signals that
719     // cause stage to change its status.  Stage remains the same as before.*/
720     return false;
721 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a6ba4f2f95d991f5be818dabf7500feed}{
\index{PipelineStage@{PipelineStage}!checkStall@{checkStall}}
\index{checkStall@{checkStall}!PipelineStage@{PipelineStage}}
\subsubsection[{checkStall}]{\setlength{\rightskip}{0pt plus 5cm}bool checkStall ({\bf ThreadID} {\em tid}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a6ba4f2f95d991f5be818dabf7500feed}
Checks all stall signals, and returns if any are true. 


\begin{DoxyCode}
219 {
220     bool ret_val = false;
221 
222     // Only check pipeline stall from stage directly following this stage
223     if (nextStageValid && stalls[tid].stage[stageNum + 1]) {
224         DPRINTF(InOrderStage,"[tid:%i]: Stall fom Stage %i detected.\n",
225                 tid, stageNum + 1);
226         ret_val = true;
227     }
228 
229     if (!stalls[tid].resources.empty()) {
230 #if TRACING_ON
231         string stall_src;
232 
233         for (int i=0; i < stalls[tid].resources.size(); i++) {
234             stall_src += stalls[tid].resources[i]->res->name() + ":";
235         }
236 
237         DPRINTF(InOrderStage,"[tid:%i]: Stall fom resources (%s) detected.\n",
238                 tid, stall_src);
239 #endif
240         ret_val = true;
241     }
242 
243     return ret_val;
244 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a80587b4fe043bbe1995536cb3b361588}{
\index{PipelineStage@{PipelineStage}!dumpInsts@{dumpInsts}}
\index{dumpInsts@{dumpInsts}!PipelineStage@{PipelineStage}}
\subsubsection[{dumpInsts}]{\setlength{\rightskip}{0pt plus 5cm}void dumpInsts ()}}
\label{classPipelineStage_a80587b4fe043bbe1995536cb3b361588}



\begin{DoxyCode}
1108 {
1109     cprintf("Insts in Stage %i skidbuffers\n",stageNum);
1110 
1111     for (ThreadID tid = 0; tid < ThePipeline::MaxThreads; tid++) {
1112         std::list<DynInstPtr>::iterator cur_it =  skidBuffer[tid].begin();
1113         std::list<DynInstPtr>::iterator end_it =  skidBuffer[tid].end();
1114 
1115         while (cur_it != end_it) {
1116             DynInstPtr inst = (*cur_it);
1117 
1118             cprintf("Inst. PC:%s\n[tid:%i]\n[sn:%i]\n\n",
1119                     inst->pcState(), inst->threadNumber, inst->seqNum);
1120 
1121             cur_it++;
1122         }
1123     }
1124 
1125 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a66db401ca5ea7de9fe7ca057d5eeb53c}{
\index{PipelineStage@{PipelineStage}!init@{init}}
\index{init@{init}!PipelineStage@{PipelineStage}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ({\bf Params} $\ast$ {\em params})}}
\label{classPipelineStage_a66db401ca5ea7de9fe7ca057d5eeb53c}
\hyperlink{classPipelineStage}{PipelineStage} initialization. 


\begin{DoxyCode}
65 {
66     for(ThreadID tid = 0; tid < numThreads; tid++) {
67         stageStatus[tid] = Idle;
68 
69         for (int stNum = 0; stNum < NumStages; stNum++) {
70             stalls[tid].stage[stNum] = false;
71         }
72         stalls[tid].resources.clear();
73 
74         if (stageNum < BackEndStartStage)
75             lastStallingStage[tid] = BackEndStartStage - 1;
76         else
77             lastStallingStage[tid] = NumStages - 1;
78     }
79 
80     if ((InOrderCPU::ThreadModel) params->threadModel ==
81         InOrderCPU::SwitchOnCacheMiss) {
82         switchedOutBuffer.resize(ThePipeline::MaxThreads);
83         switchedOutValid.resize(ThePipeline::MaxThreads);
84     }
85 }
\end{DoxyCode}
\hypertarget{classPipelineStage_ab8e0f4a73d5a3ab9fe269f3c36d97e4f}{
\index{PipelineStage@{PipelineStage}!isBlocked@{isBlocked}}
\index{isBlocked@{isBlocked}!PipelineStage@{PipelineStage}}
\subsubsection[{isBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool isBlocked ({\bf ThreadID} {\em tid})}}
\label{classPipelineStage_ab8e0f4a73d5a3ab9fe269f3c36d97e4f}



\begin{DoxyCode}
280 {
281     return stageStatus[tid] == Blocked;
282 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{PipelineStage@{PipelineStage}!name@{name}}
\index{name@{name}!PipelineStage@{PipelineStage}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const}}
\label{classPipelineStage_a37627d5d5bba7f4a8690c71c2ab3cb07}
Returns the name of stage. 


\begin{DoxyCode}
90 {
91      return cpu->name() + ".stage" + to_string(stageNum);
92 }
\end{DoxyCode}
\hypertarget{classPipelineStage_ab6e550d3e889847f642fa2205c6e12fd}{
\index{PipelineStage@{PipelineStage}!nextStageQueueValid@{nextStageQueueValid}}
\index{nextStageQueueValid@{nextStageQueueValid}!PipelineStage@{PipelineStage}}
\subsubsection[{nextStageQueueValid}]{\setlength{\rightskip}{0pt plus 5cm}bool nextStageQueueValid (int {\em stage\_\-num})}}
\label{classPipelineStage_ab6e550d3e889847f642fa2205c6e12fd}



\begin{DoxyCode}
1037 {
1038     return cpu->pipelineStage[stage_num]->nextStageValid;
1039 }
\end{DoxyCode}
\hypertarget{classPipelineStage_ab03996f3423928a0e84dc3df7fd493f2}{
\index{PipelineStage@{PipelineStage}!prevStageInstsValid@{prevStageInstsValid}}
\index{prevStageInstsValid@{prevStageInstsValid}!PipelineStage@{PipelineStage}}
\subsubsection[{prevStageInstsValid}]{\setlength{\rightskip}{0pt plus 5cm}bool prevStageInstsValid ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classPipelineStage_ab03996f3423928a0e84dc3df7fd493f2}
Returns if there any instructions from the previous stage on this cycle. 


\begin{DoxyCode}
274 {
275     return prevStage->insts.size() > 0;
276 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a4120d7c6b83eb82877f4d21109c105ba}{
\index{PipelineStage@{PipelineStage}!processInsts@{processInsts}}
\index{processInsts@{processInsts}!PipelineStage@{PipelineStage}}
\subsubsection[{processInsts}]{\setlength{\rightskip}{0pt plus 5cm}void processInsts ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classPipelineStage_a4120d7c6b83eb82877f4d21109c105ba}
Processes instructions from fetch and passes them on to rename. Decoding of instructions actually happens when they are created in fetch, so this function mostly checks if PC-\/relative branches are correct. 

\hyperlink{classFirstStage_a4120d7c6b83eb82877f4d21109c105ba}{FirstStage}で再定義されています。


\begin{DoxyCode}
860 {
861     // Instructions can come either from the skid buffer or the list of
862     // instructions coming from fetch, depending on stage's status.
863     int insts_available = skidBuffer[tid].size();
864 
865     std::list<DynInstPtr> &insts_to_stage = skidBuffer[tid];
866 
867     if (insts_available == 0) {
868         DPRINTF(InOrderStage, "[tid:%u]: Nothing to do, breaking out"
869                 " early.\n",tid);
870         return;
871     }
872 
873     DynInstPtr inst;
874     bool last_req_completed = true;
875 
876     while (insts_available > 0 &&
877            instsProcessed < stageWidth &&
878            last_req_completed) {
879         assert(!insts_to_stage.empty());
880 
881         inst = insts_to_stage.front();
882 
883         DPRINTF(InOrderStage, "[tid:%u]: Processing instruction [sn:%lli] "
884                 "%s with PC %s\n", tid, inst->seqNum,
885                 inst->instName(),
886                 inst->pcState());
887 
888         if (inst->isSquashed()) {
889             DPRINTF(InOrderStage, "[tid:%u]: Instruction %i with PC %s is "
890                     "squashed, skipping.\n",
891                     tid, inst->seqNum, inst->pcState());
892 
893             insts_to_stage.pop_front();
894 
895             --insts_available;
896 
897             continue;
898         }
899 
900         int reqs_processed = 0;        
901         last_req_completed = processInstSchedule(inst, reqs_processed);
902 
903         // If the instruction isnt squashed & we've completed one request
904         // Then we can officially count this instruction toward the stage's 
905         // bandwidth count
906         if (reqs_processed > 0)
907             instsProcessed++;
908 
909         // Don't let instruction pass to next stage if it hasnt completed
910         // all of it's requests for this stage.
911         if (!last_req_completed)
912             continue;
913 
914         // Send to Next Stage or Break Loop
915         if (nextStageValid && !sendInstToNextStage(inst)) {
916             DPRINTF(InOrderStage, "[tid:%i] [sn:%i] unable to proceed to stage"
917                     " %i.\n", tid, inst->seqNum,inst->nextStage);
918             break;
919         }
920 
921         insts_to_stage.pop_front();
922 
923         --insts_available;
924     }
925 
926     // If we didn't process all instructions, then we will need to block
927     // and put all those instructions into the skid buffer.
928     if (!insts_to_stage.empty()) {
929         blockDueToBuffer(tid);
930     }
931 
932     // Record that stage has written to the time buffer for activity
933     // tracking.
934     if (instsProcessed) {
935         wroteToTimeBuffer = true;
936     }
937 }
\end{DoxyCode}
\hypertarget{classPipelineStage_ac8bd857e45d0b201ea328b6ea8bcb890}{
\index{PipelineStage@{PipelineStage}!processInstSchedule@{processInstSchedule}}
\index{processInstSchedule@{processInstSchedule}!PipelineStage@{PipelineStage}}
\subsubsection[{processInstSchedule}]{\setlength{\rightskip}{0pt plus 5cm}bool processInstSchedule ({\bf DynInstPtr} {\em inst}, \/  int \& {\em reqs\_\-processed})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_ac8bd857e45d0b201ea328b6ea8bcb890}
\hyperlink{classProcess}{Process} all resources on an instruction's resource schedule 


\begin{DoxyCode}
941 {
942     bool last_req_completed = true;
943     ThreadID tid = inst->readTid();
944 
945     if (inst->nextResStage() == stageNum) {
946         int res_stage_num = inst->nextResStage();
947 
948         while (res_stage_num == stageNum) {
949             int res_num = inst->nextResource();
950 
951 
952             DPRINTF(InOrderStage, "[tid:%i]: [sn:%i]: sending request to %s."
953                     "\n", tid, inst->seqNum, cpu->resPool->name(res_num));
954 
955             ResReqPtr req = cpu->resPool->request(res_num, inst);
956             assert(req->valid);
957 
958             bool req_completed = req->isCompleted();
959             bool done_in_pipeline = false;
960             if (req_completed) {
961                 DPRINTF(InOrderStage, "[tid:%i]: [sn:%i] request to %s "
962                         "completed.\n", tid, inst->seqNum, 
963                         cpu->resPool->name(res_num));
964 
965                 reqs_processed++;                
966 
967                 req->stagePasses++;                
968 
969                 done_in_pipeline = inst->finishSkedEntry();
970                 if (done_in_pipeline) {
971                     DPRINTF(InOrderDynInst, "[tid:%i]: [sn:%i] finished "
972                             "in pipeline.\n", tid, inst->seqNum);
973                 }
974             } else {
975                 DPRINTF(InOrderStage, "[tid:%i]: [sn:%i] request to %s failed."
976                         "\n", tid, inst->seqNum, cpu->resPool->name(res_num));
977 
978                 last_req_completed = false;
979 
980                 if (req->isMemStall() && 
981                     cpu->threadModel == InOrderCPU::SwitchOnCacheMiss) {
982                     // Save Stalling Instruction
983                     DPRINTF(ThreadModel, "[tid:%i] [sn:%i] Detected cache "
984                             "miss.\n", tid, inst->seqNum);
985 
986                     DPRINTF(InOrderStage, "Inserting [tid:%i][sn:%i] into "
987                             "switch out buffer.\n", tid, inst->seqNum);
988 
989                     switchedOutBuffer[tid] = inst;
990                     switchedOutValid[tid] = true;
991                     
992                     // Remove Thread From Pipeline & Resource Pool
993                     inst->squashingStage = stageNum;
994                     inst->squashSeqNum = inst->seqNum;
995                     cpu->squashFromMemStall(inst, tid);  
996 
997                     // Switch On Cache Miss
998                     //=====================
999                     // Suspend Thread at end of cycle
1000                     DPRINTF(ThreadModel, "Suspending [tid:%i] due to cache "
1001                             "miss.\n", tid);
1002                     cpu->suspendContext(tid);                    
1003 
1004                     // Activate Next Ready Thread at end of cycle
1005                     DPRINTF(ThreadModel, "Attempting to activate next ready "
1006                             "thread due to cache miss.\n");
1007                     cpu->activateNextReadyContext();
1008                 }
1009             }
1010 
1011             // If this request is no longer needs to take up bandwidth in the
1012             // resource, go ahead and free that bandwidth up
1013             if (req->doneInResource) {
1014                 req->freeSlot();
1015             }
1016 
1017             // No longer need to process this instruction if the last
1018             // request it had wasn't completed or if there is nothing
1019             // else for it to do in the pipeline
1020             if (done_in_pipeline || !req_completed) {
1021                 break;
1022             }
1023 
1024             res_stage_num = inst->nextResStage();
1025         }
1026     } else {
1027         DPRINTF(InOrderStage, "[tid:%u]: Instruction [sn:%i] with PC %s "
1028                 " needed no resources in stage %i.\n",
1029                 tid, inst->seqNum, inst->pcState(), stageNum);
1030     }
1031 
1032     return last_req_completed;
1033 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a0782fca2c80ef367ee914d464584ab20}{
\index{PipelineStage@{PipelineStage}!processStage@{processStage}}
\index{processStage@{processStage}!PipelineStage@{PipelineStage}}
\subsubsection[{processStage}]{\setlength{\rightskip}{0pt plus 5cm}void processStage (bool \& {\em status\_\-change})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classPipelineStage_a0782fca2c80ef367ee914d464584ab20}
Evaluate Stage Conditions and then process stage 

\hyperlink{classFirstStage_a0782fca2c80ef367ee914d464584ab20}{FirstStage}で再定義されています。


\begin{DoxyCode}
792 {
793     list<ThreadID>::iterator threads = activeThreads->begin();
794 
795     //Check stall and squash signals.
796     while (threads != activeThreads->end()) {
797         ThreadID tid = *threads++;
798 
799         DPRINTF(InOrderStage,"Processing [tid:%i]\n",tid);
800         status_change =  checkSignalsAndUpdate(tid) || status_change;
801 
802         processThread(status_change, tid);
803     }
804 
805     if (nextStageValid) {
806         DPRINTF(InOrderStage, "%i insts now available for stage %i.\n",
807                 nextStage->insts.size(), stageNum + 1);
808     }
809 
810     if (instsProcessed > 0) {
811         ++runCycles;
812         idle = false;        
813     } else {
814         ++idleCycles;        
815         idle = true;        
816     }
817     
818     DPRINTF(InOrderStage, "%i left in stage %i incoming buffer.\n", skidSize(),
819             stageNum);
820 
821     DPRINTF(InOrderStage, "%i available in stage %i incoming buffer.\n", 
822             stageBufferAvail(), stageNum);
823 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a3e391d45d3f6411be62510f3b23105c9}{
\index{PipelineStage@{PipelineStage}!processThread@{processThread}}
\index{processThread@{processThread}!PipelineStage@{PipelineStage}}
\subsubsection[{processThread}]{\setlength{\rightskip}{0pt plus 5cm}void processThread (bool \& {\em status\_\-change}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a3e391d45d3f6411be62510f3b23105c9}
Determines what to do based on stage's current status. 
\begin{DoxyParams}{引数}
\item[{\em status\_\-change}]stage() sets this variable if there was a status change (ie switching from from blocking to unblocking). \item[{\em tid}]Thread id to stage instructions from. \end{DoxyParams}



\begin{DoxyCode}
827 {
828     // If status is Running or idle,
829     //     call processInsts()
830     // If status is Unblocking,
831     //     buffer any instructions coming from fetch
832    //     continue trying to empty skid buffer
833     //     check if stall conditions have passed
834 
835     // Stage should try to process as many instructions as its bandwidth
836     // will allow, as long as it is not currently blocked.
837     if (stageStatus[tid] == Running ||
838         stageStatus[tid] == Idle) {
839         DPRINTF(InOrderStage, "[tid:%u]: Not blocked, so attempting to run "
840                 "stage.\n",tid);
841 
842         processInsts(tid);
843     } else if (stageStatus[tid] == Unblocking) {
844         // Make sure that the skid buffer has something in it if the
845         // status is unblocking.
846         assert(!skidsEmpty());
847 
848         // If the status was unblocking, then instructions from the skid
849         // buffer were used.  Remove those instructions and handle
850         // the rest of unblocking.
851         processInsts(tid);
852 
853         status_change = unblock(tid) || status_change;
854     }
855 }
\end{DoxyCode}
\hypertarget{classPipelineStage_ad65c9f053a6038ac8c34c34bfe9a88c3}{
\index{PipelineStage@{PipelineStage}!readStallSignals@{readStallSignals}}
\index{readStallSignals@{readStallSignals}!PipelineStage@{PipelineStage}}
\subsubsection[{readStallSignals}]{\setlength{\rightskip}{0pt plus 5cm}void readStallSignals ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_ad65c9f053a6038ac8c34c34bfe9a88c3}
Reads all stall signals from the backwards communication timebuffer. 


\begin{DoxyCode}
630 {
631     for (int stage_idx = stageNum+1; stage_idx <= lastStallingStage[tid];
632          stage_idx++) {
633 
634         DPRINTF(InOrderStage, "[tid:%i] Reading stall signals from Stage "
635                 "%i. Block:%i Unblock:%i.\n",
636                 tid,
637                 stage_idx,
638                 fromNextStages->stageBlock[stage_idx][tid],
639                 fromNextStages->stageUnblock[stage_idx][tid]);
640 
641         // Check for Stage Blocking Signal
642         if (fromNextStages->stageBlock[stage_idx][tid]) {
643             DPRINTF(InOrderStage, "[tid:%i] Stall from stage %i set.\n", tid,
644                     stage_idx);
645             stalls[tid].stage[stage_idx] = true;
646         }
647 
648         // Check for Stage Unblocking Signal
649         if (fromNextStages->stageUnblock[stage_idx][tid]) {
650             DPRINTF(InOrderStage, "[tid:%i] Stall from stage %i unset.\n", tid,
651                     stage_idx);
652             stalls[tid].stage[stage_idx] = false;
653         }
654     }
655 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{PipelineStage@{PipelineStage}!regStats@{regStats}}
\index{regStats@{regStats}!PipelineStage@{PipelineStage}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()}}
\label{classPipelineStage_a4dc637449366fcdfc4e764cdf12d9b11}
Registers statistics. 


\begin{DoxyCode}
97 {
98    idleCycles
99         .name(name() + ".idleCycles")
100        .desc("Number of cycles 0 instructions are processed.");
101    
102     runCycles
103         .name(name() + ".runCycles")
104         .desc("Number of cycles 1+ instructions are processed.");
105 
106     utilization
107         .name(name() + ".utilization")
108         .desc("Percentage of cycles stage was utilized (processing insts).")
109         .precision(6);
110     utilization = (runCycles / cpu->numCycles) * 100;
111     
112 }
\end{DoxyCode}
\hypertarget{classPipelineStage_af5bd22ce78c3a8bafb5b91b7b70e8a41}{
\index{PipelineStage@{PipelineStage}!removeStalls@{removeStalls}}
\index{removeStalls@{removeStalls}!PipelineStage@{PipelineStage}}
\subsubsection[{removeStalls}]{\setlength{\rightskip}{0pt plus 5cm}void removeStalls ({\bf ThreadID} {\em tid})}}
\label{classPipelineStage_af5bd22ce78c3a8bafb5b91b7b70e8a41}
Remove all stall signals for a particular thread; 


\begin{DoxyCode}
249 {
250     for (int st_num = 0; st_num < NumStages; st_num++) {
251         if (stalls[tid].stage[st_num]) {
252             DPRINTF(InOrderStage, "Removing stall from stage %i.\n",
253                     st_num);
254             stalls[tid].stage[st_num] = false;
255         }
256 
257         if (toPrevStages->stageBlock[st_num][tid]) {
258             DPRINTF(InOrderStage, "Removing pending block from stage %i.\n",
259                     st_num);
260             toPrevStages->stageBlock[st_num][tid] = false;
261         }
262 
263         if (fromNextStages->stageBlock[st_num][tid]) {
264             DPRINTF(InOrderStage, "Removing pending block from stage %i.\n",
265                     st_num);
266             fromNextStages->stageBlock[st_num][tid] = false;
267         }
268     }
269     stalls[tid].resources.clear();
270 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a3a5710b990e95498611464d54c90dcf1}{
\index{PipelineStage@{PipelineStage}!sendInstToNextStage@{sendInstToNextStage}}
\index{sendInstToNextStage@{sendInstToNextStage}!PipelineStage@{PipelineStage}}
\subsubsection[{sendInstToNextStage}]{\setlength{\rightskip}{0pt plus 5cm}bool sendInstToNextStage ({\bf DynInstPtr} {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a3a5710b990e95498611464d54c90dcf1}
Send an instruction to the next stage buffer 


\begin{DoxyCode}
1044 {
1045     // Update Next Stage Variable in Instruction
1046     // NOTE: Some Resources will update this nextStage var. to
1047     // for bypassing, so can't always assume nextStage=stageNum+1
1048     if (inst->nextStage == stageNum)
1049         inst->nextStage++;
1050 
1051     bool success = false;
1052     ThreadID tid = inst->readTid();
1053     int next_stage = inst->nextStage;
1054     int prev_stage = next_stage - 1;
1055 
1056     assert(next_stage >= 1);
1057     assert(prev_stage >= 0);
1058 
1059     DPRINTF(InOrderStage, "[tid:%u]: Attempting to send instructions to "
1060             "stage %u.\n", tid, stageNum+1);
1061 
1062     if (!canSendInstToStage(inst->nextStage)) {
1063         DPRINTF(InOrderStage, "[tid:%u]: Could not send instruction to "
1064                 "stage %u.\n", tid, stageNum+1);
1065         return false;
1066     }
1067 
1068 
1069     if (nextStageQueueValid(inst->nextStage - 1)) {
1070         if (inst->seqNum > cpu->squashSeqNum[tid] &&
1071             curTick() == cpu->lastSquashCycle[tid]) {
1072             DPRINTF(InOrderStage, "[tid:%u]: [sn:%i]: squashed, skipping "
1073                     "insertion into stage %i queue.\n", tid, inst->seqNum, 
1074                     inst->nextStage);
1075         } else {
1076             if (nextStageValid) {
1077                 DPRINTF(InOrderStage, "[tid:%u] %i slots available in next "
1078                         "stage buffer.\n", tid, 
1079                         cpu->pipelineStage[next_stage]->stageBufferAvail());
1080             }
1081 
1082             DPRINTF(InOrderStage, "[tid:%u]: [sn:%i]: being placed into  "
1083                     "index %i of stage buffer %i queue.\n",
1084                     tid, inst->seqNum,
1085                     cpu->pipelineStage[prev_stage]->nextStage->insts.size(),
1086                     cpu->pipelineStage[prev_stage]->nextStageQueue->id());
1087 
1088             // Place instructions in inter-stage communication struct for next
1089             // pipeline stage to read next cycle
1090             cpu->pipelineStage[prev_stage]->nextStage->insts.push_back(inst);
1091 
1092             success = true;
1093 
1094             // Take note of trace data for this inst & stage
1095             if (inst->traceData) {
1096                 //@todo: exec traces are broke. fix them
1097                 inst->traceData->setStageCycle(stageNum, curTick());
1098             }
1099 
1100         }
1101     }
1102 
1103     return success;
1104 }
\end{DoxyCode}
\hypertarget{classPipelineStage_aab96bdacf8bd420402cbb543f994e054}{
\index{PipelineStage@{PipelineStage}!setActiveThreads@{setActiveThreads}}
\index{setActiveThreads@{setActiveThreads}!PipelineStage@{PipelineStage}}
\subsubsection[{setActiveThreads}]{\setlength{\rightskip}{0pt plus 5cm}void setActiveThreads ({\bf std::list}$<$ {\bf ThreadID} $>$ $\ast$ {\em at\_\-ptr})}}
\label{classPipelineStage_aab96bdacf8bd420402cbb543f994e054}
Sets pointer to list of active threads. 


\begin{DoxyCode}
170 {
171     DPRINTF(InOrderStage, "Setting active threads list pointer.\n");
172     activeThreads = at_ptr;
173 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a6fd0f914e19bcfb6d9f28e537ad956d5}{
\index{PipelineStage@{PipelineStage}!setCPU@{setCPU}}
\index{setCPU@{setCPU}!PipelineStage@{PipelineStage}}
\subsubsection[{setCPU}]{\setlength{\rightskip}{0pt plus 5cm}void setCPU ({\bf InOrderCPU} $\ast$ {\em cpu\_\-ptr})}}
\label{classPipelineStage_a6fd0f914e19bcfb6d9f28e537ad956d5}
Sets CPU pointer. 

\hyperlink{classFirstStage_a6fd0f914e19bcfb6d9f28e537ad956d5}{FirstStage}で再定義されています。


\begin{DoxyCode}
117 {
118     cpu = cpu_ptr;
119 
120     DPRINTF(InOrderStage, "Set CPU pointer.\n");
121 
122     tracer = dynamic_cast<Trace::InOrderTrace *>(cpu->getTracer());
123 }
\end{DoxyCode}
\hypertarget{classPipelineStage_ace33f1daf903e9438330807405092e20}{
\index{PipelineStage@{PipelineStage}!setNextStageQueue@{setNextStageQueue}}
\index{setNextStageQueue@{setNextStageQueue}!PipelineStage@{PipelineStage}}
\subsubsection[{setNextStageQueue}]{\setlength{\rightskip}{0pt plus 5cm}void setNextStageQueue ({\bf TimeBuffer}$<$ {\bf InterStageStruct} $>$ $\ast$ {\em next\_\-stage\_\-ptr})}}
\label{classPipelineStage_ace33f1daf903e9438330807405092e20}
Sets pointer to time buffer used to communicate to the next stage. 


\begin{DoxyCode}
157 {
158     DPRINTF(InOrderStage, "Setting next stage pointer.\n");
159     nextStageQueue = next_stage_ptr;
160 
161     // Setup wire to write information to proper place in stage queue.
162     nextStage = nextStageQueue->getWire(0);
163     nextStageValid = true;
164 }
\end{DoxyCode}
\hypertarget{classPipelineStage_aff9a9995beb69e92bbcf40c780c17b93}{
\index{PipelineStage@{PipelineStage}!setPrevStageQueue@{setPrevStageQueue}}
\index{setPrevStageQueue@{setPrevStageQueue}!PipelineStage@{PipelineStage}}
\subsubsection[{setPrevStageQueue}]{\setlength{\rightskip}{0pt plus 5cm}void setPrevStageQueue ({\bf TimeBuffer}$<$ {\bf InterStageStruct} $>$ $\ast$ {\em prev\_\-stage\_\-ptr})}}
\label{classPipelineStage_aff9a9995beb69e92bbcf40c780c17b93}
Sets pointer to time buffer coming from fetch. 


\begin{DoxyCode}
143 {
144     DPRINTF(InOrderStage, "Setting previous stage queue pointer.\n");
145     prevStageQueue = prev_stage_ptr;
146 
147     // Setup wire to read information from fetch queue.
148     prevStage = prevStageQueue->getWire(-1);
149 
150     prevStageValid = true;
151 }
\end{DoxyCode}
\hypertarget{classPipelineStage_af11246f186567b60383a2ff1d4bcf27c}{
\index{PipelineStage@{PipelineStage}!setResStall@{setResStall}}
\index{setResStall@{setResStall}!PipelineStage@{PipelineStage}}
\subsubsection[{setResStall}]{\setlength{\rightskip}{0pt plus 5cm}void setResStall ({\bf ResReqPtr} {\em res\_\-req}, \/  {\bf ThreadID} {\em tid})}}
\label{classPipelineStage_af11246f186567b60383a2ff1d4bcf27c}
\hyperlink{classSet}{Set} a resource stall in the pipeline-\/stage 


\begin{DoxyCode}
754 {
755     DPRINTF(InOrderStage, "Inserting stall from %s.\n", res_req->res->name());
756     stalls[tid].resources.push_back(res_req);
757 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a2b521ea5f191fff72265f60d4ed5187b}{
\index{PipelineStage@{PipelineStage}!setTimeBuffer@{setTimeBuffer}}
\index{setTimeBuffer@{setTimeBuffer}!PipelineStage@{PipelineStage}}
\subsubsection[{setTimeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}void setTimeBuffer ({\bf TimeBuffer}$<$ {\bf TimeStruct} $>$ $\ast$ {\em tb\_\-ptr})}}
\label{classPipelineStage_a2b521ea5f191fff72265f60d4ed5187b}
Sets the main backwards communication time buffer pointer. 


\begin{DoxyCode}
128 {
129     DPRINTF(InOrderStage, "Setting time buffer pointer.\n");
130     timeBuffer = tb_ptr;
131 
132     // Setup wire to write information back to fetch.
133     // @todo: should this be writing to the next stage => -1 and reading from is 
      (0)???
134     toPrevStages = timeBuffer->getWire(0);
135 
136     // Create wires to get information from proper places in time buffer.
137     fromNextStages = timeBuffer->getWire(-1);
138 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a9c19142b0bc2ce7b7a6593a5190cebc7}{
\index{PipelineStage@{PipelineStage}!setupSquash@{setupSquash}}
\index{setupSquash@{setupSquash}!PipelineStage@{PipelineStage}}
\subsubsection[{setupSquash}]{\setlength{\rightskip}{0pt plus 5cm}void setupSquash ({\bf DynInstPtr} {\em inst}, \/  {\bf ThreadID} {\em tid})}}
\label{classPipelineStage_a9c19142b0bc2ce7b7a6593a5190cebc7}
Setup Squashing Information to be passed back thru the pipeline 


\begin{DoxyCode}
353 {
354     if (cpu->lastSquashCycle[tid] == curTick() &&
355         cpu->squashSeqNum[tid] < inst->seqNum){
356         DPRINTF(Resource, "Ignoring [sn:%i] branch squash signal due to "
357                 "another stage's squash signal for after [sn:%i].\n", 
358                 inst->seqNum, cpu->squashSeqNum[tid]);
359     } else {
360         InstSeqNum squash_seq_num = inst->squashSeqNum;
361         unsigned squash_stage = (nextStageValid) ? stageNum + 1
362             : stageNum;
363 
364         toPrevStages->stageInfo[squash_stage][tid].squash = true;
365         toPrevStages->stageInfo[squash_stage][tid].doneSeqNum =
366             squash_seq_num;
367 
368         DPRINTF(InOrderStage, "[tid:%i]: Setting up squashing after "
369                 "[sn:%i], due to [sn:%i] %s. Squash-Start-Stage:%i\n",
370                 tid, squash_seq_num, inst->seqNum, inst->instName(),
371                 squash_stage);
372 
373         // Save squash num for later stage use
374         cpu->lastSquashCycle[tid] = curTick();
375         cpu->squashSeqNum[tid] = squash_seq_num;
376     }
377 }
\end{DoxyCode}
\hypertarget{classPipelineStage_afe3e2673d17dd5c568862ef5ae68b4d8}{
\index{PipelineStage@{PipelineStage}!skidsEmpty@{skidsEmpty}}
\index{skidsEmpty@{skidsEmpty}!PipelineStage@{PipelineStage}}
\subsubsection[{skidsEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool skidsEmpty ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_afe3e2673d17dd5c568862ef5ae68b4d8}
Returns if all of the skid buffers are empty. 


\begin{DoxyCode}
488 {
489     list<ThreadID>::iterator threads = activeThreads->begin();
490 
491     while (threads != activeThreads->end()) {
492         if (!skidBuffer[*threads++].empty())
493             return false;
494     }
495 
496     return true;
497 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a112431820c072831aa16794d42dc25e4}{
\index{PipelineStage@{PipelineStage}!skidSize@{skidSize}}
\index{skidSize@{skidSize}!PipelineStage@{PipelineStage}}
\subsubsection[{skidSize}]{\setlength{\rightskip}{0pt plus 5cm}int skidSize ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a112431820c072831aa16794d42dc25e4}
Total size of all skid buffers 


\begin{DoxyCode}
476 {
477     int total = 0;
478 
479     for (int i=0; i < ThePipeline::MaxThreads; i++) {
480         total += skidBuffer[i].size();
481     }
482 
483     return total;
484 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a9ff2aa32ab0f40674cb3518108d62f8e}{
\index{PipelineStage@{PipelineStage}!sortInsts@{sortInsts}}
\index{sortInsts@{sortInsts}!PipelineStage@{PipelineStage}}
\subsubsection[{sortInsts}]{\setlength{\rightskip}{0pt plus 5cm}void sortInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a9ff2aa32ab0f40674cb3518108d62f8e}
Separates instructions from fetch into individual lists of instructions sorted by thread. 

\hyperlink{classFirstStage_a9ff2aa32ab0f40674cb3518108d62f8e}{FirstStage}で再定義されています。


\begin{DoxyCode}
575 {
576     if (prevStageValid) {
577         assert(prevStage->insts.size() <= stageWidth);
578 
579         int insts_from_prev_stage = prevStage->insts.size();
580         int insts_from_cur_stage = skidSize();
581         DPRINTF(InOrderStage, "%i insts available from stage buffer %i. Stage "
582                 "currently has %i insts from last cycle.\n",
583                 insts_from_prev_stage, prevStageQueue->id(),
584                 insts_from_cur_stage);
585 
586         int inserted_insts = 0;
587 
588         for (int i = 0; i < insts_from_prev_stage; i++) {
589             if (prevStage->insts[i]->isSquashed()) {
590                 DPRINTF(InOrderStage, "[tid:%i]: Ignoring squashed [sn:%i], "
591                         "not inserting into stage buffer.\n",
592                     prevStage->insts[i]->readTid(),
593                     prevStage->insts[i]->seqNum);
594                 continue;
595             }
596 
597             ThreadID tid = prevStage->insts[i]->threadNumber;
598 
599             if (inserted_insts + insts_from_cur_stage == stageWidth) {
600                DPRINTF(InOrderStage, "Stage %i has accepted all insts "
601                        "possible for this tick. Placing [sn:%i] in stage %i skidB
      uffer\n",
602                        stageNum, prevStage->insts[i]->seqNum, stageNum - 1);
603                 cpu->pipelineStage[stageNum - 1]->
604                     skidBuffer[tid].push_front(prevStage->insts[i]);
605 
606                 int prev_stage = stageNum - 1;
607                 if (cpu->pipelineStage[prev_stage]->stageStatus[tid] == Running |
      |
608                     cpu->pipelineStage[prev_stage]->stageStatus[tid] == Idle) {
609                     cpu->pipelineStage[prev_stage]->stageStatus[tid] = 
      Unblocking;
610                 }
611             } else {
612                 DPRINTF(InOrderStage, "[tid:%i]: Inserting [sn:%i] into stage "
613                         "buffer.\n", prevStage->insts[i]->readTid(),
614                         prevStage->insts[i]->seqNum);
615 
616                 skidBuffer[tid].push_back(prevStage->insts[i]);
617             }
618 
619             prevStage->insts[i] = cpu->dummyBufferInst;
620 
621             inserted_insts++;
622         }
623     }
624 }
\end{DoxyCode}
\hypertarget{classPipelineStage_aee9dc23de90acd20200641407a3bd1da}{
\index{PipelineStage@{PipelineStage}!squash@{squash}}
\index{squash@{squash}!PipelineStage@{PipelineStage}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash ({\bf InstSeqNum} {\em squash\_\-num}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPipelineStage_aee9dc23de90acd20200641407a3bd1da}
Perform squash of instructions above seq\_\-num 

\hyperlink{classFirstStage_ad9e3c0e17499440cfafb6145d7be97a1}{FirstStage}で再定義されています。


\begin{DoxyCode}
409 {
410     // Set status to squashing.
411     stageStatus[tid] = Squashing;
412 
413     squashPrevStageInsts(squash_seq_num, tid);
414 
415     DPRINTF(InOrderStage, "[tid:%i]: Removing instructions from incoming stage"
416             " skidbuffer.\n", tid);
417     //@TODO: Walk Through List Using iterator and remove
418     //       all instructions over the value
419     std::list<DynInstPtr>::iterator cur_it = skidBuffer[tid].begin();
420     std::list<DynInstPtr>::iterator end_it = skidBuffer[tid].end();
421 
422     while (cur_it != end_it) {
423         if ((*cur_it)->seqNum <= squash_seq_num) {
424             DPRINTF(InOrderStage, "[tid:%i]: Cannot remove skidBuffer "
425                     "instructions (starting w/[sn:%i]) before "
426                     "[sn:%i]. %i insts left.\n", tid, 
427                     (*cur_it)->seqNum, squash_seq_num,
428                     skidBuffer[tid].size());
429             cur_it++;
430         } else {
431             DPRINTF(InOrderStage, "[tid:%i]: Removing instruction, [sn:%i] "
432                     " PC %s.\n", tid, (*cur_it)->seqNum, (*cur_it)->pc);
433             (*cur_it)->setSquashed();
434             cur_it = skidBuffer[tid].erase(cur_it);
435         }
436 
437     }
438 
439 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a960b60a46045a5363df0c263f0f43902}{
\index{PipelineStage@{PipelineStage}!squashDueToMemStall@{squashDueToMemStall}}
\index{squashDueToMemStall@{squashDueToMemStall}!PipelineStage@{PipelineStage}}
\subsubsection[{squashDueToMemStall}]{\setlength{\rightskip}{0pt plus 5cm}void squashDueToMemStall ({\bf InstSeqNum} {\em seq\_\-num}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPipelineStage_a960b60a46045a5363df0c263f0f43902}


\hyperlink{classFirstStage_a960b60a46045a5363df0c263f0f43902}{FirstStage}で再定義されています。


\begin{DoxyCode}
381 {
382     squash(seq_num, tid);    
383 }
\end{DoxyCode}
\hypertarget{classPipelineStage_adbce9d3c16239dca0ffd19bc176ea258}{
\index{PipelineStage@{PipelineStage}!squashPrevStageInsts@{squashPrevStageInsts}}
\index{squashPrevStageInsts@{squashPrevStageInsts}!PipelineStage@{PipelineStage}}
\subsubsection[{squashPrevStageInsts}]{\setlength{\rightskip}{0pt plus 5cm}void squashPrevStageInsts ({\bf InstSeqNum} {\em squash\_\-seq\_\-num}, \/  {\bf ThreadID} {\em tid})}}
\label{classPipelineStage_adbce9d3c16239dca0ffd19bc176ea258}
Squash instructions from stage buffer 


\begin{DoxyCode}
387 {
388     DPRINTF(InOrderStage, "[tid:%i]: Removing instructions from "
389             "incoming stage queue.\n", tid);
390 
391     int insts_from_prev_stage = prevStage->insts.size();
392     for (int i=0; i < insts_from_prev_stage; i++) {
393         if (prevStage->insts[i]->threadNumber == tid &&
394             prevStage->insts[i]->seqNum > squash_seq_num) {
395             DPRINTF(InOrderStage, "[tid:%i]: Squashing instruction, "
396                     "[sn:%i] PC %s.\n",
397                     tid,
398                     prevStage->insts[i]->seqNum,
399                     prevStage->insts[i]->pcState());
400             prevStage->insts[i]->setSquashed();
401 
402             prevStage->insts[i] = cpu->dummyBufferInst;
403         }
404     }
405 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a4623e7080104807616729bb5504b76ce}{
\index{PipelineStage@{PipelineStage}!stageBufferAvail@{stageBufferAvail}}
\index{stageBufferAvail@{stageBufferAvail}!PipelineStage@{PipelineStage}}
\subsubsection[{stageBufferAvail}]{\setlength{\rightskip}{0pt plus 5cm}int stageBufferAvail ()}}
\label{classPipelineStage_a4623e7080104807616729bb5504b76ce}
Is there room in the stage buffer? 


\begin{DoxyCode}
443 {
444     unsigned total = 0;
445 
446     for (int i=0; i < ThePipeline::MaxThreads; i++) {
447         total += skidBuffer[i].size();
448     }
449 
450     int avail = stageBufferMax - total;
451     assert(avail >= 0);
452 
453     return avail;
454 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a05f299b443f8cc73a93d61572edc0218}{
\index{PipelineStage@{PipelineStage}!switchOut@{switchOut}}
\index{switchOut@{switchOut}!PipelineStage@{PipelineStage}}
\subsubsection[{switchOut}]{\setlength{\rightskip}{0pt plus 5cm}void switchOut ()}}
\label{classPipelineStage_a05f299b443f8cc73a93d61572edc0218}
Changes the status of this stage to active, and indicates this to the CPU. Changes the status of this stage to inactive, and indicates this to the CPU. Switches out the stage stage. 


\begin{DoxyCode}
189 {
190     // Stage can immediately switch out.
191     panic("Switching Out of Stages Unimplemented");
192 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a8674059ce345e23aac5086b2c3e24a43}{
\index{PipelineStage@{PipelineStage}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!PipelineStage@{PipelineStage}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPipelineStage_a8674059ce345e23aac5086b2c3e24a43}
Takes over from another CPU's thread. 

\hyperlink{classFirstStage_a8674059ce345e23aac5086b2c3e24a43}{FirstStage}で再定義されています。


\begin{DoxyCode}
197 {
198     _status = Inactive;
199 
200     // Be sure to reset state and clear out any old instructions.
201     for (ThreadID tid = 0; tid < numThreads; ++tid) {
202         stageStatus[tid] = Idle;
203 
204         for (int stNum = 0; stNum < NumStages; stNum++) {
205             stalls[tid].stage[stNum] = false;
206         }
207 
208         stalls[tid].resources.clear();
209 
210         skidBuffer[tid].clear();
211     }
212     wroteToTimeBuffer = false;
213 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a873dd91783f9efb4a590aded1f70d6b0}{
\index{PipelineStage@{PipelineStage}!tick@{tick}}
\index{tick@{tick}!PipelineStage@{PipelineStage}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()}}
\label{classPipelineStage_a873dd91783f9efb4a590aded1f70d6b0}
Ticks stage, processing all input signals and executing as many instructions as possible. 


\begin{DoxyCode}
727 {
728     idle = false;
729     
730     wroteToTimeBuffer = false;
731 
732     bool status_change = false;
733     
734     sortInsts();
735 
736     instsProcessed = 0;
737 
738     processStage(status_change);
739 
740     if (status_change) {
741         updateStatus();
742     }
743 
744     if (wroteToTimeBuffer) {
745         DPRINTF(Activity, "Activity this cycle.\n");
746         cpu->activityThisCycle();
747     }
748 
749     DPRINTF(InOrderStage, "\n\n");
750 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a9cc3b95f6969935f78c0158aa5145021}{
\index{PipelineStage@{PipelineStage}!unblock@{unblock}}
\index{unblock@{unblock}!PipelineStage@{PipelineStage}}
\subsubsection[{unblock}]{\setlength{\rightskip}{0pt plus 5cm}bool unblock ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a9cc3b95f6969935f78c0158aa5145021}
Switches stage to unblocking if the skid buffer is empty, and signals back that stage has unblocked. \begin{DoxyReturn}{戻り値}
Returns true if there is a status change. 
\end{DoxyReturn}



\begin{DoxyCode}
331 {
332     // @todo: Shouldnt this be if any available slots are open???
333     // Stage is done unblocking only if the skid buffer is empty.
334     if (skidBuffer[tid].empty()) {
335         DPRINTF(InOrderStage, "[tid:%u]: Done unblocking.\n", tid);
336 
337         if (prevStageValid)
338             toPrevStages->stageUnblock[stageNum][tid] = true;
339 
340         wroteToTimeBuffer = true;
341 
342         stageStatus[tid] = Running;
343 
344         return true;
345     }
346 
347     DPRINTF(InOrderStage, "[tid:%u]: Currently unblocking.\n", tid);
348     return false;
349 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a71090c4bc5fc055eb0ea621cb65fddc8}{
\index{PipelineStage@{PipelineStage}!unsetResStall@{unsetResStall}}
\index{unsetResStall@{unsetResStall}!PipelineStage@{PipelineStage}}
\subsubsection[{unsetResStall}]{\setlength{\rightskip}{0pt plus 5cm}void unsetResStall ({\bf ResReqPtr} {\em res\_\-req}, \/  {\bf ThreadID} {\em tid})}}
\label{classPipelineStage_a71090c4bc5fc055eb0ea621cb65fddc8}
Unset a resource stall in the pipeline-\/stage 


\begin{DoxyCode}
761 {
762     // Search through stalls to find stalling request and then
763     // remove it
764     vector<ResReqPtr>::iterator req_it = stalls[tid].resources.begin();
765     vector<ResReqPtr>::iterator req_end = stalls[tid].resources.end();
766 
767     while (req_it != req_end) {
768         if( (*req_it)->res ==  res_req->res && // Same Resource
769             (*req_it)->inst ==  res_req->inst && // Same Instruction
770             (*req_it)->getSlot() ==  res_req->getSlot()) {
771             DPRINTF(InOrderStage, "[tid:%u]: Clearing stall by %s.\n",
772                     tid, res_req->res->name());
773             stalls[tid].resources.erase(req_it);
774             break;
775         }
776 
777         req_it++;
778     }
779 
780     if (stalls[tid].resources.size() == 0) {
781         DPRINTF(InOrderStage, "[tid:%u]: There are no remaining resource"
782                 "stalls.\n", tid);
783     }
784 }
\end{DoxyCode}
\hypertarget{classPipelineStage_a4bb9486757ce225941aaaf759b357a57}{
\index{PipelineStage@{PipelineStage}!updateStatus@{updateStatus}}
\index{updateStatus@{updateStatus}!PipelineStage@{PipelineStage}}
\subsubsection[{updateStatus}]{\setlength{\rightskip}{0pt plus 5cm}void updateStatus ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a4bb9486757ce225941aaaf759b357a57}
Updates overall stage status based on all of the threads' statuses. 


\begin{DoxyCode}
503 {
504     bool any_unblocking = false;
505 
506     list<ThreadID>::iterator threads = activeThreads->begin();
507 
508     while (threads != activeThreads->end()) {
509         ThreadID tid = *threads++;
510 
511         if (stageStatus[tid] == Unblocking) {
512             any_unblocking = true;
513             break;
514         }
515     }
516 
517     // Stage will have activity if it's unblocking.
518     if (any_unblocking) {
519         if (_status == Inactive) {
520             _status = Active;
521 
522             DPRINTF(Activity, "Activating stage.\n");
523 
524             cpu->activateStage(stageNum);
525         }
526     } else {
527         // If it's not unblocking, then stage will not have any internal
528         // activity.  Switch it to inactive.
529         if (_status == Active) {
530             _status = Inactive;
531             DPRINTF(Activity, "Deactivating stage.\n");
532 
533             cpu->deactivateStage(stageNum);
534         }
535     }
536 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classPipelineStage_a4530a0391410036c939865008a53f356}{
\index{PipelineStage@{PipelineStage}!\_\-status@{\_\-status}}
\index{\_\-status@{\_\-status}!PipelineStage@{PipelineStage}}
\subsubsection[{\_\-status}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StageStatus} {\bf \_\-status}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a4530a0391410036c939865008a53f356}
Stage status. \hypertarget{classPipelineStage_af6eaea53db532812052f71bf0380dab5}{
\index{PipelineStage@{PipelineStage}!activeThreads@{activeThreads}}
\index{activeThreads@{activeThreads}!PipelineStage@{PipelineStage}}
\subsubsection[{activeThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf ThreadID}$>$$\ast$ {\bf activeThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_af6eaea53db532812052f71bf0380dab5}
List of active thread ids \hypertarget{classPipelineStage_ab949b1ea7ed96a92d473eeaa17348bed}{
\index{PipelineStage@{PipelineStage}!bdelayDoneSeqNum@{bdelayDoneSeqNum}}
\index{bdelayDoneSeqNum@{bdelayDoneSeqNum}!PipelineStage@{PipelineStage}}
\subsubsection[{bdelayDoneSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf bdelayDoneSeqNum}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_ab949b1ea7ed96a92d473eeaa17348bed}
SeqNum of Squashing Branch Delay Instruction (used for MIPS) \hypertarget{classPipelineStage_a41d682c28d0f49e04393c52815808782}{
\index{PipelineStage@{PipelineStage}!cpu@{cpu}}
\index{cpu@{cpu}!PipelineStage@{PipelineStage}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InOrderCPU}$\ast$ {\bf cpu}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a41d682c28d0f49e04393c52815808782}
CPU interface. \hypertarget{classPipelineStage_a09dc4a08ace7d6e74531ffff1ba5d905}{
\index{PipelineStage@{PipelineStage}!dummyBufferInst@{dummyBufferInst}}
\index{dummyBufferInst@{dummyBufferInst}!PipelineStage@{PipelineStage}}
\subsubsection[{dummyBufferInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf dummyBufferInst}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a09dc4a08ace7d6e74531ffff1ba5d905}
Instruction used to signify that there is no $\ast$real$\ast$ instruction in buffer slot \hypertarget{classPipelineStage_a728ac6e701ecba86ee9e8d15ae07d53f}{
\index{PipelineStage@{PipelineStage}!fromNextStages@{fromNextStages}}
\index{fromNextStages@{fromNextStages}!PipelineStage@{PipelineStage}}
\subsubsection[{fromNextStages}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf fromNextStages}}}
\label{classPipelineStage_a728ac6e701ecba86ee9e8d15ae07d53f}
\hyperlink{classWire}{Wire} to get rename's output from backwards time buffer. \hypertarget{classPipelineStage_a97808a9870039f4168da10ecfb5dc472}{
\index{PipelineStage@{PipelineStage}!idle@{idle}}
\index{idle@{idle}!PipelineStage@{PipelineStage}}
\subsubsection[{idle}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf idle}}}
\label{classPipelineStage_a97808a9870039f4168da10ecfb5dc472}
\hypertarget{classPipelineStage_a42e0f4c18fdb8ef7504f5c45d697fb14}{
\index{PipelineStage@{PipelineStage}!idleCycles@{idleCycles}}
\index{idleCycles@{idleCycles}!PipelineStage@{PipelineStage}}
\subsubsection[{idleCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf idleCycles}}}
\label{classPipelineStage_a42e0f4c18fdb8ef7504f5c45d697fb14}
Number of cycles 0 instruction(s) are processed. \hypertarget{classPipelineStage_a4ac908fc89a76ee30c0af235353b6c2f}{
\index{PipelineStage@{PipelineStage}!instsProcessed@{instsProcessed}}
\index{instsProcessed@{instsProcessed}!PipelineStage@{PipelineStage}}
\subsubsection[{instsProcessed}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf instsProcessed}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a4ac908fc89a76ee30c0af235353b6c2f}
Instructions that we've processed this tick NOTE: \char`\"{}Processed\char`\"{} means completed at least 1 instruction request \hypertarget{classPipelineStage_ac171ebbc339fe3c1b91878034586b7a5}{
\index{PipelineStage@{PipelineStage}!lastStallingStage@{lastStallingStage}}
\index{lastStallingStage@{lastStallingStage}!PipelineStage@{PipelineStage}}
\subsubsection[{lastStallingStage}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf lastStallingStage}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_ac171ebbc339fe3c1b91878034586b7a5}
The last stage that this particular stage should look for stalls \hypertarget{classPipelineStage_a7a06bbc61668c11d11fde945df559f55}{
\index{PipelineStage@{PipelineStage}!nextStage@{nextStage}}
\index{nextStage@{nextStage}!PipelineStage@{PipelineStage}}
\subsubsection[{nextStage}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf InterStageStruct}$>$::wire {\bf nextStage}}}
\label{classPipelineStage_a7a06bbc61668c11d11fde945df559f55}
\hyperlink{classWire}{Wire} to write to the next stage \hypertarget{classPipelineStage_aa6321826776981dc0e21fbdeefe52016}{
\index{PipelineStage@{PipelineStage}!nextStageQueue@{nextStageQueue}}
\index{nextStageQueue@{nextStageQueue}!PipelineStage@{PipelineStage}}
\subsubsection[{nextStageQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf InterStageStruct}$>$$\ast$ {\bf nextStageQueue}}}
\label{classPipelineStage_aa6321826776981dc0e21fbdeefe52016}
Instruction queue linking next stage \hypertarget{classPipelineStage_a74cfb32df253cbcbf5d70e6523492d2d}{
\index{PipelineStage@{PipelineStage}!nextStageValid@{nextStageValid}}
\index{nextStageValid@{nextStageValid}!PipelineStage@{PipelineStage}}
\subsubsection[{nextStageValid}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf nextStageValid}}}
\label{classPipelineStage_a74cfb32df253cbcbf5d70e6523492d2d}
Is Next Stage Valid? \hypertarget{classPipelineStage_a88377f855dbf5adeeecb06b5bb821d35}{
\index{PipelineStage@{PipelineStage}!numThreads@{numThreads}}
\index{numThreads@{numThreads}!PipelineStage@{PipelineStage}}
\subsubsection[{numThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} {\bf numThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a88377f855dbf5adeeecb06b5bb821d35}
Number of Threads \hypertarget{classPipelineStage_a560e9ae4ad5991a1789e95d33f59503b}{
\index{PipelineStage@{PipelineStage}!prevStage@{prevStage}}
\index{prevStage@{prevStage}!PipelineStage@{PipelineStage}}
\subsubsection[{prevStage}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf InterStageStruct}$>$::wire {\bf prevStage}}}
\label{classPipelineStage_a560e9ae4ad5991a1789e95d33f59503b}
\hyperlink{classWire}{Wire} to get the previous stage's. \hypertarget{classPipelineStage_af54931163e4bdb38a1295065af735582}{
\index{PipelineStage@{PipelineStage}!prevStageQueue@{prevStageQueue}}
\index{prevStageQueue@{prevStageQueue}!PipelineStage@{PipelineStage}}
\subsubsection[{prevStageQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf InterStageStruct}$>$$\ast$ {\bf prevStageQueue}}}
\label{classPipelineStage_af54931163e4bdb38a1295065af735582}
Instruction queue linking previous stage \hypertarget{classPipelineStage_abb343738ea92390af4fbc30bc718d1bc}{
\index{PipelineStage@{PipelineStage}!prevStageValid@{prevStageValid}}
\index{prevStageValid@{prevStageValid}!PipelineStage@{PipelineStage}}
\subsubsection[{prevStageValid}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf prevStageValid}}}
\label{classPipelineStage_abb343738ea92390af4fbc30bc718d1bc}
Is Previous Stage Valid? \hypertarget{classPipelineStage_af9addd340a133c2f4add363a3055b019}{
\index{PipelineStage@{PipelineStage}!runCycles@{runCycles}}
\index{runCycles@{runCycles}!PipelineStage@{PipelineStage}}
\subsubsection[{runCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf runCycles}}}
\label{classPipelineStage_af9addd340a133c2f4add363a3055b019}
Number of cycles 1+ instructions are processed. \hypertarget{classPipelineStage_ad02ffed1611064a60befad18c5d428ef}{
\index{PipelineStage@{PipelineStage}!skidBuffer@{skidBuffer}}
\index{skidBuffer@{skidBuffer}!PipelineStage@{PipelineStage}}
\subsubsection[{skidBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf skidBuffer}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_ad02ffed1611064a60befad18c5d428ef}
Skid buffer between previous stage and this one. \hypertarget{classPipelineStage_ac364a786221f4a1741023dc82bc834f9}{
\index{PipelineStage@{PipelineStage}!squashAfterDelaySlot@{squashAfterDelaySlot}}
\index{squashAfterDelaySlot@{squashAfterDelaySlot}!PipelineStage@{PipelineStage}}
\subsubsection[{squashAfterDelaySlot}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf squashAfterDelaySlot}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_ac364a786221f4a1741023dc82bc834f9}
Tells when their is a pending delay slot inst. to send to rename. If there is, then wait squash after the next instruction (used for MIPS). \hypertarget{classPipelineStage_a2313a835690e0d98e53b1aa69754bb1f}{
\index{PipelineStage@{PipelineStage}!squashInst@{squashInst}}
\index{squashInst@{squashInst}!PipelineStage@{PipelineStage}}
\subsubsection[{squashInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf squashInst}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a2313a835690e0d98e53b1aa69754bb1f}
Instruction used for squashing branch (used for MIPS) \hypertarget{classPipelineStage_a8b3bf50b9e561c023857979eaf326bee}{
\index{PipelineStage@{PipelineStage}!stageBufferMax@{stageBufferMax}}
\index{stageBufferMax@{stageBufferMax}!PipelineStage@{PipelineStage}}
\subsubsection[{stageBufferMax}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf stageBufferMax}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a8b3bf50b9e561c023857979eaf326bee}
Maximum size of the inter-\/stage buffer connecting the previous stage to this stage (which we call a skid buffer) \hypertarget{classPipelineStage_afc0a9a26d747553fd1fd8e698a8e7029}{
\index{PipelineStage@{PipelineStage}!stageNum@{stageNum}}
\index{stageNum@{stageNum}!PipelineStage@{PipelineStage}}
\subsubsection[{stageNum}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf stageNum}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_afc0a9a26d747553fd1fd8e698a8e7029}
The Number of This Pipeline Stage \hypertarget{classPipelineStage_af95a0e3fe4e1c0a168cc3c74869a4816}{
\index{PipelineStage@{PipelineStage}!stageStatus@{stageStatus}}
\index{stageStatus@{stageStatus}!PipelineStage@{PipelineStage}}
\subsubsection[{stageStatus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadStatus} {\bf stageStatus}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_af95a0e3fe4e1c0a168cc3c74869a4816}
Per-\/thread status. \hypertarget{classPipelineStage_a51d98139f56a84585e4cb68e3cd67a1c}{
\index{PipelineStage@{PipelineStage}!stageWidth@{stageWidth}}
\index{stageWidth@{stageWidth}!PipelineStage@{PipelineStage}}
\subsubsection[{stageWidth}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf stageWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a51d98139f56a84585e4cb68e3cd67a1c}
The width of stage, in instructions. \hypertarget{classPipelineStage_aa7522ea079359a7730812c7091dbb4a5}{
\index{PipelineStage@{PipelineStage}!stalls@{stalls}}
\index{stalls@{stalls}!PipelineStage@{PipelineStage}}
\subsubsection[{stalls}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stalls} {\bf stalls}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}}}
\label{classPipelineStage_aa7522ea079359a7730812c7091dbb4a5}
Tracks stage/resource stalls \hypertarget{classPipelineStage_a693e4a546dfc51b4e402fe75e73e812e}{
\index{PipelineStage@{PipelineStage}!switchedOutBuffer@{switchedOutBuffer}}
\index{switchedOutBuffer@{switchedOutBuffer}!PipelineStage@{PipelineStage}}
\subsubsection[{switchedOutBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf DynInstPtr}$>$ {\bf switchedOutBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a693e4a546dfc51b4e402fe75e73e812e}
\hyperlink{classBuffer}{Buffer} of instructions switched out to mem-\/stall. Only used when using SwitchOnCacheMiss threading model Used as 1-\/to-\/1 mapping between ThreadID and Entry. \hypertarget{classPipelineStage_a09a91d6926260c8037374f0b646a62ee}{
\index{PipelineStage@{PipelineStage}!switchedOutValid@{switchedOutValid}}
\index{switchedOutValid@{switchedOutValid}!PipelineStage@{PipelineStage}}
\subsubsection[{switchedOutValid}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<$bool$>$ {\bf switchedOutValid}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a09a91d6926260c8037374f0b646a62ee}
\hypertarget{classPipelineStage_a83f9ee976e732665aeb08dbc19acfd45}{
\index{PipelineStage@{PipelineStage}!timeBuffer@{timeBuffer}}
\index{timeBuffer@{timeBuffer}!PipelineStage@{PipelineStage}}
\subsubsection[{timeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$$\ast$ {\bf timeBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a83f9ee976e732665aeb08dbc19acfd45}
\hyperlink{classTime}{Time} buffer interface. \hypertarget{classPipelineStage_ab6a826f43ca871b277e724aa148d1816}{
\index{PipelineStage@{PipelineStage}!toNextStageIndex@{toNextStageIndex}}
\index{toNextStageIndex@{toNextStageIndex}!PipelineStage@{PipelineStage}}
\subsubsection[{toNextStageIndex}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf toNextStageIndex}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_ab6a826f43ca871b277e724aa148d1816}
Index of instructions being sent to the next stage. \hypertarget{classPipelineStage_ad270a1de154f2e748a16880469c9baea}{
\index{PipelineStage@{PipelineStage}!toPrevStages@{toPrevStages}}
\index{toPrevStages@{toPrevStages}!PipelineStage@{PipelineStage}}
\subsubsection[{toPrevStages}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf toPrevStages}}}
\label{classPipelineStage_ad270a1de154f2e748a16880469c9baea}
\hyperlink{classWire}{Wire} to get iew's information from backwards time buffer. \hypertarget{classPipelineStage_af3ad9be2b464186b902b5ca568b6d439}{
\index{PipelineStage@{PipelineStage}!tracer@{tracer}}
\index{tracer@{tracer}!PipelineStage@{PipelineStage}}
\subsubsection[{tracer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Trace::InOrderTrace}$\ast$ {\bf tracer}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_af3ad9be2b464186b902b5ca568b6d439}
\hypertarget{classPipelineStage_a04353589e0e920909d3ceb8e73abb7ac}{
\index{PipelineStage@{PipelineStage}!utilization@{utilization}}
\index{utilization@{utilization}!PipelineStage@{PipelineStage}}
\subsubsection[{utilization}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf utilization}}}
\label{classPipelineStage_a04353589e0e920909d3ceb8e73abb7ac}
Percentage of cycles 1+ instructions are processed. \hypertarget{classPipelineStage_a2c7e870d4babdac0dc91fc7ffabd0f3d}{
\index{PipelineStage@{PipelineStage}!wroteToTimeBuffer@{wroteToTimeBuffer}}
\index{wroteToTimeBuffer@{wroteToTimeBuffer}!PipelineStage@{PipelineStage}}
\subsubsection[{wroteToTimeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf wroteToTimeBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPipelineStage_a2c7e870d4babdac0dc91fc7ffabd0f3d}
Variable that tracks if stage has written to the time buffer this cycle. Used to tell CPU if there is activity this cycle. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/inorder/\hyperlink{pipeline__stage_8hh}{pipeline\_\-stage.hh}\item 
cpu/inorder/\hyperlink{pipeline__stage_8cc}{pipeline\_\-stage.cc}\end{DoxyCompactItemize}
