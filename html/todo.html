<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>File&nbsp;GEM5&nbsp;Wrapper: TODO一覧</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- 作成： Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>メインページ</span></a></li>
      <li class="current"><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="todo">TODO一覧 </a></h1><p><a class="anchor" id="_todo000010"></a> </p>
<dl>
<dt>メンバ <a class="el" href="str_8cc.html#a62ee5dab740541c091921011e05068c7">__to_number</a>  </dt>
<dd>This function will not handle the smallest negative decimal value for a signed type </dd>
</dl>
<p><a class="anchor" id="_todo000003"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classArmISA_1_1TableWalker.html#a837a539f5e07e8785902d5854efde98d">ArmISA::TableWalker::doL1Descriptor</a> () </dt>
<dd>: check sctlr.ha (bit[17]) if Hardware Access Flag is enabled if set, do l1.Desc.setAp0() instead of generating AccessFlag0 </dd>
</dl>
<p><a class="anchor" id="_todo000004"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classArmISA_1_1TableWalker.html#a45b9877779ac070b7779f7e1eccdd05e">ArmISA::TableWalker::doL2Descriptor</a> () </dt>
<dd>: check sctlr.ha (bit[17]) if Hardware Access Flag is enabled if set, do l2.Desc.setAp0() instead of generating AccessFlag0 </dd>
</dl>
<p><a class="anchor" id="_todo000002"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classArmISA_1_1TableWalker.html#ae5ef435aac9ac661f33937b2254718b1">ArmISA::TableWalker::walk</a> (RequestPtr req, <a class="el" href="classThreadContext.html">ThreadContext</a> *tc, uint16_t asid, uint8_t _vmid, bool _isHyp, TLB::Mode mode, TLB::Translation *_trans, bool timing, bool functional, bool secure, TLB::ArmTranslationType tranType) </dt>
<dd>These should be cached or grabbed from cached copies in the TLB, all these miscreg reads are expensive </dd>
</dl>
<p><a class="anchor" id="_todo000012"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classBaseDynInst.html#a78a797b8c24ad873d0cbe5f52487b02f">BaseDynInst::_readySrcRegIdx</a>  </dt>
<dd>: Not sure this should be here vs the derived class. </dd>
</dl>
<p><a class="anchor" id="_todo000015"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classBaseDynInst.html#a9a56f3bdfd0d5b331356265c62556516">BaseDynInst::doneTargCalc</a> () </dt>
<dd>: Actually use this instruction. </dd>
</dl>
<p><a class="anchor" id="_todo000016"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classBaseDynInst.html#aa705cf7e79a21c2352b00ffe20cd295fab6d9bd536d2399d9e48ceac11630df4d">BaseDynInst::EACalcDone</a>  </dt>
<dd>: Consider if this is necessary or not. </dd>
</dl>
<p><a class="anchor" id="_todo000013"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classBaseDynInst.html#aaa54d2440fad0984a0a8edbcade8c26f">BaseDynInst::instEffAddr</a>  </dt>
<dd>: Consider if this is necessary or not. </dd>
</dl>
<p><a class="anchor" id="_todo000014"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classBaseDynInst.html#af3d4e52aa8ea0b526cd9f78f67127f36">BaseDynInst::renameSrcReg</a> (int idx, PhysRegIndex renamed_src) </dt>
<dd>: add in whether or not the source register is ready. </dd>
</dl>
<p><a class="anchor" id="_todo000028"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classBaseO3DynInst.html#a654e99f2be7cd298378462ce9651bb44">BaseO3DynInst::setIntRegOperand</a> (const <a class="el" href="classStaticInst.html">StaticInst</a> *si, int idx, uint64_t val) </dt>
<dd>: Make results into arrays so they can handle multiple dest registers. </dd>
</dl>
<p><a class="anchor" id="_todo000079"></a> </p>
<dl>
<dt>メンバ <a class="el" href="group__CacheStatistics.html#gadbcb32891448d652807958d7d79cac39">BaseTags::avgRefs</a>  </dt>
<dd>This should change to an average stat once we have them. </dd>
</dl>
<p><a class="anchor" id="_todo000048"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classBPredUnit.html#ab00dd76dc9f830cdae0edc72357c013a">BPredUnit::update</a> (Addr instPC, bool taken, void *bp_history, bool squashed)=0 </dt>
<dd>Make this update flexible enough to handle a global predictor. </dd>
</dl>
<p><a class="anchor" id="_todo000074"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classCache.html#a21da4bea3554874b557428e4cce5d4a4">Cache::pendingDelete</a>  </dt>
<dd>this is a temporary workaround until the 4-phase code is committed. upstream caches need this packet until true is returned, so hold it for deletion until a subsequent call </dd>
</dl>
<p><a class="anchor" id="_todo000075"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classCache.html#a3344d9dd0f83257feab5424e761f31c6">Cache::recvTimingReq</a> (PacketPtr pkt) </dt>
<dd><p class="startdd">temporary hack to deal with memory corruption issue until 4-phase transactions are complete </p>
<p>nominally we should just delete the packet here, however, until 4-phase stuff we can't because sending cache is still relying on it </p>
<p class="enddd">nominally we should just delete the packet here, however, until 4-phase stuff we can't because sending cache is still relying on it </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000073"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classCacheBlk.html#abc95fb2bad5b94ceca590f7dacd269b5">CacheBlk::set</a>  </dt>
<dd>Move this into subclasses when we fix CacheTags to use them. </dd>
</dl>
<p><a class="anchor" id="_todo000005"></a> </p>
<dl>
<dt>メンバ <a class="el" href="namespaceX86ISA.html#ae196a751ba59507ee189f66f87f62de1">convX87XTagsToTags</a>  </dt>
<dd><p class="startdd">Reconstruct the correct state of stack positions instead of just valid/invalid.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000026"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classDefaultCommit.html#a89ef54d73dbded95395181561013b0b6">DefaultCommit::commitSquashEvents</a>  </dt>
<dd>: Actually increment this stat. </dd>
</dl>
<p><a class="anchor" id="_todo000083"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classDRAMCtrl.html#a21da4bea3554874b557428e4cce5d4a4">DRAMCtrl::pendingDelete</a>  </dt>
<dd>this is a temporary workaround until the 4-phase code is committed. upstream caches needs this packet until true is returned, so hold onto it for deletion until a subsequent call </dd>
</dl>
<p><a class="anchor" id="_todo000082"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classDRAMCtrl.html#a3344d9dd0f83257feab5424e761f31c6">DRAMCtrl::recvTimingReq</a> (PacketPtr pkt) </dt>
<dd>temporary hack to deal with memory corruption issues until 4-phase transactions are complete </dd>
</dl>
<p><a class="anchor" id="_todo000084"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classDRAMSim2.html#a21da4bea3554874b557428e4cce5d4a4">DRAMSim2::pendingDelete</a>  </dt>
<dd>this is a temporary workaround until the 4-phase code is committed. upstream caches needs this packet until true is returned, so hold onto it for deletion until a subsequent call </dd>
</dl>
<p><a class="anchor" id="_todo000091"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classEventQueue.html#adc925eabe90846085072915cc6c544c2">EventQueue::serviceEvents</a> (Tick when) </dt>
<dd>this assert is a good bug catcher. I need to make it true again. </dd>
</dl>
<p><a class="anchor" id="_todo000080"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classFALRU.html#ac07d4bdf71f061cd9dba907c905a9543">FALRU::print</a> () const  </dt>
<dd>Implement as in lru. Currently not used </dd>
</dl>
<p><a class="anchor" id="_todo000023"></a> </p>
<dl>
<dt>クラス <a class="el" href="classFetchSeqUnit_1_1FetchSeqEvent.html">FetchSeqEvent</a>  </dt>
<dd>: Add <a class="el" href="classResource.html">Resource</a> <a class="el" href="namespaceStats.html">Stats</a> Here </dd>
</dl>
<p><a class="anchor" id="_todo000027"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classFullO3CPU.html#a2d6a2bbae85e604392f43b3418cdec97">FullO3CPU::syscall</a> (int64_t callnum, ThreadID tid) </dt>
<dd>: Determine if this needs to be virtual. </dd>
</dl>
<p><a class="anchor" id="_todo000057"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classIdeDisk.html#aac34c7bd9c30398a876820e7bf616b72">IdeDisk::doDmaDataRead</a> () </dt>
<dd>we need to figure out what the delay actually will be </dd>
</dl>
<p><a class="anchor" id="_todo000058"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classIdeDisk.html#ae0d5ccabc77ef46a2850230fcf2e44de">IdeDisk::doDmaDataWrite</a> () </dt>
<dd>we need to figure out what the delay actually will be </dd>
</dl>
<p><a class="anchor" id="_todo000059"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classIdeDisk.html#a64f80702e39e45d2a65869911928c8ca">IdeDisk::startCommand</a> () </dt>
<dd>make this a scheduled event to simulate disk delay </dd>
</dl>
<p><a class="anchor" id="_todo000060"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classIdeDisk.html#a24fb6794cfae6f84b380080e7501959e">IdeDisk::updateState</a> (DevAction_t action) </dt>
<dd><p class="startdd">change this to a scheduled event to simulate disk delay </p>
<p class="enddd">change this to a scheduled event to simulate disk delay </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000006"></a> </p>
<dl>
<dt>ファイル <a class="el" href="inifile_8hh.html">inifile.hh</a>  </dt>
<dd>Change comments to match documentation style. </dd>
</dl>
<p><a class="anchor" id="_todo000017"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classInOrderDynInst.html#a125f1037e43155d592320e6c70a09b6b">InOrderDynInst::_readySrcRegIdx</a> [MaxInstSrcRegs] </dt>
<dd>: Not sure this should be here vs the derived class. </dd>
</dl>
<p><a class="anchor" id="_todo000018"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classInOrderDynInst.html#a9a56f3bdfd0d5b331356265c62556516">InOrderDynInst::doneTargCalc</a> () </dt>
<dd>: Actually use this instruction. </dd>
</dl>
<p><a class="anchor" id="_todo000021"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classInOrderDynInst.html#a4c89b34e605b9d5398d51e8d754035de">InOrderDynInst::eaCalcDone</a>  </dt>
<dd>: Consider if this is necessary or not. </dd>
</dl>
<p><a class="anchor" id="_todo000020"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classInOrderDynInst.html#aaa54d2440fad0984a0a8edbcade8c26f">InOrderDynInst::instEffAddr</a>  </dt>
<dd>: Consider if this is necessary or not. </dd>
</dl>
<p><a class="anchor" id="_todo000019"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classInOrderDynInst.html#af3d4e52aa8ea0b526cd9f78f67127f36">InOrderDynInst::renameSrcReg</a> (int idx, PhysRegIndex renamed_src) </dt>
<dd>: add in whether or not the source register is ready. </dd>
</dl>
<p><a class="anchor" id="_todo000025"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classInOrderThreadContext.html#a13fa12d1779a94a1e0b968946a1367c7">InOrderThreadContext::dumpFuncProfile</a> () </dt>
<dd>: Implement. </dd>
</dl>
<p><a class="anchor" id="_todo000043"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classInstQueue.html#a92c8d68d5f0e17758f89daa2647196f5">InstQueue::commitToIEWDelay</a>  </dt>
<dd>: Make there be a distinction between the delays within IEW. </dd>
</dl>
<p><a class="anchor" id="_todo000042"></a> </p>
<dl>
<dt>クラス <a class="el" href="classInstQueue.html">InstQueue&lt; Impl &gt;</a>  </dt>
<dd>: Make IQ able to handle multiple FU pools. </dd>
</dl>
<p><a class="anchor" id="_todo000032"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classInstructionQueue.html#a6b6fe1148ed7c40758e45f351c375552">InstructionQueue::commitToIEWDelay</a>  </dt>
<dd>: Make there be a distinction between the delays within IEW. </dd>
</dl>
<p><a class="anchor" id="_todo000031"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classInstructionQueue.html#afd5860c9cc9c225411df38dd3dc89b87">InstructionQueue::listOrder</a>  </dt>
<dd>: Might be better to just move these entries around instead of creating new ones every time the position changes due to an instruction issuing. Not sure <a class="el" href="classstd_1_1list.html">std::list</a> supports this. </dd>
</dl>
<p><a class="anchor" id="_todo000033"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classInstructionQueue.html#a90810f5beb7dff46f4b45f96620474b6">InstructionQueue::numIssuedDist</a>  </dt>
<dd>: Need to create struct to track the entry time for each instruction. </dd>
</dl>
<p><a class="anchor" id="_todo000034"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classInstructionQueue.html#a92266bfdbc9a6de5005fc3f1654e0b3e">InstructionQueue::statFuBusy</a>  </dt>
<dd>: Need to create struct to track the ready time for each instruction. </dd>
</dl>
<p><a class="anchor" id="_todo000030"></a> </p>
<dl>
<dt>クラス <a class="el" href="classInstructionQueue.html">InstructionQueue&lt; Impl &gt;</a>  </dt>
<dd>: Make IQ able to handle multiple FU pools. </dd>
</dl>
<p><a class="anchor" id="_todo000001"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classLinuxAlphaSystem.html#a3c34ea9b29f410748d4435a667484924">LinuxAlphaSystem::initState</a> () </dt>
<dd>At some point we should change <a class="el" href="ev5_8hh.html">ev5.hh</a> and the palcode to support 255 ASNs. </dd>
</dl>
<p><a class="anchor" id="_todo000081"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classLRU.html#ad9acf3c29ee59e97dd4b0b73d560f382">LRU::LRU</a> (const Params *p) </dt>
<dd>Make warmup percentage a parameter. </dd>
</dl>
<p><a class="anchor" id="_todo000038"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classLSQUnit.html#ab2e23636971c40e7ed945026b2a184e1">LSQUnit::cachePorts</a>  </dt>
<dd>Consider moving to a more advanced model with write vs read ports </dd>
</dl>
<p><a class="anchor" id="_todo000039"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classLSQUnit.html#a15239c5725d8744a793c867193e4bce7">LSQUnit::checkViolations</a> (int load_idx, DynInstPtr &amp;inst) </dt>
<dd>in theory you only need to check an instruction that has executed however, there isn't a good way in the pipeline at the moment to check all instructions that will execute before the store writes back. Thus, like the implementation that came before it, we're overly conservative. </dd>
</dl>
<p><a class="anchor" id="_todo000036"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classLSQUnit.html#aafa99d800d574095881acbacdbbbcc47">LSQUnit::LQEntries</a>  </dt>
<dd>: Consider having var that records the true number of LQ entries. </dd>
</dl>
<p><a class="anchor" id="_todo000037"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classLSQUnit.html#a38c8af5392da70119dc5cce4e3637cbc">LSQUnit::SQEntries</a>  </dt>
<dd>: Consider having var that records the true number of SQ entries. </dd>
</dl>
<p><a class="anchor" id="_todo000035"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classLSQUnit.html#a873dd91783f9efb4a590aded1f70d6b0">LSQUnit::tick</a> () </dt>
<dd>: Move the number of used ports up to the <a class="el" href="classLSQ.html">LSQ</a> level so it can be shared by all <a class="el" href="classLSQ.html">LSQ</a> units. </dd>
</dl>
<p><a class="anchor" id="_todo000065"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classMaltaPChip.html#a5de3f8c8c47bf4bb58e072f54f4a7cba">MaltaPChip::translatePciToDma</a> (Addr busAddr) </dt>
<dd><p class="startdd">Andrew says this needs to be fixed. What's wrong with it? </p>
<p class="enddd">This currently is faked by just doing a direct read from memory, however, to be realistic, this needs to actually do a bus transaction. The process is explained in the malta documentation on page 10-12 and basically munges the address to look up a PTE from a table in memory and then uses that mapping to create an address for the SG page </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000078"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classMSHRQueue.html#a020dd5bb628863baf3800f816cfba197">MSHRQueue::findMatches</a> (Addr addr, bool is_secure, std::vector&lt; MSHR * &gt; &amp;matches) const  </dt>
<dd>Typedef the vector?? </dd>
</dl>
<p><a class="anchor" id="_todo000066"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classNSGigE.html#af1fc872917f4ac5efa0d55c5c139bc9a">NSGigE::cpuIntrPost</a> (Tick when) </dt>
<dd>this warning should be removed and the intrTick code should be fixed. </dd>
</dl>
<p><a class="anchor" id="_todo000067"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classNSGigE.html#a5fa946a73db6f59c9819d457c991486a">NSGigE::rxKick</a> () </dt>
<dd><p class="startdd">in reality, we should be able to start processing the packet as it arrives, and not have to wait for the full packet ot be in the receive fifo. </p>
<p class="enddd">do we want to schedule a future kick? </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000069"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classNSGigE.html#ac5484e8debdd6a2d3cf4c2902b832a76">NSGigE::txKick</a> () </dt>
<dd>do we want to schedule a future kick? </dd>
</dl>
<p><a class="anchor" id="_todo000040"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classO3ThreadContext.html#a13fa12d1779a94a1e0b968946a1367c7">O3ThreadContext::dumpFuncProfile</a> () </dt>
<dd>: Implement. </dd>
</dl>
<p><a class="anchor" id="_todo000041"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classOzoneDynInst.html#a654e99f2be7cd298378462ce9651bb44">OzoneDynInst::setIntRegOperand</a> (const <a class="el" href="classStaticInst.html">StaticInst</a> *si, int idx, uint64_t val) </dt>
<dd>: Make results into arrays so they can handle multiple dest registers. </dd>
</dl>
<p><a class="anchor" id="_todo000045"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classOzoneLSQ.html#ab2e23636971c40e7ed945026b2a184e1">OzoneLSQ::cachePorts</a>  </dt>
<dd>Consider moving to a more advanced model with write vs read ports </dd>
</dl>
<p><a class="anchor" id="_todo000044"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classOzoneLSQ.html#a873dd91783f9efb4a590aded1f70d6b0">OzoneLSQ::tick</a> () </dt>
<dd>: Move the number of used ports up to the <a class="el" href="classLSQ.html">LSQ</a> level so it can be shared by all <a class="el" href="classLSQ.html">LSQ</a> units. </dd>
</dl>
<p><a class="anchor" id="_todo000047"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classOzoneLWLSQ.html#ab2e23636971c40e7ed945026b2a184e1">OzoneLWLSQ::cachePorts</a>  </dt>
<dd>Consider moving to a more advanced model with write vs read ports </dd>
</dl>
<p><a class="anchor" id="_todo000046"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classOzoneLWLSQ.html#a873dd91783f9efb4a590aded1f70d6b0">OzoneLWLSQ::tick</a> () </dt>
<dd>: Move the number of used ports up to the <a class="el" href="classLSQ.html">LSQ</a> level so it can be shared by all <a class="el" href="classLSQ.html">LSQ</a> units. </dd>
</dl>
<p><a class="anchor" id="_todo000056"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classPl011.html#a57f9c26cb4108beccb35bb1938990932">Pl011::intStatus</a> () </dt>
<dd>fix me when implementation improves </dd>
</dl>
<p><a class="anchor" id="_todo000054"></a> </p>
<dl>
<dt>クラス <a class="el" href="classPl390.html">Pl390</a>  </dt>
<dd>this code only assumes one processor for now. Low word of intEnabled and pendingInt need to be replicated per CPU. bottom 31 interrupts (7 words) need to be replicated for for interrupt priority register, processor target registers interrupt config registers </dd>
</dl>
<p><a class="anchor" id="_todo000055"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classPl390.html#a604af0bb85a2a3f90c842febc7e8f87d">Pl390::cpuAddr</a>  </dt>
<dd>is this one per cpu? </dd>
</dl>
<p><a class="anchor" id="_todo000053"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classPl390.html#a4eccad5b19d64abe6178573f999b2b3b">Pl390::readDistributor</a> (PacketPtr pkt) </dt>
<dd>software generated interrutps and PPIs can't be configured in some ways </dd>
</dl>
<p><a class="anchor" id="_todo000008"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classRefCounted.html#ae6cca02ff208ebb8704f20b56e6de02b">RefCounted::~RefCounted</a> () </dt>
<dd>Even if this were true, does it matter? Shouldn't the derived class indicate this? This only matters if we would ever choose to delete a "RefCounted *" which I doubt we'd ever do. We don't ever delete a "void *". </dd>
</dl>
<p><a class="anchor" id="_todo000085"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classRequest.html#a1bb5b2ea96370ac4071dbe85cc9883c8">Request::invldMasterId</a>  </dt>
<dd>C++1x replace with numeric_limits when constexpr is added </dd>
</dl>
<p><a class="anchor" id="_todo000049"></a> </p>
<dl>
<dt>クラス <a class="el" href="classSatCounter.html">SatCounter</a>  </dt>
<dd>Consider making this something that more closely mimics a built in class so you can use ++ or --. </dd>
</dl>
<p><a class="anchor" id="_todo000087"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classSimpleMemory.html#a21da4bea3554874b557428e4cce5d4a4">SimpleMemory::pendingDelete</a>  </dt>
<dd>this is a temporary workaround until the 4-phase code is committed. upstream caches needs this packet until true is returned, so hold onto it for deletion until a subsequent call </dd>
</dl>
<p><a class="anchor" id="_todo000086"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classSimpleMemory.html#a3344d9dd0f83257feab5424e761f31c6">SimpleMemory::recvTimingReq</a> (PacketPtr pkt) </dt>
<dd>temporary hack to deal with memory corruption issues until 4-phase transactions are complete </dd>
</dl>
<p><a class="anchor" id="_todo000090"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classSimpleTimingPort.html#a21da4bea3554874b557428e4cce5d4a4">SimpleTimingPort::pendingDelete</a>  </dt>
<dd>this is a temporary workaround until the 4-phase code is committed. upstream caches need this packet until true is returned, so hold it for deletion until a subsequent call </dd>
</dl>
<p><a class="anchor" id="_todo000088"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classSimpleTimingPort.html#a3344d9dd0f83257feab5424e761f31c6">SimpleTimingPort::recvTimingReq</a> (PacketPtr pkt) </dt>
<dd><p class="startdd">temporary hack to deal with memory corruption issue until 4-phase transactions are complete. Remove me later </p>
<p class="enddd">nominally we should just delete the packet here. Until 4-phase stuff we can't because the sending cache is still relying on it </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000070"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classSinic_1_1Base.html#af1fc872917f4ac5efa0d55c5c139bc9a">Sinic::Base::cpuIntrPost</a> (Tick when) </dt>
<dd>this warning should be removed and the intrTick code should be fixed. </dd>
</dl>
<p><a class="anchor" id="_todo000071"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classSinic_1_1Device.html#a5fa946a73db6f59c9819d457c991486a">Sinic::Device::rxKick</a> () </dt>
<dd>do we want to schedule a future kick? </dd>
</dl>
<p><a class="anchor" id="_todo000072"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classSinic_1_1Device.html#ac5484e8debdd6a2d3cf4c2902b832a76">Sinic::Device::txKick</a> () </dt>
<dd>do we want to schedule a future kick? </dd>
</dl>
<p><a class="anchor" id="_todo000052"></a> </p>
<dl>
<dt>クラス <a class="el" href="classGenericTimer_1_1SystemCounter.html">SystemCounter</a>  </dt>
<dd>: implement memory-mapped controls </dd>
</dl>
<p><a class="anchor" id="_todo000051"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classTsunamiPChip.html#a5de3f8c8c47bf4bb58e072f54f4a7cba">TsunamiPChip::translatePciToDma</a> (Addr busAddr) </dt>
<dd><p class="startdd">Andrew says this needs to be fixed. What's wrong with it? </p>
<p class="enddd">This currently is faked by just doing a direct read from memory, however, to be realistic, this needs to actually do a bus transaction. The process is explained in the tsunami documentation on page 10-12 and basically munges the address to look up a PTE from a table in memory and then uses that mapping to create an address for the SG page </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000029"></a> </p>
<dl>
<dt>クラス <a class="el" href="classUnifiedFreeList.html">UnifiedFreeList</a>  </dt>
<dd>: Give a better name to the base FP dependency. </dd>
</dl>
<p><a class="anchor" id="_todo000011"></a> </p>
<dl>
<dt>メンバ <a class="el" href="classVncServer.html#a12fdf8396c8fe33bb93e66d7491fb497">VncServer::sendFrameBufferUpdate</a> () </dt>
<dd>this doesn't do anything smart and just sends the entire image </dd>
</dl>
</div>
<hr size="1"/><address style="text-align: right;"><small>File&nbsp;GEM5&nbsp;Wrapperに対して25 May 2015に生成されました。&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
