\hypertarget{classUart8250}{
\section{クラス Uart8250}
\label{classUart8250}\index{Uart8250@{Uart8250}}
}


{\ttfamily \#include $<$uart8250.hh$>$}Uart8250に対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=8cm]{classUart8250}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classUart8250_1_1IntrEvent}{IntrEvent}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef Uart8250Params \hyperlink{classUart8250_aa413e69885bd7a520ee8b988aa3e1c8b}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
const \hyperlink{classUart8250_aa413e69885bd7a520ee8b988aa3e1c8b}{Params} $\ast$ \hyperlink{classUart8250_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{classUart8250_a199a0b3907670a9f201d8123ce9bbcda}{Uart8250} (const \hyperlink{classUart8250_aa413e69885bd7a520ee8b988aa3e1c8b}{Params} $\ast$p)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classUart8250_a613ec7d5e1ec64f8d21fec78ae8e568e}{read} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classUart8250_a4cefab464e72b5dd42c003a0a4341802}{write} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classUart8250_a36cf113d5e5e091ebddb32306c098fae}{getAddrRanges} () const 
\item 
virtual void \hyperlink{classUart8250_a603e184f4f31471b76cff54303262aa8}{dataAvailable} ()
\item 
virtual bool \hyperlink{classUart8250_a57f9c26cb4108beccb35bb1938990932}{intStatus} ()
\item 
virtual void \hyperlink{classUart8250_ad6272f80ae37e8331e3969b3f072a801}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classUart8250_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
uint8\_\-t \hyperlink{classUart8250_a0d2e65bc658b3afbf973a7d17b1a1141}{IER}
\item 
uint8\_\-t \hyperlink{classUart8250_a6f5a5913f717a1e7b5c873b039943e71}{DLAB}
\item 
uint8\_\-t \hyperlink{classUart8250_aa9c639e7ed5a83c1914831868650c332}{LCR}
\item 
uint8\_\-t \hyperlink{classUart8250_a87b7c2c55a7f4f90bfb8d7220e9ef4fd}{MCR}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classUart8250_a21681e52ffddf9836e26b311b3d66179}{lastTxInt}
\item 
\hyperlink{classUart8250_1_1IntrEvent}{IntrEvent} \hyperlink{classUart8250_a619f722020680f8c7380685b753493b8}{txIntrEvent}
\item 
\hyperlink{classUart8250_1_1IntrEvent}{IntrEvent} \hyperlink{classUart8250_a15bed45cc2f52bb7b1f571124937ef23}{rxIntrEvent}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classUart8250_aa413e69885bd7a520ee8b988aa3e1c8b}{
\index{Uart8250@{Uart8250}!Params@{Params}}
\index{Params@{Params}!Uart8250@{Uart8250}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef Uart8250Params {\bf Params}}}
\label{classUart8250_aa413e69885bd7a520ee8b988aa3e1c8b}


\hyperlink{classUart_a20a580db9778bd0604704c3c6baabfa6}{Uart}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classUart8250_a199a0b3907670a9f201d8123ce9bbcda}{
\index{Uart8250@{Uart8250}!Uart8250@{Uart8250}}
\index{Uart8250@{Uart8250}!Uart8250@{Uart8250}}
\subsubsection[{Uart8250}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Uart8250} (const {\bf Params} $\ast$ {\em p})}}
\label{classUart8250_a199a0b3907670a9f201d8123ce9bbcda}



\begin{DoxyCode}
105     : Uart(p, 8), IER(0), DLAB(0), LCR(0), MCR(0), lastTxInt(0),
106       txIntrEvent(this, TX_INT), rxIntrEvent(this, RX_INT)
107 {
108 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classUart8250_a603e184f4f31471b76cff54303262aa8}{
\index{Uart8250@{Uart8250}!dataAvailable@{dataAvailable}}
\index{dataAvailable@{dataAvailable}!Uart8250@{Uart8250}}
\subsubsection[{dataAvailable}]{\setlength{\rightskip}{0pt plus 5cm}void dataAvailable ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classUart8250_a603e184f4f31471b76cff54303262aa8}
Inform the uart that there is data available. 

\hyperlink{classUart_a8e0026e4db90ce7efbddf2835f411b0b}{Uart}を実装しています。


\begin{DoxyCode}
278 {
279     // if the kernel wants an interrupt when we have data
280     if (IER & UART_IER_RDI)
281     {
282         platform->postConsoleInt();
283         status |= RX_INT;
284     }
285 
286 }
\end{DoxyCode}
\hypertarget{classUart8250_a36cf113d5e5e091ebddb32306c098fae}{
\index{Uart8250@{Uart8250}!getAddrRanges@{getAddrRanges}}
\index{getAddrRanges@{getAddrRanges}!Uart8250@{Uart8250}}
\subsubsection[{getAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRangeList} getAddrRanges () const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classUart8250_a36cf113d5e5e091ebddb32306c098fae}
Determine the address ranges that this device responds to.

\begin{DoxyReturn}{戻り値}
a list of non-\/overlapping address ranges 
\end{DoxyReturn}


\hyperlink{classBasicPioDevice_a36cf113d5e5e091ebddb32306c098fae}{BasicPioDevice}を再定義しています。


\begin{DoxyCode}
290 {
291     AddrRangeList ranges;
292     ranges.push_back(RangeSize(pioAddr, pioSize));
293     return ranges;
294 }
\end{DoxyCode}
\hypertarget{classUart8250_a57f9c26cb4108beccb35bb1938990932}{
\index{Uart8250@{Uart8250}!intStatus@{intStatus}}
\index{intStatus@{intStatus}!Uart8250@{Uart8250}}
\subsubsection[{intStatus}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool intStatus ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classUart8250_a57f9c26cb4108beccb35bb1938990932}
Return if we have an interrupt pending \begin{DoxyReturn}{戻り値}
interrupt status 
\end{DoxyReturn}


\hyperlink{classUart_a73c7d9c634e4c31cda71a6dd2fa67381}{Uart}を再定義しています。


\begin{DoxyCode}
114 { return status ? true : false; }
\end{DoxyCode}
\hypertarget{classUart8250_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{Uart8250@{Uart8250}!params@{params}}
\index{params@{params}!Uart8250@{Uart8250}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classUart8250_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classUart_acd3c3feb78ae7a8f88fe0f110a718dff}{Uart}を再定義しています。


\begin{DoxyCode}
95     {
96         return dynamic_cast<const Params *>(_params);
97     }
\end{DoxyCode}
\hypertarget{classUart8250_a613ec7d5e1ec64f8d21fec78ae8e568e}{
\index{Uart8250@{Uart8250}!read@{read}}
\index{read@{read}!Uart8250@{Uart8250}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} read ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classUart8250_a613ec7d5e1ec64f8d21fec78ae8e568e}
Pure virtual function that the device must implement. Called when a read command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_a842312590432036092c422c87a442358}{PioDevice}を実装しています。


\begin{DoxyCode}
112 {
113     assert(pkt->getAddr() >= pioAddr && pkt->getAddr() < pioAddr + pioSize);
114     assert(pkt->getSize() == 1);
115 
116     Addr daddr = pkt->getAddr() - pioAddr;
117     pkt->allocate();
118 
119     DPRINTF(Uart, " read register %#x\n", daddr);
120 
121     switch (daddr) {
122         case 0x0:
123             if (!(LCR & 0x80)) { // read byte
124                 if (term->dataAvailable())
125                     pkt->set(term->in());
126                 else {
127                     pkt->set((uint8_t)0);
128                     // A limited amount of these are ok.
129                     DPRINTF(Uart, "empty read of RX register\n");
130                 }
131                 status &= ~RX_INT;
132                 platform->clearConsoleInt();
133 
134                 if (term->dataAvailable() && (IER & UART_IER_RDI))
135                     rxIntrEvent.scheduleIntr();
136             } else { // dll divisor latch
137                ;
138             }
139             break;
140         case 0x1:
141             if (!(LCR & 0x80)) { // Intr Enable Register(IER)
142                 pkt->set(IER);
143             } else { // DLM divisor latch MSB
144                 ;
145             }
146             break;
147         case 0x2: // Intr Identification Register (IIR)
148             DPRINTF(Uart, "IIR Read, status = %#x\n", (uint32_t)status);
149 
150             if (status & RX_INT) /* Rx data interrupt has a higher priority */
151                 pkt->set(IIR_RXID);
152             else if (status & TX_INT) {
153                 pkt->set(IIR_TXID);
154                 //Tx interrupts are cleared on IIR reads
155                 status &= ~TX_INT;
156             } else
157                 pkt->set(IIR_NOPEND);
158 
159             break;
160         case 0x3: // Line Control Register (LCR)
161             pkt->set(LCR);
162             break;
163         case 0x4: // Modem Control Register (MCR)
164             pkt->set(MCR);
165             break;
166         case 0x5: // Line Status Register (LSR)
167             uint8_t lsr;
168             lsr = 0;
169             // check if there are any bytes to be read
170             if (term->dataAvailable())
171                 lsr = UART_LSR_DR;
172             lsr |= UART_LSR_TEMT | UART_LSR_THRE;
173             pkt->set(lsr);
174             break;
175         case 0x6: // Modem Status Register (MSR)
176             pkt->set((uint8_t)0);
177             break;
178         case 0x7: // Scratch Register (SCR)
179             pkt->set((uint8_t)0); // doesn't exist with at 8250.
180             break;
181         default:
182             panic("Tried to access a UART port that doesn't exist\n");
183             break;
184     }
185 /*    uint32_t d32 = *data;
186     DPRINTF(Uart, "Register read to register %#x returned %#x\n", daddr, d32);
187 */
188     pkt->makeAtomicResponse();
189     return pioDelay;
190 }
\end{DoxyCode}
\hypertarget{classUart8250_ad6272f80ae37e8331e3969b3f072a801}{
\index{Uart8250@{Uart8250}!serialize@{serialize}}
\index{serialize@{serialize}!Uart8250@{Uart8250}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}virtual void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classUart8250_ad6272f80ae37e8331e3969b3f072a801}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。\hypertarget{classUart8250_af22e5d6d660b97db37003ac61ac4ee49}{
\index{Uart8250@{Uart8250}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!Uart8250@{Uart8250}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classUart8250_af22e5d6d660b97db37003ac61ac4ee49}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。


\begin{DoxyCode}
320 {
321     UNSERIALIZE_SCALAR(status);
322     UNSERIALIZE_SCALAR(IER);
323     UNSERIALIZE_SCALAR(DLAB);
324     UNSERIALIZE_SCALAR(LCR);
325     UNSERIALIZE_SCALAR(MCR);
326     Tick rxintrwhen;
327     Tick txintrwhen;
328     UNSERIALIZE_SCALAR(rxintrwhen);
329     UNSERIALIZE_SCALAR(txintrwhen);
330     if (rxintrwhen != 0)
331         schedule(rxIntrEvent, rxintrwhen);
332     if (txintrwhen != 0)
333         schedule(txIntrEvent, txintrwhen);
334 }
\end{DoxyCode}
\hypertarget{classUart8250_a4cefab464e72b5dd42c003a0a4341802}{
\index{Uart8250@{Uart8250}!write@{write}}
\index{write@{write}!Uart8250@{Uart8250}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} write ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classUart8250_a4cefab464e72b5dd42c003a0a4341802}
Pure virtual function that the device must implement. Called when a write command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_afe8371668d023bb2516b286e5e399b6f}{PioDevice}を実装しています。


\begin{DoxyCode}
194 {
195 
196     assert(pkt->getAddr() >= pioAddr && pkt->getAddr() < pioAddr + pioSize);
197     assert(pkt->getSize() == 1);
198 
199     Addr daddr = pkt->getAddr() - pioAddr;
200 
201     DPRINTF(Uart, " write register %#x value %#x\n", daddr, pkt->get<uint8_t>());
      
202 
203     switch (daddr) {
204         case 0x0:
205             if (!(LCR & 0x80)) { // write byte
206                 term->out(pkt->get<uint8_t>());
207                 platform->clearConsoleInt();
208                 status &= ~TX_INT;
209                 if (UART_IER_THRI & IER)
210                     txIntrEvent.scheduleIntr();
211             } else { // dll divisor latch
212                ;
213             }
214             break;
215         case 0x1:
216             if (!(LCR & 0x80)) { // Intr Enable Register(IER)
217                 IER = pkt->get<uint8_t>();
218                 if (UART_IER_THRI & IER)
219                 {
220                     DPRINTF(Uart, "IER: IER_THRI set, scheduling TX intrrupt\n");
      
221                     if (curTick() - lastTxInt > 225 * SimClock::Int::ns) {
222                         DPRINTF(Uart, "-- Interrupting Immediately... %d,%d\n",
223                                 curTick(), lastTxInt);
224                         txIntrEvent.process();
225                     } else {
226                         DPRINTF(Uart, "-- Delaying interrupt... %d,%d\n",
227                                 curTick(), lastTxInt);
228                         txIntrEvent.scheduleIntr();
229                     }
230                 }
231                 else
232                 {
233                     DPRINTF(Uart, "IER: IER_THRI cleared, descheduling TX intrrup
      t\n");
234                     if (txIntrEvent.scheduled())
235                         deschedule(txIntrEvent);
236                     if (status & TX_INT)
237                         platform->clearConsoleInt();
238                     status &= ~TX_INT;
239                 }
240 
241                 if ((UART_IER_RDI & IER) && term->dataAvailable()) {
242                     DPRINTF(Uart, "IER: IER_RDI set, scheduling RX intrrupt\n");
243                     rxIntrEvent.scheduleIntr();
244                 } else {
245                     DPRINTF(Uart, "IER: IER_RDI cleared, descheduling RX intrrupt
      \n");
246                     if (rxIntrEvent.scheduled())
247                         deschedule(rxIntrEvent);
248                     if (status & RX_INT)
249                         platform->clearConsoleInt();
250                     status &= ~RX_INT;
251                 }
252              } else { // DLM divisor latch MSB
253                 ;
254             }
255             break;
256         case 0x2: // FIFO Control Register (FCR)
257             break;
258         case 0x3: // Line Control Register (LCR)
259             LCR = pkt->get<uint8_t>();
260             break;
261         case 0x4: // Modem Control Register (MCR)
262             if (pkt->get<uint8_t>() == (UART_MCR_LOOP | 0x0A))
263                     MCR = 0x9A;
264             break;
265         case 0x7: // Scratch Register (SCR)
266             // We are emulating a 8250 so we don't have a scratch reg
267             break;
268         default:
269             panic("Tried to access a UART port that doesn't exist\n");
270             break;
271     }
272     pkt->makeAtomicResponse();
273     return pioDelay;
274 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classUart8250_a6f5a5913f717a1e7b5c873b039943e71}{
\index{Uart8250@{Uart8250}!DLAB@{DLAB}}
\index{DLAB@{DLAB}!Uart8250@{Uart8250}}
\subsubsection[{DLAB}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf DLAB}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUart8250_a6f5a5913f717a1e7b5c873b039943e71}
\hypertarget{classUart8250_a0d2e65bc658b3afbf973a7d17b1a1141}{
\index{Uart8250@{Uart8250}!IER@{IER}}
\index{IER@{IER}!Uart8250@{Uart8250}}
\subsubsection[{IER}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf IER}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUart8250_a0d2e65bc658b3afbf973a7d17b1a1141}
\hypertarget{classUart8250_a21681e52ffddf9836e26b311b3d66179}{
\index{Uart8250@{Uart8250}!lastTxInt@{lastTxInt}}
\index{lastTxInt@{lastTxInt}!Uart8250@{Uart8250}}
\subsubsection[{lastTxInt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf lastTxInt}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUart8250_a21681e52ffddf9836e26b311b3d66179}
\hypertarget{classUart8250_aa9c639e7ed5a83c1914831868650c332}{
\index{Uart8250@{Uart8250}!LCR@{LCR}}
\index{LCR@{LCR}!Uart8250@{Uart8250}}
\subsubsection[{LCR}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf LCR}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUart8250_aa9c639e7ed5a83c1914831868650c332}
\hypertarget{classUart8250_a87b7c2c55a7f4f90bfb8d7220e9ef4fd}{
\index{Uart8250@{Uart8250}!MCR@{MCR}}
\index{MCR@{MCR}!Uart8250@{Uart8250}}
\subsubsection[{MCR}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf MCR}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUart8250_a87b7c2c55a7f4f90bfb8d7220e9ef4fd}
\hypertarget{classUart8250_a15bed45cc2f52bb7b1f571124937ef23}{
\index{Uart8250@{Uart8250}!rxIntrEvent@{rxIntrEvent}}
\index{rxIntrEvent@{rxIntrEvent}!Uart8250@{Uart8250}}
\subsubsection[{rxIntrEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IntrEvent} {\bf rxIntrEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUart8250_a15bed45cc2f52bb7b1f571124937ef23}
\hypertarget{classUart8250_a619f722020680f8c7380685b753493b8}{
\index{Uart8250@{Uart8250}!txIntrEvent@{txIntrEvent}}
\index{txIntrEvent@{txIntrEvent}!Uart8250@{Uart8250}}
\subsubsection[{txIntrEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IntrEvent} {\bf txIntrEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classUart8250_a619f722020680f8c7380685b753493b8}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/\hyperlink{uart8250_8hh}{uart8250.hh}\item 
dev/\hyperlink{uart8250_8cc}{uart8250.cc}\end{DoxyCompactItemize}
