\hypertarget{classBaseCache}{
\section{クラス BaseCache}
\label{classBaseCache}\index{BaseCache@{BaseCache}}
}


{\ttfamily \#include $<$base.hh$>$}BaseCacheに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=6cm]{classBaseCache}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classBaseCache_1_1BaseCache}{BaseCache}
\item 
class \hyperlink{classBaseCache_1_1CacheMasterPort}{CacheMasterPort}
\item 
class \hyperlink{classBaseCache_1_1CacheSlavePort}{CacheSlavePort}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classBaseCache_a98297f294858ead7eafd19af93e64c6d}{BlockedCause} \{ \hyperlink{classBaseCache_a98297f294858ead7eafd19af93e64c6dab669a177c35c6b5166465c9e93eb71e7}{Blocked\_\-NoMSHRs} =  MSHRQueue\_\-MSHRs, 
\hyperlink{classBaseCache_a98297f294858ead7eafd19af93e64c6da1e332cbac57efe6b49ce9a0ab5e3f0de}{Blocked\_\-NoWBBuffers} =  MSHRQueue\_\-WriteBuffer, 
\hyperlink{classBaseCache_a98297f294858ead7eafd19af93e64c6da2e0db8e863cb5a0c10b73be89a535323}{Blocked\_\-NoTargets}, 
\hyperlink{classBaseCache_a98297f294858ead7eafd19af93e64c6da444545819cad907e5fafbf1c940a3f3f}{NUM\_\-BLOCKED\_\-CAUSES}
 \}
\item 
enum \hyperlink{classBaseCache_a8ca466a3028d5dd05a9f31798a0115b8}{RequestCause} \{ \hyperlink{classBaseCache_a8ca466a3028d5dd05a9f31798a0115b8a28d46d22a1bfda7d140d0496e9cb399b}{Request\_\-MSHR} =  MSHRQueue\_\-MSHRs, 
\hyperlink{classBaseCache_a8ca466a3028d5dd05a9f31798a0115b8a2c4aab170dcb384c7424ee1e77411d24}{Request\_\-WB} =  MSHRQueue\_\-WriteBuffer, 
\hyperlink{classBaseCache_a8ca466a3028d5dd05a9f31798a0115b8ad591c96d60dbceaf75076c496d695d14}{Request\_\-PF}, 
\hyperlink{classBaseCache_a8ca466a3028d5dd05a9f31798a0115b8a836f2b395337a49406bc6709a8a2ff3a}{NUM\_\-REQUEST\_\-CAUSES}
 \}
\item 
typedef BaseCacheParams \hyperlink{classBaseCache_a23c1728f4d2cabb1996560194937d427}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classBaseCache_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
\hyperlink{classBaseCache_a6c1d60cbb9ab660c557bca8bfb40d768}{BaseCache} (const \hyperlink{classBaseCache_a23c1728f4d2cabb1996560194937d427}{Params} $\ast$p)
\item 
\hyperlink{classBaseCache_a9864fcb9f5632b2c250c18a2f6b9ac46}{$\sim$BaseCache} ()
\item 
virtual void \hyperlink{classBaseCache_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
virtual \hyperlink{classBaseMasterPort}{BaseMasterPort} \& \hyperlink{classBaseCache_adc4e675e51defbdd1e354dac729d0703}{getMasterPort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
virtual \hyperlink{classBaseSlavePort}{BaseSlavePort} \& \hyperlink{classBaseCache_ac918a145092d7514ebc6dbd952dceafb}{getSlavePort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
unsigned \hyperlink{classBaseCache_a38301abe4b3689f8ac7de5c13a046234}{getBlockSize} () const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classBaseCache_a676df8321350e810fc857d99cdcebc22}{blockAlign} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr) const 
\item 
const \hyperlink{classstd_1_1list}{AddrRangeList} \& \hyperlink{classBaseCache_a030a5d76880e3d3187c9f46971525d09}{getAddrRanges} () const 
\item 
\hyperlink{classMSHR}{MSHR} $\ast$ \hyperlink{classBaseCache_ac37432bbe5fab7cdf422ee29acf155f2}{allocateMissBuffer} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} time, bool requestBus)
\item 
\hyperlink{classMSHR}{MSHR} $\ast$ \hyperlink{classBaseCache_a3f81ca9ba6f7294f930eca229838edc6}{allocateWriteBuffer} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} time, bool requestBus)
\item 
\hyperlink{classMSHR}{MSHR} $\ast$ \hyperlink{classBaseCache_a8dfb4bae0c201cd12ca22dd159740541}{allocateUncachedReadBuffer} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} time, bool requestBus)
\item 
bool \hyperlink{classBaseCache_a798c4be15789e723465215258f41c29b}{isBlocked} () const 
\item 
void \hyperlink{classBaseCache_a79de24f2f3eda2cc3ac13f600d171bc0}{setBlocked} (\hyperlink{classBaseCache_a98297f294858ead7eafd19af93e64c6d}{BlockedCause} cause)
\item 
void \hyperlink{classBaseCache_a78948a7bd2b849859bfc6fee2fc3d070}{clearBlocked} (\hyperlink{classBaseCache_a98297f294858ead7eafd19af93e64c6d}{BlockedCause} cause)
\item 
void \hyperlink{classBaseCache_af0bf3b9e90ffddfd7762af4c5fd5247b}{requestMemSideBus} (\hyperlink{classBaseCache_a8ca466a3028d5dd05a9f31798a0115b8}{RequestCause} cause, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} time)
\item 
void \hyperlink{classBaseCache_a7eb041ca3a51fe243525b95dea36f813}{deassertMemSideBusRequest} (\hyperlink{classBaseCache_a8ca466a3028d5dd05a9f31798a0115b8}{RequestCause} cause)
\item 
virtual unsigned int \hyperlink{classBaseCache_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)
\item 
virtual bool \hyperlink{classBaseCache_a2ac85ef6d4c6f16111c1da31c2363aa7}{inCache} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, bool is\_\-secure) const =0
\item 
virtual bool \hyperlink{classBaseCache_abb47bf01a0bb0aa1c4e3d60fc2ca8175}{inMissQueue} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, bool is\_\-secure) const =0
\item 
void \hyperlink{classBaseCache_a998427ec80c26469aae228b0d6bd9bd0}{incMissCount} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classBaseCache_a5d0c42b459c95506252f8916dc4abc9c}{incHitCount} (\hyperlink{classPacket}{PacketPtr} pkt)
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSystem}{System} $\ast$ \hyperlink{classBaseCache_af27ccd765f13a4b7bd119dc7579e2746}{system}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{group__CacheStatistics_gad6a8ff96d397437943d0a35012008e84}{hits} \mbox{[}MemCmd::NUM\_\-MEM\_\-CMDS\mbox{]}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_gafc2d55cfff6a5b55a9c19bf5c7b13729}{demandHits}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_gaa4d78014f29a4bc534e1d71a1ada3bb8}{overallHits}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{group__CacheStatistics_gaef820137ee3e0d7ce5895019f76e1ad7}{misses} \mbox{[}MemCmd::NUM\_\-MEM\_\-CMDS\mbox{]}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_gab0c200c0250a66f1e1d8a257d3f9f313}{demandMisses}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_ga15889ae23e7332b01de9bc31e05a21e5}{overallMisses}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{group__CacheStatistics_gaf96751c776ee651f3284e22686b8978a}{missLatency} \mbox{[}MemCmd::NUM\_\-MEM\_\-CMDS\mbox{]}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_gaef1ab5073e901bd4df644ff0780fc668}{demandMissLatency}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_ga7d70913fe3dbd532369b977f9a28446c}{overallMissLatency}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_gaa45ed75982de310df369d8bfa4b8896f}{accesses} \mbox{[}MemCmd::NUM\_\-MEM\_\-CMDS\mbox{]}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_gae4b2f837d0d9919fe4ce7389922a001d}{demandAccesses}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_ga84cca53e5e12d55fe025a3a22bd77a28}{overallAccesses}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_gabe84abb4bee43d594923487ba5e013c1}{missRate} \mbox{[}MemCmd::NUM\_\-MEM\_\-CMDS\mbox{]}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_ga58de8cb7b3151d13ca30115eee7cd475}{demandMissRate}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_ga61b6b530510b172ca4c2774dd939debf}{overallMissRate}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_ga964a436d0a0ae4006fe5a8b418058e44}{avgMissLatency} \mbox{[}MemCmd::NUM\_\-MEM\_\-CMDS\mbox{]}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_ga4a5f08d40501e08ed841c65206fc7757}{demandAvgMissLatency}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_ga1246f7d24c92b2c043128804bb772c53}{overallAvgMissLatency}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{group__CacheStatistics_ga4acd5af734aeaacf375fb724164623a2}{blocked\_\-cycles}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{group__CacheStatistics_ga7868c651a1ef44806d546d9a018835cc}{blocked\_\-causes}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_ga61f8d4c8d21aa6b9347cb04bd401d05f}{avg\_\-blocked}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{group__CacheStatistics_gaaa4a7e9f5dcb48cc5a53ac2335e934b3}{fastWrites}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{group__CacheStatistics_ga733d9eeafaa8c6f179cf5ed460e36ce0}{cacheCopies}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{group__CacheStatistics_gace2b37e760e47862f243e4b03c05ef5e}{writebacks}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{group__CacheStatistics_ga92faf658f75559bd75a8839d4de1f8a9}{mshr\_\-hits} \mbox{[}MemCmd::NUM\_\-MEM\_\-CMDS\mbox{]}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_gaf118fca77a3f5d6f217fcee58c71fec2}{demandMshrHits}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_ga0fb9f1f22aa968d550eef9c03997ac18}{overallMshrHits}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{group__CacheStatistics_gaececf7d3c236db3a8f26999e5330a7f8}{mshr\_\-misses} \mbox{[}MemCmd::NUM\_\-MEM\_\-CMDS\mbox{]}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_ga378613cfcd9d1eb93a478cdfd5cfe47f}{demandMshrMisses}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_ga89bdc1747e7c539c145e1721f92e9077}{overallMshrMisses}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{group__CacheStatistics_gafef11db68765de904faaf296082e02e3}{mshr\_\-uncacheable} \mbox{[}MemCmd::NUM\_\-MEM\_\-CMDS\mbox{]}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_gac79654a6d31745d642afc7a53b5ea638}{overallMshrUncacheable}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{group__CacheStatistics_gacfad5551221a8363918fd4b484112695}{mshr\_\-miss\_\-latency} \mbox{[}MemCmd::NUM\_\-MEM\_\-CMDS\mbox{]}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_ga9bba866a0a6f9d08968ea7793e1718d3}{demandMshrMissLatency}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_ga54ac605e36884492867f19da4de6b8d3}{overallMshrMissLatency}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{group__CacheStatistics_ga7dd6d70b9cba9493a783a2aceadb23b1}{mshr\_\-uncacheable\_\-lat} \mbox{[}MemCmd::NUM\_\-MEM\_\-CMDS\mbox{]}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_ga860805a5426cb057583a0a1eb7dd9c4c}{overallMshrUncacheableLatency}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_ga2e5641462c14394bea8a57328586ab08}{mshrMissRate} \mbox{[}MemCmd::NUM\_\-MEM\_\-CMDS\mbox{]}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_gab2368c54094c318b31b50fd594422e7d}{demandMshrMissRate}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_ga041b1609c62fdc738bc7f66172ee5c7d}{overallMshrMissRate}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_gabab885accb53d71c843ad12bc0a928e7}{avgMshrMissLatency} \mbox{[}MemCmd::NUM\_\-MEM\_\-CMDS\mbox{]}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_ga0fba53068815c749879bd3ec5aed871f}{demandAvgMshrMissLatency}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_gabb74e2451414ec42c24792cdea6a6060}{overallAvgMshrMissLatency}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_gaf6ebe7e4d284c4f93fd2ec80828e0e82}{avgMshrUncacheableLatency} \mbox{[}MemCmd::NUM\_\-MEM\_\-CMDS\mbox{]}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{group__CacheStatistics_gaabd47c5862f5963ede65d408a3776412}{overallAvgMshrUncacheableLatency}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{group__CacheStatistics_gab4ea8c6f8941356804bb9de4885a7ff4}{mshr\_\-cap\_\-events}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{group__CacheStatistics_ga673f963f100608daf064537a4dde7ec7}{soft\_\-prefetch\_\-mshr\_\-full}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{group__CacheStatistics_ga031ceb1999386dd8e6f8e9355942d9eb}{mshr\_\-no\_\-allocate\_\-misses}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMSHR}{MSHR} $\ast$ \hyperlink{classBaseCache_a2183a3718ac71defa0314e7030c4bfe5}{allocateBufferInternal} (\hyperlink{classMSHRQueue}{MSHRQueue} $\ast$mq, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, int size, \hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} time, bool requestBus)
\item 
void \hyperlink{classBaseCache_a08042a551e2a1bcdd036c84d277bc89f}{markInServiceInternal} (\hyperlink{classMSHR}{MSHR} $\ast$mshr, \hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual void \hyperlink{classBaseCache_afd3c83f1883488031612de6c47fcaabb}{memWriteback} ()=0
\item 
virtual void \hyperlink{classBaseCache_aeb9356f940fbf8410f41920ee1d5864d}{memInvalidate} ()=0
\item 
virtual bool \hyperlink{classBaseCache_a373dc1334f26db2ba94e827f3c9adc83}{isDirty} () const =0
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classBaseCache_1_1CacheSlavePort}{CacheSlavePort} $\ast$ \hyperlink{classBaseCache_a14913ffff181227d085f25a95e6ada42}{cpuSidePort}
\item 
\hyperlink{classBaseCache_1_1CacheMasterPort}{CacheMasterPort} $\ast$ \hyperlink{classBaseCache_af29f0c640654a651bf26558b4b39623b}{memSidePort}
\item 
\hyperlink{classMSHRQueue}{MSHRQueue} \hyperlink{classBaseCache_aa73933a75144caca7a7d3d77cf285c23}{mshrQueue}
\item 
\hyperlink{classMSHRQueue}{MSHRQueue} \hyperlink{classBaseCache_ad44ec41bd8517224df8584b5e7fbe372}{writeBuffer}
\item 
const unsigned \hyperlink{classBaseCache_a87b03496724866a3daf3e8ebeb831290}{blkSize}
\item 
const \hyperlink{classCycles}{Cycles} \hyperlink{classBaseCache_a4075fdc5720f8f0f57c379c396e74718}{hitLatency}
\item 
const \hyperlink{classCycles}{Cycles} \hyperlink{classBaseCache_ab3672589b3ea30e547b2a30f50d814eb}{responseLatency}
\item 
const int \hyperlink{classBaseCache_a3c2d74d5455e7b8ccefd3edb38c291de}{numTarget}
\item 
const bool \hyperlink{classBaseCache_ac8d6ebb7f62e1afe78ddc7c774316d66}{forwardSnoops}
\item 
const bool \hyperlink{classBaseCache_a9d8582d06c3d2f59711d1bbf7d383df3}{isTopLevel}
\item 
uint8\_\-t \hyperlink{classBaseCache_a1618f82ecde158c73f229ae4cc0f6f8b}{blocked}
\item 
uint64\_\-t \hyperlink{classBaseCache_ab26c49bd3bef351f3658df29505d78dd}{order}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classBaseCache_ae1148c48e3f5a892c0576b7e10eec8d0}{blockedCycle}
\item 
\hyperlink{classMSHR}{MSHR} $\ast$ \hyperlink{classBaseCache_ae429d09cb5301f34a7eb7e6c765d4441}{noTargetMSHR}
\item 
\hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classBaseCache_aec6f1d9f27ecfada36c359137b578352}{missCount}
\item 
const \hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classBaseCache_aad23e5e7311cbfb1189b674238254c39}{addrRanges}
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classBaseCache_a044898b3a082229405ecc19b5b26b144}{MSHRQueueIndex} \{ \hyperlink{classBaseCache_a044898b3a082229405ecc19b5b26b144ada8ec99f45021e0596a1bd0e9dfecfc2}{MSHRQueue\_\-MSHRs}, 
\hyperlink{classBaseCache_a044898b3a082229405ecc19b5b26b144a0eb759fee101138752a64fb5932353f7}{MSHRQueue\_\-WriteBuffer}
 \}
\end{DoxyCompactItemize}


\subsection{説明}
A basic cache interface. Implements some common functions for speed. 

\subsection{型定義}
\hypertarget{classBaseCache_a23c1728f4d2cabb1996560194937d427}{
\index{BaseCache@{BaseCache}!Params@{Params}}
\index{Params@{Params}!BaseCache@{BaseCache}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef BaseCacheParams {\bf Params}}}
\label{classBaseCache_a23c1728f4d2cabb1996560194937d427}


\hyperlink{classMemObject_a905bbc621eeec0ed08859e21c8c95412}{MemObject}を再定義しています。

\subsection{列挙型}
\hypertarget{classBaseCache_a98297f294858ead7eafd19af93e64c6d}{
\index{BaseCache@{BaseCache}!BlockedCause@{BlockedCause}}
\index{BlockedCause@{BlockedCause}!BaseCache@{BaseCache}}
\subsubsection[{BlockedCause}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf BlockedCause}}}
\label{classBaseCache_a98297f294858ead7eafd19af93e64c6d}
Reasons for caches to be blocked. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Blocked\_\-NoMSHRs@{Blocked\_\-NoMSHRs}!BaseCache@{BaseCache}}\index{BaseCache@{BaseCache}!Blocked\_\-NoMSHRs@{Blocked\_\-NoMSHRs}}\item[{\em 
\hypertarget{classBaseCache_a98297f294858ead7eafd19af93e64c6dab669a177c35c6b5166465c9e93eb71e7}{
Blocked\_\-NoMSHRs}
\label{classBaseCache_a98297f294858ead7eafd19af93e64c6dab669a177c35c6b5166465c9e93eb71e7}
}]\index{Blocked\_\-NoWBBuffers@{Blocked\_\-NoWBBuffers}!BaseCache@{BaseCache}}\index{BaseCache@{BaseCache}!Blocked\_\-NoWBBuffers@{Blocked\_\-NoWBBuffers}}\item[{\em 
\hypertarget{classBaseCache_a98297f294858ead7eafd19af93e64c6da1e332cbac57efe6b49ce9a0ab5e3f0de}{
Blocked\_\-NoWBBuffers}
\label{classBaseCache_a98297f294858ead7eafd19af93e64c6da1e332cbac57efe6b49ce9a0ab5e3f0de}
}]\index{Blocked\_\-NoTargets@{Blocked\_\-NoTargets}!BaseCache@{BaseCache}}\index{BaseCache@{BaseCache}!Blocked\_\-NoTargets@{Blocked\_\-NoTargets}}\item[{\em 
\hypertarget{classBaseCache_a98297f294858ead7eafd19af93e64c6da2e0db8e863cb5a0c10b73be89a535323}{
Blocked\_\-NoTargets}
\label{classBaseCache_a98297f294858ead7eafd19af93e64c6da2e0db8e863cb5a0c10b73be89a535323}
}]\index{NUM\_\-BLOCKED\_\-CAUSES@{NUM\_\-BLOCKED\_\-CAUSES}!BaseCache@{BaseCache}}\index{BaseCache@{BaseCache}!NUM\_\-BLOCKED\_\-CAUSES@{NUM\_\-BLOCKED\_\-CAUSES}}\item[{\em 
\hypertarget{classBaseCache_a98297f294858ead7eafd19af93e64c6da444545819cad907e5fafbf1c940a3f3f}{
NUM\_\-BLOCKED\_\-CAUSES}
\label{classBaseCache_a98297f294858ead7eafd19af93e64c6da444545819cad907e5fafbf1c940a3f3f}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
93                       {
94         Blocked_NoMSHRs = MSHRQueue_MSHRs,
95         Blocked_NoWBBuffers = MSHRQueue_WriteBuffer,
96         Blocked_NoTargets,
97         NUM_BLOCKED_CAUSES
98     };
\end{DoxyCode}
\hypertarget{classBaseCache_a044898b3a082229405ecc19b5b26b144}{
\index{BaseCache@{BaseCache}!MSHRQueueIndex@{MSHRQueueIndex}}
\index{MSHRQueueIndex@{MSHRQueueIndex}!BaseCache@{BaseCache}}
\subsubsection[{MSHRQueueIndex}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf MSHRQueueIndex}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBaseCache_a044898b3a082229405ecc19b5b26b144}
Indexes to enumerate the \hyperlink{classMSHR}{MSHR} queues. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{MSHRQueue\_\-MSHRs@{MSHRQueue\_\-MSHRs}!BaseCache@{BaseCache}}\index{BaseCache@{BaseCache}!MSHRQueue\_\-MSHRs@{MSHRQueue\_\-MSHRs}}\item[{\em 
\hypertarget{classBaseCache_a044898b3a082229405ecc19b5b26b144ada8ec99f45021e0596a1bd0e9dfecfc2}{
MSHRQueue\_\-MSHRs}
\label{classBaseCache_a044898b3a082229405ecc19b5b26b144ada8ec99f45021e0596a1bd0e9dfecfc2}
}]\index{MSHRQueue\_\-WriteBuffer@{MSHRQueue\_\-WriteBuffer}!BaseCache@{BaseCache}}\index{BaseCache@{BaseCache}!MSHRQueue\_\-WriteBuffer@{MSHRQueue\_\-WriteBuffer}}\item[{\em 
\hypertarget{classBaseCache_a044898b3a082229405ecc19b5b26b144a0eb759fee101138752a64fb5932353f7}{
MSHRQueue\_\-WriteBuffer}
\label{classBaseCache_a044898b3a082229405ecc19b5b26b144a0eb759fee101138752a64fb5932353f7}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
84                         {
85         MSHRQueue_MSHRs,
86         MSHRQueue_WriteBuffer
87     };
\end{DoxyCode}
\hypertarget{classBaseCache_a8ca466a3028d5dd05a9f31798a0115b8}{
\index{BaseCache@{BaseCache}!RequestCause@{RequestCause}}
\index{RequestCause@{RequestCause}!BaseCache@{BaseCache}}
\subsubsection[{RequestCause}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf RequestCause}}}
\label{classBaseCache_a8ca466a3028d5dd05a9f31798a0115b8}
Reasons for cache to request a bus. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Request\_\-MSHR@{Request\_\-MSHR}!BaseCache@{BaseCache}}\index{BaseCache@{BaseCache}!Request\_\-MSHR@{Request\_\-MSHR}}\item[{\em 
\hypertarget{classBaseCache_a8ca466a3028d5dd05a9f31798a0115b8a28d46d22a1bfda7d140d0496e9cb399b}{
Request\_\-MSHR}
\label{classBaseCache_a8ca466a3028d5dd05a9f31798a0115b8a28d46d22a1bfda7d140d0496e9cb399b}
}]\index{Request\_\-WB@{Request\_\-WB}!BaseCache@{BaseCache}}\index{BaseCache@{BaseCache}!Request\_\-WB@{Request\_\-WB}}\item[{\em 
\hypertarget{classBaseCache_a8ca466a3028d5dd05a9f31798a0115b8a2c4aab170dcb384c7424ee1e77411d24}{
Request\_\-WB}
\label{classBaseCache_a8ca466a3028d5dd05a9f31798a0115b8a2c4aab170dcb384c7424ee1e77411d24}
}]\index{Request\_\-PF@{Request\_\-PF}!BaseCache@{BaseCache}}\index{BaseCache@{BaseCache}!Request\_\-PF@{Request\_\-PF}}\item[{\em 
\hypertarget{classBaseCache_a8ca466a3028d5dd05a9f31798a0115b8ad591c96d60dbceaf75076c496d695d14}{
Request\_\-PF}
\label{classBaseCache_a8ca466a3028d5dd05a9f31798a0115b8ad591c96d60dbceaf75076c496d695d14}
}]\index{NUM\_\-REQUEST\_\-CAUSES@{NUM\_\-REQUEST\_\-CAUSES}!BaseCache@{BaseCache}}\index{BaseCache@{BaseCache}!NUM\_\-REQUEST\_\-CAUSES@{NUM\_\-REQUEST\_\-CAUSES}}\item[{\em 
\hypertarget{classBaseCache_a8ca466a3028d5dd05a9f31798a0115b8a836f2b395337a49406bc6709a8a2ff3a}{
NUM\_\-REQUEST\_\-CAUSES}
\label{classBaseCache_a8ca466a3028d5dd05a9f31798a0115b8a836f2b395337a49406bc6709a8a2ff3a}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
103                       {
104         Request_MSHR = MSHRQueue_MSHRs,
105         Request_WB = MSHRQueue_WriteBuffer,
106         Request_PF,
107         NUM_REQUEST_CAUSES
108     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classBaseCache_a6c1d60cbb9ab660c557bca8bfb40d768}{
\index{BaseCache@{BaseCache}!BaseCache@{BaseCache}}
\index{BaseCache@{BaseCache}!BaseCache@{BaseCache}}
\subsubsection[{BaseCache}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseCache} (const {\bf Params} $\ast$ {\em p})}}
\label{classBaseCache_a6c1d60cbb9ab660c557bca8bfb40d768}



\begin{DoxyCode}
68     : MemObject(p),
69       mshrQueue("MSHRs", p->mshrs, 4, MSHRQueue_MSHRs),
70       writeBuffer("write buffer", p->write_buffers, p->mshrs+1000,
71                   MSHRQueue_WriteBuffer),
72       blkSize(p->system->cacheLineSize()),
73       hitLatency(p->hit_latency),
74       responseLatency(p->response_latency),
75       numTarget(p->tgts_per_mshr),
76       forwardSnoops(p->forward_snoops),
77       isTopLevel(p->is_top_level),
78       blocked(0),
79       noTargetMSHR(NULL),
80       missCount(p->max_miss_count),
81       addrRanges(p->addr_ranges.begin(), p->addr_ranges.end()),
82       system(p->system)
83 {
84 }
\end{DoxyCode}
\hypertarget{classBaseCache_a9864fcb9f5632b2c250c18a2f6b9ac46}{
\index{BaseCache@{BaseCache}!$\sim$BaseCache@{$\sim$BaseCache}}
\index{$\sim$BaseCache@{$\sim$BaseCache}!BaseCache@{BaseCache}}
\subsubsection[{$\sim$BaseCache}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf BaseCache} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseCache_a9864fcb9f5632b2c250c18a2f6b9ac46}



\begin{DoxyCode}
445 {}
\end{DoxyCode}


\subsection{関数}
\hypertarget{classBaseCache_a2183a3718ac71defa0314e7030c4bfe5}{
\index{BaseCache@{BaseCache}!allocateBufferInternal@{allocateBufferInternal}}
\index{allocateBufferInternal@{allocateBufferInternal}!BaseCache@{BaseCache}}
\subsubsection[{allocateBufferInternal}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHR}$\ast$ allocateBufferInternal ({\bf MSHRQueue} $\ast$ {\em mq}, \/  {\bf Addr} {\em addr}, \/  int {\em size}, \/  {\bf PacketPtr} {\em pkt}, \/  {\bf Tick} {\em time}, \/  bool {\em requestBus})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classBaseCache_a2183a3718ac71defa0314e7030c4bfe5}



\begin{DoxyCode}
202     {
203         MSHR *mshr = mq->allocate(addr, size, pkt, time, order++);
204 
205         if (mq->isFull()) {
206             setBlocked((BlockedCause)mq->index);
207         }
208 
209         if (requestBus) {
210             requestMemSideBus((RequestCause)mq->index, time);
211         }
212 
213         return mshr;
214     }
\end{DoxyCode}
\hypertarget{classBaseCache_ac37432bbe5fab7cdf422ee29acf155f2}{
\index{BaseCache@{BaseCache}!allocateMissBuffer@{allocateMissBuffer}}
\index{allocateMissBuffer@{allocateMissBuffer}!BaseCache@{BaseCache}}
\subsubsection[{allocateMissBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHR}$\ast$ allocateMissBuffer ({\bf PacketPtr} {\em pkt}, \/  {\bf Tick} {\em time}, \/  bool {\em requestBus})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseCache_ac37432bbe5fab7cdf422ee29acf155f2}



\begin{DoxyCode}
471     {
472         assert(!pkt->req->isUncacheable());
473         return allocateBufferInternal(&mshrQueue,
474                                       blockAlign(pkt->getAddr()), blkSize,
475                                       pkt, time, requestBus);
476     }
\end{DoxyCode}
\hypertarget{classBaseCache_a8dfb4bae0c201cd12ca22dd159740541}{
\index{BaseCache@{BaseCache}!allocateUncachedReadBuffer@{allocateUncachedReadBuffer}}
\index{allocateUncachedReadBuffer@{allocateUncachedReadBuffer}!BaseCache@{BaseCache}}
\subsubsection[{allocateUncachedReadBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHR}$\ast$ allocateUncachedReadBuffer ({\bf PacketPtr} {\em pkt}, \/  {\bf Tick} {\em time}, \/  bool {\em requestBus})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseCache_a8dfb4bae0c201cd12ca22dd159740541}



\begin{DoxyCode}
487     {
488         assert(pkt->req->isUncacheable());
489         assert(pkt->isRead());
490         return allocateBufferInternal(&mshrQueue,
491                                       pkt->getAddr(), pkt->getSize(),
492                                       pkt, time, requestBus);
493     }
\end{DoxyCode}
\hypertarget{classBaseCache_a3f81ca9ba6f7294f930eca229838edc6}{
\index{BaseCache@{BaseCache}!allocateWriteBuffer@{allocateWriteBuffer}}
\index{allocateWriteBuffer@{allocateWriteBuffer}!BaseCache@{BaseCache}}
\subsubsection[{allocateWriteBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHR}$\ast$ allocateWriteBuffer ({\bf PacketPtr} {\em pkt}, \/  {\bf Tick} {\em time}, \/  bool {\em requestBus})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseCache_a3f81ca9ba6f7294f930eca229838edc6}



\begin{DoxyCode}
479     {
480         assert(pkt->isWrite() && !pkt->isRead());
481         return allocateBufferInternal(&writeBuffer,
482                                       pkt->getAddr(), pkt->getSize(),
483                                       pkt, time, requestBus);
484     }
\end{DoxyCode}
\hypertarget{classBaseCache_a676df8321350e810fc857d99cdcebc22}{
\index{BaseCache@{BaseCache}!blockAlign@{blockAlign}}
\index{blockAlign@{blockAlign}!BaseCache@{BaseCache}}
\subsubsection[{blockAlign}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} blockAlign ({\bf Addr} {\em addr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseCache_a676df8321350e810fc857d99cdcebc22}



\begin{DoxyCode}
465 { return (addr & ~(Addr(blkSize - 1))); }
\end{DoxyCode}
\hypertarget{classBaseCache_a78948a7bd2b849859bfc6fee2fc3d070}{
\index{BaseCache@{BaseCache}!clearBlocked@{clearBlocked}}
\index{clearBlocked@{clearBlocked}!BaseCache@{BaseCache}}
\subsubsection[{clearBlocked}]{\setlength{\rightskip}{0pt plus 5cm}void clearBlocked ({\bf BlockedCause} {\em cause})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseCache_a78948a7bd2b849859bfc6fee2fc3d070}
Marks the cache as unblocked for the given cause. This also clears the blocked flags in the appropriate interfaces. 
\begin{DoxyParams}{引数}
\item[{\em cause}]The newly unblocked cause. \end{DoxyParams}
\begin{DoxyWarning}{警告}
Calling this function can cause a blocked request on the bus to access the cache. The cache must be in a state to handle that request. 
\end{DoxyWarning}



\begin{DoxyCode}
528     {
529         uint8_t flag = 1 << cause;
530         blocked &= ~flag;
531         DPRINTF(Cache,"Unblocking for cause %d, mask=%d\n", cause, blocked);
532         if (blocked == 0) {
533             blocked_cycles[cause] += curCycle() - blockedCycle;
534             cpuSidePort->clearBlocked();
535         }
536     }
\end{DoxyCode}
\hypertarget{classBaseCache_a7eb041ca3a51fe243525b95dea36f813}{
\index{BaseCache@{BaseCache}!deassertMemSideBusRequest@{deassertMemSideBusRequest}}
\index{deassertMemSideBusRequest@{deassertMemSideBusRequest}!BaseCache@{BaseCache}}
\subsubsection[{deassertMemSideBusRequest}]{\setlength{\rightskip}{0pt plus 5cm}void deassertMemSideBusRequest ({\bf RequestCause} {\em cause})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseCache_a7eb041ca3a51fe243525b95dea36f813}
Clear the master bus request for the given cause. 
\begin{DoxyParams}{引数}
\item[{\em cause}]The request reason to clear. \end{DoxyParams}



\begin{DoxyCode}
553     {
554         // Obsolete... we no longer signal bus requests explicitly so
555         // we can't deassert them.  Leaving this in as a no-op since
556         // the prefetcher calls it to indicate that it no longer wants
557         // to request a prefetch, and someday that might be
558         // interesting again.
559     }
\end{DoxyCode}
\hypertarget{classBaseCache_aa8a18d230dba7a674ac8a0b4f35bc36a}{
\index{BaseCache@{BaseCache}!drain@{drain}}
\index{drain@{drain}!BaseCache@{BaseCache}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em drainManger})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classBaseCache_aa8a18d230dba7a674ac8a0b4f35bc36a}
Provide a default implementation of the drain interface that simply returns 0 (draining completed) and sets the drain state to Drained. 

\hyperlink{classSimObject_a6bf479c521c7c3eb473822d953275b26}{SimObject}を再定義しています。


\begin{DoxyCode}
756 {
757     int count = memSidePort->drain(dm) + cpuSidePort->drain(dm) +
758         mshrQueue.drain(dm) + writeBuffer.drain(dm);
759 
760     // Set status
761     if (count != 0) {
762         setDrainState(Drainable::Draining);
763         DPRINTF(Drain, "Cache not drained\n");
764         return count;
765     }
766 
767     setDrainState(Drainable::Drained);
768     return 0;
769 }
\end{DoxyCode}
\hypertarget{classBaseCache_a030a5d76880e3d3187c9f46971525d09}{
\index{BaseCache@{BaseCache}!getAddrRanges@{getAddrRanges}}
\index{getAddrRanges@{getAddrRanges}!BaseCache@{BaseCache}}
\subsubsection[{getAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf AddrRangeList}\& getAddrRanges () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseCache_a030a5d76880e3d3187c9f46971525d09}



\begin{DoxyCode}
468 { return addrRanges; }
\end{DoxyCode}
\hypertarget{classBaseCache_a38301abe4b3689f8ac7de5c13a046234}{
\index{BaseCache@{BaseCache}!getBlockSize@{getBlockSize}}
\index{getBlockSize@{getBlockSize}!BaseCache@{BaseCache}}
\subsubsection[{getBlockSize}]{\setlength{\rightskip}{0pt plus 5cm}unsigned getBlockSize () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseCache_a38301abe4b3689f8ac7de5c13a046234}
Query block size of a cache. \begin{DoxyReturn}{戻り値}
The block size 
\end{DoxyReturn}



\begin{DoxyCode}
460     {
461         return blkSize;
462     }
\end{DoxyCode}
\hypertarget{classBaseCache_adc4e675e51defbdd1e354dac729d0703}{
\index{BaseCache@{BaseCache}!getMasterPort@{getMasterPort}}
\index{getMasterPort@{getMasterPort}!BaseCache@{BaseCache}}
\subsubsection[{getMasterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseMasterPort} \& getMasterPort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classBaseCache_adc4e675e51defbdd1e354dac729d0703}
Get a master port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classMemObject_adc4e675e51defbdd1e354dac729d0703}{MemObject}を再定義しています。


\begin{DoxyCode}
126 {
127     if (if_name == "mem_side") {
128         return *memSidePort;
129     }  else {
130         return MemObject::getMasterPort(if_name, idx);
131     }
132 }
\end{DoxyCode}
\hypertarget{classBaseCache_ac918a145092d7514ebc6dbd952dceafb}{
\index{BaseCache@{BaseCache}!getSlavePort@{getSlavePort}}
\index{getSlavePort@{getSlavePort}!BaseCache@{BaseCache}}
\subsubsection[{getSlavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseSlavePort} \& getSlavePort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classBaseCache_ac918a145092d7514ebc6dbd952dceafb}
Get a slave port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classMemObject_ac918a145092d7514ebc6dbd952dceafb}{MemObject}を再定義しています。


\begin{DoxyCode}
136 {
137     if (if_name == "cpu_side") {
138         return *cpuSidePort;
139     } else {
140         return MemObject::getSlavePort(if_name, idx);
141     }
142 }
\end{DoxyCode}
\hypertarget{classBaseCache_a2ac85ef6d4c6f16111c1da31c2363aa7}{
\index{BaseCache@{BaseCache}!inCache@{inCache}}
\index{inCache@{inCache}!BaseCache@{BaseCache}}
\subsubsection[{inCache}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool inCache ({\bf Addr} {\em addr}, \/  bool {\em is\_\-secure}) const\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classBaseCache_a2ac85ef6d4c6f16111c1da31c2363aa7}


\hyperlink{classCache_a2a9a72a19c7910262542bc96de2488fb}{Cache$<$ TagStore $>$}で実装されています。\hypertarget{classBaseCache_a5d0c42b459c95506252f8916dc4abc9c}{
\index{BaseCache@{BaseCache}!incHitCount@{incHitCount}}
\index{incHitCount@{incHitCount}!BaseCache@{BaseCache}}
\subsubsection[{incHitCount}]{\setlength{\rightskip}{0pt plus 5cm}void incHitCount ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseCache_a5d0c42b459c95506252f8916dc4abc9c}



\begin{DoxyCode}
579     {
580         assert(pkt->req->masterId() < system->maxMasters());
581         hits[pkt->cmdToIndex()][pkt->req->masterId()]++;
582 
583     }
\end{DoxyCode}
\hypertarget{classBaseCache_a998427ec80c26469aae228b0d6bd9bd0}{
\index{BaseCache@{BaseCache}!incMissCount@{incMissCount}}
\index{incMissCount@{incMissCount}!BaseCache@{BaseCache}}
\subsubsection[{incMissCount}]{\setlength{\rightskip}{0pt plus 5cm}void incMissCount ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseCache_a998427ec80c26469aae228b0d6bd9bd0}



\begin{DoxyCode}
568     {
569         assert(pkt->req->masterId() < system->maxMasters());
570         misses[pkt->cmdToIndex()][pkt->req->masterId()]++;
571         pkt->req->incAccessDepth();
572         if (missCount) {
573             --missCount;
574             if (missCount == 0)
575                 exitSimLoop("A cache reached the maximum miss count");
576         }
577     }
\end{DoxyCode}
\hypertarget{classBaseCache_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{BaseCache@{BaseCache}!init@{init}}
\index{init@{init}!BaseCache@{BaseCache}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classBaseCache_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classBaseCache_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{SimObject}を再定義しています。


\begin{DoxyCode}
118 {
119     if (!cpuSidePort->isConnected() || !memSidePort->isConnected())
120         fatal("Cache ports on %s are not connected\n", name());
121     cpuSidePort->sendRangeChange();
122 }
\end{DoxyCode}
\hypertarget{classBaseCache_abb47bf01a0bb0aa1c4e3d60fc2ca8175}{
\index{BaseCache@{BaseCache}!inMissQueue@{inMissQueue}}
\index{inMissQueue@{inMissQueue}!BaseCache@{BaseCache}}
\subsubsection[{inMissQueue}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool inMissQueue ({\bf Addr} {\em addr}, \/  bool {\em is\_\-secure}) const\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classBaseCache_abb47bf01a0bb0aa1c4e3d60fc2ca8175}


\hyperlink{classCache_a01f08168ad1a2fee8ccff0f562da70de}{Cache$<$ TagStore $>$}で実装されています。\hypertarget{classBaseCache_a798c4be15789e723465215258f41c29b}{
\index{BaseCache@{BaseCache}!isBlocked@{isBlocked}}
\index{isBlocked@{isBlocked}!BaseCache@{BaseCache}}
\subsubsection[{isBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool isBlocked () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseCache_a798c4be15789e723465215258f41c29b}
Returns true if the cache is blocked for accesses. 


\begin{DoxyCode}
499     {
500         return blocked != 0;
501     }
\end{DoxyCode}
\hypertarget{classBaseCache_a373dc1334f26db2ba94e827f3c9adc83}{
\index{BaseCache@{BaseCache}!isDirty@{isDirty}}
\index{isDirty@{isDirty}!BaseCache@{BaseCache}}
\subsubsection[{isDirty}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool isDirty () const\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classBaseCache_a373dc1334f26db2ba94e827f3c9adc83}
Determine if there are any dirty blocks in the cache.

\begin{DoxyReturn}{戻り値}
true if at least one block is dirty, false otherwise. 
\end{DoxyReturn}


\hyperlink{classCache_ad66f409af3c387e166ff7ee95169b7b6}{Cache$<$ TagStore $>$}で実装されています。\hypertarget{classBaseCache_a08042a551e2a1bcdd036c84d277bc89f}{
\index{BaseCache@{BaseCache}!markInServiceInternal@{markInServiceInternal}}
\index{markInServiceInternal@{markInServiceInternal}!BaseCache@{BaseCache}}
\subsubsection[{markInServiceInternal}]{\setlength{\rightskip}{0pt plus 5cm}void markInServiceInternal ({\bf MSHR} $\ast$ {\em mshr}, \/  {\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classBaseCache_a08042a551e2a1bcdd036c84d277bc89f}



\begin{DoxyCode}
217     {
218         MSHRQueue *mq = mshr->queue;
219         bool wasFull = mq->isFull();
220         mq->markInService(mshr, pkt);
221         if (wasFull && !mq->isFull()) {
222             clearBlocked((BlockedCause)mq->index);
223         }
224     }
\end{DoxyCode}
\hypertarget{classBaseCache_aeb9356f940fbf8410f41920ee1d5864d}{
\index{BaseCache@{BaseCache}!memInvalidate@{memInvalidate}}
\index{memInvalidate@{memInvalidate}!BaseCache@{BaseCache}}
\subsubsection[{memInvalidate}]{\setlength{\rightskip}{0pt plus 5cm}virtual void memInvalidate ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classBaseCache_aeb9356f940fbf8410f41920ee1d5864d}
Invalidates all blocks in the cache.

Dirty cache lines will not be written back to memory. Make sure to call functionalWriteback() first if you want the to write them to memory. 

\hyperlink{classDrainable_a7f243f736712f56d8dd50cd21c77b9d1}{Drainable}を再定義しています。

\hyperlink{classCache_afea64b0aa579c17485db54c6a5c2ede3}{Cache$<$ TagStore $>$}で実装されています。\hypertarget{classBaseCache_afd3c83f1883488031612de6c47fcaabb}{
\index{BaseCache@{BaseCache}!memWriteback@{memWriteback}}
\index{memWriteback@{memWriteback}!BaseCache@{BaseCache}}
\subsubsection[{memWriteback}]{\setlength{\rightskip}{0pt plus 5cm}virtual void memWriteback ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classBaseCache_afd3c83f1883488031612de6c47fcaabb}
Write back dirty blocks in the cache using functional accesses. 

\hyperlink{classDrainable_aaec8b1741246cef384bc2743ce21cc34}{Drainable}を再定義しています。

\hyperlink{classCache_a381272ae5c2cc173adb59cd67a76b458}{Cache$<$ TagStore $>$}で実装されています。\hypertarget{classBaseCache_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{BaseCache@{BaseCache}!regStats@{regStats}}
\index{regStats@{regStats}!BaseCache@{BaseCache}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classBaseCache_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} stats for this object. 

\hyperlink{classSimObject_a4dc637449366fcdfc4e764cdf12d9b11}{SimObject}を再定義しています。

\hyperlink{classCache_a4dc637449366fcdfc4e764cdf12d9b11}{Cache$<$ TagStore $>$}で再定義されています。


\begin{DoxyCode}
146 {
147     using namespace Stats;
148 
149     // Hit statistics
150     for (int access_idx = 0; access_idx < MemCmd::NUM_MEM_CMDS; ++access_idx) {
151         MemCmd cmd(access_idx);
152         const string &cstr = cmd.toString();
153 
154         hits[access_idx]
155             .init(system->maxMasters())
156             .name(name() + "." + cstr + "_hits")
157             .desc("number of " + cstr + " hits")
158             .flags(total | nozero | nonan)
159             ;
160         for (int i = 0; i < system->maxMasters(); i++) {
161             hits[access_idx].subname(i, system->getMasterName(i));
162         }
163     }
164 
165 // These macros make it easier to sum the right subset of commands and
166 // to change the subset of commands that are considered "demand" vs
167 // "non-demand"
168 #define SUM_DEMAND(s) \
169     (s[MemCmd::ReadReq] + s[MemCmd::WriteReq] + s[MemCmd::ReadExReq])
170 
171 // should writebacks be included here?  prior code was inconsistent...
172 #define SUM_NON_DEMAND(s) \
173     (s[MemCmd::SoftPFReq] + s[MemCmd::HardPFReq])
174 
175     demandHits
176         .name(name() + ".demand_hits")
177         .desc("number of demand (read+write) hits")
178         .flags(total | nozero | nonan)
179         ;
180     demandHits = SUM_DEMAND(hits);
181     for (int i = 0; i < system->maxMasters(); i++) {
182         demandHits.subname(i, system->getMasterName(i));
183     }
184 
185     overallHits
186         .name(name() + ".overall_hits")
187         .desc("number of overall hits")
188         .flags(total | nozero | nonan)
189         ;
190     overallHits = demandHits + SUM_NON_DEMAND(hits);
191     for (int i = 0; i < system->maxMasters(); i++) {
192         overallHits.subname(i, system->getMasterName(i));
193     }
194 
195     // Miss statistics
196     for (int access_idx = 0; access_idx < MemCmd::NUM_MEM_CMDS; ++access_idx) {
197         MemCmd cmd(access_idx);
198         const string &cstr = cmd.toString();
199 
200         misses[access_idx]
201             .init(system->maxMasters())
202             .name(name() + "." + cstr + "_misses")
203             .desc("number of " + cstr + " misses")
204             .flags(total | nozero | nonan)
205             ;
206         for (int i = 0; i < system->maxMasters(); i++) {
207             misses[access_idx].subname(i, system->getMasterName(i));
208         }
209     }
210 
211     demandMisses
212         .name(name() + ".demand_misses")
213         .desc("number of demand (read+write) misses")
214         .flags(total | nozero | nonan)
215         ;
216     demandMisses = SUM_DEMAND(misses);
217     for (int i = 0; i < system->maxMasters(); i++) {
218         demandMisses.subname(i, system->getMasterName(i));
219     }
220 
221     overallMisses
222         .name(name() + ".overall_misses")
223         .desc("number of overall misses")
224         .flags(total | nozero | nonan)
225         ;
226     overallMisses = demandMisses + SUM_NON_DEMAND(misses);
227     for (int i = 0; i < system->maxMasters(); i++) {
228         overallMisses.subname(i, system->getMasterName(i));
229     }
230 
231     // Miss latency statistics
232     for (int access_idx = 0; access_idx < MemCmd::NUM_MEM_CMDS; ++access_idx) {
233         MemCmd cmd(access_idx);
234         const string &cstr = cmd.toString();
235 
236         missLatency[access_idx]
237             .init(system->maxMasters())
238             .name(name() + "." + cstr + "_miss_latency")
239             .desc("number of " + cstr + " miss cycles")
240             .flags(total | nozero | nonan)
241             ;
242         for (int i = 0; i < system->maxMasters(); i++) {
243             missLatency[access_idx].subname(i, system->getMasterName(i));
244         }
245     }
246 
247     demandMissLatency
248         .name(name() + ".demand_miss_latency")
249         .desc("number of demand (read+write) miss cycles")
250         .flags(total | nozero | nonan)
251         ;
252     demandMissLatency = SUM_DEMAND(missLatency);
253     for (int i = 0; i < system->maxMasters(); i++) {
254         demandMissLatency.subname(i, system->getMasterName(i));
255     }
256 
257     overallMissLatency
258         .name(name() + ".overall_miss_latency")
259         .desc("number of overall miss cycles")
260         .flags(total | nozero | nonan)
261         ;
262     overallMissLatency = demandMissLatency + SUM_NON_DEMAND(missLatency);
263     for (int i = 0; i < system->maxMasters(); i++) {
264         overallMissLatency.subname(i, system->getMasterName(i));
265     }
266 
267     // access formulas
268     for (int access_idx = 0; access_idx < MemCmd::NUM_MEM_CMDS; ++access_idx) {
269         MemCmd cmd(access_idx);
270         const string &cstr = cmd.toString();
271 
272         accesses[access_idx]
273             .name(name() + "." + cstr + "_accesses")
274             .desc("number of " + cstr + " accesses(hits+misses)")
275             .flags(total | nozero | nonan)
276             ;
277         accesses[access_idx] = hits[access_idx] + misses[access_idx];
278 
279         for (int i = 0; i < system->maxMasters(); i++) {
280             accesses[access_idx].subname(i, system->getMasterName(i));
281         }
282     }
283 
284     demandAccesses
285         .name(name() + ".demand_accesses")
286         .desc("number of demand (read+write) accesses")
287         .flags(total | nozero | nonan)
288         ;
289     demandAccesses = demandHits + demandMisses;
290     for (int i = 0; i < system->maxMasters(); i++) {
291         demandAccesses.subname(i, system->getMasterName(i));
292     }
293 
294     overallAccesses
295         .name(name() + ".overall_accesses")
296         .desc("number of overall (read+write) accesses")
297         .flags(total | nozero | nonan)
298         ;
299     overallAccesses = overallHits + overallMisses;
300     for (int i = 0; i < system->maxMasters(); i++) {
301         overallAccesses.subname(i, system->getMasterName(i));
302     }
303 
304     // miss rate formulas
305     for (int access_idx = 0; access_idx < MemCmd::NUM_MEM_CMDS; ++access_idx) {
306         MemCmd cmd(access_idx);
307         const string &cstr = cmd.toString();
308 
309         missRate[access_idx]
310             .name(name() + "." + cstr + "_miss_rate")
311             .desc("miss rate for " + cstr + " accesses")
312             .flags(total | nozero | nonan)
313             ;
314         missRate[access_idx] = misses[access_idx] / accesses[access_idx];
315 
316         for (int i = 0; i < system->maxMasters(); i++) {
317             missRate[access_idx].subname(i, system->getMasterName(i));
318         }
319     }
320 
321     demandMissRate
322         .name(name() + ".demand_miss_rate")
323         .desc("miss rate for demand accesses")
324         .flags(total | nozero | nonan)
325         ;
326     demandMissRate = demandMisses / demandAccesses;
327     for (int i = 0; i < system->maxMasters(); i++) {
328         demandMissRate.subname(i, system->getMasterName(i));
329     }
330 
331     overallMissRate
332         .name(name() + ".overall_miss_rate")
333         .desc("miss rate for overall accesses")
334         .flags(total | nozero | nonan)
335         ;
336     overallMissRate = overallMisses / overallAccesses;
337     for (int i = 0; i < system->maxMasters(); i++) {
338         overallMissRate.subname(i, system->getMasterName(i));
339     }
340 
341     // miss latency formulas
342     for (int access_idx = 0; access_idx < MemCmd::NUM_MEM_CMDS; ++access_idx) {
343         MemCmd cmd(access_idx);
344         const string &cstr = cmd.toString();
345 
346         avgMissLatency[access_idx]
347             .name(name() + "." + cstr + "_avg_miss_latency")
348             .desc("average " + cstr + " miss latency")
349             .flags(total | nozero | nonan)
350             ;
351         avgMissLatency[access_idx] =
352             missLatency[access_idx] / misses[access_idx];
353 
354         for (int i = 0; i < system->maxMasters(); i++) {
355             avgMissLatency[access_idx].subname(i, system->getMasterName(i));
356         }
357     }
358 
359     demandAvgMissLatency
360         .name(name() + ".demand_avg_miss_latency")
361         .desc("average overall miss latency")
362         .flags(total | nozero | nonan)
363         ;
364     demandAvgMissLatency = demandMissLatency / demandMisses;
365     for (int i = 0; i < system->maxMasters(); i++) {
366         demandAvgMissLatency.subname(i, system->getMasterName(i));
367     }
368 
369     overallAvgMissLatency
370         .name(name() + ".overall_avg_miss_latency")
371         .desc("average overall miss latency")
372         .flags(total | nozero | nonan)
373         ;
374     overallAvgMissLatency = overallMissLatency / overallMisses;
375     for (int i = 0; i < system->maxMasters(); i++) {
376         overallAvgMissLatency.subname(i, system->getMasterName(i));
377     }
378 
379     blocked_cycles.init(NUM_BLOCKED_CAUSES);
380     blocked_cycles
381         .name(name() + ".blocked_cycles")
382         .desc("number of cycles access was blocked")
383         .subname(Blocked_NoMSHRs, "no_mshrs")
384         .subname(Blocked_NoTargets, "no_targets")
385         ;
386 
387 
388     blocked_causes.init(NUM_BLOCKED_CAUSES);
389     blocked_causes
390         .name(name() + ".blocked")
391         .desc("number of cycles access was blocked")
392         .subname(Blocked_NoMSHRs, "no_mshrs")
393         .subname(Blocked_NoTargets, "no_targets")
394         ;
395 
396     avg_blocked
397         .name(name() + ".avg_blocked_cycles")
398         .desc("average number of cycles each access was blocked")
399         .subname(Blocked_NoMSHRs, "no_mshrs")
400         .subname(Blocked_NoTargets, "no_targets")
401         ;
402 
403     avg_blocked = blocked_cycles / blocked_causes;
404 
405     fastWrites
406         .name(name() + ".fast_writes")
407         .desc("number of fast writes performed")
408         ;
409 
410     cacheCopies
411         .name(name() + ".cache_copies")
412         .desc("number of cache copies performed")
413         ;
414 
415     writebacks
416         .init(system->maxMasters())
417         .name(name() + ".writebacks")
418         .desc("number of writebacks")
419         .flags(total | nozero | nonan)
420         ;
421     for (int i = 0; i < system->maxMasters(); i++) {
422         writebacks.subname(i, system->getMasterName(i));
423     }
424 
425     // MSHR statistics
426     // MSHR hit statistics
427     for (int access_idx = 0; access_idx < MemCmd::NUM_MEM_CMDS; ++access_idx) {
428         MemCmd cmd(access_idx);
429         const string &cstr = cmd.toString();
430 
431         mshr_hits[access_idx]
432             .init(system->maxMasters())
433             .name(name() + "." + cstr + "_mshr_hits")
434             .desc("number of " + cstr + " MSHR hits")
435             .flags(total | nozero | nonan)
436             ;
437         for (int i = 0; i < system->maxMasters(); i++) {
438             mshr_hits[access_idx].subname(i, system->getMasterName(i));
439         }
440     }
441 
442     demandMshrHits
443         .name(name() + ".demand_mshr_hits")
444         .desc("number of demand (read+write) MSHR hits")
445         .flags(total | nozero | nonan)
446         ;
447     demandMshrHits = SUM_DEMAND(mshr_hits);
448     for (int i = 0; i < system->maxMasters(); i++) {
449         demandMshrHits.subname(i, system->getMasterName(i));
450     }
451 
452     overallMshrHits
453         .name(name() + ".overall_mshr_hits")
454         .desc("number of overall MSHR hits")
455         .flags(total | nozero | nonan)
456         ;
457     overallMshrHits = demandMshrHits + SUM_NON_DEMAND(mshr_hits);
458     for (int i = 0; i < system->maxMasters(); i++) {
459         overallMshrHits.subname(i, system->getMasterName(i));
460     }
461 
462     // MSHR miss statistics
463     for (int access_idx = 0; access_idx < MemCmd::NUM_MEM_CMDS; ++access_idx) {
464         MemCmd cmd(access_idx);
465         const string &cstr = cmd.toString();
466 
467         mshr_misses[access_idx]
468             .init(system->maxMasters())
469             .name(name() + "." + cstr + "_mshr_misses")
470             .desc("number of " + cstr + " MSHR misses")
471             .flags(total | nozero | nonan)
472             ;
473         for (int i = 0; i < system->maxMasters(); i++) {
474             mshr_misses[access_idx].subname(i, system->getMasterName(i));
475         }
476     }
477 
478     demandMshrMisses
479         .name(name() + ".demand_mshr_misses")
480         .desc("number of demand (read+write) MSHR misses")
481         .flags(total | nozero | nonan)
482         ;
483     demandMshrMisses = SUM_DEMAND(mshr_misses);
484     for (int i = 0; i < system->maxMasters(); i++) {
485         demandMshrMisses.subname(i, system->getMasterName(i));
486     }
487 
488     overallMshrMisses
489         .name(name() + ".overall_mshr_misses")
490         .desc("number of overall MSHR misses")
491         .flags(total | nozero | nonan)
492         ;
493     overallMshrMisses = demandMshrMisses + SUM_NON_DEMAND(mshr_misses);
494     for (int i = 0; i < system->maxMasters(); i++) {
495         overallMshrMisses.subname(i, system->getMasterName(i));
496     }
497 
498     // MSHR miss latency statistics
499     for (int access_idx = 0; access_idx < MemCmd::NUM_MEM_CMDS; ++access_idx) {
500         MemCmd cmd(access_idx);
501         const string &cstr = cmd.toString();
502 
503         mshr_miss_latency[access_idx]
504             .init(system->maxMasters())
505             .name(name() + "." + cstr + "_mshr_miss_latency")
506             .desc("number of " + cstr + " MSHR miss cycles")
507             .flags(total | nozero | nonan)
508             ;
509         for (int i = 0; i < system->maxMasters(); i++) {
510             mshr_miss_latency[access_idx].subname(i, system->getMasterName(i));
511         }
512     }
513 
514     demandMshrMissLatency
515         .name(name() + ".demand_mshr_miss_latency")
516         .desc("number of demand (read+write) MSHR miss cycles")
517         .flags(total | nozero | nonan)
518         ;
519     demandMshrMissLatency = SUM_DEMAND(mshr_miss_latency);
520     for (int i = 0; i < system->maxMasters(); i++) {
521         demandMshrMissLatency.subname(i, system->getMasterName(i));
522     }
523 
524     overallMshrMissLatency
525         .name(name() + ".overall_mshr_miss_latency")
526         .desc("number of overall MSHR miss cycles")
527         .flags(total | nozero | nonan)
528         ;
529     overallMshrMissLatency =
530         demandMshrMissLatency + SUM_NON_DEMAND(mshr_miss_latency);
531     for (int i = 0; i < system->maxMasters(); i++) {
532         overallMshrMissLatency.subname(i, system->getMasterName(i));
533     }
534 
535     // MSHR uncacheable statistics
536     for (int access_idx = 0; access_idx < MemCmd::NUM_MEM_CMDS; ++access_idx) {
537         MemCmd cmd(access_idx);
538         const string &cstr = cmd.toString();
539 
540         mshr_uncacheable[access_idx]
541             .init(system->maxMasters())
542             .name(name() + "." + cstr + "_mshr_uncacheable")
543             .desc("number of " + cstr + " MSHR uncacheable")
544             .flags(total | nozero | nonan)
545             ;
546         for (int i = 0; i < system->maxMasters(); i++) {
547             mshr_uncacheable[access_idx].subname(i, system->getMasterName(i));
548         }
549     }
550 
551     overallMshrUncacheable
552         .name(name() + ".overall_mshr_uncacheable_misses")
553         .desc("number of overall MSHR uncacheable misses")
554         .flags(total | nozero | nonan)
555         ;
556     overallMshrUncacheable =
557         SUM_DEMAND(mshr_uncacheable) + SUM_NON_DEMAND(mshr_uncacheable);
558     for (int i = 0; i < system->maxMasters(); i++) {
559         overallMshrUncacheable.subname(i, system->getMasterName(i));
560     }
561 
562     // MSHR miss latency statistics
563     for (int access_idx = 0; access_idx < MemCmd::NUM_MEM_CMDS; ++access_idx) {
564         MemCmd cmd(access_idx);
565         const string &cstr = cmd.toString();
566 
567         mshr_uncacheable_lat[access_idx]
568             .init(system->maxMasters())
569             .name(name() + "." + cstr + "_mshr_uncacheable_latency")
570             .desc("number of " + cstr + " MSHR uncacheable cycles")
571             .flags(total | nozero | nonan)
572             ;
573         for (int i = 0; i < system->maxMasters(); i++) {
574             mshr_uncacheable_lat[access_idx].subname(i, system->getMasterName(i))
      ;
575         }
576     }
577 
578     overallMshrUncacheableLatency
579         .name(name() + ".overall_mshr_uncacheable_latency")
580         .desc("number of overall MSHR uncacheable cycles")
581         .flags(total | nozero | nonan)
582         ;
583     overallMshrUncacheableLatency =
584         SUM_DEMAND(mshr_uncacheable_lat) +
585         SUM_NON_DEMAND(mshr_uncacheable_lat);
586     for (int i = 0; i < system->maxMasters(); i++) {
587         overallMshrUncacheableLatency.subname(i, system->getMasterName(i));
588     }
589 
590 #if 0
591     // MSHR access formulas
592     for (int access_idx = 0; access_idx < MemCmd::NUM_MEM_CMDS; ++access_idx) {
593         MemCmd cmd(access_idx);
594         const string &cstr = cmd.toString();
595 
596         mshrAccesses[access_idx]
597             .name(name() + "." + cstr + "_mshr_accesses")
598             .desc("number of " + cstr + " mshr accesses(hits+misses)")
599             .flags(total | nozero | nonan)
600             ;
601         mshrAccesses[access_idx] =
602             mshr_hits[access_idx] + mshr_misses[access_idx]
603             + mshr_uncacheable[access_idx];
604     }
605 
606     demandMshrAccesses
607         .name(name() + ".demand_mshr_accesses")
608         .desc("number of demand (read+write) mshr accesses")
609         .flags(total | nozero | nonan)
610         ;
611     demandMshrAccesses = demandMshrHits + demandMshrMisses;
612 
613     overallMshrAccesses
614         .name(name() + ".overall_mshr_accesses")
615         .desc("number of overall (read+write) mshr accesses")
616         .flags(total | nozero | nonan)
617         ;
618     overallMshrAccesses = overallMshrHits + overallMshrMisses
619         + overallMshrUncacheable;
620 #endif
621 
622     // MSHR miss rate formulas
623     for (int access_idx = 0; access_idx < MemCmd::NUM_MEM_CMDS; ++access_idx) {
624         MemCmd cmd(access_idx);
625         const string &cstr = cmd.toString();
626 
627         mshrMissRate[access_idx]
628             .name(name() + "." + cstr + "_mshr_miss_rate")
629             .desc("mshr miss rate for " + cstr + " accesses")
630             .flags(total | nozero | nonan)
631             ;
632         mshrMissRate[access_idx] =
633             mshr_misses[access_idx] / accesses[access_idx];
634 
635         for (int i = 0; i < system->maxMasters(); i++) {
636             mshrMissRate[access_idx].subname(i, system->getMasterName(i));
637         }
638     }
639 
640     demandMshrMissRate
641         .name(name() + ".demand_mshr_miss_rate")
642         .desc("mshr miss rate for demand accesses")
643         .flags(total | nozero | nonan)
644         ;
645     demandMshrMissRate = demandMshrMisses / demandAccesses;
646     for (int i = 0; i < system->maxMasters(); i++) {
647         demandMshrMissRate.subname(i, system->getMasterName(i));
648     }
649 
650     overallMshrMissRate
651         .name(name() + ".overall_mshr_miss_rate")
652         .desc("mshr miss rate for overall accesses")
653         .flags(total | nozero | nonan)
654         ;
655     overallMshrMissRate = overallMshrMisses / overallAccesses;
656     for (int i = 0; i < system->maxMasters(); i++) {
657         overallMshrMissRate.subname(i, system->getMasterName(i));
658     }
659 
660     // mshrMiss latency formulas
661     for (int access_idx = 0; access_idx < MemCmd::NUM_MEM_CMDS; ++access_idx) {
662         MemCmd cmd(access_idx);
663         const string &cstr = cmd.toString();
664 
665         avgMshrMissLatency[access_idx]
666             .name(name() + "." + cstr + "_avg_mshr_miss_latency")
667             .desc("average " + cstr + " mshr miss latency")
668             .flags(total | nozero | nonan)
669             ;
670         avgMshrMissLatency[access_idx] =
671             mshr_miss_latency[access_idx] / mshr_misses[access_idx];
672 
673         for (int i = 0; i < system->maxMasters(); i++) {
674             avgMshrMissLatency[access_idx].subname(i, system->getMasterName(i));
675         }
676     }
677 
678     demandAvgMshrMissLatency
679         .name(name() + ".demand_avg_mshr_miss_latency")
680         .desc("average overall mshr miss latency")
681         .flags(total | nozero | nonan)
682         ;
683     demandAvgMshrMissLatency = demandMshrMissLatency / demandMshrMisses;
684     for (int i = 0; i < system->maxMasters(); i++) {
685         demandAvgMshrMissLatency.subname(i, system->getMasterName(i));
686     }
687 
688     overallAvgMshrMissLatency
689         .name(name() + ".overall_avg_mshr_miss_latency")
690         .desc("average overall mshr miss latency")
691         .flags(total | nozero | nonan)
692         ;
693     overallAvgMshrMissLatency = overallMshrMissLatency / overallMshrMisses;
694     for (int i = 0; i < system->maxMasters(); i++) {
695         overallAvgMshrMissLatency.subname(i, system->getMasterName(i));
696     }
697 
698     // mshrUncacheable latency formulas
699     for (int access_idx = 0; access_idx < MemCmd::NUM_MEM_CMDS; ++access_idx) {
700         MemCmd cmd(access_idx);
701         const string &cstr = cmd.toString();
702 
703         avgMshrUncacheableLatency[access_idx]
704             .name(name() + "." + cstr + "_avg_mshr_uncacheable_latency")
705             .desc("average " + cstr + " mshr uncacheable latency")
706             .flags(total | nozero | nonan)
707             ;
708         avgMshrUncacheableLatency[access_idx] =
709             mshr_uncacheable_lat[access_idx] / mshr_uncacheable[access_idx];
710 
711         for (int i = 0; i < system->maxMasters(); i++) {
712             avgMshrUncacheableLatency[access_idx].subname(i, system->
      getMasterName(i));
713         }
714     }
715 
716     overallAvgMshrUncacheableLatency
717         .name(name() + ".overall_avg_mshr_uncacheable_latency")
718         .desc("average overall mshr uncacheable latency")
719         .flags(total | nozero | nonan)
720         ;
721     overallAvgMshrUncacheableLatency = overallMshrUncacheableLatency / overallMsh
      rUncacheable;
722     for (int i = 0; i < system->maxMasters(); i++) {
723         overallAvgMshrUncacheableLatency.subname(i, system->getMasterName(i));
724     }
725 
726     mshr_cap_events
727         .init(system->maxMasters())
728         .name(name() + ".mshr_cap_events")
729         .desc("number of times MSHR cap was activated")
730         .flags(total | nozero | nonan)
731         ;
732     for (int i = 0; i < system->maxMasters(); i++) {
733         mshr_cap_events.subname(i, system->getMasterName(i));
734     }
735 
736     //software prefetching stats
737     soft_prefetch_mshr_full
738         .init(system->maxMasters())
739         .name(name() + ".soft_prefetch_mshr_full")
740         .desc("number of mshr full events for SW prefetching instrutions")
741         .flags(total | nozero | nonan)
742         ;
743     for (int i = 0; i < system->maxMasters(); i++) {
744         soft_prefetch_mshr_full.subname(i, system->getMasterName(i));
745     }
746 
747     mshr_no_allocate_misses
748         .name(name() +".no_allocate_misses")
749         .desc("Number of misses that were no-allocate")
750         ;
751 
752 }
\end{DoxyCode}
\hypertarget{classBaseCache_af0bf3b9e90ffddfd7762af4c5fd5247b}{
\index{BaseCache@{BaseCache}!requestMemSideBus@{requestMemSideBus}}
\index{requestMemSideBus@{requestMemSideBus}!BaseCache@{BaseCache}}
\subsubsection[{requestMemSideBus}]{\setlength{\rightskip}{0pt plus 5cm}void requestMemSideBus ({\bf RequestCause} {\em cause}, \/  {\bf Tick} {\em time})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseCache_af0bf3b9e90ffddfd7762af4c5fd5247b}
\hyperlink{classRequest}{Request} the master bus for the given cause and time. 
\begin{DoxyParams}{引数}
\item[{\em cause}]The reason for the request. \item[{\em time}]The time to make the request. \end{DoxyParams}



\begin{DoxyCode}
544     {
545         memSidePort->requestBus(cause, time);
546     }
\end{DoxyCode}
\hypertarget{classBaseCache_a79de24f2f3eda2cc3ac13f600d171bc0}{
\index{BaseCache@{BaseCache}!setBlocked@{setBlocked}}
\index{setBlocked@{setBlocked}!BaseCache@{BaseCache}}
\subsubsection[{setBlocked}]{\setlength{\rightskip}{0pt plus 5cm}void setBlocked ({\bf BlockedCause} {\em cause})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseCache_a79de24f2f3eda2cc3ac13f600d171bc0}
Marks the access path of the cache as blocked for the given cause. This also sets the blocked flag in the slave interface. 
\begin{DoxyParams}{引数}
\item[{\em cause}]The reason for the cache blocking. \end{DoxyParams}



\begin{DoxyCode}
509     {
510         uint8_t flag = 1 << cause;
511         if (blocked == 0) {
512             blocked_causes[cause]++;
513             blockedCycle = curCycle();
514             cpuSidePort->setBlocked();
515         }
516         blocked |= flag;
517         DPRINTF(Cache,"Blocking for cause %d, mask=%d\n", cause, blocked);
518     }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classBaseCache_aad23e5e7311cbfb1189b674238254c39}{
\index{BaseCache@{BaseCache}!addrRanges@{addrRanges}}
\index{addrRanges@{addrRanges}!BaseCache@{BaseCache}}
\subsubsection[{addrRanges}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf AddrRangeList} {\bf addrRanges}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseCache_aad23e5e7311cbfb1189b674238254c39}
The address range to which the cache responds on the CPU side. Normally this is all possible memory addresses. \hypertarget{classBaseCache_a87b03496724866a3daf3e8ebeb831290}{
\index{BaseCache@{BaseCache}!blkSize@{blkSize}}
\index{blkSize@{blkSize}!BaseCache@{BaseCache}}
\subsubsection[{blkSize}]{\setlength{\rightskip}{0pt plus 5cm}const unsigned {\bf blkSize}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseCache_a87b03496724866a3daf3e8ebeb831290}
Block size of this cache \hypertarget{classBaseCache_a1618f82ecde158c73f229ae4cc0f6f8b}{
\index{BaseCache@{BaseCache}!blocked@{blocked}}
\index{blocked@{blocked}!BaseCache@{BaseCache}}
\subsubsection[{blocked}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf blocked}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseCache_a1618f82ecde158c73f229ae4cc0f6f8b}
Bit vector of the blocking reasons for the access path. \begin{DoxySeeAlso}{参照}
\hyperlink{classBaseCache_a98297f294858ead7eafd19af93e64c6d}{BlockedCause} 
\end{DoxySeeAlso}
\hypertarget{classBaseCache_ae1148c48e3f5a892c0576b7e10eec8d0}{
\index{BaseCache@{BaseCache}!blockedCycle@{blockedCycle}}
\index{blockedCycle@{blockedCycle}!BaseCache@{BaseCache}}
\subsubsection[{blockedCycle}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf blockedCycle}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseCache_ae1148c48e3f5a892c0576b7e10eec8d0}
Stores time the cache blocked for statistics. \hypertarget{classBaseCache_a14913ffff181227d085f25a95e6ada42}{
\index{BaseCache@{BaseCache}!cpuSidePort@{cpuSidePort}}
\index{cpuSidePort@{cpuSidePort}!BaseCache@{BaseCache}}
\subsubsection[{cpuSidePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CacheSlavePort}$\ast$ {\bf cpuSidePort}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseCache_a14913ffff181227d085f25a95e6ada42}
\hypertarget{classBaseCache_ac8d6ebb7f62e1afe78ddc7c774316d66}{
\index{BaseCache@{BaseCache}!forwardSnoops@{forwardSnoops}}
\index{forwardSnoops@{forwardSnoops}!BaseCache@{BaseCache}}
\subsubsection[{forwardSnoops}]{\setlength{\rightskip}{0pt plus 5cm}const bool {\bf forwardSnoops}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseCache_ac8d6ebb7f62e1afe78ddc7c774316d66}
Do we forward snoops from mem side port through to cpu side port? \hypertarget{classBaseCache_a4075fdc5720f8f0f57c379c396e74718}{
\index{BaseCache@{BaseCache}!hitLatency@{hitLatency}}
\index{hitLatency@{hitLatency}!BaseCache@{BaseCache}}
\subsubsection[{hitLatency}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Cycles} {\bf hitLatency}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseCache_a4075fdc5720f8f0f57c379c396e74718}
The latency of a hit in this device. \hypertarget{classBaseCache_a9d8582d06c3d2f59711d1bbf7d383df3}{
\index{BaseCache@{BaseCache}!isTopLevel@{isTopLevel}}
\index{isTopLevel@{isTopLevel}!BaseCache@{BaseCache}}
\subsubsection[{isTopLevel}]{\setlength{\rightskip}{0pt plus 5cm}const bool {\bf isTopLevel}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseCache_a9d8582d06c3d2f59711d1bbf7d383df3}
Is this cache a toplevel cache (e.g. L1, I/O cache). If so we should never try to forward ownership and similar optimizations to the cpu side \hypertarget{classBaseCache_af29f0c640654a651bf26558b4b39623b}{
\index{BaseCache@{BaseCache}!memSidePort@{memSidePort}}
\index{memSidePort@{memSidePort}!BaseCache@{BaseCache}}
\subsubsection[{memSidePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CacheMasterPort}$\ast$ {\bf memSidePort}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseCache_af29f0c640654a651bf26558b4b39623b}
\hypertarget{classBaseCache_aec6f1d9f27ecfada36c359137b578352}{
\index{BaseCache@{BaseCache}!missCount@{missCount}}
\index{missCount@{missCount}!BaseCache@{BaseCache}}
\subsubsection[{missCount}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Counter} {\bf missCount}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseCache_aec6f1d9f27ecfada36c359137b578352}
The number of misses to trigger an exit event. \hypertarget{classBaseCache_aa73933a75144caca7a7d3d77cf285c23}{
\index{BaseCache@{BaseCache}!mshrQueue@{mshrQueue}}
\index{mshrQueue@{mshrQueue}!BaseCache@{BaseCache}}
\subsubsection[{mshrQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHRQueue} {\bf mshrQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseCache_aa73933a75144caca7a7d3d77cf285c23}
Miss status registers \hypertarget{classBaseCache_ae429d09cb5301f34a7eb7e6c765d4441}{
\index{BaseCache@{BaseCache}!noTargetMSHR@{noTargetMSHR}}
\index{noTargetMSHR@{noTargetMSHR}!BaseCache@{BaseCache}}
\subsubsection[{noTargetMSHR}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHR}$\ast$ {\bf noTargetMSHR}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseCache_ae429d09cb5301f34a7eb7e6c765d4441}
Pointer to the \hyperlink{classMSHR}{MSHR} that has no targets. \hypertarget{classBaseCache_a3c2d74d5455e7b8ccefd3edb38c291de}{
\index{BaseCache@{BaseCache}!numTarget@{numTarget}}
\index{numTarget@{numTarget}!BaseCache@{BaseCache}}
\subsubsection[{numTarget}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf numTarget}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseCache_a3c2d74d5455e7b8ccefd3edb38c291de}
The number of targets for each \hyperlink{classMSHR}{MSHR}. \hypertarget{classBaseCache_ab26c49bd3bef351f3658df29505d78dd}{
\index{BaseCache@{BaseCache}!order@{order}}
\index{order@{order}!BaseCache@{BaseCache}}
\subsubsection[{order}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf order}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseCache_ab26c49bd3bef351f3658df29505d78dd}
Increasing order number assigned to each incoming request. \hypertarget{classBaseCache_ab3672589b3ea30e547b2a30f50d814eb}{
\index{BaseCache@{BaseCache}!responseLatency@{responseLatency}}
\index{responseLatency@{responseLatency}!BaseCache@{BaseCache}}
\subsubsection[{responseLatency}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Cycles} {\bf responseLatency}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseCache_ab3672589b3ea30e547b2a30f50d814eb}
The latency of sending reponse to its upper level cache/core on a linefill. In most contemporary processors, the return path on a cache miss is much quicker that the hit latency. The responseLatency parameter tries to capture this latency. \hypertarget{classBaseCache_af27ccd765f13a4b7bd119dc7579e2746}{
\index{BaseCache@{BaseCache}!system@{system}}
\index{system@{system}!BaseCache@{BaseCache}}
\subsubsection[{system}]{\setlength{\rightskip}{0pt plus 5cm}{\bf System}$\ast$ {\bf system}}}
\label{classBaseCache_af27ccd765f13a4b7bd119dc7579e2746}
\hyperlink{classSystem}{System} we are currently operating in. \hypertarget{classBaseCache_ad44ec41bd8517224df8584b5e7fbe372}{
\index{BaseCache@{BaseCache}!writeBuffer@{writeBuffer}}
\index{writeBuffer@{writeBuffer}!BaseCache@{BaseCache}}
\subsubsection[{writeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHRQueue} {\bf writeBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseCache_ad44ec41bd8517224df8584b5e7fbe372}
Write/writeback buffer 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/cache/\hyperlink{mem_2cache_2base_8hh}{base.hh}\item 
mem/cache/\hyperlink{mem_2cache_2base_8cc}{base.cc}\end{DoxyCompactItemize}
