\hypertarget{classLWBackEnd}{
\section{クラス テンプレート LWBackEnd$<$ Impl $>$}
\label{classLWBackEnd}\index{LWBackEnd@{LWBackEnd}}
}


{\ttfamily \#include $<$lw\_\-back\_\-end.hh$>$}\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structLWBackEnd_1_1pqCompare}{pqCompare}
\item 
struct \hyperlink{structLWBackEnd_1_1SizeStruct}{SizeStruct}
\item 
class \hyperlink{classLWBackEnd_1_1TrapEvent}{TrapEvent}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \{ \par
\hyperlink{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}{Running}, 
\hyperlink{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}{Idle}, 
\hyperlink{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba4ba5ae5815b190bd652669e2fdea5ed7}{DcacheMissStall}, 
\hyperlink{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba1eb81f4540c1c4b90839b08ae63c5d7f}{DcacheMissComplete}, 
\par
\hyperlink{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba9463ee9b8700258a1019b4b9d2d77a30}{Blocked}, 
\hyperlink{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba8c49adf6da5f507150d403610c684877}{TrapPending}
 \}
\item 
typedef \hyperlink{structOzoneThreadState}{OzoneThreadState}$<$ Impl $>$ \hyperlink{classLWBackEnd_a9311aca87e8229ec3f7a7422ccbc9fbe}{Thread}
\item 
typedef Impl::Params \hyperlink{classLWBackEnd_a818e103eae798a24a06a0a34631849ea}{Params}
\item 
typedef Impl::DynInst \hyperlink{classLWBackEnd_ab741745c86a14c765b999c11167636d9}{DynInst}
\item 
typedef Impl::DynInstPtr \hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}
\item 
typedef Impl::OzoneCPU \hyperlink{classLWBackEnd_a9730cc41bccb218cae8f32869b8d887e}{OzoneCPU}
\item 
typedef Impl::FrontEnd \hyperlink{classLWBackEnd_abe8e1d8243582d5024a1076f6091d9fe}{FrontEnd}
\item 
typedef Impl::OzoneCPU::CommStruct \hyperlink{classLWBackEnd_abdf3026ccc30c2ed3cb77dbe3cfbacad}{CommStruct}
\item 
typedef \hyperlink{structLWBackEnd_1_1SizeStruct}{SizeStruct} \hyperlink{classLWBackEnd_a99d236038ce57aa3ef78858228c5f972}{DispatchToIssue}
\item 
typedef \hyperlink{structLWBackEnd_1_1SizeStruct}{SizeStruct} \hyperlink{classLWBackEnd_a5badfe54e71b8fccb3d371013a8eef73}{IssueToExec}
\item 
typedef \hyperlink{structLWBackEnd_1_1SizeStruct}{SizeStruct} \hyperlink{classLWBackEnd_a91ea582041466725b4b17ce19f98685f}{ExecToCommit}
\item 
typedef \hyperlink{structLWBackEnd_1_1SizeStruct}{SizeStruct} \hyperlink{classLWBackEnd_a20d1fb15b536d49c687dee42d95c1a87}{Writeback}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classLWBackEnd_a547c62cea335ccc135b28bf60afc1a65}{LWBackEnd} (\hyperlink{classLWBackEnd_a818e103eae798a24a06a0a34631849ea}{Params} $\ast$params)
\item 
std::string \hyperlink{classLWBackEnd_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classLWBackEnd_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classLWBackEnd_ab8056057b67b41f234f56940cc115cc1}{setCPU} (\hyperlink{classOzoneCPU}{OzoneCPU} $\ast$cpu\_\-ptr)
\item 
void \hyperlink{classLWBackEnd_a122009fa2730cee3898ac945227da8eb}{setFrontEnd} (\hyperlink{classFrontEnd}{FrontEnd} $\ast$front\_\-end\_\-ptr)
\item 
void \hyperlink{classLWBackEnd_ac6ccaaea6ac518cab92f71723b5a739e}{setTC} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc\_\-ptr)
\item 
void \hyperlink{classLWBackEnd_a850bea4a9b9f631e7b6a4c7dc92f662a}{setThreadState} (\hyperlink{structOzoneThreadState}{Thread} $\ast$thread\_\-ptr)
\item 
void \hyperlink{classLWBackEnd_aeabdb9f0aae07df67c3029f8fddb2693}{setCommBuffer} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classLWBackEnd_abdf3026ccc30c2ed3cb77dbe3cfbacad}{CommStruct} $>$ $\ast$\_\-comm)
\item 
\hyperlink{classPort}{Port} $\ast$ \hyperlink{classLWBackEnd_a32e64f82b805fe23a17b01dda0f44fb0}{getDcachePort} ()
\item 
void \hyperlink{classLWBackEnd_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\item 
void \hyperlink{classLWBackEnd_a3c68c455d9207edd23ae3bcb7971e653}{squash} ()
\item 
void \hyperlink{classLWBackEnd_aee57f4aad9f2308dcc12325319c170d5}{generateTCEvent} ()
\item 
void \hyperlink{classLWBackEnd_a24cd8db837a73b879041bf33da7b2064}{squashFromTC} ()
\item 
void \hyperlink{classLWBackEnd_a63c6cc9b9d0507c286d035e92a1bc4f4}{squashFromTrap} ()
\item 
void \hyperlink{classLWBackEnd_a53f309de2e633a8788fc67ba03d23675}{checkInterrupts} ()
\item 
{\footnotesize template$<$class T $>$ }\\\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classLWBackEnd_a0747777ac998dabdc20fa0c554d378d3}{read} (\hyperlink{classRequest}{RequestPtr} req, T \&data, int load\_\-idx)
\item 
{\footnotesize template$<$class T $>$ }\\\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classLWBackEnd_abbf7bcc93511421a1787650a43e2642a}{write} (\hyperlink{classRequest}{RequestPtr} req, T \&data, int store\_\-idx)
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classLWBackEnd_aa28f3fe58fde4b038a92b9f87a40cb10}{readCommitPC} ()
\item 
bool \hyperlink{classLWBackEnd_a5c38df1621043861ada4dd0939509869}{robEmpty} ()
\item 
bool \hyperlink{classLWBackEnd_a3e70330939fdfc4dbc2f60c1a660584d}{isFull} ()
\item 
bool \hyperlink{classLWBackEnd_ae6ec007d68382eb124ed25bc90ae9c17}{isBlocked} ()
\item 
void \hyperlink{classLWBackEnd_a71dcc69e5b01fa12b8ccd2dccdcc9917}{fetchFault} (\hyperlink{classRefCountingPtr}{Fault} \&fault)
\item 
int \hyperlink{classLWBackEnd_a044f74c5b9426d9738e2d015395a3e72}{wakeDependents} (\hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst, bool memory\_\-deps=false)
\item 
void \hyperlink{classLWBackEnd_aa9c46f45f491ef90a936c7e2b95f20aa}{rescheduleMemInst} (\hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classLWBackEnd_ae165df775b4de9e9430228c7f04c2bc9}{replayMemInst} (\hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classLWBackEnd_a2212f511dc1886c073cf7ff1665f5c87}{completeMemInst} (\hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classLWBackEnd_a1a46c3adb06eeecca716b3cffb054d84}{addDcacheMiss} (\hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classLWBackEnd_a3eec16e4a583e6312ba14ffe5a004296}{removeDcacheMiss} (\hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classLWBackEnd_a965a423ceedaeb3ec978531621234d0e}{addWaitingMemOp} (\hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classLWBackEnd_a38f3385718380c23fe08a81063cc37e1}{removeWaitingMemOp} (\hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classLWBackEnd_a720e9865ffa6e84b756f5ec1d1a24d94}{instToCommit} (\hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classLWBackEnd_aaf16f1d27dc8f5db83c4d2b981a100a9}{readyInstsForCommit} ()
\item 
void \hyperlink{classLWBackEnd_a05f299b443f8cc73a93d61572edc0218}{switchOut} ()
\item 
void \hyperlink{classLWBackEnd_a039b639c41c289e1cfe6d71c41d9308c}{doSwitchOut} ()
\item 
void \hyperlink{classLWBackEnd_a5a901e7ec5b94a55bd61fde88ad0b7f1}{takeOverFrom} (\hyperlink{classThreadContext}{ThreadContext} $\ast$old\_\-tc=NULL)
\item 
bool \hyperlink{classLWBackEnd_a471165257f311a78136ce991a3bad31a}{isSwitchedOut} ()
\item 
void \hyperlink{classLWBackEnd_a80587b4fe043bbe1995536cb3b361588}{dumpInsts} ()
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structLWBackEnd_1_1SizeStruct}{DispatchToIssue} $>$ \hyperlink{classLWBackEnd_ae446eaddd47d5f227ed00af24aaefe68}{d2i}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structLWBackEnd_1_1SizeStruct}{DispatchToIssue} $>$::wire \hyperlink{classLWBackEnd_ace1cd34be1eca99cb8c1d3a30e32fcbe}{instsToDispatch}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structLWBackEnd_1_1SizeStruct}{IssueToExec} $>$ \hyperlink{classLWBackEnd_a055203b013ada25d70a2a2c8b2364455}{i2e}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structLWBackEnd_1_1SizeStruct}{IssueToExec} $>$::wire \hyperlink{classLWBackEnd_a45c3ddf2275eab2326190578f1fcbee2}{instsToExecute}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structLWBackEnd_1_1SizeStruct}{ExecToCommit} $>$ \hyperlink{classLWBackEnd_a114248f83077c8e99f4f4aa0236aafeb}{e2c}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ int $>$ \hyperlink{classLWBackEnd_a34cd6ffaeb59e3f95f2cc2aaf8eb7ecf}{numInstsToWB}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classLWBackEnd_abdf3026ccc30c2ed3cb77dbe3cfbacad}{CommStruct} $>$ $\ast$ \hyperlink{classLWBackEnd_a282f2307a986f183b83e887756561687}{comm}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classLWBackEnd_abdf3026ccc30c2ed3cb77dbe3cfbacad}{CommStruct} $>$::wire \hyperlink{classLWBackEnd_acf56450a952ce19a7cc68c86f0334c0c}{toIEW}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classLWBackEnd_abdf3026ccc30c2ed3cb77dbe3cfbacad}{CommStruct} $>$::wire \hyperlink{classLWBackEnd_a77bf6c956edddf1d551d5371ff72162e}{fromCommit}
\item 
bool \hyperlink{classLWBackEnd_a9fe09e5855dab23839c125d21e03c644}{trapSquash}
\item 
bool \hyperlink{classLWBackEnd_ae3369c2288f4867553aaca811229bd3c}{tcSquash}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classLWBackEnd_af043d6103c5f173871f527899c41d2d2}{commitPC}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classLWBackEnd_aeb527b92e111b469a5358de46cc799b6}{lastCommitCycle}
\item 
\hyperlink{classOzoneCPU}{OzoneCPU} $\ast$ \hyperlink{classLWBackEnd_a61b5f503eec141308b0cd6b4322b405b}{cpu}
\item 
\hyperlink{classFrontEnd}{FrontEnd} $\ast$ \hyperlink{classLWBackEnd_a67c762418bb2017cb2dce5a0c94f0788}{frontEnd}
\item 
\hyperlink{classThreadContext}{ThreadContext} $\ast$ \hyperlink{classLWBackEnd_a4455a4759e69e5ebe68ae7298cbcc37d}{tc}
\item 
\hyperlink{structOzoneThreadState}{Thread} $\ast$ \hyperlink{classLWBackEnd_a743989b66f3b52f1eda2a8498a93da0b}{thread}
\item 
\hyperlink{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \hyperlink{classLWBackEnd_ae29aa2d4ae440022daaed1107eb306b3}{status}
\item 
\hyperlink{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \hyperlink{classLWBackEnd_a245e3bace7ab490110304d56450aba64}{dispatchStatus}
\item 
\hyperlink{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \hyperlink{classLWBackEnd_aed64bfbc119bb879e8625e3951e26502}{commitStatus}
\item 
\hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classLWBackEnd_a344acde4f72898017365be79fd18a323}{funcExeInst}
\item 
\hyperlink{classRenameTable}{RenameTable}$<$ Impl $>$ \hyperlink{classLWBackEnd_adbf41f9b1f8e58747002bd5f65f2ded9}{commitRenameTable}
\item 
\hyperlink{classRenameTable}{RenameTable}$<$ Impl $>$ \hyperlink{classLWBackEnd_af8d3f859e7c0dd9408ba99de6f415616}{renameTable}
\item 
\hyperlink{classChecker}{Checker}$<$ \hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ $\ast$ \hyperlink{classLWBackEnd_af07b45c0b87d6672f4066d2c189013f9}{checker}
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef Impl::LdstQueue \hyperlink{classLWBackEnd_a4c90230ea80fdcedea6e4fb9b43009cd}{LdstQueue}
\item 
typedef std::set$<$ \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} $>$::iterator \hyperlink{classLWBackEnd_a3beb474846c53de6d7b8047314dcf3cd}{MemIt}
\item 
typedef std::priority\_\-queue$<$ \hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}, \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$, \hyperlink{structLWBackEnd_1_1pqCompare}{pqCompare} $>$ \hyperlink{classLWBackEnd_a60636ae8f3b649078c4f1bdd3b20dcad}{ReadyInstQueue}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$::iterator \hyperlink{classLWBackEnd_a4da46d72d68fcd5bfe65dc701c358379}{InstListIt}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classLWBackEnd_a17fd6203f0789b68f99f618ea93ab6e0}{generateTrapEvent} (\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classLWBackEnd_a9c5bf07170b5d91cfb44d4bfd0517128}{latency}=0)
\item 
void \hyperlink{classLWBackEnd_af3d02b2950c0aaa8cd71d422abd0ef51}{handleFault} (\hyperlink{classRefCountingPtr}{Fault} \&fault, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classLWBackEnd_a9c5bf07170b5d91cfb44d4bfd0517128}{latency}=0)
\item 
void \hyperlink{classLWBackEnd_a1107d388cfcea92a9043608346ce98f0}{updateStructures} ()
\item 
void \hyperlink{classLWBackEnd_ac3f94deccc87588d728716efc4dd7ce8}{dispatchInsts} ()
\item 
void \hyperlink{classLWBackEnd_a3a69629e2b050560eb983bdedffc30ba}{dispatchStall} ()
\item 
void \hyperlink{classLWBackEnd_aee5c9997a61eb30564062dcdbda8c246}{checkDispatchStatus} ()
\item 
void \hyperlink{classLWBackEnd_a2d00e30d66a56e4667e28df302c98ac0}{executeInsts} ()
\item 
void \hyperlink{classLWBackEnd_ac8b85fbfdf330d000c094a9d1886d264}{commitInsts} ()
\item 
void \hyperlink{classLWBackEnd_a1b9c2184abc4f4e7a00285130f39bf26}{addToLSQ} (\hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classLWBackEnd_a5e9a203f943b3a8a243ddc6d2a0a240d}{writebackInsts} ()
\item 
bool \hyperlink{classLWBackEnd_a300f33ed45badc3c856983b1b7469955}{commitInst} (int inst\_\-num)
\item 
void \hyperlink{classLWBackEnd_adc9b67ce59b0b2e930cfaf6361ce42c5}{squash} (const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&sn)
\item 
void \hyperlink{classLWBackEnd_a05c89a1532adb13cc0632fc3bb600add}{squashDueToBranch} (\hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classLWBackEnd_a493d3b3596dc6e17cc56990a4e71602d}{squashDueToMemViolation} (\hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classLWBackEnd_a5fcf443dc6ada1ab1936df923c3205d2}{squashDueToMemBlocked} (\hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classLWBackEnd_a132db67a5c42af856da64e347e8284d8}{updateExeInstStats} (\hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classLWBackEnd_a5bbf266cb0cc97eed138c8fe0d2d76b6}{updateComInstStats} (\hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classLWBackEnd_a4c90230ea80fdcedea6e4fb9b43009cd}{LdstQueue} \hyperlink{classLWBackEnd_a2d033f80e55d1123d747d40f026042aa}{LSQ}
\item 
int \hyperlink{classLWBackEnd_a9c5bf07170b5d91cfb44d4bfd0517128}{latency}
\item 
int \hyperlink{classLWBackEnd_a2474a5474cbff19523a51eb1de01cda4}{width}
\item 
int \hyperlink{classLWBackEnd_aa304d4c426ea2bba52be0a3c0b9811e3}{dispatchWidth}
\item 
int \hyperlink{classLWBackEnd_a32343e1e9e56c17bb868f861f9b8927d}{dispatchSize}
\item 
int \hyperlink{classLWBackEnd_a9b9600f987928599f17c3549b0de891a}{waitingInsts}
\item 
int \hyperlink{classLWBackEnd_a171bac1210be84c8811563ab35209fce}{issueWidth}
\item 
int \hyperlink{classLWBackEnd_a20d3086e6bcdc826d99143ac7c9b23a4}{wbWidth}
\item 
int \hyperlink{classLWBackEnd_a328db48cdab1c2a18d8432b647e2785b}{commitWidth}
\item 
unsigned \hyperlink{classLWBackEnd_a5fa0799bf5569437190dd1eda1d62b7b}{wbNumInst}
\item 
unsigned \hyperlink{classLWBackEnd_ad2c7b2687f864f2b7359eb393276996f}{wbCycle}
\item 
int \hyperlink{classLWBackEnd_ae40678133a160367f2207f07975ca0f3}{numROBEntries}
\item 
int \hyperlink{classLWBackEnd_a358c879c68910efe5300c4515df35b6c}{numInsts}
\item 
bool \hyperlink{classLWBackEnd_a448f97a01f3a53c40ed453a5e27c02ab}{lsqLimits}
\item 
std::set$<$ \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} $>$ \hyperlink{classLWBackEnd_af9ed5543b904bf082a41d640654588e5}{waitingMemOps}
\item 
int \hyperlink{classLWBackEnd_a96e0941aaf8a2dd157434967a452531b}{numWaitingMemOps}
\item 
unsigned \hyperlink{classLWBackEnd_ad6fbab05ce17a32ecda942c0cf4398ae}{maxOutstandingMemOps}
\item 
bool \hyperlink{classLWBackEnd_a2aafb6fc593b04986eeed845923a8953}{squashPending}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classLWBackEnd_a34292b1418c46ca63c892e7826510d77}{squashSeqNum}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classLWBackEnd_aabe0c73b4678ef858d3363c9bed18906}{squashNextPC}
\item 
bool \hyperlink{classLWBackEnd_a1aee6db9bfb75cf02e38a82e5d02847f}{switchedOut}
\item 
bool \hyperlink{classLWBackEnd_ace47ce39eea04902597d72ae3040c322}{switchPending}
\item 
\hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classLWBackEnd_aba4f4d748e592a95e9a44184b2f4cfa9}{memBarrier}
\item 
\hyperlink{classLWBackEnd_a60636ae8f3b649078c4f1bdd3b20dcad}{ReadyInstQueue} \hyperlink{classLWBackEnd_a033c224149bfca7d589121bf77f1b681}{exeList}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classLWBackEnd_ae10a391d02ce1ef67ee13cd82b7d46e5}{instList}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classLWBackEnd_a01b09fb4e81dae8e11ca298561afebe9}{waitingList}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classLWBackEnd_a75af5d227f5f7bbb93a6bb4bf680e6ee}{replayList}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classLWBackEnd_ae4b76f4612be07d13b349e13ee9dfa16}{writeback}
\item 
int \hyperlink{classLWBackEnd_a440f8cda1481977c324a827c7c9f1e24}{squashLatency}
\item 
bool \hyperlink{classLWBackEnd_a319e9530b28153883e886be5b9c573eb}{exactFullStall}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a746b17c64f4337f2cf0bd3eb37df8cf5}{robCapEvents}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_aea092d89c0e23a99adfd1aa642e8ad37}{robCapInstCount}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a18e004a2b90fafdb8e602ab4fd99f971}{iqCapEvents}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_adf3ce08ee23edc6f4b6d1dcea1b39b31}{iqCapInstCount}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a02103b42af4cd3d8b606764dcd24e277}{exeInst}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a149e196f188dd6166c0c8c16cc023ad2}{exeSwp}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_acada805051a7dbb6b8459c5856be8a01}{exeNop}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_aad83ba41ef04d5d18ea21b492e5b2313}{exeRefs}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_acdffd7467b37177b4352cc95a4541c7d}{exeLoads}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a1c8de90750d60821aba6ab2e07c3564c}{exeBranches}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_ace641e242f8066857ee021c0f54488fc}{issuedOps}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a8360980798f5ee19e9b6a40c1d2402dd}{lsqForwLoads}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_ab6f202cc22f2199e7d5cafb2e5af3451}{invAddrLoads}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a188a7b143a76b88b85fb994dbdd7e0ea}{invAddrSwpfs}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a4b6441df3c51e29c627f7dbf5bed8409}{lsqBlockedLoads}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classLWBackEnd_abf96f4acba126fbcf919829a1125954c}{lsqInversion}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a63ce9344b46599ab3db4eb196ee89799}{nIssuedDist}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a85f5041a2e3375a2dc81bc0ae534aa2e}{writebackCount}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a79df9c76c4c8c7da92694a4a571d44f0}{producerInst}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a69b21b8b0360b93b3088bbf183fe6abf}{consumerInst}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a364daa8f3a358e41aa13fac115bb5e0f}{wbPenalized}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classLWBackEnd_a5ab2bb9fa8eb98a735a204082a37c9db}{wbRate}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classLWBackEnd_a667246d811337454bc9ceccf8bbf8f1c}{wbFanout}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classLWBackEnd_a58a4cd085d39435e69bc1ee729422d84}{wbPenalizedRate}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a17e218fe16ffffa3f596551115cf1592}{statComInst}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a4cb385aa97530dd2621c74f376839e79}{statComSwp}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_afe174c4b8e70d840a2e91bf1ca3092ac}{statComRefs}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a91927819864b9dc9d1ac706dc55d5dce}{statComLoads}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a9b029ac182d54199247dfa90ed86d368}{statComMembars}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a39a7da0b20d1e83ccfe4b2f2b19d6e94}{statComBranches}
\item 
\hyperlink{classStats_1_1Distribution}{Stats::Distribution} \hyperlink{classLWBackEnd_a95950b28aceca73a1f17427dd767552d}{nCommittedDist}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classLWBackEnd_a16d1a4bbb2cb87488fd876fbf6e7a518}{commitEligibleSamples}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a26f5138543e43cbaba9459036fc0b04c}{commitEligible}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_ab27e4267b3c35957215c1c88c2d6462a}{squashedInsts}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_ae0e4c1bd43a0cb1f736062e536168fa3}{ROBSquashedInsts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classLWBackEnd_afdfe647a67d89f9620c69019c79547be}{ROBFcount}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classLWBackEnd_a26d90e83e9d707184d857b5df610d726}{ROBFullRate}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classLWBackEnd_a39034d47fcced7afdc840710ff261574}{ROBCount}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classLWBackEnd_afb382907daa4161f6ea36acfab3a1c40}{ROBOccRate}
\end{DoxyCompactItemize}
\subsubsection*{template$<$class Impl$>$ class LWBackEnd$<$ Impl $>$}



\subsection{型定義}
\hypertarget{classLWBackEnd_abdf3026ccc30c2ed3cb77dbe3cfbacad}{
\index{LWBackEnd@{LWBackEnd}!CommStruct@{CommStruct}}
\index{CommStruct@{CommStruct}!LWBackEnd@{LWBackEnd}}
\subsubsection[{CommStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::OzoneCPU::CommStruct {\bf CommStruct}}}
\label{classLWBackEnd_abdf3026ccc30c2ed3cb77dbe3cfbacad}
\hypertarget{classLWBackEnd_a99d236038ce57aa3ef78858228c5f972}{
\index{LWBackEnd@{LWBackEnd}!DispatchToIssue@{DispatchToIssue}}
\index{DispatchToIssue@{DispatchToIssue}!LWBackEnd@{LWBackEnd}}
\subsubsection[{DispatchToIssue}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf SizeStruct} {\bf DispatchToIssue}}}
\label{classLWBackEnd_a99d236038ce57aa3ef78858228c5f972}
\hypertarget{classLWBackEnd_ab741745c86a14c765b999c11167636d9}{
\index{LWBackEnd@{LWBackEnd}!DynInst@{DynInst}}
\index{DynInst@{DynInst}!LWBackEnd@{LWBackEnd}}
\subsubsection[{DynInst}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInst {\bf DynInst}}}
\label{classLWBackEnd_ab741745c86a14c765b999c11167636d9}
\hypertarget{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}{
\index{LWBackEnd@{LWBackEnd}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!LWBackEnd@{LWBackEnd}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInstPtr {\bf DynInstPtr}}}
\label{classLWBackEnd_a028ce10889c5f6450239d9e9a7347976}
\hypertarget{classLWBackEnd_a91ea582041466725b4b17ce19f98685f}{
\index{LWBackEnd@{LWBackEnd}!ExecToCommit@{ExecToCommit}}
\index{ExecToCommit@{ExecToCommit}!LWBackEnd@{LWBackEnd}}
\subsubsection[{ExecToCommit}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf SizeStruct} {\bf ExecToCommit}}}
\label{classLWBackEnd_a91ea582041466725b4b17ce19f98685f}
\hypertarget{classLWBackEnd_abe8e1d8243582d5024a1076f6091d9fe}{
\index{LWBackEnd@{LWBackEnd}!FrontEnd@{FrontEnd}}
\index{FrontEnd@{FrontEnd}!LWBackEnd@{LWBackEnd}}
\subsubsection[{FrontEnd}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::FrontEnd {\bf FrontEnd}}}
\label{classLWBackEnd_abe8e1d8243582d5024a1076f6091d9fe}
\hypertarget{classLWBackEnd_a4da46d72d68fcd5bfe65dc701c358379}{
\index{LWBackEnd@{LWBackEnd}!InstListIt@{InstListIt}}
\index{InstListIt@{InstListIt}!LWBackEnd@{LWBackEnd}}
\subsubsection[{InstListIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf DynInstPtr}$>$::iterator {\bf InstListIt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a4da46d72d68fcd5bfe65dc701c358379}
\hypertarget{classLWBackEnd_a5badfe54e71b8fccb3d371013a8eef73}{
\index{LWBackEnd@{LWBackEnd}!IssueToExec@{IssueToExec}}
\index{IssueToExec@{IssueToExec}!LWBackEnd@{LWBackEnd}}
\subsubsection[{IssueToExec}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf SizeStruct} {\bf IssueToExec}}}
\label{classLWBackEnd_a5badfe54e71b8fccb3d371013a8eef73}
\hypertarget{classLWBackEnd_a4c90230ea80fdcedea6e4fb9b43009cd}{
\index{LWBackEnd@{LWBackEnd}!LdstQueue@{LdstQueue}}
\index{LdstQueue@{LdstQueue}!LWBackEnd@{LWBackEnd}}
\subsubsection[{LdstQueue}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::LdstQueue {\bf LdstQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a4c90230ea80fdcedea6e4fb9b43009cd}
\hypertarget{classLWBackEnd_a3beb474846c53de6d7b8047314dcf3cd}{
\index{LWBackEnd@{LWBackEnd}!MemIt@{MemIt}}
\index{MemIt@{MemIt}!LWBackEnd@{LWBackEnd}}
\subsubsection[{MemIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef std::set$<${\bf InstSeqNum}$>$::iterator {\bf MemIt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a3beb474846c53de6d7b8047314dcf3cd}
\hypertarget{classLWBackEnd_a9730cc41bccb218cae8f32869b8d887e}{
\index{LWBackEnd@{LWBackEnd}!OzoneCPU@{OzoneCPU}}
\index{OzoneCPU@{OzoneCPU}!LWBackEnd@{LWBackEnd}}
\subsubsection[{OzoneCPU}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::OzoneCPU {\bf OzoneCPU}}}
\label{classLWBackEnd_a9730cc41bccb218cae8f32869b8d887e}
\hypertarget{classLWBackEnd_a818e103eae798a24a06a0a34631849ea}{
\index{LWBackEnd@{LWBackEnd}!Params@{Params}}
\index{Params@{Params}!LWBackEnd@{LWBackEnd}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::Params {\bf Params}}}
\label{classLWBackEnd_a818e103eae798a24a06a0a34631849ea}
\hypertarget{classLWBackEnd_a60636ae8f3b649078c4f1bdd3b20dcad}{
\index{LWBackEnd@{LWBackEnd}!ReadyInstQueue@{ReadyInstQueue}}
\index{ReadyInstQueue@{ReadyInstQueue}!LWBackEnd@{LWBackEnd}}
\subsubsection[{ReadyInstQueue}]{\setlength{\rightskip}{0pt plus 5cm}typedef std::priority\_\-queue$<${\bf DynInstPtr}, {\bf std::vector}$<${\bf DynInstPtr}$>$, {\bf pqCompare}$>$ {\bf ReadyInstQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a60636ae8f3b649078c4f1bdd3b20dcad}
\hypertarget{classLWBackEnd_a9311aca87e8229ec3f7a7422ccbc9fbe}{
\index{LWBackEnd@{LWBackEnd}!Thread@{Thread}}
\index{Thread@{Thread}!LWBackEnd@{LWBackEnd}}
\subsubsection[{Thread}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf OzoneThreadState}$<$Impl$>$ {\bf Thread}}}
\label{classLWBackEnd_a9311aca87e8229ec3f7a7422ccbc9fbe}
\hypertarget{classLWBackEnd_a20d1fb15b536d49c687dee42d95c1a87}{
\index{LWBackEnd@{LWBackEnd}!Writeback@{Writeback}}
\index{Writeback@{Writeback}!LWBackEnd@{LWBackEnd}}
\subsubsection[{Writeback}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf SizeStruct} {\bf Writeback}}}
\label{classLWBackEnd_a20d1fb15b536d49c687dee42d95c1a87}


\subsection{列挙型}
\hypertarget{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}{
\index{LWBackEnd@{LWBackEnd}!Status@{Status}}
\index{Status@{Status}!LWBackEnd@{LWBackEnd}}
\subsubsection[{Status}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Status}}}
\label{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Running@{Running}!LWBackEnd@{LWBackEnd}}\index{LWBackEnd@{LWBackEnd}!Running@{Running}}\item[{\em 
\hypertarget{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}{
Running}
\label{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}
}]\index{Idle@{Idle}!LWBackEnd@{LWBackEnd}}\index{LWBackEnd@{LWBackEnd}!Idle@{Idle}}\item[{\em 
\hypertarget{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}{
Idle}
\label{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}
}]\index{DcacheMissStall@{DcacheMissStall}!LWBackEnd@{LWBackEnd}}\index{LWBackEnd@{LWBackEnd}!DcacheMissStall@{DcacheMissStall}}\item[{\em 
\hypertarget{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba4ba5ae5815b190bd652669e2fdea5ed7}{
DcacheMissStall}
\label{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba4ba5ae5815b190bd652669e2fdea5ed7}
}]\index{DcacheMissComplete@{DcacheMissComplete}!LWBackEnd@{LWBackEnd}}\index{LWBackEnd@{LWBackEnd}!DcacheMissComplete@{DcacheMissComplete}}\item[{\em 
\hypertarget{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba1eb81f4540c1c4b90839b08ae63c5d7f}{
DcacheMissComplete}
\label{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba1eb81f4540c1c4b90839b08ae63c5d7f}
}]\index{Blocked@{Blocked}!LWBackEnd@{LWBackEnd}}\index{LWBackEnd@{LWBackEnd}!Blocked@{Blocked}}\item[{\em 
\hypertarget{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba9463ee9b8700258a1019b4b9d2d77a30}{
Blocked}
\label{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba9463ee9b8700258a1019b4b9d2d77a30}
}]\index{TrapPending@{TrapPending}!LWBackEnd@{LWBackEnd}}\index{LWBackEnd@{LWBackEnd}!TrapPending@{TrapPending}}\item[{\em 
\hypertarget{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba8c49adf6da5f507150d403610c684877}{
TrapPending}
\label{classLWBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba8c49adf6da5f507150d403610c684877}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
233                 {
234         Running,
235         Idle,
236         DcacheMissStall,
237         DcacheMissComplete,
238         Blocked,
239         TrapPending
240     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classLWBackEnd_a547c62cea335ccc135b28bf60afc1a65}{
\index{LWBackEnd@{LWBackEnd}!LWBackEnd@{LWBackEnd}}
\index{LWBackEnd@{LWBackEnd}!LWBackEnd@{LWBackEnd}}
\subsubsection[{LWBackEnd}]{\setlength{\rightskip}{0pt plus 5cm}{\bf LWBackEnd} ({\bf Params} $\ast$ {\em params})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a547c62cea335ccc135b28bf60afc1a65}



\begin{DoxyCode}
142     : d2i(5, 5), i2e(5, 5), e2c(5, 5), numInstsToWB(params->backEndLatency, 0),
143       trapSquash(false), tcSquash(false),
144       latency(params->backEndLatency),
145       width(params->backEndWidth), lsqLimits(params->lsqLimits),
146       exactFullStall(true)
147 {
148     numROBEntries = params->numROBEntries;
149     numInsts = 0;
150     maxOutstandingMemOps = params->maxOutstandingMemOps;
151     numWaitingMemOps = 0;
152     waitingInsts = 0;
153     switchedOut = false;
154     switchPending = false;
155 
156     LSQ.setBE(this);
157 
158     // Setup IQ and LSQ with their parameters here.
159     instsToDispatch = d2i.getWire(-1);
160 
161     instsToExecute = i2e.getWire(-1);
162 
163     dispatchWidth = params->dispatchWidth ? params->dispatchWidth : width;
164     issueWidth = params->issueWidth ? params->issueWidth : width;
165     wbWidth = params->wbWidth ? params->wbWidth : width;
166     commitWidth = params->commitWidth ? params->commitWidth : width;
167 
168     LSQ.init(params, params->LQEntries, params->SQEntries, 0);
169 
170     dispatchStatus = Running;
171     commitStatus = Running;
172 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classLWBackEnd_a1a46c3adb06eeecca716b3cffb054d84}{
\index{LWBackEnd@{LWBackEnd}!addDcacheMiss@{addDcacheMiss}}
\index{addDcacheMiss@{addDcacheMiss}!LWBackEnd@{LWBackEnd}}
\subsubsection[{addDcacheMiss}]{\setlength{\rightskip}{0pt plus 5cm}void addDcacheMiss ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a1a46c3adb06eeecca716b3cffb054d84}



\begin{DoxyCode}
163     {
164         waitingMemOps.insert(inst->seqNum);
165         numWaitingMemOps++;
166         DPRINTF(BE, "Adding a Dcache miss mem op [sn:%lli], total %i\n",
167                 inst->seqNum, numWaitingMemOps);
168     }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a1b9c2184abc4f4e7a00285130f39bf26}{
\index{LWBackEnd@{LWBackEnd}!addToLSQ@{addToLSQ}}
\index{addToLSQ@{addToLSQ}!LWBackEnd@{LWBackEnd}}
\subsubsection[{addToLSQ}]{\setlength{\rightskip}{0pt plus 5cm}void addToLSQ ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLWBackEnd_a1b9c2184abc4f4e7a00285130f39bf26}



\begin{DoxyCode}
661 {
662     // Do anything LSQ specific here?
663     LSQ.insert(inst);
664 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a965a423ceedaeb3ec978531621234d0e}{
\index{LWBackEnd@{LWBackEnd}!addWaitingMemOp@{addWaitingMemOp}}
\index{addWaitingMemOp@{addWaitingMemOp}!LWBackEnd@{LWBackEnd}}
\subsubsection[{addWaitingMemOp}]{\setlength{\rightskip}{0pt plus 5cm}void addWaitingMemOp ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a965a423ceedaeb3ec978531621234d0e}



\begin{DoxyCode}
180     {
181         waitingMemOps.insert(inst->seqNum);
182         numWaitingMemOps++;
183         DPRINTF(BE, "Adding a waiting mem op [sn:%lli], total %i\n",
184                 inst->seqNum, numWaitingMemOps);
185     }
\end{DoxyCode}
\hypertarget{classLWBackEnd_aee5c9997a61eb30564062dcdbda8c246}{
\index{LWBackEnd@{LWBackEnd}!checkDispatchStatus@{checkDispatchStatus}}
\index{checkDispatchStatus@{checkDispatchStatus}!LWBackEnd@{LWBackEnd}}
\subsubsection[{checkDispatchStatus}]{\setlength{\rightskip}{0pt plus 5cm}void checkDispatchStatus ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLWBackEnd_aee5c9997a61eb30564062dcdbda8c246}



\begin{DoxyCode}
812 {
813     DPRINTF(BE, "Checking dispatch status\n");
814     assert(dispatchStatus == Blocked);
815     if (!LSQ.isFull() && !isFull()) {
816         DPRINTF(BE, "Dispatch no longer blocked\n");
817         dispatchStatus = Running;
818         dispatchInsts();
819     }
820 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a53f309de2e633a8788fc67ba03d23675}{
\index{LWBackEnd@{LWBackEnd}!checkInterrupts@{checkInterrupts}}
\index{checkInterrupts@{checkInterrupts}!LWBackEnd@{LWBackEnd}}
\subsubsection[{checkInterrupts}]{\setlength{\rightskip}{0pt plus 5cm}void checkInterrupts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a53f309de2e633a8788fc67ba03d23675}



\begin{DoxyCode}
524 {
525     if (cpu->checkInterrupts(tc) && !trapSquash && !tcSquash) {
526         frontEnd->interruptPending = true;
527         if (robEmpty() && !LSQ.hasStoresToWB()) {
528             // Will need to squash all instructions currently in flight and have
529             // the interrupt handler restart at the last non-committed inst.
530             // Most of that can be handled through the trap() function.  The
531             // processInterrupts() function really just checks for interrupts
532             // and then calls trap() if there is an interrupt present.
533 
534             // Not sure which thread should be the one to interrupt.  For now
535             // always do thread 0.
536             assert(!thread->noSquashFromTC);
537             thread->noSquashFromTC = true;
538 
539             // CPU will handle implementation of the interrupt.
540             cpu->processInterrupts();
541 
542             // Now squash or record that I need to squash this cycle.
543             commitStatus = TrapPending;
544 
545             // Exit state update mode to avoid accidental updating.
546             thread->noSquashFromTC = false;
547 
548             // Generate trap squash event.
549             generateTrapEvent();
550 
551             DPRINTF(BE, "Interrupt detected.\n");
552         } else {
553             DPRINTF(BE, "Interrupt must wait for ROB to drain.\n");
554         }
555     }
556 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a300f33ed45badc3c856983b1b7469955}{
\index{LWBackEnd@{LWBackEnd}!commitInst@{commitInst}}
\index{commitInst@{commitInst}!LWBackEnd@{LWBackEnd}}
\subsubsection[{commitInst}]{\setlength{\rightskip}{0pt plus 5cm}bool commitInst (int {\em inst\_\-num})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLWBackEnd_a300f33ed45badc3c856983b1b7469955}



\begin{DoxyCode}
1022 {
1023     // Read instruction from the head of the ROB
1024     DynInstPtr inst = instList.back();
1025 
1026     // Make sure instruction is valid
1027     assert(inst);
1028 
1029     if (!inst->readyToCommit())
1030         return false;
1031 
1032     DPRINTF(BE, "Trying to commit instruction [sn:%lli] PC:%#x\n",
1033             inst->seqNum, inst->readPC());
1034 
1035     thread->setPC(inst->readPC());
1036     thread->setNextPC(inst->readNextPC());
1037     inst->setAtCommit();
1038 
1039     // If the instruction is not executed yet, then it is a non-speculative
1040     // or store inst.  Signal backwards that it should be executed.
1041     if (!inst->isExecuted()) {
1042         if (inst->isNonSpeculative() ||
1043             (inst->isStoreConditional() && inst->getFault() == NoFault) ||
1044             inst->isMemBarrier() ||
1045             inst->isWriteBarrier()) {
1046             if ((inst->isMemBarrier() || inst->isWriteBarrier() ||
1047                     inst->isQuiesce()) && LSQ.hasStoresToWB())
1048             {
1049                 DPRINTF(BE, "Waiting for all stores to writeback.\n");
1050                 return false;
1051             }
1052 
1053             DPRINTF(BE, "Encountered a store or non-speculative "
1054                     "instruction at the head of the ROB, PC %#x.\n",
1055                     inst->readPC());
1056 
1057             if (inst->isMemBarrier() || inst->isWriteBarrier()) {
1058                 DPRINTF(BE, "Waking dependents on barrier [sn:%lli]\n",
1059                         inst->seqNum);
1060                 assert(memBarrier);
1061                 wakeDependents(inst, true);
1062                 if (memBarrier == inst)
1063                     memBarrier = NULL;
1064                 inst->clearMemDependents();
1065             }
1066 
1067             // Send back the non-speculative instruction's sequence number.
1068             if (inst->iqItValid) {
1069                 DPRINTF(BE, "Removing instruction from waiting list\n");
1070                 waitingList.erase(inst->iqIt);
1071                 inst->iqItValid = false;
1072                 waitingInsts--;
1073                 assert(waitingInsts >= 0);
1074                 if (inst->isStore())
1075                     removeWaitingMemOp(inst);
1076             }
1077 
1078             exeList.push(inst);
1079 
1080             // Change the instruction so it won't try to commit again until
1081             // it is executed.
1082             inst->clearCanCommit();
1083 
1084 //            ++commitNonSpecStalls;
1085 
1086             return false;
1087         } else if (inst->isLoad()) {
1088             DPRINTF(BE, "[sn:%lli]: Uncached load, PC %#x.\n",
1089                     inst->seqNum, inst->readPC());
1090 
1091             // Send back the non-speculative instruction's sequence
1092             // number.  Maybe just tell the lsq to re-execute the load.
1093 
1094             // Send back the non-speculative instruction's sequence number.
1095             if (inst->iqItValid) {
1096                 DPRINTF(BE, "Removing instruction from waiting list\n");
1097                 waitingList.erase(inst->iqIt);
1098                 inst->iqItValid = false;
1099                 waitingInsts--;
1100                 assert(waitingInsts >= 0);
1101                 removeWaitingMemOp(inst);
1102             }
1103             replayMemInst(inst);
1104 
1105             inst->clearCanCommit();
1106 
1107             return false;
1108         } else {
1109             panic("Trying to commit un-executed instruction "
1110                   "of unknown type!\n");
1111         }
1112     }
1113 
1114     // Not handled for now.
1115     assert(!inst->isThreadSync());
1116     assert(inst->memDepReady());
1117     // Stores will mark themselves as totally completed as they need
1118     // to wait to writeback to memory.  @todo: Hack...attempt to fix
1119     // having the checker be forced to wait until a store completes in
1120     // order to check all of the instructions.  If the store at the
1121     // head of the check list misses, but a later store hits, then
1122     // loads in the checker may see the younger store values instead
1123     // of the store they should see.  Either the checker needs its own
1124     // memory (annoying to update), its own store buffer (how to tell
1125     // which value is correct?), or something else...
1126     if (!inst->isStore()) {
1127         inst->setCompleted();
1128     }
1129     // Check if the instruction caused a fault.  If so, trap.
1130     Fault inst_fault = inst->getFault();
1131 
1132     // Use checker prior to updating anything due to traps or PC
1133     // based events.
1134     if (checker) {
1135         checker->verify(inst);
1136     }
1137 
1138     if (inst_fault != NoFault) {
1139         DPRINTF(BE, "Inst [sn:%lli] PC %#x has a fault\n",
1140                 inst->seqNum, inst->readPC());
1141 
1142         // Instruction is completed as it has a fault.
1143         inst->setCompleted();
1144 
1145         if (LSQ.hasStoresToWB()) {
1146             DPRINTF(BE, "Stores still in flight, will wait until drained.\n");
1147             return false;
1148         } else if (inst_num != 0) {
1149             DPRINTF(BE, "Will wait until instruction is head of commit group.\n")
      ;
1150             return false;
1151         }
1152         else if (checker && inst->isStore()) {
1153             checker->verify(inst);
1154         }
1155 
1156         handleFault(inst_fault);
1157         return false;
1158     }
1159 
1160     int freed_regs = 0;
1161 
1162     for (int i = 0; i < inst->numDestRegs(); ++i) {
1163         DPRINTF(BE, "Commit rename map setting reg %i to [sn:%lli]\n",
1164                 (int)inst->destRegIdx(i), inst->seqNum);
1165         thread->renameTable[inst->destRegIdx(i)] = inst;
1166         ++freed_regs;
1167     }
1168 
1169     if (FullSystem && thread->profile) {
1170         thread->profilePC = inst->readPC();
1171         ProfileNode *node = thread->profile->consume(thread->getTC(),
1172                                                      inst->staticInst);
1173 
1174         if (node)
1175             thread->profileNode = node;
1176     }
1177 
1178     if (inst->traceData) {
1179         inst->traceData->setFetchSeq(inst->seqNum);
1180         inst->traceData->setCPSeq(thread->numInst);
1181         inst->traceData->finalize();
1182         inst->traceData = NULL;
1183     }
1184 
1185     inst->clearDependents();
1186 
1187     frontEnd->addFreeRegs(freed_regs);
1188 
1189     instList.pop_back();
1190 
1191     --numInsts;
1192     ++thread->funcExeInst;
1193     // Maybe move this to where the fault is handled; if the fault is
1194     // handled, don't try to set this myself as the fault will set it.
1195     // If not, then I set thread->PC = thread->nextPC and
1196     // thread->nextPC = thread->nextPC + 4.
1197     thread->setPC(thread->readNextPC());
1198     thread->setNextPC(thread->readNextPC() + sizeof(TheISA::MachInst));
1199     updateComInstStats(inst);
1200 
1201     // Write the done sequence number here.
1202     toIEW->doneSeqNum = inst->seqNum;
1203     lastCommitCycle = curTick();
1204 
1205     if (FullSystem) {
1206         int count = 0;
1207         Addr oldpc;
1208         do {
1209             if (count == 0)
1210                 assert(!thread->noSquashFromTC && !thread->trapPending);
1211             oldpc = thread->readPC();
1212             cpu->system->pcEventQueue.service(
1213                 thread->getTC());
1214             count++;
1215         } while (oldpc != thread->readPC());
1216         if (count > 1) {
1217             DPRINTF(BE, "PC skip function event, stopping commit\n");
1218             tcSquash = true;
1219             return false;
1220         }
1221     }
1222     return true;
1223 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_ac8b85fbfdf330d000c094a9d1886d264}{
\index{LWBackEnd@{LWBackEnd}!commitInsts@{commitInsts}}
\index{commitInsts@{commitInsts}!LWBackEnd@{LWBackEnd}}
\subsubsection[{commitInsts}]{\setlength{\rightskip}{0pt plus 5cm}void commitInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLWBackEnd_ac8b85fbfdf330d000c094a9d1886d264}



\begin{DoxyCode}
1228 {
1229     // Not sure this should be a loop or not.
1230     int inst_num = 0;
1231     while (!instList.empty() && inst_num < commitWidth) {
1232         if (instList.back()->isSquashed()) {
1233             instList.back()->clearDependents();
1234             ROBSquashedInsts[instList.back()->threadNumber]++;
1235             instList.pop_back();
1236             --numInsts;
1237             continue;
1238         }
1239 
1240         if (!commitInst(inst_num++)) {
1241             DPRINTF(BE, "Can't commit, Instruction [sn:%lli] PC "
1242                     "%#x is head of ROB and not ready\n",
1243                     instList.back()->seqNum, instList.back()->readPC());
1244             --inst_num;
1245             break;
1246         }
1247     }
1248     nCommittedDist.sample(inst_num);
1249 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a2212f511dc1886c073cf7ff1665f5c87}{
\index{LWBackEnd@{LWBackEnd}!completeMemInst@{completeMemInst}}
\index{completeMemInst@{completeMemInst}!LWBackEnd@{LWBackEnd}}
\subsubsection[{completeMemInst}]{\setlength{\rightskip}{0pt plus 5cm}void completeMemInst ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a2212f511dc1886c073cf7ff1665f5c87}
Completes memory instruction. 


\begin{DoxyCode}
160 { }
\end{DoxyCode}
\hypertarget{classLWBackEnd_ac3f94deccc87588d728716efc4dd7ce8}{
\index{LWBackEnd@{LWBackEnd}!dispatchInsts@{dispatchInsts}}
\index{dispatchInsts@{dispatchInsts}!LWBackEnd@{LWBackEnd}}
\subsubsection[{dispatchInsts}]{\setlength{\rightskip}{0pt plus 5cm}void dispatchInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLWBackEnd_ac3f94deccc87588d728716efc4dd7ce8}



\begin{DoxyCode}
669 {
670     DPRINTF(BE, "Trying to dispatch instructions.\n");
671 
672     while (numInsts < numROBEntries &&
673            numWaitingMemOps < maxOutstandingMemOps) {
674         // Get instruction from front of time buffer
675         if (lsqLimits && LSQ.isFull()) {
676             break;
677         }
678 
679         DynInstPtr inst = frontEnd->getInst();
680         if (!inst) {
681             break;
682         } else if (inst->isSquashed()) {
683             continue;
684         }
685 
686         ++numInsts;
687         instList.push_front(inst);
688 
689         inst->setInROB();
690 
691         DPRINTF(BE, "Dispatching instruction [sn:%lli] PC:%#x\n",
692                 inst->seqNum, inst->readPC());
693 
694         for (int i = 0; i < inst->numDestRegs(); ++i)
695             renameTable[inst->destRegIdx(i)] = inst;
696 
697         if (inst->isMemBarrier() || inst->isWriteBarrier()) {
698             if (memBarrier) {
699                 DPRINTF(BE, "Instruction [sn:%lli] is waiting on "
700                         "barrier [sn:%lli].\n",
701                         inst->seqNum, memBarrier->seqNum);
702                 memBarrier->addMemDependent(inst);
703                 inst->addSrcMemInst(memBarrier);
704             }
705             memBarrier = inst;
706             inst->setCanCommit();
707         } else if (inst->readyToIssue() &&
708                    !inst->isNonSpeculative() &&
709                    !inst->isStoreConditional()) {
710             if (inst->isMemRef()) {
711 
712                 LSQ.insert(inst);
713                 if (memBarrier) {
714                     DPRINTF(BE, "Instruction [sn:%lli] is waiting on "
715                             "barrier [sn:%lli].\n",
716                             inst->seqNum, memBarrier->seqNum);
717                     memBarrier->addMemDependent(inst);
718                     inst->addSrcMemInst(memBarrier);
719                     addWaitingMemOp(inst);
720 
721                     waitingList.push_front(inst);
722                     inst->iqIt = waitingList.begin();
723                     inst->iqItValid = true;
724                     waitingInsts++;
725                 } else {
726                     DPRINTF(BE, "Instruction [sn:%lli] ready, addding to "
727                             "exeList.\n",
728                             inst->seqNum);
729                     exeList.push(inst);
730                 }
731             } else if (inst->isNop()) {
732                 DPRINTF(BE, "Nop encountered [sn:%lli], skipping exeList.\n",
733                         inst->seqNum);
734                 inst->setIssued();
735                 inst->setExecuted();
736                 inst->setCanCommit();
737                 numInstsToWB[0]++;
738             } else {
739                 DPRINTF(BE, "Instruction [sn:%lli] ready, addding to "
740                         "exeList.\n",
741                         inst->seqNum);
742                 exeList.push(inst);
743             }
744         } else {
745             if (inst->isNonSpeculative() || inst->isStoreConditional()) {
746                 inst->setCanCommit();
747                 DPRINTF(BE, "Adding non speculative instruction\n");
748             }
749 
750             if (inst->isMemRef()) {
751                 addWaitingMemOp(inst);
752                 LSQ.insert(inst);
753                 if (memBarrier) {
754                     memBarrier->addMemDependent(inst);
755                     inst->addSrcMemInst(memBarrier);
756 
757                     DPRINTF(BE, "Instruction [sn:%lli] is waiting on "
758                             "barrier [sn:%lli].\n",
759                             inst->seqNum, memBarrier->seqNum);
760                 }
761             }
762 
763             DPRINTF(BE, "Instruction [sn:%lli] not ready, addding to "
764                     "waitingList.\n",
765                     inst->seqNum);
766             waitingList.push_front(inst);
767             inst->iqIt = waitingList.begin();
768             inst->iqItValid = true;
769             waitingInsts++;
770         }
771     }
772 
773     // Check if IQ or LSQ is full.  If so we'll need to break and stop
774     // removing instructions.  Also update the number of insts to remove
775     // from the queue.  Check here if we don't care about exact stall
776     // conditions.
777 /*
778     bool stall = false;
779     if (IQ.isFull()) {
780         DPRINTF(BE, "IQ is full!\n");
781         stall = true;
782     } else if (LSQ.isFull()) {
783         DPRINTF(BE, "LSQ is full!\n");
784         stall = true;
785     } else if (isFull()) {
786         DPRINTF(BE, "ROB is full!\n");
787         stall = true;
788         ROB_fcount++;
789     }
790     if (stall) {
791         d2i.advance();
792         dispatchStall();
793         return;
794     }
795 */
796 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a3a69629e2b050560eb983bdedffc30ba}{
\index{LWBackEnd@{LWBackEnd}!dispatchStall@{dispatchStall}}
\index{dispatchStall@{dispatchStall}!LWBackEnd@{LWBackEnd}}
\subsubsection[{dispatchStall}]{\setlength{\rightskip}{0pt plus 5cm}void dispatchStall ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLWBackEnd_a3a69629e2b050560eb983bdedffc30ba}



\begin{DoxyCode}
801 {
802     dispatchStatus = Blocked;
803     if (!cpu->decoupledFrontEnd) {
804         // Tell front end to stall here through a timebuffer, or just tell
805         // it directly.
806     }
807 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a039b639c41c289e1cfe6d71c41d9308c}{
\index{LWBackEnd@{LWBackEnd}!doSwitchOut@{doSwitchOut}}
\index{doSwitchOut@{doSwitchOut}!LWBackEnd@{LWBackEnd}}
\subsubsection[{doSwitchOut}]{\setlength{\rightskip}{0pt plus 5cm}void doSwitchOut ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a039b639c41c289e1cfe6d71c41d9308c}



\begin{DoxyCode}
1428 {
1429     switchedOut = true;
1430     switchPending = false;
1431     // Need to get rid of all committed, non-speculative state and write it
1432     // to memory/TC.  In this case this is stores that have committed and not
1433     // yet written back.
1434     assert(robEmpty());
1435     assert(!LSQ.hasStoresToWB());
1436     writeback.clear();
1437     for (int i = 0; i < numInstsToWB.getSize() + 1; ++i)
1438         numInstsToWB.advance();
1439 
1440 //    squash(0);
1441     assert(waitingList.empty());
1442     assert(instList.empty());
1443     assert(replayList.empty());
1444     assert(writeback.empty());
1445     LSQ.switchOut();
1446 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a80587b4fe043bbe1995536cb3b361588}{
\index{LWBackEnd@{LWBackEnd}!dumpInsts@{dumpInsts}}
\index{dumpInsts@{dumpInsts}!LWBackEnd@{LWBackEnd}}
\subsubsection[{dumpInsts}]{\setlength{\rightskip}{0pt plus 5cm}void dumpInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a80587b4fe043bbe1995536cb3b361588}



\begin{DoxyCode}
1542 {
1543     int num = 0;
1544     int valid_num = 0;
1545 
1546     InstListIt inst_list_it = --(instList.end());
1547 
1548     cprintf("ExeList size: %i\n", exeList.size());
1549 
1550     cprintf("Inst list size: %i\n", instList.size());
1551 
1552     while (inst_list_it != instList.end())
1553     {
1554         cprintf("Instruction:%i\n",
1555                 num);
1556         if (!(*inst_list_it)->isSquashed()) {
1557             if (!(*inst_list_it)->isIssued()) {
1558                 ++valid_num;
1559                 cprintf("Count:%i\n", valid_num);
1560             } else if ((*inst_list_it)->isMemRef() &&
1561                        !(*inst_list_it)->memOpDone) {
1562                 // Loads that have not been marked as executed still count
1563                 // towards the total instructions.
1564                 ++valid_num;
1565                 cprintf("Count:%i\n", valid_num);
1566             }
1567         }
1568 
1569         cprintf("PC:%#x\n[sn:%lli]\n[tid:%i]\n"
1570                 "Issued:%i\nSquashed:%i\n",
1571                 (*inst_list_it)->readPC(),
1572                 (*inst_list_it)->seqNum,
1573                 (*inst_list_it)->threadNumber,
1574                 (*inst_list_it)->isIssued(),
1575                 (*inst_list_it)->isSquashed());
1576 
1577         if ((*inst_list_it)->isMemRef()) {
1578             cprintf("MemOpDone:%i\n", (*inst_list_it)->memOpDone);
1579         }
1580 
1581         cprintf("\n");
1582 
1583         inst_list_it--;
1584         ++num;
1585     }
1586 
1587     inst_list_it = --(writeback.end());
1588 
1589     cprintf("Writeback list size: %i\n", writeback.size());
1590 
1591     while (inst_list_it != writeback.end())
1592     {
1593         cprintf("Instruction:%i\n",
1594                 num);
1595         if (!(*inst_list_it)->isSquashed()) {
1596             if (!(*inst_list_it)->isIssued()) {
1597                 ++valid_num;
1598                 cprintf("Count:%i\n", valid_num);
1599             } else if ((*inst_list_it)->isMemRef() &&
1600                        !(*inst_list_it)->memOpDone) {
1601                 // Loads that have not been marked as executed still count
1602                 // towards the total instructions.
1603                 ++valid_num;
1604                 cprintf("Count:%i\n", valid_num);
1605             }
1606         }
1607 
1608         cprintf("PC:%#x\n[sn:%lli]\n[tid:%i]\n"
1609                 "Issued:%i\nSquashed:%i\n",
1610                 (*inst_list_it)->readPC(),
1611                 (*inst_list_it)->seqNum,
1612                 (*inst_list_it)->threadNumber,
1613                 (*inst_list_it)->isIssued(),
1614                 (*inst_list_it)->isSquashed());
1615 
1616         if ((*inst_list_it)->isMemRef()) {
1617             cprintf("MemOpDone:%i\n", (*inst_list_it)->memOpDone);
1618         }
1619 
1620         cprintf("\n");
1621 
1622         inst_list_it--;
1623         ++num;
1624     }
1625 
1626     cprintf("Waiting list size: %i\n", waitingList.size());
1627 
1628     inst_list_it = --(waitingList.end());
1629 
1630     while (inst_list_it != waitingList.end())
1631     {
1632         cprintf("Instruction:%i\n",
1633                 num);
1634         if (!(*inst_list_it)->isSquashed()) {
1635             if (!(*inst_list_it)->isIssued()) {
1636                 ++valid_num;
1637                 cprintf("Count:%i\n", valid_num);
1638             } else if ((*inst_list_it)->isMemRef() &&
1639                        !(*inst_list_it)->memOpDone) {
1640                 // Loads that have not been marked as executed still count
1641                 // towards the total instructions.
1642                 ++valid_num;
1643                 cprintf("Count:%i\n", valid_num);
1644             }
1645         }
1646 
1647         cprintf("PC:%#x\n[sn:%lli]\n[tid:%i]\n"
1648                 "Issued:%i\nSquashed:%i\n",
1649                 (*inst_list_it)->readPC(),
1650                 (*inst_list_it)->seqNum,
1651                 (*inst_list_it)->threadNumber,
1652                 (*inst_list_it)->isIssued(),
1653                 (*inst_list_it)->isSquashed());
1654 
1655         if ((*inst_list_it)->isMemRef()) {
1656             cprintf("MemOpDone:%i\n", (*inst_list_it)->memOpDone);
1657         }
1658 
1659         cprintf("\n");
1660 
1661         inst_list_it--;
1662         ++num;
1663     }
1664 
1665     cprintf("waitingMemOps list size: %i\n", waitingMemOps.size());
1666 
1667     MemIt waiting_it = waitingMemOps.begin();
1668 
1669     while (waiting_it != waitingMemOps.end())
1670     {
1671         cprintf("[sn:%lli] ", (*waiting_it));
1672         waiting_it++;
1673         ++num;
1674     }
1675     cprintf("\n");
1676 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a2d00e30d66a56e4667e28df302c98ac0}{
\index{LWBackEnd@{LWBackEnd}!executeInsts@{executeInsts}}
\index{executeInsts@{executeInsts}!LWBackEnd@{LWBackEnd}}
\subsubsection[{executeInsts}]{\setlength{\rightskip}{0pt plus 5cm}void executeInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLWBackEnd_a2d00e30d66a56e4667e28df302c98ac0}



\begin{DoxyCode}
825 {
826     DPRINTF(BE, "Trying to execute instructions\n");
827 
828     int num_executed = 0;
829     while (!exeList.empty() && num_executed < issueWidth) {
830         DynInstPtr inst = exeList.top();
831 
832         DPRINTF(BE, "Executing inst [sn:%lli] PC: %#x\n",
833                 inst->seqNum, inst->readPC());
834 
835         // Check if the instruction is squashed; if so then skip it
836         // and don't count it towards the FU usage.
837         if (inst->isSquashed()) {
838             DPRINTF(BE, "Execute: Instruction was squashed.\n");
839 
840             // Not sure how to handle this plus the method of sending # of
841             // instructions to use.  Probably will just have to count it
842             // towards the bandwidth usage, but not the FU usage.
843             ++num_executed;
844 
845             // Consider this instruction executed so that commit can go
846             // ahead and retire the instruction.
847             inst->setExecuted();
848 
849             // Not sure if I should set this here or just let commit try to
850             // commit any squashed instructions.  I like the latter a bit more.
851             inst->setCanCommit();
852 
853 //            ++iewExecSquashedInsts;
854             exeList.pop();
855 
856             continue;
857         }
858 
859         Fault fault = NoFault;
860 
861         // Execute instruction.
862         // Note that if the instruction faults, it will be handled
863         // at the commit stage.
864         if (inst->isMemRef() &&
865             (!inst->isDataPrefetch() && !inst->isInstPrefetch())) {
866             DPRINTF(BE, "Execute: Initiating access for memory "
867                     "reference.\n");
868 
869             if (inst->isLoad()) {
870                 LSQ.executeLoad(inst);
871             } else if (inst->isStore()) {
872                 Fault fault = LSQ.executeStore(inst);
873 
874                 if (!inst->isStoreConditional() && fault == NoFault) {
875                     inst->setExecuted();
876 
877                     instToCommit(inst);
878                 } else if (fault != NoFault) {
879                     // If the instruction faulted, then we need to send it along 
      to commit
880                     // without the instruction completing.
881                     // Send this instruction to commit, also make sure iew stage
882                     // realizes there is activity.
883                     inst->setExecuted();
884 
885                     instToCommit(inst);
886                 }
887             } else {
888                 panic("Unknown mem type!");
889             }
890         } else {
891             inst->execute();
892 
893             inst->setExecuted();
894 
895             instToCommit(inst);
896         }
897 
898         updateExeInstStats(inst);
899 
900         ++funcExeInst;
901         ++num_executed;
902 
903         exeList.pop();
904 
905         if (inst->mispredicted()) {
906             squashDueToBranch(inst);
907             break;
908         } else if (LSQ.violation()) {
909             // Get the DynInst that caused the violation.  Note that this
910             // clears the violation signal.
911             DynInstPtr violator;
912             violator = LSQ.getMemDepViolator();
913 
914             DPRINTF(BE, "LDSTQ detected a violation.  Violator PC: "
915                     "%#x, inst PC: %#x.  Addr is: %#x.\n",
916                     violator->readPC(), inst->readPC(), inst->physEffAddr);
917 
918             // Squash.
919             squashDueToMemViolation(inst);
920         }
921     }
922 
923     issuedOps[0]+= num_executed;
924     nIssuedDist[num_executed]++;
925 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a71dcc69e5b01fa12b8ccd2dccdcc9917}{
\index{LWBackEnd@{LWBackEnd}!fetchFault@{fetchFault}}
\index{fetchFault@{fetchFault}!LWBackEnd@{LWBackEnd}}
\subsubsection[{fetchFault}]{\setlength{\rightskip}{0pt plus 5cm}void fetchFault ({\bf Fault} \& {\em fault})}}
\label{classLWBackEnd_a71dcc69e5b01fa12b8ccd2dccdcc9917}
\hypertarget{classLWBackEnd_aee57f4aad9f2308dcc12325319c170d5}{
\index{LWBackEnd@{LWBackEnd}!generateTCEvent@{generateTCEvent}}
\index{generateTCEvent@{generateTCEvent}!LWBackEnd@{LWBackEnd}}
\subsubsection[{generateTCEvent}]{\setlength{\rightskip}{0pt plus 5cm}void generateTCEvent ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_aee57f4aad9f2308dcc12325319c170d5}



\begin{DoxyCode}
123 { tcSquash = true; }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a17fd6203f0789b68f99f618ea93ab6e0}{
\index{LWBackEnd@{LWBackEnd}!generateTrapEvent@{generateTrapEvent}}
\index{generateTrapEvent@{generateTrapEvent}!LWBackEnd@{LWBackEnd}}
\subsubsection[{generateTrapEvent}]{\setlength{\rightskip}{0pt plus 5cm}void generateTrapEvent ({\bf Tick} {\em latency} = {\ttfamily 0})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLWBackEnd_a17fd6203f0789b68f99f618ea93ab6e0}



\begin{DoxyCode}
41 {
42     DPRINTF(BE, "Generating trap event\n");
43 
44     TrapEvent *trap = new TrapEvent(this);
45 
46     trap->schedule(curTick() + cpu->ticks(latency));
47 
48     thread->trapPending = true;
49 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a32e64f82b805fe23a17b01dda0f44fb0}{
\index{LWBackEnd@{LWBackEnd}!getDcachePort@{getDcachePort}}
\index{getDcachePort@{getDcachePort}!LWBackEnd@{LWBackEnd}}
\subsubsection[{getDcachePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Port}$\ast$ getDcachePort ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a32e64f82b805fe23a17b01dda0f44fb0}



\begin{DoxyCode}
119 { return LSQ.getDcachePort(); }
\end{DoxyCode}
\hypertarget{classLWBackEnd_af3d02b2950c0aaa8cd71d422abd0ef51}{
\index{LWBackEnd@{LWBackEnd}!handleFault@{handleFault}}
\index{handleFault@{handleFault}!LWBackEnd@{LWBackEnd}}
\subsubsection[{handleFault}]{\setlength{\rightskip}{0pt plus 5cm}void handleFault ({\bf Fault} \& {\em fault}, \/  {\bf Tick} {\em latency} = {\ttfamily 0})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLWBackEnd_af3d02b2950c0aaa8cd71d422abd0ef51}



\begin{DoxyCode}
561 {
562     DPRINTF(BE, "Handling fault!\n");
563 
564     assert(!thread->noSquashFromTC);
565 
566     thread->noSquashFromTC = true;
567 
568     // Consider holding onto the trap and waiting until the trap event
569     // happens for this to be executed.
570     fault->invoke(thread->getTC());
571 
572     // Exit state update mode to avoid accidental updating.
573     thread->noSquashFromTC = false;
574 
575     commitStatus = TrapPending;
576 
577     // Generate trap squash event.
578     generateTrapEvent(latency);
579 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a720e9865ffa6e84b756f5ec1d1a24d94}{
\index{LWBackEnd@{LWBackEnd}!instToCommit@{instToCommit}}
\index{instToCommit@{instToCommit}!LWBackEnd@{LWBackEnd}}
\subsubsection[{instToCommit}]{\setlength{\rightskip}{0pt plus 5cm}void instToCommit ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a720e9865ffa6e84b756f5ec1d1a24d94}



\begin{DoxyCode}
930 {
931     DPRINTF(BE, "Sending instructions to commit [sn:%lli] PC %#x.\n",
932             inst->seqNum, inst->readPC());
933 
934     if (!inst->isSquashed()) {
935         if (inst->isExecuted()) {
936             inst->setResultReady();
937             int dependents = wakeDependents(inst);
938             if (dependents) {
939                 producerInst[0]++;
940                 consumerInst[0]+= dependents;
941             }
942         }
943     }
944 
945     writeback.push_back(inst);
946 
947     numInstsToWB[0]++;
948 
949     writebackCount[0]++;
950 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_ae6ec007d68382eb124ed25bc90ae9c17}{
\index{LWBackEnd@{LWBackEnd}!isBlocked@{isBlocked}}
\index{isBlocked@{isBlocked}!LWBackEnd@{LWBackEnd}}
\subsubsection[{isBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool isBlocked ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_ae6ec007d68382eb124ed25bc90ae9c17}



\begin{DoxyCode}
145 { return status == Blocked || dispatchStatus == Blocked; }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a3e70330939fdfc4dbc2f60c1a660584d}{
\index{LWBackEnd@{LWBackEnd}!isFull@{isFull}}
\index{isFull@{isFull}!LWBackEnd@{LWBackEnd}}
\subsubsection[{isFull}]{\setlength{\rightskip}{0pt plus 5cm}bool isFull ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a3e70330939fdfc4dbc2f60c1a660584d}



\begin{DoxyCode}
144 { return numInsts >= numROBEntries; }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a471165257f311a78136ce991a3bad31a}{
\index{LWBackEnd@{LWBackEnd}!isSwitchedOut@{isSwitchedOut}}
\index{isSwitchedOut@{isSwitchedOut}!LWBackEnd@{LWBackEnd}}
\subsubsection[{isSwitchedOut}]{\setlength{\rightskip}{0pt plus 5cm}bool isSwitchedOut ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a471165257f311a78136ce991a3bad31a}



\begin{DoxyCode}
203 { return switchedOut; }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{LWBackEnd@{LWBackEnd}!name@{name}}
\index{name@{name}!LWBackEnd@{LWBackEnd}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a37627d5d5bba7f4a8690c71c2ab3cb07}



\begin{DoxyCode}
177 {
178     return cpu->name() + ".backend";
179 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a0747777ac998dabdc20fa0c554d378d3}{
\index{LWBackEnd@{LWBackEnd}!read@{read}}
\index{read@{read}!LWBackEnd@{LWBackEnd}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} read ({\bf RequestPtr} {\em req}, \/  T \& {\em data}, \/  int {\em load\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a0747777ac998dabdc20fa0c554d378d3}



\begin{DoxyCode}
423 {
424     return LSQ.read(req, data, load_idx);
425 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_aa28f3fe58fde4b038a92b9f87a40cb10}{
\index{LWBackEnd@{LWBackEnd}!readCommitPC@{readCommitPC}}
\index{readCommitPC@{readCommitPC}!LWBackEnd@{LWBackEnd}}
\subsubsection[{readCommitPC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} readCommitPC ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_aa28f3fe58fde4b038a92b9f87a40cb10}



\begin{DoxyCode}
136 { return commitPC; }
\end{DoxyCode}
\hypertarget{classLWBackEnd_aaf16f1d27dc8f5db83c4d2b981a100a9}{
\index{LWBackEnd@{LWBackEnd}!readyInstsForCommit@{readyInstsForCommit}}
\index{readyInstsForCommit@{readyInstsForCommit}!LWBackEnd@{LWBackEnd}}
\subsubsection[{readyInstsForCommit}]{\setlength{\rightskip}{0pt plus 5cm}void readyInstsForCommit ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_aaf16f1d27dc8f5db83c4d2b981a100a9}



\begin{DoxyCode}
955 {
956     for (int i = numInstsToWB[-latency];
957          !writeback.empty() && i;
958          --i)
959     {
960         DynInstPtr inst = writeback.front();
961         writeback.pop_front();
962         if (!inst->isSquashed()) {
963             DPRINTF(BE, "Writing back instruction [sn:%lli] PC %#x.\n",
964                     inst->seqNum, inst->readPC());
965 
966             inst->setCanCommit();
967         }
968     }
969 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{LWBackEnd@{LWBackEnd}!regStats@{regStats}}
\index{regStats@{regStats}!LWBackEnd@{LWBackEnd}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a4dc637449366fcdfc4e764cdf12d9b11}



\begin{DoxyCode}
184 {
185     using namespace Stats;
186     LSQ.regStats();
187 
188     robCapEvents
189         .init(cpu->numThreads)
190         .name(name() + ".ROB:cap_events")
191         .desc("number of cycles where ROB cap was active")
192         .flags(total)
193         ;
194 
195     robCapInstCount
196         .init(cpu->numThreads)
197         .name(name() + ".ROB:cap_inst")
198         .desc("number of instructions held up by ROB cap")
199         .flags(total)
200         ;
201 
202     iqCapEvents
203         .init(cpu->numThreads)
204         .name(name() +".IQ:cap_events" )
205         .desc("number of cycles where IQ cap was active")
206         .flags(total)
207         ;
208 
209     iqCapInstCount
210         .init(cpu->numThreads)
211         .name(name() + ".IQ:cap_inst")
212         .desc("number of instructions held up by IQ cap")
213         .flags(total)
214         ;
215 
216     exeInst
217         .init(cpu->numThreads)
218         .name(name() + ".ISSUE:count")
219         .desc("number of insts issued")
220         .flags(total)
221         ;
222 
223     exeSwp
224         .init(cpu->numThreads)
225         .name(name() + ".ISSUE:swp")
226         .desc("number of swp insts issued")
227         .flags(total)
228         ;
229 
230     exeNop
231         .init(cpu->numThreads)
232         .name(name() + ".ISSUE:nop")
233         .desc("number of nop insts issued")
234         .flags(total)
235         ;
236 
237     exeRefs
238         .init(cpu->numThreads)
239         .name(name() + ".ISSUE:refs")
240         .desc("number of memory reference insts issued")
241         .flags(total)
242         ;
243 
244     exeLoads
245         .init(cpu->numThreads)
246         .name(name() + ".ISSUE:loads")
247         .desc("number of load insts issued")
248         .flags(total)
249         ;
250 
251     exeBranches
252         .init(cpu->numThreads)
253         .name(name() + ".ISSUE:branches")
254         .desc("Number of branches issued")
255         .flags(total)
256         ;
257 
258     issuedOps
259         .init(cpu->numThreads)
260         .name(name() + ".ISSUE:op_count")
261         .desc("number of insts issued")
262         .flags(total)
263         ;
264 
265 /*
266     for (int i=0; i<Num_OpClasses; ++i) {
267         stringstream subname;
268         subname << opClassStrings[i] << "_delay";
269         issue_delay_dist.subname(i, subname.str());
270     }
271 */
272     //
273     //  Other stats
274     //
275     lsqForwLoads
276         .init(cpu->numThreads)
277         .name(name() + ".LSQ:forw_loads")
278         .desc("number of loads forwarded via LSQ")
279         .flags(total)
280         ;
281 
282     invAddrLoads
283         .init(cpu->numThreads)
284         .name(name() + ".ISSUE:addr_loads")
285         .desc("number of invalid-address loads")
286         .flags(total)
287         ;
288 
289     invAddrSwpfs
290         .init(cpu->numThreads)
291         .name(name() + ".ISSUE:addr_swpfs")
292         .desc("number of invalid-address SW prefetches")
293         .flags(total)
294         ;
295 
296     lsqBlockedLoads
297         .init(cpu->numThreads)
298         .name(name() + ".LSQ:blocked_loads")
299         .desc("number of ready loads not issued due to memory disambiguation")
300         .flags(total)
301         ;
302 
303     lsqInversion
304         .name(name() + ".ISSUE:lsq_invert")
305         .desc("Number of times LSQ instruction issued early")
306         ;
307 
308     nIssuedDist
309         .init(issueWidth + 1)
310         .name(name() + ".ISSUE:issued_per_cycle")
311         .desc("Number of insts issued each cycle")
312         .flags(total | pdf | dist)
313         ;
314 /*
315     issueDelayDist
316         .init(Num_OpClasses,0,99,2)
317         .name(name() + ".ISSUE:")
318         .desc("cycles from operands ready to issue")
319         .flags(pdf | cdf)
320         ;
321 
322     queueResDist
323         .init(Num_OpClasses, 0, 99, 2)
324         .name(name() + ".IQ:residence:")
325         .desc("cycles from dispatch to issue")
326         .flags(total | pdf | cdf )
327         ;
328     for (int i = 0; i < Num_OpClasses; ++i) {
329         queueResDist.subname(i, opClassStrings[i]);
330     }
331 */
332     writebackCount
333         .init(cpu->numThreads)
334         .name(name() + ".WB:count")
335         .desc("cumulative count of insts written-back")
336         .flags(total)
337         ;
338 
339     producerInst
340         .init(cpu->numThreads)
341         .name(name() + ".WB:producers")
342         .desc("num instructions producing a value")
343         .flags(total)
344         ;
345 
346     consumerInst
347         .init(cpu->numThreads)
348         .name(name() + ".WB:consumers")
349         .desc("num instructions consuming a value")
350         .flags(total)
351         ;
352 
353     wbPenalized
354         .init(cpu->numThreads)
355         .name(name() + ".WB:penalized")
356         .desc("number of instrctions required to write to 'other' IQ")
357         .flags(total)
358         ;
359 
360 
361     wbPenalizedRate
362         .name(name() + ".WB:penalized_rate")
363         .desc ("fraction of instructions written-back that wrote to 'other' IQ")
364         .flags(total)
365         ;
366 
367     wbPenalizedRate = wbPenalized / writebackCount;
368 
369     wbFanout
370         .name(name() + ".WB:fanout")
371         .desc("average fanout of values written-back")
372         .flags(total)
373         ;
374 
375     wbFanout = producerInst / consumerInst;
376 
377     wbRate
378         .name(name() + ".WB:rate")
379         .desc("insts written-back per cycle")
380         .flags(total)
381         ;
382     wbRate = writebackCount / cpu->numCycles;
383 
384     statComInst
385         .init(cpu->numThreads)
386         .name(name() + ".COM:count")
387         .desc("Number of instructions committed")
388         .flags(total)
389         ;
390 
391     statComSwp
392         .init(cpu->numThreads)
393         .name(name() + ".COM:swp_count")
394         .desc("Number of s/w prefetches committed")
395         .flags(total)
396         ;
397 
398     statComRefs
399         .init(cpu->numThreads)
400         .name(name() +  ".COM:refs")
401         .desc("Number of memory references committed")
402         .flags(total)
403         ;
404 
405     statComLoads
406         .init(cpu->numThreads)
407         .name(name() +  ".COM:loads")
408         .desc("Number of loads committed")
409         .flags(total)
410         ;
411 
412     statComMembars
413         .init(cpu->numThreads)
414         .name(name() +  ".COM:membars")
415         .desc("Number of memory barriers committed")
416         .flags(total)
417         ;
418 
419     statComBranches
420         .init(cpu->numThreads)
421         .name(name() + ".COM:branches")
422         .desc("Number of branches committed")
423         .flags(total)
424         ;
425     nCommittedDist
426         .init(0,commitWidth,1)
427         .name(name() + ".COM:committed_per_cycle")
428         .desc("Number of insts commited each cycle")
429         .flags(pdf)
430         ;
431 
432     //
433     //  Commit-Eligible instructions...
434     //
435     //  -> The number of instructions eligible to commit in those
436     //  cycles where we reached our commit BW limit (less the number
437     //  actually committed)
438     //
439     //  -> The average value is computed over ALL CYCLES... not just
440     //  the BW limited cycles
441     //
442     //  -> The standard deviation is computed only over cycles where
443     //  we reached the BW limit
444     //
445     commitEligible
446         .init(cpu->numThreads)
447         .name(name() + ".COM:bw_limited")
448         .desc("number of insts not committed due to BW limits")
449         .flags(total)
450         ;
451 
452     commitEligibleSamples
453         .name(name() + ".COM:bw_lim_events")
454         .desc("number cycles where commit BW limit reached")
455         ;
456 
457     squashedInsts
458         .init(cpu->numThreads)
459         .name(name() + ".COM:squashed_insts")
460         .desc("Number of instructions removed from inst list")
461         ;
462 
463     ROBSquashedInsts
464         .init(cpu->numThreads)
465         .name(name() + ".COM:rob_squashed_insts")
466         .desc("Number of instructions removed from inst list when they reached th
      e head of the ROB")
467         ;
468 
469     ROBFcount
470         .name(name() + ".ROB:full_count")
471         .desc("number of cycles where ROB was full")
472         ;
473 
474     ROBCount
475         .init(cpu->numThreads)
476         .name(name() + ".ROB:occupancy")
477         .desc(name() + ".ROB occupancy (cumulative)")
478         .flags(total)
479         ;
480 
481     ROBFullRate
482         .name(name() + ".ROB:full_rate")
483         .desc("ROB full per cycle")
484         ;
485     ROBFullRate = ROBFcount / cpu->numCycles;
486 
487     ROBOccRate
488         .name(name() + ".ROB:occ_rate")
489         .desc("ROB occupancy rate")
490         .flags(total)
491         ;
492     ROBOccRate = ROBCount / cpu->numCycles;
493 /*
494     ROBOccDist
495         .init(cpu->numThreads, 0, numROBEntries, 2)
496         .name(name() + ".ROB:occ_dist")
497         .desc("ROB Occupancy per cycle")
498         .flags(total | cdf)
499         ;
500 */
501 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a3eec16e4a583e6312ba14ffe5a004296}{
\index{LWBackEnd@{LWBackEnd}!removeDcacheMiss@{removeDcacheMiss}}
\index{removeDcacheMiss@{removeDcacheMiss}!LWBackEnd@{LWBackEnd}}
\subsubsection[{removeDcacheMiss}]{\setlength{\rightskip}{0pt plus 5cm}void removeDcacheMiss ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a3eec16e4a583e6312ba14ffe5a004296}



\begin{DoxyCode}
171     {
172         assert(waitingMemOps.find(inst->seqNum) != waitingMemOps.end());
173         waitingMemOps.erase(inst->seqNum);
174         numWaitingMemOps--;
175         DPRINTF(BE, "Removing a Dcache miss mem op [sn:%lli], total %i\n",
176                 inst->seqNum, numWaitingMemOps);
177     }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a38f3385718380c23fe08a81063cc37e1}{
\index{LWBackEnd@{LWBackEnd}!removeWaitingMemOp@{removeWaitingMemOp}}
\index{removeWaitingMemOp@{removeWaitingMemOp}!LWBackEnd@{LWBackEnd}}
\subsubsection[{removeWaitingMemOp}]{\setlength{\rightskip}{0pt plus 5cm}void removeWaitingMemOp ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a38f3385718380c23fe08a81063cc37e1}



\begin{DoxyCode}
188     {
189         assert(waitingMemOps.find(inst->seqNum) != waitingMemOps.end());
190         waitingMemOps.erase(inst->seqNum);
191         numWaitingMemOps--;
192         DPRINTF(BE, "Removing a waiting mem op [sn:%lli], total %i\n",
193                 inst->seqNum, numWaitingMemOps);
194     }
\end{DoxyCode}
\hypertarget{classLWBackEnd_ae165df775b4de9e9430228c7f04c2bc9}{
\index{LWBackEnd@{LWBackEnd}!replayMemInst@{replayMemInst}}
\index{replayMemInst@{replayMemInst}!LWBackEnd@{LWBackEnd}}
\subsubsection[{replayMemInst}]{\setlength{\rightskip}{0pt plus 5cm}void replayMemInst ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_ae165df775b4de9e9430228c7f04c2bc9}
Re-\/executes all rescheduled memory instructions. 


\begin{DoxyCode}
128 {
129     bool found_inst = false;
130     while (!replayList.empty()) {
131         exeList.push(replayList.front());
132         if (replayList.front() == inst) {
133             found_inst = true;
134         }
135         replayList.pop_front();
136     }
137     assert(found_inst);
138 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_aa9c46f45f491ef90a936c7e2b95f20aa}{
\index{LWBackEnd@{LWBackEnd}!rescheduleMemInst@{rescheduleMemInst}}
\index{rescheduleMemInst@{rescheduleMemInst}!LWBackEnd@{LWBackEnd}}
\subsubsection[{rescheduleMemInst}]{\setlength{\rightskip}{0pt plus 5cm}void rescheduleMemInst ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_aa9c46f45f491ef90a936c7e2b95f20aa}
Tells memory dependence unit that a memory instruction needs to be rescheduled. It will re-\/execute once \hyperlink{classLWBackEnd_ae165df775b4de9e9430228c7f04c2bc9}{replayMemInst()} is called. 


\begin{DoxyCode}
100 {
101     replayList.push_front(inst);
102 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a5c38df1621043861ada4dd0939509869}{
\index{LWBackEnd@{LWBackEnd}!robEmpty@{robEmpty}}
\index{robEmpty@{robEmpty}!LWBackEnd@{LWBackEnd}}
\subsubsection[{robEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool robEmpty ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a5c38df1621043861ada4dd0939509869}



\begin{DoxyCode}
142 { return numInsts == 0; }
\end{DoxyCode}
\hypertarget{classLWBackEnd_aeabdb9f0aae07df67c3029f8fddb2693}{
\index{LWBackEnd@{LWBackEnd}!setCommBuffer@{setCommBuffer}}
\index{setCommBuffer@{setCommBuffer}!LWBackEnd@{LWBackEnd}}
\subsubsection[{setCommBuffer}]{\setlength{\rightskip}{0pt plus 5cm}void setCommBuffer ({\bf TimeBuffer}$<$ {\bf CommStruct} $>$ $\ast$ {\em \_\-comm})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_aeabdb9f0aae07df67c3029f8fddb2693}



\begin{DoxyCode}
515 {
516     comm = _comm;
517     toIEW = comm->getWire(0);
518     fromCommit = comm->getWire(-1);
519 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_ab8056057b67b41f234f56940cc115cc1}{
\index{LWBackEnd@{LWBackEnd}!setCPU@{setCPU}}
\index{setCPU@{setCPU}!LWBackEnd@{LWBackEnd}}
\subsubsection[{setCPU}]{\setlength{\rightskip}{0pt plus 5cm}void setCPU ({\bf OzoneCPU} $\ast$ {\em cpu\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_ab8056057b67b41f234f56940cc115cc1}



\begin{DoxyCode}
506 {
507     cpu = cpu_ptr;
508     LSQ.setCPU(cpu_ptr);
509     checker = cpu->checker;
510 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a122009fa2730cee3898ac945227da8eb}{
\index{LWBackEnd@{LWBackEnd}!setFrontEnd@{setFrontEnd}}
\index{setFrontEnd@{setFrontEnd}!LWBackEnd@{LWBackEnd}}
\subsubsection[{setFrontEnd}]{\setlength{\rightskip}{0pt plus 5cm}void setFrontEnd ({\bf FrontEnd} $\ast$ {\em front\_\-end\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a122009fa2730cee3898ac945227da8eb}



\begin{DoxyCode}
109     { frontEnd = front_end_ptr; }
\end{DoxyCode}
\hypertarget{classLWBackEnd_ac6ccaaea6ac518cab92f71723b5a739e}{
\index{LWBackEnd@{LWBackEnd}!setTC@{setTC}}
\index{setTC@{setTC}!LWBackEnd@{LWBackEnd}}
\subsubsection[{setTC}]{\setlength{\rightskip}{0pt plus 5cm}void setTC ({\bf ThreadContext} $\ast$ {\em tc\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_ac6ccaaea6ac518cab92f71723b5a739e}



\begin{DoxyCode}
112     { tc = tc_ptr; }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a850bea4a9b9f631e7b6a4c7dc92f662a}{
\index{LWBackEnd@{LWBackEnd}!setThreadState@{setThreadState}}
\index{setThreadState@{setThreadState}!LWBackEnd@{LWBackEnd}}
\subsubsection[{setThreadState}]{\setlength{\rightskip}{0pt plus 5cm}void setThreadState ({\bf Thread} $\ast$ {\em thread\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a850bea4a9b9f631e7b6a4c7dc92f662a}



\begin{DoxyCode}
115     { thread = thread_ptr; }
\end{DoxyCode}
\hypertarget{classLWBackEnd_adc9b67ce59b0b2e930cfaf6361ce42c5}{
\index{LWBackEnd@{LWBackEnd}!squash@{squash}}
\index{squash@{squash}!LWBackEnd@{LWBackEnd}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash (const {\bf InstSeqNum} \& {\em sn})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLWBackEnd_adc9b67ce59b0b2e930cfaf6361ce42c5}



\begin{DoxyCode}
1254 {
1255     LSQ.squash(sn);
1256 
1257     int freed_regs = 0;
1258     InstListIt insts_end_it = waitingList.end();
1259     InstListIt insts_it = waitingList.begin();
1260 
1261     while (insts_it != insts_end_it && (*insts_it)->seqNum > sn)
1262     {
1263         if ((*insts_it)->isSquashed()) {
1264             ++insts_it;
1265             continue;
1266         }
1267         DPRINTF(BE, "Squashing instruction on waitingList PC %#x, [sn:%lli].\n",
1268                 (*insts_it)->readPC(),
1269                 (*insts_it)->seqNum);
1270 
1271         if ((*insts_it)->isMemRef()) {
1272             DPRINTF(BE, "Squashing a waiting mem op [sn:%lli]\n",
1273                     (*insts_it)->seqNum);
1274             removeWaitingMemOp((*insts_it));
1275         }
1276 
1277         waitingList.erase(insts_it++);
1278         waitingInsts--;
1279     }
1280     assert(waitingInsts >= 0);
1281 
1282     insts_it = instList.begin();
1283 
1284     while (!instList.empty() && (*insts_it)->seqNum > sn)
1285     {
1286         if ((*insts_it)->isSquashed()) {
1287             panic("Instruction should not be already squashed and on list!");
1288             ++insts_it;
1289             continue;
1290         }
1291         DPRINTF(BE, "Squashing instruction on inst list PC %#x, [sn:%lli].\n",
1292                 (*insts_it)->readPC(),
1293                 (*insts_it)->seqNum);
1294 
1295         // Mark the instruction as squashed, and ready to commit so that
1296         // it can drain out of the pipeline.
1297         (*insts_it)->setSquashed();
1298 
1299         (*insts_it)->setCanCommit();
1300 
1301         (*insts_it)->clearInROB();
1302 
1303         for (int i = 0; i < (*insts_it)->numDestRegs(); ++i) {
1304             DynInstPtr prev_dest = (*insts_it)->getPrevDestInst(i);
1305             DPRINTF(BE, "Commit rename map setting reg %i to [sn:%lli]\n",
1306                     (int)(*insts_it)->destRegIdx(i), prev_dest->seqNum);
1307             renameTable[(*insts_it)->destRegIdx(i)] = prev_dest;
1308             ++freed_regs;
1309         }
1310 
1311         (*insts_it)->clearDependents();
1312 
1313         squashedInsts[(*insts_it)->threadNumber]++;
1314 
1315         instList.erase(insts_it++);
1316         --numInsts;
1317     }
1318 
1319     while (memBarrier && memBarrier->seqNum > sn) {
1320         DPRINTF(BE, "[sn:%lli] Memory barrier squashed (or previously "
1321                 "squashed)\n", memBarrier->seqNum);
1322         memBarrier->clearMemDependents();
1323         if (memBarrier->memDepReady()) {
1324             DPRINTF(BE, "No previous barrier\n");
1325             memBarrier = NULL;
1326         } else {
1327             std::list<DynInstPtr> &srcs = memBarrier->getMemSrcs();
1328             memBarrier = srcs.front();
1329             srcs.pop_front();
1330             assert(srcs.empty());
1331             DPRINTF(BE, "Previous barrier: [sn:%lli]\n",
1332                     memBarrier->seqNum);
1333         }
1334     }
1335 
1336     insts_it = replayList.begin();
1337     insts_end_it = replayList.end();
1338     while (!replayList.empty() && insts_it != insts_end_it) {
1339         if ((*insts_it)->seqNum < sn) {
1340             ++insts_it;
1341             continue;
1342         }
1343         assert((*insts_it)->isSquashed());
1344 
1345         replayList.erase(insts_it++);
1346     }
1347 
1348     frontEnd->addFreeRegs(freed_regs);
1349 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a3c68c455d9207edd23ae3bcb7971e653}{
\index{LWBackEnd@{LWBackEnd}!squash@{squash}}
\index{squash@{squash}!LWBackEnd@{LWBackEnd}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash ()}}
\label{classLWBackEnd_a3c68c455d9207edd23ae3bcb7971e653}
\hypertarget{classLWBackEnd_a05c89a1532adb13cc0632fc3bb600add}{
\index{LWBackEnd@{LWBackEnd}!squashDueToBranch@{squashDueToBranch}}
\index{squashDueToBranch@{squashDueToBranch}!LWBackEnd@{LWBackEnd}}
\subsubsection[{squashDueToBranch}]{\setlength{\rightskip}{0pt plus 5cm}void squashDueToBranch ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLWBackEnd_a05c89a1532adb13cc0632fc3bb600add}



\begin{DoxyCode}
1386 {
1387     // Update the branch predictor state I guess
1388     DPRINTF(BE, "Squashing due to branch [sn:%lli], will restart at PC %#x\n",
1389             inst->seqNum, inst->readNextPC());
1390     squash(inst->seqNum);
1391     frontEnd->squash(inst->seqNum, inst->readNextPC(),
1392                      true, inst->mispredicted());
1393 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a5fcf443dc6ada1ab1936df923c3205d2}{
\index{LWBackEnd@{LWBackEnd}!squashDueToMemBlocked@{squashDueToMemBlocked}}
\index{squashDueToMemBlocked@{squashDueToMemBlocked}!LWBackEnd@{LWBackEnd}}
\subsubsection[{squashDueToMemBlocked}]{\setlength{\rightskip}{0pt plus 5cm}void squashDueToMemBlocked ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLWBackEnd_a5fcf443dc6ada1ab1936df923c3205d2}



\begin{DoxyCode}
1410 {
1411     DPRINTF(IEW, "Memory blocked, squashing load and younger insts, "
1412             "PC: %#x [sn:%i].\n", inst->readPC(), inst->seqNum);
1413 
1414     squash(inst->seqNum - 1);
1415     frontEnd->squash(inst->seqNum - 1, inst->readPC());
1416 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a493d3b3596dc6e17cc56990a4e71602d}{
\index{LWBackEnd@{LWBackEnd}!squashDueToMemViolation@{squashDueToMemViolation}}
\index{squashDueToMemViolation@{squashDueToMemViolation}!LWBackEnd@{LWBackEnd}}
\subsubsection[{squashDueToMemViolation}]{\setlength{\rightskip}{0pt plus 5cm}void squashDueToMemViolation ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLWBackEnd_a493d3b3596dc6e17cc56990a4e71602d}



\begin{DoxyCode}
1398 {
1399     // Update the branch predictor state I guess
1400     DPRINTF(BE, "Squashing due to violation [sn:%lli], will restart at PC %#x\n",
      
1401             inst->seqNum, inst->readNextPC());
1402     squash(inst->seqNum);
1403     frontEnd->squash(inst->seqNum, inst->readNextPC(),
1404                      false, inst->mispredicted());
1405 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a24cd8db837a73b879041bf33da7b2064}{
\index{LWBackEnd@{LWBackEnd}!squashFromTC@{squashFromTC}}
\index{squashFromTC@{squashFromTC}!LWBackEnd@{LWBackEnd}}
\subsubsection[{squashFromTC}]{\setlength{\rightskip}{0pt plus 5cm}void squashFromTC ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a24cd8db837a73b879041bf33da7b2064}



\begin{DoxyCode}
1354 {
1355     InstSeqNum squashed_inst = robEmpty() ? 0 : instList.back()->seqNum - 1;
1356     squash(squashed_inst);
1357     frontEnd->squash(squashed_inst, thread->readPC(),
1358                      false, false);
1359     frontEnd->interruptPending = false;
1360 
1361     thread->trapPending = false;
1362     thread->noSquashFromTC = false;
1363     tcSquash = false;
1364     commitStatus = Running;
1365 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a63c6cc9b9d0507c286d035e92a1bc4f4}{
\index{LWBackEnd@{LWBackEnd}!squashFromTrap@{squashFromTrap}}
\index{squashFromTrap@{squashFromTrap}!LWBackEnd@{LWBackEnd}}
\subsubsection[{squashFromTrap}]{\setlength{\rightskip}{0pt plus 5cm}void squashFromTrap ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a63c6cc9b9d0507c286d035e92a1bc4f4}



\begin{DoxyCode}
1370 {
1371     InstSeqNum squashed_inst = robEmpty() ? 0 : instList.back()->seqNum - 1;
1372     squash(squashed_inst);
1373     frontEnd->squash(squashed_inst, thread->readPC(),
1374                      false, false);
1375     frontEnd->interruptPending = false;
1376 
1377     thread->trapPending = false;
1378     thread->noSquashFromTC = false;
1379     trapSquash = false;
1380     commitStatus = Running;
1381 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a05f299b443f8cc73a93d61572edc0218}{
\index{LWBackEnd@{LWBackEnd}!switchOut@{switchOut}}
\index{switchOut@{switchOut}!LWBackEnd@{LWBackEnd}}
\subsubsection[{switchOut}]{\setlength{\rightskip}{0pt plus 5cm}void switchOut ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a05f299b443f8cc73a93d61572edc0218}



\begin{DoxyCode}
1421 {
1422     switchPending = true;
1423 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a5a901e7ec5b94a55bd61fde88ad0b7f1}{
\index{LWBackEnd@{LWBackEnd}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!LWBackEnd@{LWBackEnd}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ({\bf ThreadContext} $\ast$ {\em old\_\-tc} = {\ttfamily NULL})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a5a901e7ec5b94a55bd61fde88ad0b7f1}



\begin{DoxyCode}
1451 {
1452     assert(!squashPending);
1453     squashSeqNum = 0;
1454     squashNextPC = 0;
1455     tcSquash = false;
1456     trapSquash = false;
1457 
1458     numInsts = 0;
1459     numWaitingMemOps = 0;
1460     waitingMemOps.clear();
1461     waitingInsts = 0;
1462     switchedOut = false;
1463     dispatchStatus = Running;
1464     commitStatus = Running;
1465     LSQ.takeOverFrom(old_tc);
1466 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a873dd91783f9efb4a590aded1f70d6b0}{
\index{LWBackEnd@{LWBackEnd}!tick@{tick}}
\index{tick@{tick}!LWBackEnd@{LWBackEnd}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a873dd91783f9efb4a590aded1f70d6b0}



\begin{DoxyCode}
584 {
585     DPRINTF(BE, "Ticking back end\n");
586 
587     // Read in any done instruction information and update the IQ or LSQ.
588     updateStructures();
589 
590     if (switchPending && robEmpty() && !LSQ.hasStoresToWB()) {
591         cpu->signalSwitched();
592         return;
593     }
594 
595     readyInstsForCommit();
596 
597     numInstsToWB.advance();
598 
599     ROBCount[0]+= numInsts;
600 
601     wbCycle = 0;
602 
603     checkInterrupts();
604 
605     if (trapSquash) {
606         assert(!tcSquash);
607         squashFromTrap();
608     } else if (tcSquash) {
609         squashFromTC();
610     }
611 
612     if (dispatchStatus != Blocked) {
613         dispatchInsts();
614     } else {
615         checkDispatchStatus();
616     }
617 
618     if (commitStatus != TrapPending) {
619         executeInsts();
620 
621         commitInsts();
622     }
623 
624     LSQ.writebackStores();
625 
626     DPRINTF(BE, "Waiting insts: %i, mem ops: %i, ROB entries in use: %i, "
627             "LSQ loads: %i, LSQ stores: %i\n",
628             waitingInsts, numWaitingMemOps, numInsts,
629             LSQ.numLoads(), LSQ.numStores());
630 
631 #ifdef DEBUG
632     assert(numInsts == instList.size());
633     assert(waitingInsts == waitingList.size());
634     assert(numWaitingMemOps == waitingMemOps.size());
635     assert(!switchedOut);
636 #endif
637 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a5bbf266cb0cc97eed138c8fe0d2d76b6}{
\index{LWBackEnd@{LWBackEnd}!updateComInstStats@{updateComInstStats}}
\index{updateComInstStats@{updateComInstStats}!LWBackEnd@{LWBackEnd}}
\subsubsection[{updateComInstStats}]{\setlength{\rightskip}{0pt plus 5cm}void updateComInstStats ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLWBackEnd_a5bbf266cb0cc97eed138c8fe0d2d76b6}



\begin{DoxyCode}
1496 {
1497     ThreadID tid = inst->threadNumber;
1498 
1499     // keep an instruction count
1500     thread->numInst++;
1501     thread->numInsts++;
1502 
1503     cpu->numInst++;
1504     //
1505     //  Pick off the software prefetches
1506     //
1507 #ifdef TARGET_ALPHA
1508     if (inst->isDataPrefetch()) {
1509         statComSwp[tid]++;
1510     } else {
1511         statComInst[tid]++;
1512     }
1513 #else
1514     statComInst[tid]++;
1515 #endif
1516 
1517     //
1518     //  Control Instructions
1519     //
1520     if (inst->isControl())
1521         statComBranches[tid]++;
1522 
1523     //
1524     //  Memory references
1525     //
1526     if (inst->isMemRef()) {
1527         statComRefs[tid]++;
1528 
1529         if (inst->isLoad()) {
1530             statComLoads[tid]++;
1531         }
1532     }
1533 
1534     if (inst->isMemBarrier()) {
1535         statComMembars[tid]++;
1536     }
1537 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a132db67a5c42af856da64e347e8284d8}{
\index{LWBackEnd@{LWBackEnd}!updateExeInstStats@{updateExeInstStats}}
\index{updateExeInstStats@{updateExeInstStats}!LWBackEnd@{LWBackEnd}}
\subsubsection[{updateExeInstStats}]{\setlength{\rightskip}{0pt plus 5cm}void updateExeInstStats ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLWBackEnd_a132db67a5c42af856da64e347e8284d8}



\begin{DoxyCode}
1471 {
1472     ThreadID tid = inst->threadNumber;
1473 
1474     exeInst[tid]++;
1475 
1476     //
1477     //  Control operations
1478     //
1479     if (inst->isControl())
1480         exeBranches[tid]++;
1481 
1482     //
1483     //  Memory operations
1484     //
1485     if (inst->isMemRef()) {
1486         exeRefs[tid]++;
1487 
1488         if (inst->isLoad())
1489             exeLoads[tid]++;
1490     }
1491 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a1107d388cfcea92a9043608346ce98f0}{
\index{LWBackEnd@{LWBackEnd}!updateStructures@{updateStructures}}
\index{updateStructures@{updateStructures}!LWBackEnd@{LWBackEnd}}
\subsubsection[{updateStructures}]{\setlength{\rightskip}{0pt plus 5cm}void updateStructures ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLWBackEnd_a1107d388cfcea92a9043608346ce98f0}



\begin{DoxyCode}
642 {
643     if (fromCommit->doneSeqNum) {
644         LSQ.commitLoads(fromCommit->doneSeqNum);
645         LSQ.commitStores(fromCommit->doneSeqNum);
646     }
647 
648     if (fromCommit->nonSpecSeqNum) {
649         if (fromCommit->uncached) {
650 //            LSQ.executeLoad(fromCommit->lqIdx);
651         } else {
652 //            IQ.scheduleNonSpec(
653 //                fromCommit->nonSpecSeqNum);
654         }
655     }
656 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a044f74c5b9426d9738e2d015395a3e72}{
\index{LWBackEnd@{LWBackEnd}!wakeDependents@{wakeDependents}}
\index{wakeDependents@{wakeDependents}!LWBackEnd@{LWBackEnd}}
\subsubsection[{wakeDependents}]{\setlength{\rightskip}{0pt plus 5cm}int wakeDependents ({\bf DynInstPtr} \& {\em inst}, \/  bool {\em memory\_\-deps} = {\ttfamily false})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_a044f74c5b9426d9738e2d015395a3e72}



\begin{DoxyCode}
54 {
55     assert(!inst->isSquashed());
56     std::vector<DynInstPtr> &dependents = memory_deps ? inst->getMemDeps() :
57         inst->getDependents();
58     int num_outputs = dependents.size();
59 
60     DPRINTF(BE, "Waking instruction [sn:%lli] dependents in IQ\n", inst->seqNum);
      
61 
62     for (int i = 0; i < num_outputs; i++) {
63         DynInstPtr dep_inst = dependents[i];
64         if (!memory_deps) {
65             dep_inst->markSrcRegReady();
66         } else {
67             if (!dep_inst->isSquashed())
68                 dep_inst->markMemInstReady(inst.get());
69         }
70 
71         DPRINTF(BE, "Marking source reg ready [sn:%lli] in IQ\n", dep_inst->seqNu
      m);
72 
73         if (dep_inst->readyToIssue() && dep_inst->isInROB() &&
74             !dep_inst->isNonSpeculative() && !dep_inst->isStoreConditional() &&
75             dep_inst->memDepReady() && !dep_inst->isMemBarrier() &&
76             !dep_inst->isWriteBarrier()) {
77             DPRINTF(BE, "Adding instruction to exeList [sn:%lli]\n",
78                     dep_inst->seqNum);
79             exeList.push(dep_inst);
80             if (dep_inst->iqItValid) {
81                 DPRINTF(BE, "Removing instruction from waiting list\n");
82                 waitingList.erase(dep_inst->iqIt);
83                 waitingInsts--;
84                 dep_inst->iqItValid = false;
85                 assert(waitingInsts >= 0);
86             }
87             if (dep_inst->isMemRef()) {
88                 removeWaitingMemOp(dep_inst);
89                 DPRINTF(BE, "Issued a waiting mem op [sn:%lli]\n",
90                         dep_inst->seqNum);
91             }
92         }
93     }
94     return num_outputs;
95 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_abbf7bcc93511421a1787650a43e2642a}{
\index{LWBackEnd@{LWBackEnd}!write@{write}}
\index{write@{write}!LWBackEnd@{LWBackEnd}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} write ({\bf RequestPtr} {\em req}, \/  T \& {\em data}, \/  int {\em store\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLWBackEnd_abbf7bcc93511421a1787650a43e2642a}



\begin{DoxyCode}
431 {
432     return LSQ.write(req, data, store_idx);
433 }
\end{DoxyCode}
\hypertarget{classLWBackEnd_a5e9a203f943b3a8a243ddc6d2a0a240d}{
\index{LWBackEnd@{LWBackEnd}!writebackInsts@{writebackInsts}}
\index{writebackInsts@{writebackInsts}!LWBackEnd@{LWBackEnd}}
\subsubsection[{writebackInsts}]{\setlength{\rightskip}{0pt plus 5cm}void writebackInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a5e9a203f943b3a8a243ddc6d2a0a240d}


\subsection{変数}
\hypertarget{classLWBackEnd_af07b45c0b87d6672f4066d2c189013f9}{
\index{LWBackEnd@{LWBackEnd}!checker@{checker}}
\index{checker@{checker}!LWBackEnd@{LWBackEnd}}
\subsubsection[{checker}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Checker}$<${\bf DynInstPtr}$>$$\ast$ {\bf checker}}}
\label{classLWBackEnd_af07b45c0b87d6672f4066d2c189013f9}
\hypertarget{classLWBackEnd_a282f2307a986f183b83e887756561687}{
\index{LWBackEnd@{LWBackEnd}!comm@{comm}}
\index{comm@{comm}!LWBackEnd@{LWBackEnd}}
\subsubsection[{comm}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf CommStruct}$>$$\ast$ {\bf comm}}}
\label{classLWBackEnd_a282f2307a986f183b83e887756561687}
\hypertarget{classLWBackEnd_a26f5138543e43cbaba9459036fc0b04c}{
\index{LWBackEnd@{LWBackEnd}!commitEligible@{commitEligible}}
\index{commitEligible@{commitEligible}!LWBackEnd@{LWBackEnd}}
\subsubsection[{commitEligible}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf commitEligible}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a26f5138543e43cbaba9459036fc0b04c}
\hypertarget{classLWBackEnd_a16d1a4bbb2cb87488fd876fbf6e7a518}{
\index{LWBackEnd@{LWBackEnd}!commitEligibleSamples@{commitEligibleSamples}}
\index{commitEligibleSamples@{commitEligibleSamples}!LWBackEnd@{LWBackEnd}}
\subsubsection[{commitEligibleSamples}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf commitEligibleSamples}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a16d1a4bbb2cb87488fd876fbf6e7a518}
\hypertarget{classLWBackEnd_af043d6103c5f173871f527899c41d2d2}{
\index{LWBackEnd@{LWBackEnd}!commitPC@{commitPC}}
\index{commitPC@{commitPC}!LWBackEnd@{LWBackEnd}}
\subsubsection[{commitPC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf commitPC}}}
\label{classLWBackEnd_af043d6103c5f173871f527899c41d2d2}
\hypertarget{classLWBackEnd_adbf41f9b1f8e58747002bd5f65f2ded9}{
\index{LWBackEnd@{LWBackEnd}!commitRenameTable@{commitRenameTable}}
\index{commitRenameTable@{commitRenameTable}!LWBackEnd@{LWBackEnd}}
\subsubsection[{commitRenameTable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RenameTable}$<$Impl$>$ {\bf commitRenameTable}}}
\label{classLWBackEnd_adbf41f9b1f8e58747002bd5f65f2ded9}
\hypertarget{classLWBackEnd_aed64bfbc119bb879e8625e3951e26502}{
\index{LWBackEnd@{LWBackEnd}!commitStatus@{commitStatus}}
\index{commitStatus@{commitStatus}!LWBackEnd@{LWBackEnd}}
\subsubsection[{commitStatus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Status} {\bf commitStatus}}}
\label{classLWBackEnd_aed64bfbc119bb879e8625e3951e26502}
\hypertarget{classLWBackEnd_a328db48cdab1c2a18d8432b647e2785b}{
\index{LWBackEnd@{LWBackEnd}!commitWidth@{commitWidth}}
\index{commitWidth@{commitWidth}!LWBackEnd@{LWBackEnd}}
\subsubsection[{commitWidth}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf commitWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a328db48cdab1c2a18d8432b647e2785b}
\hypertarget{classLWBackEnd_a69b21b8b0360b93b3088bbf183fe6abf}{
\index{LWBackEnd@{LWBackEnd}!consumerInst@{consumerInst}}
\index{consumerInst@{consumerInst}!LWBackEnd@{LWBackEnd}}
\subsubsection[{consumerInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf consumerInst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a69b21b8b0360b93b3088bbf183fe6abf}
\hypertarget{classLWBackEnd_a61b5f503eec141308b0cd6b4322b405b}{
\index{LWBackEnd@{LWBackEnd}!cpu@{cpu}}
\index{cpu@{cpu}!LWBackEnd@{LWBackEnd}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf OzoneCPU}$\ast$ {\bf cpu}}}
\label{classLWBackEnd_a61b5f503eec141308b0cd6b4322b405b}
\hypertarget{classLWBackEnd_ae446eaddd47d5f227ed00af24aaefe68}{
\index{LWBackEnd@{LWBackEnd}!d2i@{d2i}}
\index{d2i@{d2i}!LWBackEnd@{LWBackEnd}}
\subsubsection[{d2i}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf DispatchToIssue}$>$ {\bf d2i}}}
\label{classLWBackEnd_ae446eaddd47d5f227ed00af24aaefe68}
\hypertarget{classLWBackEnd_a32343e1e9e56c17bb868f861f9b8927d}{
\index{LWBackEnd@{LWBackEnd}!dispatchSize@{dispatchSize}}
\index{dispatchSize@{dispatchSize}!LWBackEnd@{LWBackEnd}}
\subsubsection[{dispatchSize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf dispatchSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a32343e1e9e56c17bb868f861f9b8927d}
\hypertarget{classLWBackEnd_a245e3bace7ab490110304d56450aba64}{
\index{LWBackEnd@{LWBackEnd}!dispatchStatus@{dispatchStatus}}
\index{dispatchStatus@{dispatchStatus}!LWBackEnd@{LWBackEnd}}
\subsubsection[{dispatchStatus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Status} {\bf dispatchStatus}}}
\label{classLWBackEnd_a245e3bace7ab490110304d56450aba64}
\hypertarget{classLWBackEnd_aa304d4c426ea2bba52be0a3c0b9811e3}{
\index{LWBackEnd@{LWBackEnd}!dispatchWidth@{dispatchWidth}}
\index{dispatchWidth@{dispatchWidth}!LWBackEnd@{LWBackEnd}}
\subsubsection[{dispatchWidth}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf dispatchWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_aa304d4c426ea2bba52be0a3c0b9811e3}
\hypertarget{classLWBackEnd_a114248f83077c8e99f4f4aa0236aafeb}{
\index{LWBackEnd@{LWBackEnd}!e2c@{e2c}}
\index{e2c@{e2c}!LWBackEnd@{LWBackEnd}}
\subsubsection[{e2c}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf ExecToCommit}$>$ {\bf e2c}}}
\label{classLWBackEnd_a114248f83077c8e99f4f4aa0236aafeb}
\hypertarget{classLWBackEnd_a319e9530b28153883e886be5b9c573eb}{
\index{LWBackEnd@{LWBackEnd}!exactFullStall@{exactFullStall}}
\index{exactFullStall@{exactFullStall}!LWBackEnd@{LWBackEnd}}
\subsubsection[{exactFullStall}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf exactFullStall}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a319e9530b28153883e886be5b9c573eb}
\hypertarget{classLWBackEnd_a1c8de90750d60821aba6ab2e07c3564c}{
\index{LWBackEnd@{LWBackEnd}!exeBranches@{exeBranches}}
\index{exeBranches@{exeBranches}!LWBackEnd@{LWBackEnd}}
\subsubsection[{exeBranches}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf exeBranches}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a1c8de90750d60821aba6ab2e07c3564c}
\hypertarget{classLWBackEnd_a02103b42af4cd3d8b606764dcd24e277}{
\index{LWBackEnd@{LWBackEnd}!exeInst@{exeInst}}
\index{exeInst@{exeInst}!LWBackEnd@{LWBackEnd}}
\subsubsection[{exeInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf exeInst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a02103b42af4cd3d8b606764dcd24e277}
\hypertarget{classLWBackEnd_a033c224149bfca7d589121bf77f1b681}{
\index{LWBackEnd@{LWBackEnd}!exeList@{exeList}}
\index{exeList@{exeList}!LWBackEnd@{LWBackEnd}}
\subsubsection[{exeList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ReadyInstQueue} {\bf exeList}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a033c224149bfca7d589121bf77f1b681}
\hypertarget{classLWBackEnd_acdffd7467b37177b4352cc95a4541c7d}{
\index{LWBackEnd@{LWBackEnd}!exeLoads@{exeLoads}}
\index{exeLoads@{exeLoads}!LWBackEnd@{LWBackEnd}}
\subsubsection[{exeLoads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf exeLoads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_acdffd7467b37177b4352cc95a4541c7d}
\hypertarget{classLWBackEnd_acada805051a7dbb6b8459c5856be8a01}{
\index{LWBackEnd@{LWBackEnd}!exeNop@{exeNop}}
\index{exeNop@{exeNop}!LWBackEnd@{LWBackEnd}}
\subsubsection[{exeNop}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf exeNop}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_acada805051a7dbb6b8459c5856be8a01}
\hypertarget{classLWBackEnd_aad83ba41ef04d5d18ea21b492e5b2313}{
\index{LWBackEnd@{LWBackEnd}!exeRefs@{exeRefs}}
\index{exeRefs@{exeRefs}!LWBackEnd@{LWBackEnd}}
\subsubsection[{exeRefs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf exeRefs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_aad83ba41ef04d5d18ea21b492e5b2313}
\hypertarget{classLWBackEnd_a149e196f188dd6166c0c8c16cc023ad2}{
\index{LWBackEnd@{LWBackEnd}!exeSwp@{exeSwp}}
\index{exeSwp@{exeSwp}!LWBackEnd@{LWBackEnd}}
\subsubsection[{exeSwp}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf exeSwp}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a149e196f188dd6166c0c8c16cc023ad2}
\hypertarget{classLWBackEnd_a77bf6c956edddf1d551d5371ff72162e}{
\index{LWBackEnd@{LWBackEnd}!fromCommit@{fromCommit}}
\index{fromCommit@{fromCommit}!LWBackEnd@{LWBackEnd}}
\subsubsection[{fromCommit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf CommStruct}$>$::wire {\bf fromCommit}}}
\label{classLWBackEnd_a77bf6c956edddf1d551d5371ff72162e}
\hypertarget{classLWBackEnd_a67c762418bb2017cb2dce5a0c94f0788}{
\index{LWBackEnd@{LWBackEnd}!frontEnd@{frontEnd}}
\index{frontEnd@{frontEnd}!LWBackEnd@{LWBackEnd}}
\subsubsection[{frontEnd}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FrontEnd}$\ast$ {\bf frontEnd}}}
\label{classLWBackEnd_a67c762418bb2017cb2dce5a0c94f0788}
\hypertarget{classLWBackEnd_a344acde4f72898017365be79fd18a323}{
\index{LWBackEnd@{LWBackEnd}!funcExeInst@{funcExeInst}}
\index{funcExeInst@{funcExeInst}!LWBackEnd@{LWBackEnd}}
\subsubsection[{funcExeInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Counter} {\bf funcExeInst}}}
\label{classLWBackEnd_a344acde4f72898017365be79fd18a323}
\hypertarget{classLWBackEnd_a055203b013ada25d70a2a2c8b2364455}{
\index{LWBackEnd@{LWBackEnd}!i2e@{i2e}}
\index{i2e@{i2e}!LWBackEnd@{LWBackEnd}}
\subsubsection[{i2e}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf IssueToExec}$>$ {\bf i2e}}}
\label{classLWBackEnd_a055203b013ada25d70a2a2c8b2364455}
\hypertarget{classLWBackEnd_ae10a391d02ce1ef67ee13cd82b7d46e5}{
\index{LWBackEnd@{LWBackEnd}!instList@{instList}}
\index{instList@{instList}!LWBackEnd@{LWBackEnd}}
\subsubsection[{instList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf instList}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_ae10a391d02ce1ef67ee13cd82b7d46e5}
\hypertarget{classLWBackEnd_ace1cd34be1eca99cb8c1d3a30e32fcbe}{
\index{LWBackEnd@{LWBackEnd}!instsToDispatch@{instsToDispatch}}
\index{instsToDispatch@{instsToDispatch}!LWBackEnd@{LWBackEnd}}
\subsubsection[{instsToDispatch}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf DispatchToIssue}$>$::wire {\bf instsToDispatch}}}
\label{classLWBackEnd_ace1cd34be1eca99cb8c1d3a30e32fcbe}
\hypertarget{classLWBackEnd_a45c3ddf2275eab2326190578f1fcbee2}{
\index{LWBackEnd@{LWBackEnd}!instsToExecute@{instsToExecute}}
\index{instsToExecute@{instsToExecute}!LWBackEnd@{LWBackEnd}}
\subsubsection[{instsToExecute}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf IssueToExec}$>$::wire {\bf instsToExecute}}}
\label{classLWBackEnd_a45c3ddf2275eab2326190578f1fcbee2}
\hypertarget{classLWBackEnd_ab6f202cc22f2199e7d5cafb2e5af3451}{
\index{LWBackEnd@{LWBackEnd}!invAddrLoads@{invAddrLoads}}
\index{invAddrLoads@{invAddrLoads}!LWBackEnd@{LWBackEnd}}
\subsubsection[{invAddrLoads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf invAddrLoads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_ab6f202cc22f2199e7d5cafb2e5af3451}
\hypertarget{classLWBackEnd_a188a7b143a76b88b85fb994dbdd7e0ea}{
\index{LWBackEnd@{LWBackEnd}!invAddrSwpfs@{invAddrSwpfs}}
\index{invAddrSwpfs@{invAddrSwpfs}!LWBackEnd@{LWBackEnd}}
\subsubsection[{invAddrSwpfs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf invAddrSwpfs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a188a7b143a76b88b85fb994dbdd7e0ea}
\hypertarget{classLWBackEnd_a18e004a2b90fafdb8e602ab4fd99f971}{
\index{LWBackEnd@{LWBackEnd}!iqCapEvents@{iqCapEvents}}
\index{iqCapEvents@{iqCapEvents}!LWBackEnd@{LWBackEnd}}
\subsubsection[{iqCapEvents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf iqCapEvents}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a18e004a2b90fafdb8e602ab4fd99f971}
\hypertarget{classLWBackEnd_adf3ce08ee23edc6f4b6d1dcea1b39b31}{
\index{LWBackEnd@{LWBackEnd}!iqCapInstCount@{iqCapInstCount}}
\index{iqCapInstCount@{iqCapInstCount}!LWBackEnd@{LWBackEnd}}
\subsubsection[{iqCapInstCount}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf iqCapInstCount}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_adf3ce08ee23edc6f4b6d1dcea1b39b31}
\hypertarget{classLWBackEnd_ace641e242f8066857ee021c0f54488fc}{
\index{LWBackEnd@{LWBackEnd}!issuedOps@{issuedOps}}
\index{issuedOps@{issuedOps}!LWBackEnd@{LWBackEnd}}
\subsubsection[{issuedOps}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf issuedOps}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_ace641e242f8066857ee021c0f54488fc}
\hypertarget{classLWBackEnd_a171bac1210be84c8811563ab35209fce}{
\index{LWBackEnd@{LWBackEnd}!issueWidth@{issueWidth}}
\index{issueWidth@{issueWidth}!LWBackEnd@{LWBackEnd}}
\subsubsection[{issueWidth}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf issueWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a171bac1210be84c8811563ab35209fce}
\hypertarget{classLWBackEnd_aeb527b92e111b469a5358de46cc799b6}{
\index{LWBackEnd@{LWBackEnd}!lastCommitCycle@{lastCommitCycle}}
\index{lastCommitCycle@{lastCommitCycle}!LWBackEnd@{LWBackEnd}}
\subsubsection[{lastCommitCycle}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf lastCommitCycle}}}
\label{classLWBackEnd_aeb527b92e111b469a5358de46cc799b6}
\hypertarget{classLWBackEnd_a9c5bf07170b5d91cfb44d4bfd0517128}{
\index{LWBackEnd@{LWBackEnd}!latency@{latency}}
\index{latency@{latency}!LWBackEnd@{LWBackEnd}}
\subsubsection[{latency}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf latency}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a9c5bf07170b5d91cfb44d4bfd0517128}
\hypertarget{classLWBackEnd_a2d033f80e55d1123d747d40f026042aa}{
\index{LWBackEnd@{LWBackEnd}!LSQ@{LSQ}}
\index{LSQ@{LSQ}!LWBackEnd@{LWBackEnd}}
\subsubsection[{LSQ}]{\setlength{\rightskip}{0pt plus 5cm}{\bf LdstQueue} {\bf LSQ}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a2d033f80e55d1123d747d40f026042aa}
\hypertarget{classLWBackEnd_a4b6441df3c51e29c627f7dbf5bed8409}{
\index{LWBackEnd@{LWBackEnd}!lsqBlockedLoads@{lsqBlockedLoads}}
\index{lsqBlockedLoads@{lsqBlockedLoads}!LWBackEnd@{LWBackEnd}}
\subsubsection[{lsqBlockedLoads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf lsqBlockedLoads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a4b6441df3c51e29c627f7dbf5bed8409}
\hypertarget{classLWBackEnd_a8360980798f5ee19e9b6a40c1d2402dd}{
\index{LWBackEnd@{LWBackEnd}!lsqForwLoads@{lsqForwLoads}}
\index{lsqForwLoads@{lsqForwLoads}!LWBackEnd@{LWBackEnd}}
\subsubsection[{lsqForwLoads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf lsqForwLoads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a8360980798f5ee19e9b6a40c1d2402dd}
\hypertarget{classLWBackEnd_abf96f4acba126fbcf919829a1125954c}{
\index{LWBackEnd@{LWBackEnd}!lsqInversion@{lsqInversion}}
\index{lsqInversion@{lsqInversion}!LWBackEnd@{LWBackEnd}}
\subsubsection[{lsqInversion}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf lsqInversion}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_abf96f4acba126fbcf919829a1125954c}
\hypertarget{classLWBackEnd_a448f97a01f3a53c40ed453a5e27c02ab}{
\index{LWBackEnd@{LWBackEnd}!lsqLimits@{lsqLimits}}
\index{lsqLimits@{lsqLimits}!LWBackEnd@{LWBackEnd}}
\subsubsection[{lsqLimits}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf lsqLimits}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a448f97a01f3a53c40ed453a5e27c02ab}
\hypertarget{classLWBackEnd_ad6fbab05ce17a32ecda942c0cf4398ae}{
\index{LWBackEnd@{LWBackEnd}!maxOutstandingMemOps@{maxOutstandingMemOps}}
\index{maxOutstandingMemOps@{maxOutstandingMemOps}!LWBackEnd@{LWBackEnd}}
\subsubsection[{maxOutstandingMemOps}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf maxOutstandingMemOps}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_ad6fbab05ce17a32ecda942c0cf4398ae}
\hypertarget{classLWBackEnd_aba4f4d748e592a95e9a44184b2f4cfa9}{
\index{LWBackEnd@{LWBackEnd}!memBarrier@{memBarrier}}
\index{memBarrier@{memBarrier}!LWBackEnd@{LWBackEnd}}
\subsubsection[{memBarrier}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf memBarrier}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_aba4f4d748e592a95e9a44184b2f4cfa9}
\hypertarget{classLWBackEnd_a95950b28aceca73a1f17427dd767552d}{
\index{LWBackEnd@{LWBackEnd}!nCommittedDist@{nCommittedDist}}
\index{nCommittedDist@{nCommittedDist}!LWBackEnd@{LWBackEnd}}
\subsubsection[{nCommittedDist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Distribution} {\bf nCommittedDist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a95950b28aceca73a1f17427dd767552d}
\hypertarget{classLWBackEnd_a63ce9344b46599ab3db4eb196ee89799}{
\index{LWBackEnd@{LWBackEnd}!nIssuedDist@{nIssuedDist}}
\index{nIssuedDist@{nIssuedDist}!LWBackEnd@{LWBackEnd}}
\subsubsection[{nIssuedDist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf nIssuedDist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a63ce9344b46599ab3db4eb196ee89799}
\hypertarget{classLWBackEnd_a358c879c68910efe5300c4515df35b6c}{
\index{LWBackEnd@{LWBackEnd}!numInsts@{numInsts}}
\index{numInsts@{numInsts}!LWBackEnd@{LWBackEnd}}
\subsubsection[{numInsts}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf numInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a358c879c68910efe5300c4515df35b6c}
\hypertarget{classLWBackEnd_a34cd6ffaeb59e3f95f2cc2aaf8eb7ecf}{
\index{LWBackEnd@{LWBackEnd}!numInstsToWB@{numInstsToWB}}
\index{numInstsToWB@{numInstsToWB}!LWBackEnd@{LWBackEnd}}
\subsubsection[{numInstsToWB}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<$int$>$ {\bf numInstsToWB}}}
\label{classLWBackEnd_a34cd6ffaeb59e3f95f2cc2aaf8eb7ecf}
\hypertarget{classLWBackEnd_ae40678133a160367f2207f07975ca0f3}{
\index{LWBackEnd@{LWBackEnd}!numROBEntries@{numROBEntries}}
\index{numROBEntries@{numROBEntries}!LWBackEnd@{LWBackEnd}}
\subsubsection[{numROBEntries}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf numROBEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_ae40678133a160367f2207f07975ca0f3}
\hypertarget{classLWBackEnd_a96e0941aaf8a2dd157434967a452531b}{
\index{LWBackEnd@{LWBackEnd}!numWaitingMemOps@{numWaitingMemOps}}
\index{numWaitingMemOps@{numWaitingMemOps}!LWBackEnd@{LWBackEnd}}
\subsubsection[{numWaitingMemOps}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf numWaitingMemOps}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a96e0941aaf8a2dd157434967a452531b}
\hypertarget{classLWBackEnd_a79df9c76c4c8c7da92694a4a571d44f0}{
\index{LWBackEnd@{LWBackEnd}!producerInst@{producerInst}}
\index{producerInst@{producerInst}!LWBackEnd@{LWBackEnd}}
\subsubsection[{producerInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf producerInst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a79df9c76c4c8c7da92694a4a571d44f0}
\hypertarget{classLWBackEnd_af8d3f859e7c0dd9408ba99de6f415616}{
\index{LWBackEnd@{LWBackEnd}!renameTable@{renameTable}}
\index{renameTable@{renameTable}!LWBackEnd@{LWBackEnd}}
\subsubsection[{renameTable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RenameTable}$<$Impl$>$ {\bf renameTable}}}
\label{classLWBackEnd_af8d3f859e7c0dd9408ba99de6f415616}
\hypertarget{classLWBackEnd_a75af5d227f5f7bbb93a6bb4bf680e6ee}{
\index{LWBackEnd@{LWBackEnd}!replayList@{replayList}}
\index{replayList@{replayList}!LWBackEnd@{LWBackEnd}}
\subsubsection[{replayList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf replayList}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a75af5d227f5f7bbb93a6bb4bf680e6ee}
\hypertarget{classLWBackEnd_a746b17c64f4337f2cf0bd3eb37df8cf5}{
\index{LWBackEnd@{LWBackEnd}!robCapEvents@{robCapEvents}}
\index{robCapEvents@{robCapEvents}!LWBackEnd@{LWBackEnd}}
\subsubsection[{robCapEvents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf robCapEvents}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a746b17c64f4337f2cf0bd3eb37df8cf5}
\hypertarget{classLWBackEnd_aea092d89c0e23a99adfd1aa642e8ad37}{
\index{LWBackEnd@{LWBackEnd}!robCapInstCount@{robCapInstCount}}
\index{robCapInstCount@{robCapInstCount}!LWBackEnd@{LWBackEnd}}
\subsubsection[{robCapInstCount}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf robCapInstCount}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_aea092d89c0e23a99adfd1aa642e8ad37}
\hypertarget{classLWBackEnd_a39034d47fcced7afdc840710ff261574}{
\index{LWBackEnd@{LWBackEnd}!ROBCount@{ROBCount}}
\index{ROBCount@{ROBCount}!LWBackEnd@{LWBackEnd}}
\subsubsection[{ROBCount}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf ROBCount}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a39034d47fcced7afdc840710ff261574}
\hypertarget{classLWBackEnd_afdfe647a67d89f9620c69019c79547be}{
\index{LWBackEnd@{LWBackEnd}!ROBFcount@{ROBFcount}}
\index{ROBFcount@{ROBFcount}!LWBackEnd@{LWBackEnd}}
\subsubsection[{ROBFcount}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf ROBFcount}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_afdfe647a67d89f9620c69019c79547be}
\hypertarget{classLWBackEnd_a26d90e83e9d707184d857b5df610d726}{
\index{LWBackEnd@{LWBackEnd}!ROBFullRate@{ROBFullRate}}
\index{ROBFullRate@{ROBFullRate}!LWBackEnd@{LWBackEnd}}
\subsubsection[{ROBFullRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf ROBFullRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a26d90e83e9d707184d857b5df610d726}
\hypertarget{classLWBackEnd_afb382907daa4161f6ea36acfab3a1c40}{
\index{LWBackEnd@{LWBackEnd}!ROBOccRate@{ROBOccRate}}
\index{ROBOccRate@{ROBOccRate}!LWBackEnd@{LWBackEnd}}
\subsubsection[{ROBOccRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf ROBOccRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_afb382907daa4161f6ea36acfab3a1c40}
\hypertarget{classLWBackEnd_ae0e4c1bd43a0cb1f736062e536168fa3}{
\index{LWBackEnd@{LWBackEnd}!ROBSquashedInsts@{ROBSquashedInsts}}
\index{ROBSquashedInsts@{ROBSquashedInsts}!LWBackEnd@{LWBackEnd}}
\subsubsection[{ROBSquashedInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf ROBSquashedInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_ae0e4c1bd43a0cb1f736062e536168fa3}
\hypertarget{classLWBackEnd_ab27e4267b3c35957215c1c88c2d6462a}{
\index{LWBackEnd@{LWBackEnd}!squashedInsts@{squashedInsts}}
\index{squashedInsts@{squashedInsts}!LWBackEnd@{LWBackEnd}}
\subsubsection[{squashedInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf squashedInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_ab27e4267b3c35957215c1c88c2d6462a}
\hypertarget{classLWBackEnd_a440f8cda1481977c324a827c7c9f1e24}{
\index{LWBackEnd@{LWBackEnd}!squashLatency@{squashLatency}}
\index{squashLatency@{squashLatency}!LWBackEnd@{LWBackEnd}}
\subsubsection[{squashLatency}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf squashLatency}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a440f8cda1481977c324a827c7c9f1e24}
\hypertarget{classLWBackEnd_aabe0c73b4678ef858d3363c9bed18906}{
\index{LWBackEnd@{LWBackEnd}!squashNextPC@{squashNextPC}}
\index{squashNextPC@{squashNextPC}!LWBackEnd@{LWBackEnd}}
\subsubsection[{squashNextPC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf squashNextPC}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_aabe0c73b4678ef858d3363c9bed18906}
\hypertarget{classLWBackEnd_a2aafb6fc593b04986eeed845923a8953}{
\index{LWBackEnd@{LWBackEnd}!squashPending@{squashPending}}
\index{squashPending@{squashPending}!LWBackEnd@{LWBackEnd}}
\subsubsection[{squashPending}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf squashPending}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a2aafb6fc593b04986eeed845923a8953}
\hypertarget{classLWBackEnd_a34292b1418c46ca63c892e7826510d77}{
\index{LWBackEnd@{LWBackEnd}!squashSeqNum@{squashSeqNum}}
\index{squashSeqNum@{squashSeqNum}!LWBackEnd@{LWBackEnd}}
\subsubsection[{squashSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf squashSeqNum}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a34292b1418c46ca63c892e7826510d77}
\hypertarget{classLWBackEnd_a39a7da0b20d1e83ccfe4b2f2b19d6e94}{
\index{LWBackEnd@{LWBackEnd}!statComBranches@{statComBranches}}
\index{statComBranches@{statComBranches}!LWBackEnd@{LWBackEnd}}
\subsubsection[{statComBranches}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf statComBranches}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a39a7da0b20d1e83ccfe4b2f2b19d6e94}
\hypertarget{classLWBackEnd_a17e218fe16ffffa3f596551115cf1592}{
\index{LWBackEnd@{LWBackEnd}!statComInst@{statComInst}}
\index{statComInst@{statComInst}!LWBackEnd@{LWBackEnd}}
\subsubsection[{statComInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf statComInst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a17e218fe16ffffa3f596551115cf1592}
\hypertarget{classLWBackEnd_a91927819864b9dc9d1ac706dc55d5dce}{
\index{LWBackEnd@{LWBackEnd}!statComLoads@{statComLoads}}
\index{statComLoads@{statComLoads}!LWBackEnd@{LWBackEnd}}
\subsubsection[{statComLoads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf statComLoads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a91927819864b9dc9d1ac706dc55d5dce}
\hypertarget{classLWBackEnd_a9b029ac182d54199247dfa90ed86d368}{
\index{LWBackEnd@{LWBackEnd}!statComMembars@{statComMembars}}
\index{statComMembars@{statComMembars}!LWBackEnd@{LWBackEnd}}
\subsubsection[{statComMembars}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf statComMembars}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a9b029ac182d54199247dfa90ed86d368}
\hypertarget{classLWBackEnd_afe174c4b8e70d840a2e91bf1ca3092ac}{
\index{LWBackEnd@{LWBackEnd}!statComRefs@{statComRefs}}
\index{statComRefs@{statComRefs}!LWBackEnd@{LWBackEnd}}
\subsubsection[{statComRefs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf statComRefs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_afe174c4b8e70d840a2e91bf1ca3092ac}
\hypertarget{classLWBackEnd_a4cb385aa97530dd2621c74f376839e79}{
\index{LWBackEnd@{LWBackEnd}!statComSwp@{statComSwp}}
\index{statComSwp@{statComSwp}!LWBackEnd@{LWBackEnd}}
\subsubsection[{statComSwp}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf statComSwp}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a4cb385aa97530dd2621c74f376839e79}
\hypertarget{classLWBackEnd_ae29aa2d4ae440022daaed1107eb306b3}{
\index{LWBackEnd@{LWBackEnd}!status@{status}}
\index{status@{status}!LWBackEnd@{LWBackEnd}}
\subsubsection[{status}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Status} {\bf status}}}
\label{classLWBackEnd_ae29aa2d4ae440022daaed1107eb306b3}
\hypertarget{classLWBackEnd_a1aee6db9bfb75cf02e38a82e5d02847f}{
\index{LWBackEnd@{LWBackEnd}!switchedOut@{switchedOut}}
\index{switchedOut@{switchedOut}!LWBackEnd@{LWBackEnd}}
\subsubsection[{switchedOut}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf switchedOut}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a1aee6db9bfb75cf02e38a82e5d02847f}
\hypertarget{classLWBackEnd_ace47ce39eea04902597d72ae3040c322}{
\index{LWBackEnd@{LWBackEnd}!switchPending@{switchPending}}
\index{switchPending@{switchPending}!LWBackEnd@{LWBackEnd}}
\subsubsection[{switchPending}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf switchPending}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_ace47ce39eea04902597d72ae3040c322}
\hypertarget{classLWBackEnd_a4455a4759e69e5ebe68ae7298cbcc37d}{
\index{LWBackEnd@{LWBackEnd}!tc@{tc}}
\index{tc@{tc}!LWBackEnd@{LWBackEnd}}
\subsubsection[{tc}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadContext}$\ast$ {\bf tc}}}
\label{classLWBackEnd_a4455a4759e69e5ebe68ae7298cbcc37d}
\hypertarget{classLWBackEnd_ae3369c2288f4867553aaca811229bd3c}{
\index{LWBackEnd@{LWBackEnd}!tcSquash@{tcSquash}}
\index{tcSquash@{tcSquash}!LWBackEnd@{LWBackEnd}}
\subsubsection[{tcSquash}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf tcSquash}}}
\label{classLWBackEnd_ae3369c2288f4867553aaca811229bd3c}
\hypertarget{classLWBackEnd_a743989b66f3b52f1eda2a8498a93da0b}{
\index{LWBackEnd@{LWBackEnd}!thread@{thread}}
\index{thread@{thread}!LWBackEnd@{LWBackEnd}}
\subsubsection[{thread}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Thread}$\ast$ {\bf thread}}}
\label{classLWBackEnd_a743989b66f3b52f1eda2a8498a93da0b}
\hypertarget{classLWBackEnd_acf56450a952ce19a7cc68c86f0334c0c}{
\index{LWBackEnd@{LWBackEnd}!toIEW@{toIEW}}
\index{toIEW@{toIEW}!LWBackEnd@{LWBackEnd}}
\subsubsection[{toIEW}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf CommStruct}$>$::wire {\bf toIEW}}}
\label{classLWBackEnd_acf56450a952ce19a7cc68c86f0334c0c}
\hypertarget{classLWBackEnd_a9fe09e5855dab23839c125d21e03c644}{
\index{LWBackEnd@{LWBackEnd}!trapSquash@{trapSquash}}
\index{trapSquash@{trapSquash}!LWBackEnd@{LWBackEnd}}
\subsubsection[{trapSquash}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf trapSquash}}}
\label{classLWBackEnd_a9fe09e5855dab23839c125d21e03c644}
\hypertarget{classLWBackEnd_a9b9600f987928599f17c3549b0de891a}{
\index{LWBackEnd@{LWBackEnd}!waitingInsts@{waitingInsts}}
\index{waitingInsts@{waitingInsts}!LWBackEnd@{LWBackEnd}}
\subsubsection[{waitingInsts}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf waitingInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a9b9600f987928599f17c3549b0de891a}
\hypertarget{classLWBackEnd_a01b09fb4e81dae8e11ca298561afebe9}{
\index{LWBackEnd@{LWBackEnd}!waitingList@{waitingList}}
\index{waitingList@{waitingList}!LWBackEnd@{LWBackEnd}}
\subsubsection[{waitingList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf waitingList}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a01b09fb4e81dae8e11ca298561afebe9}
\hypertarget{classLWBackEnd_af9ed5543b904bf082a41d640654588e5}{
\index{LWBackEnd@{LWBackEnd}!waitingMemOps@{waitingMemOps}}
\index{waitingMemOps@{waitingMemOps}!LWBackEnd@{LWBackEnd}}
\subsubsection[{waitingMemOps}]{\setlength{\rightskip}{0pt plus 5cm}std::set$<${\bf InstSeqNum}$>$ {\bf waitingMemOps}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_af9ed5543b904bf082a41d640654588e5}
\hypertarget{classLWBackEnd_ad2c7b2687f864f2b7359eb393276996f}{
\index{LWBackEnd@{LWBackEnd}!wbCycle@{wbCycle}}
\index{wbCycle@{wbCycle}!LWBackEnd@{LWBackEnd}}
\subsubsection[{wbCycle}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf wbCycle}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_ad2c7b2687f864f2b7359eb393276996f}
Cycle number within the queue of instructions being written back. Used in case there are too many instructions writing back at the current cycle and writesbacks need to be scheduled for the future. See comments in \hyperlink{classLWBackEnd_a720e9865ffa6e84b756f5ec1d1a24d94}{instToCommit()}. \hypertarget{classLWBackEnd_a667246d811337454bc9ceccf8bbf8f1c}{
\index{LWBackEnd@{LWBackEnd}!wbFanout@{wbFanout}}
\index{wbFanout@{wbFanout}!LWBackEnd@{LWBackEnd}}
\subsubsection[{wbFanout}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf wbFanout}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a667246d811337454bc9ceccf8bbf8f1c}
\hypertarget{classLWBackEnd_a5fa0799bf5569437190dd1eda1d62b7b}{
\index{LWBackEnd@{LWBackEnd}!wbNumInst@{wbNumInst}}
\index{wbNumInst@{wbNumInst}!LWBackEnd@{LWBackEnd}}
\subsubsection[{wbNumInst}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf wbNumInst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a5fa0799bf5569437190dd1eda1d62b7b}
Index into queue of instructions being written back. \hypertarget{classLWBackEnd_a364daa8f3a358e41aa13fac115bb5e0f}{
\index{LWBackEnd@{LWBackEnd}!wbPenalized@{wbPenalized}}
\index{wbPenalized@{wbPenalized}!LWBackEnd@{LWBackEnd}}
\subsubsection[{wbPenalized}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf wbPenalized}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a364daa8f3a358e41aa13fac115bb5e0f}
\hypertarget{classLWBackEnd_a58a4cd085d39435e69bc1ee729422d84}{
\index{LWBackEnd@{LWBackEnd}!wbPenalizedRate@{wbPenalizedRate}}
\index{wbPenalizedRate@{wbPenalizedRate}!LWBackEnd@{LWBackEnd}}
\subsubsection[{wbPenalizedRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf wbPenalizedRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a58a4cd085d39435e69bc1ee729422d84}
\hypertarget{classLWBackEnd_a5ab2bb9fa8eb98a735a204082a37c9db}{
\index{LWBackEnd@{LWBackEnd}!wbRate@{wbRate}}
\index{wbRate@{wbRate}!LWBackEnd@{LWBackEnd}}
\subsubsection[{wbRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf wbRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a5ab2bb9fa8eb98a735a204082a37c9db}
\hypertarget{classLWBackEnd_a20d3086e6bcdc826d99143ac7c9b23a4}{
\index{LWBackEnd@{LWBackEnd}!wbWidth@{wbWidth}}
\index{wbWidth@{wbWidth}!LWBackEnd@{LWBackEnd}}
\subsubsection[{wbWidth}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf wbWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a20d3086e6bcdc826d99143ac7c9b23a4}
\hypertarget{classLWBackEnd_a2474a5474cbff19523a51eb1de01cda4}{
\index{LWBackEnd@{LWBackEnd}!width@{width}}
\index{width@{width}!LWBackEnd@{LWBackEnd}}
\subsubsection[{width}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf width}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a2474a5474cbff19523a51eb1de01cda4}
\hypertarget{classLWBackEnd_ae4b76f4612be07d13b349e13ee9dfa16}{
\index{LWBackEnd@{LWBackEnd}!writeback@{writeback}}
\index{writeback@{writeback}!LWBackEnd@{LWBackEnd}}
\subsubsection[{writeback}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf writeback}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_ae4b76f4612be07d13b349e13ee9dfa16}
\hypertarget{classLWBackEnd_a85f5041a2e3375a2dc81bc0ae534aa2e}{
\index{LWBackEnd@{LWBackEnd}!writebackCount@{writebackCount}}
\index{writebackCount@{writebackCount}!LWBackEnd@{LWBackEnd}}
\subsubsection[{writebackCount}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf writebackCount}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLWBackEnd_a85f5041a2e3375a2dc81bc0ae534aa2e}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/ozone/\hyperlink{lw__back__end_8hh}{lw\_\-back\_\-end.hh}\item 
cpu/ozone/\hyperlink{lw__back__end__impl_8hh}{lw\_\-back\_\-end\_\-impl.hh}\end{DoxyCompactItemize}
