\hypertarget{classBackEnd}{
\section{クラス テンプレート BackEnd$<$ Impl $>$}
\label{classBackEnd}\index{BackEnd@{BackEnd}}
}


{\ttfamily \#include $<$back\_\-end.hh$>$}\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classBackEnd_1_1DCacheCompletionEvent}{DCacheCompletionEvent}
\item 
class \hyperlink{classBackEnd_1_1InstQueue}{InstQueue}
\item 
class \hyperlink{classBackEnd_1_1LdWritebackEvent}{LdWritebackEvent}
\item 
struct \hyperlink{structBackEnd_1_1SizeStruct}{SizeStruct}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \{ \par
\hyperlink{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}{Running}, 
\hyperlink{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}{Idle}, 
\hyperlink{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba4ba5ae5815b190bd652669e2fdea5ed7}{DcacheMissStall}, 
\hyperlink{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba1eb81f4540c1c4b90839b08ae63c5d7f}{DcacheMissComplete}, 
\par
\hyperlink{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba9463ee9b8700258a1019b4b9d2d77a30}{Blocked}
 \}
\item 
typedef \hyperlink{structOzoneThreadState}{OzoneThreadState}$<$ Impl $>$ \hyperlink{classBackEnd_a9311aca87e8229ec3f7a7422ccbc9fbe}{Thread}
\item 
typedef Impl::Params \hyperlink{classBackEnd_a818e103eae798a24a06a0a34631849ea}{Params}
\item 
typedef Impl::DynInst \hyperlink{classBackEnd_ab741745c86a14c765b999c11167636d9}{DynInst}
\item 
typedef Impl::DynInstPtr \hyperlink{classBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}
\item 
typedef Impl::FullCPU \hyperlink{classBackEnd_a90ba84e54618cc07f2e8f05e046cb5ce}{FullCPU}
\item 
typedef Impl::FrontEnd \hyperlink{classBackEnd_abe8e1d8243582d5024a1076f6091d9fe}{FrontEnd}
\item 
typedef Impl::FullCPU::CommStruct \hyperlink{classBackEnd_a82fb3c7183ba777a05c510ab2fbcfb82}{CommStruct}
\item 
typedef \hyperlink{structBackEnd_1_1SizeStruct}{SizeStruct} \hyperlink{classBackEnd_a99d236038ce57aa3ef78858228c5f972}{DispatchToIssue}
\item 
typedef \hyperlink{structBackEnd_1_1SizeStruct}{SizeStruct} \hyperlink{classBackEnd_a5badfe54e71b8fccb3d371013a8eef73}{IssueToExec}
\item 
typedef \hyperlink{structBackEnd_1_1SizeStruct}{SizeStruct} \hyperlink{classBackEnd_a91ea582041466725b4b17ce19f98685f}{ExecToCommit}
\item 
typedef \hyperlink{structBackEnd_1_1SizeStruct}{SizeStruct} \hyperlink{classBackEnd_a20d1fb15b536d49c687dee42d95c1a87}{Writeback}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classBackEnd_a8698a618ba78dbd457f2cee79a739588}{BackEnd} (\hyperlink{classBackEnd_a818e103eae798a24a06a0a34631849ea}{Params} $\ast$params)
\item 
std::string \hyperlink{classBackEnd_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classBackEnd_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classBackEnd_ad491c9766121fc19aa77fd0723e7641d}{setCPU} (\hyperlink{classBackEnd_a90ba84e54618cc07f2e8f05e046cb5ce}{FullCPU} $\ast$cpu\_\-ptr)
\item 
void \hyperlink{classBackEnd_a122009fa2730cee3898ac945227da8eb}{setFrontEnd} (\hyperlink{classFrontEnd}{FrontEnd} $\ast$front\_\-end\_\-ptr)
\item 
void \hyperlink{classBackEnd_ac6ccaaea6ac518cab92f71723b5a739e}{setTC} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc\_\-ptr)
\item 
void \hyperlink{classBackEnd_a850bea4a9b9f631e7b6a4c7dc92f662a}{setThreadState} (\hyperlink{structOzoneThreadState}{Thread} $\ast$thread\_\-ptr)
\item 
void \hyperlink{classBackEnd_aeabdb9f0aae07df67c3029f8fddb2693}{setCommBuffer} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classBackEnd_a82fb3c7183ba777a05c510ab2fbcfb82}{CommStruct} $>$ $\ast$\_\-comm)
\item 
void \hyperlink{classBackEnd_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\item 
void \hyperlink{classBackEnd_a3c68c455d9207edd23ae3bcb7971e653}{squash} ()
\item 
void \hyperlink{classBackEnd_a24cd8db837a73b879041bf33da7b2064}{squashFromTC} ()
\item 
{\footnotesize template$<$class T $>$ }\\\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classBackEnd_a0747777ac998dabdc20fa0c554d378d3}{read} (\hyperlink{classRequest}{RequestPtr} req, T \&data, int load\_\-idx)
\item 
{\footnotesize template$<$class T $>$ }\\\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classBackEnd_abbf7bcc93511421a1787650a43e2642a}{write} (\hyperlink{classRequest}{RequestPtr} req, T \&data, int store\_\-idx)
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classBackEnd_aa28f3fe58fde4b038a92b9f87a40cb10}{readCommitPC} ()
\item 
bool \hyperlink{classBackEnd_a5c38df1621043861ada4dd0939509869}{robEmpty} ()
\item 
bool \hyperlink{classBackEnd_a3e70330939fdfc4dbc2f60c1a660584d}{isFull} ()
\item 
bool \hyperlink{classBackEnd_ae6ec007d68382eb124ed25bc90ae9c17}{isBlocked} ()
\item 
void \hyperlink{classBackEnd_aa9c46f45f491ef90a936c7e2b95f20aa}{rescheduleMemInst} (\hyperlink{classBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classBackEnd_ae165df775b4de9e9430228c7f04c2bc9}{replayMemInst} (\hyperlink{classBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classBackEnd_a2212f511dc1886c073cf7ff1665f5c87}{completeMemInst} (\hyperlink{classBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classBackEnd_a71dcc69e5b01fa12b8ccd2dccdcc9917}{fetchFault} (\hyperlink{classRefCountingPtr}{Fault} \&fault)
\item 
void \hyperlink{classBackEnd_a80587b4fe043bbe1995536cb3b361588}{dumpInsts} ()
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structBackEnd_1_1SizeStruct}{DispatchToIssue} $>$ \hyperlink{classBackEnd_ae446eaddd47d5f227ed00af24aaefe68}{d2i}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structBackEnd_1_1SizeStruct}{DispatchToIssue} $>$::wire \hyperlink{classBackEnd_ace1cd34be1eca99cb8c1d3a30e32fcbe}{instsToDispatch}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structBackEnd_1_1SizeStruct}{IssueToExec} $>$ \hyperlink{classBackEnd_a055203b013ada25d70a2a2c8b2364455}{i2e}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structBackEnd_1_1SizeStruct}{IssueToExec} $>$::wire \hyperlink{classBackEnd_a45c3ddf2275eab2326190578f1fcbee2}{instsToExecute}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structBackEnd_1_1SizeStruct}{ExecToCommit} $>$ \hyperlink{classBackEnd_a114248f83077c8e99f4f4aa0236aafeb}{e2c}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structBackEnd_1_1SizeStruct}{Writeback} $>$ \hyperlink{classBackEnd_a2647e2052851a9122ac4ce89b84d77b5}{numInstsToWB}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classBackEnd_a82fb3c7183ba777a05c510ab2fbcfb82}{CommStruct} $>$ $\ast$ \hyperlink{classBackEnd_a282f2307a986f183b83e887756561687}{comm}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classBackEnd_a82fb3c7183ba777a05c510ab2fbcfb82}{CommStruct} $>$::wire \hyperlink{classBackEnd_acf56450a952ce19a7cc68c86f0334c0c}{toIEW}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classBackEnd_a82fb3c7183ba777a05c510ab2fbcfb82}{CommStruct} $>$::wire \hyperlink{classBackEnd_a77bf6c956edddf1d551d5371ff72162e}{fromCommit}
\item 
bool \hyperlink{classBackEnd_ae3369c2288f4867553aaca811229bd3c}{tcSquash}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classBackEnd_af043d6103c5f173871f527899c41d2d2}{commitPC}
\item 
\hyperlink{classBackEnd_a90ba84e54618cc07f2e8f05e046cb5ce}{FullCPU} $\ast$ \hyperlink{classBackEnd_a766385c2941cd46525f4d9dff90200a2}{cpu}
\item 
\hyperlink{classFrontEnd}{FrontEnd} $\ast$ \hyperlink{classBackEnd_a67c762418bb2017cb2dce5a0c94f0788}{frontEnd}
\item 
\hyperlink{classThreadContext}{ThreadContext} $\ast$ \hyperlink{classBackEnd_a4455a4759e69e5ebe68ae7298cbcc37d}{tc}
\item 
\hyperlink{structOzoneThreadState}{Thread} $\ast$ \hyperlink{classBackEnd_a743989b66f3b52f1eda2a8498a93da0b}{thread}
\item 
\hyperlink{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \hyperlink{classBackEnd_ae29aa2d4ae440022daaed1107eb306b3}{status}
\item 
\hyperlink{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \hyperlink{classBackEnd_a245e3bace7ab490110304d56450aba64}{dispatchStatus}
\item 
\hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classBackEnd_a344acde4f72898017365be79fd18a323}{funcExeInst}
\item 
\hyperlink{classRenameTable}{RenameTable}$<$ Impl $>$ \hyperlink{classBackEnd_adbf41f9b1f8e58747002bd5f65f2ded9}{commitRenameTable}
\item 
\hyperlink{classRenameTable}{RenameTable}$<$ Impl $>$ \hyperlink{classBackEnd_af8d3f859e7c0dd9408ba99de6f415616}{renameTable}
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef Impl::LdstQueue \hyperlink{classBackEnd_a4c90230ea80fdcedea6e4fb9b43009cd}{LdstQueue}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$::iterator \hyperlink{classBackEnd_a4da46d72d68fcd5bfe65dc701c358379}{InstListIt}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classBackEnd_a1107d388cfcea92a9043608346ce98f0}{updateStructures} ()
\item 
void \hyperlink{classBackEnd_ac3f94deccc87588d728716efc4dd7ce8}{dispatchInsts} ()
\item 
void \hyperlink{classBackEnd_a3a69629e2b050560eb983bdedffc30ba}{dispatchStall} ()
\item 
void \hyperlink{classBackEnd_aee5c9997a61eb30564062dcdbda8c246}{checkDispatchStatus} ()
\item 
void \hyperlink{classBackEnd_a3694e72427d3a616808797f9343d1fc4}{scheduleReadyInsts} ()
\item 
void \hyperlink{classBackEnd_a2d00e30d66a56e4667e28df302c98ac0}{executeInsts} ()
\item 
void \hyperlink{classBackEnd_ac8b85fbfdf330d000c094a9d1886d264}{commitInsts} ()
\item 
void \hyperlink{classBackEnd_a2c7b6d036b77d997f9c6f718ddf0be7d}{addToIQ} (\hyperlink{classBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classBackEnd_a1b9c2184abc4f4e7a00285130f39bf26}{addToLSQ} (\hyperlink{classBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classBackEnd_a720e9865ffa6e84b756f5ec1d1a24d94}{instToCommit} (\hyperlink{classBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classBackEnd_a5e9a203f943b3a8a243ddc6d2a0a240d}{writebackInsts} ()
\item 
bool \hyperlink{classBackEnd_a300f33ed45badc3c856983b1b7469955}{commitInst} (int inst\_\-num)
\item 
void \hyperlink{classBackEnd_adc9b67ce59b0b2e930cfaf6361ce42c5}{squash} (const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&sn)
\item 
void \hyperlink{classBackEnd_a05c89a1532adb13cc0632fc3bb600add}{squashDueToBranch} (\hyperlink{classBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classBackEnd_a5fcf443dc6ada1ab1936df923c3205d2}{squashDueToMemBlocked} (\hyperlink{classBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classBackEnd_a132db67a5c42af856da64e347e8284d8}{updateExeInstStats} (\hyperlink{classBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classBackEnd_a5bbf266cb0cc97eed138c8fe0d2d76b6}{updateComInstStats} (\hyperlink{classBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classBackEnd_1_1InstQueue}{InstQueue} \hyperlink{classBackEnd_a9f8da5ee0decabae62161ec4c1738952}{IQ}
\item 
\hyperlink{classBackEnd_a4c90230ea80fdcedea6e4fb9b43009cd}{LdstQueue} \hyperlink{classBackEnd_a2d033f80e55d1123d747d40f026042aa}{LSQ}
\item 
\hyperlink{classBackEnd_1_1DCacheCompletionEvent}{DCacheCompletionEvent} \hyperlink{classBackEnd_a08f9ddeb55a0840fc2f9d8f4c5e7a9fc}{cacheCompletionEvent}
\item 
MemInterface $\ast$ \hyperlink{classBackEnd_a22dc8294eecb144fbdd951d2e32e9330}{dcacheInterface}
\item 
\hyperlink{classRequest}{Request} $\ast$ \hyperlink{classBackEnd_aeb76c16c8ed66ba50e2c29989814616d}{memReq}
\item 
int \hyperlink{classBackEnd_a2474a5474cbff19523a51eb1de01cda4}{width}
\item 
int \hyperlink{classBackEnd_aa304d4c426ea2bba52be0a3c0b9811e3}{dispatchWidth}
\item 
int \hyperlink{classBackEnd_a10a1f0f6ff8acbb26f4c308a502c6141}{numDispatchEntries}
\item 
int \hyperlink{classBackEnd_a32343e1e9e56c17bb868f861f9b8927d}{dispatchSize}
\item 
int \hyperlink{classBackEnd_a171bac1210be84c8811563ab35209fce}{issueWidth}
\item 
int \hyperlink{classBackEnd_a20d3086e6bcdc826d99143ac7c9b23a4}{wbWidth}
\item 
int \hyperlink{classBackEnd_a328db48cdab1c2a18d8432b647e2785b}{commitWidth}
\item 
unsigned \hyperlink{classBackEnd_a5fa0799bf5569437190dd1eda1d62b7b}{wbNumInst}
\item 
unsigned \hyperlink{classBackEnd_ad2c7b2687f864f2b7359eb393276996f}{wbCycle}
\item 
int \hyperlink{classBackEnd_ae40678133a160367f2207f07975ca0f3}{numROBEntries}
\item 
int \hyperlink{classBackEnd_a358c879c68910efe5300c4515df35b6c}{numInsts}
\item 
bool \hyperlink{classBackEnd_a2aafb6fc593b04986eeed845923a8953}{squashPending}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classBackEnd_a34292b1418c46ca63c892e7826510d77}{squashSeqNum}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classBackEnd_aabe0c73b4678ef858d3363c9bed18906}{squashNextPC}
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classBackEnd_a21a86a2f5f30b0f512909bdc8b2aae53}{faultFromFetch}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classBackEnd_ae10a391d02ce1ef67ee13cd82b7d46e5}{instList}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classBackEnd_a1e13c801cafc8d7e052b2f999c89ad85}{dispatch}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classBackEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classBackEnd_ae4b76f4612be07d13b349e13ee9dfa16}{writeback}
\item 
int \hyperlink{classBackEnd_a9c5bf07170b5d91cfb44d4bfd0517128}{latency}
\item 
int \hyperlink{classBackEnd_a440f8cda1481977c324a827c7c9f1e24}{squashLatency}
\item 
bool \hyperlink{classBackEnd_a319e9530b28153883e886be5b9c573eb}{exactFullStall}
\item 
bool \hyperlink{classBackEnd_aa40219506ff80e4e8c5a9a3b1205b282}{fetchRedirect} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a6480145c05acc370598e816e2e8cf879}{rob\_\-cap\_\-events}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a0eb2b00bb6b4dfa3e98d7a3c5c425c50}{rob\_\-cap\_\-inst\_\-count}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a94526617722efa24b56a33ac2e91a53d}{iq\_\-cap\_\-events}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_ab013e91b819cbfbaeb30f620eeb9af63}{iq\_\-cap\_\-inst\_\-count}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_afdd7841e13784687ccb7c432189dca2f}{exe\_\-inst}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a7d82b30a9bc5daa8a508aad6120df60a}{exe\_\-swp}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a16327b5e9165d27dc47c0bf44238cd74}{exe\_\-nop}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a9c0474dab97b001394a40aed972f827a}{exe\_\-refs}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a07f469c547d380cda882b5ca10fc8813}{exe\_\-loads}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a2bffb8fee3fa396523a2b86dba12a606}{exe\_\-branches}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_ad98215aa24a0390cc2ba2234f272cb17}{issued\_\-ops}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_afcc98cdfa47d5d6cfd8818f91dde0eb5}{lsq\_\-forw\_\-loads}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a032ab6d2dd14a8ccff4d407c7ff2a3d9}{inv\_\-addr\_\-loads}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a3814f636ed4028691262652be79c7091}{inv\_\-addr\_\-swpfs}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_afdabbae5f4752ae636610a296ce040e6}{lsq\_\-blocked\_\-loads}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBackEnd_abf96f4acba126fbcf919829a1125954c}{lsqInversion}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_aef7967289461e66d515723da65e1f9f7}{n\_\-issued\_\-dist}
\item 
\hyperlink{classStats_1_1VectorDistribution}{Stats::VectorDistribution} \hyperlink{classBackEnd_acbff26ed63b17948662f090985d17d32}{issue\_\-delay\_\-dist}
\item 
\hyperlink{classStats_1_1VectorDistribution}{Stats::VectorDistribution} \hyperlink{classBackEnd_a6737d38b89983fe331764c5c0edfbe12}{queue\_\-res\_\-dist}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a1b89675ac5b779ab9ead5ae5d3550189}{writeback\_\-count}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a47652a48ae1beac314831c224e026f24}{producer\_\-inst}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a5242b9d95c9537000e64dee2e5ac42cf}{consumer\_\-inst}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_adf6ccbeee5b1388f198d050e098df8d5}{wb\_\-penalized}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classBackEnd_ae3e32acce8acd38434b6efd36ea6198e}{wb\_\-rate}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classBackEnd_ac715c98888746617df195a858e4a13a4}{wb\_\-fanout}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classBackEnd_a3f801d7a68c69a6b19ef993fcbad1453}{wb\_\-penalized\_\-rate}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a3f56571c523bf46f2fe976188ad1e50c}{stat\_\-com\_\-inst}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a2c3ec644af0af2970d0066b987427b46}{stat\_\-com\_\-swp}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a541fdbe722e4ddbdcca7994625162235}{stat\_\-com\_\-refs}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a998922e22a0a08c55cf2f5ed99ad79cc}{stat\_\-com\_\-loads}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a2e29921a3b4c4ffb52ceef970898e906}{stat\_\-com\_\-membars}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a3368cb0b59cef9b4542f17661835022f}{stat\_\-com\_\-branches}
\item 
\hyperlink{classStats_1_1Distribution}{Stats::Distribution} \hyperlink{classBackEnd_adef6c140c8c63175c52b3bc6501f9d1c}{n\_\-committed\_\-dist}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBackEnd_accdcc276eadba243157fb68d08dd5cda}{commit\_\-eligible\_\-samples}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a3dd8a34217d79ba678222441cf275502}{commit\_\-eligible}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBackEnd_ac41e5b42959e2f75c51c9fec633e2491}{ROB\_\-fcount}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classBackEnd_a4e4aad30eb153b8d15da02cf33e57e9c}{ROB\_\-full\_\-rate}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBackEnd_a4ccaf3f968ca2c525ff6934f5dc202a4}{ROB\_\-count}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classBackEnd_ac6bfab47ea686c39b71e475aec8b07ca}{ROB\_\-occ\_\-rate}
\item 
\hyperlink{classStats_1_1VectorDistribution}{Stats::VectorDistribution} \hyperlink{classBackEnd_ace261e0da7b5ca53fcfc3a27782418c4}{ROB\_\-occ\_\-dist}
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classBackEnd_a27227be5511e316f17702a3a99fb0b98}{DCacheCompletionEvent}
\end{DoxyCompactItemize}
\subsubsection*{template$<$class Impl$>$ class BackEnd$<$ Impl $>$}



\subsection{型定義}
\hypertarget{classBackEnd_a82fb3c7183ba777a05c510ab2fbcfb82}{
\index{BackEnd@{BackEnd}!CommStruct@{CommStruct}}
\index{CommStruct@{CommStruct}!BackEnd@{BackEnd}}
\subsubsection[{CommStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::FullCPU::CommStruct {\bf CommStruct}}}
\label{classBackEnd_a82fb3c7183ba777a05c510ab2fbcfb82}
\hypertarget{classBackEnd_a99d236038ce57aa3ef78858228c5f972}{
\index{BackEnd@{BackEnd}!DispatchToIssue@{DispatchToIssue}}
\index{DispatchToIssue@{DispatchToIssue}!BackEnd@{BackEnd}}
\subsubsection[{DispatchToIssue}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf SizeStruct} {\bf DispatchToIssue}}}
\label{classBackEnd_a99d236038ce57aa3ef78858228c5f972}
\hypertarget{classBackEnd_ab741745c86a14c765b999c11167636d9}{
\index{BackEnd@{BackEnd}!DynInst@{DynInst}}
\index{DynInst@{DynInst}!BackEnd@{BackEnd}}
\subsubsection[{DynInst}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInst {\bf DynInst}}}
\label{classBackEnd_ab741745c86a14c765b999c11167636d9}
\hypertarget{classBackEnd_a028ce10889c5f6450239d9e9a7347976}{
\index{BackEnd@{BackEnd}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!BackEnd@{BackEnd}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInstPtr {\bf DynInstPtr}}}
\label{classBackEnd_a028ce10889c5f6450239d9e9a7347976}
\hypertarget{classBackEnd_a91ea582041466725b4b17ce19f98685f}{
\index{BackEnd@{BackEnd}!ExecToCommit@{ExecToCommit}}
\index{ExecToCommit@{ExecToCommit}!BackEnd@{BackEnd}}
\subsubsection[{ExecToCommit}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf SizeStruct} {\bf ExecToCommit}}}
\label{classBackEnd_a91ea582041466725b4b17ce19f98685f}
\hypertarget{classBackEnd_abe8e1d8243582d5024a1076f6091d9fe}{
\index{BackEnd@{BackEnd}!FrontEnd@{FrontEnd}}
\index{FrontEnd@{FrontEnd}!BackEnd@{BackEnd}}
\subsubsection[{FrontEnd}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::FrontEnd {\bf FrontEnd}}}
\label{classBackEnd_abe8e1d8243582d5024a1076f6091d9fe}
\hypertarget{classBackEnd_a90ba84e54618cc07f2e8f05e046cb5ce}{
\index{BackEnd@{BackEnd}!FullCPU@{FullCPU}}
\index{FullCPU@{FullCPU}!BackEnd@{BackEnd}}
\subsubsection[{FullCPU}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::FullCPU {\bf FullCPU}}}
\label{classBackEnd_a90ba84e54618cc07f2e8f05e046cb5ce}
\hypertarget{classBackEnd_a4da46d72d68fcd5bfe65dc701c358379}{
\index{BackEnd@{BackEnd}!InstListIt@{InstListIt}}
\index{InstListIt@{InstListIt}!BackEnd@{BackEnd}}
\subsubsection[{InstListIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf DynInstPtr}$>$::iterator {\bf InstListIt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a4da46d72d68fcd5bfe65dc701c358379}
\hypertarget{classBackEnd_a5badfe54e71b8fccb3d371013a8eef73}{
\index{BackEnd@{BackEnd}!IssueToExec@{IssueToExec}}
\index{IssueToExec@{IssueToExec}!BackEnd@{BackEnd}}
\subsubsection[{IssueToExec}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf SizeStruct} {\bf IssueToExec}}}
\label{classBackEnd_a5badfe54e71b8fccb3d371013a8eef73}
\hypertarget{classBackEnd_a4c90230ea80fdcedea6e4fb9b43009cd}{
\index{BackEnd@{BackEnd}!LdstQueue@{LdstQueue}}
\index{LdstQueue@{LdstQueue}!BackEnd@{BackEnd}}
\subsubsection[{LdstQueue}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::LdstQueue {\bf LdstQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a4c90230ea80fdcedea6e4fb9b43009cd}
\hypertarget{classBackEnd_a818e103eae798a24a06a0a34631849ea}{
\index{BackEnd@{BackEnd}!Params@{Params}}
\index{Params@{Params}!BackEnd@{BackEnd}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::Params {\bf Params}}}
\label{classBackEnd_a818e103eae798a24a06a0a34631849ea}
\hypertarget{classBackEnd_a9311aca87e8229ec3f7a7422ccbc9fbe}{
\index{BackEnd@{BackEnd}!Thread@{Thread}}
\index{Thread@{Thread}!BackEnd@{BackEnd}}
\subsubsection[{Thread}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf OzoneThreadState}$<$Impl$>$ {\bf Thread}}}
\label{classBackEnd_a9311aca87e8229ec3f7a7422ccbc9fbe}
\hypertarget{classBackEnd_a20d1fb15b536d49c687dee42d95c1a87}{
\index{BackEnd@{BackEnd}!Writeback@{Writeback}}
\index{Writeback@{Writeback}!BackEnd@{BackEnd}}
\subsubsection[{Writeback}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf SizeStruct} {\bf Writeback}}}
\label{classBackEnd_a20d1fb15b536d49c687dee42d95c1a87}


\subsection{列挙型}
\hypertarget{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}{
\index{BackEnd@{BackEnd}!Status@{Status}}
\index{Status@{Status}!BackEnd@{BackEnd}}
\subsubsection[{Status}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Status}}}
\label{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Running@{Running}!BackEnd@{BackEnd}}\index{BackEnd@{BackEnd}!Running@{Running}}\item[{\em 
\hypertarget{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}{
Running}
\label{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}
}]\index{Idle@{Idle}!BackEnd@{BackEnd}}\index{BackEnd@{BackEnd}!Idle@{Idle}}\item[{\em 
\hypertarget{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}{
Idle}
\label{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}
}]\index{DcacheMissStall@{DcacheMissStall}!BackEnd@{BackEnd}}\index{BackEnd@{BackEnd}!DcacheMissStall@{DcacheMissStall}}\item[{\em 
\hypertarget{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba4ba5ae5815b190bd652669e2fdea5ed7}{
DcacheMissStall}
\label{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba4ba5ae5815b190bd652669e2fdea5ed7}
}]\index{DcacheMissComplete@{DcacheMissComplete}!BackEnd@{BackEnd}}\index{BackEnd@{BackEnd}!DcacheMissComplete@{DcacheMissComplete}}\item[{\em 
\hypertarget{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba1eb81f4540c1c4b90839b08ae63c5d7f}{
DcacheMissComplete}
\label{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba1eb81f4540c1c4b90839b08ae63c5d7f}
}]\index{Blocked@{Blocked}!BackEnd@{BackEnd}}\index{BackEnd@{BackEnd}!Blocked@{Blocked}}\item[{\em 
\hypertarget{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba9463ee9b8700258a1019b4b9d2d77a30}{
Blocked}
\label{classBackEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba9463ee9b8700258a1019b4b9d2d77a30}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
276                 {
277         Running,
278         Idle,
279         DcacheMissStall,
280         DcacheMissComplete,
281         Blocked
282     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classBackEnd_a8698a618ba78dbd457f2cee79a739588}{
\index{BackEnd@{BackEnd}!BackEnd@{BackEnd}}
\index{BackEnd@{BackEnd}!BackEnd@{BackEnd}}
\subsubsection[{BackEnd}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BackEnd} ({\bf Params} $\ast$ {\em params})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_a8698a618ba78dbd457f2cee79a739588}



\begin{DoxyCode}
614     : d2i(5, 5), i2e(5, 5), e2c(5, 5), numInstsToWB(5, 5),
615       xcSquash(false), IQ(params),
616       cacheCompletionEvent(this), width(params->backEndWidth),
617       exactFullStall(true)
618 {
619     numROBEntries = params->numROBEntries;
620     numInsts = 0;
621     numDispatchEntries = 32;
622     IQ.setBE(this);
623     LSQ.setBE(this);
624 
625     // Setup IQ and LSQ with their parameters here.
626     instsToDispatch = d2i.getWire(-1);
627 
628     instsToExecute = i2e.getWire(-1);
629 
630     IQ.setIssueExecQueue(&i2e);
631 
632     dispatchWidth = params->dispatchWidth ? params->dispatchWidth : width;
633     issueWidth = params->issueWidth ? params->issueWidth : width;
634     wbWidth = params->wbWidth ? params->wbWidth : width;
635     commitWidth = params->commitWidth ? params->commitWidth : width;
636 
637     LSQ.init(params, params->LQEntries, params->SQEntries, 0);
638 
639     dispatchStatus = Running;
640 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classBackEnd_a2c7b6d036b77d997f9c6f718ddf0be7d}{
\index{BackEnd@{BackEnd}!addToIQ@{addToIQ}}
\index{addToIQ@{addToIQ}!BackEnd@{BackEnd}}
\subsubsection[{addToIQ}]{\setlength{\rightskip}{0pt plus 5cm}void addToIQ ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classBackEnd_a2c7b6d036b77d997f9c6f718ddf0be7d}



\begin{DoxyCode}
1031 {
1032     // Do anything IQ specific here?
1033     IQ.insert(inst);
1034 }
\end{DoxyCode}
\hypertarget{classBackEnd_a1b9c2184abc4f4e7a00285130f39bf26}{
\index{BackEnd@{BackEnd}!addToLSQ@{addToLSQ}}
\index{addToLSQ@{addToLSQ}!BackEnd@{BackEnd}}
\subsubsection[{addToLSQ}]{\setlength{\rightskip}{0pt plus 5cm}void addToLSQ ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classBackEnd_a1b9c2184abc4f4e7a00285130f39bf26}



\begin{DoxyCode}
1039 {
1040     // Do anything LSQ specific here?
1041     LSQ.insert(inst);
1042 }
\end{DoxyCode}
\hypertarget{classBackEnd_aee5c9997a61eb30564062dcdbda8c246}{
\index{BackEnd@{BackEnd}!checkDispatchStatus@{checkDispatchStatus}}
\index{checkDispatchStatus@{checkDispatchStatus}!BackEnd@{BackEnd}}
\subsubsection[{checkDispatchStatus}]{\setlength{\rightskip}{0pt plus 5cm}void checkDispatchStatus ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classBackEnd_aee5c9997a61eb30564062dcdbda8c246}



\begin{DoxyCode}
1170 {
1171     DPRINTF(BE, "Checking dispatch status\n");
1172     assert(dispatchStatus == Blocked);
1173     if (!IQ.isFull() && !LSQ.isFull() && !isFull()) {
1174         DPRINTF(BE, "Dispatch no longer blocked\n");
1175         dispatchStatus = Running;
1176         dispatchInsts();
1177     }
1178 }
\end{DoxyCode}
\hypertarget{classBackEnd_a300f33ed45badc3c856983b1b7469955}{
\index{BackEnd@{BackEnd}!commitInst@{commitInst}}
\index{commitInst@{commitInst}!BackEnd@{BackEnd}}
\subsubsection[{commitInst}]{\setlength{\rightskip}{0pt plus 5cm}bool commitInst (int {\em inst\_\-num})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classBackEnd_a300f33ed45badc3c856983b1b7469955}



\begin{DoxyCode}
1441 {
1442     // Read instruction from the head of the ROB
1443     DynInstPtr inst = instList.front();
1444 
1445     // Make sure instruction is valid
1446     assert(inst);
1447 
1448     if (!inst->readyToCommit())
1449         return false;
1450 
1451     DPRINTF(BE, "Trying to commit instruction [sn:%lli] PC:%#x\n",
1452             inst->seqNum, inst->readPC());
1453 
1454     // If the instruction is not executed yet, then it is a non-speculative
1455     // or store inst.  Signal backwards that it should be executed.
1456     if (!inst->isExecuted()) {
1457         // Keep this number correct.  We have not yet actually executed
1458         // and committed this instruction.
1459 //        thread->funcExeInst--;
1460 
1461         if (inst->isNonSpeculative()) {
1462             // Hack to make sure syscalls aren't executed until all stores
1463             // write back their data.  This direct communication shouldn't
1464             // be used for anything other than this.
1465             if (inst_num > 0 || LSQ.hasStoresToWB()) {
1466                 DPRINTF(BE, "Waiting for all stores to writeback.\n");
1467                 return false;
1468             }
1469 
1470             DPRINTF(BE, "Encountered a store or non-speculative "
1471                     "instruction at the head of the ROB, PC %#x.\n",
1472                     inst->readPC());
1473 
1474             // Send back the non-speculative instruction's sequence number.
1475             toIEW->nonSpecSeqNum = inst->seqNum;
1476 
1477             // Change the instruction so it won't try to commit again until
1478             // it is executed.
1479             inst->clearCanCommit();
1480 
1481 //            ++commitNonSpecStalls;
1482 
1483             return false;
1484         } else if (inst->isLoad()) {
1485             DPRINTF(BE, "[sn:%lli]: Uncached load, PC %#x.\n",
1486                     inst->seqNum, inst->readPC());
1487 
1488             // Send back the non-speculative instruction's sequence
1489             // number.  Maybe just tell the lsq to re-execute the load.
1490             toIEW->nonSpecSeqNum = inst->seqNum;
1491             toIEW->uncached = true;
1492             toIEW->lqIdx = inst->lqIdx;
1493 
1494             inst->clearCanCommit();
1495 
1496             return false;
1497         } else {
1498             panic("Trying to commit un-executed instruction "
1499                   "of unknown type!\n");
1500         }
1501     }
1502 
1503     // Now check if it's one of the special trap or barrier or
1504     // serializing instructions.
1505     if (inst->isThreadSync())
1506     {
1507         // Not handled for now.
1508         panic("Barrier instructions are not handled yet.\n");
1509     }
1510 
1511     // Check if the instruction caused a fault.  If so, trap.
1512     Fault inst_fault = inst->getFault();
1513 
1514     if (inst_fault != NoFault) {
1515         if (!inst->isNop()) {
1516             DPRINTF(BE, "Inst [sn:%lli] PC %#x has a fault\n",
1517                     inst->seqNum, inst->readPC());
1518 
1519 //            assert(!thread->noSquashFromTC);
1520 
1521 //            thread->noSquashFromTC = true;
1522 
1523             // Consider holding onto the trap and waiting until the trap event
1524             // happens for this to be executed.
1525             inst_fault->invoke(thread->getXCProxy());
1526 
1527             // Exit state update mode to avoid accidental updating.
1528 //            thread->noSquashFromTC = false;
1529 
1530 //            commitStatus = TrapPending;
1531 
1532             // Generate trap squash event.
1533 //            generateTrapEvent();
1534 
1535             return false;
1536         }
1537     }
1538 
1539     if (inst->isControl()) {
1540 //        ++commitCommittedBranches;
1541     }
1542 
1543     int freed_regs = 0;
1544 
1545     for (int i = 0; i < inst->numDestRegs(); ++i) {
1546         DPRINTF(BE, "Commit rename map setting register %i to [sn:%lli]\n",
1547                 (int)inst->destRegIdx(i), inst->seqNum);
1548         thread->renameTable[inst->destRegIdx(i)] = inst;
1549         ++freed_regs;
1550     }
1551 
1552     if (inst->traceData) {
1553         inst->traceData->finalize();
1554         inst->traceData = NULL;
1555     }
1556 
1557     inst->clearDependents();
1558 
1559     frontEnd->addFreeRegs(freed_regs);
1560 
1561     instList.pop_front();
1562 
1563     --numInsts;
1564     cpu->numInst++;
1565     thread->numInsts++;
1566     ++thread->funcExeInst;
1567     thread->PC = inst->readNextPC();
1568     updateComInstStats(inst);
1569 
1570     // Write the done sequence number here.
1571     toIEW->doneSeqNum = inst->seqNum;
1572 
1573     int count = 0;
1574     Addr oldpc;
1575     do {
1576         if (count == 0)
1577             assert(!thread->noSquashFromTC && !thread->trapPending);
1578         oldpc = thread->readPC();
1579         cpu->system->pcEventQueue.service(
1580             thread->getXCProxy());
1581         count++;
1582     } while (oldpc != thread->readPC());
1583     if (count > 1) {
1584         DPRINTF(BE, "PC skip function event, stopping commit\n");
1585 //        completed_last_inst = false;
1586 //        squashPending = true;
1587         return false;
1588     }
1589     return true;
1590 }
\end{DoxyCode}
\hypertarget{classBackEnd_ac8b85fbfdf330d000c094a9d1886d264}{
\index{BackEnd@{BackEnd}!commitInsts@{commitInsts}}
\index{commitInsts@{commitInsts}!BackEnd@{BackEnd}}
\subsubsection[{commitInsts}]{\setlength{\rightskip}{0pt plus 5cm}void commitInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classBackEnd_ac8b85fbfdf330d000c094a9d1886d264}



\begin{DoxyCode}
1595 {
1596     int commit_width = commitWidth ? commitWidth : width;
1597 
1598     // Not sure this should be a loop or not.
1599     int inst_num = 0;
1600     while (!instList.empty() && inst_num < commit_width) {
1601         if (instList.front()->isSquashed()) {
1602             panic("No squashed insts should still be on the list!");
1603             instList.front()->clearDependents();
1604             instList.pop_front();
1605             continue;
1606         }
1607 
1608         if (!commitInst(inst_num++)) {
1609             break;
1610         }
1611     }
1612     n_committed_dist.sample(inst_num);
1613 }
\end{DoxyCode}
\hypertarget{classBackEnd_a2212f511dc1886c073cf7ff1665f5c87}{
\index{BackEnd@{BackEnd}!completeMemInst@{completeMemInst}}
\index{completeMemInst@{completeMemInst}!BackEnd@{BackEnd}}
\subsubsection[{completeMemInst}]{\setlength{\rightskip}{0pt plus 5cm}void completeMemInst ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_a2212f511dc1886c073cf7ff1665f5c87}
Completes memory instruction. 


\begin{DoxyCode}
244     { IQ.completeMemInst(inst); }
\end{DoxyCode}
\hypertarget{classBackEnd_ac3f94deccc87588d728716efc4dd7ce8}{
\index{BackEnd@{BackEnd}!dispatchInsts@{dispatchInsts}}
\index{dispatchInsts@{dispatchInsts}!BackEnd@{BackEnd}}
\subsubsection[{dispatchInsts}]{\setlength{\rightskip}{0pt plus 5cm}void dispatchInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classBackEnd_ac3f94deccc87588d728716efc4dd7ce8}



\begin{DoxyCode}
1047 {
1048     DPRINTF(BE, "Trying to dispatch instructions.\n");
1049 
1050     // Pull instructions out of the front end.
1051     int disp_width = dispatchWidth ? dispatchWidth : width;
1052 
1053     // Could model dispatching time, but in general 1 cycle is probably
1054     // good enough.
1055 
1056     if (dispatchSize < numDispatchEntries) {
1057         for (int i = 0; i < disp_width; i++) {
1058             // Get instructions
1059             DynInstPtr inst = frontEnd->getInst();
1060 
1061             if (!inst) {
1062                 // No more instructions to get
1063                 break;
1064             }
1065 
1066             DPRINTF(BE, "Processing instruction [sn:%lli] PC:%#x\n",
1067                     inst->seqNum, inst->readPC());
1068 
1069             for (int i = 0; i < inst->numDestRegs(); ++i)
1070                 renameTable[inst->destRegIdx(i)] = inst;
1071 
1072             // Add to queue to be dispatched.
1073             dispatch.push_back(inst);
1074 
1075             d2i[0].size++;
1076             ++dispatchSize;
1077         }
1078     }
1079 
1080     assert(dispatch.size() < 64);
1081 
1082     for (int i = 0; i < instsToDispatch->size; ++i) {
1083         assert(!dispatch.empty());
1084         // Get instruction from front of time buffer
1085         DynInstPtr inst = dispatch.front();
1086         dispatch.pop_front();
1087         --dispatchSize;
1088 
1089         if (inst->isSquashed())
1090             continue;
1091 
1092         ++numInsts;
1093         instList.push_back(inst);
1094 
1095         DPRINTF(BE, "Dispatching instruction [sn:%lli] PC:%#x\n",
1096                 inst->seqNum, inst->readPC());
1097 
1098         addToIQ(inst);
1099 
1100         if (inst->isMemRef()) {
1101             addToLSQ(inst);
1102         }
1103 
1104         if (inst->isNonSpeculative()) {
1105             inst->setCanCommit();
1106         }
1107 
1108         // Check if IQ or LSQ is full.  If so we'll need to break and stop
1109         // removing instructions.  Also update the number of insts to remove
1110         // from the queue.
1111         if (exactFullStall) {
1112             bool stall = false;
1113             if (IQ.isFull()) {
1114                 DPRINTF(BE, "IQ is full!\n");
1115                 stall = true;
1116             } else if (LSQ.isFull()) {
1117                 DPRINTF(BE, "LSQ is full!\n");
1118                 stall = true;
1119             } else if (isFull()) {
1120                 DPRINTF(BE, "ROB is full!\n");
1121                 stall = true;
1122                 ROB_fcount++;
1123             }
1124             if (stall) {
1125                 instsToDispatch->size-= i+1;
1126                 dispatchStall();
1127                 return;
1128             }
1129         }
1130     }
1131 
1132     // Check if IQ or LSQ is full.  If so we'll need to break and stop
1133     // removing instructions.  Also update the number of insts to remove
1134     // from the queue.  Check here if we don't care about exact stall
1135     // conditions.
1136 
1137     bool stall = false;
1138     if (IQ.isFull()) {
1139         DPRINTF(BE, "IQ is full!\n");
1140         stall = true;
1141     } else if (LSQ.isFull()) {
1142         DPRINTF(BE, "LSQ is full!\n");
1143         stall = true;
1144     } else if (isFull()) {
1145         DPRINTF(BE, "ROB is full!\n");
1146         stall = true;
1147         ROB_fcount++;
1148     }
1149     if (stall) {
1150         d2i.advance();
1151         dispatchStall();
1152         return;
1153     }
1154 }
\end{DoxyCode}
\hypertarget{classBackEnd_a3a69629e2b050560eb983bdedffc30ba}{
\index{BackEnd@{BackEnd}!dispatchStall@{dispatchStall}}
\index{dispatchStall@{dispatchStall}!BackEnd@{BackEnd}}
\subsubsection[{dispatchStall}]{\setlength{\rightskip}{0pt plus 5cm}void dispatchStall ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classBackEnd_a3a69629e2b050560eb983bdedffc30ba}



\begin{DoxyCode}
1159 {
1160     dispatchStatus = Blocked;
1161     if (!cpu->decoupledFrontEnd) {
1162         // Tell front end to stall here through a timebuffer, or just tell
1163         // it directly.
1164     }
1165 }
\end{DoxyCode}
\hypertarget{classBackEnd_a80587b4fe043bbe1995536cb3b361588}{
\index{BackEnd@{BackEnd}!dumpInsts@{dumpInsts}}
\index{dumpInsts@{dumpInsts}!BackEnd@{BackEnd}}
\subsubsection[{dumpInsts}]{\setlength{\rightskip}{0pt plus 5cm}void dumpInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_a80587b4fe043bbe1995536cb3b361588}



\begin{DoxyCode}
1797 {
1798     int num = 0;
1799     int valid_num = 0;
1800 
1801     InstListIt inst_list_it = instList.begin();
1802 
1803     cprintf("Inst list size: %i\n", instList.size());
1804 
1805     while (inst_list_it != instList.end())
1806     {
1807         cprintf("Instruction:%i\n",
1808                 num);
1809         if (!(*inst_list_it)->isSquashed()) {
1810             if (!(*inst_list_it)->isIssued()) {
1811                 ++valid_num;
1812                 cprintf("Count:%i\n", valid_num);
1813             } else if ((*inst_list_it)->isMemRef() &&
1814                        !(*inst_list_it)->memOpDone) {
1815                 // Loads that have not been marked as executed still count
1816                 // towards the total instructions.
1817                 ++valid_num;
1818                 cprintf("Count:%i\n", valid_num);
1819             }
1820         }
1821 
1822         cprintf("PC:%#x\n[sn:%lli]\n[tid:%i]\n"
1823                 "Issued:%i\nSquashed:%i\n",
1824                 (*inst_list_it)->readPC(),
1825                 (*inst_list_it)->seqNum,
1826                 (*inst_list_it)->threadNumber,
1827                 (*inst_list_it)->isIssued(),
1828                 (*inst_list_it)->isSquashed());
1829 
1830         if ((*inst_list_it)->isMemRef()) {
1831             cprintf("MemOpDone:%i\n", (*inst_list_it)->memOpDone);
1832         }
1833 
1834         cprintf("\n");
1835 
1836         inst_list_it++;
1837         ++num;
1838     }
1839 
1840     cprintf("Dispatch list size: %i\n", dispatch.size());
1841 
1842     inst_list_it = dispatch.begin();
1843 
1844     while (inst_list_it != dispatch.end())
1845     {
1846         cprintf("Instruction:%i\n",
1847                 num);
1848         if (!(*inst_list_it)->isSquashed()) {
1849             if (!(*inst_list_it)->isIssued()) {
1850                 ++valid_num;
1851                 cprintf("Count:%i\n", valid_num);
1852             } else if ((*inst_list_it)->isMemRef() &&
1853                        !(*inst_list_it)->memOpDone) {
1854                 // Loads that have not been marked as executed still count
1855                 // towards the total instructions.
1856                 ++valid_num;
1857                 cprintf("Count:%i\n", valid_num);
1858             }
1859         }
1860 
1861         cprintf("PC:%#x\n[sn:%lli]\n[tid:%i]\n"
1862                 "Issued:%i\nSquashed:%i\n",
1863                 (*inst_list_it)->readPC(),
1864                 (*inst_list_it)->seqNum,
1865                 (*inst_list_it)->threadNumber,
1866                 (*inst_list_it)->isIssued(),
1867                 (*inst_list_it)->isSquashed());
1868 
1869         if ((*inst_list_it)->isMemRef()) {
1870             cprintf("MemOpDone:%i\n", (*inst_list_it)->memOpDone);
1871         }
1872 
1873         cprintf("\n");
1874 
1875         inst_list_it++;
1876         ++num;
1877     }
1878 
1879     cprintf("Writeback list size: %i\n", writeback.size());
1880 
1881     inst_list_it = writeback.begin();
1882 
1883     while (inst_list_it != writeback.end())
1884     {
1885         cprintf("Instruction:%i\n",
1886                 num);
1887         if (!(*inst_list_it)->isSquashed()) {
1888             if (!(*inst_list_it)->isIssued()) {
1889                 ++valid_num;
1890                 cprintf("Count:%i\n", valid_num);
1891             } else if ((*inst_list_it)->isMemRef() &&
1892                        !(*inst_list_it)->memOpDone) {
1893                 // Loads that have not been marked as executed still count
1894                 // towards the total instructions.
1895                 ++valid_num;
1896                 cprintf("Count:%i\n", valid_num);
1897             }
1898         }
1899 
1900         cprintf("PC:%#x\n[sn:%lli]\n[tid:%i]\n"
1901                 "Issued:%i\nSquashed:%i\n",
1902                 (*inst_list_it)->readPC(),
1903                 (*inst_list_it)->seqNum,
1904                 (*inst_list_it)->threadNumber,
1905                 (*inst_list_it)->isIssued(),
1906                 (*inst_list_it)->isSquashed());
1907 
1908         if ((*inst_list_it)->isMemRef()) {
1909             cprintf("MemOpDone:%i\n", (*inst_list_it)->memOpDone);
1910         }
1911 
1912         cprintf("\n");
1913 
1914         inst_list_it++;
1915         ++num;
1916     }
1917 }
\end{DoxyCode}
\hypertarget{classBackEnd_a2d00e30d66a56e4667e28df302c98ac0}{
\index{BackEnd@{BackEnd}!executeInsts@{executeInsts}}
\index{executeInsts@{executeInsts}!BackEnd@{BackEnd}}
\subsubsection[{executeInsts}]{\setlength{\rightskip}{0pt plus 5cm}void executeInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classBackEnd_a2d00e30d66a56e4667e28df302c98ac0}



\begin{DoxyCode}
1196 {
1197     int insts_to_execute = instsToExecute->size;
1198 
1199     issued_ops[0]+= insts_to_execute;
1200     n_issued_dist[insts_to_execute]++;
1201 
1202     DPRINTF(BE, "Trying to execute %i instructions\n", insts_to_execute);
1203 
1204     fetchRedirect[0] = false;
1205 
1206     while (insts_to_execute > 0) {
1207         // Get ready instruction from the IQ (or queue coming out of IQ)
1208         // Execute the ready instruction.
1209         // Wakeup any dependents if it's done.
1210         DynInstPtr inst = IQ.getReadyInst();
1211 
1212         DPRINTF(BE, "Executing inst [sn:%lli] PC: %#x\n",
1213                 inst->seqNum, inst->readPC());
1214 
1215         ++funcExeInst;
1216 
1217         // Check if the instruction is squashed; if so then skip it
1218         // and don't count it towards the FU usage.
1219         if (inst->isSquashed()) {
1220             DPRINTF(BE, "Execute: Instruction was squashed.\n");
1221 
1222             // Not sure how to handle this plus the method of sending # of
1223             // instructions to use.  Probably will just have to count it
1224             // towards the bandwidth usage, but not the FU usage.
1225             --insts_to_execute;
1226 
1227             // Consider this instruction executed so that commit can go
1228             // ahead and retire the instruction.
1229             inst->setExecuted();
1230 
1231             // Not sure if I should set this here or just let commit try to
1232             // commit any squashed instructions.  I like the latter a bit more.
1233             inst->setCanCommit();
1234 
1235 //            ++iewExecSquashedInsts;
1236 
1237             continue;
1238         }
1239 
1240         Fault fault = NoFault;
1241 
1242         // Execute instruction.
1243         // Note that if the instruction faults, it will be handled
1244         // at the commit stage.
1245         if (inst->isMemRef() &&
1246             (!inst->isDataPrefetch() && !inst->isInstPrefetch())) {
1247             DPRINTF(BE, "Execute: Initiating access for memory "
1248                     "reference.\n");
1249 
1250             // Tell the LDSTQ to execute this instruction (if it is a load).
1251             if (inst->isLoad()) {
1252                 // Loads will mark themselves as executed, and their writeback
1253                 // event adds the instruction to the queue to commit
1254                 fault = LSQ.executeLoad(inst);
1255 
1256 //                ++iewExecLoadInsts;
1257             } else if (inst->isStore()) {
1258                 LSQ.executeStore(inst);
1259 
1260 //                ++iewExecStoreInsts;
1261 
1262                 if (!(inst->req->isLLSC())) {
1263                     inst->setExecuted();
1264 
1265                     instToCommit(inst);
1266                 }
1267                 // Store conditionals will mark themselves as executed, and
1268                 // their writeback event will add the instruction to the queue
1269                 // to commit.
1270             } else {
1271                 panic("Unexpected memory type!\n");
1272             }
1273 
1274         } else {
1275             inst->execute();
1276 
1277 //            ++iewExecutedInsts;
1278 
1279             inst->setExecuted();
1280 
1281             instToCommit(inst);
1282         }
1283 
1284         updateExeInstStats(inst);
1285 
1286         // Probably should have some sort of function for this.
1287         // More general question of how to handle squashes?  Have some sort of
1288         // squash unit that controls it?  Probably...
1289         // Check if branch was correct.  This check happens after the
1290         // instruction is added to the queue because even if the branch
1291         // is mispredicted, the branch instruction itself is still valid.
1292         // Only handle this if there hasn't already been something that
1293         // redirects fetch in this group of instructions.
1294 
1295         // This probably needs to prioritize the redirects if a different
1296         // scheduler is used.  Currently the scheduler schedules the oldest
1297         // instruction first, so the branch resolution order will be correct.
1298         ThreadID tid = inst->threadNumber;
1299 
1300         if (!fetchRedirect[tid]) {
1301 
1302             if (inst->mispredicted()) {
1303                 fetchRedirect[tid] = true;
1304 
1305                 DPRINTF(BE, "Execute: Branch mispredict detected.\n");
1306                 DPRINTF(BE, "Execute: Redirecting fetch to PC: %#x.\n",
1307                         inst->nextPC);
1308 
1309                 // If incorrect, then signal the ROB that it must be squashed.
1310                 squashDueToBranch(inst);
1311 
1312                 if (inst->predTaken()) {
1313 //                    predictedTakenIncorrect++;
1314                 } else {
1315 //                    predictedNotTakenIncorrect++;
1316                 }
1317             } else if (LSQ.violation()) {
1318                 fetchRedirect[tid] = true;
1319 
1320                 // Get the DynInst that caused the violation.  Note that this
1321                 // clears the violation signal.
1322                 DynInstPtr violator;
1323                 violator = LSQ.getMemDepViolator();
1324 
1325                 DPRINTF(BE, "LDSTQ detected a violation.  Violator PC: "
1326                         "%#x, inst PC: %#x.  Addr is: %#x.\n",
1327                         violator->readPC(), inst->readPC(), inst->physEffAddr);
1328 
1329                 // Tell the instruction queue that a violation has occured.
1330 //                IQ.violation(inst, violator);
1331 
1332                 // Squash.
1333 //                squashDueToMemOrder(inst,tid);
1334                 squashDueToBranch(inst);
1335 
1336 //                ++memOrderViolationEvents;
1337             } else if (LSQ.loadBlocked()) {
1338                 fetchRedirect[tid] = true;
1339 
1340                 DPRINTF(BE, "Load operation couldn't execute because the "
1341                         "memory system is blocked.  PC: %#x [sn:%lli]\n",
1342                         inst->readPC(), inst->seqNum);
1343 
1344                 squashDueToMemBlocked(inst);
1345             }
1346         }
1347 
1348 //        instList.pop_front();
1349 
1350         --insts_to_execute;
1351 
1352         // keep an instruction count
1353         thread->numInst++;
1354         thread->numInsts++;
1355     }
1356 
1357     assert(insts_to_execute >= 0);
1358 }
\end{DoxyCode}
\hypertarget{classBackEnd_a71dcc69e5b01fa12b8ccd2dccdcc9917}{
\index{BackEnd@{BackEnd}!fetchFault@{fetchFault}}
\index{fetchFault@{fetchFault}!BackEnd@{BackEnd}}
\subsubsection[{fetchFault}]{\setlength{\rightskip}{0pt plus 5cm}void fetchFault ({\bf Fault} \& {\em fault})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_a71dcc69e5b01fa12b8ccd2dccdcc9917}



\begin{DoxyCode}
1724 {
1725     faultFromFetch = fault;
1726 }
\end{DoxyCode}
\hypertarget{classBackEnd_a720e9865ffa6e84b756f5ec1d1a24d94}{
\index{BackEnd@{BackEnd}!instToCommit@{instToCommit}}
\index{instToCommit@{instToCommit}!BackEnd@{BackEnd}}
\subsubsection[{instToCommit}]{\setlength{\rightskip}{0pt plus 5cm}void instToCommit ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classBackEnd_a720e9865ffa6e84b756f5ec1d1a24d94}



\begin{DoxyCode}
1363 {
1364     int wb_width = wbWidth;
1365     // First check the time slot that this instruction will write
1366     // to.  If there are free write ports at the time, then go ahead
1367     // and write the instruction to that time.  If there are not,
1368     // keep looking back to see where's the first time there's a
1369     // free slot.  What happens if you run out of free spaces?
1370     // For now naively assume that all instructions take one cycle.
1371     // Otherwise would have to look into the time buffer based on the
1372     // latency of the instruction.
1373 
1374     DPRINTF(BE, "Sending instructions to commit [sn:%lli] PC %#x.\n",
1375             inst->seqNum, inst->readPC());
1376 
1377     while (numInstsToWB[wbCycle].size >= wb_width) {
1378         ++wbCycle;
1379 
1380         assert(wbCycle < 5);
1381     }
1382 
1383     // Add finished instruction to queue to commit.
1384     writeback.push_back(inst);
1385     numInstsToWB[wbCycle].size++;
1386 
1387     if (wbCycle)
1388         wb_penalized[0]++;
1389 }
\end{DoxyCode}
\hypertarget{classBackEnd_ae6ec007d68382eb124ed25bc90ae9c17}{
\index{BackEnd@{BackEnd}!isBlocked@{isBlocked}}
\index{isBlocked@{isBlocked}!BackEnd@{BackEnd}}
\subsubsection[{isBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool isBlocked ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_ae6ec007d68382eb124ed25bc90ae9c17}



\begin{DoxyCode}
230 { return status == Blocked || dispatchStatus == Blocked; }
\end{DoxyCode}
\hypertarget{classBackEnd_a3e70330939fdfc4dbc2f60c1a660584d}{
\index{BackEnd@{BackEnd}!isFull@{isFull}}
\index{isFull@{isFull}!BackEnd@{BackEnd}}
\subsubsection[{isFull}]{\setlength{\rightskip}{0pt plus 5cm}bool isFull ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_a3e70330939fdfc4dbc2f60c1a660584d}



\begin{DoxyCode}
229 { return numInsts >= numROBEntries; }
\end{DoxyCode}
\hypertarget{classBackEnd_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{BackEnd@{BackEnd}!name@{name}}
\index{name@{name}!BackEnd@{BackEnd}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_a37627d5d5bba7f4a8690c71c2ab3cb07}



\begin{DoxyCode}
645 {
646     return cpu->name() + ".backend";
647 }
\end{DoxyCode}
\hypertarget{classBackEnd_a0747777ac998dabdc20fa0c554d378d3}{
\index{BackEnd@{BackEnd}!read@{read}}
\index{read@{read}!BackEnd@{BackEnd}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} read ({\bf RequestPtr} {\em req}, \/  T \& {\em data}, \/  int {\em load\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_a0747777ac998dabdc20fa0c554d378d3}



\begin{DoxyCode}
461 {
462 /*    memReq->reset(addr, sizeof(T), flags);
463 
464     // translate to physical address
465     Fault fault = cpu->translateDataReadReq(memReq);
466 
467     // if we have a cache, do cache access too
468     if (fault == NoFault && dcacheInterface) {
469         memReq->cmd = Read;
470         memReq->completionEvent = NULL;
471         memReq->time = curTick();
472         memReq->flags &= ~INST_READ;
473         MemAccessResult result = dcacheInterface->access(memReq);
474 
475         // Ugly hack to get an event scheduled *only* if the access is
476         // a miss.  We really should add first-class support for this
477         // at some point.
478         if (result != MA_HIT && dcacheInterface->doEvents()) {
479             // Fix this hack for keeping funcExeInst correct with loads that
480             // are executed twice.
481             --funcExeInst;
482 
483             memReq->completionEvent = &cacheCompletionEvent;
484             lastDcacheStall = curTick();
485 //          unscheduleTickEvent();
486 //          status = DcacheMissStall;
487             DPRINTF(OzoneCPU, "Dcache miss stall!\n");
488         } else {
489             // do functional access
490             fault = thread->mem->read(memReq, data);
491 
492         }
493     }
494 */
495     return LSQ.read(req, data, load_idx);
496 }
\end{DoxyCode}
\hypertarget{classBackEnd_aa28f3fe58fde4b038a92b9f87a40cb10}{
\index{BackEnd@{BackEnd}!readCommitPC@{readCommitPC}}
\index{readCommitPC@{readCommitPC}!BackEnd@{BackEnd}}
\subsubsection[{readCommitPC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} readCommitPC ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_aa28f3fe58fde4b038a92b9f87a40cb10}



\begin{DoxyCode}
223 { return commitPC; }
\end{DoxyCode}
\hypertarget{classBackEnd_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{BackEnd@{BackEnd}!regStats@{regStats}}
\index{regStats@{regStats}!BackEnd@{BackEnd}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_a4dc637449366fcdfc4e764cdf12d9b11}



\begin{DoxyCode}
652 {
653     using namespace Stats;
654     rob_cap_events
655         .init(cpu->numThreads)
656         .name(name() + ".ROB:cap_events")
657         .desc("number of cycles where ROB cap was active")
658         .flags(total)
659         ;
660 
661     rob_cap_inst_count
662         .init(cpu->numThreads)
663         .name(name() + ".ROB:cap_inst")
664         .desc("number of instructions held up by ROB cap")
665         .flags(total)
666         ;
667 
668     iq_cap_events
669         .init(cpu->numThreads)
670         .name(name() +".IQ:cap_events" )
671         .desc("number of cycles where IQ cap was active")
672         .flags(total)
673         ;
674 
675     iq_cap_inst_count
676         .init(cpu->numThreads)
677         .name(name() + ".IQ:cap_inst")
678         .desc("number of instructions held up by IQ cap")
679         .flags(total)
680         ;
681 
682 
683     exe_inst
684         .init(cpu->numThreads)
685         .name(name() + ".ISSUE:count")
686         .desc("number of insts issued")
687         .flags(total)
688         ;
689 
690     exe_swp
691         .init(cpu->numThreads)
692         .name(name() + ".ISSUE:swp")
693         .desc("number of swp insts issued")
694         .flags(total)
695         ;
696 
697     exe_nop
698         .init(cpu->numThreads)
699         .name(name() + ".ISSUE:nop")
700         .desc("number of nop insts issued")
701         .flags(total)
702         ;
703 
704     exe_refs
705         .init(cpu->numThreads)
706         .name(name() + ".ISSUE:refs")
707         .desc("number of memory reference insts issued")
708         .flags(total)
709         ;
710 
711     exe_loads
712         .init(cpu->numThreads)
713         .name(name() + ".ISSUE:loads")
714         .desc("number of load insts issued")
715         .flags(total)
716         ;
717 
718     exe_branches
719         .init(cpu->numThreads)
720         .name(name() + ".ISSUE:branches")
721         .desc("Number of branches issued")
722         .flags(total)
723         ;
724 
725     issued_ops
726         .init(cpu->numThreads)
727         .name(name() + ".ISSUE:op_count")
728         .desc("number of insts issued")
729         .flags(total)
730         ;
731 
732 /*
733     for (int i=0; i<Num_OpClasses; ++i) {
734         stringstream subname;
735         subname << opClassStrings[i] << "_delay";
736         issue_delay_dist.subname(i, subname.str());
737     }
738 */
739     //
740     //  Other stats
741     //
742     lsq_forw_loads
743         .init(cpu->numThreads)
744         .name(name() + ".LSQ:forw_loads")
745         .desc("number of loads forwarded via LSQ")
746         .flags(total)
747         ;
748 
749     inv_addr_loads
750         .init(cpu->numThreads)
751         .name(name() + ".ISSUE:addr_loads")
752         .desc("number of invalid-address loads")
753         .flags(total)
754         ;
755 
756     inv_addr_swpfs
757         .init(cpu->numThreads)
758         .name(name() + ".ISSUE:addr_swpfs")
759         .desc("number of invalid-address SW prefetches")
760         .flags(total)
761         ;
762 
763     lsq_blocked_loads
764         .init(cpu->numThreads)
765         .name(name() + ".LSQ:blocked_loads")
766         .desc("number of ready loads not issued due to memory disambiguation")
767         .flags(total)
768         ;
769 
770     lsqInversion
771         .name(name() + ".ISSUE:lsq_invert")
772         .desc("Number of times LSQ instruction issued early")
773         ;
774 
775     n_issued_dist
776         .init(issueWidth + 1)
777         .name(name() + ".ISSUE:issued_per_cycle")
778         .desc("Number of insts issued each cycle")
779         .flags(total | pdf | dist)
780         ;
781     issue_delay_dist
782         .init(Num_OpClasses,0,99,2)
783         .name(name() + ".ISSUE:")
784         .desc("cycles from operands ready to issue")
785         .flags(pdf | cdf)
786         ;
787 
788     queue_res_dist
789         .init(Num_OpClasses, 0, 99, 2)
790         .name(name() + ".IQ:residence:")
791         .desc("cycles from dispatch to issue")
792         .flags(total | pdf | cdf )
793         ;
794     for (int i = 0; i < Num_OpClasses; ++i) {
795         queue_res_dist.subname(i, opClassStrings[i]);
796     }
797 
798     writeback_count
799         .init(cpu->numThreads)
800         .name(name() + ".WB:count")
801         .desc("cumulative count of insts written-back")
802         .flags(total)
803         ;
804 
805     producer_inst
806         .init(cpu->numThreads)
807         .name(name() + ".WB:producers")
808         .desc("num instructions producing a value")
809         .flags(total)
810         ;
811 
812     consumer_inst
813         .init(cpu->numThreads)
814         .name(name() + ".WB:consumers")
815         .desc("num instructions consuming a value")
816         .flags(total)
817         ;
818 
819     wb_penalized
820         .init(cpu->numThreads)
821         .name(name() + ".WB:penalized")
822         .desc("number of instrctions required to write to 'other' IQ")
823         .flags(total)
824         ;
825 
826 
827     wb_penalized_rate
828         .name(name() + ".WB:penalized_rate")
829         .desc ("fraction of instructions written-back that wrote to 'other' IQ")
830         .flags(total)
831         ;
832 
833     wb_penalized_rate = wb_penalized / writeback_count;
834 
835     wb_fanout
836         .name(name() + ".WB:fanout")
837         .desc("average fanout of values written-back")
838         .flags(total)
839         ;
840 
841     wb_fanout = producer_inst / consumer_inst;
842 
843     wb_rate
844         .name(name() + ".WB:rate")
845         .desc("insts written-back per cycle")
846         .flags(total)
847         ;
848     wb_rate = writeback_count / cpu->numCycles;
849 
850     stat_com_inst
851         .init(cpu->numThreads)
852         .name(name() + ".COM:count")
853         .desc("Number of instructions committed")
854         .flags(total)
855         ;
856 
857     stat_com_swp
858         .init(cpu->numThreads)
859         .name(name() + ".COM:swp_count")
860         .desc("Number of s/w prefetches committed")
861         .flags(total)
862         ;
863 
864     stat_com_refs
865         .init(cpu->numThreads)
866         .name(name() +  ".COM:refs")
867         .desc("Number of memory references committed")
868         .flags(total)
869         ;
870 
871     stat_com_loads
872         .init(cpu->numThreads)
873         .name(name() +  ".COM:loads")
874         .desc("Number of loads committed")
875         .flags(total)
876         ;
877 
878     stat_com_membars
879         .init(cpu->numThreads)
880         .name(name() +  ".COM:membars")
881         .desc("Number of memory barriers committed")
882         .flags(total)
883         ;
884 
885     stat_com_branches
886         .init(cpu->numThreads)
887         .name(name() + ".COM:branches")
888         .desc("Number of branches committed")
889         .flags(total)
890         ;
891     n_committed_dist
892         .init(0,commitWidth,1)
893         .name(name() + ".COM:committed_per_cycle")
894         .desc("Number of insts commited each cycle")
895         .flags(pdf)
896         ;
897 
898     //
899     //  Commit-Eligible instructions...
900     //
901     //  -> The number of instructions eligible to commit in those
902     //  cycles where we reached our commit BW limit (less the number
903     //  actually committed)
904     //
905     //  -> The average value is computed over ALL CYCLES... not just
906     //  the BW limited cycles
907     //
908     //  -> The standard deviation is computed only over cycles where
909     //  we reached the BW limit
910     //
911     commit_eligible
912         .init(cpu->numThreads)
913         .name(name() + ".COM:bw_limited")
914         .desc("number of insts not committed due to BW limits")
915         .flags(total)
916         ;
917 
918     commit_eligible_samples
919         .name(name() + ".COM:bw_lim_events")
920         .desc("number cycles where commit BW limit reached")
921         ;
922 
923     ROB_fcount
924         .name(name() + ".ROB:full_count")
925         .desc("number of cycles where ROB was full")
926         ;
927 
928     ROB_count
929         .init(cpu->numThreads)
930         .name(name() + ".ROB:occupancy")
931         .desc(name() + ".ROB occupancy (cumulative)")
932         .flags(total)
933         ;
934 
935     ROB_full_rate
936         .name(name() + ".ROB:full_rate")
937         .desc("ROB full per cycle")
938         ;
939     ROB_full_rate = ROB_fcount / cpu->numCycles;
940 
941     ROB_occ_rate
942         .name(name() + ".ROB:occ_rate")
943         .desc("ROB occupancy rate")
944         .flags(total)
945         ;
946     ROB_occ_rate = ROB_count / cpu->numCycles;
947 
948     ROB_occ_dist
949         .init(cpu->numThreads, 0, numROBEntries, 2)
950         .name(name() + ".ROB:occ_dist")
951         .desc("ROB Occupancy per cycle")
952         .flags(total | cdf)
953         ;
954 
955     IQ.regStats();
956 }
\end{DoxyCode}
\hypertarget{classBackEnd_ae165df775b4de9e9430228c7f04c2bc9}{
\index{BackEnd@{BackEnd}!replayMemInst@{replayMemInst}}
\index{replayMemInst@{replayMemInst}!BackEnd@{BackEnd}}
\subsubsection[{replayMemInst}]{\setlength{\rightskip}{0pt plus 5cm}void replayMemInst ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_ae165df775b4de9e9430228c7f04c2bc9}
Re-\/executes all rescheduled memory instructions. 


\begin{DoxyCode}
240     { IQ.replayMemInst(inst); }
\end{DoxyCode}
\hypertarget{classBackEnd_aa9c46f45f491ef90a936c7e2b95f20aa}{
\index{BackEnd@{BackEnd}!rescheduleMemInst@{rescheduleMemInst}}
\index{rescheduleMemInst@{rescheduleMemInst}!BackEnd@{BackEnd}}
\subsubsection[{rescheduleMemInst}]{\setlength{\rightskip}{0pt plus 5cm}void rescheduleMemInst ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_aa9c46f45f491ef90a936c7e2b95f20aa}
Tells memory dependence unit that a memory instruction needs to be rescheduled. It will re-\/execute once \hyperlink{classBackEnd_ae165df775b4de9e9430228c7f04c2bc9}{replayMemInst()} is called. 


\begin{DoxyCode}
236     { IQ.rescheduleMemInst(inst); }
\end{DoxyCode}
\hypertarget{classBackEnd_a5c38df1621043861ada4dd0939509869}{
\index{BackEnd@{BackEnd}!robEmpty@{robEmpty}}
\index{robEmpty@{robEmpty}!BackEnd@{BackEnd}}
\subsubsection[{robEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool robEmpty ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_a5c38df1621043861ada4dd0939509869}



\begin{DoxyCode}
227 { return instList.empty(); }
\end{DoxyCode}
\hypertarget{classBackEnd_a3694e72427d3a616808797f9343d1fc4}{
\index{BackEnd@{BackEnd}!scheduleReadyInsts@{scheduleReadyInsts}}
\index{scheduleReadyInsts@{scheduleReadyInsts}!BackEnd@{BackEnd}}
\subsubsection[{scheduleReadyInsts}]{\setlength{\rightskip}{0pt plus 5cm}void scheduleReadyInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classBackEnd_a3694e72427d3a616808797f9343d1fc4}



\begin{DoxyCode}
1183 {
1184     // Tell IQ to put any ready instructions into the instruction list.
1185     // Probably want to have a list of DynInstPtrs returned here.  Then I
1186     // can choose to either put them into a time buffer to simulate
1187     // IQ scheduling time, or hand them directly off to the next stage.
1188     // Do you ever want to directly hand it off to the next stage?
1189     DPRINTF(BE, "Trying to schedule ready instructions\n");
1190     IQ.scheduleReadyInsts();
1191 }
\end{DoxyCode}
\hypertarget{classBackEnd_aeabdb9f0aae07df67c3029f8fddb2693}{
\index{BackEnd@{BackEnd}!setCommBuffer@{setCommBuffer}}
\index{setCommBuffer@{setCommBuffer}!BackEnd@{BackEnd}}
\subsubsection[{setCommBuffer}]{\setlength{\rightskip}{0pt plus 5cm}void setCommBuffer ({\bf TimeBuffer}$<$ {\bf CommStruct} $>$ $\ast$ {\em \_\-comm})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_aeabdb9f0aae07df67c3029f8fddb2693}



\begin{DoxyCode}
961 {
962     comm = _comm;
963     toIEW = comm->getWire(0);
964     fromCommit = comm->getWire(-1);
965 }
\end{DoxyCode}
\hypertarget{classBackEnd_ad491c9766121fc19aa77fd0723e7641d}{
\index{BackEnd@{BackEnd}!setCPU@{setCPU}}
\index{setCPU@{setCPU}!BackEnd@{BackEnd}}
\subsubsection[{setCPU}]{\setlength{\rightskip}{0pt plus 5cm}void setCPU ({\bf FullCPU} $\ast$ {\em cpu\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_ad491c9766121fc19aa77fd0723e7641d}



\begin{DoxyCode}
199     { cpu = cpu_ptr; }
\end{DoxyCode}
\hypertarget{classBackEnd_a122009fa2730cee3898ac945227da8eb}{
\index{BackEnd@{BackEnd}!setFrontEnd@{setFrontEnd}}
\index{setFrontEnd@{setFrontEnd}!BackEnd@{BackEnd}}
\subsubsection[{setFrontEnd}]{\setlength{\rightskip}{0pt plus 5cm}void setFrontEnd ({\bf FrontEnd} $\ast$ {\em front\_\-end\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_a122009fa2730cee3898ac945227da8eb}



\begin{DoxyCode}
202     { frontEnd = front_end_ptr; }
\end{DoxyCode}
\hypertarget{classBackEnd_ac6ccaaea6ac518cab92f71723b5a739e}{
\index{BackEnd@{BackEnd}!setTC@{setTC}}
\index{setTC@{setTC}!BackEnd@{BackEnd}}
\subsubsection[{setTC}]{\setlength{\rightskip}{0pt plus 5cm}void setTC ({\bf ThreadContext} $\ast$ {\em tc\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_ac6ccaaea6ac518cab92f71723b5a739e}



\begin{DoxyCode}
205     { tc = tc_ptr; }
\end{DoxyCode}
\hypertarget{classBackEnd_a850bea4a9b9f631e7b6a4c7dc92f662a}{
\index{BackEnd@{BackEnd}!setThreadState@{setThreadState}}
\index{setThreadState@{setThreadState}!BackEnd@{BackEnd}}
\subsubsection[{setThreadState}]{\setlength{\rightskip}{0pt plus 5cm}void setThreadState ({\bf Thread} $\ast$ {\em thread\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_a850bea4a9b9f631e7b6a4c7dc92f662a}



\begin{DoxyCode}
208     { thread = thread_ptr; }
\end{DoxyCode}
\hypertarget{classBackEnd_adc9b67ce59b0b2e930cfaf6361ce42c5}{
\index{BackEnd@{BackEnd}!squash@{squash}}
\index{squash@{squash}!BackEnd@{BackEnd}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash (const {\bf InstSeqNum} \& {\em sn})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classBackEnd_adc9b67ce59b0b2e930cfaf6361ce42c5}



\begin{DoxyCode}
1618 {
1619     IQ.squash(sn);
1620     LSQ.squash(sn);
1621 
1622     int freed_regs = 0;
1623     InstListIt dispatch_end = dispatch.end();
1624     InstListIt insts_it = dispatch.end();
1625     insts_it--;
1626 
1627     while (insts_it != dispatch_end && (*insts_it)->seqNum > sn)
1628     {
1629         if ((*insts_it)->isSquashed()) {
1630             --insts_it;
1631             continue;
1632         }
1633         DPRINTF(BE, "Squashing instruction on dispatch list PC %#x, [sn:%lli].\n"
      ,
1634                 (*insts_it)->readPC(),
1635                 (*insts_it)->seqNum);
1636 
1637         // Mark the instruction as squashed, and ready to commit so that
1638         // it can drain out of the pipeline.
1639         (*insts_it)->setSquashed();
1640 
1641         (*insts_it)->setCanCommit();
1642 
1643         // Be careful with IPRs and such here
1644         for (int i = 0; i < (*insts_it)->numDestRegs(); ++i) {
1645             DynInstPtr prev_dest = (*insts_it)->getPrevDestInst(i);
1646             DPRINTF(BE, "Commit rename map setting register %i to [sn:%lli]\n",
1647                     (int)(*insts_it)->destRegIdx(i), prev_dest);
1648             renameTable[(*insts_it)->destRegIdx(i)] = prev_dest;
1649             ++freed_regs;
1650         }
1651 
1652         (*insts_it)->clearDependents();
1653 
1654         --insts_it;
1655     }
1656 
1657     insts_it = instList.end();
1658     insts_it--;
1659 
1660     while (!instList.empty() && (*insts_it)->seqNum > sn)
1661     {
1662         if ((*insts_it)->isSquashed()) {
1663             --insts_it;
1664             continue;
1665         }
1666         DPRINTF(BE, "Squashing instruction on inst list PC %#x, [sn:%lli].\n",
1667                 (*insts_it)->readPC(),
1668                 (*insts_it)->seqNum);
1669 
1670         // Mark the instruction as squashed, and ready to commit so that
1671         // it can drain out of the pipeline.
1672         (*insts_it)->setSquashed();
1673 
1674         (*insts_it)->setCanCommit();
1675 
1676         for (int i = 0; i < (*insts_it)->numDestRegs(); ++i) {
1677             DynInstPtr prev_dest = (*insts_it)->getPrevDestInst(i);
1678             DPRINTF(BE, "Commit rename map setting register %i to [sn:%lli]\n",
1679                     (int)(*insts_it)->destRegIdx(i), prev_dest);
1680             renameTable[(*insts_it)->destRegIdx(i)] = prev_dest;
1681             ++freed_regs;
1682         }
1683 
1684         (*insts_it)->clearDependents();
1685 
1686         instList.erase(insts_it--);
1687         --numInsts;
1688     }
1689 
1690     frontEnd->addFreeRegs(freed_regs);
1691 }
\end{DoxyCode}
\hypertarget{classBackEnd_a3c68c455d9207edd23ae3bcb7971e653}{
\index{BackEnd@{BackEnd}!squash@{squash}}
\index{squash@{squash}!BackEnd@{BackEnd}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash ()}}
\label{classBackEnd_a3c68c455d9207edd23ae3bcb7971e653}
\hypertarget{classBackEnd_a05c89a1532adb13cc0632fc3bb600add}{
\index{BackEnd@{BackEnd}!squashDueToBranch@{squashDueToBranch}}
\index{squashDueToBranch@{squashDueToBranch}!BackEnd@{BackEnd}}
\subsubsection[{squashDueToBranch}]{\setlength{\rightskip}{0pt plus 5cm}void squashDueToBranch ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classBackEnd_a05c89a1532adb13cc0632fc3bb600add}



\begin{DoxyCode}
1703 {
1704     // Update the branch predictor state I guess
1705     squash(inst->seqNum);
1706     frontEnd->squash(inst->seqNum, inst->readNextPC(),
1707                      true, inst->mispredicted());
1708 }
\end{DoxyCode}
\hypertarget{classBackEnd_a5fcf443dc6ada1ab1936df923c3205d2}{
\index{BackEnd@{BackEnd}!squashDueToMemBlocked@{squashDueToMemBlocked}}
\index{squashDueToMemBlocked@{squashDueToMemBlocked}!BackEnd@{BackEnd}}
\subsubsection[{squashDueToMemBlocked}]{\setlength{\rightskip}{0pt plus 5cm}void squashDueToMemBlocked ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classBackEnd_a5fcf443dc6ada1ab1936df923c3205d2}



\begin{DoxyCode}
1713 {
1714     DPRINTF(IEW, "Memory blocked, squashing load and younger insts, "
1715             "PC: %#x [sn:%i].\n", inst->readPC(), inst->seqNum);
1716 
1717     squash(inst->seqNum - 1);
1718     frontEnd->squash(inst->seqNum - 1, inst->readPC());
1719 }
\end{DoxyCode}
\hypertarget{classBackEnd_a24cd8db837a73b879041bf33da7b2064}{
\index{BackEnd@{BackEnd}!squashFromTC@{squashFromTC}}
\index{squashFromTC@{squashFromTC}!BackEnd@{BackEnd}}
\subsubsection[{squashFromTC}]{\setlength{\rightskip}{0pt plus 5cm}void squashFromTC ()}}
\label{classBackEnd_a24cd8db837a73b879041bf33da7b2064}
\hypertarget{classBackEnd_a873dd91783f9efb4a590aded1f70d6b0}{
\index{BackEnd@{BackEnd}!tick@{tick}}
\index{tick@{tick}!BackEnd@{BackEnd}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_a873dd91783f9efb4a590aded1f70d6b0}



\begin{DoxyCode}
970 {
971     DPRINTF(BE, "Ticking back end\n");
972 
973     ROB_count[0]+= numInsts;
974 
975     wbCycle = 0;
976 
977     if (xcSquash) {
978         squashFromXC();
979     }
980 
981     // Read in any done instruction information and update the IQ or LSQ.
982     updateStructures();
983 
984     if (dispatchStatus != Blocked) {
985         d2i.advance();
986         dispatchInsts();
987     } else {
988         checkDispatchStatus();
989     }
990 
991     i2e.advance();
992     scheduleReadyInsts();
993 
994     e2c.advance();
995     executeInsts();
996 
997     numInstsToWB.advance();
998     writebackInsts();
999 
1000     commitInsts();
1001 
1002     DPRINTF(BE, "IQ entries in use: %i, ROB entries in use: %i, LSQ loads: %i, LS
      Q stores: %i\n",
1003             IQ.numInsts, numInsts, LSQ.numLoads(), LSQ.numStores());
1004 
1005     assert(numInsts == instList.size());
1006 }
\end{DoxyCode}
\hypertarget{classBackEnd_a5bbf266cb0cc97eed138c8fe0d2d76b6}{
\index{BackEnd@{BackEnd}!updateComInstStats@{updateComInstStats}}
\index{updateComInstStats@{updateComInstStats}!BackEnd@{BackEnd}}
\subsubsection[{updateComInstStats}]{\setlength{\rightskip}{0pt plus 5cm}void updateComInstStats ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classBackEnd_a5bbf266cb0cc97eed138c8fe0d2d76b6}



\begin{DoxyCode}
1756 {
1757     ThreadID tid = inst->threadNumber;
1758 
1759     //
1760     //  Pick off the software prefetches
1761     //
1762 #ifdef TARGET_ALPHA
1763     if (inst->isDataPrefetch()) {
1764         stat_com_swp[tid]++;
1765     } else {
1766         stat_com_inst[tid]++;
1767     }
1768 #else
1769     stat_com_inst[tid]++;
1770 #endif
1771 
1772     //
1773     //  Control Instructions
1774     //
1775     if (inst->isControl())
1776         stat_com_branches[tid]++;
1777 
1778     //
1779     //  Memory references
1780     //
1781     if (inst->isMemRef()) {
1782         stat_com_refs[tid]++;
1783 
1784         if (inst->isLoad()) {
1785             stat_com_loads[tid]++;
1786         }
1787     }
1788 
1789     if (inst->isMemBarrier()) {
1790         stat_com_membars[tid]++;
1791     }
1792 }
\end{DoxyCode}
\hypertarget{classBackEnd_a132db67a5c42af856da64e347e8284d8}{
\index{BackEnd@{BackEnd}!updateExeInstStats@{updateExeInstStats}}
\index{updateExeInstStats@{updateExeInstStats}!BackEnd@{BackEnd}}
\subsubsection[{updateExeInstStats}]{\setlength{\rightskip}{0pt plus 5cm}void updateExeInstStats ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classBackEnd_a132db67a5c42af856da64e347e8284d8}



\begin{DoxyCode}
1731 {
1732     ThreadID tid = inst->threadNumber;
1733 
1734     exe_inst[tid]++;
1735 
1736     //
1737     //  Control operations
1738     //
1739     if (inst->isControl())
1740         exe_branches[tid]++;
1741 
1742     //
1743     //  Memory operations
1744     //
1745     if (inst->isMemRef()) {
1746         exe_refs[tid]++;
1747 
1748         if (inst->isLoad())
1749             exe_loads[tid]++;
1750     }
1751 }
\end{DoxyCode}
\hypertarget{classBackEnd_a1107d388cfcea92a9043608346ce98f0}{
\index{BackEnd@{BackEnd}!updateStructures@{updateStructures}}
\index{updateStructures@{updateStructures}!BackEnd@{BackEnd}}
\subsubsection[{updateStructures}]{\setlength{\rightskip}{0pt plus 5cm}void updateStructures ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classBackEnd_a1107d388cfcea92a9043608346ce98f0}



\begin{DoxyCode}
1011 {
1012     if (fromCommit->doneSeqNum) {
1013         IQ.commit(fromCommit->doneSeqNum);
1014         LSQ.commitLoads(fromCommit->doneSeqNum);
1015         LSQ.commitStores(fromCommit->doneSeqNum);
1016     }
1017 
1018     if (fromCommit->nonSpecSeqNum) {
1019         if (fromCommit->uncached) {
1020             LSQ.executeLoad(fromCommit->lqIdx);
1021         } else {
1022             IQ.scheduleNonSpec(
1023                 fromCommit->nonSpecSeqNum);
1024         }
1025     }
1026 }
\end{DoxyCode}
\hypertarget{classBackEnd_abbf7bcc93511421a1787650a43e2642a}{
\index{BackEnd@{BackEnd}!write@{write}}
\index{write@{write}!BackEnd@{BackEnd}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} write ({\bf RequestPtr} {\em req}, \/  T \& {\em data}, \/  int {\em store\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBackEnd_abbf7bcc93511421a1787650a43e2642a}



\begin{DoxyCode}
502 {
503 /*
504     memReq->reset(addr, sizeof(T), flags);
505 
506     // translate to physical address
507     Fault fault = cpu->translateDataWriteReq(memReq);
508 
509     if (fault == NoFault && dcacheInterface) {
510         memReq->cmd = Write;
511         memcpy(memReq->data,(uint8_t *)&data,memReq->size);
512         memReq->completionEvent = NULL;
513         memReq->time = curTick();
514         memReq->flags &= ~INST_READ;
515         MemAccessResult result = dcacheInterface->access(memReq);
516 
517         // Ugly hack to get an event scheduled *only* if the access is
518         // a miss.  We really should add first-class support for this
519         // at some point.
520         if (result != MA_HIT && dcacheInterface->doEvents()) {
521             memReq->completionEvent = &cacheCompletionEvent;
522             lastDcacheStall = curTick();
523 //          unscheduleTickEvent();
524 //          status = DcacheMissStall;
525             DPRINTF(OzoneCPU, "Dcache miss stall!\n");
526         }
527     }
528 
529     if (res && (fault == NoFault))
530         *res = memReq->result;
531         */
532     return LSQ.write(req, data, store_idx);
533 }
\end{DoxyCode}
\hypertarget{classBackEnd_a5e9a203f943b3a8a243ddc6d2a0a240d}{
\index{BackEnd@{BackEnd}!writebackInsts@{writebackInsts}}
\index{writebackInsts@{writebackInsts}!BackEnd@{BackEnd}}
\subsubsection[{writebackInsts}]{\setlength{\rightskip}{0pt plus 5cm}void writebackInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classBackEnd_a5e9a203f943b3a8a243ddc6d2a0a240d}



\begin{DoxyCode}
1394 {
1395     int wb_width = wbWidth;
1396     // Using this method I'm not quite sure how to prevent an
1397     // instruction from waking its own dependents multiple times,
1398     // without the guarantee that commit always has enough bandwidth
1399     // to accept all instructions being written back.  This guarantee
1400     // might not be too unrealistic.
1401     InstListIt wb_inst_it = writeback.begin();
1402     InstListIt wb_end_it = writeback.end();
1403     int inst_num = 0;
1404     int consumer_insts = 0;
1405 
1406     for (; inst_num < wb_width &&
1407              wb_inst_it != wb_end_it; inst_num++) {
1408         DynInstPtr inst = (*wb_inst_it);
1409 
1410         // Some instructions will be sent to commit without having
1411         // executed because they need commit to handle them.
1412         // E.g. Uncached loads have not actually executed when they
1413         // are first sent to commit.  Instead commit must tell the LSQ
1414         // when it's ready to execute the uncached load.
1415         if (!inst->isSquashed()) {
1416             DPRINTF(BE, "Writing back instruction [sn:%lli] PC %#x.\n",
1417                     inst->seqNum, inst->readPC());
1418 
1419             inst->setCanCommit();
1420             inst->setResultReady();
1421 
1422             if (inst->isExecuted()) {
1423                 int dependents = IQ.wakeDependents(inst);
1424                 if (dependents) {
1425                     producer_inst[0]++;
1426                     consumer_insts+= dependents;
1427                 }
1428             }
1429         }
1430 
1431         writeback.erase(wb_inst_it++);
1432     }
1433     LSQ.writebackStores();
1434     consumer_inst[0]+= consumer_insts;
1435     writeback_count[0]+= inst_num;
1436 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classBackEnd_a27227be5511e316f17702a3a99fb0b98}{
\index{BackEnd@{BackEnd}!DCacheCompletionEvent@{DCacheCompletionEvent}}
\index{DCacheCompletionEvent@{DCacheCompletionEvent}!BackEnd@{BackEnd}}
\subsubsection[{DCacheCompletionEvent}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf DCacheCompletionEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classBackEnd_a27227be5511e316f17702a3a99fb0b98}


\subsection{変数}
\hypertarget{classBackEnd_a08f9ddeb55a0840fc2f9d8f4c5e7a9fc}{
\index{BackEnd@{BackEnd}!cacheCompletionEvent@{cacheCompletionEvent}}
\index{cacheCompletionEvent@{cacheCompletionEvent}!BackEnd@{BackEnd}}
\subsubsection[{cacheCompletionEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DCacheCompletionEvent} {\bf cacheCompletionEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a08f9ddeb55a0840fc2f9d8f4c5e7a9fc}
\hypertarget{classBackEnd_a282f2307a986f183b83e887756561687}{
\index{BackEnd@{BackEnd}!comm@{comm}}
\index{comm@{comm}!BackEnd@{BackEnd}}
\subsubsection[{comm}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf CommStruct}$>$$\ast$ {\bf comm}}}
\label{classBackEnd_a282f2307a986f183b83e887756561687}
\hypertarget{classBackEnd_a3dd8a34217d79ba678222441cf275502}{
\index{BackEnd@{BackEnd}!commit\_\-eligible@{commit\_\-eligible}}
\index{commit\_\-eligible@{commit\_\-eligible}!BackEnd@{BackEnd}}
\subsubsection[{commit\_\-eligible}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf commit\_\-eligible}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a3dd8a34217d79ba678222441cf275502}
\hypertarget{classBackEnd_accdcc276eadba243157fb68d08dd5cda}{
\index{BackEnd@{BackEnd}!commit\_\-eligible\_\-samples@{commit\_\-eligible\_\-samples}}
\index{commit\_\-eligible\_\-samples@{commit\_\-eligible\_\-samples}!BackEnd@{BackEnd}}
\subsubsection[{commit\_\-eligible\_\-samples}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf commit\_\-eligible\_\-samples}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_accdcc276eadba243157fb68d08dd5cda}
\hypertarget{classBackEnd_af043d6103c5f173871f527899c41d2d2}{
\index{BackEnd@{BackEnd}!commitPC@{commitPC}}
\index{commitPC@{commitPC}!BackEnd@{BackEnd}}
\subsubsection[{commitPC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf commitPC}}}
\label{classBackEnd_af043d6103c5f173871f527899c41d2d2}
\hypertarget{classBackEnd_adbf41f9b1f8e58747002bd5f65f2ded9}{
\index{BackEnd@{BackEnd}!commitRenameTable@{commitRenameTable}}
\index{commitRenameTable@{commitRenameTable}!BackEnd@{BackEnd}}
\subsubsection[{commitRenameTable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RenameTable}$<$Impl$>$ {\bf commitRenameTable}}}
\label{classBackEnd_adbf41f9b1f8e58747002bd5f65f2ded9}
\hypertarget{classBackEnd_a328db48cdab1c2a18d8432b647e2785b}{
\index{BackEnd@{BackEnd}!commitWidth@{commitWidth}}
\index{commitWidth@{commitWidth}!BackEnd@{BackEnd}}
\subsubsection[{commitWidth}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf commitWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a328db48cdab1c2a18d8432b647e2785b}
\hypertarget{classBackEnd_a5242b9d95c9537000e64dee2e5ac42cf}{
\index{BackEnd@{BackEnd}!consumer\_\-inst@{consumer\_\-inst}}
\index{consumer\_\-inst@{consumer\_\-inst}!BackEnd@{BackEnd}}
\subsubsection[{consumer\_\-inst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf consumer\_\-inst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a5242b9d95c9537000e64dee2e5ac42cf}
\hypertarget{classBackEnd_a766385c2941cd46525f4d9dff90200a2}{
\index{BackEnd@{BackEnd}!cpu@{cpu}}
\index{cpu@{cpu}!BackEnd@{BackEnd}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FullCPU}$\ast$ {\bf cpu}}}
\label{classBackEnd_a766385c2941cd46525f4d9dff90200a2}
\hypertarget{classBackEnd_ae446eaddd47d5f227ed00af24aaefe68}{
\index{BackEnd@{BackEnd}!d2i@{d2i}}
\index{d2i@{d2i}!BackEnd@{BackEnd}}
\subsubsection[{d2i}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf DispatchToIssue}$>$ {\bf d2i}}}
\label{classBackEnd_ae446eaddd47d5f227ed00af24aaefe68}
\hypertarget{classBackEnd_a22dc8294eecb144fbdd951d2e32e9330}{
\index{BackEnd@{BackEnd}!dcacheInterface@{dcacheInterface}}
\index{dcacheInterface@{dcacheInterface}!BackEnd@{BackEnd}}
\subsubsection[{dcacheInterface}]{\setlength{\rightskip}{0pt plus 5cm}MemInterface$\ast$ {\bf dcacheInterface}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a22dc8294eecb144fbdd951d2e32e9330}
\hypertarget{classBackEnd_a1e13c801cafc8d7e052b2f999c89ad85}{
\index{BackEnd@{BackEnd}!dispatch@{dispatch}}
\index{dispatch@{dispatch}!BackEnd@{BackEnd}}
\subsubsection[{dispatch}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf dispatch}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a1e13c801cafc8d7e052b2f999c89ad85}
\hypertarget{classBackEnd_a32343e1e9e56c17bb868f861f9b8927d}{
\index{BackEnd@{BackEnd}!dispatchSize@{dispatchSize}}
\index{dispatchSize@{dispatchSize}!BackEnd@{BackEnd}}
\subsubsection[{dispatchSize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf dispatchSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a32343e1e9e56c17bb868f861f9b8927d}
\hypertarget{classBackEnd_a245e3bace7ab490110304d56450aba64}{
\index{BackEnd@{BackEnd}!dispatchStatus@{dispatchStatus}}
\index{dispatchStatus@{dispatchStatus}!BackEnd@{BackEnd}}
\subsubsection[{dispatchStatus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Status} {\bf dispatchStatus}}}
\label{classBackEnd_a245e3bace7ab490110304d56450aba64}
\hypertarget{classBackEnd_aa304d4c426ea2bba52be0a3c0b9811e3}{
\index{BackEnd@{BackEnd}!dispatchWidth@{dispatchWidth}}
\index{dispatchWidth@{dispatchWidth}!BackEnd@{BackEnd}}
\subsubsection[{dispatchWidth}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf dispatchWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_aa304d4c426ea2bba52be0a3c0b9811e3}
\hypertarget{classBackEnd_a114248f83077c8e99f4f4aa0236aafeb}{
\index{BackEnd@{BackEnd}!e2c@{e2c}}
\index{e2c@{e2c}!BackEnd@{BackEnd}}
\subsubsection[{e2c}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf ExecToCommit}$>$ {\bf e2c}}}
\label{classBackEnd_a114248f83077c8e99f4f4aa0236aafeb}
\hypertarget{classBackEnd_a319e9530b28153883e886be5b9c573eb}{
\index{BackEnd@{BackEnd}!exactFullStall@{exactFullStall}}
\index{exactFullStall@{exactFullStall}!BackEnd@{BackEnd}}
\subsubsection[{exactFullStall}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf exactFullStall}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a319e9530b28153883e886be5b9c573eb}
\hypertarget{classBackEnd_a2bffb8fee3fa396523a2b86dba12a606}{
\index{BackEnd@{BackEnd}!exe\_\-branches@{exe\_\-branches}}
\index{exe\_\-branches@{exe\_\-branches}!BackEnd@{BackEnd}}
\subsubsection[{exe\_\-branches}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf exe\_\-branches}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a2bffb8fee3fa396523a2b86dba12a606}
\hypertarget{classBackEnd_afdd7841e13784687ccb7c432189dca2f}{
\index{BackEnd@{BackEnd}!exe\_\-inst@{exe\_\-inst}}
\index{exe\_\-inst@{exe\_\-inst}!BackEnd@{BackEnd}}
\subsubsection[{exe\_\-inst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf exe\_\-inst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_afdd7841e13784687ccb7c432189dca2f}
\hypertarget{classBackEnd_a07f469c547d380cda882b5ca10fc8813}{
\index{BackEnd@{BackEnd}!exe\_\-loads@{exe\_\-loads}}
\index{exe\_\-loads@{exe\_\-loads}!BackEnd@{BackEnd}}
\subsubsection[{exe\_\-loads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf exe\_\-loads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a07f469c547d380cda882b5ca10fc8813}
\hypertarget{classBackEnd_a16327b5e9165d27dc47c0bf44238cd74}{
\index{BackEnd@{BackEnd}!exe\_\-nop@{exe\_\-nop}}
\index{exe\_\-nop@{exe\_\-nop}!BackEnd@{BackEnd}}
\subsubsection[{exe\_\-nop}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf exe\_\-nop}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a16327b5e9165d27dc47c0bf44238cd74}
\hypertarget{classBackEnd_a9c0474dab97b001394a40aed972f827a}{
\index{BackEnd@{BackEnd}!exe\_\-refs@{exe\_\-refs}}
\index{exe\_\-refs@{exe\_\-refs}!BackEnd@{BackEnd}}
\subsubsection[{exe\_\-refs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf exe\_\-refs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a9c0474dab97b001394a40aed972f827a}
\hypertarget{classBackEnd_a7d82b30a9bc5daa8a508aad6120df60a}{
\index{BackEnd@{BackEnd}!exe\_\-swp@{exe\_\-swp}}
\index{exe\_\-swp@{exe\_\-swp}!BackEnd@{BackEnd}}
\subsubsection[{exe\_\-swp}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf exe\_\-swp}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a7d82b30a9bc5daa8a508aad6120df60a}
\hypertarget{classBackEnd_a21a86a2f5f30b0f512909bdc8b2aae53}{
\index{BackEnd@{BackEnd}!faultFromFetch@{faultFromFetch}}
\index{faultFromFetch@{faultFromFetch}!BackEnd@{BackEnd}}
\subsubsection[{faultFromFetch}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} {\bf faultFromFetch}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a21a86a2f5f30b0f512909bdc8b2aae53}
\hypertarget{classBackEnd_aa40219506ff80e4e8c5a9a3b1205b282}{
\index{BackEnd@{BackEnd}!fetchRedirect@{fetchRedirect}}
\index{fetchRedirect@{fetchRedirect}!BackEnd@{BackEnd}}
\subsubsection[{fetchRedirect}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf fetchRedirect}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_aa40219506ff80e4e8c5a9a3b1205b282}
\hypertarget{classBackEnd_a77bf6c956edddf1d551d5371ff72162e}{
\index{BackEnd@{BackEnd}!fromCommit@{fromCommit}}
\index{fromCommit@{fromCommit}!BackEnd@{BackEnd}}
\subsubsection[{fromCommit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf CommStruct}$>$::wire {\bf fromCommit}}}
\label{classBackEnd_a77bf6c956edddf1d551d5371ff72162e}
\hypertarget{classBackEnd_a67c762418bb2017cb2dce5a0c94f0788}{
\index{BackEnd@{BackEnd}!frontEnd@{frontEnd}}
\index{frontEnd@{frontEnd}!BackEnd@{BackEnd}}
\subsubsection[{frontEnd}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FrontEnd}$\ast$ {\bf frontEnd}}}
\label{classBackEnd_a67c762418bb2017cb2dce5a0c94f0788}
\hypertarget{classBackEnd_a344acde4f72898017365be79fd18a323}{
\index{BackEnd@{BackEnd}!funcExeInst@{funcExeInst}}
\index{funcExeInst@{funcExeInst}!BackEnd@{BackEnd}}
\subsubsection[{funcExeInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Counter} {\bf funcExeInst}}}
\label{classBackEnd_a344acde4f72898017365be79fd18a323}
\hypertarget{classBackEnd_a055203b013ada25d70a2a2c8b2364455}{
\index{BackEnd@{BackEnd}!i2e@{i2e}}
\index{i2e@{i2e}!BackEnd@{BackEnd}}
\subsubsection[{i2e}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf IssueToExec}$>$ {\bf i2e}}}
\label{classBackEnd_a055203b013ada25d70a2a2c8b2364455}
\hypertarget{classBackEnd_ae10a391d02ce1ef67ee13cd82b7d46e5}{
\index{BackEnd@{BackEnd}!instList@{instList}}
\index{instList@{instList}!BackEnd@{BackEnd}}
\subsubsection[{instList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf instList}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_ae10a391d02ce1ef67ee13cd82b7d46e5}
\hypertarget{classBackEnd_ace1cd34be1eca99cb8c1d3a30e32fcbe}{
\index{BackEnd@{BackEnd}!instsToDispatch@{instsToDispatch}}
\index{instsToDispatch@{instsToDispatch}!BackEnd@{BackEnd}}
\subsubsection[{instsToDispatch}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf DispatchToIssue}$>$::wire {\bf instsToDispatch}}}
\label{classBackEnd_ace1cd34be1eca99cb8c1d3a30e32fcbe}
\hypertarget{classBackEnd_a45c3ddf2275eab2326190578f1fcbee2}{
\index{BackEnd@{BackEnd}!instsToExecute@{instsToExecute}}
\index{instsToExecute@{instsToExecute}!BackEnd@{BackEnd}}
\subsubsection[{instsToExecute}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf IssueToExec}$>$::wire {\bf instsToExecute}}}
\label{classBackEnd_a45c3ddf2275eab2326190578f1fcbee2}
\hypertarget{classBackEnd_a032ab6d2dd14a8ccff4d407c7ff2a3d9}{
\index{BackEnd@{BackEnd}!inv\_\-addr\_\-loads@{inv\_\-addr\_\-loads}}
\index{inv\_\-addr\_\-loads@{inv\_\-addr\_\-loads}!BackEnd@{BackEnd}}
\subsubsection[{inv\_\-addr\_\-loads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf inv\_\-addr\_\-loads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a032ab6d2dd14a8ccff4d407c7ff2a3d9}
\hypertarget{classBackEnd_a3814f636ed4028691262652be79c7091}{
\index{BackEnd@{BackEnd}!inv\_\-addr\_\-swpfs@{inv\_\-addr\_\-swpfs}}
\index{inv\_\-addr\_\-swpfs@{inv\_\-addr\_\-swpfs}!BackEnd@{BackEnd}}
\subsubsection[{inv\_\-addr\_\-swpfs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf inv\_\-addr\_\-swpfs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a3814f636ed4028691262652be79c7091}
\hypertarget{classBackEnd_a9f8da5ee0decabae62161ec4c1738952}{
\index{BackEnd@{BackEnd}!IQ@{IQ}}
\index{IQ@{IQ}!BackEnd@{BackEnd}}
\subsubsection[{IQ}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstQueue} {\bf IQ}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a9f8da5ee0decabae62161ec4c1738952}
\hypertarget{classBackEnd_a94526617722efa24b56a33ac2e91a53d}{
\index{BackEnd@{BackEnd}!iq\_\-cap\_\-events@{iq\_\-cap\_\-events}}
\index{iq\_\-cap\_\-events@{iq\_\-cap\_\-events}!BackEnd@{BackEnd}}
\subsubsection[{iq\_\-cap\_\-events}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf iq\_\-cap\_\-events}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a94526617722efa24b56a33ac2e91a53d}
\hypertarget{classBackEnd_ab013e91b819cbfbaeb30f620eeb9af63}{
\index{BackEnd@{BackEnd}!iq\_\-cap\_\-inst\_\-count@{iq\_\-cap\_\-inst\_\-count}}
\index{iq\_\-cap\_\-inst\_\-count@{iq\_\-cap\_\-inst\_\-count}!BackEnd@{BackEnd}}
\subsubsection[{iq\_\-cap\_\-inst\_\-count}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf iq\_\-cap\_\-inst\_\-count}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_ab013e91b819cbfbaeb30f620eeb9af63}
\hypertarget{classBackEnd_acbff26ed63b17948662f090985d17d32}{
\index{BackEnd@{BackEnd}!issue\_\-delay\_\-dist@{issue\_\-delay\_\-dist}}
\index{issue\_\-delay\_\-dist@{issue\_\-delay\_\-dist}!BackEnd@{BackEnd}}
\subsubsection[{issue\_\-delay\_\-dist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::VectorDistribution} {\bf issue\_\-delay\_\-dist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_acbff26ed63b17948662f090985d17d32}
\hypertarget{classBackEnd_ad98215aa24a0390cc2ba2234f272cb17}{
\index{BackEnd@{BackEnd}!issued\_\-ops@{issued\_\-ops}}
\index{issued\_\-ops@{issued\_\-ops}!BackEnd@{BackEnd}}
\subsubsection[{issued\_\-ops}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf issued\_\-ops}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_ad98215aa24a0390cc2ba2234f272cb17}
\hypertarget{classBackEnd_a171bac1210be84c8811563ab35209fce}{
\index{BackEnd@{BackEnd}!issueWidth@{issueWidth}}
\index{issueWidth@{issueWidth}!BackEnd@{BackEnd}}
\subsubsection[{issueWidth}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf issueWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a171bac1210be84c8811563ab35209fce}
\hypertarget{classBackEnd_a9c5bf07170b5d91cfb44d4bfd0517128}{
\index{BackEnd@{BackEnd}!latency@{latency}}
\index{latency@{latency}!BackEnd@{BackEnd}}
\subsubsection[{latency}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf latency}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a9c5bf07170b5d91cfb44d4bfd0517128}
\hypertarget{classBackEnd_a2d033f80e55d1123d747d40f026042aa}{
\index{BackEnd@{BackEnd}!LSQ@{LSQ}}
\index{LSQ@{LSQ}!BackEnd@{BackEnd}}
\subsubsection[{LSQ}]{\setlength{\rightskip}{0pt plus 5cm}{\bf LdstQueue} {\bf LSQ}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a2d033f80e55d1123d747d40f026042aa}
\hypertarget{classBackEnd_afdabbae5f4752ae636610a296ce040e6}{
\index{BackEnd@{BackEnd}!lsq\_\-blocked\_\-loads@{lsq\_\-blocked\_\-loads}}
\index{lsq\_\-blocked\_\-loads@{lsq\_\-blocked\_\-loads}!BackEnd@{BackEnd}}
\subsubsection[{lsq\_\-blocked\_\-loads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf lsq\_\-blocked\_\-loads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_afdabbae5f4752ae636610a296ce040e6}
\hypertarget{classBackEnd_afcc98cdfa47d5d6cfd8818f91dde0eb5}{
\index{BackEnd@{BackEnd}!lsq\_\-forw\_\-loads@{lsq\_\-forw\_\-loads}}
\index{lsq\_\-forw\_\-loads@{lsq\_\-forw\_\-loads}!BackEnd@{BackEnd}}
\subsubsection[{lsq\_\-forw\_\-loads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf lsq\_\-forw\_\-loads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_afcc98cdfa47d5d6cfd8818f91dde0eb5}
\hypertarget{classBackEnd_abf96f4acba126fbcf919829a1125954c}{
\index{BackEnd@{BackEnd}!lsqInversion@{lsqInversion}}
\index{lsqInversion@{lsqInversion}!BackEnd@{BackEnd}}
\subsubsection[{lsqInversion}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf lsqInversion}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_abf96f4acba126fbcf919829a1125954c}
\hypertarget{classBackEnd_aeb76c16c8ed66ba50e2c29989814616d}{
\index{BackEnd@{BackEnd}!memReq@{memReq}}
\index{memReq@{memReq}!BackEnd@{BackEnd}}
\subsubsection[{memReq}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Request}$\ast$ {\bf memReq}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_aeb76c16c8ed66ba50e2c29989814616d}
\hypertarget{classBackEnd_adef6c140c8c63175c52b3bc6501f9d1c}{
\index{BackEnd@{BackEnd}!n\_\-committed\_\-dist@{n\_\-committed\_\-dist}}
\index{n\_\-committed\_\-dist@{n\_\-committed\_\-dist}!BackEnd@{BackEnd}}
\subsubsection[{n\_\-committed\_\-dist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Distribution} {\bf n\_\-committed\_\-dist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_adef6c140c8c63175c52b3bc6501f9d1c}
\hypertarget{classBackEnd_aef7967289461e66d515723da65e1f9f7}{
\index{BackEnd@{BackEnd}!n\_\-issued\_\-dist@{n\_\-issued\_\-dist}}
\index{n\_\-issued\_\-dist@{n\_\-issued\_\-dist}!BackEnd@{BackEnd}}
\subsubsection[{n\_\-issued\_\-dist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf n\_\-issued\_\-dist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_aef7967289461e66d515723da65e1f9f7}
\hypertarget{classBackEnd_a10a1f0f6ff8acbb26f4c308a502c6141}{
\index{BackEnd@{BackEnd}!numDispatchEntries@{numDispatchEntries}}
\index{numDispatchEntries@{numDispatchEntries}!BackEnd@{BackEnd}}
\subsubsection[{numDispatchEntries}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf numDispatchEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a10a1f0f6ff8acbb26f4c308a502c6141}
\hypertarget{classBackEnd_a358c879c68910efe5300c4515df35b6c}{
\index{BackEnd@{BackEnd}!numInsts@{numInsts}}
\index{numInsts@{numInsts}!BackEnd@{BackEnd}}
\subsubsection[{numInsts}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf numInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a358c879c68910efe5300c4515df35b6c}
\hypertarget{classBackEnd_a2647e2052851a9122ac4ce89b84d77b5}{
\index{BackEnd@{BackEnd}!numInstsToWB@{numInstsToWB}}
\index{numInstsToWB@{numInstsToWB}!BackEnd@{BackEnd}}
\subsubsection[{numInstsToWB}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf Writeback}$>$ {\bf numInstsToWB}}}
\label{classBackEnd_a2647e2052851a9122ac4ce89b84d77b5}
\hypertarget{classBackEnd_ae40678133a160367f2207f07975ca0f3}{
\index{BackEnd@{BackEnd}!numROBEntries@{numROBEntries}}
\index{numROBEntries@{numROBEntries}!BackEnd@{BackEnd}}
\subsubsection[{numROBEntries}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf numROBEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_ae40678133a160367f2207f07975ca0f3}
\hypertarget{classBackEnd_a47652a48ae1beac314831c224e026f24}{
\index{BackEnd@{BackEnd}!producer\_\-inst@{producer\_\-inst}}
\index{producer\_\-inst@{producer\_\-inst}!BackEnd@{BackEnd}}
\subsubsection[{producer\_\-inst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf producer\_\-inst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a47652a48ae1beac314831c224e026f24}
\hypertarget{classBackEnd_a6737d38b89983fe331764c5c0edfbe12}{
\index{BackEnd@{BackEnd}!queue\_\-res\_\-dist@{queue\_\-res\_\-dist}}
\index{queue\_\-res\_\-dist@{queue\_\-res\_\-dist}!BackEnd@{BackEnd}}
\subsubsection[{queue\_\-res\_\-dist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::VectorDistribution} {\bf queue\_\-res\_\-dist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a6737d38b89983fe331764c5c0edfbe12}
\hypertarget{classBackEnd_af8d3f859e7c0dd9408ba99de6f415616}{
\index{BackEnd@{BackEnd}!renameTable@{renameTable}}
\index{renameTable@{renameTable}!BackEnd@{BackEnd}}
\subsubsection[{renameTable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RenameTable}$<$Impl$>$ {\bf renameTable}}}
\label{classBackEnd_af8d3f859e7c0dd9408ba99de6f415616}
\hypertarget{classBackEnd_a6480145c05acc370598e816e2e8cf879}{
\index{BackEnd@{BackEnd}!rob\_\-cap\_\-events@{rob\_\-cap\_\-events}}
\index{rob\_\-cap\_\-events@{rob\_\-cap\_\-events}!BackEnd@{BackEnd}}
\subsubsection[{rob\_\-cap\_\-events}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf rob\_\-cap\_\-events}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a6480145c05acc370598e816e2e8cf879}
\hypertarget{classBackEnd_a0eb2b00bb6b4dfa3e98d7a3c5c425c50}{
\index{BackEnd@{BackEnd}!rob\_\-cap\_\-inst\_\-count@{rob\_\-cap\_\-inst\_\-count}}
\index{rob\_\-cap\_\-inst\_\-count@{rob\_\-cap\_\-inst\_\-count}!BackEnd@{BackEnd}}
\subsubsection[{rob\_\-cap\_\-inst\_\-count}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf rob\_\-cap\_\-inst\_\-count}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a0eb2b00bb6b4dfa3e98d7a3c5c425c50}
\hypertarget{classBackEnd_a4ccaf3f968ca2c525ff6934f5dc202a4}{
\index{BackEnd@{BackEnd}!ROB\_\-count@{ROB\_\-count}}
\index{ROB\_\-count@{ROB\_\-count}!BackEnd@{BackEnd}}
\subsubsection[{ROB\_\-count}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf ROB\_\-count}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a4ccaf3f968ca2c525ff6934f5dc202a4}
\hypertarget{classBackEnd_ac41e5b42959e2f75c51c9fec633e2491}{
\index{BackEnd@{BackEnd}!ROB\_\-fcount@{ROB\_\-fcount}}
\index{ROB\_\-fcount@{ROB\_\-fcount}!BackEnd@{BackEnd}}
\subsubsection[{ROB\_\-fcount}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf ROB\_\-fcount}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_ac41e5b42959e2f75c51c9fec633e2491}
\hypertarget{classBackEnd_a4e4aad30eb153b8d15da02cf33e57e9c}{
\index{BackEnd@{BackEnd}!ROB\_\-full\_\-rate@{ROB\_\-full\_\-rate}}
\index{ROB\_\-full\_\-rate@{ROB\_\-full\_\-rate}!BackEnd@{BackEnd}}
\subsubsection[{ROB\_\-full\_\-rate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf ROB\_\-full\_\-rate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a4e4aad30eb153b8d15da02cf33e57e9c}
\hypertarget{classBackEnd_ace261e0da7b5ca53fcfc3a27782418c4}{
\index{BackEnd@{BackEnd}!ROB\_\-occ\_\-dist@{ROB\_\-occ\_\-dist}}
\index{ROB\_\-occ\_\-dist@{ROB\_\-occ\_\-dist}!BackEnd@{BackEnd}}
\subsubsection[{ROB\_\-occ\_\-dist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::VectorDistribution} {\bf ROB\_\-occ\_\-dist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_ace261e0da7b5ca53fcfc3a27782418c4}
\hypertarget{classBackEnd_ac6bfab47ea686c39b71e475aec8b07ca}{
\index{BackEnd@{BackEnd}!ROB\_\-occ\_\-rate@{ROB\_\-occ\_\-rate}}
\index{ROB\_\-occ\_\-rate@{ROB\_\-occ\_\-rate}!BackEnd@{BackEnd}}
\subsubsection[{ROB\_\-occ\_\-rate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf ROB\_\-occ\_\-rate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_ac6bfab47ea686c39b71e475aec8b07ca}
\hypertarget{classBackEnd_a440f8cda1481977c324a827c7c9f1e24}{
\index{BackEnd@{BackEnd}!squashLatency@{squashLatency}}
\index{squashLatency@{squashLatency}!BackEnd@{BackEnd}}
\subsubsection[{squashLatency}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf squashLatency}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a440f8cda1481977c324a827c7c9f1e24}
\hypertarget{classBackEnd_aabe0c73b4678ef858d3363c9bed18906}{
\index{BackEnd@{BackEnd}!squashNextPC@{squashNextPC}}
\index{squashNextPC@{squashNextPC}!BackEnd@{BackEnd}}
\subsubsection[{squashNextPC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf squashNextPC}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_aabe0c73b4678ef858d3363c9bed18906}
\hypertarget{classBackEnd_a2aafb6fc593b04986eeed845923a8953}{
\index{BackEnd@{BackEnd}!squashPending@{squashPending}}
\index{squashPending@{squashPending}!BackEnd@{BackEnd}}
\subsubsection[{squashPending}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf squashPending}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a2aafb6fc593b04986eeed845923a8953}
\hypertarget{classBackEnd_a34292b1418c46ca63c892e7826510d77}{
\index{BackEnd@{BackEnd}!squashSeqNum@{squashSeqNum}}
\index{squashSeqNum@{squashSeqNum}!BackEnd@{BackEnd}}
\subsubsection[{squashSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf squashSeqNum}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a34292b1418c46ca63c892e7826510d77}
\hypertarget{classBackEnd_a3368cb0b59cef9b4542f17661835022f}{
\index{BackEnd@{BackEnd}!stat\_\-com\_\-branches@{stat\_\-com\_\-branches}}
\index{stat\_\-com\_\-branches@{stat\_\-com\_\-branches}!BackEnd@{BackEnd}}
\subsubsection[{stat\_\-com\_\-branches}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf stat\_\-com\_\-branches}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a3368cb0b59cef9b4542f17661835022f}
\hypertarget{classBackEnd_a3f56571c523bf46f2fe976188ad1e50c}{
\index{BackEnd@{BackEnd}!stat\_\-com\_\-inst@{stat\_\-com\_\-inst}}
\index{stat\_\-com\_\-inst@{stat\_\-com\_\-inst}!BackEnd@{BackEnd}}
\subsubsection[{stat\_\-com\_\-inst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf stat\_\-com\_\-inst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a3f56571c523bf46f2fe976188ad1e50c}
\hypertarget{classBackEnd_a998922e22a0a08c55cf2f5ed99ad79cc}{
\index{BackEnd@{BackEnd}!stat\_\-com\_\-loads@{stat\_\-com\_\-loads}}
\index{stat\_\-com\_\-loads@{stat\_\-com\_\-loads}!BackEnd@{BackEnd}}
\subsubsection[{stat\_\-com\_\-loads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf stat\_\-com\_\-loads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a998922e22a0a08c55cf2f5ed99ad79cc}
\hypertarget{classBackEnd_a2e29921a3b4c4ffb52ceef970898e906}{
\index{BackEnd@{BackEnd}!stat\_\-com\_\-membars@{stat\_\-com\_\-membars}}
\index{stat\_\-com\_\-membars@{stat\_\-com\_\-membars}!BackEnd@{BackEnd}}
\subsubsection[{stat\_\-com\_\-membars}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf stat\_\-com\_\-membars}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a2e29921a3b4c4ffb52ceef970898e906}
\hypertarget{classBackEnd_a541fdbe722e4ddbdcca7994625162235}{
\index{BackEnd@{BackEnd}!stat\_\-com\_\-refs@{stat\_\-com\_\-refs}}
\index{stat\_\-com\_\-refs@{stat\_\-com\_\-refs}!BackEnd@{BackEnd}}
\subsubsection[{stat\_\-com\_\-refs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf stat\_\-com\_\-refs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a541fdbe722e4ddbdcca7994625162235}
\hypertarget{classBackEnd_a2c3ec644af0af2970d0066b987427b46}{
\index{BackEnd@{BackEnd}!stat\_\-com\_\-swp@{stat\_\-com\_\-swp}}
\index{stat\_\-com\_\-swp@{stat\_\-com\_\-swp}!BackEnd@{BackEnd}}
\subsubsection[{stat\_\-com\_\-swp}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf stat\_\-com\_\-swp}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a2c3ec644af0af2970d0066b987427b46}
\hypertarget{classBackEnd_ae29aa2d4ae440022daaed1107eb306b3}{
\index{BackEnd@{BackEnd}!status@{status}}
\index{status@{status}!BackEnd@{BackEnd}}
\subsubsection[{status}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Status} {\bf status}}}
\label{classBackEnd_ae29aa2d4ae440022daaed1107eb306b3}
\hypertarget{classBackEnd_a4455a4759e69e5ebe68ae7298cbcc37d}{
\index{BackEnd@{BackEnd}!tc@{tc}}
\index{tc@{tc}!BackEnd@{BackEnd}}
\subsubsection[{tc}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadContext}$\ast$ {\bf tc}}}
\label{classBackEnd_a4455a4759e69e5ebe68ae7298cbcc37d}
\hypertarget{classBackEnd_ae3369c2288f4867553aaca811229bd3c}{
\index{BackEnd@{BackEnd}!tcSquash@{tcSquash}}
\index{tcSquash@{tcSquash}!BackEnd@{BackEnd}}
\subsubsection[{tcSquash}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf tcSquash}}}
\label{classBackEnd_ae3369c2288f4867553aaca811229bd3c}
\hypertarget{classBackEnd_a743989b66f3b52f1eda2a8498a93da0b}{
\index{BackEnd@{BackEnd}!thread@{thread}}
\index{thread@{thread}!BackEnd@{BackEnd}}
\subsubsection[{thread}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Thread}$\ast$ {\bf thread}}}
\label{classBackEnd_a743989b66f3b52f1eda2a8498a93da0b}
\hypertarget{classBackEnd_acf56450a952ce19a7cc68c86f0334c0c}{
\index{BackEnd@{BackEnd}!toIEW@{toIEW}}
\index{toIEW@{toIEW}!BackEnd@{BackEnd}}
\subsubsection[{toIEW}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf CommStruct}$>$::wire {\bf toIEW}}}
\label{classBackEnd_acf56450a952ce19a7cc68c86f0334c0c}
\hypertarget{classBackEnd_ac715c98888746617df195a858e4a13a4}{
\index{BackEnd@{BackEnd}!wb\_\-fanout@{wb\_\-fanout}}
\index{wb\_\-fanout@{wb\_\-fanout}!BackEnd@{BackEnd}}
\subsubsection[{wb\_\-fanout}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf wb\_\-fanout}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_ac715c98888746617df195a858e4a13a4}
\hypertarget{classBackEnd_adf6ccbeee5b1388f198d050e098df8d5}{
\index{BackEnd@{BackEnd}!wb\_\-penalized@{wb\_\-penalized}}
\index{wb\_\-penalized@{wb\_\-penalized}!BackEnd@{BackEnd}}
\subsubsection[{wb\_\-penalized}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf wb\_\-penalized}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_adf6ccbeee5b1388f198d050e098df8d5}
\hypertarget{classBackEnd_a3f801d7a68c69a6b19ef993fcbad1453}{
\index{BackEnd@{BackEnd}!wb\_\-penalized\_\-rate@{wb\_\-penalized\_\-rate}}
\index{wb\_\-penalized\_\-rate@{wb\_\-penalized\_\-rate}!BackEnd@{BackEnd}}
\subsubsection[{wb\_\-penalized\_\-rate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf wb\_\-penalized\_\-rate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a3f801d7a68c69a6b19ef993fcbad1453}
\hypertarget{classBackEnd_ae3e32acce8acd38434b6efd36ea6198e}{
\index{BackEnd@{BackEnd}!wb\_\-rate@{wb\_\-rate}}
\index{wb\_\-rate@{wb\_\-rate}!BackEnd@{BackEnd}}
\subsubsection[{wb\_\-rate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf wb\_\-rate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_ae3e32acce8acd38434b6efd36ea6198e}
\hypertarget{classBackEnd_ad2c7b2687f864f2b7359eb393276996f}{
\index{BackEnd@{BackEnd}!wbCycle@{wbCycle}}
\index{wbCycle@{wbCycle}!BackEnd@{BackEnd}}
\subsubsection[{wbCycle}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf wbCycle}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_ad2c7b2687f864f2b7359eb393276996f}
Cycle number within the queue of instructions being written back. Used in case there are too many instructions writing back at the current cycle and writesbacks need to be scheduled for the future. See comments in \hyperlink{classBackEnd_a720e9865ffa6e84b756f5ec1d1a24d94}{instToCommit()}. \hypertarget{classBackEnd_a5fa0799bf5569437190dd1eda1d62b7b}{
\index{BackEnd@{BackEnd}!wbNumInst@{wbNumInst}}
\index{wbNumInst@{wbNumInst}!BackEnd@{BackEnd}}
\subsubsection[{wbNumInst}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf wbNumInst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a5fa0799bf5569437190dd1eda1d62b7b}
Index into queue of instructions being written back. \hypertarget{classBackEnd_a20d3086e6bcdc826d99143ac7c9b23a4}{
\index{BackEnd@{BackEnd}!wbWidth@{wbWidth}}
\index{wbWidth@{wbWidth}!BackEnd@{BackEnd}}
\subsubsection[{wbWidth}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf wbWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a20d3086e6bcdc826d99143ac7c9b23a4}
\hypertarget{classBackEnd_a2474a5474cbff19523a51eb1de01cda4}{
\index{BackEnd@{BackEnd}!width@{width}}
\index{width@{width}!BackEnd@{BackEnd}}
\subsubsection[{width}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf width}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a2474a5474cbff19523a51eb1de01cda4}
\hypertarget{classBackEnd_ae4b76f4612be07d13b349e13ee9dfa16}{
\index{BackEnd@{BackEnd}!writeback@{writeback}}
\index{writeback@{writeback}!BackEnd@{BackEnd}}
\subsubsection[{writeback}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf writeback}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_ae4b76f4612be07d13b349e13ee9dfa16}
\hypertarget{classBackEnd_a1b89675ac5b779ab9ead5ae5d3550189}{
\index{BackEnd@{BackEnd}!writeback\_\-count@{writeback\_\-count}}
\index{writeback\_\-count@{writeback\_\-count}!BackEnd@{BackEnd}}
\subsubsection[{writeback\_\-count}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf writeback\_\-count}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBackEnd_a1b89675ac5b779ab9ead5ae5d3550189}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/ozone/\hyperlink{back__end_8hh}{back\_\-end.hh}\item 
cpu/ozone/\hyperlink{back__end__impl_8hh}{back\_\-end\_\-impl.hh}\end{DoxyCompactItemize}
