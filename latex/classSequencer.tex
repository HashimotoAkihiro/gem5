\hypertarget{classSequencer}{
\section{クラス Sequencer}
\label{classSequencer}\index{Sequencer@{Sequencer}}
}


{\ttfamily \#include $<$Sequencer.hh$>$}Sequencerに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=6cm]{classSequencer}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classSequencer_1_1DMASequencer}{DMASequencer}
\item 
class \hyperlink{classSequencer_1_1RubyPort}{RubyPort}
\item 
class \hyperlink{classSequencer_1_1RubyPortProxy}{RubyPortProxy}
\item 
class \hyperlink{classSequencer_1_1RubySequencer}{RubySequencer}
\item 
class \hyperlink{classSequencer_1_1SequencerWakeupEvent}{SequencerWakeupEvent}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef RubySequencerParams \hyperlink{classSequencer_a55b8bba242820df379c5d9139a854e5b}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSequencer_a5f15f2d0a36488220062dc04ca597b6e}{Sequencer} (const \hyperlink{classSequencer_a55b8bba242820df379c5d9139a854e5b}{Params} $\ast$)
\item 
\hyperlink{classSequencer_a33e9de4a3e9618f014e48385c51abe67}{$\sim$Sequencer} ()
\item 
void \hyperlink{classSequencer_ae674290a26ecbd622c5160e38e8a4fe9}{wakeup} ()
\item 
void \hyperlink{classSequencer_a5108f0f12fa601b4c6713ee79510ef83}{printProgress} (std::ostream \&out) const 
\item 
void \hyperlink{classSequencer_a65880e61108132689a1bd769b9187fb7}{resetStats} ()
\item 
void \hyperlink{classSequencer_a208669cbc0bb1d52565956ca8c690c55}{collateStats} ()
\item 
void \hyperlink{classSequencer_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classSequencer_a97f81494e28695a87ea2fdc0346ceb30}{writeCallback} (const \hyperlink{classAddress}{Address} \&address, \hyperlink{classDataBlock}{DataBlock} \&data, const bool externalHit=false, const MachineType mach=MachineType\_\-NUM, const \hyperlink{classCycles}{Cycles} initialRequestTime=\hyperlink{classCycles}{Cycles}(0), const \hyperlink{classCycles}{Cycles} forwardRequestTime=\hyperlink{classCycles}{Cycles}(0), const \hyperlink{classCycles}{Cycles} firstResponseTime=\hyperlink{classCycles}{Cycles}(0))
\item 
void \hyperlink{classSequencer_a6b6826ba925b0aa2cad4601dcb8dd5ee}{readCallback} (const \hyperlink{classAddress}{Address} \&address, \hyperlink{classDataBlock}{DataBlock} \&data, const bool externalHit=false, const MachineType mach=MachineType\_\-NUM, const \hyperlink{classCycles}{Cycles} initialRequestTime=\hyperlink{classCycles}{Cycles}(0), const \hyperlink{classCycles}{Cycles} forwardRequestTime=\hyperlink{classCycles}{Cycles}(0), const \hyperlink{classCycles}{Cycles} firstResponseTime=\hyperlink{classCycles}{Cycles}(0))
\item 
RequestStatus \hyperlink{classSequencer_a23de6e3fbb2362f4410d435e3600d0f7}{makeRequest} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classSequencer_ac6e61de369e994009e36f344f99c15ad}{empty} () const 
\item 
int \hyperlink{classSequencer_ae47593dc86baa86bf047ad1fbcdcceed}{outstandingCount} () const 
\item 
bool \hyperlink{classSequencer_a11ce018fbd3aa89624b06dbdafbd4ef9}{isDeadlockEventScheduled} () const 
\item 
void \hyperlink{classSequencer_a7c9a8861621a62055761f47310814762}{descheduleDeadlockEvent} ()
\item 
void \hyperlink{classSequencer_ac55fe386a101fbae38c716067c9966a0}{print} (std::ostream \&out) const 
\item 
void \hyperlink{classSequencer_a381b1e1191b76356f0a37f22b3d19c52}{checkCoherence} (const \hyperlink{classAddress}{Address} \&address)
\item 
void \hyperlink{classSequencer_a2e67c7ecd7fa83154e841e80a502130d}{markRemoved} ()
\item 
void \hyperlink{classSequencer_a525e0db39943b198c53fc6e8356f6050}{removeRequest} (\hyperlink{structSequencerRequest}{SequencerRequest} $\ast$request)
\item 
void \hyperlink{classSequencer_a3af79aeefd596a230ebc3a579fcc3fb1}{evictionCallback} (const \hyperlink{classAddress}{Address} \&address)
\item 
void \hyperlink{classSequencer_ab328ca1fdc98e525561d4fc99de4757c}{invalidateSC} (const \hyperlink{classAddress}{Address} \&address)
\item 
void \hyperlink{classSequencer_a2fa76b7c47843db1ca8a852a1b4fdb49}{recordRequestType} (SequencerRequestType requestType)
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \& \hyperlink{classSequencer_aad0db21fdf9ff4bdf60a45e0eea9ef12}{getOutstandReqHist} ()
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \& \hyperlink{classSequencer_ac46dd25fc33d37a54c700053c1f79314}{getLatencyHist} ()
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \& \hyperlink{classSequencer_ad93cd72a0644b8593762e57de8dcaef3}{getTypeLatencyHist} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} t)
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \& \hyperlink{classSequencer_a60d594e19c05f710687dabeccab69cb4}{getHitLatencyHist} ()
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \& \hyperlink{classSequencer_a4996199be67d053287bec8a2fa742ee0}{getHitTypeLatencyHist} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} t)
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \& \hyperlink{classSequencer_a1923ce01b6ae7bce28ca59c6df159058}{getHitMachLatencyHist} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} t)
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \& \hyperlink{classSequencer_a7d6dd3224cae81bef46bd66b8923f3ca}{getHitTypeMachLatencyHist} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} r, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} t)
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \& \hyperlink{classSequencer_ac9bb113b7a017a3530b476b4a6a86995}{getMissLatencyHist} ()
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \& \hyperlink{classSequencer_acca7e48b22f04eb014984ab493afe1e0}{getMissTypeLatencyHist} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} t)
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \& \hyperlink{classSequencer_a3ebf605b76407a53e0c62c2578cc7248}{getMissMachLatencyHist} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} t) const 
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \& \hyperlink{classSequencer_a72d6c50e8af0a27e656f731aa0196daa}{getMissTypeMachLatencyHist} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} r, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} t) const 
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \& \hyperlink{classSequencer_a27018ff7465a95b74e4271af0669d480}{getIssueToInitialDelayHist} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} t) const 
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \& \hyperlink{classSequencer_a56ef3b1fa82226933191e723ad52cf12}{getInitialToForwardDelayHist} (const MachineType t) const 
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \& \hyperlink{classSequencer_a39c21f2486b1d7dc3ca2a11ddf5378ce}{getForwardRequestToFirstResponseHist} (const MachineType t) const 
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \& \hyperlink{classSequencer_a9f0e5366d9f6881645645f94fa07f5df}{getFirstResponseToCompletionDelayHist} (const MachineType t) const 
\item 
\hyperlink{namespaceStats_ac35128c026c72bb36af9cea00774e8a6}{Stats::Counter} \hyperlink{classSequencer_a24bd4dceacbe5dac96e549c7b1b42717}{getIncompleteTimes} (const MachineType t) const 
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef m5::hash\_\-map$<$ \hyperlink{classAddress}{Address}, \hyperlink{structSequencerRequest}{SequencerRequest} $\ast$ $>$ \hyperlink{classSequencer_ab8b07c7968ec41f243eeb0c53e459bb8}{RequestTable}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classSequencer_adf180308d81a9eade08f190a0b220c6d}{issueRequest} (\hyperlink{classPacket}{PacketPtr} pkt, RubyRequestType \hyperlink{classSequencer_1_1RubyPort_acce15679d830831b0bbe8ebc2a60b2ca}{type})
\item 
void \hyperlink{classSequencer_ae5b978643179033488a1153899c085e5}{hitCallback} (\hyperlink{structSequencerRequest}{SequencerRequest} $\ast$request, \hyperlink{classDataBlock}{DataBlock} \&data, bool llscSuccess, const MachineType mach, const bool externalHit, const \hyperlink{classCycles}{Cycles} initialRequestTime, const \hyperlink{classCycles}{Cycles} forwardRequestTime, const \hyperlink{classCycles}{Cycles} firstResponseTime)
\item 
void \hyperlink{classSequencer_a37b774f897c19e6a2a84d89aeb3f5b45}{recordMissLatency} (const \hyperlink{classCycles}{Cycles} t, const RubyRequestType \hyperlink{classSequencer_1_1RubyPort_acce15679d830831b0bbe8ebc2a60b2ca}{type}, const MachineType respondingMach, bool isExternalHit, \hyperlink{classCycles}{Cycles} issuedTime, \hyperlink{classCycles}{Cycles} initialRequestTime, \hyperlink{classCycles}{Cycles} forwardRequestTime, \hyperlink{classCycles}{Cycles} firstResponseTime, \hyperlink{classCycles}{Cycles} completionTime)
\item 
RequestStatus \hyperlink{classSequencer_ad7e26bff5c0772136a69fc46fb6b6b21}{insertRequest} (\hyperlink{classPacket}{PacketPtr} pkt, RubyRequestType request\_\-type)
\item 
bool \hyperlink{classSequencer_add40b4adaa2c154a2c81fcebc9ff4aaf}{handleLlsc} (const \hyperlink{classAddress}{Address} \&address, \hyperlink{structSequencerRequest}{SequencerRequest} $\ast$request)
\item 
\hyperlink{classSequencer_a59cf565c114ce83354332f4f49b9add0}{Sequencer} (const \hyperlink{classSequencer}{Sequencer} \&obj)
\item 
\hyperlink{classSequencer}{Sequencer} \& \hyperlink{classSequencer_ad3a4eee2c15f83ff25ee60d438602e6b}{operator=} (const \hyperlink{classSequencer}{Sequencer} \&obj)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classSequencer_aa4e402fb0283ff3547ee82785e7a66c3}{m\_\-max\_\-outstanding\_\-requests}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classSequencer_a4760ee57ee761ad53400a617eb12e95a}{m\_\-deadlock\_\-threshold}
\item 
\hyperlink{classCacheMemory}{CacheMemory} $\ast$ \hyperlink{classSequencer_a7a3b3fe88942aab5003a24c6f1da4428}{m\_\-dataCache\_\-ptr}
\item 
\hyperlink{classCacheMemory}{CacheMemory} $\ast$ \hyperlink{classSequencer_ad75cc69f67160a8550641442ffdb6a47}{m\_\-instCache\_\-ptr}
\item 
\hyperlink{classSequencer_ab8b07c7968ec41f243eeb0c53e459bb8}{RequestTable} \hyperlink{classSequencer_ad419eb325e663790853ec757ca3b02aa}{m\_\-writeRequestTable}
\item 
\hyperlink{classSequencer_ab8b07c7968ec41f243eeb0c53e459bb8}{RequestTable} \hyperlink{classSequencer_a50b1d01ac64e8f892be4a49998965cda}{m\_\-readRequestTable}
\item 
int \hyperlink{classSequencer_a5d645b1dc48106eac07688fc8c65edd2}{m\_\-outstanding\_\-count}
\item 
bool \hyperlink{classSequencer_a2e50c90663719c912c32881d58f1bd01}{m\_\-deadlock\_\-check\_\-scheduled}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classSequencer_a6d186a780be6aa79db648192dd730779}{m\_\-store\_\-waiting\_\-on\_\-load}
\begin{DoxyCompactList}\small\item\em Counters for recording aliasing information. \item\end{DoxyCompactList}\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classSequencer_a79cb8a27dd783e3c7298d8d874795b3d}{m\_\-store\_\-waiting\_\-on\_\-store}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classSequencer_a8e5427a5d38caa118425b87f68c8b8c0}{m\_\-load\_\-waiting\_\-on\_\-store}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classSequencer_a19936e24600f4fafad29833ae73051fa}{m\_\-load\_\-waiting\_\-on\_\-load}
\item 
bool \hyperlink{classSequencer_a6e3aaea8b048e1811c53f89dfb99260e}{m\_\-usingNetworkTester}
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \hyperlink{classSequencer_a24e9160c0860bc93a5f57de63544fe65}{m\_\-outstandReqHist}
\begin{DoxyCompactList}\small\item\em \hyperlink{classHistogram}{Histogram} for number of outstanding requests per cycle. \item\end{DoxyCompactList}\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \hyperlink{classSequencer_aeb3fc96d5f4638c5599ed141c6c6bda7}{m\_\-latencyHist}
\begin{DoxyCompactList}\small\item\em \hyperlink{classHistogram}{Histogram} for holding latency profile of all requests. \item\end{DoxyCompactList}\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classStats_1_1Histogram}{Stats::Histogram} $\ast$ $>$ \hyperlink{classSequencer_a21453ca0672126e1c0e204b7c60b3340}{m\_\-typeLatencyHist}
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \hyperlink{classSequencer_aa7b4f1cb2f6f69fac85f5fa0be12f95a}{m\_\-hitLatencyHist}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classStats_1_1Histogram}{Stats::Histogram} $\ast$ $>$ \hyperlink{classSequencer_aeecaf5411cd3b34435f621db03387b67}{m\_\-hitTypeLatencyHist}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classStats_1_1Histogram}{Stats::Histogram} $\ast$ $>$ \hyperlink{classSequencer_add8e2c73ddfe42f1b177e641a0e626d5}{m\_\-hitMachLatencyHist}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classStats_1_1Histogram}{Stats::Histogram} $\ast$ $>$ $>$ \hyperlink{classSequencer_aaf855f02483dc21743651007a759ea77}{m\_\-hitTypeMachLatencyHist}
\item 
\hyperlink{classStats_1_1Histogram}{Stats::Histogram} \hyperlink{classSequencer_aff6841cbe8b6a9be485b4c45a8208f93}{m\_\-missLatencyHist}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classStats_1_1Histogram}{Stats::Histogram} $\ast$ $>$ \hyperlink{classSequencer_ac5a934c0abe9f0185357eb76de27dee3}{m\_\-missTypeLatencyHist}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classStats_1_1Histogram}{Stats::Histogram} $\ast$ $>$ \hyperlink{classSequencer_a55e994bce4da18f7600be6cbf7a4a3b5}{m\_\-missMachLatencyHist}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classStats_1_1Histogram}{Stats::Histogram} $\ast$ $>$ $>$ \hyperlink{classSequencer_a8e022aebc37a4b83df56956874befd75}{m\_\-missTypeMachLatencyHist}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classStats_1_1Histogram}{Stats::Histogram} $\ast$ $>$ \hyperlink{classSequencer_a503562ca3d885333c87da80d05ee612a}{m\_\-IssueToInitialDelayHist}
\begin{DoxyCompactList}\small\item\em Histograms for recording the breakdown of miss latency. \item\end{DoxyCompactList}\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classStats_1_1Histogram}{Stats::Histogram} $\ast$ $>$ \hyperlink{classSequencer_a0dbfb83f6edf61cad3d0aebdc89ed370}{m\_\-InitialToForwardDelayHist}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classStats_1_1Histogram}{Stats::Histogram} $\ast$ $>$ \hyperlink{classSequencer_ae9bea11c9b001a155e7f7a0f39ac7bf9}{m\_\-ForwardToFirstResponseDelayHist}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classStats_1_1Histogram}{Stats::Histogram} $\ast$ $>$ \hyperlink{classSequencer_a6236c49462f2162310ca62569ec869ac}{m\_\-FirstResponseToCompletionDelayHist}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{namespaceStats_ac35128c026c72bb36af9cea00774e8a6}{Stats::Counter} $>$ \hyperlink{classSequencer_a42ce5f1f915ac19c7e7575172f28e412}{m\_\-IncompleteTimes}
\item 
\hyperlink{classSequencer_1_1SequencerWakeupEvent}{SequencerWakeupEvent} \hyperlink{classSequencer_a1898c82aec1a510eaa5aa55cb23a5bc3}{deadlockCheckEvent}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classSequencer_a55b8bba242820df379c5d9139a854e5b}{
\index{Sequencer@{Sequencer}!Params@{Params}}
\index{Params@{Params}!Sequencer@{Sequencer}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef RubySequencerParams {\bf Params}}}
\label{classSequencer_a55b8bba242820df379c5d9139a854e5b}


\hyperlink{classMemObject_a905bbc621eeec0ed08859e21c8c95412}{MemObject}を再定義しています。\hypertarget{classSequencer_ab8b07c7968ec41f243eeb0c53e459bb8}{
\index{Sequencer@{Sequencer}!RequestTable@{RequestTable}}
\index{RequestTable@{RequestTable}!Sequencer@{Sequencer}}
\subsubsection[{RequestTable}]{\setlength{\rightskip}{0pt plus 5cm}typedef m5::hash\_\-map$<${\bf Address}, {\bf SequencerRequest}$\ast$$>$ {\bf RequestTable}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_ab8b07c7968ec41f243eeb0c53e459bb8}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classSequencer_a5f15f2d0a36488220062dc04ca597b6e}{
\index{Sequencer@{Sequencer}!Sequencer@{Sequencer}}
\index{Sequencer@{Sequencer}!Sequencer@{Sequencer}}
\subsubsection[{Sequencer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Sequencer} (const {\bf Params} $\ast$ {\em p})}}
\label{classSequencer_a5f15f2d0a36488220062dc04ca597b6e}



\begin{DoxyCode}
58     : RubyPort(p), m_IncompleteTimes(MachineType_NUM), deadlockCheckEvent(this)
59 {
60     m_outstanding_count = 0;
61 
62     m_instCache_ptr = p->icache;
63     m_dataCache_ptr = p->dcache;
64     m_max_outstanding_requests = p->max_outstanding_requests;
65     m_deadlock_threshold = p->deadlock_threshold;
66 
67     assert(m_max_outstanding_requests > 0);
68     assert(m_deadlock_threshold > 0);
69     assert(m_instCache_ptr != NULL);
70     assert(m_dataCache_ptr != NULL);
71 
72     m_usingNetworkTester = p->using_network_tester;
73 }
\end{DoxyCode}
\hypertarget{classSequencer_a33e9de4a3e9618f014e48385c51abe67}{
\index{Sequencer@{Sequencer}!$\sim$Sequencer@{$\sim$Sequencer}}
\index{$\sim$Sequencer@{$\sim$Sequencer}!Sequencer@{Sequencer}}
\subsubsection[{$\sim$Sequencer}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf Sequencer} ()}}
\label{classSequencer_a33e9de4a3e9618f014e48385c51abe67}



\begin{DoxyCode}
76 {
77 }
\end{DoxyCode}
\hypertarget{classSequencer_a59cf565c114ce83354332f4f49b9add0}{
\index{Sequencer@{Sequencer}!Sequencer@{Sequencer}}
\index{Sequencer@{Sequencer}!Sequencer@{Sequencer}}
\subsubsection[{Sequencer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Sequencer} (const {\bf Sequencer} \& {\em obj})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a59cf565c114ce83354332f4f49b9add0}


\subsection{関数}
\hypertarget{classSequencer_a381b1e1191b76356f0a37f22b3d19c52}{
\index{Sequencer@{Sequencer}!checkCoherence@{checkCoherence}}
\index{checkCoherence@{checkCoherence}!Sequencer@{Sequencer}}
\subsubsection[{checkCoherence}]{\setlength{\rightskip}{0pt plus 5cm}void checkCoherence (const {\bf Address} \& {\em address})}}
\label{classSequencer_a381b1e1191b76356f0a37f22b3d19c52}



\begin{DoxyCode}
739 {
740 #ifdef CHECK_COHERENCE
741     g_system_ptr->checkGlobalCoherenceInvariant(addr);
742 #endif
743 }
\end{DoxyCode}
\hypertarget{classSequencer_a208669cbc0bb1d52565956ca8c690c55}{
\index{Sequencer@{Sequencer}!collateStats@{collateStats}}
\index{collateStats@{collateStats}!Sequencer@{Sequencer}}
\subsubsection[{collateStats}]{\setlength{\rightskip}{0pt plus 5cm}void collateStats ()}}
\label{classSequencer_a208669cbc0bb1d52565956ca8c690c55}
\hypertarget{classSequencer_a7c9a8861621a62055761f47310814762}{
\index{Sequencer@{Sequencer}!descheduleDeadlockEvent@{descheduleDeadlockEvent}}
\index{descheduleDeadlockEvent@{descheduleDeadlockEvent}!Sequencer@{Sequencer}}
\subsubsection[{descheduleDeadlockEvent}]{\setlength{\rightskip}{0pt plus 5cm}void descheduleDeadlockEvent ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_a7c9a8861621a62055761f47310814762}



\begin{DoxyCode}
95     { deschedule(deadlockCheckEvent); }
\end{DoxyCode}
\hypertarget{classSequencer_ac6e61de369e994009e36f344f99c15ad}{
\index{Sequencer@{Sequencer}!empty@{empty}}
\index{empty@{empty}!Sequencer@{Sequencer}}
\subsubsection[{empty}]{\setlength{\rightskip}{0pt plus 5cm}bool empty () const}}
\label{classSequencer_ac6e61de369e994009e36f344f99c15ad}



\begin{DoxyCode}
580 {
581     return m_writeRequestTable.empty() && m_readRequestTable.empty();
582 }
\end{DoxyCode}
\hypertarget{classSequencer_a3af79aeefd596a230ebc3a579fcc3fb1}{
\index{Sequencer@{Sequencer}!evictionCallback@{evictionCallback}}
\index{evictionCallback@{evictionCallback}!Sequencer@{Sequencer}}
\subsubsection[{evictionCallback}]{\setlength{\rightskip}{0pt plus 5cm}void evictionCallback (const {\bf Address} \& {\em address})}}
\label{classSequencer_a3af79aeefd596a230ebc3a579fcc3fb1}



\begin{DoxyCode}
754 {
755     ruby_eviction_callback(address);
756 }
\end{DoxyCode}
\hypertarget{classSequencer_a9f0e5366d9f6881645645f94fa07f5df}{
\index{Sequencer@{Sequencer}!getFirstResponseToCompletionDelayHist@{getFirstResponseToCompletionDelayHist}}
\index{getFirstResponseToCompletionDelayHist@{getFirstResponseToCompletionDelayHist}!Sequencer@{Sequencer}}
\subsubsection[{getFirstResponseToCompletionDelayHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram}\& getFirstResponseToCompletionDelayHist (const MachineType {\em t}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_a9f0e5366d9f6881645645f94fa07f5df}



\begin{DoxyCode}
147     { return *m_FirstResponseToCompletionDelayHist[t]; }
\end{DoxyCode}
\hypertarget{classSequencer_a39c21f2486b1d7dc3ca2a11ddf5378ce}{
\index{Sequencer@{Sequencer}!getForwardRequestToFirstResponseHist@{getForwardRequestToFirstResponseHist}}
\index{getForwardRequestToFirstResponseHist@{getForwardRequestToFirstResponseHist}!Sequencer@{Sequencer}}
\subsubsection[{getForwardRequestToFirstResponseHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram}\& getForwardRequestToFirstResponseHist (const MachineType {\em t}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_a39c21f2486b1d7dc3ca2a11ddf5378ce}



\begin{DoxyCode}
143     { return *m_ForwardToFirstResponseDelayHist[t]; }
\end{DoxyCode}
\hypertarget{classSequencer_a60d594e19c05f710687dabeccab69cb4}{
\index{Sequencer@{Sequencer}!getHitLatencyHist@{getHitLatencyHist}}
\index{getHitLatencyHist@{getHitLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{getHitLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram}\& getHitLatencyHist ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_a60d594e19c05f710687dabeccab69cb4}



\begin{DoxyCode}
112 { return m_hitLatencyHist; }
\end{DoxyCode}
\hypertarget{classSequencer_a1923ce01b6ae7bce28ca59c6df159058}{
\index{Sequencer@{Sequencer}!getHitMachLatencyHist@{getHitMachLatencyHist}}
\index{getHitMachLatencyHist@{getHitMachLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{getHitMachLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram}\& getHitMachLatencyHist ({\bf uint32\_\-t} {\em t})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_a1923ce01b6ae7bce28ca59c6df159058}



\begin{DoxyCode}
117     { return *m_hitMachLatencyHist[t]; }
\end{DoxyCode}
\hypertarget{classSequencer_a4996199be67d053287bec8a2fa742ee0}{
\index{Sequencer@{Sequencer}!getHitTypeLatencyHist@{getHitTypeLatencyHist}}
\index{getHitTypeLatencyHist@{getHitTypeLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{getHitTypeLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram}\& getHitTypeLatencyHist ({\bf uint32\_\-t} {\em t})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_a4996199be67d053287bec8a2fa742ee0}



\begin{DoxyCode}
114     { return *m_hitTypeLatencyHist[t]; }
\end{DoxyCode}
\hypertarget{classSequencer_a7d6dd3224cae81bef46bd66b8923f3ca}{
\index{Sequencer@{Sequencer}!getHitTypeMachLatencyHist@{getHitTypeMachLatencyHist}}
\index{getHitTypeMachLatencyHist@{getHitTypeMachLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{getHitTypeMachLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram}\& getHitTypeMachLatencyHist ({\bf uint32\_\-t} {\em r}, \/  {\bf uint32\_\-t} {\em t})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_a7d6dd3224cae81bef46bd66b8923f3ca}



\begin{DoxyCode}
120     { return *m_hitTypeMachLatencyHist[r][t]; }
\end{DoxyCode}
\hypertarget{classSequencer_a24bd4dceacbe5dac96e549c7b1b42717}{
\index{Sequencer@{Sequencer}!getIncompleteTimes@{getIncompleteTimes}}
\index{getIncompleteTimes@{getIncompleteTimes}!Sequencer@{Sequencer}}
\subsubsection[{getIncompleteTimes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Counter} getIncompleteTimes (const MachineType {\em t}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_a24bd4dceacbe5dac96e549c7b1b42717}



\begin{DoxyCode}
150     { return m_IncompleteTimes[t]; }
\end{DoxyCode}
\hypertarget{classSequencer_a56ef3b1fa82226933191e723ad52cf12}{
\index{Sequencer@{Sequencer}!getInitialToForwardDelayHist@{getInitialToForwardDelayHist}}
\index{getInitialToForwardDelayHist@{getInitialToForwardDelayHist}!Sequencer@{Sequencer}}
\subsubsection[{getInitialToForwardDelayHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram}\& getInitialToForwardDelayHist (const MachineType {\em t}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_a56ef3b1fa82226933191e723ad52cf12}



\begin{DoxyCode}
139     { return *m_InitialToForwardDelayHist[t]; }
\end{DoxyCode}
\hypertarget{classSequencer_a27018ff7465a95b74e4271af0669d480}{
\index{Sequencer@{Sequencer}!getIssueToInitialDelayHist@{getIssueToInitialDelayHist}}
\index{getIssueToInitialDelayHist@{getIssueToInitialDelayHist}!Sequencer@{Sequencer}}
\subsubsection[{getIssueToInitialDelayHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram}\& getIssueToInitialDelayHist ({\bf uint32\_\-t} {\em t}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_a27018ff7465a95b74e4271af0669d480}



\begin{DoxyCode}
135     { return *m_IssueToInitialDelayHist[t]; }
\end{DoxyCode}
\hypertarget{classSequencer_ac46dd25fc33d37a54c700053c1f79314}{
\index{Sequencer@{Sequencer}!getLatencyHist@{getLatencyHist}}
\index{getLatencyHist@{getLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{getLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram}\& getLatencyHist ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_ac46dd25fc33d37a54c700053c1f79314}



\begin{DoxyCode}
108 { return m_latencyHist; }
\end{DoxyCode}
\hypertarget{classSequencer_ac9bb113b7a017a3530b476b4a6a86995}{
\index{Sequencer@{Sequencer}!getMissLatencyHist@{getMissLatencyHist}}
\index{getMissLatencyHist@{getMissLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{getMissLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram}\& getMissLatencyHist ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_ac9bb113b7a017a3530b476b4a6a86995}



\begin{DoxyCode}
123     { return m_missLatencyHist; }
\end{DoxyCode}
\hypertarget{classSequencer_a3ebf605b76407a53e0c62c2578cc7248}{
\index{Sequencer@{Sequencer}!getMissMachLatencyHist@{getMissMachLatencyHist}}
\index{getMissMachLatencyHist@{getMissMachLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{getMissMachLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram}\& getMissMachLatencyHist ({\bf uint32\_\-t} {\em t}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_a3ebf605b76407a53e0c62c2578cc7248}



\begin{DoxyCode}
128     { return *m_missMachLatencyHist[t]; }
\end{DoxyCode}
\hypertarget{classSequencer_acca7e48b22f04eb014984ab493afe1e0}{
\index{Sequencer@{Sequencer}!getMissTypeLatencyHist@{getMissTypeLatencyHist}}
\index{getMissTypeLatencyHist@{getMissTypeLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{getMissTypeLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram}\& getMissTypeLatencyHist ({\bf uint32\_\-t} {\em t})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_acca7e48b22f04eb014984ab493afe1e0}



\begin{DoxyCode}
125     { return *m_missTypeLatencyHist[t]; }
\end{DoxyCode}
\hypertarget{classSequencer_a72d6c50e8af0a27e656f731aa0196daa}{
\index{Sequencer@{Sequencer}!getMissTypeMachLatencyHist@{getMissTypeMachLatencyHist}}
\index{getMissTypeMachLatencyHist@{getMissTypeMachLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{getMissTypeMachLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram}\& getMissTypeMachLatencyHist ({\bf uint32\_\-t} {\em r}, \/  {\bf uint32\_\-t} {\em t}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_a72d6c50e8af0a27e656f731aa0196daa}



\begin{DoxyCode}
132     { return *m_missTypeMachLatencyHist[r][t]; }
\end{DoxyCode}
\hypertarget{classSequencer_aad0db21fdf9ff4bdf60a45e0eea9ef12}{
\index{Sequencer@{Sequencer}!getOutstandReqHist@{getOutstandReqHist}}
\index{getOutstandReqHist@{getOutstandReqHist}!Sequencer@{Sequencer}}
\subsubsection[{getOutstandReqHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram}\& getOutstandReqHist ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_aad0db21fdf9ff4bdf60a45e0eea9ef12}



\begin{DoxyCode}
106 { return m_outstandReqHist; }
\end{DoxyCode}
\hypertarget{classSequencer_ad93cd72a0644b8593762e57de8dcaef3}{
\index{Sequencer@{Sequencer}!getTypeLatencyHist@{getTypeLatencyHist}}
\index{getTypeLatencyHist@{getTypeLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{getTypeLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram}\& getTypeLatencyHist ({\bf uint32\_\-t} {\em t})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_ad93cd72a0644b8593762e57de8dcaef3}



\begin{DoxyCode}
110     { return *m_typeLatencyHist[t]; }
\end{DoxyCode}
\hypertarget{classSequencer_add40b4adaa2c154a2c81fcebc9ff4aaf}{
\index{Sequencer@{Sequencer}!handleLlsc@{handleLlsc}}
\index{handleLlsc@{handleLlsc}!Sequencer@{Sequencer}}
\subsubsection[{handleLlsc}]{\setlength{\rightskip}{0pt plus 5cm}bool handleLlsc (const {\bf Address} \& {\em address}, \/  {\bf SequencerRequest} $\ast$ {\em request})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_add40b4adaa2c154a2c81fcebc9ff4aaf}



\begin{DoxyCode}
334 {
335     //
336     // The success flag indicates whether the LLSC operation was successful.
337     // LL ops will always succeed, but SC may fail if the cache line is no
338     // longer locked.
339     //
340     bool success = true;
341     if (request->m_type == RubyRequestType_Store_Conditional) {
342         if (!m_dataCache_ptr->isLocked(address, m_version)) {
343             //
344             // For failed SC requests, indicate the failure to the cpu by
345             // setting the extra data to zero.
346             //
347             request->pkt->req->setExtraData(0);
348             success = false;
349         } else {
350             //
351             // For successful SC requests, indicate the success to the cpu by
352             // setting the extra data to one.  
353             //
354             request->pkt->req->setExtraData(1);
355         }
356         //
357         // Independent of success, all SC operations must clear the lock
358         //
359         m_dataCache_ptr->clearLocked(address);
360     } else if (request->m_type == RubyRequestType_Load_Linked) {
361         //
362         // Note: To fully follow Alpha LLSC semantics, should the LL clear any
363         // previously locked cache lines?
364         //
365         m_dataCache_ptr->setLocked(address, m_version);
366     } else if ((m_dataCache_ptr->isTagPresent(address)) &&
367                (m_dataCache_ptr->isLocked(address, m_version))) {
368         //
369         // Normal writes should clear the locked address
370         //
371         m_dataCache_ptr->clearLocked(address);
372     }
373     return success;
374 }
\end{DoxyCode}
\hypertarget{classSequencer_ae5b978643179033488a1153899c085e5}{
\index{Sequencer@{Sequencer}!hitCallback@{hitCallback}}
\index{hitCallback@{hitCallback}!Sequencer@{Sequencer}}
\subsubsection[{hitCallback}]{\setlength{\rightskip}{0pt plus 5cm}void hitCallback ({\bf SequencerRequest} $\ast$ {\em request}, \/  {\bf DataBlock} \& {\em data}, \/  bool {\em llscSuccess}, \/  const MachineType {\em mach}, \/  const bool {\em externalHit}, \/  const {\bf Cycles} {\em initialRequestTime}, \/  const {\bf Cycles} {\em forwardRequestTime}, \/  const {\bf Cycles} {\em firstResponseTime})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_ae5b978643179033488a1153899c085e5}



\begin{DoxyCode}
501 {
502     PacketPtr pkt = srequest->pkt;
503     Address request_address(pkt->getAddr());
504     Address request_line_address(pkt->getAddr());
505     request_line_address.makeLineAddress();
506     RubyRequestType type = srequest->m_type;
507     Cycles issued_time = srequest->issue_time;
508 
509     // Set this cache entry to the most recently used
510     if (type == RubyRequestType_IFETCH) {
511         m_instCache_ptr->setMRU(request_line_address);
512     } else {
513         m_dataCache_ptr->setMRU(request_line_address);
514     }
515 
516     assert(curCycle() >= issued_time);
517     Cycles total_latency = curCycle() - issued_time;
518 
519     // Profile the latency for all demand accesses.
520     recordMissLatency(total_latency, type, mach, externalHit, issued_time,
521                       initialRequestTime, forwardRequestTime,
522                       firstResponseTime, curCycle());
523 
524     DPRINTFR(ProtocolTrace, "%15s %3s %10s%20s %6s>%-6s %s %d cycles\n",
525              curTick(), m_version, "Seq",
526              llscSuccess ? "Done" : "SC_Failed", "", "",
527              request_address, total_latency);
528 
529     // update the data
530     if (g_system_ptr->m_warmup_enabled) {
531         assert(pkt->getPtr<uint8_t>(false) != NULL);
532         data.setData(pkt->getPtr<uint8_t>(false),
533                      request_address.getOffset(), pkt->getSize());
534     } else if (pkt->getPtr<uint8_t>(true) != NULL) {
535         if ((type == RubyRequestType_LD) ||
536             (type == RubyRequestType_IFETCH) ||
537             (type == RubyRequestType_RMW_Read) ||
538             (type == RubyRequestType_Locked_RMW_Read) ||
539             (type == RubyRequestType_Load_Linked)) {
540             memcpy(pkt->getPtr<uint8_t>(true),
541                    data.getData(request_address.getOffset(), pkt->getSize()),
542                    pkt->getSize());
543         } else {
544             data.setData(pkt->getPtr<uint8_t>(true),
545                          request_address.getOffset(), pkt->getSize());
546         }
547     } else {
548         DPRINTF(MemoryAccess,
549                 "WARNING.  Data not transfered from Ruby to M5 for type %s\n",
550                 RubyRequestType_to_string(type));
551     }
552 
553     // If using the RubyTester, update the RubyTester sender state's
554     // subBlock with the recieved data.  The tester will later access
555     // this state.
556     if (m_usingRubyTester) {
557         RubyTester::SenderState* testerSenderState =
558             pkt->findNextSenderState<RubyTester::SenderState>();
559         assert(testerSenderState);
560         testerSenderState->subBlock.mergeFrom(data);
561     }
562 
563     delete srequest;
564 
565     if (g_system_ptr->m_warmup_enabled) {
566         assert(pkt->req);
567         delete pkt->req;
568         delete pkt;
569         g_system_ptr->m_cache_recorder->enqueueNextFetchRequest();
570     } else if (g_system_ptr->m_cooldown_enabled) {
571         delete pkt;
572         g_system_ptr->m_cache_recorder->enqueueNextFlushRequest();
573     } else {
574         ruby_hit_callback(pkt);
575     }
576 }
\end{DoxyCode}
\hypertarget{classSequencer_ad7e26bff5c0772136a69fc46fb6b6b21}{
\index{Sequencer@{Sequencer}!insertRequest@{insertRequest}}
\index{insertRequest@{insertRequest}!Sequencer@{Sequencer}}
\subsubsection[{insertRequest}]{\setlength{\rightskip}{0pt plus 5cm}RequestStatus insertRequest ({\bf PacketPtr} {\em pkt}, \/  RubyRequestType {\em request\_\-type})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_ad7e26bff5c0772136a69fc46fb6b6b21}



\begin{DoxyCode}
214 {
215     assert(m_outstanding_count ==
216         (m_writeRequestTable.size() + m_readRequestTable.size()));
217 
218     // See if we should schedule a deadlock check
219     if (!deadlockCheckEvent.scheduled() &&
220         getDrainState() != Drainable::Draining) {
221         schedule(deadlockCheckEvent, clockEdge(m_deadlock_threshold));
222     }
223 
224     Address line_addr(pkt->getAddr());
225     line_addr.makeLineAddress();
226     // Create a default entry, mapping the address to NULL, the cast is
227     // there to make gcc 4.4 happy
228     RequestTable::value_type default_entry(line_addr,
229                                            (SequencerRequest*) NULL);
230 
231     if ((request_type == RubyRequestType_ST) ||
232         (request_type == RubyRequestType_RMW_Read) ||
233         (request_type == RubyRequestType_RMW_Write) ||
234         (request_type == RubyRequestType_Load_Linked) ||
235         (request_type == RubyRequestType_Store_Conditional) ||
236         (request_type == RubyRequestType_Locked_RMW_Read) ||
237         (request_type == RubyRequestType_Locked_RMW_Write) ||
238         (request_type == RubyRequestType_FLUSH)) {
239 
240         // Check if there is any outstanding read request for the same
241         // cache line.
242         if (m_readRequestTable.count(line_addr) > 0) {
243             m_store_waiting_on_load++;
244             return RequestStatus_Aliased;
245         }
246 
247         pair<RequestTable::iterator, bool> r =
248             m_writeRequestTable.insert(default_entry);
249         if (r.second) {
250             RequestTable::iterator i = r.first;
251             i->second = new SequencerRequest(pkt, request_type, curCycle());
252             m_outstanding_count++;
253         } else {
254           // There is an outstanding write request for the cache line
255           m_store_waiting_on_store++;
256           return RequestStatus_Aliased;
257         }
258     } else {
259         // Check if there is any outstanding write request for the same
260         // cache line.
261         if (m_writeRequestTable.count(line_addr) > 0) {
262             m_load_waiting_on_store++;
263             return RequestStatus_Aliased;
264         }
265 
266         pair<RequestTable::iterator, bool> r =
267             m_readRequestTable.insert(default_entry);
268 
269         if (r.second) {
270             RequestTable::iterator i = r.first;
271             i->second = new SequencerRequest(pkt, request_type, curCycle());
272             m_outstanding_count++;
273         } else {
274             // There is an outstanding read request for the cache line
275             m_load_waiting_on_load++;
276             return RequestStatus_Aliased;
277         }
278     }
279 
280     m_outstandReqHist.sample(m_outstanding_count);
281     assert(m_outstanding_count ==
282         (m_writeRequestTable.size() + m_readRequestTable.size()));
283 
284     return RequestStatus_Ready;
285 }
\end{DoxyCode}
\hypertarget{classSequencer_ab328ca1fdc98e525561d4fc99de4757c}{
\index{Sequencer@{Sequencer}!invalidateSC@{invalidateSC}}
\index{invalidateSC@{invalidateSC}!Sequencer@{Sequencer}}
\subsubsection[{invalidateSC}]{\setlength{\rightskip}{0pt plus 5cm}void invalidateSC (const {\bf Address} \& {\em address})}}
\label{classSequencer_ab328ca1fdc98e525561d4fc99de4757c}



\begin{DoxyCode}
320 {
321     RequestTable::iterator i = m_writeRequestTable.find(address);
322     if (i != m_writeRequestTable.end()) {
323         SequencerRequest* request = i->second;
324         // The controller has lost the coherence permissions, hence the lock
325         // on the cache line maintained by the cache should be cleared.
326         if (request->m_type == RubyRequestType_Store_Conditional) {
327             m_dataCache_ptr->clearLocked(address);
328         }
329     }
330 }
\end{DoxyCode}
\hypertarget{classSequencer_a11ce018fbd3aa89624b06dbdafbd4ef9}{
\index{Sequencer@{Sequencer}!isDeadlockEventScheduled@{isDeadlockEventScheduled}}
\index{isDeadlockEventScheduled@{isDeadlockEventScheduled}!Sequencer@{Sequencer}}
\subsubsection[{isDeadlockEventScheduled}]{\setlength{\rightskip}{0pt plus 5cm}bool isDeadlockEventScheduled () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_a11ce018fbd3aa89624b06dbdafbd4ef9}



\begin{DoxyCode}
92     { return deadlockCheckEvent.scheduled(); }
\end{DoxyCode}
\hypertarget{classSequencer_adf180308d81a9eade08f190a0b220c6d}{
\index{Sequencer@{Sequencer}!issueRequest@{issueRequest}}
\index{issueRequest@{issueRequest}!Sequencer@{Sequencer}}
\subsubsection[{issueRequest}]{\setlength{\rightskip}{0pt plus 5cm}void issueRequest ({\bf PacketPtr} {\em pkt}, \/  RubyRequestType {\em type})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_adf180308d81a9eade08f190a0b220c6d}



\begin{DoxyCode}
671 {
672     assert(pkt != NULL);
673     int proc_id = -1;
674     if (pkt->req->hasContextId()) {
675         proc_id = pkt->req->contextId();
676     }
677 
678     // If valid, copy the pc to the ruby request
679     Addr pc = 0;
680     if (pkt->req->hasPC()) {
681         pc = pkt->req->getPC();
682     }
683 
684     RubyRequest *msg = new RubyRequest(clockEdge(), pkt->getAddr(),
685                                        pkt->getPtr<uint8_t>(true),
686                                        pkt->getSize(), pc, secondary_type,
687                                        RubyAccessMode_Supervisor, pkt,
688                                        PrefetchBit_No, proc_id);
689 
690     DPRINTFR(ProtocolTrace, "%15s %3s %10s%20s %6s>%-6s %s %s\n",
691             curTick(), m_version, "Seq", "Begin", "", "",
692             msg->getPhysicalAddress(),
693             RubyRequestType_to_string(secondary_type));
694 
695     Cycles latency(0);  // initialzed to an null value
696 
697     if (secondary_type == RubyRequestType_IFETCH)
698         latency = m_instCache_ptr->getLatency();
699     else
700         latency = m_dataCache_ptr->getLatency();
701 
702     // Send the message to the cache controller
703     assert(latency > 0);
704 
705     assert(m_mandatory_q_ptr != NULL);
706     m_mandatory_q_ptr->enqueue(msg, latency);
707 }
\end{DoxyCode}
\hypertarget{classSequencer_a23de6e3fbb2362f4410d435e3600d0f7}{
\index{Sequencer@{Sequencer}!makeRequest@{makeRequest}}
\index{makeRequest@{makeRequest}!Sequencer@{Sequencer}}
\subsubsection[{makeRequest}]{\setlength{\rightskip}{0pt plus 5cm}RequestStatus makeRequest ({\bf PacketPtr} {\em pkt})}}
\label{classSequencer_a23de6e3fbb2362f4410d435e3600d0f7}



\begin{DoxyCode}
586 {
587     if (m_outstanding_count >= m_max_outstanding_requests) {
588         return RequestStatus_BufferFull;
589     }
590 
591     RubyRequestType primary_type = RubyRequestType_NULL;
592     RubyRequestType secondary_type = RubyRequestType_NULL;
593 
594     if (pkt->isLLSC()) {
595         //
596         // Alpha LL/SC instructions need to be handled carefully by the cache
597         // coherence protocol to ensure they follow the proper semantics. In
598         // particular, by identifying the operations as atomic, the protocol
599         // should understand that migratory sharing optimizations should not
600         // be performed (i.e. a load between the LL and SC should not steal
601         // away exclusive permission).
602         //
603         if (pkt->isWrite()) {
604             DPRINTF(RubySequencer, "Issuing SC\n");
605             primary_type = RubyRequestType_Store_Conditional;
606         } else {
607             DPRINTF(RubySequencer, "Issuing LL\n");
608             assert(pkt->isRead());
609             primary_type = RubyRequestType_Load_Linked;
610         }
611         secondary_type = RubyRequestType_ATOMIC;
612     } else if (pkt->req->isLocked()) {
613         //
614         // x86 locked instructions are translated to store cache coherence
615         // requests because these requests should always be treated as read
616         // exclusive operations and should leverage any migratory sharing
617         // optimization built into the protocol.
618         //
619         if (pkt->isWrite()) {
620             DPRINTF(RubySequencer, "Issuing Locked RMW Write\n");
621             primary_type = RubyRequestType_Locked_RMW_Write;
622         } else {
623             DPRINTF(RubySequencer, "Issuing Locked RMW Read\n");
624             assert(pkt->isRead());
625             primary_type = RubyRequestType_Locked_RMW_Read;
626         }
627         secondary_type = RubyRequestType_ST;
628     } else {
629         if (pkt->isRead()) {
630             if (pkt->req->isInstFetch()) {
631                 primary_type = secondary_type = RubyRequestType_IFETCH;
632             } else {
633 #if THE_ISA == X86_ISA
634                 uint32_t flags = pkt->req->getFlags();
635                 bool storeCheck = flags &
636                         (TheISA::StoreCheck << TheISA::FlagShift);
637 #else
638                 bool storeCheck = false;
639 #endif // X86_ISA
640                 if (storeCheck) {
641                     primary_type = RubyRequestType_RMW_Read;
642                     secondary_type = RubyRequestType_ST;
643                 } else {
644                     primary_type = secondary_type = RubyRequestType_LD;
645                 }
646             }
647         } else if (pkt->isWrite()) {
648             //
649             // Note: M5 packets do not differentiate ST from RMW_Write
650             //
651             primary_type = secondary_type = RubyRequestType_ST;
652         } else if (pkt->isFlush()) {
653           primary_type = secondary_type = RubyRequestType_FLUSH;
654         } else {
655             panic("Unsupported ruby packet type\n");
656         }
657     }
658 
659     RequestStatus status = insertRequest(pkt, primary_type);
660     if (status != RequestStatus_Ready)
661         return status;
662 
663     issueRequest(pkt, secondary_type);
664 
665     // TODO: issue hardware prefetches here
666     return RequestStatus_Issued;
667 }
\end{DoxyCode}
\hypertarget{classSequencer_a2e67c7ecd7fa83154e841e80a502130d}{
\index{Sequencer@{Sequencer}!markRemoved@{markRemoved}}
\index{markRemoved@{markRemoved}!Sequencer@{Sequencer}}
\subsubsection[{markRemoved}]{\setlength{\rightskip}{0pt plus 5cm}void markRemoved ()}}
\label{classSequencer_a2e67c7ecd7fa83154e841e80a502130d}



\begin{DoxyCode}
289 {
290     m_outstanding_count--;
291     assert(m_outstanding_count ==
292            m_writeRequestTable.size() + m_readRequestTable.size());
293 }
\end{DoxyCode}
\hypertarget{classSequencer_ad3a4eee2c15f83ff25ee60d438602e6b}{
\index{Sequencer@{Sequencer}!operator=@{operator=}}
\index{operator=@{operator=}!Sequencer@{Sequencer}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Sequencer}\& operator= (const {\bf Sequencer} \& {\em obj})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_ad3a4eee2c15f83ff25ee60d438602e6b}
\hypertarget{classSequencer_ae47593dc86baa86bf047ad1fbcdcceed}{
\index{Sequencer@{Sequencer}!outstandingCount@{outstandingCount}}
\index{outstandingCount@{outstandingCount}!Sequencer@{Sequencer}}
\subsubsection[{outstandingCount}]{\setlength{\rightskip}{0pt plus 5cm}int outstandingCount () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSequencer_ae47593dc86baa86bf047ad1fbcdcceed}



\begin{DoxyCode}
89 { return m_outstanding_count; }
\end{DoxyCode}
\hypertarget{classSequencer_ac55fe386a101fbae38c716067c9966a0}{
\index{Sequencer@{Sequencer}!print@{print}}
\index{print@{print}!Sequencer@{Sequencer}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}void print (std::ostream \& {\em out}) const}}
\label{classSequencer_ac55fe386a101fbae38c716067c9966a0}
\hypertarget{classSequencer_a5108f0f12fa601b4c6713ee79510ef83}{
\index{Sequencer@{Sequencer}!printProgress@{printProgress}}
\index{printProgress@{printProgress}!Sequencer@{Sequencer}}
\subsubsection[{printProgress}]{\setlength{\rightskip}{0pt plus 5cm}void printProgress (std::ostream \& {\em out}) const}}
\label{classSequencer_a5108f0f12fa601b4c6713ee79510ef83}
\hypertarget{classSequencer_a6b6826ba925b0aa2cad4601dcb8dd5ee}{
\index{Sequencer@{Sequencer}!readCallback@{readCallback}}
\index{readCallback@{readCallback}!Sequencer@{Sequencer}}
\subsubsection[{readCallback}]{\setlength{\rightskip}{0pt plus 5cm}void readCallback (const {\bf Address} \& {\em address}, \/  {\bf DataBlock} \& {\em data}, \/  const bool {\em externalHit} = {\ttfamily false}, \/  const MachineType {\em mach} = {\ttfamily MachineType\_\-NUM}, \/  const {\bf Cycles} {\em initialRequestTime} = {\ttfamily {\bf Cycles}(0)}, \/  const {\bf Cycles} {\em forwardRequestTime} = {\ttfamily {\bf Cycles}(0)}, \/  const {\bf Cycles} {\em firstResponseTime} = {\ttfamily {\bf Cycles}(0)})}}
\label{classSequencer_a6b6826ba925b0aa2cad4601dcb8dd5ee}



\begin{DoxyCode}
476 {
477     assert(address == line_address(address));
478     assert(m_readRequestTable.count(line_address(address)));
479 
480     RequestTable::iterator i = m_readRequestTable.find(address);
481     assert(i != m_readRequestTable.end());
482     SequencerRequest* request = i->second;
483 
484     m_readRequestTable.erase(i);
485     markRemoved();
486 
487     assert((request->m_type == RubyRequestType_LD) ||
488            (request->m_type == RubyRequestType_IFETCH));
489 
490     hitCallback(request, data, true, mach, externalHit,
491                 initialRequestTime, forwardRequestTime, firstResponseTime);
492 }
\end{DoxyCode}
\hypertarget{classSequencer_a37b774f897c19e6a2a84d89aeb3f5b45}{
\index{Sequencer@{Sequencer}!recordMissLatency@{recordMissLatency}}
\index{recordMissLatency@{recordMissLatency}!Sequencer@{Sequencer}}
\subsubsection[{recordMissLatency}]{\setlength{\rightskip}{0pt plus 5cm}void recordMissLatency (const {\bf Cycles} {\em t}, \/  const RubyRequestType {\em type}, \/  const MachineType {\em respondingMach}, \/  bool {\em isExternalHit}, \/  {\bf Cycles} {\em issuedTime}, \/  {\bf Cycles} {\em initialRequestTime}, \/  {\bf Cycles} {\em forwardRequestTime}, \/  {\bf Cycles} {\em firstResponseTime}, \/  {\bf Cycles} {\em completionTime})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a37b774f897c19e6a2a84d89aeb3f5b45}



\begin{DoxyCode}
383 {
384     m_latencyHist.sample(cycles);
385     m_typeLatencyHist[type]->sample(cycles);
386 
387     if (isExternalHit) {
388         m_missLatencyHist.sample(cycles);
389         m_missTypeLatencyHist[type]->sample(cycles);
390 
391         if (respondingMach != MachineType_NUM) {
392             m_missMachLatencyHist[respondingMach]->sample(cycles);
393             m_missTypeMachLatencyHist[type][respondingMach]->sample(cycles);
394 
395             if ((issuedTime <= initialRequestTime) &&
396                 (initialRequestTime <= forwardRequestTime) &&
397                 (forwardRequestTime <= firstResponseTime) &&
398                 (firstResponseTime <= completionTime)) {
399 
400                 m_IssueToInitialDelayHist[respondingMach]->sample(
401                     initialRequestTime - issuedTime);
402                 m_InitialToForwardDelayHist[respondingMach]->sample(
403                     forwardRequestTime - initialRequestTime);
404                 m_ForwardToFirstResponseDelayHist[respondingMach]->sample(
405                     firstResponseTime - forwardRequestTime);
406                 m_FirstResponseToCompletionDelayHist[respondingMach]->sample(
407                     completionTime - firstResponseTime);
408             } else {
409                 m_IncompleteTimes[respondingMach]++;
410             }
411         }
412     } else {
413         m_hitLatencyHist.sample(cycles);
414         m_hitTypeLatencyHist[type]->sample(cycles);
415 
416         if (respondingMach != MachineType_NUM) {
417             m_hitMachLatencyHist[respondingMach]->sample(cycles);
418             m_hitTypeMachLatencyHist[type][respondingMach]->sample(cycles);
419         }
420     }
421 }
\end{DoxyCode}
\hypertarget{classSequencer_a2fa76b7c47843db1ca8a852a1b4fdb49}{
\index{Sequencer@{Sequencer}!recordRequestType@{recordRequestType}}
\index{recordRequestType@{recordRequestType}!Sequencer@{Sequencer}}
\subsubsection[{recordRequestType}]{\setlength{\rightskip}{0pt plus 5cm}void recordRequestType (SequencerRequestType {\em requestType})}}
\label{classSequencer_a2fa76b7c47843db1ca8a852a1b4fdb49}



\begin{DoxyCode}
746                                                              {
747     DPRINTF(RubyStats, "Recorded statistic: %s\n",
748             SequencerRequestType_to_string(requestType));
749 }
\end{DoxyCode}
\hypertarget{classSequencer_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{Sequencer@{Sequencer}!regStats@{regStats}}
\index{regStats@{regStats}!Sequencer@{Sequencer}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSequencer_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} statistics for this object. 

\hyperlink{classSimObject_a4dc637449366fcdfc4e764cdf12d9b11}{SimObject}を再定義しています。


\begin{DoxyCode}
760 {
761     m_store_waiting_on_load
762         .name(name() + ".store_waiting_on_load")
763         .desc("Number of times a store aliased with a pending load")
764         .flags(Stats::nozero);
765     m_store_waiting_on_store
766         .name(name() + ".store_waiting_on_store")
767         .desc("Number of times a store aliased with a pending store")
768         .flags(Stats::nozero);
769     m_load_waiting_on_load
770         .name(name() + ".load_waiting_on_load")
771         .desc("Number of times a load aliased with a pending load")
772         .flags(Stats::nozero);
773     m_load_waiting_on_store
774         .name(name() + ".load_waiting_on_store")
775         .desc("Number of times a load aliased with a pending store")
776         .flags(Stats::nozero);
777 
778     // These statistical variables are not for display.
779     // The profiler will collate these across different
780     // sequencers and display those collated statistics.
781     m_outstandReqHist.init(10);
782     m_latencyHist.init(10);
783     m_hitLatencyHist.init(10);
784     m_missLatencyHist.init(10);
785 
786     for (int i = 0; i < RubyRequestType_NUM; i++) {
787         m_typeLatencyHist.push_back(new Stats::Histogram());
788         m_typeLatencyHist[i]->init(10);
789 
790         m_hitTypeLatencyHist.push_back(new Stats::Histogram());
791         m_hitTypeLatencyHist[i]->init(10);
792 
793         m_missTypeLatencyHist.push_back(new Stats::Histogram());
794         m_missTypeLatencyHist[i]->init(10);
795     }
796 
797     for (int i = 0; i < MachineType_NUM; i++) {
798         m_hitMachLatencyHist.push_back(new Stats::Histogram());
799         m_hitMachLatencyHist[i]->init(10);
800 
801         m_missMachLatencyHist.push_back(new Stats::Histogram());
802         m_missMachLatencyHist[i]->init(10);
803 
804         m_IssueToInitialDelayHist.push_back(new Stats::Histogram());
805         m_IssueToInitialDelayHist[i]->init(10);
806 
807         m_InitialToForwardDelayHist.push_back(new Stats::Histogram());
808         m_InitialToForwardDelayHist[i]->init(10);
809 
810         m_ForwardToFirstResponseDelayHist.push_back(new Stats::Histogram());
811         m_ForwardToFirstResponseDelayHist[i]->init(10);
812 
813         m_FirstResponseToCompletionDelayHist.push_back(new Stats::Histogram());
814         m_FirstResponseToCompletionDelayHist[i]->init(10);
815     }
816 
817     for (int i = 0; i < RubyRequestType_NUM; i++) {
818         m_hitTypeMachLatencyHist.push_back(std::vector<Stats::Histogram *>());
819         m_missTypeMachLatencyHist.push_back(std::vector<Stats::Histogram *>());
820 
821         for (int j = 0; j < MachineType_NUM; j++) {
822             m_hitTypeMachLatencyHist[i].push_back(new Stats::Histogram());
823             m_hitTypeMachLatencyHist[i][j]->init(10);
824 
825             m_missTypeMachLatencyHist[i].push_back(new Stats::Histogram());
826             m_missTypeMachLatencyHist[i][j]->init(10);
827         }
828     }
829 }
\end{DoxyCode}
\hypertarget{classSequencer_a525e0db39943b198c53fc6e8356f6050}{
\index{Sequencer@{Sequencer}!removeRequest@{removeRequest}}
\index{removeRequest@{removeRequest}!Sequencer@{Sequencer}}
\subsubsection[{removeRequest}]{\setlength{\rightskip}{0pt plus 5cm}void removeRequest ({\bf SequencerRequest} $\ast$ {\em request})}}
\label{classSequencer_a525e0db39943b198c53fc6e8356f6050}



\begin{DoxyCode}
297 {
298     assert(m_outstanding_count ==
299            m_writeRequestTable.size() + m_readRequestTable.size());
300 
301     Address line_addr(srequest->pkt->getAddr());
302     line_addr.makeLineAddress();
303     if ((srequest->m_type == RubyRequestType_ST) ||
304         (srequest->m_type == RubyRequestType_RMW_Read) ||
305         (srequest->m_type == RubyRequestType_RMW_Write) ||
306         (srequest->m_type == RubyRequestType_Load_Linked) ||
307         (srequest->m_type == RubyRequestType_Store_Conditional) ||
308         (srequest->m_type == RubyRequestType_Locked_RMW_Read) ||
309         (srequest->m_type == RubyRequestType_Locked_RMW_Write)) {
310         m_writeRequestTable.erase(line_addr);
311     } else {
312         m_readRequestTable.erase(line_addr);
313     }
314 
315     markRemoved();
316 }
\end{DoxyCode}
\hypertarget{classSequencer_a65880e61108132689a1bd769b9187fb7}{
\index{Sequencer@{Sequencer}!resetStats@{resetStats}}
\index{resetStats@{resetStats}!Sequencer@{Sequencer}}
\subsubsection[{resetStats}]{\setlength{\rightskip}{0pt plus 5cm}void resetStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSequencer_a65880e61108132689a1bd769b9187fb7}
Reset statistics associated with this object. 

\hyperlink{classSimObject_a65880e61108132689a1bd769b9187fb7}{SimObject}を再定義しています。


\begin{DoxyCode}
132 {
133     m_latencyHist.reset();
134     m_hitLatencyHist.reset();
135     m_missLatencyHist.reset();
136     for (int i = 0; i < RubyRequestType_NUM; i++) {
137         m_typeLatencyHist[i]->reset();
138         m_hitTypeLatencyHist[i]->reset();
139         m_missTypeLatencyHist[i]->reset();
140         for (int j = 0; j < MachineType_NUM; j++) {
141             m_hitTypeMachLatencyHist[i][j]->reset();
142             m_missTypeMachLatencyHist[i][j]->reset();
143         }
144     }
145 
146     for (int i = 0; i < MachineType_NUM; i++) {
147         m_missMachLatencyHist[i]->reset();
148         m_hitMachLatencyHist[i]->reset();
149 
150         m_IssueToInitialDelayHist[i]->reset();
151         m_InitialToForwardDelayHist[i]->reset();
152         m_ForwardToFirstResponseDelayHist[i]->reset();
153         m_FirstResponseToCompletionDelayHist[i]->reset();
154 
155         m_IncompleteTimes[i] = 0;
156     }
157 }
\end{DoxyCode}
\hypertarget{classSequencer_ae674290a26ecbd622c5160e38e8a4fe9}{
\index{Sequencer@{Sequencer}!wakeup@{wakeup}}
\index{wakeup@{wakeup}!Sequencer@{Sequencer}}
\subsubsection[{wakeup}]{\setlength{\rightskip}{0pt plus 5cm}void wakeup ()}}
\label{classSequencer_ae674290a26ecbd622c5160e38e8a4fe9}



\begin{DoxyCode}
81 {
82     assert(getDrainState() != Drainable::Draining);
83 
84     // Check for deadlock of any of the requests
85     Cycles current_time = curCycle();
86 
87     // Check across all outstanding requests
88     int total_outstanding = 0;
89 
90     RequestTable::iterator read = m_readRequestTable.begin();
91     RequestTable::iterator read_end = m_readRequestTable.end();
92     for (; read != read_end; ++read) {
93         SequencerRequest* request = read->second;
94         if (current_time - request->issue_time < m_deadlock_threshold)
95             continue;
96 
97         panic("Possible Deadlock detected. Aborting!\n"
98              "version: %d request.paddr: 0x%x m_readRequestTable: %d "
99              "current time: %u issue_time: %d difference: %d\n", m_version,
100              Address(request->pkt->getAddr()), m_readRequestTable.size(),
101               current_time * clockPeriod(), request->issue_time * clockPeriod(),
102               (current_time * clockPeriod()) - (request->issue_time * 
      clockPeriod()));
103     }
104 
105     RequestTable::iterator write = m_writeRequestTable.begin();
106     RequestTable::iterator write_end = m_writeRequestTable.end();
107     for (; write != write_end; ++write) {
108         SequencerRequest* request = write->second;
109         if (current_time - request->issue_time < m_deadlock_threshold)
110             continue;
111 
112         panic("Possible Deadlock detected. Aborting!\n"
113              "version: %d request.paddr: 0x%x m_writeRequestTable: %d "
114              "current time: %u issue_time: %d difference: %d\n", m_version,
115              Address(request->pkt->getAddr()), m_writeRequestTable.size(),
116               current_time * clockPeriod(), request->issue_time * clockPeriod(),
117               (current_time * clockPeriod()) - (request->issue_time * 
      clockPeriod()));
118     }
119 
120     total_outstanding += m_writeRequestTable.size();
121     total_outstanding += m_readRequestTable.size();
122 
123     assert(m_outstanding_count == total_outstanding);
124 
125     if (m_outstanding_count > 0) {
126         // If there are still outstanding requests, keep checking
127         schedule(deadlockCheckEvent, clockEdge(m_deadlock_threshold));
128     }
129 }
\end{DoxyCode}
\hypertarget{classSequencer_a97f81494e28695a87ea2fdc0346ceb30}{
\index{Sequencer@{Sequencer}!writeCallback@{writeCallback}}
\index{writeCallback@{writeCallback}!Sequencer@{Sequencer}}
\subsubsection[{writeCallback}]{\setlength{\rightskip}{0pt plus 5cm}void writeCallback (const {\bf Address} \& {\em address}, \/  {\bf DataBlock} \& {\em data}, \/  const bool {\em externalHit} = {\ttfamily false}, \/  const MachineType {\em mach} = {\ttfamily MachineType\_\-NUM}, \/  const {\bf Cycles} {\em initialRequestTime} = {\ttfamily {\bf Cycles}(0)}, \/  const {\bf Cycles} {\em forwardRequestTime} = {\ttfamily {\bf Cycles}(0)}, \/  const {\bf Cycles} {\em firstResponseTime} = {\ttfamily {\bf Cycles}(0)})}}
\label{classSequencer_a97f81494e28695a87ea2fdc0346ceb30}



\begin{DoxyCode}
429 {
430     assert(address == line_address(address));
431     assert(m_writeRequestTable.count(line_address(address)));
432 
433     RequestTable::iterator i = m_writeRequestTable.find(address);
434     assert(i != m_writeRequestTable.end());
435     SequencerRequest* request = i->second;
436 
437     m_writeRequestTable.erase(i);
438     markRemoved();
439 
440     assert((request->m_type == RubyRequestType_ST) ||
441            (request->m_type == RubyRequestType_ATOMIC) ||
442            (request->m_type == RubyRequestType_RMW_Read) ||
443            (request->m_type == RubyRequestType_RMW_Write) ||
444            (request->m_type == RubyRequestType_Load_Linked) ||
445            (request->m_type == RubyRequestType_Store_Conditional) ||
446            (request->m_type == RubyRequestType_Locked_RMW_Read) ||
447            (request->m_type == RubyRequestType_Locked_RMW_Write) ||
448            (request->m_type == RubyRequestType_FLUSH));
449 
450     //
451     // For Alpha, properly handle LL, SC, and write requests with respect to
452     // locked cache blocks.
453     //
454     // Not valid for Network_test protocl
455     //
456     bool success = true;
457     if(!m_usingNetworkTester)
458         success = handleLlsc(address, request);
459 
460     if (request->m_type == RubyRequestType_Locked_RMW_Read) {
461         m_controller->blockOnQueue(address, m_mandatory_q_ptr);
462     } else if (request->m_type == RubyRequestType_Locked_RMW_Write) {
463         m_controller->unblock(address);
464     }
465 
466     hitCallback(request, data, success, mach, externalHit,
467                 initialRequestTime, forwardRequestTime, firstResponseTime);
468 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classSequencer_a1898c82aec1a510eaa5aa55cb23a5bc3}{
\index{Sequencer@{Sequencer}!deadlockCheckEvent@{deadlockCheckEvent}}
\index{deadlockCheckEvent@{deadlockCheckEvent}!Sequencer@{Sequencer}}
\subsubsection[{deadlockCheckEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SequencerWakeupEvent} {\bf deadlockCheckEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a1898c82aec1a510eaa5aa55cb23a5bc3}
\hypertarget{classSequencer_a7a3b3fe88942aab5003a24c6f1da4428}{
\index{Sequencer@{Sequencer}!m\_\-dataCache\_\-ptr@{m\_\-dataCache\_\-ptr}}
\index{m\_\-dataCache\_\-ptr@{m\_\-dataCache\_\-ptr}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-dataCache\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CacheMemory}$\ast$ {\bf m\_\-dataCache\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a7a3b3fe88942aab5003a24c6f1da4428}
\hypertarget{classSequencer_a2e50c90663719c912c32881d58f1bd01}{
\index{Sequencer@{Sequencer}!m\_\-deadlock\_\-check\_\-scheduled@{m\_\-deadlock\_\-check\_\-scheduled}}
\index{m\_\-deadlock\_\-check\_\-scheduled@{m\_\-deadlock\_\-check\_\-scheduled}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-deadlock\_\-check\_\-scheduled}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf m\_\-deadlock\_\-check\_\-scheduled}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a2e50c90663719c912c32881d58f1bd01}
\hypertarget{classSequencer_a4760ee57ee761ad53400a617eb12e95a}{
\index{Sequencer@{Sequencer}!m\_\-deadlock\_\-threshold@{m\_\-deadlock\_\-threshold}}
\index{m\_\-deadlock\_\-threshold@{m\_\-deadlock\_\-threshold}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-deadlock\_\-threshold}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf m\_\-deadlock\_\-threshold}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a4760ee57ee761ad53400a617eb12e95a}
\hypertarget{classSequencer_a6236c49462f2162310ca62569ec869ac}{
\index{Sequencer@{Sequencer}!m\_\-FirstResponseToCompletionDelayHist@{m\_\-FirstResponseToCompletionDelayHist}}
\index{m\_\-FirstResponseToCompletionDelayHist@{m\_\-FirstResponseToCompletionDelayHist}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-FirstResponseToCompletionDelayHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf Stats::Histogram} $\ast$$>$ {\bf m\_\-FirstResponseToCompletionDelayHist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a6236c49462f2162310ca62569ec869ac}
\hypertarget{classSequencer_ae9bea11c9b001a155e7f7a0f39ac7bf9}{
\index{Sequencer@{Sequencer}!m\_\-ForwardToFirstResponseDelayHist@{m\_\-ForwardToFirstResponseDelayHist}}
\index{m\_\-ForwardToFirstResponseDelayHist@{m\_\-ForwardToFirstResponseDelayHist}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-ForwardToFirstResponseDelayHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf Stats::Histogram} $\ast$$>$ {\bf m\_\-ForwardToFirstResponseDelayHist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_ae9bea11c9b001a155e7f7a0f39ac7bf9}
\hypertarget{classSequencer_aa7b4f1cb2f6f69fac85f5fa0be12f95a}{
\index{Sequencer@{Sequencer}!m\_\-hitLatencyHist@{m\_\-hitLatencyHist}}
\index{m\_\-hitLatencyHist@{m\_\-hitLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-hitLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram} {\bf m\_\-hitLatencyHist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_aa7b4f1cb2f6f69fac85f5fa0be12f95a}
\hyperlink{classHistogram}{Histogram} for holding latency profile of all requests that hit in the controller connected to this sequencer. \hypertarget{classSequencer_add8e2c73ddfe42f1b177e641a0e626d5}{
\index{Sequencer@{Sequencer}!m\_\-hitMachLatencyHist@{m\_\-hitMachLatencyHist}}
\index{m\_\-hitMachLatencyHist@{m\_\-hitMachLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-hitMachLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf Stats::Histogram} $\ast$$>$ {\bf m\_\-hitMachLatencyHist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_add8e2c73ddfe42f1b177e641a0e626d5}
Histograms for profiling the latencies for requests that did not required external messages. \hypertarget{classSequencer_aeecaf5411cd3b34435f621db03387b67}{
\index{Sequencer@{Sequencer}!m\_\-hitTypeLatencyHist@{m\_\-hitTypeLatencyHist}}
\index{m\_\-hitTypeLatencyHist@{m\_\-hitTypeLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-hitTypeLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf Stats::Histogram} $\ast$$>$ {\bf m\_\-hitTypeLatencyHist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_aeecaf5411cd3b34435f621db03387b67}
\hypertarget{classSequencer_aaf855f02483dc21743651007a759ea77}{
\index{Sequencer@{Sequencer}!m\_\-hitTypeMachLatencyHist@{m\_\-hitTypeMachLatencyHist}}
\index{m\_\-hitTypeMachLatencyHist@{m\_\-hitTypeMachLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-hitTypeMachLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<$ {\bf std::vector}$<${\bf Stats::Histogram} $\ast$$>$ $>$ {\bf m\_\-hitTypeMachLatencyHist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_aaf855f02483dc21743651007a759ea77}
\hypertarget{classSequencer_a42ce5f1f915ac19c7e7575172f28e412}{
\index{Sequencer@{Sequencer}!m\_\-IncompleteTimes@{m\_\-IncompleteTimes}}
\index{m\_\-IncompleteTimes@{m\_\-IncompleteTimes}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-IncompleteTimes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf Stats::Counter}$>$ {\bf m\_\-IncompleteTimes}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a42ce5f1f915ac19c7e7575172f28e412}
\hypertarget{classSequencer_a0dbfb83f6edf61cad3d0aebdc89ed370}{
\index{Sequencer@{Sequencer}!m\_\-InitialToForwardDelayHist@{m\_\-InitialToForwardDelayHist}}
\index{m\_\-InitialToForwardDelayHist@{m\_\-InitialToForwardDelayHist}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-InitialToForwardDelayHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf Stats::Histogram} $\ast$$>$ {\bf m\_\-InitialToForwardDelayHist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a0dbfb83f6edf61cad3d0aebdc89ed370}
\hypertarget{classSequencer_ad75cc69f67160a8550641442ffdb6a47}{
\index{Sequencer@{Sequencer}!m\_\-instCache\_\-ptr@{m\_\-instCache\_\-ptr}}
\index{m\_\-instCache\_\-ptr@{m\_\-instCache\_\-ptr}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-instCache\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CacheMemory}$\ast$ {\bf m\_\-instCache\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_ad75cc69f67160a8550641442ffdb6a47}
\hypertarget{classSequencer_a503562ca3d885333c87da80d05ee612a}{
\index{Sequencer@{Sequencer}!m\_\-IssueToInitialDelayHist@{m\_\-IssueToInitialDelayHist}}
\index{m\_\-IssueToInitialDelayHist@{m\_\-IssueToInitialDelayHist}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-IssueToInitialDelayHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf Stats::Histogram} $\ast$$>$ {\bf m\_\-IssueToInitialDelayHist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a503562ca3d885333c87da80d05ee612a}


Histograms for recording the breakdown of miss latency. \hypertarget{classSequencer_aeb3fc96d5f4638c5599ed141c6c6bda7}{
\index{Sequencer@{Sequencer}!m\_\-latencyHist@{m\_\-latencyHist}}
\index{m\_\-latencyHist@{m\_\-latencyHist}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-latencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram} {\bf m\_\-latencyHist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_aeb3fc96d5f4638c5599ed141c6c6bda7}


\hyperlink{classHistogram}{Histogram} for holding latency profile of all requests. \hypertarget{classSequencer_a19936e24600f4fafad29833ae73051fa}{
\index{Sequencer@{Sequencer}!m\_\-load\_\-waiting\_\-on\_\-load@{m\_\-load\_\-waiting\_\-on\_\-load}}
\index{m\_\-load\_\-waiting\_\-on\_\-load@{m\_\-load\_\-waiting\_\-on\_\-load}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-load\_\-waiting\_\-on\_\-load}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf m\_\-load\_\-waiting\_\-on\_\-load}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a19936e24600f4fafad29833ae73051fa}
\hypertarget{classSequencer_a8e5427a5d38caa118425b87f68c8b8c0}{
\index{Sequencer@{Sequencer}!m\_\-load\_\-waiting\_\-on\_\-store@{m\_\-load\_\-waiting\_\-on\_\-store}}
\index{m\_\-load\_\-waiting\_\-on\_\-store@{m\_\-load\_\-waiting\_\-on\_\-store}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-load\_\-waiting\_\-on\_\-store}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf m\_\-load\_\-waiting\_\-on\_\-store}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a8e5427a5d38caa118425b87f68c8b8c0}
\hypertarget{classSequencer_aa4e402fb0283ff3547ee82785e7a66c3}{
\index{Sequencer@{Sequencer}!m\_\-max\_\-outstanding\_\-requests@{m\_\-max\_\-outstanding\_\-requests}}
\index{m\_\-max\_\-outstanding\_\-requests@{m\_\-max\_\-outstanding\_\-requests}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-max\_\-outstanding\_\-requests}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-max\_\-outstanding\_\-requests}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_aa4e402fb0283ff3547ee82785e7a66c3}
\hypertarget{classSequencer_aff6841cbe8b6a9be485b4c45a8208f93}{
\index{Sequencer@{Sequencer}!m\_\-missLatencyHist@{m\_\-missLatencyHist}}
\index{m\_\-missLatencyHist@{m\_\-missLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-missLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram} {\bf m\_\-missLatencyHist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_aff6841cbe8b6a9be485b4c45a8208f93}
\hyperlink{classHistogram}{Histogram} for holding latency profile of all requests that miss in the controller connected to this sequencer. \hypertarget{classSequencer_a55e994bce4da18f7600be6cbf7a4a3b5}{
\index{Sequencer@{Sequencer}!m\_\-missMachLatencyHist@{m\_\-missMachLatencyHist}}
\index{m\_\-missMachLatencyHist@{m\_\-missMachLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-missMachLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf Stats::Histogram} $\ast$$>$ {\bf m\_\-missMachLatencyHist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a55e994bce4da18f7600be6cbf7a4a3b5}
Histograms for profiling the latencies for requests that required external messages. \hypertarget{classSequencer_ac5a934c0abe9f0185357eb76de27dee3}{
\index{Sequencer@{Sequencer}!m\_\-missTypeLatencyHist@{m\_\-missTypeLatencyHist}}
\index{m\_\-missTypeLatencyHist@{m\_\-missTypeLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-missTypeLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf Stats::Histogram} $\ast$$>$ {\bf m\_\-missTypeLatencyHist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_ac5a934c0abe9f0185357eb76de27dee3}
\hypertarget{classSequencer_a8e022aebc37a4b83df56956874befd75}{
\index{Sequencer@{Sequencer}!m\_\-missTypeMachLatencyHist@{m\_\-missTypeMachLatencyHist}}
\index{m\_\-missTypeMachLatencyHist@{m\_\-missTypeMachLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-missTypeMachLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<$ {\bf std::vector}$<${\bf Stats::Histogram} $\ast$$>$ $>$ {\bf m\_\-missTypeMachLatencyHist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a8e022aebc37a4b83df56956874befd75}
\hypertarget{classSequencer_a5d645b1dc48106eac07688fc8c65edd2}{
\index{Sequencer@{Sequencer}!m\_\-outstanding\_\-count@{m\_\-outstanding\_\-count}}
\index{m\_\-outstanding\_\-count@{m\_\-outstanding\_\-count}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-outstanding\_\-count}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-outstanding\_\-count}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a5d645b1dc48106eac07688fc8c65edd2}
\hypertarget{classSequencer_a24e9160c0860bc93a5f57de63544fe65}{
\index{Sequencer@{Sequencer}!m\_\-outstandReqHist@{m\_\-outstandReqHist}}
\index{m\_\-outstandReqHist@{m\_\-outstandReqHist}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-outstandReqHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Histogram} {\bf m\_\-outstandReqHist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a24e9160c0860bc93a5f57de63544fe65}


\hyperlink{classHistogram}{Histogram} for number of outstanding requests per cycle. \hypertarget{classSequencer_a50b1d01ac64e8f892be4a49998965cda}{
\index{Sequencer@{Sequencer}!m\_\-readRequestTable@{m\_\-readRequestTable}}
\index{m\_\-readRequestTable@{m\_\-readRequestTable}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-readRequestTable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RequestTable} {\bf m\_\-readRequestTable}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a50b1d01ac64e8f892be4a49998965cda}
\hypertarget{classSequencer_a6d186a780be6aa79db648192dd730779}{
\index{Sequencer@{Sequencer}!m\_\-store\_\-waiting\_\-on\_\-load@{m\_\-store\_\-waiting\_\-on\_\-load}}
\index{m\_\-store\_\-waiting\_\-on\_\-load@{m\_\-store\_\-waiting\_\-on\_\-load}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-store\_\-waiting\_\-on\_\-load}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf m\_\-store\_\-waiting\_\-on\_\-load}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a6d186a780be6aa79db648192dd730779}


Counters for recording aliasing information. \hypertarget{classSequencer_a79cb8a27dd783e3c7298d8d874795b3d}{
\index{Sequencer@{Sequencer}!m\_\-store\_\-waiting\_\-on\_\-store@{m\_\-store\_\-waiting\_\-on\_\-store}}
\index{m\_\-store\_\-waiting\_\-on\_\-store@{m\_\-store\_\-waiting\_\-on\_\-store}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-store\_\-waiting\_\-on\_\-store}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf m\_\-store\_\-waiting\_\-on\_\-store}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a79cb8a27dd783e3c7298d8d874795b3d}
\hypertarget{classSequencer_a21453ca0672126e1c0e204b7c60b3340}{
\index{Sequencer@{Sequencer}!m\_\-typeLatencyHist@{m\_\-typeLatencyHist}}
\index{m\_\-typeLatencyHist@{m\_\-typeLatencyHist}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-typeLatencyHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf Stats::Histogram} $\ast$$>$ {\bf m\_\-typeLatencyHist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a21453ca0672126e1c0e204b7c60b3340}
\hypertarget{classSequencer_a6e3aaea8b048e1811c53f89dfb99260e}{
\index{Sequencer@{Sequencer}!m\_\-usingNetworkTester@{m\_\-usingNetworkTester}}
\index{m\_\-usingNetworkTester@{m\_\-usingNetworkTester}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-usingNetworkTester}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf m\_\-usingNetworkTester}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_a6e3aaea8b048e1811c53f89dfb99260e}
\hypertarget{classSequencer_ad419eb325e663790853ec757ca3b02aa}{
\index{Sequencer@{Sequencer}!m\_\-writeRequestTable@{m\_\-writeRequestTable}}
\index{m\_\-writeRequestTable@{m\_\-writeRequestTable}!Sequencer@{Sequencer}}
\subsubsection[{m\_\-writeRequestTable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RequestTable} {\bf m\_\-writeRequestTable}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSequencer_ad419eb325e663790853ec757ca3b02aa}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/ruby/system/\hyperlink{Sequencer_8hh}{Sequencer.hh}\item 
mem/ruby/system/\hyperlink{Sequencer_8cc}{Sequencer.cc}\end{DoxyCompactItemize}
