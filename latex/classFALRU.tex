\hypertarget{classFALRU}{
\section{クラス FALRU}
\label{classFALRU}\index{FALRU@{FALRU}}
}


{\ttfamily \#include $<$fa\_\-lru.hh$>$}FALRUに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=5cm]{classFALRU}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classFALRUBlk}{FALRUBlk} \hyperlink{classFALRU_a484db1f477d317f6694973b77f1e3ab1}{BlkType}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classFALRUBlk}{FALRUBlk} $\ast$ $>$ \hyperlink{classFALRU_ae5eda55657abbfe7eda0b6d87a1eb18f}{BlkList}
\item 
typedef FALRUParams \hyperlink{classFALRU_ac02f095611cbe1cc1b0d89ce95694168}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classFALRU_a008e99fdba3bde11cbd17bbc553a58f5}{FALRU} (const \hyperlink{classFALRU_ac02f095611cbe1cc1b0d89ce95694168}{Params} $\ast$p)
\item 
\hyperlink{classFALRU_a642d32a0be0130f14545c0d7c2cf71a1}{$\sim$FALRU} ()
\item 
void \hyperlink{classFALRU_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classFALRU_a11ea27715371eaeb125996e0a9ce14ab}{invalidate} (\hyperlink{classFALRUBlk}{BlkType} $\ast$blk)
\item 
\hyperlink{classFALRUBlk}{FALRUBlk} $\ast$ \hyperlink{classFALRU_a1cdfe87d1268e092f50485fd168e30ba}{accessBlock} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, bool is\_\-secure, \hyperlink{classCycles}{Cycles} \&lat, int context\_\-src, int $\ast$inCache=0)
\item 
\hyperlink{classFALRUBlk}{FALRUBlk} $\ast$ \hyperlink{classFALRU_ac33a8d39699e8ad6ba542fe00377e99f}{findBlock} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, bool is\_\-secure) const 
\item 
\hyperlink{classFALRUBlk}{FALRUBlk} $\ast$ \hyperlink{classFALRU_aa576cf2f9fcd41bff96e7a930ae24849}{findVictim} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr)
\item 
void \hyperlink{classFALRU_a79eef32acfa26685ba4a2f8e89f3f949}{insertBlock} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{classFALRUBlk}{BlkType} $\ast$blk)
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classFALRU_a0239f3ef0ba6cf7c0460b12d289e6517}{getHitLatency} () const 
\item 
unsigned \hyperlink{classFALRU_a38301abe4b3689f8ac7de5c13a046234}{getBlockSize} () const 
\item 
unsigned \hyperlink{classFALRU_aca3769c95ef908ce22475a69f8929a32}{getSubBlockSize} () const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classFALRU_a73119e914b3b83f88be5bde312855cfe}{blkAlign} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr) const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classFALRU_a3a855eb5b0d8adbf737f25baa15a3d7b}{extractTag} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr) const 
\item 
int \hyperlink{classFALRU_a8fdcc1372cb0a5d8e1933bdb0bf7d680}{extractSet} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr) const 
\item 
int \hyperlink{classFALRU_aca82d98193a0685a9648acf6127abb1c}{extractBlkOffset} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr) const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classFALRU_a6a30d516ca3dfb528b6e28e39b4744e8}{regenerateBlkAddr} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} tag, int set) const 
\item 
virtual void \hyperlink{classFALRU_a522e7dda9c2f4eba2cc1c103887d9265}{clearLocks} ()
\item 
virtual std::string \hyperlink{classFALRU_ac07d4bdf71f061cd9dba907c905a9543}{print} () const 
\item 
{\footnotesize template$<$typename V $>$ }\\void \hyperlink{classFALRU_a2f6fd1256bf2c210092c065ea65b83de}{forEachBlk} (V \&visitor)
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
typedef m5::hash\_\-map$<$ \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr}, \hyperlink{classFALRUBlk}{FALRUBlk} $\ast$, m5::hash$<$ \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} $>$ $>$ \hyperlink{classFALRU_adac55c74efec4bdd54e5042924e5cd4d}{hash\_\-t}
\item 
typedef hash\_\-t::const\_\-iterator \hyperlink{classFALRU_a6b2dee7e09394d1cc2e986975c29fade}{tagIterator}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classFALRUBlk}{FALRUBlk} $\ast$ \hyperlink{classFALRU_a55122befb6dfc11b5c81f04315531ee0}{hashLookup} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr) const 
\item 
void \hyperlink{classFALRU_a500e9f80634c062b4dbdd9c7e77565f8}{moveToHead} (\hyperlink{classFALRUBlk}{FALRUBlk} $\ast$blk)
\item 
bool \hyperlink{classFALRU_ae1ee541bb22588b6a71650c807efca90}{check} ()
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classFALRUBlk}{FALRUBlk} $\ast$$\ast$ \hyperlink{classFALRU_a5d339ffbb2b7d1fc126327a7eaecedc9}{cacheBoundaries}
\item 
int \hyperlink{classFALRU_abf2fa43889270cf9cc3906c2347bc837}{cacheMask}
\item 
unsigned \hyperlink{classFALRU_ae8d599d08408b7259ec22ce188c8a936}{numCaches}
\item 
\hyperlink{classFALRUBlk}{FALRUBlk} $\ast$ \hyperlink{classFALRU_a7493a5b25265aaedfdcf4de5febf03e7}{blks}
\item 
\hyperlink{classFALRUBlk}{FALRUBlk} $\ast$ \hyperlink{classFALRU_a5827e7c04ec688fa822655255fb9643d}{head}
\item 
\hyperlink{classFALRUBlk}{FALRUBlk} $\ast$ \hyperlink{classFALRU_ac959b56dd2bb57a61f6869516a31460d}{tail}
\item 
\hyperlink{classFALRU_adac55c74efec4bdd54e5042924e5cd4d}{hash\_\-t} \hyperlink{classFALRU_a89874e6ace0517ea2a50bae25cbbbf83}{tagHash}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{group__FALRUStats_ga9fa327cedfd790f651b9218d749c7c73}{hits}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{group__FALRUStats_gadc50dd8bb92cf864a73d259ac6c67ecd}{misses}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{group__FALRUStats_ga60db2c0b2a8e7ec99712db305f2adf5d}{accesses}
\end{DoxyCompactItemize}


\subsection{説明}
A fully associative \hyperlink{classLRU}{LRU} cache. Keeps statistics for accesses to a number of cache sizes at once. 

\subsection{型定義}
\hypertarget{classFALRU_ae5eda55657abbfe7eda0b6d87a1eb18f}{
\index{FALRU@{FALRU}!BlkList@{BlkList}}
\index{BlkList@{BlkList}!FALRU@{FALRU}}
\subsubsection[{BlkList}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf FALRUBlk}$\ast$$>$ {\bf BlkList}}}
\label{classFALRU_ae5eda55657abbfe7eda0b6d87a1eb18f}
Typedef a list of pointers to the local block type. \hypertarget{classFALRU_a484db1f477d317f6694973b77f1e3ab1}{
\index{FALRU@{FALRU}!BlkType@{BlkType}}
\index{BlkType@{BlkType}!FALRU@{FALRU}}
\subsubsection[{BlkType}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf FALRUBlk} {\bf BlkType}}}
\label{classFALRU_a484db1f477d317f6694973b77f1e3ab1}
Typedef the block type used in this class. \hypertarget{classFALRU_adac55c74efec4bdd54e5042924e5cd4d}{
\index{FALRU@{FALRU}!hash\_\-t@{hash\_\-t}}
\index{hash\_\-t@{hash\_\-t}!FALRU@{FALRU}}
\subsubsection[{hash\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef m5::hash\_\-map$<${\bf Addr}, {\bf FALRUBlk} $\ast$, m5::hash$<${\bf Addr}$>$ $>$ {\bf hash\_\-t}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFALRU_adac55c74efec4bdd54e5042924e5cd4d}
Hash table type mapping addresses to cache block pointers. \hypertarget{classFALRU_ac02f095611cbe1cc1b0d89ce95694168}{
\index{FALRU@{FALRU}!Params@{Params}}
\index{Params@{Params}!FALRU@{FALRU}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef FALRUParams {\bf Params}}}
\label{classFALRU_ac02f095611cbe1cc1b0d89ce95694168}


\hyperlink{classBaseTags_aab33a5313a7ca07c69f8a4e6e1490375}{BaseTags}を再定義しています。\hypertarget{classFALRU_a6b2dee7e09394d1cc2e986975c29fade}{
\index{FALRU@{FALRU}!tagIterator@{tagIterator}}
\index{tagIterator@{tagIterator}!FALRU@{FALRU}}
\subsubsection[{tagIterator}]{\setlength{\rightskip}{0pt plus 5cm}typedef hash\_\-t::const\_\-iterator {\bf tagIterator}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFALRU_a6b2dee7e09394d1cc2e986975c29fade}
Iterator into the address hash table. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classFALRU_a008e99fdba3bde11cbd17bbc553a58f5}{
\index{FALRU@{FALRU}!FALRU@{FALRU}}
\index{FALRU@{FALRU}!FALRU@{FALRU}}
\subsubsection[{FALRU}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FALRU} (const {\bf Params} $\ast$ {\em p})}}
\label{classFALRU_a008e99fdba3bde11cbd17bbc553a58f5}
Construct and initialize this cache tagstore. 


\begin{DoxyCode}
58     : BaseTags(p)
59 {
60     if (!isPowerOf2(blkSize))
61         fatal("cache block size (in bytes) `%d' must be a power of two",
62               blkSize);
63     if (!(hitLatency > 0))
64         fatal("Access latency in cycles must be at least one cycle");
65     if (!isPowerOf2(size))
66         fatal("Cache Size must be power of 2 for now");
67 
68     // Track all cache sizes from 128K up by powers of 2
69     numCaches = floorLog2(size) - 17;
70     if (numCaches >0){
71         cacheBoundaries = new FALRUBlk *[numCaches];
72         cacheMask = (1 << numCaches) - 1;
73     } else {
74         cacheMask = 0;
75     }
76 
77     warmedUp = false;
78     warmupBound = size/blkSize;
79     numBlocks = size/blkSize;
80 
81     blks = new FALRUBlk[numBlocks];
82     head = &(blks[0]);
83     tail = &(blks[numBlocks-1]);
84 
85     head->prev = NULL;
86     head->next = &(blks[1]);
87     head->inCache = cacheMask;
88 
89     tail->prev = &(blks[numBlocks-2]);
90     tail->next = NULL;
91     tail->inCache = 0;
92 
93     unsigned index = (1 << 17) / blkSize;
94     unsigned j = 0;
95     int flags = cacheMask;
96     for (unsigned i = 1; i < numBlocks - 1; i++) {
97         blks[i].inCache = flags;
98         if (i == index - 1){
99             cacheBoundaries[j] = &(blks[i]);
100             flags &= ~ (1<<j);
101             ++j;
102             index = index << 1;
103         }
104         blks[i].prev = &(blks[i-1]);
105         blks[i].next = &(blks[i+1]);
106         blks[i].isTouched = false;
107     }
108     assert(j == numCaches);
109     assert(index == numBlocks);
110     //assert(check());
111 }
\end{DoxyCode}
\hypertarget{classFALRU_a642d32a0be0130f14545c0d7c2cf71a1}{
\index{FALRU@{FALRU}!$\sim$FALRU@{$\sim$FALRU}}
\index{$\sim$FALRU@{$\sim$FALRU}!FALRU@{FALRU}}
\subsubsection[{$\sim$FALRU}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf FALRU} ()}}
\label{classFALRU_a642d32a0be0130f14545c0d7c2cf71a1}



\begin{DoxyCode}
114 {
115     if (numCaches)
116         delete[] cacheBoundaries;
117 
118     delete[] blks;
119 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classFALRU_a1cdfe87d1268e092f50485fd168e30ba}{
\index{FALRU@{FALRU}!accessBlock@{accessBlock}}
\index{accessBlock@{accessBlock}!FALRU@{FALRU}}
\subsubsection[{accessBlock}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FALRUBlk} $\ast$ accessBlock ({\bf Addr} {\em addr}, \/  bool {\em is\_\-secure}, \/  {\bf Cycles} \& {\em lat}, \/  int {\em context\_\-src}, \/  int $\ast$ {\em inCache} = {\ttfamily 0})}}
\label{classFALRU_a1cdfe87d1268e092f50485fd168e30ba}
Access block and update replacement data. May not succeed, in which case NULL pointer is returned. This has all the implications of a cache access and should only be used as such. Returns the access latency and inCache flags as a side effect. 
\begin{DoxyParams}{引数}
\item[{\em addr}]The address to look for. \item[{\em is\_\-secure}]True if the target memory space is secure. \item[{\em asid}]The address space ID. \item[{\em lat}]The latency of the access. \item[{\em inCache}]The \hyperlink{classFALRUBlk_ac6da16cc60d372d1160776a7dbd19225}{FALRUBlk::inCache} flags. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Pointer to the cache block. 
\end{DoxyReturn}



\begin{DoxyCode}
176 {
177     accesses++;
178     int tmp_in_cache = 0;
179     Addr blkAddr = blkAlign(addr);
180     FALRUBlk* blk = hashLookup(blkAddr);
181 
182     if (blk && blk->isValid()) {
183         assert(blk->tag == blkAddr);
184         tmp_in_cache = blk->inCache;
185         for (unsigned i = 0; i < numCaches; i++) {
186             if (1<<i & blk->inCache) {
187                 hits[i]++;
188             } else {
189                 misses[i]++;
190             }
191         }
192         hits[numCaches]++;
193         if (blk != head){
194             moveToHead(blk);
195         }
196     } else {
197         blk = NULL;
198         for (unsigned i = 0; i <= numCaches; ++i) {
199             misses[i]++;
200         }
201     }
202     if (inCache) {
203         *inCache = tmp_in_cache;
204     }
205 
206     lat = hitLatency;
207     //assert(check());
208     return blk;
209 }
\end{DoxyCode}
\hypertarget{classFALRU_a73119e914b3b83f88be5bde312855cfe}{
\index{FALRU@{FALRU}!blkAlign@{blkAlign}}
\index{blkAlign@{blkAlign}!FALRU@{FALRU}}
\subsubsection[{blkAlign}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} blkAlign ({\bf Addr} {\em addr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFALRU_a73119e914b3b83f88be5bde312855cfe}
Align an address to the block size. 
\begin{DoxyParams}{引数}
\item[{\em addr}]the address to align. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
The aligned address. 
\end{DoxyReturn}



\begin{DoxyCode}
247     {
248         return (addr & ~(Addr)(blkSize-1));
249     }
\end{DoxyCode}
\hypertarget{classFALRU_ae1ee541bb22588b6a71650c807efca90}{
\index{FALRU@{FALRU}!check@{check}}
\index{check@{check}!FALRU@{FALRU}}
\subsubsection[{check}]{\setlength{\rightskip}{0pt plus 5cm}bool check ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFALRU_ae1ee541bb22588b6a71650c807efca90}
\hyperlink{classCheck}{Check} to make sure all the cache boundaries are still where they should be. Used for debugging. \begin{DoxyReturn}{戻り値}
True if everything is correct. 
\end{DoxyReturn}



\begin{DoxyCode}
284 {
285     FALRUBlk* blk = head;
286     int tot_size = 0;
287     int boundary = 1<<17;
288     int j = 0;
289     int flags = cacheMask;
290     while (blk) {
291         tot_size += blkSize;
292         if (blk->inCache != flags) {
293             return false;
294         }
295         if (tot_size == boundary && blk != tail) {
296             if (cacheBoundaries[j] != blk) {
297                 return false;
298             }
299             flags &=~(1 << j);
300             boundary = boundary<<1;
301             ++j;
302         }
303         blk = blk->next;
304     }
305     return true;
306 }
\end{DoxyCode}
\hypertarget{classFALRU_a522e7dda9c2f4eba2cc1c103887d9265}{
\index{FALRU@{FALRU}!clearLocks@{clearLocks}}
\index{clearLocks@{clearLocks}!FALRU@{FALRU}}
\subsubsection[{clearLocks}]{\setlength{\rightskip}{0pt plus 5cm}void clearLocks ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFALRU_a522e7dda9c2f4eba2cc1c103887d9265}
iterated through all blocks and clear all locks Needed to clear all lock tracking at once 

\hyperlink{classBaseTags_a9f3e3b80f263780be72db8b9dc53680e}{BaseTags}を再定義しています。


\begin{DoxyCode}
310 {
311     for (int i = 0; i < numBlocks; i++){
312         blks[i].clearLoadLocks();
313     }
314 }
\end{DoxyCode}
\hypertarget{classFALRU_aca82d98193a0685a9648acf6127abb1c}{
\index{FALRU@{FALRU}!extractBlkOffset@{extractBlkOffset}}
\index{extractBlkOffset@{extractBlkOffset}!FALRU@{FALRU}}
\subsubsection[{extractBlkOffset}]{\setlength{\rightskip}{0pt plus 5cm}int extractBlkOffset ({\bf Addr} {\em addr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFALRU_aca82d98193a0685a9648acf6127abb1c}
Calculate the block offset of an address. 
\begin{DoxyParams}{引数}
\item[{\em addr}]the address to get the offset of. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
the block offset. 
\end{DoxyReturn}



\begin{DoxyCode}
278     {
279         return (addr & (Addr)(blkSize-1));
280     }
\end{DoxyCode}
\hypertarget{classFALRU_a8fdcc1372cb0a5d8e1933bdb0bf7d680}{
\index{FALRU@{FALRU}!extractSet@{extractSet}}
\index{extractSet@{extractSet}!FALRU@{FALRU}}
\subsubsection[{extractSet}]{\setlength{\rightskip}{0pt plus 5cm}int extractSet ({\bf Addr} {\em addr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFALRU_a8fdcc1372cb0a5d8e1933bdb0bf7d680}
Return the set of an address. Only one set in a fully associative cache. 
\begin{DoxyParams}{引数}
\item[{\em addr}]The address to get the set from. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
0. 
\end{DoxyReturn}



\begin{DoxyCode}
268     {
269         return 0;
270     }
\end{DoxyCode}
\hypertarget{classFALRU_a3a855eb5b0d8adbf737f25baa15a3d7b}{
\index{FALRU@{FALRU}!extractTag@{extractTag}}
\index{extractTag@{extractTag}!FALRU@{FALRU}}
\subsubsection[{extractTag}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} extractTag ({\bf Addr} {\em addr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFALRU_a3a855eb5b0d8adbf737f25baa15a3d7b}
Generate the tag from the addres. For fully associative this is just the block address. 
\begin{DoxyParams}{引数}
\item[{\em addr}]The address to get the tag from. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
The tag. 
\end{DoxyReturn}



\begin{DoxyCode}
258     {
259         return blkAlign(addr);
260     }
\end{DoxyCode}
\hypertarget{classFALRU_ac33a8d39699e8ad6ba542fe00377e99f}{
\index{FALRU@{FALRU}!findBlock@{findBlock}}
\index{findBlock@{findBlock}!FALRU@{FALRU}}
\subsubsection[{findBlock}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FALRUBlk} $\ast$ findBlock ({\bf Addr} {\em addr}, \/  bool {\em is\_\-secure}) const}}
\label{classFALRU_ac33a8d39699e8ad6ba542fe00377e99f}
Find the block in the cache, do not update the replacement data. 
\begin{DoxyParams}{引数}
\item[{\em addr}]The address to look for. \item[{\em is\_\-secure}]True if the target memory space is secure. \item[{\em asid}]The address space ID. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Pointer to the cache block. 
\end{DoxyReturn}



\begin{DoxyCode}
214 {
215     Addr blkAddr = blkAlign(addr);
216     FALRUBlk* blk = hashLookup(blkAddr);
217 
218     if (blk && blk->isValid()) {
219         assert(blk->tag == blkAddr);
220     } else {
221         blk = NULL;
222     }
223     return blk;
224 }
\end{DoxyCode}
\hypertarget{classFALRU_aa576cf2f9fcd41bff96e7a930ae24849}{
\index{FALRU@{FALRU}!findVictim@{findVictim}}
\index{findVictim@{findVictim}!FALRU@{FALRU}}
\subsubsection[{findVictim}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FALRUBlk} $\ast$ findVictim ({\bf Addr} {\em addr})}}
\label{classFALRU_aa576cf2f9fcd41bff96e7a930ae24849}
Find a replacement block for the address provided. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]The request to a find a replacement candidate for. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
The block to place the replacement in. 
\end{DoxyReturn}



\begin{DoxyCode}
228 {
229     FALRUBlk * blk = tail;
230     assert(blk->inCache == 0);
231     moveToHead(blk);
232     tagHash.erase(blk->tag);
233     tagHash[blkAlign(addr)] = blk;
234     if (blk->isValid()) {
235         replacements[0]++;
236     } else {
237         tagsInUse++;
238         blk->isTouched = true;
239         if (!warmedUp && tagsInUse.value() >= warmupBound) {
240             warmedUp = true;
241             warmupCycle = curTick();
242         }
243     }
244     //assert(check());
245     return blk;
246 }
\end{DoxyCode}
\hypertarget{classFALRU_a2f6fd1256bf2c210092c065ea65b83de}{
\index{FALRU@{FALRU}!forEachBlk@{forEachBlk}}
\index{forEachBlk@{forEachBlk}!FALRU@{FALRU}}
\subsubsection[{forEachBlk}]{\setlength{\rightskip}{0pt plus 5cm}void forEachBlk (V \& {\em visitor})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFALRU_a2f6fd1256bf2c210092c065ea65b83de}
Visit each block in the tag store and apply a visitor to the block.

The visitor should be a function (or object that behaves like a function) that takes a cache block reference as its parameter and returns a bool. A visitor can request the traversal to be stopped by returning false, returning true causes it to be called for the next block in the tag store.


\begin{DoxyParams}{引数}
\item[{\em visitor}]Visitor to call on each block. \end{DoxyParams}



\begin{DoxyCode}
317                                 {
318         for (int i = 0; i < numBlocks; i++) {
319             if (!visitor(blks[i]))
320                 return;
321         }
322     }
\end{DoxyCode}
\hypertarget{classFALRU_a38301abe4b3689f8ac7de5c13a046234}{
\index{FALRU@{FALRU}!getBlockSize@{getBlockSize}}
\index{getBlockSize@{getBlockSize}!FALRU@{FALRU}}
\subsubsection[{getBlockSize}]{\setlength{\rightskip}{0pt plus 5cm}unsigned getBlockSize () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFALRU_a38301abe4b3689f8ac7de5c13a046234}
Return the block size of this cache. \begin{DoxyReturn}{戻り値}
The block size. 
\end{DoxyReturn}



\begin{DoxyCode}
227     {
228         return blkSize;
229     }
\end{DoxyCode}
\hypertarget{classFALRU_a0239f3ef0ba6cf7c0460b12d289e6517}{
\index{FALRU@{FALRU}!getHitLatency@{getHitLatency}}
\index{getHitLatency@{getHitLatency}!FALRU@{FALRU}}
\subsubsection[{getHitLatency}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} getHitLatency () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFALRU_a0239f3ef0ba6cf7c0460b12d289e6517}
Return the hit latency of this cache. \begin{DoxyReturn}{戻り値}
The hit latency. 
\end{DoxyReturn}



\begin{DoxyCode}
217     {
218         return hitLatency;
219     }
\end{DoxyCode}
\hypertarget{classFALRU_aca3769c95ef908ce22475a69f8929a32}{
\index{FALRU@{FALRU}!getSubBlockSize@{getSubBlockSize}}
\index{getSubBlockSize@{getSubBlockSize}!FALRU@{FALRU}}
\subsubsection[{getSubBlockSize}]{\setlength{\rightskip}{0pt plus 5cm}unsigned getSubBlockSize () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFALRU_aca3769c95ef908ce22475a69f8929a32}
Return the subblock size of this cache, always the block size. \begin{DoxyReturn}{戻り値}
The block size. 
\end{DoxyReturn}



\begin{DoxyCode}
237     {
238         return blkSize;
239     }
\end{DoxyCode}
\hypertarget{classFALRU_a55122befb6dfc11b5c81f04315531ee0}{
\index{FALRU@{FALRU}!hashLookup@{hashLookup}}
\index{hashLookup@{hashLookup}!FALRU@{FALRU}}
\subsubsection[{hashLookup}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FALRUBlk} $\ast$ hashLookup ({\bf Addr} {\em addr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFALRU_a55122befb6dfc11b5c81f04315531ee0}
Find the cache block for the given address. 
\begin{DoxyParams}{引数}
\item[{\em addr}]The address to find. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
The cache block of the address, if any. 
\end{DoxyReturn}



\begin{DoxyCode}
158 {
159     tagIterator iter = tagHash.find(addr);
160     if (iter != tagHash.end()) {
161         return (*iter).second;
162     }
163     return NULL;
164 }
\end{DoxyCode}
\hypertarget{classFALRU_a79eef32acfa26685ba4a2f8e89f3f949}{
\index{FALRU@{FALRU}!insertBlock@{insertBlock}}
\index{insertBlock@{insertBlock}!FALRU@{FALRU}}
\subsubsection[{insertBlock}]{\setlength{\rightskip}{0pt plus 5cm}void insertBlock ({\bf PacketPtr} {\em pkt}, \/  {\bf FALRU::BlkType} $\ast$ {\em blk})}}
\label{classFALRU_a79eef32acfa26685ba4a2f8e89f3f949}



\begin{DoxyCode}
250 {
251 }
\end{DoxyCode}
\hypertarget{classFALRU_a11ea27715371eaeb125996e0a9ce14ab}{
\index{FALRU@{FALRU}!invalidate@{invalidate}}
\index{invalidate@{invalidate}!FALRU@{FALRU}}
\subsubsection[{invalidate}]{\setlength{\rightskip}{0pt plus 5cm}void invalidate ({\bf FALRU::BlkType} $\ast$ {\em blk})}}
\label{classFALRU_a11ea27715371eaeb125996e0a9ce14ab}
Invalidate a cache block. 
\begin{DoxyParams}{引数}
\item[{\em blk}]The block to invalidate. \end{DoxyParams}



\begin{DoxyCode}
168 {
169     assert(blk);
170     tagsInUse--;
171 }
\end{DoxyCode}
\hypertarget{classFALRU_a500e9f80634c062b4dbdd9c7e77565f8}{
\index{FALRU@{FALRU}!moveToHead@{moveToHead}}
\index{moveToHead@{moveToHead}!FALRU@{FALRU}}
\subsubsection[{moveToHead}]{\setlength{\rightskip}{0pt plus 5cm}void moveToHead ({\bf FALRUBlk} $\ast$ {\em blk})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFALRU_a500e9f80634c062b4dbdd9c7e77565f8}
Move a cache block to the MRU position. 
\begin{DoxyParams}{引数}
\item[{\em blk}]The block to promote. \end{DoxyParams}



\begin{DoxyCode}
255 {
256     int updateMask = blk->inCache ^ cacheMask;
257     for (unsigned i = 0; i < numCaches; i++){
258         if ((1<<i) & updateMask) {
259             cacheBoundaries[i]->inCache &= ~(1<<i);
260             cacheBoundaries[i] = cacheBoundaries[i]->prev;
261         } else if (cacheBoundaries[i] == blk) {
262             cacheBoundaries[i] = blk->prev;
263         }
264     }
265     blk->inCache = cacheMask;
266     if (blk != head) {
267         if (blk == tail){
268             assert(blk->next == NULL);
269             tail = blk->prev;
270             tail->next = NULL;
271         } else {
272             blk->prev->next = blk->next;
273             blk->next->prev = blk->prev;
274         }
275         blk->next = head;
276         blk->prev = NULL;
277         head->prev = blk;
278         head = blk;
279     }
280 }
\end{DoxyCode}
\hypertarget{classFALRU_ac07d4bdf71f061cd9dba907c905a9543}{
\index{FALRU@{FALRU}!print@{print}}
\index{print@{print}!FALRU@{FALRU}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}virtual std::string print () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classFALRU_ac07d4bdf71f061cd9dba907c905a9543}
\begin{Desc}
\item[\hyperlink{todo__todo000080}{TODO}]Implement as in lru. Currently not used \end{Desc}


\hyperlink{classBaseTags_a56a7c10391fb704ea26efc16f4f4f87b}{BaseTags}を実装しています。


\begin{DoxyCode}
302 { return ""; }
\end{DoxyCode}
\hypertarget{classFALRU_a6a30d516ca3dfb528b6e28e39b4744e8}{
\index{FALRU@{FALRU}!regenerateBlkAddr@{regenerateBlkAddr}}
\index{regenerateBlkAddr@{regenerateBlkAddr}!FALRU@{FALRU}}
\subsubsection[{regenerateBlkAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} regenerateBlkAddr ({\bf Addr} {\em tag}, \/  int {\em set}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFALRU_a6a30d516ca3dfb528b6e28e39b4744e8}
Regenerate the block address from the tag and the set. 
\begin{DoxyParams}{引数}
\item[{\em tag}]The tag of the block. \item[{\em set}]The set the block belongs to. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
the block address. 
\end{DoxyReturn}



\begin{DoxyCode}
289     {
290         return (tag);
291     }
\end{DoxyCode}
\hypertarget{classFALRU_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{FALRU@{FALRU}!regStats@{regStats}}
\index{regStats@{regStats}!FALRU@{FALRU}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFALRU_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} the stats for this object. 
\begin{DoxyParams}{引数}
\item[{\em name}]The name to prepend to the stats name. \end{DoxyParams}


\hyperlink{classBaseTags_a4dc637449366fcdfc4e764cdf12d9b11}{BaseTags}を再定義しています。


\begin{DoxyCode}
123 {
124     using namespace Stats;
125     BaseTags::regStats();
126     hits
127         .init(numCaches+1)
128         .name(name() + ".falru_hits")
129         .desc("The number of hits in each cache size.")
130         ;
131     misses
132         .init(numCaches+1)
133         .name(name() + ".falru_misses")
134         .desc("The number of misses in each cache size.")
135         ;
136     accesses
137         .name(name() + ".falru_accesses")
138         .desc("The number of accesses to the FA LRU cache.")
139         ;
140 
141     for (unsigned i = 0; i <= numCaches; ++i) {
142         stringstream size_str;
143         if (i < 3){
144             size_str << (1<<(i+7)) <<"K";
145         } else {
146             size_str << (1<<(i-3)) <<"M";
147         }
148 
149         hits.subname(i, size_str.str());
150         hits.subdesc(i, "Hits in a " + size_str.str() +" cache");
151         misses.subname(i, size_str.str());
152         misses.subdesc(i, "Misses in a " + size_str.str() +" cache");
153     }
154 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classFALRU_a7493a5b25265aaedfdcf4de5febf03e7}{
\index{FALRU@{FALRU}!blks@{blks}}
\index{blks@{blks}!FALRU@{FALRU}}
\subsubsection[{blks}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FALRUBlk}$\ast$ {\bf blks}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFALRU_a7493a5b25265aaedfdcf4de5febf03e7}
The cache blocks. \hypertarget{classFALRU_a5d339ffbb2b7d1fc126327a7eaecedc9}{
\index{FALRU@{FALRU}!cacheBoundaries@{cacheBoundaries}}
\index{cacheBoundaries@{cacheBoundaries}!FALRU@{FALRU}}
\subsubsection[{cacheBoundaries}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FALRUBlk}$\ast$$\ast$ {\bf cacheBoundaries}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFALRU_a5d339ffbb2b7d1fc126327a7eaecedc9}
Array of pointers to blocks at the cache size boundaries. \hypertarget{classFALRU_abf2fa43889270cf9cc3906c2347bc837}{
\index{FALRU@{FALRU}!cacheMask@{cacheMask}}
\index{cacheMask@{cacheMask}!FALRU@{FALRU}}
\subsubsection[{cacheMask}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf cacheMask}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFALRU_abf2fa43889270cf9cc3906c2347bc837}
A mask for the \hyperlink{classFALRUBlk_ac6da16cc60d372d1160776a7dbd19225}{FALRUBlk::inCache} bits. \hypertarget{classFALRU_a5827e7c04ec688fa822655255fb9643d}{
\index{FALRU@{FALRU}!head@{head}}
\index{head@{head}!FALRU@{FALRU}}
\subsubsection[{head}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FALRUBlk}$\ast$ {\bf head}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFALRU_a5827e7c04ec688fa822655255fb9643d}
The MRU block. \hypertarget{classFALRU_ae8d599d08408b7259ec22ce188c8a936}{
\index{FALRU@{FALRU}!numCaches@{numCaches}}
\index{numCaches@{numCaches}!FALRU@{FALRU}}
\subsubsection[{numCaches}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf numCaches}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFALRU_ae8d599d08408b7259ec22ce188c8a936}
The number of different size caches being tracked. \hypertarget{classFALRU_a89874e6ace0517ea2a50bae25cbbbf83}{
\index{FALRU@{FALRU}!tagHash@{tagHash}}
\index{tagHash@{tagHash}!FALRU@{FALRU}}
\subsubsection[{tagHash}]{\setlength{\rightskip}{0pt plus 5cm}{\bf hash\_\-t} {\bf tagHash}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFALRU_a89874e6ace0517ea2a50bae25cbbbf83}
The address hash table. \hypertarget{classFALRU_ac959b56dd2bb57a61f6869516a31460d}{
\index{FALRU@{FALRU}!tail@{tail}}
\index{tail@{tail}!FALRU@{FALRU}}
\subsubsection[{tail}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FALRUBlk}$\ast$ {\bf tail}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classFALRU_ac959b56dd2bb57a61f6869516a31460d}
The \hyperlink{classLRU}{LRU} block. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/cache/tags/\hyperlink{fa__lru_8hh}{fa\_\-lru.hh}\item 
mem/cache/tags/\hyperlink{fa__lru_8cc}{fa\_\-lru.cc}\end{DoxyCompactItemize}
