\hypertarget{classBPredUnit}{
\section{クラス BPredUnit}
\label{classBPredUnit}\index{BPredUnit@{BPredUnit}}
}


{\ttfamily \#include $<$bpred\_\-unit.hh$>$}BPredUnitに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4cm]{classBPredUnit}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structBPredUnit_1_1PredictorHistory}{PredictorHistory}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef BranchPredictorParams \hyperlink{classBPredUnit_aa715df0f49f029439cca4c7bd6e3d4fb}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classBPredUnit_a1061023e2f959cf88ef9064923a4667f}{BPredUnit} (const \hyperlink{classBPredUnit_aa715df0f49f029439cca4c7bd6e3d4fb}{Params} $\ast$p)
\item 
void \hyperlink{classBPredUnit_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classBPredUnit_a0240eb42fa57fe5d3788093f62b77347}{drainSanityCheck} () const 
\item 
bool \hyperlink{classBPredUnit_a9d2ad862133709eece4bf864fe378282}{predict} (\hyperlink{classRefCountingPtr}{StaticInstPtr} \&inst, const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&seqNum, TheISA::PCState \&pc, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classBPredUnit_a73a7edc2571c70838069e32ff33a2788}{predictInOrder} (\hyperlink{classRefCountingPtr}{StaticInstPtr} \&inst, const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&seqNum, int asid, TheISA::PCState \&instPC, TheISA::PCState \&predPC, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
virtual void \hyperlink{classBPredUnit_a17161e0c51444f148e49e4df2ba89704}{uncondBranch} (void $\ast$\&bp\_\-history)=0
\item 
void \hyperlink{classBPredUnit_a6e4be480aeb0d4acfb352802ab73a3df}{update} (const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&done\_\-sn, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classBPredUnit_af62f441ad740da2cd987637cfa87dfe5}{squash} (const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&squashed\_\-sn, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classBPredUnit_af5d7fa639b2e7ef3c6449d26f93771a0}{squash} (const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&squashed\_\-sn, const TheISA::PCState \&corr\_\-target, bool actually\_\-taken, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
virtual void \hyperlink{classBPredUnit_a2af63ba741727bdf58e2b2dc22a912ed}{squash} (void $\ast$bp\_\-history)=0
\item 
virtual bool \hyperlink{classBPredUnit_a5632fdea0abc34f7d68d8445a7a6c166}{lookup} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} instPC, void $\ast$\&bp\_\-history)=0
\item 
virtual void \hyperlink{classBPredUnit_a7b687ebde63095b00a0b083ba6607cd4}{btbUpdate} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} instPC, void $\ast$\&bp\_\-history)=0
\item 
bool \hyperlink{classBPredUnit_a93ec70ede183b1d9c34cef98153c01f8}{BTBValid} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} instPC)
\item 
TheISA::PCState \hyperlink{classBPredUnit_a391197cbd3ef7a4dd06e561671f1347a}{BTBLookup} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} instPC)
\item 
virtual void \hyperlink{classBPredUnit_ab00dd76dc9f830cdae0edc72357c013a}{update} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} instPC, bool taken, void $\ast$bp\_\-history, bool squashed)=0
\item 
void \hyperlink{classBPredUnit_a9c9cad624af5c71140d7f402ee4f1a2c}{BTBUpdate} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} instPC, const TheISA::PCState \&target)
\item 
void \hyperlink{classBPredUnit_accd2600060dbaee3a3b41aed4034c63c}{dump} ()
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{structBPredUnit_1_1PredictorHistory}{PredictorHistory} $>$ \hyperlink{classBPredUnit_a4b4610c4c56c4d7061849e23009cbb4b}{History}
\item 
typedef History::iterator \hyperlink{classBPredUnit_abaefb3dcd19a61b2383910e6efb536eb}{HistoryIt}
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classBPredUnit_a82dc714137537bc6ed526164d95f6674}{numThreads}
\item 
\hyperlink{classstd_1_1list}{History} $\ast$ \hyperlink{classBPredUnit_a17866949610525907d51191ce3271e73}{predHist}
\item 
\hyperlink{classDefaultBTB}{DefaultBTB} \hyperlink{classBPredUnit_abd4f25a0378890fc9bfa1adef49cc0ce}{BTB}
\item 
\hyperlink{classReturnAddrStack}{ReturnAddrStack} $\ast$ \hyperlink{classBPredUnit_aaff600a1f8b1b71ac7636e62cb7319dd}{RAS}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBPredUnit_a4a025c8c15499fd8df40b46f39496321}{lookups}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBPredUnit_a5c78c3319018e9949a36e46bfe617905}{condPredicted}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBPredUnit_a185c5e4f3b5ec64fe7a1120ead854d93}{condIncorrect}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBPredUnit_aa62bafdbd09ec7c26031a8b58a042569}{BTBLookups}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBPredUnit_a62943c2b7168001cfb6cf5f3a724e04a}{BTBHits}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBPredUnit_a05ffad6906b6204237963e1d3652be90}{BTBCorrect}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classBPredUnit_adeb28302a86d176687ddfc4227ef78ff}{BTBHitPct}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBPredUnit_af589fa2a7ce83147ab8c0d4169c0748f}{usedRAS}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classBPredUnit_a8f16f8a930ca557e2a627a4dfa15e67f}{RASIncorrect}
\end{DoxyCompactItemize}


\subsection{説明}
Basically a wrapper class to hold both the branch predictor and the BTB. 

\subsection{型定義}
\hypertarget{classBPredUnit_a4b4610c4c56c4d7061849e23009cbb4b}{
\index{BPredUnit@{BPredUnit}!History@{History}}
\index{History@{History}!BPredUnit@{BPredUnit}}
\subsubsection[{History}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf PredictorHistory}$>$ {\bf History}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBPredUnit_a4b4610c4c56c4d7061849e23009cbb4b}
\hypertarget{classBPredUnit_abaefb3dcd19a61b2383910e6efb536eb}{
\index{BPredUnit@{BPredUnit}!HistoryIt@{HistoryIt}}
\index{HistoryIt@{HistoryIt}!BPredUnit@{BPredUnit}}
\subsubsection[{HistoryIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef History::iterator {\bf HistoryIt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBPredUnit_abaefb3dcd19a61b2383910e6efb536eb}
\hypertarget{classBPredUnit_aa715df0f49f029439cca4c7bd6e3d4fb}{
\index{BPredUnit@{BPredUnit}!Params@{Params}}
\index{Params@{Params}!BPredUnit@{BPredUnit}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef BranchPredictorParams {\bf Params}}}
\label{classBPredUnit_aa715df0f49f029439cca4c7bd6e3d4fb}


\hyperlink{classSimObject_a0f0761d2db586a23bb2a2880b8f387bb}{SimObject}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classBPredUnit_a1061023e2f959cf88ef9064923a4667f}{
\index{BPredUnit@{BPredUnit}!BPredUnit@{BPredUnit}}
\index{BPredUnit@{BPredUnit}!BPredUnit@{BPredUnit}}
\subsubsection[{BPredUnit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BPredUnit} (const {\bf Params} $\ast$ {\em p})}}
\label{classBPredUnit_a1061023e2f959cf88ef9064923a4667f}

\begin{DoxyParams}{引数}
\item[{\em params}]The params object, that has the size of the BP and BTB. \end{DoxyParams}



\begin{DoxyCode}
59     : SimObject(params),
60       BTB(params->BTBEntries,
61           params->BTBTagSize,
62           params->instShiftAmt)
63 {
64     numThreads = params->numThreads;
65 
66     predHist = new History[numThreads];
67 
68     RAS = new ReturnAddrStack[numThreads];
69     for (int i=0; i < numThreads; i++)
70         RAS[i].init(params->RASSize);
71 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classBPredUnit_a391197cbd3ef7a4dd06e561671f1347a}{
\index{BPredUnit@{BPredUnit}!BTBLookup@{BTBLookup}}
\index{BTBLookup@{BTBLookup}!BPredUnit@{BPredUnit}}
\subsubsection[{BTBLookup}]{\setlength{\rightskip}{0pt plus 5cm}TheISA::PCState BTBLookup ({\bf Addr} {\em instPC})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBPredUnit_a391197cbd3ef7a4dd06e561671f1347a}
Looks up a given PC in the BTB to get the predicted target. 
\begin{DoxyParams}{引数}
\item[{\em inst\_\-PC}]The PC to look up. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
The address of the target of the branch. 
\end{DoxyReturn}



\begin{DoxyCode}
167     { return BTB.lookup(instPC, 0); }
\end{DoxyCode}
\hypertarget{classBPredUnit_a9c9cad624af5c71140d7f402ee4f1a2c}{
\index{BPredUnit@{BPredUnit}!BTBUpdate@{BTBUpdate}}
\index{BTBUpdate@{BTBUpdate}!BPredUnit@{BPredUnit}}
\subsubsection[{BTBUpdate}]{\setlength{\rightskip}{0pt plus 5cm}void BTBUpdate ({\bf Addr} {\em instPC}, \/  const TheISA::PCState \& {\em target})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBPredUnit_a9c9cad624af5c71140d7f402ee4f1a2c}
Updates the BTB with the target of a branch. 
\begin{DoxyParams}{引数}
\item[{\em inst\_\-PC}]The branch's PC that will be updated. \item[{\em target\_\-PC}]The branch's target that will be added to the BTB. \end{DoxyParams}



\begin{DoxyCode}
188     { BTB.update(instPC, target, 0); }
\end{DoxyCode}
\hypertarget{classBPredUnit_a7b687ebde63095b00a0b083ba6607cd4}{
\index{BPredUnit@{BPredUnit}!btbUpdate@{btbUpdate}}
\index{btbUpdate@{btbUpdate}!BPredUnit@{BPredUnit}}
\subsubsection[{btbUpdate}]{\setlength{\rightskip}{0pt plus 5cm}virtual void btbUpdate ({\bf Addr} {\em instPC}, \/  void $\ast$\& {\em bp\_\-history})\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classBPredUnit_a7b687ebde63095b00a0b083ba6607cd4}
If a branch is not taken, because the BTB address is invalid or missing, this function sets the appropriate counter in the global and local predictors to not taken. 
\begin{DoxyParams}{引数}
\item[{\em inst\_\-PC}]The PC to look up the local predictor. \item[{\em bp\_\-history}]Pointer that will be set to an object that has the branch predictor state associated with the lookup. \end{DoxyParams}


\hyperlink{classLocalBP_a101ada238eecd07cc6905c60272e2693}{LocalBP}, と \hyperlink{classTournamentBP_a101ada238eecd07cc6905c60272e2693}{TournamentBP}で実装されています。\hypertarget{classBPredUnit_a93ec70ede183b1d9c34cef98153c01f8}{
\index{BPredUnit@{BPredUnit}!BTBValid@{BTBValid}}
\index{BTBValid@{BTBValid}!BPredUnit@{BPredUnit}}
\subsubsection[{BTBValid}]{\setlength{\rightskip}{0pt plus 5cm}bool BTBValid ({\bf Addr} {\em instPC})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBPredUnit_a93ec70ede183b1d9c34cef98153c01f8}
Looks up a given PC in the BTB to see if a matching entry exists. 
\begin{DoxyParams}{引数}
\item[{\em inst\_\-PC}]The PC to look up. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Whether the BTB contains the given PC. 
\end{DoxyReturn}



\begin{DoxyCode}
159     { return BTB.valid(instPC, 0); }
\end{DoxyCode}
\hypertarget{classBPredUnit_a0240eb42fa57fe5d3788093f62b77347}{
\index{BPredUnit@{BPredUnit}!drainSanityCheck@{drainSanityCheck}}
\index{drainSanityCheck@{drainSanityCheck}!BPredUnit@{BPredUnit}}
\subsubsection[{drainSanityCheck}]{\setlength{\rightskip}{0pt plus 5cm}void drainSanityCheck () const}}
\label{classBPredUnit_a0240eb42fa57fe5d3788093f62b77347}
Perform sanity checks after a drain. 


\begin{DoxyCode}
126 {
127     // We shouldn't have any outstanding requests when we resume from
128     // a drained system.
129     for (int i = 0; i < numThreads; ++i)
130         assert(predHist[i].empty());
131 }
\end{DoxyCode}
\hypertarget{classBPredUnit_accd2600060dbaee3a3b41aed4034c63c}{
\index{BPredUnit@{BPredUnit}!dump@{dump}}
\index{dump@{dump}!BPredUnit@{BPredUnit}}
\subsubsection[{dump}]{\setlength{\rightskip}{0pt plus 5cm}void dump ()}}
\label{classBPredUnit_accd2600060dbaee3a3b41aed4034c63c}



\begin{DoxyCode}
518 {
519     HistoryIt pred_hist_it;
520 
521     for (int i = 0; i < numThreads; ++i) {
522         if (!predHist[i].empty()) {
523             pred_hist_it = predHist[i].begin();
524 
525             cprintf("predHist[%i].size(): %i\n", i, predHist[i].size());
526 
527             while (pred_hist_it != predHist[i].end()) {
528                 cprintf("[sn:%lli], PC:%#x, tid:%i, predTaken:%i, "
529                         "bpHistory:%#x\n",
530                         pred_hist_it->seqNum, pred_hist_it->pc,
531                         pred_hist_it->tid, pred_hist_it->predTaken,
532                         pred_hist_it->bpHistory);
533                 pred_hist_it++;
534             }
535 
536             cprintf("\n");
537         }
538     }
539 }
\end{DoxyCode}
\hypertarget{classBPredUnit_a5632fdea0abc34f7d68d8445a7a6c166}{
\index{BPredUnit@{BPredUnit}!lookup@{lookup}}
\index{lookup@{lookup}!BPredUnit@{BPredUnit}}
\subsubsection[{lookup}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool lookup ({\bf Addr} {\em instPC}, \/  void $\ast$\& {\em bp\_\-history})\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classBPredUnit_a5632fdea0abc34f7d68d8445a7a6c166}
Looks up a given PC in the BP to see if it is taken or not taken. 
\begin{DoxyParams}{引数}
\item[{\em inst\_\-PC}]The PC to look up. \item[{\em bp\_\-history}]Pointer that will be set to an object that has the branch predictor state associated with the lookup. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Whether the branch is taken or not taken. 
\end{DoxyReturn}


\hyperlink{classLocalBP_a9c30d728e49473b5a3825835e98a10bc}{LocalBP}, と \hyperlink{classTournamentBP_a9c30d728e49473b5a3825835e98a10bc}{TournamentBP}で実装されています。\hypertarget{classBPredUnit_a9d2ad862133709eece4bf864fe378282}{
\index{BPredUnit@{BPredUnit}!predict@{predict}}
\index{predict@{predict}!BPredUnit@{BPredUnit}}
\subsubsection[{predict}]{\setlength{\rightskip}{0pt plus 5cm}bool predict ({\bf StaticInstPtr} \& {\em inst}, \/  const {\bf InstSeqNum} \& {\em seqNum}, \/  TheISA::PCState \& {\em pc}, \/  {\bf ThreadID} {\em tid})}}
\label{classBPredUnit_a9d2ad862133709eece4bf864fe378282}
Predicts whether or not the instruction is a taken branch, and the target of the branch if it is taken. 
\begin{DoxyParams}{引数}
\item[{\em inst}]The branch instruction. \item[{\em PC}]The predicted PC is passed back through this parameter. \item[{\em tid}]The thread id. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Returns if the branch is taken or not. 
\end{DoxyReturn}



\begin{DoxyCode}
136 {
137     // See if branch predictor predicts taken.
138     // If so, get its target addr either from the BTB or the RAS.
139     // Save off record of branch stuff so the RAS can be fixed
140     // up once it's done.
141 
142     bool pred_taken = false;
143     TheISA::PCState target = pc;
144 
145     ++lookups;
146 
147     void *bp_history = NULL;
148 
149     if (inst->isUncondCtrl()) {
150         DPRINTF(Branch, "[tid:%i]: Unconditional control.\n", tid);
151         pred_taken = true;
152         // Tell the BP there was an unconditional branch.
153         uncondBranch(bp_history);
154     } else {
155         ++condPredicted;
156         pred_taken = lookup(pc.instAddr(), bp_history);
157 
158         DPRINTF(Branch, "[tid:%i]: [sn:%i] Branch predictor"
159                 " predicted %i for PC %s\n", tid, seqNum,  pred_taken, pc);
160     }
161 
162     DPRINTF(Branch, "[tid:%i]: [sn:%i] Creating prediction history "
163             "for PC %s\n", tid, seqNum, pc);
164 
165     PredictorHistory predict_record(seqNum, pc.instAddr(),
166                                     pred_taken, bp_history, tid);
167 
168     // Now lookup in the BTB or RAS.
169     if (pred_taken) {
170         if (inst->isReturn()) {
171             ++usedRAS;
172             predict_record.wasReturn = true;
173             // If it's a function return call, then look up the address
174             // in the RAS.
175             TheISA::PCState rasTop = RAS[tid].top();
176             target = TheISA::buildRetPC(pc, rasTop);
177 
178             // Record the top entry of the RAS, and its index.
179             predict_record.usedRAS = true;
180             predict_record.RASIndex = RAS[tid].topIdx();
181             predict_record.RASTarget = rasTop;
182 
183             RAS[tid].pop();
184 
185             DPRINTF(Branch, "[tid:%i]: Instruction %s is a return, "
186                     "RAS predicted target: %s, RAS index: %i.\n",
187                     tid, pc, target, predict_record.RASIndex);
188         } else {
189             ++BTBLookups;
190 
191             if (inst->isCall()) {
192                 RAS[tid].push(pc);
193                 predict_record.pushedRAS = true;
194 
195                 // Record that it was a call so that the top RAS entry can
196                 // be popped off if the speculation is incorrect.
197                 predict_record.wasCall = true;
198 
199                 DPRINTF(Branch, "[tid:%i]: Instruction %s was a "
200                         "call, adding %s to the RAS index: %i.\n",
201                         tid, pc, pc, RAS[tid].topIdx());
202             }
203 
204             if (BTB.valid(pc.instAddr(), tid)) {
205                 ++BTBHits;
206 
207                 // If it's not a return, use the BTB to get the target addr.
208                 target = BTB.lookup(pc.instAddr(), tid);
209 
210                 DPRINTF(Branch, "[tid:%i]: Instruction %s predicted"
211                         " target is %s.\n", tid, pc, target);
212 
213             } else {
214                 DPRINTF(Branch, "[tid:%i]: BTB doesn't have a "
215                         "valid entry.\n",tid);
216                 pred_taken = false;
217                 // The Direction of the branch predictor is altered because the
218                 // BTB did not have an entry
219                 // The predictor needs to be updated accordingly
220                 if (!inst->isCall() && !inst->isReturn()) {
221                       btbUpdate(pc.instAddr(), bp_history);
222                       DPRINTF(Branch, "[tid:%i]:[sn:%i] btbUpdate"
223                               " called for %s\n", tid, seqNum, pc);
224                 } else if (inst->isCall() && !inst->isUncondCtrl()) {
225                       RAS[tid].pop();
226                       predict_record.pushedRAS = false;
227                 }
228                 TheISA::advancePC(target, inst);
229             }
230         }
231     } else {
232         if (inst->isReturn()) {
233            predict_record.wasReturn = true;
234         }
235         TheISA::advancePC(target, inst);
236     }
237 
238     pc = target;
239 
240     predHist[tid].push_front(predict_record);
241 
242     DPRINTF(Branch, "[tid:%i]: [sn:%i]: History entry added."
243             "predHist.size(): %i\n", tid, seqNum, predHist[tid].size());
244 
245     return pred_taken;
246 }
\end{DoxyCode}
\hypertarget{classBPredUnit_a73a7edc2571c70838069e32ff33a2788}{
\index{BPredUnit@{BPredUnit}!predictInOrder@{predictInOrder}}
\index{predictInOrder@{predictInOrder}!BPredUnit@{BPredUnit}}
\subsubsection[{predictInOrder}]{\setlength{\rightskip}{0pt plus 5cm}bool predictInOrder ({\bf StaticInstPtr} \& {\em inst}, \/  const {\bf InstSeqNum} \& {\em seqNum}, \/  int {\em asid}, \/  TheISA::PCState \& {\em instPC}, \/  TheISA::PCState \& {\em predPC}, \/  {\bf ThreadID} {\em tid})}}
\label{classBPredUnit_a73a7edc2571c70838069e32ff33a2788}



\begin{DoxyCode}
252 {
253     // See if branch predictor predicts taken.
254     // If so, get its target addr either from the BTB or the RAS.
255     // Save off record of branch stuff so the RAS can be fixed
256     // up once it's done.
257 
258     using TheISA::MachInst;
259 
260     bool pred_taken = false;
261     TheISA::PCState target;
262 
263     ++lookups;
264     DPRINTF(Branch, "[tid:%i] [sn:%i] %s ... PC %s doing branch "
265             "prediction\n", tid, seqNum,
266             inst->disassemble(instPC.instAddr()), instPC);
267 
268     void *bp_history = NULL;
269 
270     if (inst->isUncondCtrl()) {
271         DPRINTF(Branch, "[tid:%i] Unconditional control.\n", tid);
272         pred_taken = true;
273         // Tell the BP there was an unconditional branch.
274         uncondBranch(bp_history);
275 
276         if (inst->isReturn() && RAS[tid].empty()) {
277             DPRINTF(Branch, "[tid:%i] RAS is empty, predicting "
278                     "false.\n", tid);
279             pred_taken = false;
280         }
281     } else {
282         ++condPredicted;
283 
284         pred_taken = lookup(predPC.instAddr(), bp_history);
285     }
286 
287     PredictorHistory predict_record(seqNum, predPC.instAddr(), pred_taken,
288                                     bp_history, tid);
289 
290     // Now lookup in the BTB or RAS.
291     if (pred_taken) {
292         if (inst->isReturn()) {
293             ++usedRAS;
294 
295             // If it's a function return call, then look up the address
296             // in the RAS.
297             TheISA::PCState rasTop = RAS[tid].top();
298             target = TheISA::buildRetPC(instPC, rasTop);
299 
300             // Record the top entry of the RAS, and its index.
301             predict_record.usedRAS = true;
302             predict_record.RASIndex = RAS[tid].topIdx();
303             predict_record.RASTarget = rasTop;
304 
305             assert(predict_record.RASIndex < 16);
306 
307             RAS[tid].pop();
308 
309             DPRINTF(Branch, "[tid:%i]: Instruction %s is a return, "
310                     "RAS predicted target: %s, RAS index: %i.\n",
311                     tid, instPC, target,
312                     predict_record.RASIndex);
313         } else {
314             ++BTBLookups;
315 
316             if (inst->isCall()) {
317 
318                 RAS[tid].push(instPC);
319                 predict_record.pushedRAS = true;
320 
321                 // Record that it was a call so that the top RAS entry can
322                 // be popped off if the speculation is incorrect.
323                 predict_record.wasCall = true;
324 
325                 DPRINTF(Branch, "[tid:%i]: Instruction %s was a call"
326                         ", adding %s to the RAS index: %i.\n",
327                         tid, instPC, predPC,
328                         RAS[tid].topIdx());
329             }
330 
331             if (inst->isCall() &&
332                 inst->isUncondCtrl() &&
333                 inst->isDirectCtrl()) {
334                 target = inst->branchTarget(instPC);
335             } else if (BTB.valid(predPC.instAddr(), asid)) {
336                 ++BTBHits;
337 
338                 // If it's not a return, use the BTB to get the target addr.
339                 target = BTB.lookup(predPC.instAddr(), asid);
340 
341                 DPRINTF(Branch, "[tid:%i]: [asid:%i] Instruction %s "
342                         "predicted target is %s.\n",
343                         tid, asid, instPC, target);
344             } else {
345                 DPRINTF(Branch, "[tid:%i]: BTB doesn't have a "
346                         "valid entry, predicting false.\n",tid);
347                 pred_taken = false;
348             }
349         }
350     }
351 
352     if (pred_taken) {
353         // Set the PC and the instruction's predicted target.
354         predPC = target;
355     }
356     DPRINTF(Branch, "[tid:%i]: [sn:%i]: Setting Predicted PC to %s.\n",
357             tid, seqNum, predPC);
358 
359     predHist[tid].push_front(predict_record);
360 
361     DPRINTF(Branch, "[tid:%i] [sn:%i] pushed onto front of predHist "
362             "...predHist.size(): %i\n",
363             tid, seqNum, predHist[tid].size());
364 
365     return pred_taken;
366 }
\end{DoxyCode}
\hypertarget{classBPredUnit_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{BPredUnit@{BPredUnit}!regStats@{regStats}}
\index{regStats@{regStats}!BPredUnit@{BPredUnit}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classBPredUnit_a4dc637449366fcdfc4e764cdf12d9b11}
Registers statistics. 

\hyperlink{classSimObject_a4dc637449366fcdfc4e764cdf12d9b11}{SimObject}を再定義しています。


\begin{DoxyCode}
75 {
76     lookups
77         .name(name() + ".lookups")
78         .desc("Number of BP lookups")
79         ;
80 
81     condPredicted
82         .name(name() + ".condPredicted")
83         .desc("Number of conditional branches predicted")
84         ;
85 
86     condIncorrect
87         .name(name() + ".condIncorrect")
88         .desc("Number of conditional branches incorrect")
89         ;
90 
91     BTBLookups
92         .name(name() + ".BTBLookups")
93         .desc("Number of BTB lookups")
94         ;
95 
96     BTBHits
97         .name(name() + ".BTBHits")
98         .desc("Number of BTB hits")
99         ;
100 
101     BTBCorrect
102         .name(name() + ".BTBCorrect")
103         .desc("Number of correct BTB predictions (this stat may not "
104               "work properly.")
105         ;
106 
107     BTBHitPct
108         .name(name() + ".BTBHitPct")
109         .desc("BTB Hit Percentage")
110         .precision(6);
111     BTBHitPct = (BTBHits / BTBLookups) * 100;
112 
113     usedRAS
114         .name(name() + ".usedRAS")
115         .desc("Number of times the RAS was used to get a target.")
116         ;
117 
118     RASIncorrect
119         .name(name() + ".RASInCorrect")
120         .desc("Number of incorrect RAS predictions.")
121         ;
122 }
\end{DoxyCode}
\hypertarget{classBPredUnit_a2af63ba741727bdf58e2b2dc22a912ed}{
\index{BPredUnit@{BPredUnit}!squash@{squash}}
\index{squash@{squash}!BPredUnit@{BPredUnit}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}virtual void squash (void $\ast$ {\em bp\_\-history})\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classBPredUnit_a2af63ba741727bdf58e2b2dc22a912ed}

\begin{DoxyParams}{引数}
\item[{\em bp\_\-history}]Pointer to the history object. The predictor will need to update any state and delete the object. \end{DoxyParams}


\hyperlink{classLocalBP_aeb215cee5cdccdf52d02b73fffe80220}{LocalBP}, と \hyperlink{classTournamentBP_aeb215cee5cdccdf52d02b73fffe80220}{TournamentBP}で実装されています。\hypertarget{classBPredUnit_af5d7fa639b2e7ef3c6449d26f93771a0}{
\index{BPredUnit@{BPredUnit}!squash@{squash}}
\index{squash@{squash}!BPredUnit@{BPredUnit}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash (const {\bf InstSeqNum} \& {\em squashed\_\-sn}, \/  const TheISA::PCState \& {\em corr\_\-target}, \/  bool {\em actually\_\-taken}, \/  {\bf ThreadID} {\em tid})}}
\label{classBPredUnit_af5d7fa639b2e7ef3c6449d26f93771a0}
Squashes all outstanding updates until a given sequence number, and corrects that sn's update with the proper address and taken/not taken. 
\begin{DoxyParams}{引数}
\item[{\em squashed\_\-sn}]The sequence number to squash any younger updates up until. \item[{\em corr\_\-target}]The correct branch target. \item[{\em actually\_\-taken}]The correct branch direction. \item[{\em tid}]The thread id. \end{DoxyParams}



\begin{DoxyCode}
424 {
425     // Now that we know that a branch was mispredicted, we need to undo
426     // all the branches that have been seen up until this branch and
427     // fix up everything.
428     // NOTE: This should be call conceivably in 2 scenarios:
429     // (1) After an branch is executed, it updates its status in the ROB
430     //     The commit stage then checks the ROB update and sends a signal to
431     //     the fetch stage to squash history after the mispredict
432     // (2) In the decode stage, you can find out early if a unconditional
433     //     PC-relative, branch was predicted incorrectly. If so, a signal
434     //     to the fetch stage is sent to squash history after the mispredict
435 
436     History &pred_hist = predHist[tid];
437 
438     ++condIncorrect;
439 
440     DPRINTF(Branch, "[tid:%i]: Squashing from sequence number %i, "
441             "setting target to %s.\n", tid, squashed_sn, corrTarget);
442 
443     // Squash All Branches AFTER this mispredicted branch
444     squash(squashed_sn, tid);
445 
446     // If there's a squash due to a syscall, there may not be an entry
447     // corresponding to the squash.  In that case, don't bother trying to
448     // fix up the entry.
449     if (!pred_hist.empty()) {
450 
451         HistoryIt hist_it = pred_hist.begin();
452         //HistoryIt hist_it = find(pred_hist.begin(), pred_hist.end(),
453         //                       squashed_sn);
454 
455         //assert(hist_it != pred_hist.end());
456         if (pred_hist.front().seqNum != squashed_sn) {
457             DPRINTF(Branch, "Front sn %i != Squash sn %i\n",
458                     pred_hist.front().seqNum, squashed_sn);
459 
460             assert(pred_hist.front().seqNum == squashed_sn);
461         }
462 
463 
464         if ((*hist_it).usedRAS) {
465             ++RASIncorrect;
466         }
467 
468         update((*hist_it).pc, actually_taken,
469                pred_hist.front().bpHistory, true);
470         if (actually_taken) {
471             if (hist_it->wasReturn && !hist_it->usedRAS) {
472                  DPRINTF(Branch, "[tid: %i] Incorrectly predicted"
473                          "  return [sn:%i] PC: %s\n", tid, hist_it->seqNum,
474                          hist_it->pc);
475                  RAS[tid].pop();
476             }
477 
478             DPRINTF(Branch,"[tid: %i] BTB Update called for [sn:%i]"
479                     " PC: %s\n", tid,hist_it->seqNum, hist_it->pc);
480 
481             BTB.update((*hist_it).pc, corrTarget, tid);
482 
483         } else {
484            //Actually not Taken
485            if (hist_it->usedRAS) {
486                 DPRINTF(Branch,"[tid: %i] Incorrectly predicted"
487                         "  return [sn:%i] PC: %s Restoring RAS\n", tid,
488                         hist_it->seqNum, hist_it->pc);
489                 DPRINTF(Branch, "[tid:%i]: Restoring top of RAS"
490                         " to: %i, target: %s.\n", tid,
491                         hist_it->RASIndex, hist_it->RASTarget);
492                 RAS[tid].restore(hist_it->RASIndex, hist_it->RASTarget);
493 
494            } else if (hist_it->wasCall && hist_it->pushedRAS) {
495                  //Was a Call but predicated false. Pop RAS here
496                  DPRINTF(Branch, "[tid: %i] Incorrectly predicted"
497                          "  Call [sn:%i] PC: %s Popping RAS\n", tid,
498                          hist_it->seqNum, hist_it->pc);
499                  RAS[tid].pop();
500            }
501         }
502         DPRINTF(Branch, "[tid:%i]: Removing history for [sn:%i]"
503                 " PC %s  Actually Taken: %i\n", tid, hist_it->seqNum,
504                 hist_it->pc, actually_taken);
505 
506         pred_hist.erase(hist_it);
507 
508         DPRINTF(Branch, "[tid:%i]: predHist.size(): %i\n", tid,
509                                          predHist[tid].size());
510     } else {
511         DPRINTF(Branch, "[tid:%i]: [sn:%i] pred_hist empty, can't "
512                 "update.\n", tid, squashed_sn);
513     }
514 }
\end{DoxyCode}
\hypertarget{classBPredUnit_af62f441ad740da2cd987637cfa87dfe5}{
\index{BPredUnit@{BPredUnit}!squash@{squash}}
\index{squash@{squash}!BPredUnit@{BPredUnit}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash (const {\bf InstSeqNum} \& {\em squashed\_\-sn}, \/  {\bf ThreadID} {\em tid})}}
\label{classBPredUnit_af62f441ad740da2cd987637cfa87dfe5}
Squashes all outstanding updates until a given sequence number. 
\begin{DoxyParams}{引数}
\item[{\em squashed\_\-sn}]The sequence number to squash any younger updates up until. \item[{\em tid}]The thread id. \end{DoxyParams}



\begin{DoxyCode}
386 {
387     History &pred_hist = predHist[tid];
388 
389     while (!pred_hist.empty() &&
390            pred_hist.front().seqNum > squashed_sn) {
391         if (pred_hist.front().usedRAS) {
392             DPRINTF(Branch, "[tid:%i]: Restoring top of RAS to: %i,"
393                     " target: %s.\n", tid,
394                     pred_hist.front().RASIndex, pred_hist.front().RASTarget);
395 
396             RAS[tid].restore(pred_hist.front().RASIndex,
397                              pred_hist.front().RASTarget);
398         } else if(pred_hist.front().wasCall && pred_hist.front().pushedRAS) {
399              // Was a call but predicated false. Pop RAS here
400              DPRINTF(Branch, "[tid: %i] Squashing"
401                      "  Call [sn:%i] PC: %s Popping RAS\n", tid,
402                      pred_hist.front().seqNum, pred_hist.front().pc);
403              RAS[tid].pop();
404         }
405 
406         // This call should delete the bpHistory.
407         squash(pred_hist.front().bpHistory);
408 
409         DPRINTF(Branch, "[tid:%i]: Removing history for [sn:%i] "
410                 "PC %s.\n", tid, pred_hist.front().seqNum,
411                 pred_hist.front().pc);
412 
413         pred_hist.pop_front();
414 
415         DPRINTF(Branch, "[tid:%i]: predHist.size(): %i\n",
416                 tid, predHist[tid].size());
417     }
418 }
\end{DoxyCode}
\hypertarget{classBPredUnit_a17161e0c51444f148e49e4df2ba89704}{
\index{BPredUnit@{BPredUnit}!uncondBranch@{uncondBranch}}
\index{uncondBranch@{uncondBranch}!BPredUnit@{BPredUnit}}
\subsubsection[{uncondBranch}]{\setlength{\rightskip}{0pt plus 5cm}virtual void uncondBranch (void $\ast$\& {\em bp\_\-history})\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classBPredUnit_a17161e0c51444f148e49e4df2ba89704}


\hyperlink{classLocalBP_ad3d898a5eab93d923a1073fe6a0f0030}{LocalBP}, と \hyperlink{classTournamentBP_ad3d898a5eab93d923a1073fe6a0f0030}{TournamentBP}で実装されています。\hypertarget{classBPredUnit_ab00dd76dc9f830cdae0edc72357c013a}{
\index{BPredUnit@{BPredUnit}!update@{update}}
\index{update@{update}!BPredUnit@{BPredUnit}}
\subsubsection[{update}]{\setlength{\rightskip}{0pt plus 5cm}virtual void update ({\bf Addr} {\em instPC}, \/  bool {\em taken}, \/  void $\ast$ {\em bp\_\-history}, \/  bool {\em squashed})\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classBPredUnit_ab00dd76dc9f830cdae0edc72357c013a}
Updates the BP with taken/not taken information. 
\begin{DoxyParams}{引数}
\item[{\em inst\_\-PC}]The branch's PC that will be updated. \item[{\em taken}]Whether the branch was taken or not taken. \item[{\em bp\_\-history}]Pointer to the branch predictor state that is associated with the branch lookup that is being updated. \item[{\em squashed}]\hyperlink{classSet}{Set} to true when this function is called during a squash operation. \end{DoxyParams}
\begin{Desc}
\item[\hyperlink{todo__todo000048}{TODO}]Make this update flexible enough to handle a global predictor. \end{Desc}


\hyperlink{classLocalBP_a590e0fd17d5b663e25f0e956fadc7062}{LocalBP}, と \hyperlink{classTournamentBP_a590e0fd17d5b663e25f0e956fadc7062}{TournamentBP}で実装されています。\hypertarget{classBPredUnit_a6e4be480aeb0d4acfb352802ab73a3df}{
\index{BPredUnit@{BPredUnit}!update@{update}}
\index{update@{update}!BPredUnit@{BPredUnit}}
\subsubsection[{update}]{\setlength{\rightskip}{0pt plus 5cm}void update (const {\bf InstSeqNum} \& {\em done\_\-sn}, \/  {\bf ThreadID} {\em tid})}}
\label{classBPredUnit_a6e4be480aeb0d4acfb352802ab73a3df}
Tells the branch predictor to commit any updates until the given sequence number. 
\begin{DoxyParams}{引数}
\item[{\em done\_\-sn}]The sequence number to commit any older updates up until. \item[{\em tid}]The thread id. \end{DoxyParams}



\begin{DoxyCode}
370 {
371     DPRINTF(Branch, "[tid:%i]: Committing branches until "
372             "[sn:%lli].\n", tid, done_sn);
373 
374     while (!predHist[tid].empty() &&
375            predHist[tid].back().seqNum <= done_sn) {
376         // Update the branch predictor with the correct results.
377         update(predHist[tid].back().pc, predHist[tid].back().predTaken,
378                predHist[tid].back().bpHistory, false);
379 
380         predHist[tid].pop_back();
381     }
382 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classBPredUnit_abd4f25a0378890fc9bfa1adef49cc0ce}{
\index{BPredUnit@{BPredUnit}!BTB@{BTB}}
\index{BTB@{BTB}!BPredUnit@{BPredUnit}}
\subsubsection[{BTB}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DefaultBTB} {\bf BTB}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBPredUnit_abd4f25a0378890fc9bfa1adef49cc0ce}
The BTB. \hypertarget{classBPredUnit_a05ffad6906b6204237963e1d3652be90}{
\index{BPredUnit@{BPredUnit}!BTBCorrect@{BTBCorrect}}
\index{BTBCorrect@{BTBCorrect}!BPredUnit@{BPredUnit}}
\subsubsection[{BTBCorrect}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf BTBCorrect}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBPredUnit_a05ffad6906b6204237963e1d3652be90}
Stat for number of times the BTB is correct. \hypertarget{classBPredUnit_adeb28302a86d176687ddfc4227ef78ff}{
\index{BPredUnit@{BPredUnit}!BTBHitPct@{BTBHitPct}}
\index{BTBHitPct@{BTBHitPct}!BPredUnit@{BPredUnit}}
\subsubsection[{BTBHitPct}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf BTBHitPct}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBPredUnit_adeb28302a86d176687ddfc4227ef78ff}
Stat for percent times an entry in BTB found. \hypertarget{classBPredUnit_a62943c2b7168001cfb6cf5f3a724e04a}{
\index{BPredUnit@{BPredUnit}!BTBHits@{BTBHits}}
\index{BTBHits@{BTBHits}!BPredUnit@{BPredUnit}}
\subsubsection[{BTBHits}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf BTBHits}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBPredUnit_a62943c2b7168001cfb6cf5f3a724e04a}
Stat for number of BTB hits. \hypertarget{classBPredUnit_aa62bafdbd09ec7c26031a8b58a042569}{
\index{BPredUnit@{BPredUnit}!BTBLookups@{BTBLookups}}
\index{BTBLookups@{BTBLookups}!BPredUnit@{BPredUnit}}
\subsubsection[{BTBLookups}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf BTBLookups}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBPredUnit_aa62bafdbd09ec7c26031a8b58a042569}
Stat for number of BTB lookups. \hypertarget{classBPredUnit_a185c5e4f3b5ec64fe7a1120ead854d93}{
\index{BPredUnit@{BPredUnit}!condIncorrect@{condIncorrect}}
\index{condIncorrect@{condIncorrect}!BPredUnit@{BPredUnit}}
\subsubsection[{condIncorrect}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf condIncorrect}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBPredUnit_a185c5e4f3b5ec64fe7a1120ead854d93}
Stat for number of conditional branches predicted incorrectly. \hypertarget{classBPredUnit_a5c78c3319018e9949a36e46bfe617905}{
\index{BPredUnit@{BPredUnit}!condPredicted@{condPredicted}}
\index{condPredicted@{condPredicted}!BPredUnit@{BPredUnit}}
\subsubsection[{condPredicted}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf condPredicted}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBPredUnit_a5c78c3319018e9949a36e46bfe617905}
Stat for number of conditional branches predicted. \hypertarget{classBPredUnit_a4a025c8c15499fd8df40b46f39496321}{
\index{BPredUnit@{BPredUnit}!lookups@{lookups}}
\index{lookups@{lookups}!BPredUnit@{BPredUnit}}
\subsubsection[{lookups}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf lookups}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBPredUnit_a4a025c8c15499fd8df40b46f39496321}
Stat for number of BP lookups. \hypertarget{classBPredUnit_a82dc714137537bc6ed526164d95f6674}{
\index{BPredUnit@{BPredUnit}!numThreads@{numThreads}}
\index{numThreads@{numThreads}!BPredUnit@{BPredUnit}}
\subsubsection[{numThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf numThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBPredUnit_a82dc714137537bc6ed526164d95f6674}
Number of the threads for which the branch history is maintained. \hypertarget{classBPredUnit_a17866949610525907d51191ce3271e73}{
\index{BPredUnit@{BPredUnit}!predHist@{predHist}}
\index{predHist@{predHist}!BPredUnit@{BPredUnit}}
\subsubsection[{predHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf History}$\ast$ {\bf predHist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBPredUnit_a17866949610525907d51191ce3271e73}
The per-\/thread predictor history. This is used to update the predictor as instructions are committed, or restore it to the proper state after a squash. \hypertarget{classBPredUnit_aaff600a1f8b1b71ac7636e62cb7319dd}{
\index{BPredUnit@{BPredUnit}!RAS@{RAS}}
\index{RAS@{RAS}!BPredUnit@{BPredUnit}}
\subsubsection[{RAS}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ReturnAddrStack}$\ast$ {\bf RAS}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBPredUnit_aaff600a1f8b1b71ac7636e62cb7319dd}
The per-\/thread return address stack. \hypertarget{classBPredUnit_a8f16f8a930ca557e2a627a4dfa15e67f}{
\index{BPredUnit@{BPredUnit}!RASIncorrect@{RASIncorrect}}
\index{RASIncorrect@{RASIncorrect}!BPredUnit@{BPredUnit}}
\subsubsection[{RASIncorrect}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf RASIncorrect}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBPredUnit_a8f16f8a930ca557e2a627a4dfa15e67f}
Stat for number of times the RAS is incorrect. \hypertarget{classBPredUnit_af589fa2a7ce83147ab8c0d4169c0748f}{
\index{BPredUnit@{BPredUnit}!usedRAS@{usedRAS}}
\index{usedRAS@{usedRAS}!BPredUnit@{BPredUnit}}
\subsubsection[{usedRAS}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf usedRAS}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBPredUnit_af589fa2a7ce83147ab8c0d4169c0748f}
Stat for number of times the RAS is used to get a target. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/pred/\hyperlink{bpred__unit_8hh}{bpred\_\-unit.hh}\item 
cpu/pred/\hyperlink{bpred__unit__impl_8hh}{bpred\_\-unit\_\-impl.hh}\end{DoxyCompactItemize}
