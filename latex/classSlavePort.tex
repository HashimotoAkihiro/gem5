\hypertarget{classSlavePort}{
\section{クラス SlavePort}
\label{classSlavePort}\index{SlavePort@{SlavePort}}
}


{\ttfamily \#include $<$port.hh$>$}SlavePortに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=11cm]{classSlavePort}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSlavePort_a7f3816163b85700b0d74c0c275d030c9}{SlavePort} (const std::string \&name, \hyperlink{classMemObject}{MemObject} $\ast$\hyperlink{classPort_aba966efb6c1df4b015be3a396df6c318}{owner}, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} \hyperlink{classPort_a0a67444fc1c33a60fe4a92bfff05d0cb}{id}=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
virtual \hyperlink{classSlavePort_a4756d4cc1faf925dc00225c5e66c8394}{$\sim$SlavePort} ()
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classSlavePort_a4cc4d76bd3aaf333980c232125c8acc8}{sendAtomicSnoop} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classSlavePort_a821cf873ae00e77f71d77505a63cfed7}{sendFunctionalSnoop} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classSlavePort_a0c021b2778a3358d110bd8700fe85732}{sendTimingResp} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classSlavePort_a44317ff11e2c240ae72ca2f5f1d9076d}{sendTimingSnoopReq} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classSlavePort_a6172657b944e32a722d90a20c5896bb7}{sendRetry} ()
\item 
bool \hyperlink{classSlavePort_a5ce11b7a254d3cb756d94568f7cbc25d}{isSnooping} () const 
\item 
void \hyperlink{classSlavePort_afb438cc39c4c679860c791bcef6dc7f3}{sendRangeChange} () const 
\item 
virtual \hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classSlavePort_a6e967f8921e80748eb2be35b6b481a7e}{getAddrRanges} () const =0
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classSlavePort_af294915156f1e30f1d2e574dccc87945}{unbind} ()
\item 
void \hyperlink{classSlavePort_ad7992aad912bd9f1bf4774673a7980e1}{bind} (\hyperlink{classMasterPort}{MasterPort} \&master\_\-port)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classSlavePort_a428ab07671bc9372dc44a2487b12a726}{recvAtomic} (\hyperlink{classPacket}{PacketPtr} pkt)=0
\item 
virtual void \hyperlink{classSlavePort_a6a3d6f2e5dab6bed16d53d9e7c17378d}{recvFunctional} (\hyperlink{classPacket}{PacketPtr} pkt)=0
\item 
virtual bool \hyperlink{classSlavePort_abcece77e42f88ee41af8d3d01bb48253}{recvTimingReq} (\hyperlink{classPacket}{PacketPtr} pkt)=0
\item 
virtual bool \hyperlink{classSlavePort_ae808ca0180bf333d9072270ed66f17fe}{recvTimingSnoopResp} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual void \hyperlink{classSlavePort_ac1ccc3bcf7ebabb20b57fab99b2be5b0}{recvRetry} ()=0
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMasterPort}{MasterPort} $\ast$ \hyperlink{classSlavePort_a5e0f39f8e39e5b4c3dcf0991c627489b}{\_\-masterPort}
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classSlavePort_a6c830d413286a218b881eaca621285e4}{MasterPort}
\end{DoxyCompactItemize}


\subsection{説明}
A \hyperlink{classSlavePort}{SlavePort} is a specialisation of a port. In addition to the basic functionality of sending packets to its master peer, it also has functions specific to a slave, e.g. to send range changes and get the address ranges that the port responds to. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classSlavePort_a7f3816163b85700b0d74c0c275d030c9}{
\index{SlavePort@{SlavePort}!SlavePort@{SlavePort}}
\index{SlavePort@{SlavePort}!SlavePort@{SlavePort}}
\subsubsection[{SlavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SlavePort} (const std::string \& {\em name}, \/  {\bf MemObject} $\ast$ {\em owner}, \/  {\bf PortID} {\em id} = {\ttfamily {\bf InvalidPortID}})}}
\label{classSlavePort_a7f3816163b85700b0d74c0c275d030c9}
Slave port 


\begin{DoxyCode}
213     : BaseSlavePort(name, owner, id), _masterPort(NULL)
214 {
215 }
\end{DoxyCode}
\hypertarget{classSlavePort_a4756d4cc1faf925dc00225c5e66c8394}{
\index{SlavePort@{SlavePort}!$\sim$SlavePort@{$\sim$SlavePort}}
\index{$\sim$SlavePort@{$\sim$SlavePort}!SlavePort@{SlavePort}}
\subsubsection[{$\sim$SlavePort}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf SlavePort} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSlavePort_a4756d4cc1faf925dc00225c5e66c8394}



\begin{DoxyCode}
218 {
219 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classSlavePort_ad7992aad912bd9f1bf4774673a7980e1}{
\index{SlavePort@{SlavePort}!bind@{bind}}
\index{bind@{bind}!SlavePort@{SlavePort}}
\subsubsection[{bind}]{\setlength{\rightskip}{0pt plus 5cm}void bind ({\bf MasterPort} \& {\em master\_\-port})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSlavePort_ad7992aad912bd9f1bf4774673a7980e1}
Called by the master port to bind. Should never be called directly. 


\begin{DoxyCode}
230 {
231     _baseMasterPort = &master_port;
232     _masterPort = &master_port;
233 }
\end{DoxyCode}
\hypertarget{classSlavePort_a6e967f8921e80748eb2be35b6b481a7e}{
\index{SlavePort@{SlavePort}!getAddrRanges@{getAddrRanges}}
\index{getAddrRanges@{getAddrRanges}!SlavePort@{SlavePort}}
\subsubsection[{getAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf AddrRangeList} getAddrRanges () const\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classSlavePort_a6e967f8921e80748eb2be35b6b481a7e}
Get a list of the non-\/overlapping address ranges the owner is responsible for. All slave ports must override this function and return a populated list with at least one item.

\begin{DoxyReturn}{戻り値}
a list of ranges responded to 
\end{DoxyReturn}


\hyperlink{classPioPort_a36cf113d5e5e091ebddb32306c098fae}{PioPort}, \hyperlink{classPciDevice_1_1PciConfigPort_a36cf113d5e5e091ebddb32306c098fae}{PciConfigPort}, \hyperlink{classX86ISA_1_1IntDevice_1_1IntSlavePort_a36cf113d5e5e091ebddb32306c098fae}{IntSlavePort}, \hyperlink{classAddrMapper_1_1MapperSlavePort_a36cf113d5e5e091ebddb32306c098fae}{MapperSlavePort}, \hyperlink{classBridge_1_1BridgeSlavePort_a36cf113d5e5e091ebddb32306c098fae}{BridgeSlavePort}, \hyperlink{classCoherentBus_1_1CoherentBusSlavePort_a9367d737cb872cb8573f44b501f99363}{CoherentBusSlavePort}, \hyperlink{classCommMonitor_1_1MonitorSlavePort_a36cf113d5e5e091ebddb32306c098fae}{MonitorSlavePort}, \hyperlink{classDRAMCtrl_1_1MemoryPort_a36cf113d5e5e091ebddb32306c098fae}{MemoryPort}, \hyperlink{classDRAMSim2_1_1MemoryPort_a36cf113d5e5e091ebddb32306c098fae}{MemoryPort}, \hyperlink{classNoncoherentBus_1_1NoncoherentBusSlavePort_a9367d737cb872cb8573f44b501f99363}{NoncoherentBusSlavePort}, \hyperlink{classRubyPort_1_1MemSlavePort_a36cf113d5e5e091ebddb32306c098fae}{MemSlavePort}, \hyperlink{classRubyPort_1_1PioSlavePort_a36cf113d5e5e091ebddb32306c098fae}{PioSlavePort}, と \hyperlink{classSimpleMemory_1_1MemoryPort_a36cf113d5e5e091ebddb32306c098fae}{MemoryPort}で実装されています。\hypertarget{classSlavePort_a5ce11b7a254d3cb756d94568f7cbc25d}{
\index{SlavePort@{SlavePort}!isSnooping@{isSnooping}}
\index{isSnooping@{isSnooping}!SlavePort@{SlavePort}}
\subsubsection[{isSnooping}]{\setlength{\rightskip}{0pt plus 5cm}bool isSnooping () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSlavePort_a5ce11b7a254d3cb756d94568f7cbc25d}
Find out if the peer master port is snooping or not.

\begin{DoxyReturn}{戻り値}
true if the peer master port is snooping 
\end{DoxyReturn}



\begin{DoxyCode}
402 { return _masterPort->isSnooping(); }
\end{DoxyCode}
\hypertarget{classSlavePort_a428ab07671bc9372dc44a2487b12a726}{
\index{SlavePort@{SlavePort}!recvAtomic@{recvAtomic}}
\index{recvAtomic@{recvAtomic}!SlavePort@{SlavePort}}
\subsubsection[{recvAtomic}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Tick} recvAtomic ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classSlavePort_a428ab07671bc9372dc44a2487b12a726}
Receive an atomic request packet from the master port. 

\hyperlink{classPioPort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{PioPort}, \hyperlink{classPciDevice_1_1PciConfigPort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{PciConfigPort}, \hyperlink{classAddrMapper_1_1MapperSlavePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{MapperSlavePort}, \hyperlink{classBridge_1_1BridgeSlavePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{BridgeSlavePort}, \hyperlink{classCoherentBus_1_1CoherentBusSlavePort_a9b5348b3521da3a6333e6b0eed3b98e6}{CoherentBusSlavePort}, \hyperlink{classCommMonitor_1_1MonitorSlavePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{MonitorSlavePort}, \hyperlink{classDRAMCtrl_1_1MemoryPort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{MemoryPort}, \hyperlink{classDRAMSim2_1_1MemoryPort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{MemoryPort}, \hyperlink{classMessageSlavePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{MessageSlavePort}, \hyperlink{classNoncoherentBus_1_1NoncoherentBusSlavePort_a9b5348b3521da3a6333e6b0eed3b98e6}{NoncoherentBusSlavePort}, \hyperlink{classRubyPort_1_1MemSlavePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{MemSlavePort}, \hyperlink{classRubyPort_1_1PioSlavePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{PioSlavePort}, \hyperlink{classSimpleMemory_1_1MemoryPort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{MemoryPort}, と \hyperlink{classSimpleTimingPort_a428ab07671bc9372dc44a2487b12a726}{SimpleTimingPort}で実装されています。\hypertarget{classSlavePort_a6a3d6f2e5dab6bed16d53d9e7c17378d}{
\index{SlavePort@{SlavePort}!recvFunctional@{recvFunctional}}
\index{recvFunctional@{recvFunctional}!SlavePort@{SlavePort}}
\subsubsection[{recvFunctional}]{\setlength{\rightskip}{0pt plus 5cm}virtual void recvFunctional ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classSlavePort_a6a3d6f2e5dab6bed16d53d9e7c17378d}
Receive a functional request packet from the master port. 

\hyperlink{classAddrMapper_1_1MapperSlavePort_aeefa907fb6d6a787e6dab90e8138ea90}{MapperSlavePort}, \hyperlink{classBridge_1_1BridgeSlavePort_aeefa907fb6d6a787e6dab90e8138ea90}{BridgeSlavePort}, \hyperlink{classCoherentBus_1_1CoherentBusSlavePort_a914924599c231593833dd1d527b4bb7c}{CoherentBusSlavePort}, \hyperlink{classCommMonitor_1_1MonitorSlavePort_aeefa907fb6d6a787e6dab90e8138ea90}{MonitorSlavePort}, \hyperlink{classDRAMCtrl_1_1MemoryPort_aeefa907fb6d6a787e6dab90e8138ea90}{MemoryPort}, \hyperlink{classDRAMSim2_1_1MemoryPort_aeefa907fb6d6a787e6dab90e8138ea90}{MemoryPort}, \hyperlink{classNoncoherentBus_1_1NoncoherentBusSlavePort_a914924599c231593833dd1d527b4bb7c}{NoncoherentBusSlavePort}, \hyperlink{classRubyPort_1_1MemSlavePort_aeefa907fb6d6a787e6dab90e8138ea90}{MemSlavePort}, \hyperlink{classRubyPort_1_1PioSlavePort_aeefa907fb6d6a787e6dab90e8138ea90}{PioSlavePort}, \hyperlink{classSimpleMemory_1_1MemoryPort_aeefa907fb6d6a787e6dab90e8138ea90}{MemoryPort}, と \hyperlink{classSimpleTimingPort_aeefa907fb6d6a787e6dab90e8138ea90}{SimpleTimingPort}で実装されています。\hypertarget{classSlavePort_ac1ccc3bcf7ebabb20b57fab99b2be5b0}{
\index{SlavePort@{SlavePort}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!SlavePort@{SlavePort}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}virtual void recvRetry ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classSlavePort_ac1ccc3bcf7ebabb20b57fab99b2be5b0}
Called by the master port if sendTimingResp was called on this slave port (causing recvTimingResp to be called on the master port) and was unsuccesful. 

\hyperlink{classAddrMapper_1_1MapperSlavePort_a29cb5a4f98063ce6e9210eacbdb35298}{MapperSlavePort}, \hyperlink{classBridge_1_1BridgeSlavePort_a29cb5a4f98063ce6e9210eacbdb35298}{BridgeSlavePort}, \hyperlink{classCoherentBus_1_1CoherentBusSlavePort_a7ec461ad187b82b4b21e27c86e45cf9c}{CoherentBusSlavePort}, \hyperlink{classCommMonitor_1_1MonitorSlavePort_a29cb5a4f98063ce6e9210eacbdb35298}{MonitorSlavePort}, \hyperlink{classDRAMSim2_1_1MemoryPort_a29cb5a4f98063ce6e9210eacbdb35298}{MemoryPort}, \hyperlink{classNoncoherentBus_1_1NoncoherentBusSlavePort_a7ec461ad187b82b4b21e27c86e45cf9c}{NoncoherentBusSlavePort}, \hyperlink{classQueuedSlavePort_a7ec461ad187b82b4b21e27c86e45cf9c}{QueuedSlavePort}, と \hyperlink{classSimpleMemory_1_1MemoryPort_a29cb5a4f98063ce6e9210eacbdb35298}{MemoryPort}で実装されています。\hypertarget{classSlavePort_abcece77e42f88ee41af8d3d01bb48253}{
\index{SlavePort@{SlavePort}!recvTimingReq@{recvTimingReq}}
\index{recvTimingReq@{recvTimingReq}!SlavePort@{SlavePort}}
\subsubsection[{recvTimingReq}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool recvTimingReq ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classSlavePort_abcece77e42f88ee41af8d3d01bb48253}
Receive a timing request from the master port. 

\hyperlink{classAddrMapper_1_1MapperSlavePort_a3344d9dd0f83257feab5424e761f31c6}{MapperSlavePort}, \hyperlink{classBridge_1_1BridgeSlavePort_a3344d9dd0f83257feab5424e761f31c6}{BridgeSlavePort}, \hyperlink{classCoherentBus_1_1CoherentBusSlavePort_ad3786e65574e70ec0a5bd2b0ce311d20}{CoherentBusSlavePort}, \hyperlink{classCommMonitor_1_1MonitorSlavePort_a3344d9dd0f83257feab5424e761f31c6}{MonitorSlavePort}, \hyperlink{classDRAMCtrl_1_1MemoryPort_a8a15a0ae9c080c5f879fc5e791a9e3e7}{MemoryPort}, \hyperlink{classDRAMSim2_1_1MemoryPort_a3344d9dd0f83257feab5424e761f31c6}{MemoryPort}, \hyperlink{classNoncoherentBus_1_1NoncoherentBusSlavePort_ad3786e65574e70ec0a5bd2b0ce311d20}{NoncoherentBusSlavePort}, \hyperlink{classRubyPort_1_1MemSlavePort_a3344d9dd0f83257feab5424e761f31c6}{MemSlavePort}, \hyperlink{classRubyPort_1_1PioSlavePort_a3344d9dd0f83257feab5424e761f31c6}{PioSlavePort}, \hyperlink{classSimpleMemory_1_1MemoryPort_a3344d9dd0f83257feab5424e761f31c6}{MemoryPort}, と \hyperlink{classSimpleTimingPort_a3344d9dd0f83257feab5424e761f31c6}{SimpleTimingPort}で実装されています。\hypertarget{classSlavePort_ae808ca0180bf333d9072270ed66f17fe}{
\index{SlavePort@{SlavePort}!recvTimingSnoopResp@{recvTimingSnoopResp}}
\index{recvTimingSnoopResp@{recvTimingSnoopResp}!SlavePort@{SlavePort}}
\subsubsection[{recvTimingSnoopResp}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool recvTimingSnoopResp ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classSlavePort_ae808ca0180bf333d9072270ed66f17fe}
Receive a timing snoop response from the master port. 

\hyperlink{classAddrMapper_1_1MapperSlavePort_a9b643d565edc21dac11ce15a560238a7}{MapperSlavePort}, \hyperlink{classCoherentBus_1_1CoherentBusSlavePort_ae808ca0180bf333d9072270ed66f17fe}{CoherentBusSlavePort}, と \hyperlink{classCommMonitor_1_1MonitorSlavePort_a9b643d565edc21dac11ce15a560238a7}{MonitorSlavePort}で再定義されています。


\begin{DoxyCode}
451     {
452         panic("%s was not expecting a timing snoop response\n", name());
453     }
\end{DoxyCode}
\hypertarget{classSlavePort_a4cc4d76bd3aaf333980c232125c8acc8}{
\index{SlavePort@{SlavePort}!sendAtomicSnoop@{sendAtomicSnoop}}
\index{sendAtomicSnoop@{sendAtomicSnoop}!SlavePort@{SlavePort}}
\subsubsection[{sendAtomicSnoop}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} sendAtomicSnoop ({\bf PacketPtr} {\em pkt})}}
\label{classSlavePort_a4cc4d76bd3aaf333980c232125c8acc8}
Send an atomic snoop request packet, where the data is moved and the state is updated in zero time, without interleaving with other memory accesses.


\begin{DoxyParams}{引数}
\item[{\em pkt}]Snoop packet to send.\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Estimated latency of access. 
\end{DoxyReturn}



\begin{DoxyCode}
237 {
238     assert(pkt->isRequest());
239     return _masterPort->recvAtomicSnoop(pkt);
240 }
\end{DoxyCode}
\hypertarget{classSlavePort_a821cf873ae00e77f71d77505a63cfed7}{
\index{SlavePort@{SlavePort}!sendFunctionalSnoop@{sendFunctionalSnoop}}
\index{sendFunctionalSnoop@{sendFunctionalSnoop}!SlavePort@{SlavePort}}
\subsubsection[{sendFunctionalSnoop}]{\setlength{\rightskip}{0pt plus 5cm}void sendFunctionalSnoop ({\bf PacketPtr} {\em pkt})}}
\label{classSlavePort_a821cf873ae00e77f71d77505a63cfed7}
Send a functional snoop request packet, where the data is instantly updated everywhere in the memory system, without affecting the current state of any block or moving the block.


\begin{DoxyParams}{引数}
\item[{\em pkt}]Snoop packet to send. \end{DoxyParams}



\begin{DoxyCode}
244 {
245     assert(pkt->isRequest());
246     return _masterPort->recvFunctionalSnoop(pkt);
247 }
\end{DoxyCode}
\hypertarget{classSlavePort_afb438cc39c4c679860c791bcef6dc7f3}{
\index{SlavePort@{SlavePort}!sendRangeChange@{sendRangeChange}}
\index{sendRangeChange@{sendRangeChange}!SlavePort@{SlavePort}}
\subsubsection[{sendRangeChange}]{\setlength{\rightskip}{0pt plus 5cm}void sendRangeChange () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSlavePort_afb438cc39c4c679860c791bcef6dc7f3}
Called by the owner to send a range change 


\begin{DoxyCode}
407 { _masterPort->recvRangeChange(); }
\end{DoxyCode}
\hypertarget{classSlavePort_a6172657b944e32a722d90a20c5896bb7}{
\index{SlavePort@{SlavePort}!sendRetry@{sendRetry}}
\index{sendRetry@{sendRetry}!SlavePort@{SlavePort}}
\subsubsection[{sendRetry}]{\setlength{\rightskip}{0pt plus 5cm}void sendRetry ()}}
\label{classSlavePort_a6172657b944e32a722d90a20c5896bb7}
Send a retry to the master port that previously attempted a sendTimingReq or sendTimingSnoopResp to this slave port and failed. 


\begin{DoxyCode}
265 {
266     _masterPort->recvRetry();
267 }
\end{DoxyCode}
\hypertarget{classSlavePort_a0c021b2778a3358d110bd8700fe85732}{
\index{SlavePort@{SlavePort}!sendTimingResp@{sendTimingResp}}
\index{sendTimingResp@{sendTimingResp}!SlavePort@{SlavePort}}
\subsubsection[{sendTimingResp}]{\setlength{\rightskip}{0pt plus 5cm}bool sendTimingResp ({\bf PacketPtr} {\em pkt})}}
\label{classSlavePort_a0c021b2778a3358d110bd8700fe85732}
Attempt to send a timing response to the master port by calling its corresponding receive function. If the send does not succeed, as indicated by the return value, then the sender must wait for a recvRetry at which point it can re-\/issue a sendTimingResp.


\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} to send.\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
If the send was succesful or not. 
\end{DoxyReturn}



\begin{DoxyCode}
251 {
252     assert(pkt->isResponse());
253     return _masterPort->recvTimingResp(pkt);
254 }
\end{DoxyCode}
\hypertarget{classSlavePort_a44317ff11e2c240ae72ca2f5f1d9076d}{
\index{SlavePort@{SlavePort}!sendTimingSnoopReq@{sendTimingSnoopReq}}
\index{sendTimingSnoopReq@{sendTimingSnoopReq}!SlavePort@{SlavePort}}
\subsubsection[{sendTimingSnoopReq}]{\setlength{\rightskip}{0pt plus 5cm}void sendTimingSnoopReq ({\bf PacketPtr} {\em pkt})}}
\label{classSlavePort_a44317ff11e2c240ae72ca2f5f1d9076d}
Attempt to send a timing snoop request packet to the master port by calling its corresponding receive function. Snoop requests always succeed and hence no return value is needed.


\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} to send. \end{DoxyParams}



\begin{DoxyCode}
258 {
259     assert(pkt->isRequest());
260     _masterPort->recvTimingSnoopReq(pkt);
261 }
\end{DoxyCode}
\hypertarget{classSlavePort_af294915156f1e30f1d2e574dccc87945}{
\index{SlavePort@{SlavePort}!unbind@{unbind}}
\index{unbind@{unbind}!SlavePort@{SlavePort}}
\subsubsection[{unbind}]{\setlength{\rightskip}{0pt plus 5cm}void unbind ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSlavePort_af294915156f1e30f1d2e574dccc87945}
Called by the master port to unbind. Should never be called directly. 


\begin{DoxyCode}
223 {
224     _baseMasterPort = NULL;
225     _masterPort = NULL;
226 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classSlavePort_a6c830d413286a218b881eaca621285e4}{
\index{SlavePort@{SlavePort}!MasterPort@{MasterPort}}
\index{MasterPort@{MasterPort}!SlavePort@{SlavePort}}
\subsubsection[{MasterPort}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf MasterPort}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classSlavePort_a6c830d413286a218b881eaca621285e4}


\subsection{変数}
\hypertarget{classSlavePort_a5e0f39f8e39e5b4c3dcf0991c627489b}{
\index{SlavePort@{SlavePort}!\_\-masterPort@{\_\-masterPort}}
\index{\_\-masterPort@{\_\-masterPort}!SlavePort@{SlavePort}}
\subsubsection[{\_\-masterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterPort}$\ast$ {\bf \_\-masterPort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSlavePort_a5e0f39f8e39e5b4c3dcf0991c627489b}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{port_8hh}{port.hh}\item 
mem/\hyperlink{port_8cc}{port.cc}\end{DoxyCompactItemize}
