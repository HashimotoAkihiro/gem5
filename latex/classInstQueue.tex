\hypertarget{classInstQueue}{
\section{クラス テンプレート InstQueue$<$ Impl $>$}
\label{classInstQueue}\index{InstQueue@{InstQueue}}
}


{\ttfamily \#include $<$inst\_\-queue.hh$>$}\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structInstQueue_1_1IQEntry}{IQEntry}
\item 
struct \hyperlink{structInstQueue_1_1pqCompare}{pqCompare}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef Impl::FullCPU \hyperlink{classInstQueue_a90ba84e54618cc07f2e8f05e046cb5ce}{FullCPU}
\item 
typedef Impl::DynInstPtr \hyperlink{classInstQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}
\item 
typedef Impl::Params \hyperlink{classInstQueue_a818e103eae798a24a06a0a34631849ea}{Params}
\item 
typedef Impl::IssueStruct \hyperlink{classInstQueue_a568c86f6403070f1cb743e994405ba8b}{IssueStruct}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classInstQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$::iterator \hyperlink{classInstQueue_a184cb829e22cc656acb41864f68f51ea}{ListIt}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classInstQueue_a679ee5512f178ea331ab7cd3ebf2aa78}{InstQueue} (\hyperlink{classInstQueue_a818e103eae798a24a06a0a34631849ea}{Params} $\ast$params)
\item 
\hyperlink{classInstQueue_aac3885a1c3df6261e14208fc83713c17}{$\sim$InstQueue} ()
\item 
std::string \hyperlink{classInstQueue_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classInstQueue_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classInstQueue_aa783e99c55fd8695cb33c087d14bece0}{setCPU} (\hyperlink{classInstQueue_a90ba84e54618cc07f2e8f05e046cb5ce}{FullCPU} $\ast$\_\-cpu)
\item 
void \hyperlink{classInstQueue_a7cbe625b8c47621898e7ca92d70c826b}{setIssueToExecuteQueue} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structIssueStruct}{IssueStruct} $>$ $\ast$i2eQueue)
\item 
unsigned \hyperlink{classInstQueue_a028971a565aca048c67ea1c36a6a9d51}{numFreeEntries} ()
\item 
unsigned \hyperlink{classInstQueue_acc878f608deead5b5319a6a3f98b50c8}{numFreeEntries} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classInstQueue_a3e70330939fdfc4dbc2f60c1a660584d}{isFull} ()
\item 
bool \hyperlink{classInstQueue_a30fac732df9b3fda011c7329a112cb31}{isFull} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classInstQueue_ae59aad9cee1e45b5817a9d96553e4567}{hasReadyInsts} ()
\item 
void \hyperlink{classInstQueue_a786595aecf8ab7aae40868b5ac4a79a7}{insert} (\hyperlink{classInstQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&new\_\-inst)
\item 
void \hyperlink{classInstQueue_a4f7523e76440d88096a4eac14f2e0dd3}{insertNonSpec} (\hyperlink{classInstQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&new\_\-inst)
\item 
void \hyperlink{classInstQueue_a3694e72427d3a616808797f9343d1fc4}{scheduleReadyInsts} ()
\item 
void \hyperlink{classInstQueue_a15ca5aaeab5bd4c2169ed41bbc7fb79c}{scheduleNonSpec} (const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&inst)
\item 
void \hyperlink{classInstQueue_a04f8d2acf3cd0b90a1efc69b528f91bc}{commit} (const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&inst, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid=0)
\item 
void \hyperlink{classInstQueue_ab9afe94d332a563b9485d1bb9acd68b4}{wakeDependents} (\hyperlink{classInstQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&completed\_\-inst)
\item 
void \hyperlink{classInstQueue_a76bcc078140b3e79923f7b5be8b302fb}{addReadyMemInst} (\hyperlink{classInstQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&ready\_\-inst)
\item 
void \hyperlink{classInstQueue_aad2715729f71f220e9cf9b99515384ca}{completeMemInst} (\hyperlink{classInstQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&completed\_\-inst)
\item 
void \hyperlink{classInstQueue_ad33d65c18c323d90695d7c2355b49af9}{squash} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
unsigned \hyperlink{classInstQueue_aaf7eb96b7ab2a8240d043b7d82494d15}{getCount} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classInstQueue_a358bf0d85e8cd8b606877b341c518b5e}{updateFreeEntries} (int num)
\item 
void \hyperlink{classInstQueue_afc9c0c90c27fe0dc8bd4da915596bc21}{printInsts} ()
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef std::priority\_\-queue$<$ \hyperlink{classInstQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}, \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classInstQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$, \hyperlink{structInstQueue_1_1pqCompare}{pqCompare} $>$ \hyperlink{classInstQueue_a60636ae8f3b649078c4f1bdd3b20dcad}{ReadyInstQueue}
\item 
typedef std::map$<$ \hyperlink{classInstQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}, \hyperlink{structInstQueue_1_1pqCompare}{pqCompare} $>$ \hyperlink{classInstQueue_afca3a0ab9af7309428eb77c726724000}{ReadyInstMap}
\item 
typedef std::map$<$ \hyperlink{classInstQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}, \hyperlink{structInstQueue_1_1pqCompare}{pqCompare} $>$::iterator \hyperlink{classInstQueue_a2ab2a44e2b7c4b408ceda3a9a2422ecb}{ReadyMapIt}
\item 
typedef std::map$<$ \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum}, \hyperlink{classInstQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$::iterator \hyperlink{classInstQueue_a0e9597437fae9e60d5449933949416ec}{NonSpecMapIt}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classInstQueue_a06cf52c4f09162bea03ec848f247151a}{doSquash} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classInstQueue_a7e3f1fa43ca939ed6fd9b3abcc47f06e}{addIfReady} (\hyperlink{classInstQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
int \hyperlink{classInstQueue_ab654970f03abd90f0c397bba8e218bc9}{countInsts} ()
\item 
void \hyperlink{classInstQueue_a3d1dae45e8e0b5cf7c1f4f8c796d070e}{dumpLists} ()
\item 
void \hyperlink{classInstQueue_a80587b4fe043bbe1995536cb3b361588}{dumpInsts} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classInstQueue_a90ba84e54618cc07f2e8f05e046cb5ce}{FullCPU} $\ast$ \hyperlink{classInstQueue_a766385c2941cd46525f4d9dff90200a2}{cpu}
\item 
MemInterface $\ast$ \hyperlink{classInstQueue_a22dc8294eecb144fbdd951d2e32e9330}{dcacheInterface}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structIssueStruct}{IssueStruct} $>$ $\ast$ \hyperlink{classInstQueue_af5c55240e63d9a13358eede4eb5352f1}{issueToExecuteQueue}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classInstQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classInstQueue_a7f2828a4f877a4a4d4b85a6788536b82}{instList} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classInstQueue_a60636ae8f3b649078c4f1bdd3b20dcad}{ReadyInstQueue} \hyperlink{classInstQueue_a73e22f052c708ca5c198bd0a01eb3604}{readyInsts}
\item 
std::map$<$ \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum}, \hyperlink{classInstQueue_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classInstQueue_ac0ba4d07026aaf6386c001a68d059cbf}{nonSpecInsts}
\item 
unsigned \hyperlink{classInstQueue_a792311f13ea91008a88e902ef13b0341}{numThreads}
\item 
unsigned \hyperlink{classInstQueue_ac638062ba1de6609f143c5ee3a601109}{count} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
unsigned \hyperlink{classInstQueue_a51e5f9f0cb40d61e95b1518f1be90b73}{maxEntries} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
unsigned \hyperlink{classInstQueue_ac2281ff630f82397bda33269f4ee8796}{freeEntries}
\item 
unsigned \hyperlink{classInstQueue_a325de474a9f6652329339d9fc2ea09c0}{numEntries}
\item 
unsigned \hyperlink{classInstQueue_ab3c3a8cd00248d9cd6acad330da902a7}{totalWidth}
\item 
unsigned \hyperlink{classInstQueue_a92c8d68d5f0e17758f89daa2647196f5}{commitToIEWDelay}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classInstQueue_a97d5a7e4630ad1d017909f7504b9ec32}{squashedSeqNum} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classInstQueue_a184cb829e22cc656acb41864f68f51ea}{ListIt} \hyperlink{classInstQueue_a76b506d03788e72757da427226e10356}{squashIt} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstQueue_a435e1ce10c3a7f54a60941e583adeb09}{iqInstsAdded}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstQueue_adf890a08fae50ea8249171b07c40adac}{iqNonSpecInstsAdded}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstQueue_a735f2023e70e53b7889a3a316bd3d57f}{iqIntInstsIssued}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstQueue_aa9f2fa124c9f0b4b22461b6717449d9a}{iqFloatInstsIssued}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstQueue_a928f22a2c6ce592adc40e5242c9d6572}{iqBranchInstsIssued}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstQueue_a5e7d55d3f07e86e389ca3a715766e108}{iqMemInstsIssued}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstQueue_ad234890bc414fffe7ed71840c51be5cb}{iqMiscInstsIssued}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstQueue_ac91799c895e5aff3af0afdbd7691a163}{iqSquashedInstsIssued}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstQueue_a8312e8984bcfab5a77de40e1738103db}{iqSquashedInstsExamined}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstQueue_a4398b6005b81008bd163bbba78dfd929}{iqSquashedOperandsExamined}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstQueue_a6c0b47431b6e84536fd9bb61624d6d97}{iqSquashedNonSpecRemoved}
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classInstQueue_a0b1390899d1d55620476dd762bd7ac6c}{Impl::FullCPU}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$class Impl$>$ class InstQueue$<$ Impl $>$}

A standard instruction queue class. It holds ready instructions, in order, in seperate priority queues to facilitate the scheduling of instructions. The IQ uses a separate linked list to track dependencies. Similar to the rename map and the free list, it expects that floating point registers have their indices start after the integer registers (ie with 96 int and 96 fp registers, regs 0-\/95 are integer and 96-\/191 are fp). This remains true even for both logical and physical register indices. The IQ depends on the memory dependence unit to track when memory operations are ready in terms of ordering; register dependencies are tracked normally. Right now the IQ also handles the execution timing; this is mainly to allow back-\/to-\/back scheduling without requiring IEW to be able to peek into the IQ. At the end of the execution latency, the instruction is put into the queue to execute, where it will have the execute() function called on it. \begin{Desc}
\item[\hyperlink{todo__todo000042}{TODO}]: Make IQ able to handle multiple FU pools. \end{Desc}


\subsection{型定義}
\hypertarget{classInstQueue_a028ce10889c5f6450239d9e9a7347976}{
\index{InstQueue@{InstQueue}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!InstQueue@{InstQueue}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInstPtr {\bf DynInstPtr}}}
\label{classInstQueue_a028ce10889c5f6450239d9e9a7347976}
\hypertarget{classInstQueue_a90ba84e54618cc07f2e8f05e046cb5ce}{
\index{InstQueue@{InstQueue}!FullCPU@{FullCPU}}
\index{FullCPU@{FullCPU}!InstQueue@{InstQueue}}
\subsubsection[{FullCPU}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::FullCPU {\bf FullCPU}}}
\label{classInstQueue_a90ba84e54618cc07f2e8f05e046cb5ce}
\hypertarget{classInstQueue_a568c86f6403070f1cb743e994405ba8b}{
\index{InstQueue@{InstQueue}!IssueStruct@{IssueStruct}}
\index{IssueStruct@{IssueStruct}!InstQueue@{InstQueue}}
\subsubsection[{IssueStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::IssueStruct {\bf IssueStruct}}}
\label{classInstQueue_a568c86f6403070f1cb743e994405ba8b}
\hypertarget{classInstQueue_a184cb829e22cc656acb41864f68f51ea}{
\index{InstQueue@{InstQueue}!ListIt@{ListIt}}
\index{ListIt@{ListIt}!InstQueue@{InstQueue}}
\subsubsection[{ListIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf DynInstPtr}$>$::iterator {\bf ListIt}}}
\label{classInstQueue_a184cb829e22cc656acb41864f68f51ea}
\hypertarget{classInstQueue_a0e9597437fae9e60d5449933949416ec}{
\index{InstQueue@{InstQueue}!NonSpecMapIt@{NonSpecMapIt}}
\index{NonSpecMapIt@{NonSpecMapIt}!InstQueue@{InstQueue}}
\subsubsection[{NonSpecMapIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef std::map$<${\bf InstSeqNum}, {\bf DynInstPtr}$>$::iterator {\bf NonSpecMapIt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a0e9597437fae9e60d5449933949416ec}
\hypertarget{classInstQueue_a818e103eae798a24a06a0a34631849ea}{
\index{InstQueue@{InstQueue}!Params@{Params}}
\index{Params@{Params}!InstQueue@{InstQueue}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::Params {\bf Params}}}
\label{classInstQueue_a818e103eae798a24a06a0a34631849ea}
\hypertarget{classInstQueue_afca3a0ab9af7309428eb77c726724000}{
\index{InstQueue@{InstQueue}!ReadyInstMap@{ReadyInstMap}}
\index{ReadyInstMap@{ReadyInstMap}!InstQueue@{InstQueue}}
\subsubsection[{ReadyInstMap}]{\setlength{\rightskip}{0pt plus 5cm}typedef std::map$<${\bf DynInstPtr}, {\bf pqCompare}$>$ {\bf ReadyInstMap}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_afca3a0ab9af7309428eb77c726724000}
\hypertarget{classInstQueue_a60636ae8f3b649078c4f1bdd3b20dcad}{
\index{InstQueue@{InstQueue}!ReadyInstQueue@{ReadyInstQueue}}
\index{ReadyInstQueue@{ReadyInstQueue}!InstQueue@{InstQueue}}
\subsubsection[{ReadyInstQueue}]{\setlength{\rightskip}{0pt plus 5cm}typedef std::priority\_\-queue$<${\bf DynInstPtr}, {\bf std::vector}$<${\bf DynInstPtr}$>$, {\bf pqCompare}$>$ {\bf ReadyInstQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a60636ae8f3b649078c4f1bdd3b20dcad}
\hypertarget{classInstQueue_a2ab2a44e2b7c4b408ceda3a9a2422ecb}{
\index{InstQueue@{InstQueue}!ReadyMapIt@{ReadyMapIt}}
\index{ReadyMapIt@{ReadyMapIt}!InstQueue@{InstQueue}}
\subsubsection[{ReadyMapIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef std::map$<${\bf DynInstPtr}, {\bf pqCompare}$>$::iterator {\bf ReadyMapIt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a2ab2a44e2b7c4b408ceda3a9a2422ecb}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classInstQueue_a679ee5512f178ea331ab7cd3ebf2aa78}{
\index{InstQueue@{InstQueue}!InstQueue@{InstQueue}}
\index{InstQueue@{InstQueue}!InstQueue@{InstQueue}}
\subsubsection[{InstQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstQueue} ({\bf Params} $\ast$ {\em params})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_a679ee5512f178ea331ab7cd3ebf2aa78}
Constructs an IQ. 


\begin{DoxyCode}
74     : dcacheInterface(params->dcacheInterface),
75 //      fuPool(params->fuPool),
76       numEntries(params->numIQEntries),
77       totalWidth(params->issueWidth),
78 //      numPhysIntRegs(params->numPhysIntRegs),
79 //      numPhysFloatRegs(params->numPhysFloatRegs),
80       commitToIEWDelay(params->commitToIEWDelay)
81 {
82 //    assert(fuPool);
83 
84 //    numThreads = params->numberOfThreads;
85     numThreads = 1;
86 
87     //Initialize thread IQ counts
88     for (ThreadID tid = 0; tid <numThreads; tid++) {
89         count[tid] = 0;
90     }
91 
92     // Initialize the number of free IQ entries.
93     freeEntries = numEntries;
94 
95     // Set the number of physical registers as the number of int + float
96 //    numPhysRegs = numPhysIntRegs + numPhysFloatRegs;
97 
98 //    DPRINTF(IQ, "There are %i physical registers.\n", numPhysRegs);
99 
100     //Create an entry for each physical register within the
101     //dependency graph.
102 //    dependGraph = new DependencyEntry[numPhysRegs];
103 
104     // Resize the register scoreboard.
105 //    regScoreboard.resize(numPhysRegs);
106 /*
107     //Initialize Mem Dependence Units
108     for (ThreadID tid = 0; tid < numThreads; tid++) {
109         memDepUnit[tid].init(params, tid);
110         memDepUnit[tid].setIQ(this);
111     }
112 
113     // Initialize all the head pointers to point to NULL, and all the
114     // entries as unready.
115     // Note that in actuality, the registers corresponding to the logical
116     // registers start off as ready.  However this doesn't matter for the
117     // IQ as the instruction should have been correctly told if those
118     // registers are ready in rename.  Thus it can all be initialized as
119     // unready.
120     for (int i = 0; i < numPhysRegs; ++i) {
121         dependGraph[i].next = NULL;
122         dependGraph[i].inst = NULL;
123         regScoreboard[i] = false;
124     }
125 */
126     for (ThreadID tid = 0; tid < numThreads; ++tid) {
127         squashedSeqNum[tid] = 0;
128     }
129 /*
130     for (int i = 0; i < Num_OpClasses; ++i) {
131         queueOnList[i] = false;
132         readyIt[i] = listOrder.end();
133     }
134 
135     string policy = params->smtIQPolicy;
136 
137     //Convert string to lowercase
138     std::transform(policy.begin(), policy.end(), policy.begin(),
139                    (int(*)(int)) tolower);
140 
141     //Figure out resource sharing policy
142     if (policy == "dynamic") {
143         iqPolicy = Dynamic;
144 
145         //Set Max Entries to Total ROB Capacity
146         for (ThreadID tid = 0; tid < numThreads; tid++) {
147             maxEntries[tid] = numEntries;
148         }
149 
150     } else if (policy == "partitioned") {
151         iqPolicy = Partitioned;
152 
153         //@todo:make work if part_amt doesnt divide evenly.
154         int part_amt = numEntries / numThreads;
155 
156         //Divide ROB up evenly
157         for (ThreadID tid = 0; tid < numThreads; tid++) {
158             maxEntries[tid] = part_amt;
159         }
160 
161         DPRINTF(Fetch, "IQ sharing policy set to Partitioned:"
162                 "%i entries per thread.\n",part_amt);
163 
164     } else if (policy == "threshold") {
165         iqPolicy = Threshold;
166 
167         double threshold =  (double)params->smtIQThreshold / 100;
168 
169         int thresholdIQ = (int)((double)threshold * numEntries);
170 
171         //Divide up by threshold amount
172         for (ThreadID tid = 0; tid < numThreads; tid++) {
173             maxEntries[tid] = thresholdIQ;
174         }
175 
176         DPRINTF(Fetch, "IQ sharing policy set to Threshold:"
177                 "%i entries per thread.\n",thresholdIQ);
178    } else {
179        assert(0 && "Invalid IQ Sharing Policy.Options Are:{Dynamic,"
180               "Partitioned, Threshold}");
181    }
182 */
183 }
\end{DoxyCode}
\hypertarget{classInstQueue_aac3885a1c3df6261e14208fc83713c17}{
\index{InstQueue@{InstQueue}!$\sim$InstQueue@{$\sim$InstQueue}}
\index{$\sim$InstQueue@{$\sim$InstQueue}!InstQueue@{InstQueue}}
\subsubsection[{$\sim$InstQueue}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf InstQueue} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_aac3885a1c3df6261e14208fc83713c17}
Destructs the IQ. 


\begin{DoxyCode}
187 {
188     // Clear the dependency graph
189 /*
190     DependencyEntry *curr;
191     DependencyEntry *prev;
192 
193     for (int i = 0; i < numPhysRegs; ++i) {
194         curr = dependGraph[i].next;
195 
196         while (curr) {
197             DependencyEntry::mem_alloc_counter--;
198 
199             prev = curr;
200             curr = prev->next;
201             prev->inst = NULL;
202 
203             delete prev;
204         }
205 
206         if (dependGraph[i].inst) {
207             dependGraph[i].inst = NULL;
208         }
209 
210         dependGraph[i].next = NULL;
211     }
212 
213     assert(DependencyEntry::mem_alloc_counter == 0);
214 
215     delete [] dependGraph;
216 */
217 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classInstQueue_a7e3f1fa43ca939ed6fd9b3abcc47f06e}{
\index{InstQueue@{InstQueue}!addIfReady@{addIfReady}}
\index{addIfReady@{addIfReady}!InstQueue@{InstQueue}}
\subsubsection[{addIfReady}]{\setlength{\rightskip}{0pt plus 5cm}void addIfReady ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classInstQueue_a7e3f1fa43ca939ed6fd9b3abcc47f06e}
Moves an instruction to the ready queue if it is ready. 


\begin{DoxyCode}
1166 {
1167     //If the instruction now has all of its source registers
1168     // available, then add it to the list of ready instructions.
1169     if (inst->readyToIssue()) {
1170 
1171         //Add the instruction to the proper ready list.
1172         if (inst->isMemRef()) {
1173 
1174             DPRINTF(IQ, "Checking if memory instruction can issue.\n");
1175 
1176             // Message to the mem dependence unit that this instruction has
1177             // its registers ready.
1178 
1179 //            memDepUnit[inst->threadNumber].regsReady(inst);
1180 
1181             return;
1182         }
1183 
1184 //        OpClass op_class = inst->opClass();
1185 
1186         DPRINTF(IQ, "Instruction is ready to issue, putting it onto "
1187                 "the ready list, PC %#x opclass:%i [sn:%lli].\n",
1188                 inst->readPC(), inst->opClass(), inst->seqNum);
1189 
1190         readyInsts.push(inst);
1191     }
1192 }
\end{DoxyCode}
\hypertarget{classInstQueue_a76bcc078140b3e79923f7b5be8b302fb}{
\index{InstQueue@{InstQueue}!addReadyMemInst@{addReadyMemInst}}
\index{addReadyMemInst@{addReadyMemInst}!InstQueue@{InstQueue}}
\subsubsection[{addReadyMemInst}]{\setlength{\rightskip}{0pt plus 5cm}void addReadyMemInst ({\bf DynInstPtr} \& {\em ready\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_a76bcc078140b3e79923f7b5be8b302fb}
Adds a ready memory instruction to the ready list. 


\begin{DoxyCode}
856 {
857 //    OpClass op_class = ready_inst->opClass();
858 
859     readyInsts.push(ready_inst);
860 
861     DPRINTF(IQ, "Instruction is ready to issue, putting it onto "
862             "the ready list, PC %#x opclass:%i [sn:%lli].\n",
863             ready_inst->readPC(), ready_inst->opClass(), ready_inst->seqNum);
864 }
\end{DoxyCode}
\hypertarget{classInstQueue_a04f8d2acf3cd0b90a1efc69b528f91bc}{
\index{InstQueue@{InstQueue}!commit@{commit}}
\index{commit@{commit}!InstQueue@{InstQueue}}
\subsubsection[{commit}]{\setlength{\rightskip}{0pt plus 5cm}void commit (const {\bf InstSeqNum} \& {\em inst}, \/  {\bf ThreadID} {\em tid} = {\ttfamily 0})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_a04f8d2acf3cd0b90a1efc69b528f91bc}
Commits all instructions up to and including the given sequence number, for a specific thread. 


\begin{DoxyCode}
758 {
759     /*Need to go through each thread??*/
760     DPRINTF(IQ, "[tid:%i]: Committing instructions older than [sn:%i]\n",
761             tid,inst);
762 
763     ListIt iq_it = instList[tid].begin();
764 
765     while (iq_it != instList[tid].end() &&
766            (*iq_it)->seqNum <= inst) {
767         ++iq_it;
768         instList[tid].pop_front();
769     }
770 
771     assert(freeEntries == (numEntries - countInsts()));
772 }
\end{DoxyCode}
\hypertarget{classInstQueue_aad2715729f71f220e9cf9b99515384ca}{
\index{InstQueue@{InstQueue}!completeMemInst@{completeMemInst}}
\index{completeMemInst@{completeMemInst}!InstQueue@{InstQueue}}
\subsubsection[{completeMemInst}]{\setlength{\rightskip}{0pt plus 5cm}void completeMemInst ({\bf DynInstPtr} \& {\em completed\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_aad2715729f71f220e9cf9b99515384ca}
Completes a memory operation. 


\begin{DoxyCode}
883 {
884     ThreadID tid = completed_inst->threadNumber;
885 
886     DPRINTF(IQ, "Completing mem instruction PC:%#x [sn:%lli]\n",
887             completed_inst->readPC(), completed_inst->seqNum);
888 
889     ++freeEntries;
890 
891 //    completed_inst->memOpDone = true;
892 
893 //    memDepUnit[tid].completed(completed_inst);
894 
895     count[tid]--;
896 }
\end{DoxyCode}
\hypertarget{classInstQueue_ab654970f03abd90f0c397bba8e218bc9}{
\index{InstQueue@{InstQueue}!countInsts@{countInsts}}
\index{countInsts@{countInsts}!InstQueue@{InstQueue}}
\subsubsection[{countInsts}]{\setlength{\rightskip}{0pt plus 5cm}int countInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classInstQueue_ab654970f03abd90f0c397bba8e218bc9}
Debugging function to count how many entries are in the IQ. It does a linear walk through the instructions, so do not call this function during normal execution. 


\begin{DoxyCode}
1197 {
1198     //ksewell:This works but definitely could use a cleaner write
1199     //with a more intuitive way of counting. Right now it's
1200     //just brute force ....
1201 
1202 #if 0
1203     int total_insts = 0;
1204 
1205     for (ThreadID tid = 0; tid < numThreads; ++tid) {
1206         ListIt count_it = instList[tid].begin();
1207 
1208         while (count_it != instList[tid].end()) {
1209             if (!(*count_it)->isSquashed() && !(*count_it)->isSquashedInIQ()) {
1210                 if (!(*count_it)->isIssued()) {
1211                     ++total_insts;
1212                 } else if ((*count_it)->isMemRef() &&
1213                            !(*count_it)->memOpDone) {
1214                     // Loads that have not been marked as executed still count
1215                     // towards the total instructions.
1216                     ++total_insts;
1217                 }
1218             }
1219 
1220             ++count_it;
1221         }
1222     }
1223 
1224     return total_insts;
1225 #else
1226     return numEntries - freeEntries;
1227 #endif
1228 }
\end{DoxyCode}
\hypertarget{classInstQueue_a06cf52c4f09162bea03ec848f247151a}{
\index{InstQueue@{InstQueue}!doSquash@{doSquash}}
\index{doSquash@{doSquash}!InstQueue@{InstQueue}}
\subsubsection[{doSquash}]{\setlength{\rightskip}{0pt plus 5cm}void doSquash ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classInstQueue_a06cf52c4f09162bea03ec848f247151a}
Does the actual squashing. 


\begin{DoxyCode}
933 {
934     // Make sure the squashed sequence number is valid.
935     assert(squashedSeqNum[tid] != 0);
936 
937     DPRINTF(IQ, "[tid:%i]: Squashing until sequence number %i!\n",
938             tid, squashedSeqNum[tid]);
939 
940     // Squash any instructions younger than the squashed sequence number
941     // given.
942     while (squashIt[tid] != instList[tid].end() &&
943            (*squashIt[tid])->seqNum > squashedSeqNum[tid]) {
944 
945         DynInstPtr squashed_inst = (*squashIt[tid]);
946 
947         // Only handle the instruction if it actually is in the IQ and
948         // hasn't already been squashed in the IQ.
949         if (squashed_inst->threadNumber != tid ||
950             squashed_inst->isSquashedInIQ()) {
951             --squashIt[tid];
952             continue;
953         }
954 
955         if (!squashed_inst->isIssued() ||
956             (squashed_inst->isMemRef()/* &&
957                                          !squashed_inst->memOpDone*/)) {
958 
959             // Remove the instruction from the dependency list.
960             if (!squashed_inst->isNonSpeculative()) {
961 /*
962                 for (int src_reg_idx = 0;
963                      src_reg_idx < squashed_inst->numSrcRegs();
964                      src_reg_idx++)
965                 {
966                     PhysRegIndex src_reg =
967                         squashed_inst->renamedSrcRegIdx(src_reg_idx);
968 
969                     // Only remove it from the dependency graph if it was
970                     // placed there in the first place.
971                     // HACK: This assumes that instructions woken up from the
972                     // dependency chain aren't informed that a specific src
973                     // register has become ready.  This may not always be true
974                     // in the future.
975                     // Instead of doing a linked list traversal, we can just
976                     // remove these squashed instructions either at issue time,
977                     // or when the register is overwritten.  The only downside
978                     // to this is it leaves more room for error.
979 
980                     if (!squashed_inst->isReadySrcRegIdx(src_reg_idx) &&
981                         src_reg < numPhysRegs) {
982                         dependGraph[src_reg].remove(squashed_inst);
983                     }
984 
985 
986                     ++iqSquashedOperandsExamined;
987                 }
988 */
989                 // Might want to remove producers as well.
990             } else {
991                 nonSpecInsts[squashed_inst->seqNum] = NULL;
992 
993                 nonSpecInsts.erase(squashed_inst->seqNum);
994 
995                 ++iqSquashedNonSpecRemoved;
996             }
997 
998             // Might want to also clear out the head of the dependency graph.
999 
1000             // Mark it as squashed within the IQ.
1001             squashed_inst->setSquashedInIQ();
1002 
1003             // @todo: Remove this hack where several statuses are set so the
1004             // inst will flow through the rest of the pipeline.
1005             squashed_inst->setIssued();
1006             squashed_inst->setCanCommit();
1007 //            squashed_inst->removeInIQ();
1008 
1009             //Update Thread IQ Count
1010             count[squashed_inst->threadNumber]--;
1011 
1012             ++freeEntries;
1013 
1014             if (numThreads > 1) {
1015                 DPRINTF(IQ, "[tid:%i]: Instruction PC %#x squashed.\n",
1016                         tid, squashed_inst->readPC());
1017             } else {
1018                 DPRINTF(IQ, "Instruction PC %#x squashed.\n",
1019                         squashed_inst->readPC());
1020             }
1021         }
1022 
1023         --squashIt[tid];
1024         ++iqSquashedInstsExamined;
1025     }
1026 }
\end{DoxyCode}
\hypertarget{classInstQueue_a80587b4fe043bbe1995536cb3b361588}{
\index{InstQueue@{InstQueue}!dumpInsts@{dumpInsts}}
\index{dumpInsts@{dumpInsts}!InstQueue@{InstQueue}}
\subsubsection[{dumpInsts}]{\setlength{\rightskip}{0pt plus 5cm}void dumpInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classInstQueue_a80587b4fe043bbe1995536cb3b361588}
Debugging function to dump out all instructions that are in the IQ. 


\begin{DoxyCode}
1304 {
1305     for (ThreadID tid = 0; tid < numThreads; ++tid) {
1306 //        int num = 0;
1307 //        int valid_num = 0;
1308 /*
1309       ListIt inst_list_it = instList[tid].begin();
1310 
1311         while (inst_list_it != instList[tid].end())
1312         {
1313             cprintf("Instruction:%i\n",
1314                     num);
1315             if (!(*inst_list_it)->isSquashed()) {
1316                 if (!(*inst_list_it)->isIssued()) {
1317                     ++valid_num;
1318                     cprintf("Count:%i\n", valid_num);
1319                 } else if ((*inst_list_it)->isMemRef() &&
1320                            !(*inst_list_it)->memOpDone) {
1321                     // Loads that have not been marked as executed still count
1322                     // towards the total instructions.
1323                     ++valid_num;
1324                     cprintf("Count:%i\n", valid_num);
1325                 }
1326             }
1327 
1328             cprintf("PC:%#x\n[sn:%lli]\n[tid:%i]\n"
1329                     "Issued:%i\nSquashed:%i\n",
1330                     (*inst_list_it)->readPC(),
1331                     (*inst_list_it)->seqNum,
1332                     (*inst_list_it)->threadNumber,
1333                     (*inst_list_it)->isIssued(),
1334                     (*inst_list_it)->isSquashed());
1335 
1336             if ((*inst_list_it)->isMemRef()) {
1337                 cprintf("MemOpDone:%i\n", (*inst_list_it)->memOpDone);
1338             }
1339 
1340             cprintf("\n");
1341 
1342             inst_list_it++;
1343             ++num;
1344         }
1345 */
1346     }
1347 }
\end{DoxyCode}
\hypertarget{classInstQueue_a3d1dae45e8e0b5cf7c1f4f8c796d070e}{
\index{InstQueue@{InstQueue}!dumpLists@{dumpLists}}
\index{dumpLists@{dumpLists}!InstQueue@{InstQueue}}
\subsubsection[{dumpLists}]{\setlength{\rightskip}{0pt plus 5cm}void dumpLists ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classInstQueue_a3d1dae45e8e0b5cf7c1f4f8c796d070e}
Debugging function to dump all the list sizes, as well as print out the list of nonspeculative instructions. Should not be used in any other capacity, but it has no harmful sideaffects. 


\begin{DoxyCode}
1261 {
1262     for (int i = 0; i < Num_OpClasses; ++i) {
1263         cprintf("Ready list %i size: %i\n", i, readyInsts.size());
1264 
1265         cprintf("\n");
1266     }
1267 
1268     cprintf("Non speculative list size: %i\n", nonSpecInsts.size());
1269 
1270     NonSpecMapIt non_spec_it = nonSpecInsts.begin();
1271     NonSpecMapIt non_spec_end_it = nonSpecInsts.end();
1272 
1273     cprintf("Non speculative list: ");
1274 
1275     while (non_spec_it != non_spec_end_it) {
1276         cprintf("%#x [sn:%lli]", (*non_spec_it).second->readPC(),
1277                 (*non_spec_it).second->seqNum);
1278         ++non_spec_it;
1279     }
1280 
1281     cprintf("\n");
1282 /*
1283     ListOrderIt list_order_it = listOrder.begin();
1284     ListOrderIt list_order_end_it = listOrder.end();
1285     int i = 1;
1286 
1287     cprintf("List order: ");
1288 
1289     while (list_order_it != list_order_end_it) {
1290         cprintf("%i OpClass:%i [sn:%lli] ", i, (*list_order_it).queueType,
1291                 (*list_order_it).oldestInst);
1292 
1293         ++list_order_it;
1294         ++i;
1295     }
1296 */
1297     cprintf("\n");
1298 }
\end{DoxyCode}
\hypertarget{classInstQueue_aaf7eb96b7ab2a8240d043b7d82494d15}{
\index{InstQueue@{InstQueue}!getCount@{getCount}}
\index{getCount@{getCount}!InstQueue@{InstQueue}}
\subsubsection[{getCount}]{\setlength{\rightskip}{0pt plus 5cm}unsigned getCount ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_aaf7eb96b7ab2a8240d043b7d82494d15}
Returns the number of used entries for a thread. 


\begin{DoxyCode}
212 { return count[tid]; };
\end{DoxyCode}
\hypertarget{classInstQueue_ae59aad9cee1e45b5817a9d96553e4567}{
\index{InstQueue@{InstQueue}!hasReadyInsts@{hasReadyInsts}}
\index{hasReadyInsts@{hasReadyInsts}!InstQueue@{InstQueue}}
\subsubsection[{hasReadyInsts}]{\setlength{\rightskip}{0pt plus 5cm}bool hasReadyInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_ae59aad9cee1e45b5817a9d96553e4567}
Returns if there are any ready instructions in the IQ. 


\begin{DoxyCode}
405 {
406 /*
407     if (!listOrder.empty()) {
408         return true;
409     }
410 
411     for (int i = 0; i < Num_OpClasses; ++i) {
412         if (!readyInsts[i].empty()) {
413             return true;
414         }
415     }
416 
417     return false;
418 */
419     return readyInsts.empty();
420 }
\end{DoxyCode}
\hypertarget{classInstQueue_a786595aecf8ab7aae40868b5ac4a79a7}{
\index{InstQueue@{InstQueue}!insert@{insert}}
\index{insert@{insert}!InstQueue@{InstQueue}}
\subsubsection[{insert}]{\setlength{\rightskip}{0pt plus 5cm}void insert ({\bf DynInstPtr} \& {\em new\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_a786595aecf8ab7aae40868b5ac4a79a7}
Inserts a new instruction into the IQ. 


\begin{DoxyCode}
425 {
426     // Make sure the instruction is valid
427     assert(new_inst);
428 
429     DPRINTF(IQ, "Adding instruction PC %#x to the IQ.\n",
430             new_inst->readPC());
431 
432     // Check if there are any free entries.  Panic if there are none.
433     // Might want to have this return a fault in the future instead of
434     // panicing.
435     assert(freeEntries != 0);
436 
437     instList[new_inst->threadNumber].push_back(new_inst);
438 
439     // Decrease the number of free entries.
440     --freeEntries;
441 
442     //Mark Instruction as in IQ
443 //    new_inst->setInIQ();
444 /*
445     // Look through its source registers (physical regs), and mark any
446     // dependencies.
447     addToDependents(new_inst);
448 
449     // Have this instruction set itself as the producer of its destination
450     // register(s).
451     createDependency(new_inst);
452 */
453     // If it's a memory instruction, add it to the memory dependency
454     // unit.
455 //    if (new_inst->isMemRef()) {
456 //        memDepUnit[new_inst->threadNumber].insert(new_inst);
457 //    } else {
458         // If the instruction is ready then add it to the ready list.
459         addIfReady(new_inst);
460 //    }
461 
462     ++iqInstsAdded;
463 
464 
465     //Update Thread IQ Count
466     count[new_inst->threadNumber]++;
467 
468     assert(freeEntries == (numEntries - countInsts()));
469 }
\end{DoxyCode}
\hypertarget{classInstQueue_a4f7523e76440d88096a4eac14f2e0dd3}{
\index{InstQueue@{InstQueue}!insertNonSpec@{insertNonSpec}}
\index{insertNonSpec@{insertNonSpec}!InstQueue@{InstQueue}}
\subsubsection[{insertNonSpec}]{\setlength{\rightskip}{0pt plus 5cm}void insertNonSpec ({\bf DynInstPtr} \& {\em new\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_a4f7523e76440d88096a4eac14f2e0dd3}
Inserts a new, non-\/speculative instruction into the IQ. 


\begin{DoxyCode}
474 {
475     nonSpecInsts[new_inst->seqNum] = new_inst;
476 
477     // @todo: Clean up this code; can do it by setting inst as unable
478     // to issue, then calling normal insert on the inst.
479 
480     // Make sure the instruction is valid
481     assert(new_inst);
482 
483     DPRINTF(IQ, "Adding instruction PC %#x to the IQ.\n",
484             new_inst->readPC());
485 
486     // Check if there are any free entries.  Panic if there are none.
487     // Might want to have this return a fault in the future instead of
488     // panicing.
489     assert(freeEntries != 0);
490 
491     instList[new_inst->threadNumber].push_back(new_inst);
492 
493     // Decrease the number of free entries.
494     --freeEntries;
495 
496     //Mark Instruction as in IQ
497 //    new_inst->setInIQ();
498 /*
499     // Have this instruction set itself as the producer of its destination
500     // register(s).
501     createDependency(new_inst);
502 
503     // If it's a memory instruction, add it to the memory dependency
504     // unit.
505     if (new_inst->isMemRef()) {
506         memDepUnit[new_inst->threadNumber].insertNonSpec(new_inst);
507     }
508 */
509     ++iqNonSpecInstsAdded;
510 
511     //Update Thread IQ Count
512     count[new_inst->threadNumber]++;
513 
514     assert(freeEntries == (numEntries - countInsts()));
515 }
\end{DoxyCode}
\hypertarget{classInstQueue_a30fac732df9b3fda011c7329a112cb31}{
\index{InstQueue@{InstQueue}!isFull@{isFull}}
\index{isFull@{isFull}!InstQueue@{InstQueue}}
\subsubsection[{isFull}]{\setlength{\rightskip}{0pt plus 5cm}bool isFull ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_a30fac732df9b3fda011c7329a112cb31}
Returns whether or not the IQ is full for a specific thread. 


\begin{DoxyCode}
394 {
395     if (numFreeEntries(tid) == 0) {
396         return(true);
397     } else {
398         return(false);
399     }
400 }
\end{DoxyCode}
\hypertarget{classInstQueue_a3e70330939fdfc4dbc2f60c1a660584d}{
\index{InstQueue@{InstQueue}!isFull@{isFull}}
\index{isFull@{isFull}!InstQueue@{InstQueue}}
\subsubsection[{isFull}]{\setlength{\rightskip}{0pt plus 5cm}bool isFull ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_a3e70330939fdfc4dbc2f60c1a660584d}
Returns whether or not the IQ is full. 


\begin{DoxyCode}
383 {
384     if (freeEntries == 0) {
385         return(true);
386     } else {
387         return(false);
388     }
389 }
\end{DoxyCode}
\hypertarget{classInstQueue_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{InstQueue@{InstQueue}!name@{name}}
\index{name@{name}!InstQueue@{InstQueue}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_a37627d5d5bba7f4a8690c71c2ab3cb07}
Returns the name of the IQ. 


\begin{DoxyCode}
222 {
223     return cpu->name() + ".iq";
224 }
\end{DoxyCode}
\hypertarget{classInstQueue_acc878f608deead5b5319a6a3f98b50c8}{
\index{InstQueue@{InstQueue}!numFreeEntries@{numFreeEntries}}
\index{numFreeEntries@{numFreeEntries}!InstQueue@{InstQueue}}
\subsubsection[{numFreeEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned numFreeEntries ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_acc878f608deead5b5319a6a3f98b50c8}
Returns number of free entries for a thread. 


\begin{DoxyCode}
374 {
375     return maxEntries[tid] - count[tid];
376 }
\end{DoxyCode}
\hypertarget{classInstQueue_a028971a565aca048c67ea1c36a6a9d51}{
\index{InstQueue@{InstQueue}!numFreeEntries@{numFreeEntries}}
\index{numFreeEntries@{numFreeEntries}!InstQueue@{InstQueue}}
\subsubsection[{numFreeEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned numFreeEntries ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_a028971a565aca048c67ea1c36a6a9d51}
Returns total number of free entries. 


\begin{DoxyCode}
367 {
368     return freeEntries;
369 }
\end{DoxyCode}
\hypertarget{classInstQueue_afc9c0c90c27fe0dc8bd4da915596bc21}{
\index{InstQueue@{InstQueue}!printInsts@{printInsts}}
\index{printInsts@{printInsts}!InstQueue@{InstQueue}}
\subsubsection[{printInsts}]{\setlength{\rightskip}{0pt plus 5cm}void printInsts ()}}
\label{classInstQueue_afc9c0c90c27fe0dc8bd4da915596bc21}
\hyperlink{namespaceDebug}{Debug} function to print all instructions. \hypertarget{classInstQueue_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{InstQueue@{InstQueue}!regStats@{regStats}}
\index{regStats@{regStats}!InstQueue@{InstQueue}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_a4dc637449366fcdfc4e764cdf12d9b11}
Registers statistics. 


\begin{DoxyCode}
229 {
230     iqInstsAdded
231         .name(name() + ".iqInstsAdded")
232         .desc("Number of instructions added to the IQ (excludes non-spec)")
233         .prereq(iqInstsAdded);
234 
235     iqNonSpecInstsAdded
236         .name(name() + ".iqNonSpecInstsAdded")
237         .desc("Number of non-speculative instructions added to the IQ")
238         .prereq(iqNonSpecInstsAdded);
239 
240 //    iqIntInstsAdded;
241 
242     iqIntInstsIssued
243         .name(name() + ".iqIntInstsIssued")
244         .desc("Number of integer instructions issued")
245         .prereq(iqIntInstsIssued);
246 
247 //    iqFloatInstsAdded;
248 
249     iqFloatInstsIssued
250         .name(name() + ".iqFloatInstsIssued")
251         .desc("Number of float instructions issued")
252         .prereq(iqFloatInstsIssued);
253 
254 //    iqBranchInstsAdded;
255 
256     iqBranchInstsIssued
257         .name(name() + ".iqBranchInstsIssued")
258         .desc("Number of branch instructions issued")
259         .prereq(iqBranchInstsIssued);
260 
261 //    iqMemInstsAdded;
262 
263     iqMemInstsIssued
264         .name(name() + ".iqMemInstsIssued")
265         .desc("Number of memory instructions issued")
266         .prereq(iqMemInstsIssued);
267 
268 //    iqMiscInstsAdded;
269 
270     iqMiscInstsIssued
271         .name(name() + ".iqMiscInstsIssued")
272         .desc("Number of miscellaneous instructions issued")
273         .prereq(iqMiscInstsIssued);
274 
275     iqSquashedInstsIssued
276         .name(name() + ".iqSquashedInstsIssued")
277         .desc("Number of squashed instructions issued")
278         .prereq(iqSquashedInstsIssued);
279 
280     iqSquashedInstsExamined
281         .name(name() + ".iqSquashedInstsExamined")
282         .desc("Number of squashed instructions iterated over during squash;"
283               " mainly for profiling")
284         .prereq(iqSquashedInstsExamined);
285 
286     iqSquashedOperandsExamined
287         .name(name() + ".iqSquashedOperandsExamined")
288         .desc("Number of squashed operands that are examined and possibly "
289               "removed from graph")
290         .prereq(iqSquashedOperandsExamined);
291 
292     iqSquashedNonSpecRemoved
293         .name(name() + ".iqSquashedNonSpecRemoved")
294         .desc("Number of squashed non-spec instructions that were removed")
295         .prereq(iqSquashedNonSpecRemoved);
296 /*
297     for (ThreadID tid = 0; tid < numThreads; tid++) {
298         // Tell mem dependence unit to reg stats as well.
299         memDepUnit[tid].regStats();
300     }
301 */
302 }
\end{DoxyCode}
\hypertarget{classInstQueue_a15ca5aaeab5bd4c2169ed41bbc7fb79c}{
\index{InstQueue@{InstQueue}!scheduleNonSpec@{scheduleNonSpec}}
\index{scheduleNonSpec@{scheduleNonSpec}!InstQueue@{InstQueue}}
\subsubsection[{scheduleNonSpec}]{\setlength{\rightskip}{0pt plus 5cm}void scheduleNonSpec (const {\bf InstSeqNum} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_a15ca5aaeab5bd4c2169ed41bbc7fb79c}
Schedules a single specific non-\/speculative instruction. 


\begin{DoxyCode}
732 {
733     DPRINTF(IQ, "Marking nonspeculative instruction with sequence "
734             "number %i as ready to execute.\n", inst);
735 
736     NonSpecMapIt inst_it = nonSpecInsts.find(inst);
737 
738     assert(inst_it != nonSpecInsts.end());
739 
740 //    ThreadID tid = (*inst_it).second->threadNumber;
741 
742     // Mark this instruction as ready to issue.
743     (*inst_it).second->setCanIssue();
744 
745     // Now schedule the instruction.
746 //    if (!(*inst_it).second->isMemRef()) {
747         addIfReady((*inst_it).second);
748 //    } else {
749 //        memDepUnit[tid].nonSpecInstReady((*inst_it).second);
750 //    }
751 
752     nonSpecInsts.erase(inst_it);
753 }
\end{DoxyCode}
\hypertarget{classInstQueue_a3694e72427d3a616808797f9343d1fc4}{
\index{InstQueue@{InstQueue}!scheduleReadyInsts@{scheduleReadyInsts}}
\index{scheduleReadyInsts@{scheduleReadyInsts}!InstQueue@{InstQueue}}
\subsubsection[{scheduleReadyInsts}]{\setlength{\rightskip}{0pt plus 5cm}void scheduleReadyInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_a3694e72427d3a616808797f9343d1fc4}
Schedules ready instructions, adding the ready ones (oldest first) to the queue to execute. 


\begin{DoxyCode}
600 {
601     DPRINTF(IQ, "Attempting to schedule ready instructions from "
602             "the IQ.\n");
603 
604 //    IssueStruct *i2e_info = issueToExecuteQueue->access(0);
605 /*
606     // Will need to reorder the list if either a queue is not on the list,
607     // or it has an older instruction than last time.
608     for (int i = 0; i < Num_OpClasses; ++i) {
609         if (!readyInsts[i].empty()) {
610             if (!queueOnList[i]) {
611                 addToOrderList(OpClass(i));
612             } else if (readyInsts[i].top()->seqNum  <
613                        (*readyIt[i]).oldestInst) {
614                 listOrder.erase(readyIt[i]);
615                 addToOrderList(OpClass(i));
616             }
617         }
618     }
619 
620     // Have iterator to head of the list
621     // While I haven't exceeded bandwidth or reached the end of the list,
622     // Try to get a FU that can do what this op needs.
623     // If successful, change the oldestInst to the new top of the list, put
624     // the queue in the proper place in the list.
625     // Increment the iterator.
626     // This will avoid trying to schedule a certain op class if there are no
627     // FUs that handle it.
628     ListOrderIt order_it = listOrder.begin();
629     ListOrderIt order_end_it = listOrder.end();
630     int total_issued = 0;
631     int exec_queue_slot = i2e_info->size;
632 
633     while (exec_queue_slot < totalWidth && order_it != order_end_it) {
634         OpClass op_class = (*order_it).queueType;
635 
636         assert(!readyInsts[op_class].empty());
637 
638         DynInstPtr issuing_inst = readyInsts[op_class].top();
639 
640         assert(issuing_inst->seqNum == (*order_it).oldestInst);
641 
642         if (issuing_inst->isSquashed()) {
643             readyInsts[op_class].pop();
644 
645             if (!readyInsts[op_class].empty()) {
646                 moveToYoungerInst(order_it);
647             } else {
648                 readyIt[op_class] = listOrder.end();
649                 queueOnList[op_class] = false;
650             }
651 
652             listOrder.erase(order_it++);
653 
654             ++iqSquashedInstsIssued;
655 
656             continue;
657         }
658 
659         int idx = fuPool->getUnit(op_class);
660 
661         if (idx != -1) {
662             int op_latency = fuPool->getOpLatency(op_class);
663 
664             if (op_latency == 1) {
665                 i2e_info->insts[exec_queue_slot++] = issuing_inst;
666                 i2e_info->size++;
667 
668                 // Add the FU onto the list of FU's to be freed next cycle.
669                 fuPool->freeUnit(idx);
670             } else {
671                 int issue_latency = fuPool->getIssueLatency(op_class);
672 
673                 if (issue_latency > 1) {
674                     // Generate completion event for the FU
675                     FUCompletion *execution = new FUCompletion(issuing_inst,
676                                                                idx, this);
677 
678                     execution->schedule(curTick() + issue_latency - 1);
679                 } else {
680                     i2e_info->insts[exec_queue_slot++] = issuing_inst;
681                     i2e_info->size++;
682 
683                     // Add the FU onto the list of FU's to be freed next cycle.
684                     fuPool->freeUnit(idx);
685                 }
686             }
687 
688             DPRINTF(IQ, "Thread %i: Issuing instruction PC %#x "
689                     "[sn:%lli]\n",
690                     issuing_inst->threadNumber, issuing_inst->readPC(),
691                     issuing_inst->seqNum);
692 
693             readyInsts[op_class].pop();
694 
695             if (!readyInsts[op_class].empty()) {
696                 moveToYoungerInst(order_it);
697             } else {
698                 readyIt[op_class] = listOrder.end();
699                 queueOnList[op_class] = false;
700             }
701 
702             issuing_inst->setIssued();
703             ++total_issued;
704 
705             if (!issuing_inst->isMemRef()) {
706                 // Memory instructions can not be freed from the IQ until they
707                 // complete.
708                 ++freeEntries;
709                 count[issuing_inst->threadNumber]--;
710                 issuing_inst->removeInIQ();
711             } else {
712                 memDepUnit[issuing_inst->threadNumber].issue(issuing_inst);
713             }
714 
715             listOrder.erase(order_it++);
716         } else {
717             ++order_it;
718         }
719     }
720 
721     if (total_issued) {
722         cpu->activityThisCycle();
723     } else {
724         DPRINTF(IQ, "Not able to schedule any instructions.\n");
725     }
726 */
727 }
\end{DoxyCode}
\hypertarget{classInstQueue_aa783e99c55fd8695cb33c087d14bece0}{
\index{InstQueue@{InstQueue}!setCPU@{setCPU}}
\index{setCPU@{setCPU}!InstQueue@{InstQueue}}
\subsubsection[{setCPU}]{\setlength{\rightskip}{0pt plus 5cm}void setCPU ({\bf FullCPU} $\ast$ {\em \_\-cpu})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_aa783e99c55fd8695cb33c087d14bece0}
Sets CPU pointer. 


\begin{DoxyCode}
118 { cpu = _cpu; }
\end{DoxyCode}
\hypertarget{classInstQueue_a7cbe625b8c47621898e7ca92d70c826b}{
\index{InstQueue@{InstQueue}!setIssueToExecuteQueue@{setIssueToExecuteQueue}}
\index{setIssueToExecuteQueue@{setIssueToExecuteQueue}!InstQueue@{InstQueue}}
\subsubsection[{setIssueToExecuteQueue}]{\setlength{\rightskip}{0pt plus 5cm}void setIssueToExecuteQueue ({\bf TimeBuffer}$<$ {\bf IssueStruct} $>$ $\ast$ {\em i2eQueue})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_a7cbe625b8c47621898e7ca92d70c826b}
Sets the timer buffer between issue and execute. 


\begin{DoxyCode}
315 {
316     DPRINTF(IQ, "Set the issue to execute queue.\n");
317     issueToExecuteQueue = i2e_ptr;
318 }
\end{DoxyCode}
\hypertarget{classInstQueue_ad33d65c18c323d90695d7c2355b49af9}{
\index{InstQueue@{InstQueue}!squash@{squash}}
\index{squash@{squash}!InstQueue@{InstQueue}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_ad33d65c18c323d90695d7c2355b49af9}
Squashes instructions for a thread. Squashing information is obtained from the time buffer. 


\begin{DoxyCode}
909 {
910     DPRINTF(IQ, "[tid:%i]: Starting to squash instructions in "
911             "the IQ.\n", tid);
912 
913     // Read instruction sequence number of last instruction out of the
914     // time buffer.
915 //    squashedSeqNum[tid] = fromCommit->commitInfo[tid].doneSeqNum;
916 
917     // Setup the squash iterator to point to the tail.
918     squashIt[tid] = instList[tid].end();
919     --squashIt[tid];
920 
921     // Call doSquash if there are insts in the IQ
922     if (count[tid] > 0) {
923         doSquash(tid);
924     }
925 
926     // Also tell the memory dependence unit to squash.
927 //    memDepUnit[tid].squash(squashedSeqNum[tid], tid);
928 }
\end{DoxyCode}
\hypertarget{classInstQueue_a358bf0d85e8cd8b606877b341c518b5e}{
\index{InstQueue@{InstQueue}!updateFreeEntries@{updateFreeEntries}}
\index{updateFreeEntries@{updateFreeEntries}!InstQueue@{InstQueue}}
\subsubsection[{updateFreeEntries}]{\setlength{\rightskip}{0pt plus 5cm}void updateFreeEntries (int {\em num})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_a358bf0d85e8cd8b606877b341c518b5e}
Updates the number of free entries. 


\begin{DoxyCode}
215 { freeEntries += num; }
\end{DoxyCode}
\hypertarget{classInstQueue_ab9afe94d332a563b9485d1bb9acd68b4}{
\index{InstQueue@{InstQueue}!wakeDependents@{wakeDependents}}
\index{wakeDependents@{wakeDependents}!InstQueue@{InstQueue}}
\subsubsection[{wakeDependents}]{\setlength{\rightskip}{0pt plus 5cm}void wakeDependents ({\bf DynInstPtr} \& {\em completed\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classInstQueue_ab9afe94d332a563b9485d1bb9acd68b4}
Wakes all dependents of a completed instruction. 


\begin{DoxyCode}
777 {
778     DPRINTF(IQ, "Waking dependents of completed instruction.\n");
779     // Look at the physical destination register of the DynInst
780     // and look it up on the dependency graph.  Then mark as ready
781     // any instructions within the instruction queue.
782 /*
783     DependencyEntry *curr;
784     DependencyEntry *prev;
785 */
786     // Tell the memory dependence unit to wake any dependents on this
787     // instruction if it is a memory instruction.  Also complete the memory
788     // instruction at this point since we know it executed fine.
789     // @todo: Might want to rename "completeMemInst" to
790     // something that indicates that it won't need to be replayed, and call
791     // this earlier.  Might not be a big deal.
792     if (completed_inst->isMemRef()) {
793 //        memDepUnit[completed_inst->threadNumber].wakeDependents(completed_inst)
      ;
794         completeMemInst(completed_inst);
795     }
796     completed_inst->wakeDependents();
797 /*
798     for (int dest_reg_idx = 0;
799          dest_reg_idx < completed_inst->numDestRegs();
800          dest_reg_idx++)
801     {
802         PhysRegIndex dest_reg =
803             completed_inst->renamedDestRegIdx(dest_reg_idx);
804 
805         // Special case of uniq or control registers.  They are not
806         // handled by the IQ and thus have no dependency graph entry.
807         // @todo Figure out a cleaner way to handle this.
808         if (dest_reg >= numPhysRegs) {
809             continue;
810         }
811 
812         DPRINTF(IQ, "Waking any dependents on register %i.\n",
813                 (int) dest_reg);
814 
815         //Maybe abstract this part into a function.
816         //Go through the dependency chain, marking the registers as ready
817         //within the waiting instructions.
818 
819         curr = dependGraph[dest_reg].next;
820 
821         while (curr) {
822             DPRINTF(IQ, "Waking up a dependent instruction, PC%#x.\n",
823                     curr->inst->readPC());
824 
825             // Might want to give more information to the instruction
826             // so that it knows which of its source registers is ready.
827             // However that would mean that the dependency graph entries
828             // would need to hold the src_reg_idx.
829             curr->inst->markSrcRegReady();
830 
831             addIfReady(curr->inst);
832 
833             DependencyEntry::mem_alloc_counter--;
834 
835             prev = curr;
836             curr = prev->next;
837             prev->inst = NULL;
838 
839             delete prev;
840         }
841 
842         // Reset the head node now that all of its dependents have been woken
843         // up.
844         dependGraph[dest_reg].next = NULL;
845         dependGraph[dest_reg].inst = NULL;
846 
847         // Mark the scoreboard as having that register ready.
848         regScoreboard[dest_reg] = true;
849     }
850 */
851 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classInstQueue_a0b1390899d1d55620476dd762bd7ac6c}{
\index{InstQueue@{InstQueue}!Impl::FullCPU@{Impl::FullCPU}}
\index{Impl::FullCPU@{Impl::FullCPU}!InstQueue@{InstQueue}}
\subsubsection[{Impl::FullCPU}]{\setlength{\rightskip}{0pt plus 5cm}friend class Impl::FullCPU\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classInstQueue_a0b1390899d1d55620476dd762bd7ac6c}


\subsection{変数}
\hypertarget{classInstQueue_a92c8d68d5f0e17758f89daa2647196f5}{
\index{InstQueue@{InstQueue}!commitToIEWDelay@{commitToIEWDelay}}
\index{commitToIEWDelay@{commitToIEWDelay}!InstQueue@{InstQueue}}
\subsubsection[{commitToIEWDelay}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf commitToIEWDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a92c8d68d5f0e17758f89daa2647196f5}
Delay between commit stage and the IQ. \begin{Desc}
\item[\hyperlink{todo__todo000043}{TODO}]: Make there be a distinction between the delays within IEW. \end{Desc}
\hypertarget{classInstQueue_ac638062ba1de6609f143c5ee3a601109}{
\index{InstQueue@{InstQueue}!count@{count}}
\index{count@{count}!InstQueue@{InstQueue}}
\subsubsection[{count}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf count}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_ac638062ba1de6609f143c5ee3a601109}
Per Thread IQ count \hypertarget{classInstQueue_a766385c2941cd46525f4d9dff90200a2}{
\index{InstQueue@{InstQueue}!cpu@{cpu}}
\index{cpu@{cpu}!InstQueue@{InstQueue}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FullCPU}$\ast$ {\bf cpu}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a766385c2941cd46525f4d9dff90200a2}
Pointer to the CPU. \hypertarget{classInstQueue_a22dc8294eecb144fbdd951d2e32e9330}{
\index{InstQueue@{InstQueue}!dcacheInterface@{dcacheInterface}}
\index{dcacheInterface@{dcacheInterface}!InstQueue@{InstQueue}}
\subsubsection[{dcacheInterface}]{\setlength{\rightskip}{0pt plus 5cm}MemInterface$\ast$ {\bf dcacheInterface}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a22dc8294eecb144fbdd951d2e32e9330}
\hyperlink{classCache}{Cache} interface. \hypertarget{classInstQueue_ac2281ff630f82397bda33269f4ee8796}{
\index{InstQueue@{InstQueue}!freeEntries@{freeEntries}}
\index{freeEntries@{freeEntries}!InstQueue@{InstQueue}}
\subsubsection[{freeEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf freeEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_ac2281ff630f82397bda33269f4ee8796}
Number of free IQ entries left. \hypertarget{classInstQueue_a7f2828a4f877a4a4d4b85a6788536b82}{
\index{InstQueue@{InstQueue}!instList@{instList}}
\index{instList@{instList}!InstQueue@{InstQueue}}
\subsubsection[{instList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf instList}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a7f2828a4f877a4a4d4b85a6788536b82}
List of all the instructions in the IQ (some of which may be issued). \hypertarget{classInstQueue_a928f22a2c6ce592adc40e5242c9d6572}{
\index{InstQueue@{InstQueue}!iqBranchInstsIssued@{iqBranchInstsIssued}}
\index{iqBranchInstsIssued@{iqBranchInstsIssued}!InstQueue@{InstQueue}}
\subsubsection[{iqBranchInstsIssued}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqBranchInstsIssued}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a928f22a2c6ce592adc40e5242c9d6572}
Stat for number of branch instructions issued. \hypertarget{classInstQueue_aa9f2fa124c9f0b4b22461b6717449d9a}{
\index{InstQueue@{InstQueue}!iqFloatInstsIssued@{iqFloatInstsIssued}}
\index{iqFloatInstsIssued@{iqFloatInstsIssued}!InstQueue@{InstQueue}}
\subsubsection[{iqFloatInstsIssued}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqFloatInstsIssued}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_aa9f2fa124c9f0b4b22461b6717449d9a}
Stat for number of floating point instructions issued. \hypertarget{classInstQueue_a435e1ce10c3a7f54a60941e583adeb09}{
\index{InstQueue@{InstQueue}!iqInstsAdded@{iqInstsAdded}}
\index{iqInstsAdded@{iqInstsAdded}!InstQueue@{InstQueue}}
\subsubsection[{iqInstsAdded}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqInstsAdded}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a435e1ce10c3a7f54a60941e583adeb09}
Stat for number of instructions added. \hypertarget{classInstQueue_a735f2023e70e53b7889a3a316bd3d57f}{
\index{InstQueue@{InstQueue}!iqIntInstsIssued@{iqIntInstsIssued}}
\index{iqIntInstsIssued@{iqIntInstsIssued}!InstQueue@{InstQueue}}
\subsubsection[{iqIntInstsIssued}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqIntInstsIssued}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a735f2023e70e53b7889a3a316bd3d57f}
Stat for number of integer instructions issued. \hypertarget{classInstQueue_a5e7d55d3f07e86e389ca3a715766e108}{
\index{InstQueue@{InstQueue}!iqMemInstsIssued@{iqMemInstsIssued}}
\index{iqMemInstsIssued@{iqMemInstsIssued}!InstQueue@{InstQueue}}
\subsubsection[{iqMemInstsIssued}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqMemInstsIssued}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a5e7d55d3f07e86e389ca3a715766e108}
Stat for number of memory instructions issued. \hypertarget{classInstQueue_ad234890bc414fffe7ed71840c51be5cb}{
\index{InstQueue@{InstQueue}!iqMiscInstsIssued@{iqMiscInstsIssued}}
\index{iqMiscInstsIssued@{iqMiscInstsIssued}!InstQueue@{InstQueue}}
\subsubsection[{iqMiscInstsIssued}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqMiscInstsIssued}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_ad234890bc414fffe7ed71840c51be5cb}
Stat for number of miscellaneous instructions issued. \hypertarget{classInstQueue_adf890a08fae50ea8249171b07c40adac}{
\index{InstQueue@{InstQueue}!iqNonSpecInstsAdded@{iqNonSpecInstsAdded}}
\index{iqNonSpecInstsAdded@{iqNonSpecInstsAdded}!InstQueue@{InstQueue}}
\subsubsection[{iqNonSpecInstsAdded}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqNonSpecInstsAdded}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_adf890a08fae50ea8249171b07c40adac}
Stat for number of non-\/speculative instructions added. \hypertarget{classInstQueue_a8312e8984bcfab5a77de40e1738103db}{
\index{InstQueue@{InstQueue}!iqSquashedInstsExamined@{iqSquashedInstsExamined}}
\index{iqSquashedInstsExamined@{iqSquashedInstsExamined}!InstQueue@{InstQueue}}
\subsubsection[{iqSquashedInstsExamined}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqSquashedInstsExamined}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a8312e8984bcfab5a77de40e1738103db}
Stat for number of squashed instructions examined when squashing. \hypertarget{classInstQueue_ac91799c895e5aff3af0afdbd7691a163}{
\index{InstQueue@{InstQueue}!iqSquashedInstsIssued@{iqSquashedInstsIssued}}
\index{iqSquashedInstsIssued@{iqSquashedInstsIssued}!InstQueue@{InstQueue}}
\subsubsection[{iqSquashedInstsIssued}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqSquashedInstsIssued}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_ac91799c895e5aff3af0afdbd7691a163}
Stat for number of squashed instructions that were ready to issue. \hypertarget{classInstQueue_a6c0b47431b6e84536fd9bb61624d6d97}{
\index{InstQueue@{InstQueue}!iqSquashedNonSpecRemoved@{iqSquashedNonSpecRemoved}}
\index{iqSquashedNonSpecRemoved@{iqSquashedNonSpecRemoved}!InstQueue@{InstQueue}}
\subsubsection[{iqSquashedNonSpecRemoved}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqSquashedNonSpecRemoved}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a6c0b47431b6e84536fd9bb61624d6d97}
Stat for number of non-\/speculative instructions removed due to a squash. \hypertarget{classInstQueue_a4398b6005b81008bd163bbba78dfd929}{
\index{InstQueue@{InstQueue}!iqSquashedOperandsExamined@{iqSquashedOperandsExamined}}
\index{iqSquashedOperandsExamined@{iqSquashedOperandsExamined}!InstQueue@{InstQueue}}
\subsubsection[{iqSquashedOperandsExamined}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iqSquashedOperandsExamined}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a4398b6005b81008bd163bbba78dfd929}
Stat for number of squashed instruction operands examined when squashing. \hypertarget{classInstQueue_af5c55240e63d9a13358eede4eb5352f1}{
\index{InstQueue@{InstQueue}!issueToExecuteQueue@{issueToExecuteQueue}}
\index{issueToExecuteQueue@{issueToExecuteQueue}!InstQueue@{InstQueue}}
\subsubsection[{issueToExecuteQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf IssueStruct}$>$$\ast$ {\bf issueToExecuteQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_af5c55240e63d9a13358eede4eb5352f1}
The queue to the execute stage. Issued instructions will be written into it. \hypertarget{classInstQueue_a51e5f9f0cb40d61e95b1518f1be90b73}{
\index{InstQueue@{InstQueue}!maxEntries@{maxEntries}}
\index{maxEntries@{maxEntries}!InstQueue@{InstQueue}}
\subsubsection[{maxEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf maxEntries}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a51e5f9f0cb40d61e95b1518f1be90b73}
Max IQ Entries Per Thread \hypertarget{classInstQueue_ac0ba4d07026aaf6386c001a68d059cbf}{
\index{InstQueue@{InstQueue}!nonSpecInsts@{nonSpecInsts}}
\index{nonSpecInsts@{nonSpecInsts}!InstQueue@{InstQueue}}
\subsubsection[{nonSpecInsts}]{\setlength{\rightskip}{0pt plus 5cm}std::map$<${\bf InstSeqNum}, {\bf DynInstPtr}$>$ {\bf nonSpecInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_ac0ba4d07026aaf6386c001a68d059cbf}
List of non-\/speculative instructions that will be scheduled once the IQ gets a signal from commit. While it's redundant to have the key be a part of the value (the sequence number is stored inside of DynInst), when these instructions are woken up only the sequence number will be available. Thus it is most efficient to be able to search by the sequence number alone. \hypertarget{classInstQueue_a325de474a9f6652329339d9fc2ea09c0}{
\index{InstQueue@{InstQueue}!numEntries@{numEntries}}
\index{numEntries@{numEntries}!InstQueue@{InstQueue}}
\subsubsection[{numEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf numEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a325de474a9f6652329339d9fc2ea09c0}
The number of entries in the instruction queue. \hypertarget{classInstQueue_a792311f13ea91008a88e902ef13b0341}{
\index{InstQueue@{InstQueue}!numThreads@{numThreads}}
\index{numThreads@{numThreads}!InstQueue@{InstQueue}}
\subsubsection[{numThreads}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf numThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a792311f13ea91008a88e902ef13b0341}
Number of Total Threads \hypertarget{classInstQueue_a73e22f052c708ca5c198bd0a01eb3604}{
\index{InstQueue@{InstQueue}!readyInsts@{readyInsts}}
\index{readyInsts@{readyInsts}!InstQueue@{InstQueue}}
\subsubsection[{readyInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ReadyInstQueue} {\bf readyInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a73e22f052c708ca5c198bd0a01eb3604}
List of ready instructions. \hypertarget{classInstQueue_a97d5a7e4630ad1d017909f7504b9ec32}{
\index{InstQueue@{InstQueue}!squashedSeqNum@{squashedSeqNum}}
\index{squashedSeqNum@{squashedSeqNum}!InstQueue@{InstQueue}}
\subsubsection[{squashedSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf squashedSeqNum}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a97d5a7e4630ad1d017909f7504b9ec32}
The sequence number of the squashed instruction. \hypertarget{classInstQueue_a76b506d03788e72757da427226e10356}{
\index{InstQueue@{InstQueue}!squashIt@{squashIt}}
\index{squashIt@{squashIt}!InstQueue@{InstQueue}}
\subsubsection[{squashIt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ListIt} {\bf squashIt}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_a76b506d03788e72757da427226e10356}
Iterator that points to the last instruction that has been squashed. This will not be valid unless the IQ is in the process of squashing. \hypertarget{classInstQueue_ab3c3a8cd00248d9cd6acad330da902a7}{
\index{InstQueue@{InstQueue}!totalWidth@{totalWidth}}
\index{totalWidth@{totalWidth}!InstQueue@{InstQueue}}
\subsubsection[{totalWidth}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf totalWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classInstQueue_ab3c3a8cd00248d9cd6acad330da902a7}
The total number of instructions that can be issued in one cycle. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/ozone/\hyperlink{ozone_2inst__queue_8hh}{inst\_\-queue.hh}\item 
cpu/ozone/\hyperlink{ozone_2inst__queue__impl_8hh}{inst\_\-queue\_\-impl.hh}\end{DoxyCompactItemize}
