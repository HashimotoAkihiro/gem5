\hypertarget{classDefaultCommit}{
\section{クラス テンプレート DefaultCommit$<$ Impl $>$}
\label{classDefaultCommit}\index{DefaultCommit@{DefaultCommit}}
}


{\ttfamily \#include $<$commit.hh$>$}\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classDefaultCommit_1_1TrapEvent}{TrapEvent}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classDefaultCommit_a40bce497731b29d1d0756af6c5e40986}{CommitStatus} \{ \hyperlink{classDefaultCommit_a40bce497731b29d1d0756af6c5e40986a26bd8444261cc58df7a86753c79d2520}{Active}, 
\hyperlink{classDefaultCommit_a40bce497731b29d1d0756af6c5e40986a969c924a722daf6334fca64346092ae6}{Inactive}
 \}
\item 
enum \hyperlink{classDefaultCommit_ae2739961013a00cede621d4d72f2173c}{ThreadStatus} \{ \par
\hyperlink{classDefaultCommit_ae2739961013a00cede621d4d72f2173ca2f5f2c4a8c4f4f0519d503dcdfbf55cb}{Running}, 
\hyperlink{classDefaultCommit_ae2739961013a00cede621d4d72f2173cad3fa9ae9431d6cb1772f9d9df48cab19}{Idle}, 
\hyperlink{classDefaultCommit_ae2739961013a00cede621d4d72f2173ca55ceab70c6d1094de92189130c899d84}{ROBSquashing}, 
\hyperlink{classDefaultCommit_ae2739961013a00cede621d4d72f2173ca8c49adf6da5f507150d403610c684877}{TrapPending}, 
\par
\hyperlink{classDefaultCommit_ae2739961013a00cede621d4d72f2173ca757a5840686b21827966401ca2499141}{FetchTrapPending}, 
\hyperlink{classDefaultCommit_ae2739961013a00cede621d4d72f2173ca1f0e8d98cfb4db458b98f0b5e3f49466}{SquashAfterPending}
 \}
\item 
enum \hyperlink{classDefaultCommit_a2b5cad948a22cc08e48fe1a2226c8d05}{CommitPolicy} \{ \hyperlink{classDefaultCommit_a2b5cad948a22cc08e48fe1a2226c8d05a227598607ef691b05c9eb1ea73a06a2f}{Aggressive}, 
\hyperlink{classDefaultCommit_a2b5cad948a22cc08e48fe1a2226c8d05a5c08841de48c15133dd26a4d9d740a11}{RoundRobin}, 
\hyperlink{classDefaultCommit_a2b5cad948a22cc08e48fe1a2226c8d05a1ce7bd97138a7693d81bee46fa74a1cc}{OldestReady}
 \}
\item 
typedef Impl::O3CPU \hyperlink{classDefaultCommit_a44622cf06940413482836cb62931ac3f}{O3CPU}
\item 
typedef Impl::DynInstPtr \hyperlink{classDefaultCommit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}
\item 
typedef Impl::CPUPol \hyperlink{classDefaultCommit_a87d662eaeb9eab249d671b63cb4ba11a}{CPUPol}
\item 
typedef CPUPol::RenameMap \hyperlink{classDefaultCommit_a341963bcea1928476182a17e357f98e3}{RenameMap}
\item 
typedef CPUPol::ROB \hyperlink{classDefaultCommit_aa480e463fb139d9966f38e3895a8b326}{ROB}
\item 
typedef CPUPol::TimeStruct \hyperlink{classDefaultCommit_ab7dd3632ef639702a5c6e7c2c3a2f82a}{TimeStruct}
\item 
typedef CPUPol::FetchStruct \hyperlink{classDefaultCommit_a3aac8607069f16898ef53cfaa2d97aeb}{FetchStruct}
\item 
typedef CPUPol::IEWStruct \hyperlink{classDefaultCommit_a7cf3f052f760b3a8a18623f792c10910}{IEWStruct}
\item 
typedef CPUPol::RenameStruct \hyperlink{classDefaultCommit_a0c2a89ad2edad9ad605d0461f9b132a5}{RenameStruct}
\item 
typedef CPUPol::Fetch \hyperlink{classDefaultCommit_aea27de1f675f508e1eb618ac115ce05c}{Fetch}
\item 
typedef CPUPol::IEW \hyperlink{classDefaultCommit_a2e298f790f528754f0e0ffa0cb8088f6}{IEW}
\item 
typedef \hyperlink{structO3ThreadState}{O3ThreadState}$<$ Impl $>$ \hyperlink{classDefaultCommit_ad5e0f9b655492f45720f8d756f11d3b5}{Thread}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDefaultCommit_ac5ef93cb7a09f9a537c03bb1d002f7a2}{DefaultCommit} (\hyperlink{classDefaultCommit_a44622cf06940413482836cb62931ac3f}{O3CPU} $\ast$\_\-cpu, DerivO3CPUParams $\ast$params)
\item 
std::string \hyperlink{classDefaultCommit_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classDefaultCommit_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classDefaultCommit_aa2dab17a363fd4307274d579796adcf7}{regProbePoints} ()
\item 
void \hyperlink{classDefaultCommit_aa8150d8ab62e6314eb07420a63aedce2}{setThreads} (\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{structO3ThreadState}{Thread} $\ast$ $>$ \&threads)
\item 
void \hyperlink{classDefaultCommit_a2b521ea5f191fff72265f60d4ed5187b}{setTimeBuffer} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$ $\ast$tb\_\-ptr)
\item 
void \hyperlink{classDefaultCommit_ad1be90519aa7737ddf8e41de079a5ea9}{setFetchQueue} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultCommit_a3aac8607069f16898ef53cfaa2d97aeb}{FetchStruct} $>$ $\ast$fq\_\-ptr)
\item 
void \hyperlink{classDefaultCommit_a701624f92a819fe4205faede6e614d9f}{setRenameQueue} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultCommit_a0c2a89ad2edad9ad605d0461f9b132a5}{RenameStruct} $>$ $\ast$rq\_\-ptr)
\item 
void \hyperlink{classDefaultCommit_a6b8bf7d75423c9bccd93d50470f7f935}{setIEWQueue} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultCommit_a7cf3f052f760b3a8a18623f792c10910}{IEWStruct} $>$ $\ast$iq\_\-ptr)
\item 
void \hyperlink{classDefaultCommit_a4b6d8e4b2cf6249763ed2fc73eb1af47}{setIEWStage} (\hyperlink{classDefaultCommit_a2e298f790f528754f0e0ffa0cb8088f6}{IEW} $\ast$iew\_\-stage)
\item 
void \hyperlink{classDefaultCommit_aab96bdacf8bd420402cbb543f994e054}{setActiveThreads} (\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$at\_\-ptr)
\item 
void \hyperlink{classDefaultCommit_a6f0aaedb2c39d674ef86c25d0aeb4211}{setRenameMap} (\hyperlink{classDefaultCommit_a341963bcea1928476182a17e357f98e3}{RenameMap} rm\_\-ptr\mbox{[}Impl::MaxThreads\mbox{]})
\item 
void \hyperlink{classDefaultCommit_a46149ea78698ff6515a509c53d814193}{setROB} (\hyperlink{classROB}{ROB} $\ast$rob\_\-ptr)
\item 
void \hyperlink{classDefaultCommit_a31d4cbdab16d4ff8d6bc7f84ece727da}{startupStage} ()
\item 
void \hyperlink{classDefaultCommit_af7d01b5776b9d8a0f218aec331ddaeb9}{drain} ()
\item 
void \hyperlink{classDefaultCommit_a8f020d3237536fe007fc488c4125c5d8}{drainResume} ()
\item 
void \hyperlink{classDefaultCommit_a0240eb42fa57fe5d3788093f62b77347}{drainSanityCheck} () const 
\item 
bool \hyperlink{classDefaultCommit_adf5473c18a3d7c1e88c4a2072bce5526}{isDrained} () const 
\item 
void \hyperlink{classDefaultCommit_a8674059ce345e23aac5086b2c3e24a43}{takeOverFrom} ()
\item 
void \hyperlink{classDefaultCommit_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\item 
void \hyperlink{classDefaultCommit_ad55316f5135cdae6aa6c5a763f6c3473}{commit} ()
\item 
size\_\-t \hyperlink{classDefaultCommit_a3c8eae00d4f0d15336eec11f879146c2}{numROBFreeEntries} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultCommit_a7002d0f2beae1ce9a349218968ff97c3}{generateTrapEvent} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultCommit_a4adb99d6e22b7028a21e537331de6253}{generateTCEvent} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
TheISA::PCState \hyperlink{classDefaultCommit_af486ac7476906f63fc6696b3e76a411b}{pcState} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultCommit_aaa8fbb79b13ce112b6d11f77bc3dd18f}{pcState} (const TheISA::PCState \&val, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classDefaultCommit_afae6152cf4b3a51162d6e64247c1ac09}{instAddr} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classDefaultCommit_af1caba1f04cf2802d742d1a16b961e79}{nextInstAddr} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classDefaultCommit_a697667536e687bd20e95084adc90d820}{microPC} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
std::queue$<$ \hyperlink{classDefaultCommit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classDefaultCommit_ab9508ede35e5a000089a1450342412be}{skidBuffer}
\item 
\hyperlink{classDefaultCommit_a2e298f790f528754f0e0ffa0cb8088f6}{IEW} $\ast$ \hyperlink{classDefaultCommit_a4e9ef25d8913b270d432be4bbfe4965c}{iewStage}
\item 
\hyperlink{classROB}{ROB} $\ast$ \hyperlink{classDefaultCommit_a74983e0d923870864acf5b5477449d48}{rob}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classDefaultCommit_a4bb9486757ce225941aaaf759b357a57}{updateStatus} ()
\item 
void \hyperlink{classDefaultCommit_a4c5106e8a165f2f63807122b80a4e580}{setNextStatus} ()
\item 
bool \hyperlink{classDefaultCommit_a6949aa47bdaf57471e048da5c5b7c14c}{robDoneSquashing} ()
\item 
bool \hyperlink{classDefaultCommit_ac5a2190cdc184d1396bee3a6d99e34e7}{changedROBEntries} ()
\item 
void \hyperlink{classDefaultCommit_a9aa66ed2ab2c61003cbbc4f0cbb53a13}{squashAll} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultCommit_a2f79a5e45c55f3cba92021d1a5ebaadf}{squashFromTrap} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultCommit_ac4c7a18be5c282d711310ffb7b6f82f7}{squashFromTC} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultCommit_a05dbc60b1e537c4a85f4ab6dec6ca9a4}{squashFromSquashAfter} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultCommit_ad47b387a7bbc4a2153b50f96b8fd2a51}{squashAfter} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid, \hyperlink{classDefaultCommit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&head\_\-inst)
\item 
void \hyperlink{classDefaultCommit_a1cb72a248a56b5dc2b2ed27db7560b90}{handleInterrupt} ()
\item 
void \hyperlink{classDefaultCommit_ab9d20a05498697dfc59478b80a0726fb}{propagateInterrupt} ()
\item 
void \hyperlink{classDefaultCommit_ac8b85fbfdf330d000c094a9d1886d264}{commitInsts} ()
\item 
bool \hyperlink{classDefaultCommit_a5beb5c9ae170034a8abe7a578e04e47a}{commitHead} (\hyperlink{classDefaultCommit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&head\_\-inst, unsigned inst\_\-num)
\item 
void \hyperlink{classDefaultCommit_a8d0c39182cb7719942e865bcaaff769b}{getInsts} ()
\item 
void \hyperlink{classDefaultCommit_affce029fbba116bb863eb2a3a7a5bb48}{skidInsert} ()
\item 
void \hyperlink{classDefaultCommit_a035349a9fd8a12938e7997be5a76211e}{markCompletedInsts} ()
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classDefaultCommit_ad313fd14604cfa26fec9c62dba3a7062}{getCommittingThread} ()
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classDefaultCommit_a8aab9cacbc483081596b13ecd5192eb5}{roundRobin} ()
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classDefaultCommit_a7b2c5e474b4fd5c54395b44f3b792d21}{oldestReady} ()
\item 
void \hyperlink{classDefaultCommit_a5bbf266cb0cc97eed138c8fe0d2d76b6}{updateComInstStats} (\hyperlink{classDefaultCommit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDefaultCommit_a40bce497731b29d1d0756af6c5e40986}{CommitStatus} \hyperlink{classDefaultCommit_a0cf11ec4d376480eb733b779911f6446}{\_\-status}
\item 
\hyperlink{classDefaultCommit_a40bce497731b29d1d0756af6c5e40986}{CommitStatus} \hyperlink{classDefaultCommit_a96c6cf126a60fa550bd3e279b0f33838}{\_\-nextStatus}
\item 
\hyperlink{classDefaultCommit_ae2739961013a00cede621d4d72f2173c}{ThreadStatus} \hyperlink{classDefaultCommit_ae7adb1afa143087a1e39aa65f3921185}{commitStatus} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classDefaultCommit_a2b5cad948a22cc08e48fe1a2226c8d05}{CommitPolicy} \hyperlink{classDefaultCommit_acbc18713699043ca78415e9f03712ce1}{commitPolicy}
\item 
\hyperlink{classProbePointArg}{ProbePointArg}$<$ \hyperlink{classDefaultCommit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ $\ast$ \hyperlink{classDefaultCommit_ae41ff03242cc6980c072e3ea824168ed}{ppCommit}
\item 
\hyperlink{classProbePointArg}{ProbePointArg}$<$ \hyperlink{classDefaultCommit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ $\ast$ \hyperlink{classDefaultCommit_a3c0bfd67f137dbd48bc31ade04a09cf0}{ppCommitStall}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$ $\ast$ \hyperlink{classDefaultCommit_a83f9ee976e732665aeb08dbc19acfd45}{timeBuffer}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classDefaultCommit_a2877bfe6e25eb731f28c8c5a9ba55391}{toIEW}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classDefaultCommit_a2b90705fefdf84763685650c2420f184}{robInfoFromIEW}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultCommit_a3aac8607069f16898ef53cfaa2d97aeb}{FetchStruct} $>$ $\ast$ \hyperlink{classDefaultCommit_a9a2f350be647ebfb6567172812db491a}{fetchQueue}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultCommit_a3aac8607069f16898ef53cfaa2d97aeb}{FetchStruct} $>$::wire \hyperlink{classDefaultCommit_a2e3dd009c447d077f19b303b53b52fab}{fromFetch}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultCommit_a7cf3f052f760b3a8a18623f792c10910}{IEWStruct} $>$ $\ast$ \hyperlink{classDefaultCommit_a034b0868914c304e81c13c4e645d2616}{iewQueue}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultCommit_a7cf3f052f760b3a8a18623f792c10910}{IEWStruct} $>$::wire \hyperlink{classDefaultCommit_a7968756e9e478ff69e80117ffbea4e46}{fromIEW}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultCommit_a0c2a89ad2edad9ad605d0461f9b132a5}{RenameStruct} $>$ $\ast$ \hyperlink{classDefaultCommit_ae9b536282159ba75153a223be77515ba}{renameQueue}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultCommit_a0c2a89ad2edad9ad605d0461f9b132a5}{RenameStruct} $>$::wire \hyperlink{classDefaultCommit_a2b6b1d4785b92bd378f8a7abc5b7e6b9}{fromRename}
\item 
\hyperlink{classDefaultCommit_a44622cf06940413482836cb62931ac3f}{O3CPU} $\ast$ \hyperlink{classDefaultCommit_a1379cf882a12ac6fc9eba5da7c84b18b}{cpu}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{structO3ThreadState}{Thread} $\ast$ $>$ \hyperlink{classDefaultCommit_afe9da004c5a3f37cbb72fa3763d4c0d1}{thread}
\item 
bool \hyperlink{classDefaultCommit_a2c7e870d4babdac0dc91fc7ffabd0f3d}{wroteToTimeBuffer}
\item 
bool \hyperlink{classDefaultCommit_a0d55e69b2ac22e8956d569bcf49e374b}{changedROBNumEntries} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classDefaultCommit_a06341c2bebd8c862e411e474e01c9c1a}{squashCounter}
\item 
bool \hyperlink{classDefaultCommit_af3547420a792f13034730b5f327a47ff}{trapSquash} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
bool \hyperlink{classDefaultCommit_a4fce523b7a931003efb9665605a87ca0}{tcSquash} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classDefaultCommit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classDefaultCommit_af0c3f70b9be736dfd854ea22a0131e1c}{squashAfterInst} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ \hyperlink{classDefaultCommit_a4d358db7156d04e20b3269a53334dd19}{priority\_\-list}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classDefaultCommit_a29f74b65419ba8f0ae250d65e960202b}{iewToCommitDelay}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classDefaultCommit_a6b6fe1148ed7c40758e45f351c375552}{commitToIEWDelay}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classDefaultCommit_af699b6479037861b3c0e17d4bfab001d}{renameToROBDelay}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classDefaultCommit_a345f75b8236aa4fbe4ae976f8eb41a4c}{fetchToCommitDelay}
\item 
unsigned \hyperlink{classDefaultCommit_a4b41704382bddb6ee06b5ce97b47dd7b}{renameWidth}
\item 
unsigned \hyperlink{classDefaultCommit_aeab15260a0ccc0ea470bb74344b63d17}{commitWidth}
\item 
unsigned \hyperlink{classDefaultCommit_a35ee8ef405428b8d8595176ea6581681}{numRobs}
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classDefaultCommit_a88377f855dbf5adeeecb06b5bb821d35}{numThreads}
\item 
bool \hyperlink{classDefaultCommit_a547316e5bf0dc6115209737cf68e9bb8}{drainPending}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classDefaultCommit_a0bfffaa2e5f9c7e79353e61146950a9a}{trapLatency}
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classDefaultCommit_a7387b2358d0f884ccd5c383e6199f035}{interrupt}
\item 
TheISA::PCState \hyperlink{classDefaultCommit_a6e6091c9272a281b8693c0f46279cad0}{pc} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classDefaultCommit_a1d81dc5c05e15057c1985acc39285540}{youngestSeqNum} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classDefaultCommit_a4feaee1ef312dda13cff064de20dfbf3}{lastCommitedSeqNum} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
bool \hyperlink{classDefaultCommit_a4e366a325229901e41b68ff07e5f556a}{trapInFlight} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
bool \hyperlink{classDefaultCommit_a0fd9fcb6eed99c11c7fa61c7218ecf49}{committedStores} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
bool \hyperlink{classDefaultCommit_aa2d2d9b2eec88d804e25d1cb37aa6083}{checkEmptyROB} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$ \hyperlink{classDefaultCommit_af6eaea53db532812052f71bf0380dab5}{activeThreads}
\item 
\hyperlink{classDefaultCommit_a341963bcea1928476182a17e357f98e3}{RenameMap} $\ast$ \hyperlink{classDefaultCommit_ac305c101c17d28451cc1f023b187b08b}{renameMap} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
bool \hyperlink{classDefaultCommit_a893f45e65e8a47bca58661db7662cd9c}{canHandleInterrupts}
\item 
bool \hyperlink{classDefaultCommit_a7c6eee41dc1f18f1f485518f8b066033}{avoidQuiesceLiveLock}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultCommit_a66220ac67b22e3faf86b642ecc217546}{commitSquashedInsts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultCommit_a89ef54d73dbded95395181561013b0b6}{commitSquashEvents}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultCommit_ab930685f4a43596f8a315d7dc9f5c2e4}{commitNonSpecStalls}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultCommit_a9cbfa1c154e785e3c45699b02a94053d}{branchMispredicts}
\item 
\hyperlink{classStats_1_1Distribution}{Stats::Distribution} \hyperlink{classDefaultCommit_ab1b6b40d7860fef5059f9bf1b843b366}{numCommittedDist}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultCommit_a23714085cc19270c017a67c9a508601a}{instsCommitted}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultCommit_a1549eb9ffd1727a5c1937e7520a0bcc8}{opsCommitted}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultCommit_a4cb385aa97530dd2621c74f376839e79}{statComSwp}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultCommit_afe174c4b8e70d840a2e91bf1ca3092ac}{statComRefs}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultCommit_a91927819864b9dc9d1ac706dc55d5dce}{statComLoads}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultCommit_a9b029ac182d54199247dfa90ed86d368}{statComMembars}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultCommit_a39a7da0b20d1e83ccfe4b2f2b19d6e94}{statComBranches}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultCommit_a2be26eb7dfa8b9e36d0c6fdcaea8d818}{statComFloating}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultCommit_ae562968e75d903bd12352af65cc558b6}{statComInteger}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultCommit_acd1aba8c2f19771552212e9c2917ac6b}{statComFunctionCalls}
\item 
\hyperlink{classStats_1_1Vector2d}{Stats::Vector2d} \hyperlink{classDefaultCommit_ad0d59ba553bc001d75aff706903e2f77}{statCommittedInstType}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultCommit_a16d1a4bbb2cb87488fd876fbf6e7a518}{commitEligibleSamples}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultCommit_a26f5138543e43cbaba9459036fc0b04c}{commitEligible}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$class Impl$>$ class DefaultCommit$<$ Impl $>$}

\hyperlink{classDefaultCommit}{DefaultCommit} handles single threaded and SMT commit. Its width is specified by the parameters; each cycle it tries to commit that many instructions. The SMT policy decides which thread it tries to commit instructions from. Non-\/ speculative instructions must reach the head of the \hyperlink{classROB}{ROB} before they are ready to execute; once they reach the head, commit will broadcast the instruction's sequence number to the previous stages so that they can issue/ execute the instruction. Only one non-\/speculative instruction is handled per cycle. Commit is responsible for handling all back-\/end initiated redirects. It receives the redirect, and then broadcasts it to all stages, indicating the sequence number they should squash until, and any necessary branch misprediction information as well. It priortizes redirects by instruction's age, only broadcasting a redirect if it corresponds to an instruction that should currently be in the \hyperlink{classROB}{ROB}. This is done by tracking the sequence number of the youngest instruction in the \hyperlink{classROB}{ROB}, which gets updated to any squashing instruction's sequence number, and only broadcasting a redirect if it corresponds to an older instruction. Commit also supports multiple cycle squashing, to model a \hyperlink{classROB}{ROB} that can only remove a certain number of instructions per cycle. 

\subsection{型定義}
\hypertarget{classDefaultCommit_a87d662eaeb9eab249d671b63cb4ba11a}{
\index{DefaultCommit@{DefaultCommit}!CPUPol@{CPUPol}}
\index{CPUPol@{CPUPol}!DefaultCommit@{DefaultCommit}}
\subsubsection[{CPUPol}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::CPUPol {\bf CPUPol}}}
\label{classDefaultCommit_a87d662eaeb9eab249d671b63cb4ba11a}
\hypertarget{classDefaultCommit_a028ce10889c5f6450239d9e9a7347976}{
\index{DefaultCommit@{DefaultCommit}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!DefaultCommit@{DefaultCommit}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInstPtr {\bf DynInstPtr}}}
\label{classDefaultCommit_a028ce10889c5f6450239d9e9a7347976}
\hypertarget{classDefaultCommit_aea27de1f675f508e1eb618ac115ce05c}{
\index{DefaultCommit@{DefaultCommit}!Fetch@{Fetch}}
\index{Fetch@{Fetch}!DefaultCommit@{DefaultCommit}}
\subsubsection[{Fetch}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::Fetch {\bf Fetch}}}
\label{classDefaultCommit_aea27de1f675f508e1eb618ac115ce05c}
\hypertarget{classDefaultCommit_a3aac8607069f16898ef53cfaa2d97aeb}{
\index{DefaultCommit@{DefaultCommit}!FetchStruct@{FetchStruct}}
\index{FetchStruct@{FetchStruct}!DefaultCommit@{DefaultCommit}}
\subsubsection[{FetchStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::FetchStruct {\bf FetchStruct}}}
\label{classDefaultCommit_a3aac8607069f16898ef53cfaa2d97aeb}
\hypertarget{classDefaultCommit_a2e298f790f528754f0e0ffa0cb8088f6}{
\index{DefaultCommit@{DefaultCommit}!IEW@{IEW}}
\index{IEW@{IEW}!DefaultCommit@{DefaultCommit}}
\subsubsection[{IEW}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::IEW {\bf IEW}}}
\label{classDefaultCommit_a2e298f790f528754f0e0ffa0cb8088f6}
\hypertarget{classDefaultCommit_a7cf3f052f760b3a8a18623f792c10910}{
\index{DefaultCommit@{DefaultCommit}!IEWStruct@{IEWStruct}}
\index{IEWStruct@{IEWStruct}!DefaultCommit@{DefaultCommit}}
\subsubsection[{IEWStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::IEWStruct {\bf IEWStruct}}}
\label{classDefaultCommit_a7cf3f052f760b3a8a18623f792c10910}
\hypertarget{classDefaultCommit_a44622cf06940413482836cb62931ac3f}{
\index{DefaultCommit@{DefaultCommit}!O3CPU@{O3CPU}}
\index{O3CPU@{O3CPU}!DefaultCommit@{DefaultCommit}}
\subsubsection[{O3CPU}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::O3CPU {\bf O3CPU}}}
\label{classDefaultCommit_a44622cf06940413482836cb62931ac3f}
\hypertarget{classDefaultCommit_a341963bcea1928476182a17e357f98e3}{
\index{DefaultCommit@{DefaultCommit}!RenameMap@{RenameMap}}
\index{RenameMap@{RenameMap}!DefaultCommit@{DefaultCommit}}
\subsubsection[{RenameMap}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::RenameMap {\bf RenameMap}}}
\label{classDefaultCommit_a341963bcea1928476182a17e357f98e3}
\hypertarget{classDefaultCommit_a0c2a89ad2edad9ad605d0461f9b132a5}{
\index{DefaultCommit@{DefaultCommit}!RenameStruct@{RenameStruct}}
\index{RenameStruct@{RenameStruct}!DefaultCommit@{DefaultCommit}}
\subsubsection[{RenameStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::RenameStruct {\bf RenameStruct}}}
\label{classDefaultCommit_a0c2a89ad2edad9ad605d0461f9b132a5}
\hypertarget{classDefaultCommit_aa480e463fb139d9966f38e3895a8b326}{
\index{DefaultCommit@{DefaultCommit}!ROB@{ROB}}
\index{ROB@{ROB}!DefaultCommit@{DefaultCommit}}
\subsubsection[{ROB}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::ROB {\bf ROB}}}
\label{classDefaultCommit_aa480e463fb139d9966f38e3895a8b326}
\hypertarget{classDefaultCommit_ad5e0f9b655492f45720f8d756f11d3b5}{
\index{DefaultCommit@{DefaultCommit}!Thread@{Thread}}
\index{Thread@{Thread}!DefaultCommit@{DefaultCommit}}
\subsubsection[{Thread}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf O3ThreadState}$<$Impl$>$ {\bf Thread}}}
\label{classDefaultCommit_ad5e0f9b655492f45720f8d756f11d3b5}
\hypertarget{classDefaultCommit_ab7dd3632ef639702a5c6e7c2c3a2f82a}{
\index{DefaultCommit@{DefaultCommit}!TimeStruct@{TimeStruct}}
\index{TimeStruct@{TimeStruct}!DefaultCommit@{DefaultCommit}}
\subsubsection[{TimeStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::TimeStruct {\bf TimeStruct}}}
\label{classDefaultCommit_ab7dd3632ef639702a5c6e7c2c3a2f82a}


\subsection{列挙型}
\hypertarget{classDefaultCommit_a2b5cad948a22cc08e48fe1a2226c8d05}{
\index{DefaultCommit@{DefaultCommit}!CommitPolicy@{CommitPolicy}}
\index{CommitPolicy@{CommitPolicy}!DefaultCommit@{DefaultCommit}}
\subsubsection[{CommitPolicy}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf CommitPolicy}}}
\label{classDefaultCommit_a2b5cad948a22cc08e48fe1a2226c8d05}
Commit policy for SMT mode. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Aggressive@{Aggressive}!DefaultCommit@{DefaultCommit}}\index{DefaultCommit@{DefaultCommit}!Aggressive@{Aggressive}}\item[{\em 
\hypertarget{classDefaultCommit_a2b5cad948a22cc08e48fe1a2226c8d05a227598607ef691b05c9eb1ea73a06a2f}{
Aggressive}
\label{classDefaultCommit_a2b5cad948a22cc08e48fe1a2226c8d05a227598607ef691b05c9eb1ea73a06a2f}
}]\index{RoundRobin@{RoundRobin}!DefaultCommit@{DefaultCommit}}\index{DefaultCommit@{DefaultCommit}!RoundRobin@{RoundRobin}}\item[{\em 
\hypertarget{classDefaultCommit_a2b5cad948a22cc08e48fe1a2226c8d05a5c08841de48c15133dd26a4d9d740a11}{
RoundRobin}
\label{classDefaultCommit_a2b5cad948a22cc08e48fe1a2226c8d05a5c08841de48c15133dd26a4d9d740a11}
}]\index{OldestReady@{OldestReady}!DefaultCommit@{DefaultCommit}}\index{DefaultCommit@{DefaultCommit}!OldestReady@{OldestReady}}\item[{\em 
\hypertarget{classDefaultCommit_a2b5cad948a22cc08e48fe1a2226c8d05a1ce7bd97138a7693d81bee46fa74a1cc}{
OldestReady}
\label{classDefaultCommit_a2b5cad948a22cc08e48fe1a2226c8d05a1ce7bd97138a7693d81bee46fa74a1cc}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
138                       {
139         Aggressive,
140         RoundRobin,
141         OldestReady
142     };
\end{DoxyCode}
\hypertarget{classDefaultCommit_a40bce497731b29d1d0756af6c5e40986}{
\index{DefaultCommit@{DefaultCommit}!CommitStatus@{CommitStatus}}
\index{CommitStatus@{CommitStatus}!DefaultCommit@{DefaultCommit}}
\subsubsection[{CommitStatus}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf CommitStatus}}}
\label{classDefaultCommit_a40bce497731b29d1d0756af6c5e40986}
Overall commit status. Used to determine if the CPU can deschedule itself due to a lack of activity. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Active@{Active}!DefaultCommit@{DefaultCommit}}\index{DefaultCommit@{DefaultCommit}!Active@{Active}}\item[{\em 
\hypertarget{classDefaultCommit_a40bce497731b29d1d0756af6c5e40986a26bd8444261cc58df7a86753c79d2520}{
Active}
\label{classDefaultCommit_a40bce497731b29d1d0756af6c5e40986a26bd8444261cc58df7a86753c79d2520}
}]\index{Inactive@{Inactive}!DefaultCommit@{DefaultCommit}}\index{DefaultCommit@{DefaultCommit}!Inactive@{Inactive}}\item[{\em 
\hypertarget{classDefaultCommit_a40bce497731b29d1d0756af6c5e40986a969c924a722daf6334fca64346092ae6}{
Inactive}
\label{classDefaultCommit_a40bce497731b29d1d0756af6c5e40986a969c924a722daf6334fca64346092ae6}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
122                      {
123         Active,
124         Inactive
125     };
\end{DoxyCode}
\hypertarget{classDefaultCommit_ae2739961013a00cede621d4d72f2173c}{
\index{DefaultCommit@{DefaultCommit}!ThreadStatus@{ThreadStatus}}
\index{ThreadStatus@{ThreadStatus}!DefaultCommit@{DefaultCommit}}
\subsubsection[{ThreadStatus}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ThreadStatus}}}
\label{classDefaultCommit_ae2739961013a00cede621d4d72f2173c}
Individual thread status. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Running@{Running}!DefaultCommit@{DefaultCommit}}\index{DefaultCommit@{DefaultCommit}!Running@{Running}}\item[{\em 
\hypertarget{classDefaultCommit_ae2739961013a00cede621d4d72f2173ca2f5f2c4a8c4f4f0519d503dcdfbf55cb}{
Running}
\label{classDefaultCommit_ae2739961013a00cede621d4d72f2173ca2f5f2c4a8c4f4f0519d503dcdfbf55cb}
}]\index{Idle@{Idle}!DefaultCommit@{DefaultCommit}}\index{DefaultCommit@{DefaultCommit}!Idle@{Idle}}\item[{\em 
\hypertarget{classDefaultCommit_ae2739961013a00cede621d4d72f2173cad3fa9ae9431d6cb1772f9d9df48cab19}{
Idle}
\label{classDefaultCommit_ae2739961013a00cede621d4d72f2173cad3fa9ae9431d6cb1772f9d9df48cab19}
}]\index{ROBSquashing@{ROBSquashing}!DefaultCommit@{DefaultCommit}}\index{DefaultCommit@{DefaultCommit}!ROBSquashing@{ROBSquashing}}\item[{\em 
\hypertarget{classDefaultCommit_ae2739961013a00cede621d4d72f2173ca55ceab70c6d1094de92189130c899d84}{
ROBSquashing}
\label{classDefaultCommit_ae2739961013a00cede621d4d72f2173ca55ceab70c6d1094de92189130c899d84}
}]\index{TrapPending@{TrapPending}!DefaultCommit@{DefaultCommit}}\index{DefaultCommit@{DefaultCommit}!TrapPending@{TrapPending}}\item[{\em 
\hypertarget{classDefaultCommit_ae2739961013a00cede621d4d72f2173ca8c49adf6da5f507150d403610c684877}{
TrapPending}
\label{classDefaultCommit_ae2739961013a00cede621d4d72f2173ca8c49adf6da5f507150d403610c684877}
}]\index{FetchTrapPending@{FetchTrapPending}!DefaultCommit@{DefaultCommit}}\index{DefaultCommit@{DefaultCommit}!FetchTrapPending@{FetchTrapPending}}\item[{\em 
\hypertarget{classDefaultCommit_ae2739961013a00cede621d4d72f2173ca757a5840686b21827966401ca2499141}{
FetchTrapPending}
\label{classDefaultCommit_ae2739961013a00cede621d4d72f2173ca757a5840686b21827966401ca2499141}
}]\index{SquashAfterPending@{SquashAfterPending}!DefaultCommit@{DefaultCommit}}\index{DefaultCommit@{DefaultCommit}!SquashAfterPending@{SquashAfterPending}}\item[{\em 
\hypertarget{classDefaultCommit_ae2739961013a00cede621d4d72f2173ca1f0e8d98cfb4db458b98f0b5e3f49466}{
SquashAfterPending}
\label{classDefaultCommit_ae2739961013a00cede621d4d72f2173ca1f0e8d98cfb4db458b98f0b5e3f49466}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
128                       {
129         Running,
130         Idle,
131         ROBSquashing,
132         TrapPending,
133         FetchTrapPending,
134         SquashAfterPending, //< Committing instructions before a squash.
135     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classDefaultCommit_ac5ef93cb7a09f9a537c03bb1d002f7a2}{
\index{DefaultCommit@{DefaultCommit}!DefaultCommit@{DefaultCommit}}
\index{DefaultCommit@{DefaultCommit}!DefaultCommit@{DefaultCommit}}
\subsubsection[{DefaultCommit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DefaultCommit} ({\bf O3CPU} $\ast$ {\em \_\-cpu}, \/  DerivO3CPUParams $\ast$ {\em params})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_ac5ef93cb7a09f9a537c03bb1d002f7a2}
Construct a \hyperlink{classDefaultCommit}{DefaultCommit} with the given parameters. 


\begin{DoxyCode}
97     : cpu(_cpu),
98       squashCounter(0),
99       iewToCommitDelay(params->iewToCommitDelay),
100       commitToIEWDelay(params->commitToIEWDelay),
101       renameToROBDelay(params->renameToROBDelay),
102       fetchToCommitDelay(params->commitToFetchDelay),
103       renameWidth(params->renameWidth),
104       commitWidth(params->commitWidth),
105       numThreads(params->numThreads),
106       drainPending(false),
107       trapLatency(params->trapLatency),
108       canHandleInterrupts(true),
109       avoidQuiesceLiveLock(false)
110 {
111     if (commitWidth > Impl::MaxWidth)
112         fatal("commitWidth (%d) is larger than compiled limit (%d),\n"
113              "\tincrease MaxWidth in src/cpu/o3/impl.hh\n",
114              commitWidth, static_cast<int>(Impl::MaxWidth));
115 
116     _status = Active;
117     _nextStatus = Inactive;
118     std::string policy = params->smtCommitPolicy;
119 
120     //Convert string to lowercase
121     std::transform(policy.begin(), policy.end(), policy.begin(),
122                    (int(*)(int)) tolower);
123 
124     //Assign commit policy
125     if (policy == "aggressive"){
126         commitPolicy = Aggressive;
127 
128         DPRINTF(Commit,"Commit Policy set to Aggressive.\n");
129     } else if (policy == "roundrobin"){
130         commitPolicy = RoundRobin;
131 
132         //Set-Up Priority List
133         for (ThreadID tid = 0; tid < numThreads; tid++) {
134             priority_list.push_back(tid);
135         }
136 
137         DPRINTF(Commit,"Commit Policy set to Round Robin.\n");
138     } else if (policy == "oldestready"){
139         commitPolicy = OldestReady;
140 
141         DPRINTF(Commit,"Commit Policy set to Oldest Ready.");
142     } else {
143         assert(0 && "Invalid SMT Commit Policy. Options Are: {Aggressive,"
144                "RoundRobin,OldestReady}");
145     }
146 
147     for (ThreadID tid = 0; tid < numThreads; tid++) {
148         commitStatus[tid] = Idle;
149         changedROBNumEntries[tid] = false;
150         checkEmptyROB[tid] = false;
151         trapInFlight[tid] = false;
152         committedStores[tid] = false;
153         trapSquash[tid] = false;
154         tcSquash[tid] = false;
155         pc[tid].set(0);
156         lastCommitedSeqNum[tid] = 0;
157         squashAfterInst[tid] = NULL;
158     }
159     interrupt = NoFault;
160 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classDefaultCommit_ac5a2190cdc184d1396bee3a6d99e34e7}{
\index{DefaultCommit@{DefaultCommit}!changedROBEntries@{changedROBEntries}}
\index{changedROBEntries@{changedROBEntries}!DefaultCommit@{DefaultCommit}}
\subsubsection[{changedROBEntries}]{\setlength{\rightskip}{0pt plus 5cm}bool changedROBEntries ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_ac5a2190cdc184d1396bee3a6d99e34e7}
Returns if any of the threads have the number of \hyperlink{classROB}{ROB} entries changed on this cycle. Used to determine if the number of free \hyperlink{classROB}{ROB} entries needs to be sent back to previous stages. 


\begin{DoxyCode}
524 {
525     list<ThreadID>::iterator threads = activeThreads->begin();
526     list<ThreadID>::iterator end = activeThreads->end();
527 
528     while (threads != end) {
529         ThreadID tid = *threads++;
530 
531         if (changedROBNumEntries[tid]) {
532             return true;
533         }
534     }
535 
536     return false;
537 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_ad55316f5135cdae6aa6c5a763f6c3473}{
\index{DefaultCommit@{DefaultCommit}!commit@{commit}}
\index{commit@{commit}!DefaultCommit@{DefaultCommit}}
\subsubsection[{commit}]{\setlength{\rightskip}{0pt plus 5cm}void commit ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_ad55316f5135cdae6aa6c5a763f6c3473}
Handles any squashes that are sent from IEW, and adds instructions to the \hyperlink{classROB}{ROB} and tries to commit instructions. 


\begin{DoxyCode}
828 {
829     if (FullSystem) {
830         // Check if we have a interrupt and get read to handle it
831         if (cpu->checkInterrupts(cpu->tcBase(0)))
832             propagateInterrupt();
833     }
834 
836     // Check for any possible squashes, handle them first
838     list<ThreadID>::iterator threads = activeThreads->begin();
839     list<ThreadID>::iterator end = activeThreads->end();
840 
841     while (threads != end) {
842         ThreadID tid = *threads++;
843 
844         // Not sure which one takes priority.  I think if we have
845         // both, that's a bad sign.
846         if (trapSquash[tid]) {
847             assert(!tcSquash[tid]);
848             squashFromTrap(tid);
849         } else if (tcSquash[tid]) {
850             assert(commitStatus[tid] != TrapPending);
851             squashFromTC(tid);
852         } else if (commitStatus[tid] == SquashAfterPending) {
853             // A squash from the previous cycle of the commit stage (i.e.,
854             // commitInsts() called squashAfter) is pending. Squash the
855             // thread now.
856             squashFromSquashAfter(tid);
857         }
858 
859         // Squashed sequence number must be older than youngest valid
860         // instruction in the ROB. This prevents squashes from younger
861         // instructions overriding squashes from older instructions.
862         if (fromIEW->squash[tid] &&
863             commitStatus[tid] != TrapPending &&
864             fromIEW->squashedSeqNum[tid] <= youngestSeqNum[tid]) {
865 
866             if (fromIEW->mispredictInst[tid]) {
867                 DPRINTF(Commit,
868                     "[tid:%i]: Squashing due to branch mispred PC:%#x [sn:%i]\n",
      
869                     tid,
870                     fromIEW->mispredictInst[tid]->instAddr(),
871                     fromIEW->squashedSeqNum[tid]);
872             } else {
873                 DPRINTF(Commit,
874                     "[tid:%i]: Squashing due to order violation [sn:%i]\n",
875                     tid, fromIEW->squashedSeqNum[tid]);
876             }
877 
878             DPRINTF(Commit, "[tid:%i]: Redirecting to PC %#x\n",
879                     tid,
880                     fromIEW->pc[tid].nextInstAddr());
881 
882             commitStatus[tid] = ROBSquashing;
883 
884             // If we want to include the squashing instruction in the squash,
885             // then use one older sequence number.
886             InstSeqNum squashed_inst = fromIEW->squashedSeqNum[tid];
887 
888             if (fromIEW->includeSquashInst[tid]) {
889                 squashed_inst--;
890             }
891 
892             // All younger instructions will be squashed. Set the sequence
893             // number as the youngest instruction in the ROB.
894             youngestSeqNum[tid] = squashed_inst;
895 
896             rob->squash(squashed_inst, tid);
897             changedROBNumEntries[tid] = true;
898 
899             toIEW->commitInfo[tid].doneSeqNum = squashed_inst;
900 
901             toIEW->commitInfo[tid].squash = true;
902 
903             // Send back the rob squashing signal so other stages know that
904             // the ROB is in the process of squashing.
905             toIEW->commitInfo[tid].robSquashing = true;
906 
907             toIEW->commitInfo[tid].mispredictInst =
908                 fromIEW->mispredictInst[tid];
909             toIEW->commitInfo[tid].branchTaken =
910                 fromIEW->branchTaken[tid];
911             toIEW->commitInfo[tid].squashInst =
912                                     rob->findInst(tid, squashed_inst);
913             if (toIEW->commitInfo[tid].mispredictInst) {
914                 if (toIEW->commitInfo[tid].mispredictInst->isUncondCtrl()) {
915                      toIEW->commitInfo[tid].branchTaken = true;
916                 }
917             }
918 
919             toIEW->commitInfo[tid].pc = fromIEW->pc[tid];
920 
921             if (toIEW->commitInfo[tid].mispredictInst) {
922                 ++branchMispredicts;
923             }
924         }
925 
926     }
927 
928     setNextStatus();
929 
930     if (squashCounter != numThreads) {
931         // If we're not currently squashing, then get instructions.
932         getInsts();
933 
934         // Try to commit any instructions.
935         commitInsts();
936     }
937 
938     //Check for any activity
939     threads = activeThreads->begin();
940 
941     while (threads != end) {
942         ThreadID tid = *threads++;
943 
944         if (changedROBNumEntries[tid]) {
945             toIEW->commitInfo[tid].usedROB = true;
946             toIEW->commitInfo[tid].freeROBEntries = rob->numFreeEntries(tid);
947 
948             wroteToTimeBuffer = true;
949             changedROBNumEntries[tid] = false;
950             if (rob->isEmpty(tid))
951                 checkEmptyROB[tid] = true;
952         }
953 
954         // ROB is only considered "empty" for previous stages if: a)
955         // ROB is empty, b) there are no outstanding stores, c) IEW
956         // stage has received any information regarding stores that
957         // committed.
958         // c) is checked by making sure to not consider the ROB empty
959         // on the same cycle as when stores have been committed.
960         // @todo: Make this handle multi-cycle communication between
961         // commit and IEW.
962         if (checkEmptyROB[tid] && rob->isEmpty(tid) &&
963             !iewStage->hasStoresToWB(tid) && !committedStores[tid]) {
964             checkEmptyROB[tid] = false;
965             toIEW->commitInfo[tid].usedROB = true;
966             toIEW->commitInfo[tid].emptyROB = true;
967             toIEW->commitInfo[tid].freeROBEntries = rob->numFreeEntries(tid);
968             wroteToTimeBuffer = true;
969         }
970 
971     }
972 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a5beb5c9ae170034a8abe7a578e04e47a}{
\index{DefaultCommit@{DefaultCommit}!commitHead@{commitHead}}
\index{commitHead@{commitHead}!DefaultCommit@{DefaultCommit}}
\subsubsection[{commitHead}]{\setlength{\rightskip}{0pt plus 5cm}bool commitHead ({\bf DynInstPtr} \& {\em head\_\-inst}, \/  unsigned {\em inst\_\-num})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_a5beb5c9ae170034a8abe7a578e04e47a}
Tries to commit the head \hyperlink{classROB}{ROB} instruction passed in. 
\begin{DoxyParams}{引数}
\item[{\em head\_\-inst}]The instruction to be committed. \end{DoxyParams}



\begin{DoxyCode}
1133 {
1134     assert(head_inst);
1135 
1136     ThreadID tid = head_inst->threadNumber;
1137 
1138     // If the instruction is not executed yet, then it will need extra
1139     // handling.  Signal backwards that it should be executed.
1140     if (!head_inst->isExecuted()) {
1141         // Keep this number correct.  We have not yet actually executed
1142         // and committed this instruction.
1143         thread[tid]->funcExeInst--;
1144 
1145         // Make sure we are only trying to commit un-executed instructions we
1146         // think are possible.
1147         assert(head_inst->isNonSpeculative() || head_inst->isStoreConditional()
1148                || head_inst->isMemBarrier() || head_inst->isWriteBarrier() ||
1149                (head_inst->isLoad() && head_inst->uncacheable()));
1150 
1151         DPRINTF(Commit, "Encountered a barrier or non-speculative "
1152                 "instruction [sn:%lli] at the head of the ROB, PC %s.\n",
1153                 head_inst->seqNum, head_inst->pcState());
1154 
1155         if (inst_num > 0 || iewStage->hasStoresToWB(tid)) {
1156             DPRINTF(Commit, "Waiting for all stores to writeback.\n");
1157             return false;
1158         }
1159 
1160         toIEW->commitInfo[tid].nonSpecSeqNum = head_inst->seqNum;
1161 
1162         // Change the instruction so it won't try to commit again until
1163         // it is executed.
1164         head_inst->clearCanCommit();
1165 
1166         if (head_inst->isLoad() && head_inst->uncacheable()) {
1167             DPRINTF(Commit, "[sn:%lli]: Uncached load, PC %s.\n",
1168                     head_inst->seqNum, head_inst->pcState());
1169             toIEW->commitInfo[tid].uncached = true;
1170             toIEW->commitInfo[tid].uncachedLoad = head_inst;
1171         } else {
1172             ++commitNonSpecStalls;
1173         }
1174 
1175         return false;
1176     }
1177 
1178     if (head_inst->isThreadSync()) {
1179         // Not handled for now.
1180         panic("Thread sync instructions are not handled yet.\n");
1181     }
1182 
1183     // Check if the instruction caused a fault.  If so, trap.
1184     Fault inst_fault = head_inst->getFault();
1185 
1186     // Stores mark themselves as completed.
1187     if (!head_inst->isStore() && inst_fault == NoFault) {
1188         head_inst->setCompleted();
1189     }
1190 
1191     if (inst_fault != NoFault) {
1192         DPRINTF(Commit, "Inst [sn:%lli] PC %s has a fault\n",
1193                 head_inst->seqNum, head_inst->pcState());
1194 
1195         if (iewStage->hasStoresToWB(tid) || inst_num > 0) {
1196             DPRINTF(Commit, "Stores outstanding, fault must wait.\n");
1197             return false;
1198         }
1199 
1200         head_inst->setCompleted();
1201 
1202         // If instruction has faulted, let the checker execute it and
1203         // check if it sees the same fault and control flow.
1204         if (cpu->checker) {
1205             // Need to check the instruction before its fault is processed
1206             cpu->checker->verify(head_inst);
1207         }
1208 
1209         assert(!thread[tid]->noSquashFromTC);
1210 
1211         // Mark that we're in state update mode so that the trap's
1212         // execution doesn't generate extra squashes.
1213         thread[tid]->noSquashFromTC = true;
1214 
1215         // Execute the trap.  Although it's slightly unrealistic in
1216         // terms of timing (as it doesn't wait for the full timing of
1217         // the trap event to complete before updating state), it's
1218         // needed to update the state as soon as possible.  This
1219         // prevents external agents from changing any specific state
1220         // that the trap need.
1221         cpu->trap(inst_fault, tid, head_inst->staticInst);
1222 
1223         // Exit state update mode to avoid accidental updating.
1224         thread[tid]->noSquashFromTC = false;
1225 
1226         commitStatus[tid] = TrapPending;
1227 
1228         DPRINTF(Commit, "Committing instruction with fault [sn:%lli]\n",
1229             head_inst->seqNum);
1230         if (head_inst->traceData) {
1231             if (DTRACE(ExecFaulting)) {
1232                 head_inst->traceData->setFetchSeq(head_inst->seqNum);
1233                 head_inst->traceData->setCPSeq(thread[tid]->numOp);
1234                 head_inst->traceData->dump();
1235             }
1236             delete head_inst->traceData;
1237             head_inst->traceData = NULL;
1238         }
1239 
1240         // Generate trap squash event.
1241         generateTrapEvent(tid);
1242         return false;
1243     }
1244 
1245     updateComInstStats(head_inst);
1246 
1247     if (FullSystem) {
1248         if (thread[tid]->profile) {
1249             thread[tid]->profilePC = head_inst->instAddr();
1250             ProfileNode *node = thread[tid]->profile->consume(
1251                     thread[tid]->getTC(), head_inst->staticInst);
1252 
1253             if (node)
1254                 thread[tid]->profileNode = node;
1255         }
1256         if (CPA::available()) {
1257             if (head_inst->isControl()) {
1258                 ThreadContext *tc = thread[tid]->getTC();
1259                 CPA::cpa()->swAutoBegin(tc, head_inst->nextInstAddr());
1260             }
1261         }
1262     }
1263     DPRINTF(Commit, "Committing instruction with [sn:%lli] PC %s\n",
1264             head_inst->seqNum, head_inst->pcState());
1265     if (head_inst->traceData) {
1266         head_inst->traceData->setFetchSeq(head_inst->seqNum);
1267         head_inst->traceData->setCPSeq(thread[tid]->numOp);
1268         head_inst->traceData->dump();
1269         delete head_inst->traceData;
1270         head_inst->traceData = NULL;
1271     }
1272     if (head_inst->isReturn()) {
1273         DPRINTF(Commit,"Return Instruction Committed [sn:%lli] PC %s \n",
1274                         head_inst->seqNum, head_inst->pcState());
1275     }
1276 
1277     // Update the commit rename map
1278     for (int i = 0; i < head_inst->numDestRegs(); i++) {
1279         renameMap[tid]->setEntry(head_inst->flattenedDestRegIdx(i),
1280                                  head_inst->renamedDestRegIdx(i));
1281     }
1282 
1283     // Finally clear the head ROB entry.
1284     rob->retireHead(tid);
1285 
1286 #if TRACING_ON
1287     if (DTRACE(O3PipeView)) {
1288         head_inst->commitTick = curTick() - head_inst->fetchTick;
1289     }
1290 #endif
1291 
1292     // If this was a store, record it for this cycle.
1293     if (head_inst->isStore())
1294         committedStores[tid] = true;
1295 
1296     // Return true to indicate that we have committed an instruction.
1297     return true;
1298 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_ac8b85fbfdf330d000c094a9d1886d264}{
\index{DefaultCommit@{DefaultCommit}!commitInsts@{commitInsts}}
\index{commitInsts@{commitInsts}!DefaultCommit@{DefaultCommit}}
\subsubsection[{commitInsts}]{\setlength{\rightskip}{0pt plus 5cm}void commitInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_ac8b85fbfdf330d000c094a9d1886d264}
Commits as many instructions as possible. 


\begin{DoxyCode}
977 {
979     // Handle commit
980     // Note that commit will be handled prior to putting new
981     // instructions in the ROB so that the ROB only tries to commit
982     // instructions it has in this current cycle, and not instructions
983     // it is writing in during this cycle.  Can't commit and squash
984     // things at the same time...
986 
987     DPRINTF(Commit, "Trying to commit instructions in the ROB.\n");
988 
989     unsigned num_committed = 0;
990 
991     DynInstPtr head_inst;
992 
993     // Commit as many instructions as possible until the commit bandwidth
994     // limit is reached, or it becomes impossible to commit any more.
995     while (num_committed < commitWidth) {
996         // Check for any interrupt that we've already squashed for
997         // and start processing it.
998         if (interrupt != NoFault)
999             handleInterrupt();
1000 
1001         int commit_thread = getCommittingThread();
1002 
1003         if (commit_thread == -1 || !rob->isHeadReady(commit_thread))
1004             break;
1005 
1006         head_inst = rob->readHeadInst(commit_thread);
1007 
1008         ThreadID tid = head_inst->threadNumber;
1009 
1010         assert(tid == commit_thread);
1011 
1012         DPRINTF(Commit, "Trying to commit head instruction, [sn:%i] [tid:%i]\n",
1013                 head_inst->seqNum, tid);
1014 
1015         // If the head instruction is squashed, it is ready to retire
1016         // (be removed from the ROB) at any time.
1017         if (head_inst->isSquashed()) {
1018 
1019             DPRINTF(Commit, "Retiring squashed instruction from "
1020                     "ROB.\n");
1021 
1022             rob->retireHead(commit_thread);
1023 
1024             ++commitSquashedInsts;
1025 
1026             // Record that the number of ROB entries has changed.
1027             changedROBNumEntries[tid] = true;
1028         } else {
1029             pc[tid] = head_inst->pcState();
1030 
1031             // Increment the total number of non-speculative instructions
1032             // executed.
1033             // Hack for now: it really shouldn't happen until after the
1034             // commit is deemed to be successful, but this count is needed
1035             // for syscalls.
1036             thread[tid]->funcExeInst++;
1037 
1038             // Try to commit the head instruction.
1039             bool commit_success = commitHead(head_inst, num_committed);
1040 
1041             if (commit_success) {
1042                 ++num_committed;
1043                 statCommittedInstType[tid][head_inst->opClass()]++;
1044                 ppCommit->notify(head_inst);
1045 
1046                 changedROBNumEntries[tid] = true;
1047 
1048                 // Set the doneSeqNum to the youngest committed instruction.
1049                 toIEW->commitInfo[tid].doneSeqNum = head_inst->seqNum;
1050 
1051                 if (tid == 0) {
1052                     canHandleInterrupts =  (!head_inst->isDelayedCommit()) &&
1053                                            ((THE_ISA != ALPHA_ISA) ||
1054                                              (!(pc[0].instAddr() & 0x3)));
1055                 }
1056 
1057                 // Updates misc. registers.
1058                 head_inst->updateMiscRegs();
1059 
1060                 // Check instruction execution if it successfully commits and
1061                 // is not carrying a fault.
1062                 if (cpu->checker) {
1063                     cpu->checker->verify(head_inst);
1064                 }
1065 
1066                 cpu->traceFunctions(pc[tid].instAddr());
1067 
1068                 TheISA::advancePC(pc[tid], head_inst->staticInst);
1069 
1070                 // Keep track of the last sequence number commited
1071                 lastCommitedSeqNum[tid] = head_inst->seqNum;
1072 
1073                 // If this is an instruction that doesn't play nicely with
1074                 // others squash everything and restart fetch
1075                 if (head_inst->isSquashAfter())
1076                     squashAfter(tid, head_inst);
1077 
1078                 if (drainPending) {
1079                     DPRINTF(Drain, "Draining: %i:%s\n", tid, pc[tid]);
1080                     if (pc[tid].microPC() == 0 && interrupt == NoFault) {
1081                         squashAfter(tid, head_inst);
1082                         cpu->commitDrained(tid);
1083                     }
1084                 }
1085 
1086                 int count = 0;
1087                 Addr oldpc;
1088                 // Debug statement.  Checks to make sure we're not
1089                 // currently updating state while handling PC events.
1090                 assert(!thread[tid]->noSquashFromTC && !thread[tid]->trapPending)
      ;
1091                 do {
1092                     oldpc = pc[tid].instAddr();
1093                     cpu->system->pcEventQueue.service(thread[tid]->getTC());
1094                     count++;
1095                 } while (oldpc != pc[tid].instAddr());
1096                 if (count > 1) {
1097                     DPRINTF(Commit,
1098                             "PC skip function event, stopping commit\n");
1099                     break;
1100                 }
1101 
1102                 // Check if an instruction just enabled interrupts and we've
1103                 // previously had an interrupt pending that was not handled
1104                 // because interrupts were subsequently disabled before the
1105                 // pipeline reached a place to handle the interrupt. In that
1106                 // case squash now to make sure the interrupt is handled.
1107                 //
1108                 // If we don't do this, we might end up in a live lock situation
1109                 if (!interrupt  && avoidQuiesceLiveLock &&
1110                    (!head_inst->isMicroop() || head_inst->isLastMicroop()) &&
1111                    cpu->checkInterrupts(cpu->tcBase(0)))
1112                     squashAfter(tid, head_inst);
1113             } else {
1114                 DPRINTF(Commit, "Unable to commit head instruction PC:%s "
1115                         "[tid:%i] [sn:%i].\n",
1116                         head_inst->pcState(), tid ,head_inst->seqNum);
1117                 break;
1118             }
1119         }
1120     }
1121 
1122     DPRINTF(CommitRate, "%i\n", num_committed);
1123     numCommittedDist.sample(num_committed);
1124 
1125     if (num_committed == commitWidth) {
1126         commitEligibleSamples++;
1127     }
1128 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_af7d01b5776b9d8a0f218aec331ddaeb9}{
\index{DefaultCommit@{DefaultCommit}!drain@{drain}}
\index{drain@{drain}!DefaultCommit@{DefaultCommit}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}void drain ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_af7d01b5776b9d8a0f218aec331ddaeb9}
Initializes the draining of commit. 


\begin{DoxyCode}
400 {
401     drainPending = true;
402 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a8f020d3237536fe007fc488c4125c5d8}{
\index{DefaultCommit@{DefaultCommit}!drainResume@{drainResume}}
\index{drainResume@{drainResume}!DefaultCommit@{DefaultCommit}}
\subsubsection[{drainResume}]{\setlength{\rightskip}{0pt plus 5cm}void drainResume ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_a8f020d3237536fe007fc488c4125c5d8}
Resumes execution after draining. 


\begin{DoxyCode}
407 {
408     drainPending = false;
409 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a0240eb42fa57fe5d3788093f62b77347}{
\index{DefaultCommit@{DefaultCommit}!drainSanityCheck@{drainSanityCheck}}
\index{drainSanityCheck@{drainSanityCheck}!DefaultCommit@{DefaultCommit}}
\subsubsection[{drainSanityCheck}]{\setlength{\rightskip}{0pt plus 5cm}void drainSanityCheck () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_a0240eb42fa57fe5d3788093f62b77347}
Perform sanity checks after a drain. 


\begin{DoxyCode}
414 {
415     assert(isDrained());
416     rob->drainSanityCheck();
417 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a4adb99d6e22b7028a21e537331de6253}{
\index{DefaultCommit@{DefaultCommit}!generateTCEvent@{generateTCEvent}}
\index{generateTCEvent@{generateTCEvent}!DefaultCommit@{DefaultCommit}}
\subsubsection[{generateTCEvent}]{\setlength{\rightskip}{0pt plus 5cm}void generateTCEvent ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_a4adb99d6e22b7028a21e537331de6253}
Records that commit needs to initiate a squash due to an external state update through the TC. 


\begin{DoxyCode}
562 {
563     assert(!trapInFlight[tid]);
564     DPRINTF(Commit, "Generating TC squash event for [tid:%i]\n", tid);
565 
566     tcSquash[tid] = true;
567 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a7002d0f2beae1ce9a349218968ff97c3}{
\index{DefaultCommit@{DefaultCommit}!generateTrapEvent@{generateTrapEvent}}
\index{generateTrapEvent@{generateTrapEvent}!DefaultCommit@{DefaultCommit}}
\subsubsection[{generateTrapEvent}]{\setlength{\rightskip}{0pt plus 5cm}void generateTrapEvent ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_a7002d0f2beae1ce9a349218968ff97c3}
Generates an event to schedule a squash due to a trap. 


\begin{DoxyCode}
549 {
550     DPRINTF(Commit, "Generating trap event for [tid:%i]\n", tid);
551 
552     TrapEvent *trap = new TrapEvent(this, tid);
553 
554     cpu->schedule(trap, cpu->clockEdge(trapLatency));
555     trapInFlight[tid] = true;
556     thread[tid]->trapPending = true;
557 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_ad313fd14604cfa26fec9c62dba3a7062}{
\index{DefaultCommit@{DefaultCommit}!getCommittingThread@{getCommittingThread}}
\index{getCommittingThread@{getCommittingThread}!DefaultCommit@{DefaultCommit}}
\subsubsection[{getCommittingThread}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} getCommittingThread ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_ad313fd14604cfa26fec9c62dba3a7062}
Gets the thread to commit, based on the SMT policy. 


\begin{DoxyCode}
1458 {
1459     if (numThreads > 1) {
1460         switch (commitPolicy) {
1461 
1462           case Aggressive:
1463             //If Policy is Aggressive, commit will call
1464             //this function multiple times per
1465             //cycle
1466             return oldestReady();
1467 
1468           case RoundRobin:
1469             return roundRobin();
1470 
1471           case OldestReady:
1472             return oldestReady();
1473 
1474           default:
1475             return InvalidThreadID;
1476         }
1477     } else {
1478         assert(!activeThreads->empty());
1479         ThreadID tid = activeThreads->front();
1480 
1481         if (commitStatus[tid] == Running ||
1482             commitStatus[tid] == Idle ||
1483             commitStatus[tid] == FetchTrapPending) {
1484             return tid;
1485         } else {
1486             return InvalidThreadID;
1487         }
1488     }
1489 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a8d0c39182cb7719942e865bcaaff769b}{
\index{DefaultCommit@{DefaultCommit}!getInsts@{getInsts}}
\index{getInsts@{getInsts}!DefaultCommit@{DefaultCommit}}
\subsubsection[{getInsts}]{\setlength{\rightskip}{0pt plus 5cm}void getInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_a8d0c39182cb7719942e865bcaaff769b}
Gets instructions from rename and inserts them into the \hyperlink{classROB}{ROB}. 


\begin{DoxyCode}
1303 {
1304     DPRINTF(Commit, "Getting instructions from Rename stage.\n");
1305 
1306     // Read any renamed instructions and place them into the ROB.
1307     int insts_to_process = std::min((int)renameWidth, fromRename->size);
1308 
1309     for (int inst_num = 0; inst_num < insts_to_process; ++inst_num) {
1310         DynInstPtr inst;
1311 
1312         inst = fromRename->insts[inst_num];
1313         ThreadID tid = inst->threadNumber;
1314 
1315         if (!inst->isSquashed() &&
1316             commitStatus[tid] != ROBSquashing &&
1317             commitStatus[tid] != TrapPending) {
1318             changedROBNumEntries[tid] = true;
1319 
1320             DPRINTF(Commit, "Inserting PC %s [sn:%i] [tid:%i] into ROB.\n",
1321                     inst->pcState(), inst->seqNum, tid);
1322 
1323             rob->insertInst(inst);
1324 
1325             assert(rob->getThreadEntries(tid) <= rob->getMaxEntries(tid));
1326 
1327             youngestSeqNum[tid] = inst->seqNum;
1328         } else {
1329             DPRINTF(Commit, "Instruction PC %s [sn:%i] [tid:%i] was "
1330                     "squashed, skipping.\n",
1331                     inst->pcState(), inst->seqNum, tid);
1332         }
1333     }
1334 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a1cb72a248a56b5dc2b2ed27db7560b90}{
\index{DefaultCommit@{DefaultCommit}!handleInterrupt@{handleInterrupt}}
\index{handleInterrupt@{handleInterrupt}!DefaultCommit@{DefaultCommit}}
\subsubsection[{handleInterrupt}]{\setlength{\rightskip}{0pt plus 5cm}void handleInterrupt ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_a1cb72a248a56b5dc2b2ed27db7560b90}
Handles processing an interrupt. 


\begin{DoxyCode}
752 {
753     // Verify that we still have an interrupt to handle
754     if (!cpu->checkInterrupts(cpu->tcBase(0))) {
755         DPRINTF(Commit, "Pending interrupt is cleared by master before "
756                 "it got handled. Restart fetching from the orig path.\n");
757         toIEW->commitInfo[0].clearInterrupt = true;
758         interrupt = NoFault;
759         avoidQuiesceLiveLock = true;
760         return;
761     }
762 
763     // Wait until all in flight instructions are finished before enterring
764     // the interrupt.
765     if (canHandleInterrupts && cpu->instList.empty()) {
766         // Squash or record that I need to squash this cycle if
767         // an interrupt needed to be handled.
768         DPRINTF(Commit, "Interrupt detected.\n");
769 
770         // Clear the interrupt now that it's going to be handled
771         toIEW->commitInfo[0].clearInterrupt = true;
772 
773         assert(!thread[0]->noSquashFromTC);
774         thread[0]->noSquashFromTC = true;
775 
776         if (cpu->checker) {
777             cpu->checker->handlePendingInt();
778         }
779 
780         // CPU will handle interrupt. Note that we ignore the local copy of
781         // interrupt. This is because the local copy may no longer be the
782         // interrupt that the interrupt controller thinks is being handled.
783         cpu->processInterrupts(cpu->getInterrupts());
784 
785         thread[0]->noSquashFromTC = false;
786 
787         commitStatus[0] = TrapPending;
788 
789         // Generate trap squash event.
790         generateTrapEvent(0);
791 
792         interrupt = NoFault;
793         avoidQuiesceLiveLock = false;
794     } else {
795         DPRINTF(Commit, "Interrupt pending: instruction is %sin "
796                 "flight, ROB is %sempty\n",
797                 canHandleInterrupts ? "not " : "",
798                 cpu->instList.empty() ? "" : "not " );
799     }
800 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_afae6152cf4b3a51162d6e64247c1ac09}{
\index{DefaultCommit@{DefaultCommit}!instAddr@{instAddr}}
\index{instAddr@{instAddr}!DefaultCommit@{DefaultCommit}}
\subsubsection[{instAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} instAddr ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_afae6152cf4b3a51162d6e64247c1ac09}
Returns the PC of a specific thread. 


\begin{DoxyCode}
348 { return pc[tid].instAddr(); }
\end{DoxyCode}
\hypertarget{classDefaultCommit_adf5473c18a3d7c1e88c4a2072bce5526}{
\index{DefaultCommit@{DefaultCommit}!isDrained@{isDrained}}
\index{isDrained@{isDrained}!DefaultCommit@{DefaultCommit}}
\subsubsection[{isDrained}]{\setlength{\rightskip}{0pt plus 5cm}bool isDrained () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_adf5473c18a3d7c1e88c4a2072bce5526}
Has the stage drained? 


\begin{DoxyCode}
422 {
423     /* Make sure no one is executing microcode. There are two reasons
424      * for this:
425      * - Hardware virtualized CPUs can't switch into the middle of a
426      *   microcode sequence.
427      * - The current fetch implementation will most likely get very
428      *   confused if it tries to start fetching an instruction that
429      *   is executing in the middle of a ucode sequence that changes
430      *   address mappings. This can happen on for example x86.
431      */
432     for (ThreadID tid = 0; tid < numThreads; tid++) {
433         if (pc[tid].microPC() != 0)
434             return false;
435     }
436 
437     /* Make sure that all instructions have finished committing before
438      * declaring the system as drained. We want the pipeline to be
439      * completely empty when we declare the CPU to be drained. This
440      * makes debugging easier since CPU handover and restoring from a
441      * checkpoint with a different CPU should have the same timing.
442      */
443     return rob->isEmpty() &&
444         interrupt == NoFault;
445 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a035349a9fd8a12938e7997be5a76211e}{
\index{DefaultCommit@{DefaultCommit}!markCompletedInsts@{markCompletedInsts}}
\index{markCompletedInsts@{markCompletedInsts}!DefaultCommit@{DefaultCommit}}
\subsubsection[{markCompletedInsts}]{\setlength{\rightskip}{0pt plus 5cm}void markCompletedInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_a035349a9fd8a12938e7997be5a76211e}
Marks completed instructions using information sent from IEW. 


\begin{DoxyCode}
1362 {
1363     // Grab completed insts out of the IEW instruction queue, and mark
1364     // instructions completed within the ROB.
1365     for (int inst_num = 0;
1366          inst_num < fromIEW->size && fromIEW->insts[inst_num];
1367          ++inst_num)
1368     {
1369         if (!fromIEW->insts[inst_num]->isSquashed()) {
1370             DPRINTF(Commit, "[tid:%i]: Marking PC %s, [sn:%lli] ready "
1371                     "within ROB.\n",
1372                     fromIEW->insts[inst_num]->threadNumber,
1373                     fromIEW->insts[inst_num]->pcState(),
1374                     fromIEW->insts[inst_num]->seqNum);
1375 
1376             // Mark the instruction as ready to commit.
1377             fromIEW->insts[inst_num]->setCanCommit();
1378         }
1379     }
1380 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a697667536e687bd20e95084adc90d820}{
\index{DefaultCommit@{DefaultCommit}!microPC@{microPC}}
\index{microPC@{microPC}!DefaultCommit@{DefaultCommit}}
\subsubsection[{microPC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} microPC ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_a697667536e687bd20e95084adc90d820}
Reads the micro PC of a specific thread. 


\begin{DoxyCode}
354 { return pc[tid].microPC(); }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{DefaultCommit@{DefaultCommit}!name@{name}}
\index{name@{name}!DefaultCommit@{DefaultCommit}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_a37627d5d5bba7f4a8690c71c2ab3cb07}
Returns the name of the \hyperlink{classDefaultCommit}{DefaultCommit}. 


\begin{DoxyCode}
165 {
166     return cpu->name() + ".commit";
167 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_af1caba1f04cf2802d742d1a16b961e79}{
\index{DefaultCommit@{DefaultCommit}!nextInstAddr@{nextInstAddr}}
\index{nextInstAddr@{nextInstAddr}!DefaultCommit@{DefaultCommit}}
\subsubsection[{nextInstAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} nextInstAddr ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_af1caba1f04cf2802d742d1a16b961e79}
Returns the next PC of a specific thread. 


\begin{DoxyCode}
351 { return pc[tid].nextInstAddr(); }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a3c8eae00d4f0d15336eec11f879146c2}{
\index{DefaultCommit@{DefaultCommit}!numROBFreeEntries@{numROBFreeEntries}}
\index{numROBFreeEntries@{numROBFreeEntries}!DefaultCommit@{DefaultCommit}}
\subsubsection[{numROBFreeEntries}]{\setlength{\rightskip}{0pt plus 5cm}size\_\-t numROBFreeEntries ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_a3c8eae00d4f0d15336eec11f879146c2}
Returns the number of free \hyperlink{classROB}{ROB} entries for a specific thread. 


\begin{DoxyCode}
542 {
543     return rob->numFreeEntries(tid);
544 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a7b2c5e474b4fd5c54395b44f3b792d21}{
\index{DefaultCommit@{DefaultCommit}!oldestReady@{oldestReady}}
\index{oldestReady@{oldestReady}!DefaultCommit@{DefaultCommit}}
\subsubsection[{oldestReady}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} oldestReady ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_a7b2c5e474b4fd5c54395b44f3b792d21}
Returns the thread ID to use based on an oldest instruction policy. 


\begin{DoxyCode}
1522 {
1523     unsigned oldest = 0;
1524     bool first = true;
1525 
1526     list<ThreadID>::iterator threads = activeThreads->begin();
1527     list<ThreadID>::iterator end = activeThreads->end();
1528 
1529     while (threads != end) {
1530         ThreadID tid = *threads++;
1531 
1532         if (!rob->isEmpty(tid) &&
1533             (commitStatus[tid] == Running ||
1534              commitStatus[tid] == Idle ||
1535              commitStatus[tid] == FetchTrapPending)) {
1536 
1537             if (rob->isHeadReady(tid)) {
1538 
1539                 DynInstPtr head_inst = rob->readHeadInst(tid);
1540 
1541                 if (first) {
1542                     oldest = tid;
1543                     first = false;
1544                 } else if (head_inst->seqNum < oldest) {
1545                     oldest = tid;
1546                 }
1547             }
1548         }
1549     }
1550 
1551     if (!first) {
1552         return oldest;
1553     } else {
1554         return InvalidThreadID;
1555     }
1556 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_aaa8fbb79b13ce112b6d11f77bc3dd18f}{
\index{DefaultCommit@{DefaultCommit}!pcState@{pcState}}
\index{pcState@{pcState}!DefaultCommit@{DefaultCommit}}
\subsubsection[{pcState}]{\setlength{\rightskip}{0pt plus 5cm}void pcState (const TheISA::PCState \& {\em val}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_aaa8fbb79b13ce112b6d11f77bc3dd18f}
Sets the PC of a specific thread. 


\begin{DoxyCode}
345     { pc[tid] = val; }
\end{DoxyCode}
\hypertarget{classDefaultCommit_af486ac7476906f63fc6696b3e76a411b}{
\index{DefaultCommit@{DefaultCommit}!pcState@{pcState}}
\index{pcState@{pcState}!DefaultCommit@{DefaultCommit}}
\subsubsection[{pcState}]{\setlength{\rightskip}{0pt plus 5cm}TheISA::PCState pcState ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_af486ac7476906f63fc6696b3e76a411b}
Reads the PC of a specific thread. 


\begin{DoxyCode}
341 { return pc[tid]; }
\end{DoxyCode}
\hypertarget{classDefaultCommit_ab9d20a05498697dfc59478b80a0726fb}{
\index{DefaultCommit@{DefaultCommit}!propagateInterrupt@{propagateInterrupt}}
\index{propagateInterrupt@{propagateInterrupt}!DefaultCommit@{DefaultCommit}}
\subsubsection[{propagateInterrupt}]{\setlength{\rightskip}{0pt plus 5cm}void propagateInterrupt ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_ab9d20a05498697dfc59478b80a0726fb}
Get fetch redirecting so we can handle an interrupt 


\begin{DoxyCode}
805 {
806     if (commitStatus[0] == TrapPending || interrupt || trapSquash[0] ||
807             tcSquash[0])
808         return;
809 
810     // Process interrupts if interrupts are enabled, not in PAL
811     // mode, and no other traps or external squashes are currently
812     // pending.
813     // @todo: Allow other threads to handle interrupts.
814 
815     // Get any interrupt that happened
816     interrupt = cpu->getInterrupts();
817 
818     // Tell fetch that there is an interrupt pending.  This
819     // will make fetch wait until it sees a non PAL-mode PC,
820     // at which point it stops fetching instructions.
821     if (interrupt != NoFault)
822         toIEW->commitInfo[0].interruptPending = true;
823 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_aa2dab17a363fd4307274d579796adcf7}{
\index{DefaultCommit@{DefaultCommit}!regProbePoints@{regProbePoints}}
\index{regProbePoints@{regProbePoints}!DefaultCommit@{DefaultCommit}}
\subsubsection[{regProbePoints}]{\setlength{\rightskip}{0pt plus 5cm}void regProbePoints ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_aa2dab17a363fd4307274d579796adcf7}
Registers probes. 


\begin{DoxyCode}
172 {
173     ppCommit = new ProbePointArg<DynInstPtr>(cpu->getProbeManager(), "Commit");
174     ppCommitStall = new ProbePointArg<DynInstPtr>(cpu->getProbeManager(), "Commit
      Stall");
175 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{DefaultCommit@{DefaultCommit}!regStats@{regStats}}
\index{regStats@{regStats}!DefaultCommit@{DefaultCommit}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_a4dc637449366fcdfc4e764cdf12d9b11}
Registers statistics. 


\begin{DoxyCode}
180 {
181     using namespace Stats;
182     commitSquashedInsts
183         .name(name() + ".commitSquashedInsts")
184         .desc("The number of squashed insts skipped by commit")
185         .prereq(commitSquashedInsts);
186     commitSquashEvents
187         .name(name() + ".commitSquashEvents")
188         .desc("The number of times commit is told to squash")
189         .prereq(commitSquashEvents);
190     commitNonSpecStalls
191         .name(name() + ".commitNonSpecStalls")
192         .desc("The number of times commit has been forced to stall to "
193               "communicate backwards")
194         .prereq(commitNonSpecStalls);
195     branchMispredicts
196         .name(name() + ".branchMispredicts")
197         .desc("The number of times a branch was mispredicted")
198         .prereq(branchMispredicts);
199     numCommittedDist
200         .init(0,commitWidth,1)
201         .name(name() + ".committed_per_cycle")
202         .desc("Number of insts commited each cycle")
203         .flags(Stats::pdf)
204         ;
205 
206     instsCommitted
207         .init(cpu->numThreads)
208         .name(name() + ".committedInsts")
209         .desc("Number of instructions committed")
210         .flags(total)
211         ;
212 
213     opsCommitted
214         .init(cpu->numThreads)
215         .name(name() + ".committedOps")
216         .desc("Number of ops (including micro ops) committed")
217         .flags(total)
218         ;
219 
220     statComSwp
221         .init(cpu->numThreads)
222         .name(name() + ".swp_count")
223         .desc("Number of s/w prefetches committed")
224         .flags(total)
225         ;
226 
227     statComRefs
228         .init(cpu->numThreads)
229         .name(name() +  ".refs")
230         .desc("Number of memory references committed")
231         .flags(total)
232         ;
233 
234     statComLoads
235         .init(cpu->numThreads)
236         .name(name() +  ".loads")
237         .desc("Number of loads committed")
238         .flags(total)
239         ;
240 
241     statComMembars
242         .init(cpu->numThreads)
243         .name(name() +  ".membars")
244         .desc("Number of memory barriers committed")
245         .flags(total)
246         ;
247 
248     statComBranches
249         .init(cpu->numThreads)
250         .name(name() + ".branches")
251         .desc("Number of branches committed")
252         .flags(total)
253         ;
254 
255     statComFloating
256         .init(cpu->numThreads)
257         .name(name() + ".fp_insts")
258         .desc("Number of committed floating point instructions.")
259         .flags(total)
260         ;
261 
262     statComInteger
263         .init(cpu->numThreads)
264         .name(name()+".int_insts")
265         .desc("Number of committed integer instructions.")
266         .flags(total)
267         ;
268 
269     statComFunctionCalls
270         .init(cpu->numThreads)
271         .name(name()+".function_calls")
272         .desc("Number of function calls committed.")
273         .flags(total)
274         ;
275 
276     statCommittedInstType
277         .init(numThreads,Enums::Num_OpClass)
278         .name(name() + ".op_class")
279         .desc("Class of committed instruction")
280         .flags(total | pdf | dist)
281         ;
282     statCommittedInstType.ysubnames(Enums::OpClassStrings);
283 
284     commitEligible
285         .init(cpu->numThreads)
286         .name(name() + ".bw_limited")
287         .desc("number of insts not committed due to BW limits")
288         .flags(total)
289         ;
290 
291     commitEligibleSamples
292         .name(name() + ".bw_lim_events")
293         .desc("number cycles where commit BW limit reached")
294         ;
295 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a6949aa47bdaf57471e048da5c5b7c14c}{
\index{DefaultCommit@{DefaultCommit}!robDoneSquashing@{robDoneSquashing}}
\index{robDoneSquashing@{robDoneSquashing}!DefaultCommit@{DefaultCommit}}
\subsubsection[{robDoneSquashing}]{\setlength{\rightskip}{0pt plus 5cm}bool robDoneSquashing ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_a6949aa47bdaf57471e048da5c5b7c14c}
Checks if the \hyperlink{classROB}{ROB} is completed with squashing. This is for the case where the \hyperlink{classROB}{ROB} can take multiple cycles to complete squashing. 


\begin{DoxyCode}
1385 {
1386     list<ThreadID>::iterator threads = activeThreads->begin();
1387     list<ThreadID>::iterator end = activeThreads->end();
1388 
1389     while (threads != end) {
1390         ThreadID tid = *threads++;
1391 
1392         if (!rob->isDoneSquashing(tid))
1393             return false;
1394     }
1395 
1396     return true;
1397 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a8aab9cacbc483081596b13ecd5192eb5}{
\index{DefaultCommit@{DefaultCommit}!roundRobin@{roundRobin}}
\index{roundRobin@{roundRobin}!DefaultCommit@{DefaultCommit}}
\subsubsection[{roundRobin}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} roundRobin ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_a8aab9cacbc483081596b13ecd5192eb5}
Returns the thread ID to use based on a round robin policy. 


\begin{DoxyCode}
1494 {
1495     list<ThreadID>::iterator pri_iter = priority_list.begin();
1496     list<ThreadID>::iterator end      = priority_list.end();
1497 
1498     while (pri_iter != end) {
1499         ThreadID tid = *pri_iter;
1500 
1501         if (commitStatus[tid] == Running ||
1502             commitStatus[tid] == Idle ||
1503             commitStatus[tid] == FetchTrapPending) {
1504 
1505             if (rob->isHeadReady(tid)) {
1506                 priority_list.erase(pri_iter);
1507                 priority_list.push_back(tid);
1508 
1509                 return tid;
1510             }
1511         }
1512 
1513         pri_iter++;
1514     }
1515 
1516     return InvalidThreadID;
1517 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_aab96bdacf8bd420402cbb543f994e054}{
\index{DefaultCommit@{DefaultCommit}!setActiveThreads@{setActiveThreads}}
\index{setActiveThreads@{setActiveThreads}!DefaultCommit@{DefaultCommit}}
\subsubsection[{setActiveThreads}]{\setlength{\rightskip}{0pt plus 5cm}void setActiveThreads ({\bf std::list}$<$ {\bf ThreadID} $>$ $\ast$ {\em at\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_aab96bdacf8bd420402cbb543f994e054}
Sets pointer to list of active threads. 


\begin{DoxyCode}
357 {
358     activeThreads = at_ptr;
359 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_ad1be90519aa7737ddf8e41de079a5ea9}{
\index{DefaultCommit@{DefaultCommit}!setFetchQueue@{setFetchQueue}}
\index{setFetchQueue@{setFetchQueue}!DefaultCommit@{DefaultCommit}}
\subsubsection[{setFetchQueue}]{\setlength{\rightskip}{0pt plus 5cm}void setFetchQueue ({\bf TimeBuffer}$<$ {\bf FetchStruct} $>$ $\ast$ {\em fq\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_ad1be90519aa7737ddf8e41de079a5ea9}



\begin{DoxyCode}
320 {
321     fetchQueue = fq_ptr;
322 
323     // Setup wire to get instructions from rename (for the ROB).
324     fromFetch = fetchQueue->getWire(-fetchToCommitDelay);
325 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a6b8bf7d75423c9bccd93d50470f7f935}{
\index{DefaultCommit@{DefaultCommit}!setIEWQueue@{setIEWQueue}}
\index{setIEWQueue@{setIEWQueue}!DefaultCommit@{DefaultCommit}}
\subsubsection[{setIEWQueue}]{\setlength{\rightskip}{0pt plus 5cm}void setIEWQueue ({\bf TimeBuffer}$<$ {\bf IEWStruct} $>$ $\ast$ {\em iq\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_a6b8bf7d75423c9bccd93d50470f7f935}
Sets the pointer to the queue coming from IEW. 


\begin{DoxyCode}
340 {
341     iewQueue = iq_ptr;
342 
343     // Setup wire to get instructions from IEW.
344     fromIEW = iewQueue->getWire(-iewToCommitDelay);
345 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a4b6d8e4b2cf6249763ed2fc73eb1af47}{
\index{DefaultCommit@{DefaultCommit}!setIEWStage@{setIEWStage}}
\index{setIEWStage@{setIEWStage}!DefaultCommit@{DefaultCommit}}
\subsubsection[{setIEWStage}]{\setlength{\rightskip}{0pt plus 5cm}void setIEWStage ({\bf IEW} $\ast$ {\em iew\_\-stage})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_a4b6d8e4b2cf6249763ed2fc73eb1af47}
Sets the pointer to the IEW stage. 


\begin{DoxyCode}
350 {
351     iewStage = iew_stage;
352 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a4c5106e8a165f2f63807122b80a4e580}{
\index{DefaultCommit@{DefaultCommit}!setNextStatus@{setNextStatus}}
\index{setNextStatus@{setNextStatus}!DefaultCommit@{DefaultCommit}}
\subsubsection[{setNextStatus}]{\setlength{\rightskip}{0pt plus 5cm}void setNextStatus ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_a4c5106e8a165f2f63807122b80a4e580}
Sets the next status based on threads' statuses, which becomes the current status at the end of the cycle. 


\begin{DoxyCode}
498 {
499     int squashes = 0;
500 
501     list<ThreadID>::iterator threads = activeThreads->begin();
502     list<ThreadID>::iterator end = activeThreads->end();
503 
504     while (threads != end) {
505         ThreadID tid = *threads++;
506 
507         if (commitStatus[tid] == ROBSquashing) {
508             squashes++;
509         }
510     }
511 
512     squashCounter = squashes;
513 
514     // If commit is currently squashing, then it will have activity for the
515     // next cycle. Set its next status as active.
516     if (squashCounter) {
517         _nextStatus = Active;
518     }
519 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a6f0aaedb2c39d674ef86c25d0aeb4211}{
\index{DefaultCommit@{DefaultCommit}!setRenameMap@{setRenameMap}}
\index{setRenameMap@{setRenameMap}!DefaultCommit@{DefaultCommit}}
\subsubsection[{setRenameMap}]{\setlength{\rightskip}{0pt plus 5cm}void setRenameMap ({\bf RenameMap} {\em rm\_\-ptr}\mbox{[}Impl::MaxThreads\mbox{]})}}
\label{classDefaultCommit_a6f0aaedb2c39d674ef86c25d0aeb4211}
Sets pointer to the commited state rename map. \hypertarget{classDefaultCommit_a701624f92a819fe4205faede6e614d9f}{
\index{DefaultCommit@{DefaultCommit}!setRenameQueue@{setRenameQueue}}
\index{setRenameQueue@{setRenameQueue}!DefaultCommit@{DefaultCommit}}
\subsubsection[{setRenameQueue}]{\setlength{\rightskip}{0pt plus 5cm}void setRenameQueue ({\bf TimeBuffer}$<$ {\bf RenameStruct} $>$ $\ast$ {\em rq\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_a701624f92a819fe4205faede6e614d9f}
Sets the pointer to the queue coming from rename. 


\begin{DoxyCode}
330 {
331     renameQueue = rq_ptr;
332 
333     // Setup wire to get instructions from rename (for the ROB).
334     fromRename = renameQueue->getWire(-renameToROBDelay);
335 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a46149ea78698ff6515a509c53d814193}{
\index{DefaultCommit@{DefaultCommit}!setROB@{setROB}}
\index{setROB@{setROB}!DefaultCommit@{DefaultCommit}}
\subsubsection[{setROB}]{\setlength{\rightskip}{0pt plus 5cm}void setROB ({\bf ROB} $\ast$ {\em rob\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_a46149ea78698ff6515a509c53d814193}
Sets pointer to the \hyperlink{classROB}{ROB}. 


\begin{DoxyCode}
372 {
373     rob = rob_ptr;
374 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_aa8150d8ab62e6314eb07420a63aedce2}{
\index{DefaultCommit@{DefaultCommit}!setThreads@{setThreads}}
\index{setThreads@{setThreads}!DefaultCommit@{DefaultCommit}}
\subsubsection[{setThreads}]{\setlength{\rightskip}{0pt plus 5cm}void setThreads ({\bf std::vector}$<$ {\bf Thread} $\ast$ $>$ \& {\em threads})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_aa8150d8ab62e6314eb07420a63aedce2}
Sets the list of threads. 


\begin{DoxyCode}
300 {
301     thread = threads;
302 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a2b521ea5f191fff72265f60d4ed5187b}{
\index{DefaultCommit@{DefaultCommit}!setTimeBuffer@{setTimeBuffer}}
\index{setTimeBuffer@{setTimeBuffer}!DefaultCommit@{DefaultCommit}}
\subsubsection[{setTimeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}void setTimeBuffer ({\bf TimeBuffer}$<$ {\bf TimeStruct} $>$ $\ast$ {\em tb\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_a2b521ea5f191fff72265f60d4ed5187b}
Sets the main time buffer pointer, used for backwards communication. 


\begin{DoxyCode}
307 {
308     timeBuffer = tb_ptr;
309 
310     // Setup wire to send information back to IEW.
311     toIEW = timeBuffer->getWire(0);
312 
313     // Setup wire to read data from IEW (for the ROB).
314     robInfoFromIEW = timeBuffer->getWire(-iewToCommitDelay);
315 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_affce029fbba116bb863eb2a3a7a5bb48}{
\index{DefaultCommit@{DefaultCommit}!skidInsert@{skidInsert}}
\index{skidInsert@{skidInsert}!DefaultCommit@{DefaultCommit}}
\subsubsection[{skidInsert}]{\setlength{\rightskip}{0pt plus 5cm}void skidInsert ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_affce029fbba116bb863eb2a3a7a5bb48}
Insert all instructions from rename into skidBuffer 


\begin{DoxyCode}
1339 {
1340     DPRINTF(Commit, "Attempting to any instructions from rename into "
1341             "skidBuffer.\n");
1342 
1343     for (int inst_num = 0; inst_num < fromRename->size; ++inst_num) {
1344         DynInstPtr inst = fromRename->insts[inst_num];
1345 
1346         if (!inst->isSquashed()) {
1347             DPRINTF(Commit, "Inserting PC %s [sn:%i] [tid:%i] into ",
1348                     "skidBuffer.\n", inst->pcState(), inst->seqNum,
1349                     inst->threadNumber);
1350             skidBuffer.push(inst);
1351         } else {
1352             DPRINTF(Commit, "Instruction PC %s [sn:%i] [tid:%i] was "
1353                     "squashed, skipping.\n",
1354                     inst->pcState(), inst->seqNum, inst->threadNumber);
1355         }
1356     }
1357 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_ad47b387a7bbc4a2153b50f96b8fd2a51}{
\index{DefaultCommit@{DefaultCommit}!squashAfter@{squashAfter}}
\index{squashAfter@{squashAfter}!DefaultCommit@{DefaultCommit}}
\subsubsection[{squashAfter}]{\setlength{\rightskip}{0pt plus 5cm}void squashAfter ({\bf ThreadID} {\em tid}, \/  {\bf DynInstPtr} \& {\em head\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_ad47b387a7bbc4a2153b50f96b8fd2a51}
Handle squashing from instruction with SquashAfter set.

This differs from the other squashes as it squashes following instructions instead of the current instruction and doesn't clean up various status bits about traps/tc writes pending. Since there might have been instructions committed by the commit stage before the squashing instruction was reached and we can't commit and squash in the same cycle, we have to squash in two steps:


\begin{DoxyEnumerate}
\item Immediately set the commit status of the thread of SquashAfterPending. This forces the thread to stop committing instructions in this cycle. The last instruction to be committed in this cycle will be the SquashAfter instruction. 
\item In the next cycle, \hyperlink{classDefaultCommit_ad55316f5135cdae6aa6c5a763f6c3473}{commit()} checks for the SquashAfterPending state and squashes {\itshape all\/} in-\/flight instructions. Since the SquashAfter instruction was the last instruction to be committed in the previous cycle, this causes all subsequent instructions to be squashed. 
\end{DoxyEnumerate}


\begin{DoxyParams}{引数}
\item[{\em tid}]ID of the thread to squash. \item[{\em head\_\-inst}]Instruction that requested the squash. \end{DoxyParams}



\begin{DoxyCode}
661 {
662     DPRINTF(Commit, "Executing squash after for [tid:%i] inst [sn:%lli]\n",
663             tid, head_inst->seqNum);
664 
665     assert(!squashAfterInst[tid] || squashAfterInst[tid] == head_inst);
666     commitStatus[tid] = SquashAfterPending;
667     squashAfterInst[tid] = head_inst;
668 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a9aa66ed2ab2c61003cbbc4f0cbb53a13}{
\index{DefaultCommit@{DefaultCommit}!squashAll@{squashAll}}
\index{squashAll@{squashAll}!DefaultCommit@{DefaultCommit}}
\subsubsection[{squashAll}]{\setlength{\rightskip}{0pt plus 5cm}void squashAll ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_a9aa66ed2ab2c61003cbbc4f0cbb53a13}
Squashes all in flight instructions. 


\begin{DoxyCode}
572 {
573     // If we want to include the squashing instruction in the squash,
574     // then use one older sequence number.
575     // Hopefully this doesn't mess things up.  Basically I want to squash
576     // all instructions of this thread.
577     InstSeqNum squashed_inst = rob->isEmpty(tid) ?
578         lastCommitedSeqNum[tid] : rob->readHeadInst(tid)->seqNum - 1;
579 
580     // All younger instructions will be squashed. Set the sequence
581     // number as the youngest instruction in the ROB (0 in this case.
582     // Hopefully nothing breaks.)
583     youngestSeqNum[tid] = lastCommitedSeqNum[tid];
584 
585     rob->squash(squashed_inst, tid);
586     changedROBNumEntries[tid] = true;
587 
588     // Send back the sequence number of the squashed instruction.
589     toIEW->commitInfo[tid].doneSeqNum = squashed_inst;
590 
591     // Send back the squash signal to tell stages that they should
592     // squash.
593     toIEW->commitInfo[tid].squash = true;
594 
595     // Send back the rob squashing signal so other stages know that
596     // the ROB is in the process of squashing.
597     toIEW->commitInfo[tid].robSquashing = true;
598 
599     toIEW->commitInfo[tid].mispredictInst = NULL;
600     toIEW->commitInfo[tid].squashInst = NULL;
601 
602     toIEW->commitInfo[tid].pc = pc[tid];
603 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a05dbc60b1e537c4a85f4ab6dec6ca9a4}{
\index{DefaultCommit@{DefaultCommit}!squashFromSquashAfter@{squashFromSquashAfter}}
\index{squashFromSquashAfter@{squashFromSquashAfter}!DefaultCommit@{DefaultCommit}}
\subsubsection[{squashFromSquashAfter}]{\setlength{\rightskip}{0pt plus 5cm}void squashFromSquashAfter ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_a05dbc60b1e537c4a85f4ab6dec6ca9a4}
Handles a squash from a \hyperlink{classDefaultCommit_ad47b387a7bbc4a2153b50f96b8fd2a51}{squashAfter()} request. 


\begin{DoxyCode}
643 {
644     DPRINTF(Commit, "Squashing after squash after request, "
645             "restarting at PC %s\n", pc[tid]);
646 
647     squashAll(tid);
648     // Make sure to inform the fetch stage of which instruction caused
649     // the squash. It'll try to re-fetch an instruction executing in
650     // microcode unless this is set.
651     toIEW->commitInfo[tid].squashInst = squashAfterInst[tid];
652     squashAfterInst[tid] = NULL;
653 
654     commitStatus[tid] = ROBSquashing;
655     cpu->activityThisCycle();
656 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_ac4c7a18be5c282d711310ffb7b6f82f7}{
\index{DefaultCommit@{DefaultCommit}!squashFromTC@{squashFromTC}}
\index{squashFromTC@{squashFromTC}!DefaultCommit@{DefaultCommit}}
\subsubsection[{squashFromTC}]{\setlength{\rightskip}{0pt plus 5cm}void squashFromTC ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_ac4c7a18be5c282d711310ffb7b6f82f7}
Handles squashing due to an TC write. 


\begin{DoxyCode}
626 {
627     squashAll(tid);
628 
629     DPRINTF(Commit, "Squashing from TC, restarting at PC %s\n", pc[tid]);
630 
631     thread[tid]->noSquashFromTC = false;
632     assert(!thread[tid]->trapPending);
633 
634     commitStatus[tid] = ROBSquashing;
635     cpu->activityThisCycle();
636 
637     tcSquash[tid] = false;
638 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a2f79a5e45c55f3cba92021d1a5ebaadf}{
\index{DefaultCommit@{DefaultCommit}!squashFromTrap@{squashFromTrap}}
\index{squashFromTrap@{squashFromTrap}!DefaultCommit@{DefaultCommit}}
\subsubsection[{squashFromTrap}]{\setlength{\rightskip}{0pt plus 5cm}void squashFromTrap ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_a2f79a5e45c55f3cba92021d1a5ebaadf}
Handles squashing due to a trap. 


\begin{DoxyCode}
608 {
609     squashAll(tid);
610 
611     DPRINTF(Commit, "Squashing from trap, restarting at PC %s\n", pc[tid]);
612 
613     thread[tid]->trapPending = false;
614     thread[tid]->noSquashFromTC = false;
615     trapInFlight[tid] = false;
616 
617     trapSquash[tid] = false;
618 
619     commitStatus[tid] = ROBSquashing;
620     cpu->activityThisCycle();
621 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a31d4cbdab16d4ff8d6bc7f84ece727da}{
\index{DefaultCommit@{DefaultCommit}!startupStage@{startupStage}}
\index{startupStage@{startupStage}!DefaultCommit@{DefaultCommit}}
\subsubsection[{startupStage}]{\setlength{\rightskip}{0pt plus 5cm}void startupStage ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_a31d4cbdab16d4ff8d6bc7f84ece727da}
Initializes stage by sending back the number of free entries. 


\begin{DoxyCode}
379 {
380     rob->setActiveThreads(activeThreads);
381     rob->resetEntries();
382 
383     // Broadcast the number of free entries.
384     for (ThreadID tid = 0; tid < numThreads; tid++) {
385         toIEW->commitInfo[tid].usedROB = true;
386         toIEW->commitInfo[tid].freeROBEntries = rob->numFreeEntries(tid);
387         toIEW->commitInfo[tid].emptyROB = true;
388     }
389 
390     // Commit must broadcast the number of free entries it has at the
391     // start of the simulation, so it starts as active.
392     cpu->activateStage(O3CPU::CommitIdx);
393 
394     cpu->activityThisCycle();
395 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a8674059ce345e23aac5086b2c3e24a43}{
\index{DefaultCommit@{DefaultCommit}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!DefaultCommit@{DefaultCommit}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_a8674059ce345e23aac5086b2c3e24a43}
Takes over from another CPU's thread. 


\begin{DoxyCode}
450 {
451     _status = Active;
452     _nextStatus = Inactive;
453     for (ThreadID tid = 0; tid < numThreads; tid++) {
454         commitStatus[tid] = Idle;
455         changedROBNumEntries[tid] = false;
456         trapSquash[tid] = false;
457         tcSquash[tid] = false;
458         squashAfterInst[tid] = NULL;
459     }
460     squashCounter = 0;
461     rob->takeOverFrom();
462 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a873dd91783f9efb4a590aded1f70d6b0}{
\index{DefaultCommit@{DefaultCommit}!tick@{tick}}
\index{tick@{tick}!DefaultCommit@{DefaultCommit}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultCommit_a873dd91783f9efb4a590aded1f70d6b0}
Ticks the commit stage, which tries to commit instructions. 


\begin{DoxyCode}
673 {
674     wroteToTimeBuffer = false;
675     _nextStatus = Inactive;
676 
677     if (activeThreads->empty())
678         return;
679 
680     list<ThreadID>::iterator threads = activeThreads->begin();
681     list<ThreadID>::iterator end = activeThreads->end();
682 
683     // Check if any of the threads are done squashing.  Change the
684     // status if they are done.
685     while (threads != end) {
686         ThreadID tid = *threads++;
687 
688         // Clear the bit saying if the thread has committed stores
689         // this cycle.
690         committedStores[tid] = false;
691 
692         if (commitStatus[tid] == ROBSquashing) {
693 
694             if (rob->isDoneSquashing(tid)) {
695                 commitStatus[tid] = Running;
696             } else {
697                 DPRINTF(Commit,"[tid:%u]: Still Squashing, cannot commit any"
698                         " insts this cycle.\n", tid);
699                 rob->doSquash(tid);
700                 toIEW->commitInfo[tid].robSquashing = true;
701                 wroteToTimeBuffer = true;
702             }
703         }
704     }
705 
706     commit();
707 
708     markCompletedInsts();
709 
710     threads = activeThreads->begin();
711 
712     while (threads != end) {
713         ThreadID tid = *threads++;
714 
715         if (!rob->isEmpty(tid) && rob->readHeadInst(tid)->readyToCommit()) {
716             // The ROB has more instructions it can commit. Its next status
717             // will be active.
718             _nextStatus = Active;
719 
720             DynInstPtr inst = rob->readHeadInst(tid);
721 
722             DPRINTF(Commit,"[tid:%i]: Instruction [sn:%lli] PC %s is head of"
723                     " ROB and ready to commit\n",
724                     tid, inst->seqNum, inst->pcState());
725 
726         } else if (!rob->isEmpty(tid)) {
727             DynInstPtr inst = rob->readHeadInst(tid);
728 
729             ppCommitStall->notify(inst);
730 
731             DPRINTF(Commit,"[tid:%i]: Can't commit, Instruction [sn:%lli] PC "
732                     "%s is head of ROB and not ready\n",
733                     tid, inst->seqNum, inst->pcState());
734         }
735 
736         DPRINTF(Commit, "[tid:%i]: ROB has %d insts & %d free entries.\n",
737                 tid, rob->countInsts(tid), rob->numFreeEntries(tid));
738     }
739 
740 
741     if (wroteToTimeBuffer) {
742         DPRINTF(Activity, "Activity This Cycle.\n");
743         cpu->activityThisCycle();
744     }
745 
746     updateStatus();
747 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a5bbf266cb0cc97eed138c8fe0d2d76b6}{
\index{DefaultCommit@{DefaultCommit}!updateComInstStats@{updateComInstStats}}
\index{updateComInstStats@{updateComInstStats}!DefaultCommit@{DefaultCommit}}
\subsubsection[{updateComInstStats}]{\setlength{\rightskip}{0pt plus 5cm}void updateComInstStats ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_a5bbf266cb0cc97eed138c8fe0d2d76b6}
Updates commit stats based on this instruction. 


\begin{DoxyCode}
1402 {
1403     ThreadID tid = inst->threadNumber;
1404 
1405     if (!inst->isMicroop() || inst->isLastMicroop())
1406         instsCommitted[tid]++;
1407     opsCommitted[tid]++;
1408 
1409     // To match the old model, don't count nops and instruction
1410     // prefetches towards the total commit count.
1411     if (!inst->isNop() && !inst->isInstPrefetch()) {
1412         cpu->instDone(tid, inst);
1413     }
1414 
1415     //
1416     //  Control Instructions
1417     //
1418     if (inst->isControl())
1419         statComBranches[tid]++;
1420 
1421     //
1422     //  Memory references
1423     //
1424     if (inst->isMemRef()) {
1425         statComRefs[tid]++;
1426 
1427         if (inst->isLoad()) {
1428             statComLoads[tid]++;
1429         }
1430     }
1431 
1432     if (inst->isMemBarrier()) {
1433         statComMembars[tid]++;
1434     }
1435 
1436     // Integer Instruction
1437     if (inst->isInteger())
1438         statComInteger[tid]++;
1439 
1440     // Floating Point Instruction
1441     if (inst->isFloating())
1442         statComFloating[tid]++;
1443 
1444     // Function Calls
1445     if (inst->isCall())
1446         statComFunctionCalls[tid]++;
1447 
1448 }
\end{DoxyCode}
\hypertarget{classDefaultCommit_a4bb9486757ce225941aaaf759b357a57}{
\index{DefaultCommit@{DefaultCommit}!updateStatus@{updateStatus}}
\index{updateStatus@{updateStatus}!DefaultCommit@{DefaultCommit}}
\subsubsection[{updateStatus}]{\setlength{\rightskip}{0pt plus 5cm}void updateStatus ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultCommit_a4bb9486757ce225941aaaf759b357a57}
Updates the overall status of commit with the nextStatus, and tell the CPU if commit is active/inactive. 


\begin{DoxyCode}
467 {
468     // reset ROB changed variable
469     list<ThreadID>::iterator threads = activeThreads->begin();
470     list<ThreadID>::iterator end = activeThreads->end();
471 
472     while (threads != end) {
473         ThreadID tid = *threads++;
474 
475         changedROBNumEntries[tid] = false;
476 
477         // Also check if any of the threads has a trap pending
478         if (commitStatus[tid] == TrapPending ||
479             commitStatus[tid] == FetchTrapPending) {
480             _nextStatus = Active;
481         }
482     }
483 
484     if (_nextStatus == Inactive && _status == Active) {
485         DPRINTF(Activity, "Deactivating stage.\n");
486         cpu->deactivateStage(O3CPU::CommitIdx);
487     } else if (_nextStatus == Active && _status == Inactive) {
488         DPRINTF(Activity, "Activating stage.\n");
489         cpu->activateStage(O3CPU::CommitIdx);
490     }
491 
492     _status = _nextStatus;
493 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classDefaultCommit_a96c6cf126a60fa550bd3e279b0f33838}{
\index{DefaultCommit@{DefaultCommit}!\_\-nextStatus@{\_\-nextStatus}}
\index{\_\-nextStatus@{\_\-nextStatus}!DefaultCommit@{DefaultCommit}}
\subsubsection[{\_\-nextStatus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CommitStatus} {\bf \_\-nextStatus}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a96c6cf126a60fa550bd3e279b0f33838}
Next commit status, to be set at the end of the cycle. \hypertarget{classDefaultCommit_a0cf11ec4d376480eb733b779911f6446}{
\index{DefaultCommit@{DefaultCommit}!\_\-status@{\_\-status}}
\index{\_\-status@{\_\-status}!DefaultCommit@{DefaultCommit}}
\subsubsection[{\_\-status}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CommitStatus} {\bf \_\-status}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a0cf11ec4d376480eb733b779911f6446}
Overall commit status. \hypertarget{classDefaultCommit_af6eaea53db532812052f71bf0380dab5}{
\index{DefaultCommit@{DefaultCommit}!activeThreads@{activeThreads}}
\index{activeThreads@{activeThreads}!DefaultCommit@{DefaultCommit}}
\subsubsection[{activeThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf ThreadID}$>$$\ast$ {\bf activeThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_af6eaea53db532812052f71bf0380dab5}
Pointer to the list of active threads. \hypertarget{classDefaultCommit_a7c6eee41dc1f18f1f485518f8b066033}{
\index{DefaultCommit@{DefaultCommit}!avoidQuiesceLiveLock@{avoidQuiesceLiveLock}}
\index{avoidQuiesceLiveLock@{avoidQuiesceLiveLock}!DefaultCommit@{DefaultCommit}}
\subsubsection[{avoidQuiesceLiveLock}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf avoidQuiesceLiveLock}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a7c6eee41dc1f18f1f485518f8b066033}
Have we had an interrupt pending and then seen it de-\/asserted because of a masking change? In this case the variable is set and the next time interrupts are enabled and pending the pipeline will squash to avoid a possible livelock senario. \hypertarget{classDefaultCommit_a9cbfa1c154e785e3c45699b02a94053d}{
\index{DefaultCommit@{DefaultCommit}!branchMispredicts@{branchMispredicts}}
\index{branchMispredicts@{branchMispredicts}!DefaultCommit@{DefaultCommit}}
\subsubsection[{branchMispredicts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf branchMispredicts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a9cbfa1c154e785e3c45699b02a94053d}
Stat for the total number of branch mispredicts that caused a squash. \hypertarget{classDefaultCommit_a893f45e65e8a47bca58661db7662cd9c}{
\index{DefaultCommit@{DefaultCommit}!canHandleInterrupts@{canHandleInterrupts}}
\index{canHandleInterrupts@{canHandleInterrupts}!DefaultCommit@{DefaultCommit}}
\subsubsection[{canHandleInterrupts}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf canHandleInterrupts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a893f45e65e8a47bca58661db7662cd9c}
True if last committed microop can be followed by an interrupt \hypertarget{classDefaultCommit_a0d55e69b2ac22e8956d569bcf49e374b}{
\index{DefaultCommit@{DefaultCommit}!changedROBNumEntries@{changedROBNumEntries}}
\index{changedROBNumEntries@{changedROBNumEntries}!DefaultCommit@{DefaultCommit}}
\subsubsection[{changedROBNumEntries}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf changedROBNumEntries}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a0d55e69b2ac22e8956d569bcf49e374b}
Records if the number of \hyperlink{classROB}{ROB} entries has changed this cycle. If it has, then the number of free entries must be re-\/broadcast. \hypertarget{classDefaultCommit_aa2d2d9b2eec88d804e25d1cb37aa6083}{
\index{DefaultCommit@{DefaultCommit}!checkEmptyROB@{checkEmptyROB}}
\index{checkEmptyROB@{checkEmptyROB}!DefaultCommit@{DefaultCommit}}
\subsubsection[{checkEmptyROB}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf checkEmptyROB}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_aa2d2d9b2eec88d804e25d1cb37aa6083}
Records if commit should check if the \hyperlink{classROB}{ROB} is truly empty (see \hyperlink{commit__impl_8hh}{commit\_\-impl.hh}). \hypertarget{classDefaultCommit_a26f5138543e43cbaba9459036fc0b04c}{
\index{DefaultCommit@{DefaultCommit}!commitEligible@{commitEligible}}
\index{commitEligible@{commitEligible}!DefaultCommit@{DefaultCommit}}
\subsubsection[{commitEligible}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf commitEligible}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a26f5138543e43cbaba9459036fc0b04c}
Number of instructions not committed due to bandwidth limits. \hypertarget{classDefaultCommit_a16d1a4bbb2cb87488fd876fbf6e7a518}{
\index{DefaultCommit@{DefaultCommit}!commitEligibleSamples@{commitEligibleSamples}}
\index{commitEligibleSamples@{commitEligibleSamples}!DefaultCommit@{DefaultCommit}}
\subsubsection[{commitEligibleSamples}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf commitEligibleSamples}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a16d1a4bbb2cb87488fd876fbf6e7a518}
Number of cycles where the commit bandwidth limit is reached. \hypertarget{classDefaultCommit_ab930685f4a43596f8a315d7dc9f5c2e4}{
\index{DefaultCommit@{DefaultCommit}!commitNonSpecStalls@{commitNonSpecStalls}}
\index{commitNonSpecStalls@{commitNonSpecStalls}!DefaultCommit@{DefaultCommit}}
\subsubsection[{commitNonSpecStalls}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf commitNonSpecStalls}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_ab930685f4a43596f8a315d7dc9f5c2e4}
Stat for the total number of times commit has had to stall due to a non-\/ speculative instruction reaching the head of the \hyperlink{classROB}{ROB}. \hypertarget{classDefaultCommit_acbc18713699043ca78415e9f03712ce1}{
\index{DefaultCommit@{DefaultCommit}!commitPolicy@{commitPolicy}}
\index{commitPolicy@{commitPolicy}!DefaultCommit@{DefaultCommit}}
\subsubsection[{commitPolicy}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CommitPolicy} {\bf commitPolicy}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_acbc18713699043ca78415e9f03712ce1}
Commit policy used in SMT mode. \hypertarget{classDefaultCommit_a66220ac67b22e3faf86b642ecc217546}{
\index{DefaultCommit@{DefaultCommit}!commitSquashedInsts@{commitSquashedInsts}}
\index{commitSquashedInsts@{commitSquashedInsts}!DefaultCommit@{DefaultCommit}}
\subsubsection[{commitSquashedInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf commitSquashedInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a66220ac67b22e3faf86b642ecc217546}
Stat for the total number of squashed instructions discarded by commit. \hypertarget{classDefaultCommit_a89ef54d73dbded95395181561013b0b6}{
\index{DefaultCommit@{DefaultCommit}!commitSquashEvents@{commitSquashEvents}}
\index{commitSquashEvents@{commitSquashEvents}!DefaultCommit@{DefaultCommit}}
\subsubsection[{commitSquashEvents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf commitSquashEvents}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a89ef54d73dbded95395181561013b0b6}
Stat for the total number of times commit is told to squash. \begin{Desc}
\item[\hyperlink{todo__todo000026}{TODO}]: Actually increment this stat. \end{Desc}
\hypertarget{classDefaultCommit_ae7adb1afa143087a1e39aa65f3921185}{
\index{DefaultCommit@{DefaultCommit}!commitStatus@{commitStatus}}
\index{commitStatus@{commitStatus}!DefaultCommit@{DefaultCommit}}
\subsubsection[{commitStatus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadStatus} {\bf commitStatus}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_ae7adb1afa143087a1e39aa65f3921185}
Per-\/thread status. \hypertarget{classDefaultCommit_a0fd9fcb6eed99c11c7fa61c7218ecf49}{
\index{DefaultCommit@{DefaultCommit}!committedStores@{committedStores}}
\index{committedStores@{committedStores}!DefaultCommit@{DefaultCommit}}
\subsubsection[{committedStores}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf committedStores}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a0fd9fcb6eed99c11c7fa61c7218ecf49}
Records if there were any stores committed this cycle. \hypertarget{classDefaultCommit_a6b6fe1148ed7c40758e45f351c375552}{
\index{DefaultCommit@{DefaultCommit}!commitToIEWDelay@{commitToIEWDelay}}
\index{commitToIEWDelay@{commitToIEWDelay}!DefaultCommit@{DefaultCommit}}
\subsubsection[{commitToIEWDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf commitToIEWDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a6b6fe1148ed7c40758e45f351c375552}
Commit to IEW delay. \hypertarget{classDefaultCommit_aeab15260a0ccc0ea470bb74344b63d17}{
\index{DefaultCommit@{DefaultCommit}!commitWidth@{commitWidth}}
\index{commitWidth@{commitWidth}!DefaultCommit@{DefaultCommit}}
\subsubsection[{commitWidth}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf commitWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_aeab15260a0ccc0ea470bb74344b63d17}
Commit width, in instructions. \hypertarget{classDefaultCommit_a1379cf882a12ac6fc9eba5da7c84b18b}{
\index{DefaultCommit@{DefaultCommit}!cpu@{cpu}}
\index{cpu@{cpu}!DefaultCommit@{DefaultCommit}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf O3CPU}$\ast$ {\bf cpu}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a1379cf882a12ac6fc9eba5da7c84b18b}
Pointer to \hyperlink{namespaceO3CPU}{O3CPU}. \hypertarget{classDefaultCommit_a547316e5bf0dc6115209737cf68e9bb8}{
\index{DefaultCommit@{DefaultCommit}!drainPending@{drainPending}}
\index{drainPending@{drainPending}!DefaultCommit@{DefaultCommit}}
\subsubsection[{drainPending}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf drainPending}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a547316e5bf0dc6115209737cf68e9bb8}
Is a drain pending. \hypertarget{classDefaultCommit_a9a2f350be647ebfb6567172812db491a}{
\index{DefaultCommit@{DefaultCommit}!fetchQueue@{fetchQueue}}
\index{fetchQueue@{fetchQueue}!DefaultCommit@{DefaultCommit}}
\subsubsection[{fetchQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf FetchStruct}$>$$\ast$ {\bf fetchQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a9a2f350be647ebfb6567172812db491a}
\hypertarget{classDefaultCommit_a345f75b8236aa4fbe4ae976f8eb41a4c}{
\index{DefaultCommit@{DefaultCommit}!fetchToCommitDelay@{fetchToCommitDelay}}
\index{fetchToCommitDelay@{fetchToCommitDelay}!DefaultCommit@{DefaultCommit}}
\subsubsection[{fetchToCommitDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf fetchToCommitDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a345f75b8236aa4fbe4ae976f8eb41a4c}
\hypertarget{classDefaultCommit_a2e3dd009c447d077f19b303b53b52fab}{
\index{DefaultCommit@{DefaultCommit}!fromFetch@{fromFetch}}
\index{fromFetch@{fromFetch}!DefaultCommit@{DefaultCommit}}
\subsubsection[{fromFetch}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf FetchStruct}$>$::wire {\bf fromFetch}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a2e3dd009c447d077f19b303b53b52fab}
\hypertarget{classDefaultCommit_a7968756e9e478ff69e80117ffbea4e46}{
\index{DefaultCommit@{DefaultCommit}!fromIEW@{fromIEW}}
\index{fromIEW@{fromIEW}!DefaultCommit@{DefaultCommit}}
\subsubsection[{fromIEW}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf IEWStruct}$>$::wire {\bf fromIEW}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a7968756e9e478ff69e80117ffbea4e46}
\hyperlink{classWire}{Wire} to read information from IEW queue. \hypertarget{classDefaultCommit_a2b6b1d4785b92bd378f8a7abc5b7e6b9}{
\index{DefaultCommit@{DefaultCommit}!fromRename@{fromRename}}
\index{fromRename@{fromRename}!DefaultCommit@{DefaultCommit}}
\subsubsection[{fromRename}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf RenameStruct}$>$::wire {\bf fromRename}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a2b6b1d4785b92bd378f8a7abc5b7e6b9}
\hyperlink{classWire}{Wire} to read information from rename queue. \hypertarget{classDefaultCommit_a034b0868914c304e81c13c4e645d2616}{
\index{DefaultCommit@{DefaultCommit}!iewQueue@{iewQueue}}
\index{iewQueue@{iewQueue}!DefaultCommit@{DefaultCommit}}
\subsubsection[{iewQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf IEWStruct}$>$$\ast$ {\bf iewQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a034b0868914c304e81c13c4e645d2616}
IEW instruction queue interface. \hypertarget{classDefaultCommit_a4e9ef25d8913b270d432be4bbfe4965c}{
\index{DefaultCommit@{DefaultCommit}!iewStage@{iewStage}}
\index{iewStage@{iewStage}!DefaultCommit@{DefaultCommit}}
\subsubsection[{iewStage}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IEW}$\ast$ {\bf iewStage}}}
\label{classDefaultCommit_a4e9ef25d8913b270d432be4bbfe4965c}
The pointer to the IEW stage. Used solely to ensure that various events (traps, interrupts, syscalls) do not occur until all stores have written back. \hypertarget{classDefaultCommit_a29f74b65419ba8f0ae250d65e960202b}{
\index{DefaultCommit@{DefaultCommit}!iewToCommitDelay@{iewToCommitDelay}}
\index{iewToCommitDelay@{iewToCommitDelay}!DefaultCommit@{DefaultCommit}}
\subsubsection[{iewToCommitDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf iewToCommitDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a29f74b65419ba8f0ae250d65e960202b}
IEW to Commit delay. \hypertarget{classDefaultCommit_a23714085cc19270c017a67c9a508601a}{
\index{DefaultCommit@{DefaultCommit}!instsCommitted@{instsCommitted}}
\index{instsCommitted@{instsCommitted}!DefaultCommit@{DefaultCommit}}
\subsubsection[{instsCommitted}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf instsCommitted}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a23714085cc19270c017a67c9a508601a}
Total number of instructions committed. \hypertarget{classDefaultCommit_a7387b2358d0f884ccd5c383e6199f035}{
\index{DefaultCommit@{DefaultCommit}!interrupt@{interrupt}}
\index{interrupt@{interrupt}!DefaultCommit@{DefaultCommit}}
\subsubsection[{interrupt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} {\bf interrupt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a7387b2358d0f884ccd5c383e6199f035}
The interrupt fault. \hypertarget{classDefaultCommit_a4feaee1ef312dda13cff064de20dfbf3}{
\index{DefaultCommit@{DefaultCommit}!lastCommitedSeqNum@{lastCommitedSeqNum}}
\index{lastCommitedSeqNum@{lastCommitedSeqNum}!DefaultCommit@{DefaultCommit}}
\subsubsection[{lastCommitedSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf lastCommitedSeqNum}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a4feaee1ef312dda13cff064de20dfbf3}
The sequence number of the last commited instruction. \hypertarget{classDefaultCommit_ab1b6b40d7860fef5059f9bf1b843b366}{
\index{DefaultCommit@{DefaultCommit}!numCommittedDist@{numCommittedDist}}
\index{numCommittedDist@{numCommittedDist}!DefaultCommit@{DefaultCommit}}
\subsubsection[{numCommittedDist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Distribution} {\bf numCommittedDist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_ab1b6b40d7860fef5059f9bf1b843b366}
Distribution of the number of committed instructions each cycle. \hypertarget{classDefaultCommit_a35ee8ef405428b8d8595176ea6581681}{
\index{DefaultCommit@{DefaultCommit}!numRobs@{numRobs}}
\index{numRobs@{numRobs}!DefaultCommit@{DefaultCommit}}
\subsubsection[{numRobs}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf numRobs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a35ee8ef405428b8d8595176ea6581681}
Number of Reorder Buffers \hypertarget{classDefaultCommit_a88377f855dbf5adeeecb06b5bb821d35}{
\index{DefaultCommit@{DefaultCommit}!numThreads@{numThreads}}
\index{numThreads@{numThreads}!DefaultCommit@{DefaultCommit}}
\subsubsection[{numThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} {\bf numThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a88377f855dbf5adeeecb06b5bb821d35}
Number of Active Threads \hypertarget{classDefaultCommit_a1549eb9ffd1727a5c1937e7520a0bcc8}{
\index{DefaultCommit@{DefaultCommit}!opsCommitted@{opsCommitted}}
\index{opsCommitted@{opsCommitted}!DefaultCommit@{DefaultCommit}}
\subsubsection[{opsCommitted}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf opsCommitted}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a1549eb9ffd1727a5c1937e7520a0bcc8}
Total number of ops (including micro ops) committed. \hypertarget{classDefaultCommit_a6e6091c9272a281b8693c0f46279cad0}{
\index{DefaultCommit@{DefaultCommit}!pc@{pc}}
\index{pc@{pc}!DefaultCommit@{DefaultCommit}}
\subsubsection[{pc}]{\setlength{\rightskip}{0pt plus 5cm}TheISA::PCState {\bf pc}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a6e6091c9272a281b8693c0f46279cad0}
The commit PC state of each thread. Refers to the instruction that is currently being processed/committed. \hypertarget{classDefaultCommit_ae41ff03242cc6980c072e3ea824168ed}{
\index{DefaultCommit@{DefaultCommit}!ppCommit@{ppCommit}}
\index{ppCommit@{ppCommit}!DefaultCommit@{DefaultCommit}}
\subsubsection[{ppCommit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ProbePointArg}$<${\bf DynInstPtr}$>$$\ast$ {\bf ppCommit}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_ae41ff03242cc6980c072e3ea824168ed}
\hyperlink{namespaceProbe}{Probe} Points. \hypertarget{classDefaultCommit_a3c0bfd67f137dbd48bc31ade04a09cf0}{
\index{DefaultCommit@{DefaultCommit}!ppCommitStall@{ppCommitStall}}
\index{ppCommitStall@{ppCommitStall}!DefaultCommit@{DefaultCommit}}
\subsubsection[{ppCommitStall}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ProbePointArg}$<${\bf DynInstPtr}$>$$\ast$ {\bf ppCommitStall}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a3c0bfd67f137dbd48bc31ade04a09cf0}
\hypertarget{classDefaultCommit_a4d358db7156d04e20b3269a53334dd19}{
\index{DefaultCommit@{DefaultCommit}!priority\_\-list@{priority\_\-list}}
\index{priority\_\-list@{priority\_\-list}!DefaultCommit@{DefaultCommit}}
\subsubsection[{priority\_\-list}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf ThreadID}$>$ {\bf priority\_\-list}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a4d358db7156d04e20b3269a53334dd19}
Priority List used for Commit Policy \hypertarget{classDefaultCommit_ac305c101c17d28451cc1f023b187b08b}{
\index{DefaultCommit@{DefaultCommit}!renameMap@{renameMap}}
\index{renameMap@{renameMap}!DefaultCommit@{DefaultCommit}}
\subsubsection[{renameMap}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RenameMap}$\ast$ {\bf renameMap}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_ac305c101c17d28451cc1f023b187b08b}
Rename map interface. \hypertarget{classDefaultCommit_ae9b536282159ba75153a223be77515ba}{
\index{DefaultCommit@{DefaultCommit}!renameQueue@{renameQueue}}
\index{renameQueue@{renameQueue}!DefaultCommit@{DefaultCommit}}
\subsubsection[{renameQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf RenameStruct}$>$$\ast$ {\bf renameQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_ae9b536282159ba75153a223be77515ba}
Rename instruction queue interface, for \hyperlink{classROB}{ROB}. \hypertarget{classDefaultCommit_af699b6479037861b3c0e17d4bfab001d}{
\index{DefaultCommit@{DefaultCommit}!renameToROBDelay@{renameToROBDelay}}
\index{renameToROBDelay@{renameToROBDelay}!DefaultCommit@{DefaultCommit}}
\subsubsection[{renameToROBDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf renameToROBDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_af699b6479037861b3c0e17d4bfab001d}
Rename to \hyperlink{classROB}{ROB} delay. \hypertarget{classDefaultCommit_a4b41704382bddb6ee06b5ce97b47dd7b}{
\index{DefaultCommit@{DefaultCommit}!renameWidth@{renameWidth}}
\index{renameWidth@{renameWidth}!DefaultCommit@{DefaultCommit}}
\subsubsection[{renameWidth}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf renameWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a4b41704382bddb6ee06b5ce97b47dd7b}
Rename width, in instructions. Used so \hyperlink{classROB}{ROB} knows how many instructions to get from the rename instruction queue. \hypertarget{classDefaultCommit_a74983e0d923870864acf5b5477449d48}{
\index{DefaultCommit@{DefaultCommit}!rob@{rob}}
\index{rob@{rob}!DefaultCommit@{DefaultCommit}}
\subsubsection[{rob}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ROB}$\ast$ {\bf rob}}}
\label{classDefaultCommit_a74983e0d923870864acf5b5477449d48}
\hyperlink{classROB}{ROB} interface. \hypertarget{classDefaultCommit_a2b90705fefdf84763685650c2420f184}{
\index{DefaultCommit@{DefaultCommit}!robInfoFromIEW@{robInfoFromIEW}}
\index{robInfoFromIEW@{robInfoFromIEW}!DefaultCommit@{DefaultCommit}}
\subsubsection[{robInfoFromIEW}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf robInfoFromIEW}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a2b90705fefdf84763685650c2420f184}
\hyperlink{classWire}{Wire} to read information from IEW (for \hyperlink{classROB}{ROB}). \hypertarget{classDefaultCommit_ab9508ede35e5a000089a1450342412be}{
\index{DefaultCommit@{DefaultCommit}!skidBuffer@{skidBuffer}}
\index{skidBuffer@{skidBuffer}!DefaultCommit@{DefaultCommit}}
\subsubsection[{skidBuffer}]{\setlength{\rightskip}{0pt plus 5cm}std::queue$<${\bf DynInstPtr}$>$ {\bf skidBuffer}}}
\label{classDefaultCommit_ab9508ede35e5a000089a1450342412be}
Skid buffer between rename and commit. \hypertarget{classDefaultCommit_af0c3f70b9be736dfd854ea22a0131e1c}{
\index{DefaultCommit@{DefaultCommit}!squashAfterInst@{squashAfterInst}}
\index{squashAfterInst@{squashAfterInst}!DefaultCommit@{DefaultCommit}}
\subsubsection[{squashAfterInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf squashAfterInst}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_af0c3f70b9be736dfd854ea22a0131e1c}
Instruction passed to \hyperlink{classDefaultCommit_ad47b387a7bbc4a2153b50f96b8fd2a51}{squashAfter()}.

The squash after implementation needs to buffer the instruction that caused a squash since this needs to be passed to the fetch stage once squashing starts. \hypertarget{classDefaultCommit_a06341c2bebd8c862e411e474e01c9c1a}{
\index{DefaultCommit@{DefaultCommit}!squashCounter@{squashCounter}}
\index{squashCounter@{squashCounter}!DefaultCommit@{DefaultCommit}}
\subsubsection[{squashCounter}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} {\bf squashCounter}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a06341c2bebd8c862e411e474e01c9c1a}
A counter of how many threads are currently squashing. \hypertarget{classDefaultCommit_a39a7da0b20d1e83ccfe4b2f2b19d6e94}{
\index{DefaultCommit@{DefaultCommit}!statComBranches@{statComBranches}}
\index{statComBranches@{statComBranches}!DefaultCommit@{DefaultCommit}}
\subsubsection[{statComBranches}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf statComBranches}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a39a7da0b20d1e83ccfe4b2f2b19d6e94}
Total number of committed branches. \hypertarget{classDefaultCommit_a2be26eb7dfa8b9e36d0c6fdcaea8d818}{
\index{DefaultCommit@{DefaultCommit}!statComFloating@{statComFloating}}
\index{statComFloating@{statComFloating}!DefaultCommit@{DefaultCommit}}
\subsubsection[{statComFloating}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf statComFloating}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a2be26eb7dfa8b9e36d0c6fdcaea8d818}
Total number of floating point instructions \hypertarget{classDefaultCommit_acd1aba8c2f19771552212e9c2917ac6b}{
\index{DefaultCommit@{DefaultCommit}!statComFunctionCalls@{statComFunctionCalls}}
\index{statComFunctionCalls@{statComFunctionCalls}!DefaultCommit@{DefaultCommit}}
\subsubsection[{statComFunctionCalls}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf statComFunctionCalls}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_acd1aba8c2f19771552212e9c2917ac6b}
Total number of function calls \hypertarget{classDefaultCommit_ae562968e75d903bd12352af65cc558b6}{
\index{DefaultCommit@{DefaultCommit}!statComInteger@{statComInteger}}
\index{statComInteger@{statComInteger}!DefaultCommit@{DefaultCommit}}
\subsubsection[{statComInteger}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf statComInteger}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_ae562968e75d903bd12352af65cc558b6}
Total number of integer instructions \hypertarget{classDefaultCommit_a91927819864b9dc9d1ac706dc55d5dce}{
\index{DefaultCommit@{DefaultCommit}!statComLoads@{statComLoads}}
\index{statComLoads@{statComLoads}!DefaultCommit@{DefaultCommit}}
\subsubsection[{statComLoads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf statComLoads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a91927819864b9dc9d1ac706dc55d5dce}
Stat for the total number of committed loads. \hypertarget{classDefaultCommit_a9b029ac182d54199247dfa90ed86d368}{
\index{DefaultCommit@{DefaultCommit}!statComMembars@{statComMembars}}
\index{statComMembars@{statComMembars}!DefaultCommit@{DefaultCommit}}
\subsubsection[{statComMembars}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf statComMembars}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a9b029ac182d54199247dfa90ed86d368}
Total number of committed memory barriers. \hypertarget{classDefaultCommit_ad0d59ba553bc001d75aff706903e2f77}{
\index{DefaultCommit@{DefaultCommit}!statCommittedInstType@{statCommittedInstType}}
\index{statCommittedInstType@{statCommittedInstType}!DefaultCommit@{DefaultCommit}}
\subsubsection[{statCommittedInstType}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector2d} {\bf statCommittedInstType}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_ad0d59ba553bc001d75aff706903e2f77}
Committed instructions by instruction type (OpClass) \hypertarget{classDefaultCommit_afe174c4b8e70d840a2e91bf1ca3092ac}{
\index{DefaultCommit@{DefaultCommit}!statComRefs@{statComRefs}}
\index{statComRefs@{statComRefs}!DefaultCommit@{DefaultCommit}}
\subsubsection[{statComRefs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf statComRefs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_afe174c4b8e70d840a2e91bf1ca3092ac}
Stat for the total number of committed memory references. \hypertarget{classDefaultCommit_a4cb385aa97530dd2621c74f376839e79}{
\index{DefaultCommit@{DefaultCommit}!statComSwp@{statComSwp}}
\index{statComSwp@{statComSwp}!DefaultCommit@{DefaultCommit}}
\subsubsection[{statComSwp}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf statComSwp}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a4cb385aa97530dd2621c74f376839e79}
Total number of software prefetches committed. \hypertarget{classDefaultCommit_a4fce523b7a931003efb9665605a87ca0}{
\index{DefaultCommit@{DefaultCommit}!tcSquash@{tcSquash}}
\index{tcSquash@{tcSquash}!DefaultCommit@{DefaultCommit}}
\subsubsection[{tcSquash}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf tcSquash}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a4fce523b7a931003efb9665605a87ca0}
Records if a thread has to squash this cycle due to an XC write. \hypertarget{classDefaultCommit_afe9da004c5a3f37cbb72fa3763d4c0d1}{
\index{DefaultCommit@{DefaultCommit}!thread@{thread}}
\index{thread@{thread}!DefaultCommit@{DefaultCommit}}
\subsubsection[{thread}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf Thread} $\ast$$>$ {\bf thread}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_afe9da004c5a3f37cbb72fa3763d4c0d1}
Vector of all of the threads. \hypertarget{classDefaultCommit_a83f9ee976e732665aeb08dbc19acfd45}{
\index{DefaultCommit@{DefaultCommit}!timeBuffer@{timeBuffer}}
\index{timeBuffer@{timeBuffer}!DefaultCommit@{DefaultCommit}}
\subsubsection[{timeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$$\ast$ {\bf timeBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a83f9ee976e732665aeb08dbc19acfd45}
\hyperlink{classTime}{Time} buffer interface. \hypertarget{classDefaultCommit_a2877bfe6e25eb731f28c8c5a9ba55391}{
\index{DefaultCommit@{DefaultCommit}!toIEW@{toIEW}}
\index{toIEW@{toIEW}!DefaultCommit@{DefaultCommit}}
\subsubsection[{toIEW}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf toIEW}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a2877bfe6e25eb731f28c8c5a9ba55391}
\hyperlink{classWire}{Wire} to write information heading to previous stages. \hypertarget{classDefaultCommit_a4e366a325229901e41b68ff07e5f556a}{
\index{DefaultCommit@{DefaultCommit}!trapInFlight@{trapInFlight}}
\index{trapInFlight@{trapInFlight}!DefaultCommit@{DefaultCommit}}
\subsubsection[{trapInFlight}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf trapInFlight}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a4e366a325229901e41b68ff07e5f556a}
Records if there is a trap currently in flight. \hypertarget{classDefaultCommit_a0bfffaa2e5f9c7e79353e61146950a9a}{
\index{DefaultCommit@{DefaultCommit}!trapLatency@{trapLatency}}
\index{trapLatency@{trapLatency}!DefaultCommit@{DefaultCommit}}
\subsubsection[{trapLatency}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf trapLatency}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a0bfffaa2e5f9c7e79353e61146950a9a}
The latency to handle a trap. Used when scheduling trap squash event. \hypertarget{classDefaultCommit_af3547420a792f13034730b5f327a47ff}{
\index{DefaultCommit@{DefaultCommit}!trapSquash@{trapSquash}}
\index{trapSquash@{trapSquash}!DefaultCommit@{DefaultCommit}}
\subsubsection[{trapSquash}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf trapSquash}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_af3547420a792f13034730b5f327a47ff}
Records if a thread has to squash this cycle due to a trap. \hypertarget{classDefaultCommit_a2c7e870d4babdac0dc91fc7ffabd0f3d}{
\index{DefaultCommit@{DefaultCommit}!wroteToTimeBuffer@{wroteToTimeBuffer}}
\index{wroteToTimeBuffer@{wroteToTimeBuffer}!DefaultCommit@{DefaultCommit}}
\subsubsection[{wroteToTimeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf wroteToTimeBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a2c7e870d4babdac0dc91fc7ffabd0f3d}
Records that commit has written to the time buffer this cycle. Used for the CPU to determine if it can deschedule itself if there is no activity. \hypertarget{classDefaultCommit_a1d81dc5c05e15057c1985acc39285540}{
\index{DefaultCommit@{DefaultCommit}!youngestSeqNum@{youngestSeqNum}}
\index{youngestSeqNum@{youngestSeqNum}!DefaultCommit@{DefaultCommit}}
\subsubsection[{youngestSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf youngestSeqNum}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultCommit_a1d81dc5c05e15057c1985acc39285540}
The sequence number of the youngest valid instruction in the \hyperlink{classROB}{ROB}. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/o3/\hyperlink{commit_8hh}{commit.hh}\item 
cpu/o3/\hyperlink{commit__impl_8hh}{commit\_\-impl.hh}\end{DoxyCompactItemize}
