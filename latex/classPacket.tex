\hypertarget{classPacket}{
\section{クラス Packet}
\label{classPacket}\index{Packet@{Packet}}
}


{\ttfamily \#include $<$packet.hh$>$}Packetに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classPacket}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classPacket_1_1PrintReqState}{PrintReqState}
\item 
struct \hyperlink{structPacket_1_1SenderState}{SenderState}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classPacket_a2da503161d95c65aea559dbabcf570aa}{FlagsType}
\item 
typedef ::\hyperlink{classFlags}{Flags}$<$ \hyperlink{classPacket_a2da503161d95c65aea559dbabcf570aa}{FlagsType} $>$ \hyperlink{classPacket_ad6cda6b0b8d7ddfbf8e769082577b482}{Flags}
\item 
typedef \hyperlink{classMemCmd_a2afce0a47a93eee73a314d53e4890153}{MemCmd::Command} \hyperlink{classPacket_a1f48acf35af3589c5f137c85deff8e85}{Command}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classPacket_a6a6aa11d6c2aec2df5aafeefe2847d8e}{pushSenderState} (\hyperlink{structPacket_1_1SenderState}{SenderState} $\ast$sender\_\-state)
\item 
\hyperlink{structPacket_1_1SenderState}{SenderState} $\ast$ \hyperlink{classPacket_a6f73d3ef605e592952b5586975161bfd}{popSenderState} ()
\item 
{\footnotesize template$<$typename T $>$ }\\T $\ast$ \hyperlink{classPacket_a55ab7685d5e3c590ee23ca4ec7c3c0a0}{findNextSenderState} () const 
\item 
const std::string \& \hyperlink{classPacket_a863af57e28a01258236ea303155fc7ff}{cmdString} () const 
\item 
int \hyperlink{classPacket_a8db75870e65b9d86793f2805097c05a0}{cmdToIndex} () const 
\begin{DoxyCompactList}\small\item\em Return the index of this command. \item\end{DoxyCompactList}\item 
bool \hyperlink{classPacket_adc47901747fc3c447db3abddaf01491a}{isRead} () const 
\item 
bool \hyperlink{classPacket_ab699d2f0d186312531fd1c279fd27b73}{isWrite} () const 
\item 
bool \hyperlink{classPacket_aadb2fde0aba4a65b45d591e9ef5b6a63}{isUpgrade} () const 
\item 
bool \hyperlink{classPacket_af21986d725d75fa8e1b6c83457cd4501}{isRequest} () const 
\item 
bool \hyperlink{classPacket_a5f89a108755a6cb3e8185d85c850a816}{isResponse} () const 
\item 
bool \hyperlink{classPacket_aa8e449288b878ff3ff7f286eb4d28b6a}{needsExclusive} () const 
\item 
bool \hyperlink{classPacket_a390c6cced05593f0a2c75a38a7a24fa9}{needsResponse} () const 
\item 
bool \hyperlink{classPacket_a4a1a39b8ffab2d6266cd9d794ca332e3}{isInvalidate} () const 
\item 
bool \hyperlink{classPacket_a0effbd4cf91891700ac41e86defe4aa6}{hasData} () const 
\item 
bool \hyperlink{classPacket_aa05746eae63aee1fb4758c13d0301a9f}{isReadWrite} () const 
\item 
bool \hyperlink{classPacket_a8965874e960faf91ad4b6af8dbf31875}{isLLSC} () const 
\item 
bool \hyperlink{classPacket_a32759931a1b2d6380407c6a18abd46e3}{isError} () const 
\item 
bool \hyperlink{classPacket_ae56bb417ddf53e85cb389267590fe969}{isPrint} () const 
\item 
bool \hyperlink{classPacket_a5e6baaa42eabbb07af2d1769e3c0499b}{isFlush} () const 
\item 
void \hyperlink{classPacket_a159497b4ab2144a0c1c36d2266df17d1}{assertMemInhibit} ()
\item 
bool \hyperlink{classPacket_a9693a1ffeda326646443ab2a2a92be41}{memInhibitAsserted} () const 
\item 
void \hyperlink{classPacket_a40d9a7952a041e62ac388a0f523dee41}{assertShared} ()
\item 
bool \hyperlink{classPacket_a298938bfa2613955b13f630ce2b591e4}{sharedAsserted} () const 
\item 
void \hyperlink{classPacket_a556d03576cc3d726f41c7e1ad6fbb64a}{setExpressSnoop} ()
\item 
bool \hyperlink{classPacket_aa20026c596161a1efabde68c4a34e00b}{isExpressSnoop} () const 
\item 
void \hyperlink{classPacket_ad0e298222c7b6801ea282a177fac7c39}{setSupplyExclusive} ()
\item 
void \hyperlink{classPacket_a36834b936b153f19a035352b14cf180e}{clearSupplyExclusive} ()
\item 
bool \hyperlink{classPacket_ae74f555f87001a9695338ce38a6ce8ee}{isSupplyExclusive} () const 
\item 
void \hyperlink{classPacket_ad0ca097f61c7d5d16df21635617d8d07}{setSuppressFuncError} ()
\item 
bool \hyperlink{classPacket_a181cb46d55a9f0f933fe649c6937d037}{suppressFuncError} () const 
\item 
void \hyperlink{classPacket_a49108ef8d9510ea6b9982e9e97ca971b}{setPrefetchSquashed} ()
\item 
bool \hyperlink{classPacket_a142c7ae41f822269b145818af682f031}{prefetchSquashed} () const 
\item 
void \hyperlink{classPacket_a44c3e4fcce6474af8052d68e75826c13}{setBadAddress} ()
\item 
bool \hyperlink{classPacket_a729b79fed5294aff99bb49b6b6d888bc}{hadBadAddress} () const 
\item 
void \hyperlink{classPacket_a838dc8f424eaa81aa7ee30fb4c5900a0}{copyError} (\hyperlink{classPacket}{Packet} $\ast$pkt)
\item 
bool \hyperlink{classPacket_a298fc6cc50f34dc7eaee82b746129eb3}{isSrcValid} () const 
\item 
\hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} \hyperlink{classPacket_a6ac1bab8f0db56da42ee3359c3aef5dc}{getSrc} () const 
\begin{DoxyCompactList}\small\item\em Accessor function to get the source index of the packet. \item\end{DoxyCompactList}\item 
void \hyperlink{classPacket_a6e173cf473a751a0e969c1561a4184cc}{setSrc} (\hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} \_\-src)
\begin{DoxyCompactList}\small\item\em Accessor function to set the source index of the packet. \item\end{DoxyCompactList}\item 
void \hyperlink{classPacket_a65f22eb305e0e75fe1c4e484f046c00e}{clearSrc} ()
\begin{DoxyCompactList}\small\item\em Reset source field, e.g. to retransmit packet on different bus. \item\end{DoxyCompactList}\item 
bool \hyperlink{classPacket_a1a0afe1ec029c745df5d36293d306800}{isDestValid} () const 
\item 
\hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} \hyperlink{classPacket_a8c4564a96830dffcc13f56b716afa674}{getDest} () const 
\begin{DoxyCompactList}\small\item\em Accessor function for the destination index of the packet. \item\end{DoxyCompactList}\item 
void \hyperlink{classPacket_a20739d8f669d352681830025686158ce}{setDest} (\hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} \_\-dest)
\begin{DoxyCompactList}\small\item\em Accessor function to set the destination index of the packet. \item\end{DoxyCompactList}\item 
void \hyperlink{classPacket_a2d986bc7c63bf7c63e392296d32f77ae}{clearDest} ()
\begin{DoxyCompactList}\small\item\em Reset destination field, e.g. to turn a response into a request again. \item\end{DoxyCompactList}\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classPacket_afca9af4d83a57836baba87603463a6e0}{getAddr} () const 
\item 
void \hyperlink{classPacket_ac449086ed3ddac64f5f55926907b6b0c}{setAddr} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \_\-addr)
\item 
unsigned \hyperlink{classPacket_a1d18ba49c7be427da1f4a42d53e35f48}{getSize} () const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classPacket_a8c497c6b3c41668562b2a2aa57ad098d}{getOffset} (int blkSize) const 
\item 
bool \hyperlink{classPacket_a3110ebf17828782ae5aeced7396cfff2}{isSecure} () const 
\item 
void \hyperlink{classPacket_ac4dec10b288f4bdc07dd66688b81f832}{convertScToWrite} ()
\item 
void \hyperlink{classPacket_a4d3d1abff83d841c66d318d026a5d58e}{convertLlToRead} ()
\item 
\hyperlink{classPacket_af96a2c11524631f891fcbd42cf919f53}{Packet} (\hyperlink{classRequest}{Request} $\ast$\_\-req, \hyperlink{classMemCmd}{MemCmd} \_\-cmd)
\item 
\hyperlink{classPacket_a14ed9efd5f1e1b89778e2dd02cb0d6ab}{Packet} (\hyperlink{classRequest}{Request} $\ast$\_\-req, \hyperlink{classMemCmd}{MemCmd} \_\-cmd, int \_\-blkSize)
\item 
\hyperlink{classPacket_a19cdd324c9f9070b3031e8a4521ac4ba}{Packet} (\hyperlink{classPacket}{Packet} $\ast$pkt, bool clearFlags=false)
\item 
\hyperlink{classPacket_a39d19f9b1d6f6c2028a930cdfcdff809}{$\sim$Packet} ()
\item 
void \hyperlink{classPacket_a03e8085580e8f97f3177195fe2ed27e7}{reinitFromRequest} ()
\item 
void \hyperlink{classPacket_a9330bf4cbbc7e25bbfc9626182df27e5}{makeResponse} ()
\item 
void \hyperlink{classPacket_ad664e704f09d6bb5c116573721034ebd}{makeAtomicResponse} ()
\item 
void \hyperlink{classPacket_a325088bded521f69342b08a548811332}{makeTimingResponse} ()
\item 
void \hyperlink{classPacket_a61715904f754e7788941e838fca1dcb9}{setFunctionalResponseStatus} (bool success)
\item 
void \hyperlink{classPacket_a9ad6fec061170a98f1358fc86738e7b3}{setSize} (unsigned \hyperlink{classPacket_a245260f6f74972558f61b85227df5aae}{size})
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{classPacket_a60621b00d6ecd49b3e336087aca2eda0}{dataStatic} (T $\ast$p)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{classPacket_ae02c6b2e23b2a5b138c85fcf91fd818d}{dataDynamicArray} (T $\ast$p)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{classPacket_a970b12a3c3c7fe790502959ffe561eda}{dataDynamic} (T $\ast$p)
\item 
{\footnotesize template$<$typename T $>$ }\\T $\ast$ \hyperlink{classPacket_a5c451baf3f0a89084e79e69bb9061200}{getPtr} (bool null\_\-ok=false)
\item 
{\footnotesize template$<$typename T $>$ }\\T \hyperlink{classPacket_af6ea056c8af82f08af9fd0d857967f9b}{get} ()
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{classPacket_a64d947d8dd285398050238bf26c1d8d2}{set} (T v)
\item 
void \hyperlink{classPacket_aaa0b1cd19807fc630d9331be9f5d1d36}{setData} (uint8\_\-t $\ast$p)
\item 
void \hyperlink{classPacket_a0001ad64c160390fba5d1351862195ff}{setDataFromBlock} (uint8\_\-t $\ast$blk\_\-data, int blkSize)
\item 
void \hyperlink{classPacket_a2388a13bab41142d6e403b0e5a0fb649}{writeData} (uint8\_\-t $\ast$p)
\item 
void \hyperlink{classPacket_ac14ab45b04f07f4aca586b773f2252db}{writeDataToBlock} (uint8\_\-t $\ast$blk\_\-data, int blkSize)
\item 
void \hyperlink{classPacket_a01374b232898f3d3c134623ffded84af}{deleteData} ()
\item 
void \hyperlink{classPacket_acaefe811b78a2fdc4a0dba0c4029c3ef}{allocate} ()
\item 
bool \hyperlink{classPacket_a77410f93ce8057ce67882c121ac2e667}{checkFunctional} (\hyperlink{classPrintable}{Printable} $\ast$obj, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} base, bool is\_\-secure, int \hyperlink{classPacket_a245260f6f74972558f61b85227df5aae}{size}, uint8\_\-t $\ast$\hyperlink{classPacket_a60f451ea06dccaf49b32633f67e7b16e}{data})
\item 
bool \hyperlink{classPacket_ab27966f94fe8860e3845815fd4b8da7f}{checkFunctional} (\hyperlink{classPacket}{PacketPtr} other)
\item 
void \hyperlink{classPacket_ad2656c333949d4b445823d47398829f2}{pushLabel} (const std::string \&lbl)
\item 
void \hyperlink{classPacket_a3ab6da7065be0d85f45a8dd050515f16}{popLabel} ()
\item 
void \hyperlink{classPacket_ae31e5ec0b459f751b386d17dd75855d1}{print} (std::ostream \&o, int verbosity=0, const std::string \&prefix=\char`\"{}\char`\"{}) const 
\item 
std::string \hyperlink{classPacket_ae8a5b5e9e0e6be3b115ee77fa7b4d0c8}{print} () const 
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMemCmd}{MemCmd} \hyperlink{classPacket_af88eb56d484b750933cd2ea86594f001}{cmd}
\begin{DoxyCompactList}\small\item\em The command field of the packet. \item\end{DoxyCompactList}\item 
\hyperlink{classRequest}{RequestPtr} \hyperlink{classPacket_a956cd41d82347558b9c0a5b0474903f2}{req}
\begin{DoxyCompactList}\small\item\em A pointer to the original request. \item\end{DoxyCompactList}\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classPacket_af8986a05caa6c5b96b0b01bb6cf47772}{busFirstWordDelay}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classPacket_a7bf8ae0a056329f751eda8b39ca4c268}{busLastWordDelay}
\item 
\hyperlink{structPacket_1_1SenderState}{SenderState} $\ast$ \hyperlink{classPacket_a983ade0479f946c813284dcc65073367}{senderState}
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classFlags}{Flags} \hyperlink{classPacket_aa991e2b209ef26272bf4fd920777bcda}{flags}
\item 
\hyperlink{packet_8hh_ae85a9de970f801a77a1ad88ee2b39ea2}{PacketDataPtr} \hyperlink{classPacket_a60f451ea06dccaf49b32633f67e7b16e}{data}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classPacket_a0bb77b4ba61e408313e1118250f9278c}{addr}
\item 
bool \hyperlink{classPacket_a8575be38d53d73568838d5805df1cf63}{\_\-isSecure}
\begin{DoxyCompactList}\small\item\em True if the request targets the secure memory space. \item\end{DoxyCompactList}\item 
unsigned \hyperlink{classPacket_a245260f6f74972558f61b85227df5aae}{size}
\begin{DoxyCompactList}\small\item\em The size of the request or transfer. \item\end{DoxyCompactList}\item 
\hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} \hyperlink{classPacket_ae47dce578a23ce59793947e009b087e3}{src}
\item 
\hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} \hyperlink{classPacket_a826324ce6e458b38e4010b9e0ca8f14a}{dest}
\item 
\hyperlink{classMemCmd}{MemCmd} \hyperlink{classPacket_a98424e5b505c05a999a7e03dd4caa0fa}{origCmd}
\item 
uint16\_\-t \hyperlink{classPacket_a5a3c6bfd022f6812ff7f168c5233ad23}{bytesValidStart}
\item 
uint16\_\-t \hyperlink{classPacket_ae0d66052bfed50bce9fd141f1728b755}{bytesValidEnd}
\end{DoxyCompactItemize}
\subsection*{Static Private 変数}
\begin{DoxyCompactItemize}
\item 
static const \hyperlink{classPacket_a2da503161d95c65aea559dbabcf570aa}{FlagsType} \hyperlink{classPacket_aedf1d129016ac677627a1e3c2ee6b59a}{PUBLIC\_\-FLAGS} = 0x00000000
\item 
static const \hyperlink{classPacket_a2da503161d95c65aea559dbabcf570aa}{FlagsType} \hyperlink{classPacket_aa377b218207b557079f48b02e7acf167}{PRIVATE\_\-FLAGS} = 0x00007F0F
\item 
static const \hyperlink{classPacket_a2da503161d95c65aea559dbabcf570aa}{FlagsType} \hyperlink{classPacket_af494771dbda61056aaad3f6ad7e2d84d}{COPY\_\-FLAGS} = 0x0000000F
\item 
static const \hyperlink{classPacket_a2da503161d95c65aea559dbabcf570aa}{FlagsType} \hyperlink{classPacket_a3f87955b81ea6f9d7f89d5ab033074f9}{SHARED} = 0x00000001
\item 
static const \hyperlink{classPacket_a2da503161d95c65aea559dbabcf570aa}{FlagsType} \hyperlink{classPacket_a0b5a042e640242aeaeeebef73a69df26}{EXPRESS\_\-SNOOP} = 0x00000002
\begin{DoxyCompactList}\small\item\em Special timing-\/mode atomic snoop for multi-\/level coherence. \item\end{DoxyCompactList}\item 
static const \hyperlink{classPacket_a2da503161d95c65aea559dbabcf570aa}{FlagsType} \hyperlink{classPacket_a064f460e5a6ed3522adc424c5d31646a}{SUPPLY\_\-EXCLUSIVE} = 0x00000004
\item 
static const \hyperlink{classPacket_a2da503161d95c65aea559dbabcf570aa}{FlagsType} \hyperlink{classPacket_aae6e80e571cf0888e7583aa556c3f171}{MEM\_\-INHIBIT} = 0x00000008
\item 
static const \hyperlink{classPacket_a2da503161d95c65aea559dbabcf570aa}{FlagsType} \hyperlink{classPacket_ac99ea8fdca503270882373e7a801a2b6}{VALID\_\-ADDR} = 0x00000100
\begin{DoxyCompactList}\small\item\em Are the 'addr' and 'size' fields valid? \item\end{DoxyCompactList}\item 
static const \hyperlink{classPacket_a2da503161d95c65aea559dbabcf570aa}{FlagsType} \hyperlink{classPacket_a3e2067968b47a2acb352b48bced164cf}{VALID\_\-SIZE} = 0x00000200
\item 
static const \hyperlink{classPacket_a2da503161d95c65aea559dbabcf570aa}{FlagsType} \hyperlink{classPacket_a1736ff591124f446ce3ddbb16fb3f505}{STATIC\_\-DATA} = 0x00001000
\item 
static const \hyperlink{classPacket_a2da503161d95c65aea559dbabcf570aa}{FlagsType} \hyperlink{classPacket_a0100d751aaef8a927f7ba551550d142b}{DYNAMIC\_\-DATA} = 0x00002000
\item 
static const \hyperlink{classPacket_a2da503161d95c65aea559dbabcf570aa}{FlagsType} \hyperlink{classPacket_a861863488f543d1fd5aaf422469ba27a}{ARRAY\_\-DATA} = 0x00004000
\item 
static const \hyperlink{classPacket_a2da503161d95c65aea559dbabcf570aa}{FlagsType} \hyperlink{classPacket_a5e3b50f943fac776d71dbe3ff03cc7a5}{SUPPRESS\_\-FUNC\_\-ERROR} = 0x00008000
\item 
static const \hyperlink{classPacket_a2da503161d95c65aea559dbabcf570aa}{FlagsType} \hyperlink{classPacket_ae2bdbe737a4cf46b8bedebcaa602d23a}{PREFETCH\_\-SNOOP\_\-SQUASH} = 0x00010000
\end{DoxyCompactItemize}


\subsection{説明}
A \hyperlink{classPacket}{Packet} is used to encapsulate a transfer between two objects in the memory system (e.g., the L1 and L2 cache). (In contrast, a single \hyperlink{classRequest}{Request} travels all the way from the requester to the ultimate destination and back, possibly being conveyed by several different Packets along the way.) 

\subsection{型定義}
\hypertarget{classPacket_a1f48acf35af3589c5f137c85deff8e85}{
\index{Packet@{Packet}!Command@{Command}}
\index{Command@{Command}!Packet@{Packet}}
\subsubsection[{Command}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf MemCmd::Command} {\bf Command}}}
\label{classPacket_a1f48acf35af3589c5f137c85deff8e85}
\hypertarget{classPacket_ad6cda6b0b8d7ddfbf8e769082577b482}{
\index{Packet@{Packet}!Flags@{Flags}}
\index{Flags@{Flags}!Packet@{Packet}}
\subsubsection[{Flags}]{\setlength{\rightskip}{0pt plus 5cm}typedef ::{\bf Flags}$<${\bf FlagsType}$>$ {\bf Flags}}}
\label{classPacket_ad6cda6b0b8d7ddfbf8e769082577b482}
\hypertarget{classPacket_a2da503161d95c65aea559dbabcf570aa}{
\index{Packet@{Packet}!FlagsType@{FlagsType}}
\index{FlagsType@{FlagsType}!Packet@{Packet}}
\subsubsection[{FlagsType}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf uint32\_\-t} {\bf FlagsType}}}
\label{classPacket_a2da503161d95c65aea559dbabcf570aa}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classPacket_af96a2c11524631f891fcbd42cf919f53}{
\index{Packet@{Packet}!Packet@{Packet}}
\index{Packet@{Packet}!Packet@{Packet}}
\subsubsection[{Packet}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Packet} ({\bf Request} $\ast$ {\em \_\-req}, \/  {\bf MemCmd} {\em \_\-cmd})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_af96a2c11524631f891fcbd42cf919f53}
Constructor. Note that a \hyperlink{classRequest}{Request} object must be constructed first, but the Requests's physical address and size fields need not be valid. The command must be supplied. 


\begin{DoxyCode}
609         :  cmd(_cmd), req(_req), data(NULL),
610            src(InvalidPortID), dest(InvalidPortID),
611            bytesValidStart(0), bytesValidEnd(0),
612            busFirstWordDelay(0), busLastWordDelay(0),
613            senderState(NULL)
614     {
615         if (req->hasPaddr()) {
616             addr = req->getPaddr();
617             flags.set(VALID_ADDR);
618             _isSecure = req->isSecure();
619         }
620         if (req->hasSize()) {
621             size = req->getSize();
622             flags.set(VALID_SIZE);
623         }
624     }
\end{DoxyCode}
\hypertarget{classPacket_a14ed9efd5f1e1b89778e2dd02cb0d6ab}{
\index{Packet@{Packet}!Packet@{Packet}}
\index{Packet@{Packet}!Packet@{Packet}}
\subsubsection[{Packet}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Packet} ({\bf Request} $\ast$ {\em \_\-req}, \/  {\bf MemCmd} {\em \_\-cmd}, \/  int {\em \_\-blkSize})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a14ed9efd5f1e1b89778e2dd02cb0d6ab}
Alternate constructor if you are trying to create a packet with a request that is for a whole block, not the address from the req. this allows for overriding the size/addr of the req. 


\begin{DoxyCode}
632         :  cmd(_cmd), req(_req), data(NULL),
633            src(InvalidPortID), dest(InvalidPortID),
634            bytesValidStart(0), bytesValidEnd(0),
635            busFirstWordDelay(0), busLastWordDelay(0),
636            senderState(NULL)
637     {
638         if (req->hasPaddr()) {
639             addr = req->getPaddr() & ~(_blkSize - 1);
640             flags.set(VALID_ADDR);
641             _isSecure = req->isSecure();
642         }
643         size = _blkSize;
644         flags.set(VALID_SIZE);
645     }
\end{DoxyCode}
\hypertarget{classPacket_a19cdd324c9f9070b3031e8a4521ac4ba}{
\index{Packet@{Packet}!Packet@{Packet}}
\index{Packet@{Packet}!Packet@{Packet}}
\subsubsection[{Packet}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Packet} ({\bf Packet} $\ast$ {\em pkt}, \/  bool {\em clearFlags} = {\ttfamily false})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a19cdd324c9f9070b3031e8a4521ac4ba}
Alternate constructor for copying a packet. Copy all fields $\ast$except$\ast$ if the original packet's data was dynamic, don't copy that, as we can't guarantee that the new packet's lifetime is less than that of the original packet. In this case the new packet should allocate its own data. 


\begin{DoxyCode}
655         :  cmd(pkt->cmd), req(pkt->req),
656            data(pkt->flags.isSet(STATIC_DATA) ? pkt->data : NULL),
657            addr(pkt->addr), _isSecure(pkt->_isSecure), size(pkt->size),
658            src(pkt->src), dest(pkt->dest),
659            bytesValidStart(pkt->bytesValidStart),
660            bytesValidEnd(pkt->bytesValidEnd),
661            busFirstWordDelay(pkt->busFirstWordDelay),
662            busLastWordDelay(pkt->busLastWordDelay),
663            senderState(pkt->senderState)
664     {
665         if (!clearFlags)
666             flags.set(pkt->flags & COPY_FLAGS);
667 
668         flags.set(pkt->flags & (VALID_ADDR|VALID_SIZE));
669         flags.set(pkt->flags & STATIC_DATA);
670 
671     }
\end{DoxyCode}
\hypertarget{classPacket_a39d19f9b1d6f6c2028a930cdfcdff809}{
\index{Packet@{Packet}!$\sim$Packet@{$\sim$Packet}}
\index{$\sim$Packet@{$\sim$Packet}!Packet@{Packet}}
\subsubsection[{$\sim$Packet}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf Packet} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a39d19f9b1d6f6c2028a930cdfcdff809}
clean up packet variables 


\begin{DoxyCode}
677     {
678         // If this is a request packet for which there's no response,
679         // delete the request object here, since the requester will
680         // never get the chance.
681         if (req && isRequest() && !needsResponse())
682             delete req;
683         deleteData();
684     }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classPacket_acaefe811b78a2fdc4a0dba0c4029c3ef}{
\index{Packet@{Packet}!allocate@{allocate}}
\index{allocate@{allocate}!Packet@{Packet}}
\subsubsection[{allocate}]{\setlength{\rightskip}{0pt plus 5cm}void allocate ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_acaefe811b78a2fdc4a0dba0c4029c3ef}
If there isn't data in the packet, allocate some. 


\begin{DoxyCode}
894     {
895         if (data) {
896             assert(flags.isSet(STATIC_DATA|DYNAMIC_DATA));
897             return;
898         }
899 
900         assert(flags.noneSet(STATIC_DATA|DYNAMIC_DATA));
901         flags.set(DYNAMIC_DATA|ARRAY_DATA);
902         data = new uint8_t[getSize()];
903     }
\end{DoxyCode}
\hypertarget{classPacket_a159497b4ab2144a0c1c36d2266df17d1}{
\index{Packet@{Packet}!assertMemInhibit@{assertMemInhibit}}
\index{assertMemInhibit@{assertMemInhibit}!Packet@{Packet}}
\subsubsection[{assertMemInhibit}]{\setlength{\rightskip}{0pt plus 5cm}void assertMemInhibit ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a159497b4ab2144a0c1c36d2266df17d1}



\begin{DoxyCode}
515 { flags.set(MEM_INHIBIT); }
\end{DoxyCode}
\hypertarget{classPacket_a40d9a7952a041e62ac388a0f523dee41}{
\index{Packet@{Packet}!assertShared@{assertShared}}
\index{assertShared@{assertShared}!Packet@{Packet}}
\subsubsection[{assertShared}]{\setlength{\rightskip}{0pt plus 5cm}void assertShared ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a40d9a7952a041e62ac388a0f523dee41}



\begin{DoxyCode}
517 { flags.set(SHARED); }
\end{DoxyCode}
\hypertarget{classPacket_ab27966f94fe8860e3845815fd4b8da7f}{
\index{Packet@{Packet}!checkFunctional@{checkFunctional}}
\index{checkFunctional@{checkFunctional}!Packet@{Packet}}
\subsubsection[{checkFunctional}]{\setlength{\rightskip}{0pt plus 5cm}bool checkFunctional ({\bf PacketPtr} {\em other})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_ab27966f94fe8860e3845815fd4b8da7f}
\hyperlink{classCheck}{Check} a functional request against a memory value stored in another packet (i.e. an in-\/transit request or response). 


\begin{DoxyCode}
921     {
922         uint8_t *data = other->hasData() ? other->getPtr<uint8_t>() : NULL;
923         return checkFunctional(other, other->getAddr(), other->isSecure(),
924                                other->getSize(), data);
925     }
\end{DoxyCode}
\hypertarget{classPacket_a77410f93ce8057ce67882c121ac2e667}{
\index{Packet@{Packet}!checkFunctional@{checkFunctional}}
\index{checkFunctional@{checkFunctional}!Packet@{Packet}}
\subsubsection[{checkFunctional}]{\setlength{\rightskip}{0pt plus 5cm}bool checkFunctional ({\bf Printable} $\ast$ {\em obj}, \/  {\bf Addr} {\em base}, \/  bool {\em is\_\-secure}, \/  int {\em size}, \/  uint8\_\-t $\ast$ {\em data})}}
\label{classPacket_a77410f93ce8057ce67882c121ac2e667}
\hyperlink{classCheck}{Check} a functional request against a memory value represented by a base/size pair and an associated data array. If the functional request is a read, it may be satisfied by the memory value. If the functional request is a write, it may update the memory value. 


\begin{DoxyCode}
177 {
178     Addr func_start = getAddr();
179     Addr func_end   = getAddr() + getSize() - 1;
180     Addr val_start  = addr;
181     Addr val_end    = val_start + size - 1;
182 
183     if (is_secure != _isSecure || func_start > val_end ||
184         val_start > func_end) {
185         // no intersection
186         return false;
187     }
188 
189     // check print first since it doesn't require data
190     if (isPrint()) {
191         dynamic_cast<PrintReqState*>(senderState)->printObj(obj);
192         return false;
193     }
194 
195     // if there's no data, there's no need to look further
196     if (!data) {
197         return false;
198     }
199 
200     // offset of functional request into supplied value (could be
201     // negative if partial overlap)
202     int offset = func_start - val_start;
203 
204     if (isRead()) {
205         if (func_start >= val_start && func_end <= val_end) {
206             allocate();
207             if (getSize()==16)
208               printf("Packet isRead is OK\n");
209             memcpy(getPtr<uint8_t>(), data + offset, getSize());
210             return true;
211         } else {
212             // Offsets and sizes to copy in case of partial overlap
213             int func_offset;
214             int val_offset;
215             int overlap_size;
216 
217             // calculate offsets and copy sizes for the two byte arrays
218             if (val_start < func_start && val_end <= func_end) {
219                 val_offset = func_start - val_start;
220                 func_offset = 0;
221                 overlap_size = val_end - func_start;
222             } else if (val_start >= func_start && val_end > func_end) {
223                 val_offset = 0;
224                 func_offset = val_start - func_start;
225                 overlap_size = func_end - val_start;
226             } else if (val_start >= func_start && val_end <= func_end) {
227                 val_offset = 0;
228                 func_offset = val_start - func_start;
229                 overlap_size = size;
230             } else {
231                 panic("BUG: Missed a case for a partial functional request");
232             }
233 
234             // Figure out how much of the partial overlap should be copied
235             // into the packet and not overwrite previously found bytes.
236             if (bytesValidStart == 0 && bytesValidEnd == 0) {
237                 // No bytes have been copied yet, just set indices
238                 // to found range
239                 bytesValidStart = func_offset;
240                 bytesValidEnd = func_offset + overlap_size;
241             } else {
242                 // Some bytes have already been copied. Use bytesValid
243                 // indices and offset values to figure out how much data
244                 // to copy and where to copy it to.
245 
246                 // Indice overlap conditions to check
247                 int a = func_offset - bytesValidStart;
248                 int b = (func_offset + overlap_size) - bytesValidEnd;
249                 int c = func_offset - bytesValidEnd;
250                 int d = (func_offset + overlap_size) - bytesValidStart;
251 
252                 if (a >= 0 && b <= 0) {
253                     // bytes already in pkt data array are superset of
254                     // found bytes, will not copy any bytes
255                     overlap_size = 0;
256                 } else if (a < 0 && d >= 0 && b <= 0) {
257                     // found bytes will move bytesValidStart towards 0
258                     overlap_size = bytesValidStart - func_offset;
259                     bytesValidStart = func_offset;
260                 } else if (b > 0 && c <= 0 && a >= 0) {
261                     // found bytes will move bytesValidEnd
262                     // towards end of pkt data array
263                     overlap_size =
264                         (func_offset + overlap_size) - bytesValidEnd;
265                     val_offset += bytesValidEnd - func_offset;
266                     func_offset = bytesValidEnd;
267                     bytesValidEnd += overlap_size;
268                 } else if (a < 0 && b > 0) {
269                     // Found bytes are superset of copied range. Will move
270                     // bytesValidStart towards 0 and bytesValidEnd towards
271                     // end of pkt data array.  Need to break copy into two
272                     // pieces so as to not overwrite previously found data.
273 
274                     // copy the first half
275                     uint8_t *dest = getPtr<uint8_t>() + func_offset;
276                     uint8_t *src = data + val_offset;
277                     memcpy(dest, src, (bytesValidStart - func_offset));
278 
279                     // re-calc the offsets and indices to do the copy
280                     // required for the second half
281                     val_offset += (bytesValidEnd - func_offset);
282                     bytesValidStart = func_offset;
283                     overlap_size =
284                         (func_offset + overlap_size) - bytesValidEnd;
285                     func_offset = bytesValidEnd;
286                     bytesValidEnd += overlap_size;
287                 } else if ((c > 0 && b > 0)
288                            || (a < 0 && d < 0)) {
289                     // region to be copied is discontiguous! Not supported.
290                     panic("BUG: Discontiguous bytes found"
291                           "for functional copying!");
292                 }
293             }
294             assert(bytesValidEnd <= getSize());
295 
296             // copy partial data into the packet's data array
297             uint8_t *dest = getPtr<uint8_t>() + func_offset;
298             uint8_t *src = data + val_offset;
299             memcpy(dest, src, overlap_size);
300 
301             // check if we're done filling the functional access
302             bool done = (bytesValidStart == 0) && (bytesValidEnd == getSize());
303             return done;
304         }
305     } else if (isWrite()) {
306         if (offset >= 0) {
307             memcpy(data + offset, getPtr<uint8_t>(),
308                    (min(func_end, val_end) - func_start) + 1);
309         } else {
310             // val_start > func_start
311             memcpy(data, getPtr<uint8_t>() - offset,
312                    (min(func_end, val_end) - val_start) + 1);
313         }
314     } else {
315         panic("Don't know how to handle command %s\n", cmdString());
316     }
317 
318     // keep going with request by default
319     return false;
320 }
\end{DoxyCode}
\hypertarget{classPacket_a2d986bc7c63bf7c63e392296d32f77ae}{
\index{Packet@{Packet}!clearDest@{clearDest}}
\index{clearDest@{clearDest}!Packet@{Packet}}
\subsubsection[{clearDest}]{\setlength{\rightskip}{0pt plus 5cm}void clearDest ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a2d986bc7c63bf7c63e392296d32f77ae}


Reset destination field, e.g. to turn a response into a request again. 


\begin{DoxyCode}
558 { dest = InvalidPortID; }
\end{DoxyCode}
\hypertarget{classPacket_a65f22eb305e0e75fe1c4e484f046c00e}{
\index{Packet@{Packet}!clearSrc@{clearSrc}}
\index{clearSrc@{clearSrc}!Packet@{Packet}}
\subsubsection[{clearSrc}]{\setlength{\rightskip}{0pt plus 5cm}void clearSrc ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a65f22eb305e0e75fe1c4e484f046c00e}


Reset source field, e.g. to retransmit packet on different bus. 


\begin{DoxyCode}
550 { src = InvalidPortID; }
\end{DoxyCode}
\hypertarget{classPacket_a36834b936b153f19a035352b14cf180e}{
\index{Packet@{Packet}!clearSupplyExclusive@{clearSupplyExclusive}}
\index{clearSupplyExclusive@{clearSupplyExclusive}!Packet@{Packet}}
\subsubsection[{clearSupplyExclusive}]{\setlength{\rightskip}{0pt plus 5cm}void clearSupplyExclusive ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a36834b936b153f19a035352b14cf180e}



\begin{DoxyCode}
524 { flags.clear(SUPPLY_EXCLUSIVE); }
\end{DoxyCode}
\hypertarget{classPacket_a863af57e28a01258236ea303155fc7ff}{
\index{Packet@{Packet}!cmdString@{cmdString}}
\index{cmdString@{cmdString}!Packet@{Packet}}
\subsubsection[{cmdString}]{\setlength{\rightskip}{0pt plus 5cm}const std::string\& cmdString () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a863af57e28a01258236ea303155fc7ff}
Return the string name of the cmd field (for debugging and tracing). 


\begin{DoxyCode}
494 { return cmd.toString(); }
\end{DoxyCode}
\hypertarget{classPacket_a8db75870e65b9d86793f2805097c05a0}{
\index{Packet@{Packet}!cmdToIndex@{cmdToIndex}}
\index{cmdToIndex@{cmdToIndex}!Packet@{Packet}}
\subsubsection[{cmdToIndex}]{\setlength{\rightskip}{0pt plus 5cm}int cmdToIndex () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a8db75870e65b9d86793f2805097c05a0}


Return the index of this command. 


\begin{DoxyCode}
497 { return cmd.toInt(); }
\end{DoxyCode}
\hypertarget{classPacket_a4d3d1abff83d841c66d318d026a5d58e}{
\index{Packet@{Packet}!convertLlToRead@{convertLlToRead}}
\index{convertLlToRead@{convertLlToRead}!Packet@{Packet}}
\subsubsection[{convertLlToRead}]{\setlength{\rightskip}{0pt plus 5cm}void convertLlToRead ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a4d3d1abff83d841c66d318d026a5d58e}
When ruby is in use, Ruby will monitor the cache line and thus M5 phys memory should treat LL ops as normal reads. 


\begin{DoxyCode}
597     {
598         assert(isLLSC());
599         assert(isRead());
600         cmd = MemCmd::ReadReq;
601     }
\end{DoxyCode}
\hypertarget{classPacket_ac4dec10b288f4bdc07dd66688b81f832}{
\index{Packet@{Packet}!convertScToWrite@{convertScToWrite}}
\index{convertScToWrite@{convertScToWrite}!Packet@{Packet}}
\subsubsection[{convertScToWrite}]{\setlength{\rightskip}{0pt plus 5cm}void convertScToWrite ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_ac4dec10b288f4bdc07dd66688b81f832}
It has been determined that the SC packet should successfully update memory. Therefore, convert this SC packet to a normal write. 


\begin{DoxyCode}
585     {
586         assert(isLLSC());
587         assert(isWrite());
588         cmd = MemCmd::WriteReq;
589     }
\end{DoxyCode}
\hypertarget{classPacket_a838dc8f424eaa81aa7ee30fb4c5900a0}{
\index{Packet@{Packet}!copyError@{copyError}}
\index{copyError@{copyError}!Packet@{Packet}}
\subsubsection[{copyError}]{\setlength{\rightskip}{0pt plus 5cm}void copyError ({\bf Packet} $\ast$ {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a838dc8f424eaa81aa7ee30fb4c5900a0}



\begin{DoxyCode}
542 { assert(pkt->isError()); cmd = pkt->cmd; }
\end{DoxyCode}
\hypertarget{classPacket_a970b12a3c3c7fe790502959ffe561eda}{
\index{Packet@{Packet}!dataDynamic@{dataDynamic}}
\index{dataDynamic@{dataDynamic}!Packet@{Packet}}
\subsubsection[{dataDynamic}]{\setlength{\rightskip}{0pt plus 5cm}void dataDynamic (T $\ast$ {\em p})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a970b12a3c3c7fe790502959ffe561eda}
set the data pointer to a value that should have delete called on it. 


\begin{DoxyCode}
803     {
804         assert(flags.noneSet(STATIC_DATA|DYNAMIC_DATA|ARRAY_DATA));
805         data = (PacketDataPtr)p;
806         flags.set(DYNAMIC_DATA);
807     }
\end{DoxyCode}
\hypertarget{classPacket_ae02c6b2e23b2a5b138c85fcf91fd818d}{
\index{Packet@{Packet}!dataDynamicArray@{dataDynamicArray}}
\index{dataDynamicArray@{dataDynamicArray}!Packet@{Packet}}
\subsubsection[{dataDynamicArray}]{\setlength{\rightskip}{0pt plus 5cm}void dataDynamicArray (T $\ast$ {\em p})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_ae02c6b2e23b2a5b138c85fcf91fd818d}
\hyperlink{classSet}{Set} the data pointer to a value that should have delete \mbox{[}\mbox{]} called on it. 


\begin{DoxyCode}
790     {
791         assert(flags.noneSet(STATIC_DATA|DYNAMIC_DATA|ARRAY_DATA));
792         data = (PacketDataPtr)p;
793         flags.set(DYNAMIC_DATA|ARRAY_DATA);
794     }
\end{DoxyCode}
\hypertarget{classPacket_a60621b00d6ecd49b3e336087aca2eda0}{
\index{Packet@{Packet}!dataStatic@{dataStatic}}
\index{dataStatic@{dataStatic}!Packet@{Packet}}
\subsubsection[{dataStatic}]{\setlength{\rightskip}{0pt plus 5cm}void dataStatic (T $\ast$ {\em p})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a60621b00d6ecd49b3e336087aca2eda0}
\hyperlink{classSet}{Set} the data pointer to the following value that should not be freed. 


\begin{DoxyCode}
777     {
778         assert(flags.noneSet(STATIC_DATA|DYNAMIC_DATA|ARRAY_DATA));
779         data = (PacketDataPtr)p;
780         flags.set(STATIC_DATA);
781     }
\end{DoxyCode}
\hypertarget{classPacket_a01374b232898f3d3c134623ffded84af}{
\index{Packet@{Packet}!deleteData@{deleteData}}
\index{deleteData@{deleteData}!Packet@{Packet}}
\subsubsection[{deleteData}]{\setlength{\rightskip}{0pt plus 5cm}void deleteData ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a01374b232898f3d3c134623ffded84af}
delete the data pointed to in the data pointer. Ok to call to matter how data was allocted. 


\begin{DoxyCode}
881     {
882         if (flags.isSet(ARRAY_DATA))
883             delete [] data;
884         else if (flags.isSet(DYNAMIC_DATA))
885             delete data;
886 
887         flags.clear(STATIC_DATA|DYNAMIC_DATA|ARRAY_DATA);
888         data = NULL;
889     }
\end{DoxyCode}
\hypertarget{classPacket_a55ab7685d5e3c590ee23ca4ec7c3c0a0}{
\index{Packet@{Packet}!findNextSenderState@{findNextSenderState}}
\index{findNextSenderState@{findNextSenderState}!Packet@{Packet}}
\subsubsection[{findNextSenderState}]{\setlength{\rightskip}{0pt plus 5cm}T$\ast$ findNextSenderState () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a55ab7685d5e3c590ee23ca4ec7c3c0a0}
Go through the sender state stack and return the first instance that is of type T (as determined by a dynamic\_\-cast). If there is no sender state of type T, NULL is returned.

\begin{DoxyReturn}{戻り値}
The topmost state of type T 
\end{DoxyReturn}



\begin{DoxyCode}
482     {
483         T *t = NULL;
484         SenderState* sender_state = senderState;
485         while (t == NULL && sender_state != NULL) {
486             t = dynamic_cast<T*>(sender_state);
487             sender_state = sender_state->predecessor;
488         }
489         return t;
490     }
\end{DoxyCode}
\hypertarget{classPacket_af6ea056c8af82f08af9fd0d857967f9b}{
\index{Packet@{Packet}!get@{get}}
\index{get@{get}!Packet@{Packet}}
\subsubsection[{get}]{\setlength{\rightskip}{0pt plus 5cm}T get ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_af6ea056c8af82f08af9fd0d857967f9b}
return the value of what is pointed to in the packet. 


\begin{DoxyCode}
49 {
50     assert(flags.isSet(STATIC_DATA|DYNAMIC_DATA));
51     assert(sizeof(T) <= size);
52     //if(sizeof(T)==16) {return data;}
53     return TheISA::gtoh(*(T*)data);
54 }
\end{DoxyCode}
\hypertarget{classPacket_afca9af4d83a57836baba87603463a6e0}{
\index{Packet@{Packet}!getAddr@{getAddr}}
\index{getAddr@{getAddr}!Packet@{Packet}}
\subsubsection[{getAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} getAddr () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_afca9af4d83a57836baba87603463a6e0}



\begin{DoxyCode}
560 { assert(flags.isSet(VALID_ADDR)); return addr; }
\end{DoxyCode}
\hypertarget{classPacket_a8c4564a96830dffcc13f56b716afa674}{
\index{Packet@{Packet}!getDest@{getDest}}
\index{getDest@{getDest}!Packet@{Packet}}
\subsubsection[{getDest}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PortID} getDest () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a8c4564a96830dffcc13f56b716afa674}


Accessor function for the destination index of the packet. 


\begin{DoxyCode}
554 { assert(isDestValid()); return dest; }
\end{DoxyCode}
\hypertarget{classPacket_a8c497c6b3c41668562b2a2aa57ad098d}{
\index{Packet@{Packet}!getOffset@{getOffset}}
\index{getOffset@{getOffset}!Packet@{Packet}}
\subsubsection[{getOffset}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} getOffset (int {\em blkSize}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a8c497c6b3c41668562b2a2aa57ad098d}



\begin{DoxyCode}
571 { return getAddr() & (Addr)(blkSize - 1); }
\end{DoxyCode}
\hypertarget{classPacket_a5c451baf3f0a89084e79e69bb9061200}{
\index{Packet@{Packet}!getPtr@{getPtr}}
\index{getPtr@{getPtr}!Packet@{Packet}}
\subsubsection[{getPtr}]{\setlength{\rightskip}{0pt plus 5cm}T$\ast$ getPtr (bool {\em null\_\-ok} = {\ttfamily false})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a5c451baf3f0a89084e79e69bb9061200}
get a pointer to the data ptr. 


\begin{DoxyCode}
815     {
816         assert(null_ok || flags.isSet(STATIC_DATA|DYNAMIC_DATA));
817         return (T*)data;
818     }
\end{DoxyCode}
\hypertarget{classPacket_a1d18ba49c7be427da1f4a42d53e35f48}{
\index{Packet@{Packet}!getSize@{getSize}}
\index{getSize@{getSize}!Packet@{Packet}}
\subsubsection[{getSize}]{\setlength{\rightskip}{0pt plus 5cm}unsigned getSize () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a1d18ba49c7be427da1f4a42d53e35f48}



\begin{DoxyCode}
570 { assert(flags.isSet(VALID_SIZE)); return size; }
\end{DoxyCode}
\hypertarget{classPacket_a6ac1bab8f0db56da42ee3359c3aef5dc}{
\index{Packet@{Packet}!getSrc@{getSrc}}
\index{getSrc@{getSrc}!Packet@{Packet}}
\subsubsection[{getSrc}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PortID} getSrc () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a6ac1bab8f0db56da42ee3359c3aef5dc}


Accessor function to get the source index of the packet. 


\begin{DoxyCode}
546 { assert(isSrcValid()); return src; }
\end{DoxyCode}
\hypertarget{classPacket_a729b79fed5294aff99bb49b6b6d888bc}{
\index{Packet@{Packet}!hadBadAddress@{hadBadAddress}}
\index{hadBadAddress@{hadBadAddress}!Packet@{Packet}}
\subsubsection[{hadBadAddress}]{\setlength{\rightskip}{0pt plus 5cm}bool hadBadAddress () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a729b79fed5294aff99bb49b6b6d888bc}



\begin{DoxyCode}
541 { return cmd == MemCmd::BadAddressError; }
\end{DoxyCode}
\hypertarget{classPacket_a0effbd4cf91891700ac41e86defe4aa6}{
\index{Packet@{Packet}!hasData@{hasData}}
\index{hasData@{hasData}!Packet@{Packet}}
\subsubsection[{hasData}]{\setlength{\rightskip}{0pt plus 5cm}bool hasData () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a0effbd4cf91891700ac41e86defe4aa6}



\begin{DoxyCode}
507 { return cmd.hasData(); }
\end{DoxyCode}
\hypertarget{classPacket_a1a0afe1ec029c745df5d36293d306800}{
\index{Packet@{Packet}!isDestValid@{isDestValid}}
\index{isDestValid@{isDestValid}!Packet@{Packet}}
\subsubsection[{isDestValid}]{\setlength{\rightskip}{0pt plus 5cm}bool isDestValid () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a1a0afe1ec029c745df5d36293d306800}



\begin{DoxyCode}
552 { return dest != InvalidPortID; }
\end{DoxyCode}
\hypertarget{classPacket_a32759931a1b2d6380407c6a18abd46e3}{
\index{Packet@{Packet}!isError@{isError}}
\index{isError@{isError}!Packet@{Packet}}
\subsubsection[{isError}]{\setlength{\rightskip}{0pt plus 5cm}bool isError () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a32759931a1b2d6380407c6a18abd46e3}



\begin{DoxyCode}
510 { return cmd.isError(); }
\end{DoxyCode}
\hypertarget{classPacket_aa20026c596161a1efabde68c4a34e00b}{
\index{Packet@{Packet}!isExpressSnoop@{isExpressSnoop}}
\index{isExpressSnoop@{isExpressSnoop}!Packet@{Packet}}
\subsubsection[{isExpressSnoop}]{\setlength{\rightskip}{0pt plus 5cm}bool isExpressSnoop () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_aa20026c596161a1efabde68c4a34e00b}



\begin{DoxyCode}
522 { return flags.isSet(EXPRESS_SNOOP); }
\end{DoxyCode}
\hypertarget{classPacket_a5e6baaa42eabbb07af2d1769e3c0499b}{
\index{Packet@{Packet}!isFlush@{isFlush}}
\index{isFlush@{isFlush}!Packet@{Packet}}
\subsubsection[{isFlush}]{\setlength{\rightskip}{0pt plus 5cm}bool isFlush () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a5e6baaa42eabbb07af2d1769e3c0499b}



\begin{DoxyCode}
512 { return cmd.isFlush(); }
\end{DoxyCode}
\hypertarget{classPacket_a4a1a39b8ffab2d6266cd9d794ca332e3}{
\index{Packet@{Packet}!isInvalidate@{isInvalidate}}
\index{isInvalidate@{isInvalidate}!Packet@{Packet}}
\subsubsection[{isInvalidate}]{\setlength{\rightskip}{0pt plus 5cm}bool isInvalidate () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a4a1a39b8ffab2d6266cd9d794ca332e3}



\begin{DoxyCode}
506 { return cmd.isInvalidate(); }
\end{DoxyCode}
\hypertarget{classPacket_a8965874e960faf91ad4b6af8dbf31875}{
\index{Packet@{Packet}!isLLSC@{isLLSC}}
\index{isLLSC@{isLLSC}!Packet@{Packet}}
\subsubsection[{isLLSC}]{\setlength{\rightskip}{0pt plus 5cm}bool isLLSC () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a8965874e960faf91ad4b6af8dbf31875}



\begin{DoxyCode}
509 { return cmd.isLLSC(); }
\end{DoxyCode}
\hypertarget{classPacket_ae56bb417ddf53e85cb389267590fe969}{
\index{Packet@{Packet}!isPrint@{isPrint}}
\index{isPrint@{isPrint}!Packet@{Packet}}
\subsubsection[{isPrint}]{\setlength{\rightskip}{0pt plus 5cm}bool isPrint () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_ae56bb417ddf53e85cb389267590fe969}



\begin{DoxyCode}
511 { return cmd.isPrint(); }
\end{DoxyCode}
\hypertarget{classPacket_adc47901747fc3c447db3abddaf01491a}{
\index{Packet@{Packet}!isRead@{isRead}}
\index{isRead@{isRead}!Packet@{Packet}}
\subsubsection[{isRead}]{\setlength{\rightskip}{0pt plus 5cm}bool isRead () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_adc47901747fc3c447db3abddaf01491a}



\begin{DoxyCode}
499 { return cmd.isRead(); }
\end{DoxyCode}
\hypertarget{classPacket_aa05746eae63aee1fb4758c13d0301a9f}{
\index{Packet@{Packet}!isReadWrite@{isReadWrite}}
\index{isReadWrite@{isReadWrite}!Packet@{Packet}}
\subsubsection[{isReadWrite}]{\setlength{\rightskip}{0pt plus 5cm}bool isReadWrite () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_aa05746eae63aee1fb4758c13d0301a9f}



\begin{DoxyCode}
508 { return cmd.isReadWrite(); }
\end{DoxyCode}
\hypertarget{classPacket_af21986d725d75fa8e1b6c83457cd4501}{
\index{Packet@{Packet}!isRequest@{isRequest}}
\index{isRequest@{isRequest}!Packet@{Packet}}
\subsubsection[{isRequest}]{\setlength{\rightskip}{0pt plus 5cm}bool isRequest () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_af21986d725d75fa8e1b6c83457cd4501}



\begin{DoxyCode}
502 { return cmd.isRequest(); }
\end{DoxyCode}
\hypertarget{classPacket_a5f89a108755a6cb3e8185d85c850a816}{
\index{Packet@{Packet}!isResponse@{isResponse}}
\index{isResponse@{isResponse}!Packet@{Packet}}
\subsubsection[{isResponse}]{\setlength{\rightskip}{0pt plus 5cm}bool isResponse () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a5f89a108755a6cb3e8185d85c850a816}



\begin{DoxyCode}
503 { return cmd.isResponse(); }
\end{DoxyCode}
\hypertarget{classPacket_a3110ebf17828782ae5aeced7396cfff2}{
\index{Packet@{Packet}!isSecure@{isSecure}}
\index{isSecure@{isSecure}!Packet@{Packet}}
\subsubsection[{isSecure}]{\setlength{\rightskip}{0pt plus 5cm}bool isSecure () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a3110ebf17828782ae5aeced7396cfff2}



\begin{DoxyCode}
574     {
575         assert(flags.isSet(VALID_ADDR));
576         return _isSecure;
577     }
\end{DoxyCode}
\hypertarget{classPacket_a298fc6cc50f34dc7eaee82b746129eb3}{
\index{Packet@{Packet}!isSrcValid@{isSrcValid}}
\index{isSrcValid@{isSrcValid}!Packet@{Packet}}
\subsubsection[{isSrcValid}]{\setlength{\rightskip}{0pt plus 5cm}bool isSrcValid () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a298fc6cc50f34dc7eaee82b746129eb3}



\begin{DoxyCode}
544 { return src != InvalidPortID; }
\end{DoxyCode}
\hypertarget{classPacket_ae74f555f87001a9695338ce38a6ce8ee}{
\index{Packet@{Packet}!isSupplyExclusive@{isSupplyExclusive}}
\index{isSupplyExclusive@{isSupplyExclusive}!Packet@{Packet}}
\subsubsection[{isSupplyExclusive}]{\setlength{\rightskip}{0pt plus 5cm}bool isSupplyExclusive () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_ae74f555f87001a9695338ce38a6ce8ee}



\begin{DoxyCode}
525 { return flags.isSet(SUPPLY_EXCLUSIVE); }
\end{DoxyCode}
\hypertarget{classPacket_aadb2fde0aba4a65b45d591e9ef5b6a63}{
\index{Packet@{Packet}!isUpgrade@{isUpgrade}}
\index{isUpgrade@{isUpgrade}!Packet@{Packet}}
\subsubsection[{isUpgrade}]{\setlength{\rightskip}{0pt plus 5cm}bool isUpgrade () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_aadb2fde0aba4a65b45d591e9ef5b6a63}



\begin{DoxyCode}
501 { return cmd.isUpgrade(); }
\end{DoxyCode}
\hypertarget{classPacket_ab699d2f0d186312531fd1c279fd27b73}{
\index{Packet@{Packet}!isWrite@{isWrite}}
\index{isWrite@{isWrite}!Packet@{Packet}}
\subsubsection[{isWrite}]{\setlength{\rightskip}{0pt plus 5cm}bool isWrite () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_ab699d2f0d186312531fd1c279fd27b73}



\begin{DoxyCode}
500 { return cmd.isWrite(); }
\end{DoxyCode}
\hypertarget{classPacket_ad664e704f09d6bb5c116573721034ebd}{
\index{Packet@{Packet}!makeAtomicResponse@{makeAtomicResponse}}
\index{makeAtomicResponse@{makeAtomicResponse}!Packet@{Packet}}
\subsubsection[{makeAtomicResponse}]{\setlength{\rightskip}{0pt plus 5cm}void makeAtomicResponse ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_ad664e704f09d6bb5c116573721034ebd}



\begin{DoxyCode}
738     {
739         makeResponse();
740     }
\end{DoxyCode}
\hypertarget{classPacket_a9330bf4cbbc7e25bbfc9626182df27e5}{
\index{Packet@{Packet}!makeResponse@{makeResponse}}
\index{makeResponse@{makeResponse}!Packet@{Packet}}
\subsubsection[{makeResponse}]{\setlength{\rightskip}{0pt plus 5cm}void makeResponse ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a9330bf4cbbc7e25bbfc9626182df27e5}
Take a request packet and modify it in place to be suitable for returning as a response to that request. The source field is turned into the destination, and subsequently cleared. Note that the latter is not necessary for atomic requests, but causes no harm as neither field is valid. 


\begin{DoxyCode}
722     {
723         assert(needsResponse());
724         assert(isRequest());
725         origCmd = cmd;
726         cmd = cmd.responseCommand();
727 
728         // responses are never express, even if the snoop that
729         // triggered them was
730         flags.clear(EXPRESS_SNOOP);
731 
732         dest = src;
733         clearSrc();
734     }
\end{DoxyCode}
\hypertarget{classPacket_a325088bded521f69342b08a548811332}{
\index{Packet@{Packet}!makeTimingResponse@{makeTimingResponse}}
\index{makeTimingResponse@{makeTimingResponse}!Packet@{Packet}}
\subsubsection[{makeTimingResponse}]{\setlength{\rightskip}{0pt plus 5cm}void makeTimingResponse ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a325088bded521f69342b08a548811332}



\begin{DoxyCode}
744     {
745         makeResponse();
746     }
\end{DoxyCode}
\hypertarget{classPacket_a9693a1ffeda326646443ab2a2a92be41}{
\index{Packet@{Packet}!memInhibitAsserted@{memInhibitAsserted}}
\index{memInhibitAsserted@{memInhibitAsserted}!Packet@{Packet}}
\subsubsection[{memInhibitAsserted}]{\setlength{\rightskip}{0pt plus 5cm}bool memInhibitAsserted () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a9693a1ffeda326646443ab2a2a92be41}



\begin{DoxyCode}
516 { return flags.isSet(MEM_INHIBIT); }
\end{DoxyCode}
\hypertarget{classPacket_aa8e449288b878ff3ff7f286eb4d28b6a}{
\index{Packet@{Packet}!needsExclusive@{needsExclusive}}
\index{needsExclusive@{needsExclusive}!Packet@{Packet}}
\subsubsection[{needsExclusive}]{\setlength{\rightskip}{0pt plus 5cm}bool needsExclusive () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_aa8e449288b878ff3ff7f286eb4d28b6a}



\begin{DoxyCode}
504 { return cmd.needsExclusive(); }
\end{DoxyCode}
\hypertarget{classPacket_a390c6cced05593f0a2c75a38a7a24fa9}{
\index{Packet@{Packet}!needsResponse@{needsResponse}}
\index{needsResponse@{needsResponse}!Packet@{Packet}}
\subsubsection[{needsResponse}]{\setlength{\rightskip}{0pt plus 5cm}bool needsResponse () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a390c6cced05593f0a2c75a38a7a24fa9}



\begin{DoxyCode}
505 { return cmd.needsResponse(); }
\end{DoxyCode}
\hypertarget{classPacket_a3ab6da7065be0d85f45a8dd050515f16}{
\index{Packet@{Packet}!popLabel@{popLabel}}
\index{popLabel@{popLabel}!Packet@{Packet}}
\subsubsection[{popLabel}]{\setlength{\rightskip}{0pt plus 5cm}void popLabel ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a3ab6da7065be0d85f45a8dd050515f16}
Pop label for PrintReq (safe to call unconditionally). 


\begin{DoxyCode}
942     {
943         if (isPrint())
944             safe_cast<PrintReqState*>(senderState)->popLabel();
945     }
\end{DoxyCode}
\hypertarget{classPacket_a6f73d3ef605e592952b5586975161bfd}{
\index{Packet@{Packet}!popSenderState@{popSenderState}}
\index{popSenderState@{popSenderState}!Packet@{Packet}}
\subsubsection[{popSenderState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Packet::SenderState} $\ast$ popSenderState ()}}
\label{classPacket_a6f73d3ef605e592952b5586975161bfd}
Pop the top of the state stack and return a pointer to it. This assumes the current sender state is not NULL. This should be preferred over direct manipulation of the senderState member variable.

\begin{DoxyReturn}{戻り値}
The current top of the stack 
\end{DoxyReturn}



\begin{DoxyCode}
332 {
333     assert(senderState != NULL);
334     SenderState *sender_state = senderState;
335     senderState = sender_state->predecessor;
336     sender_state->predecessor = NULL;
337     return sender_state;
338 }
\end{DoxyCode}
\hypertarget{classPacket_a142c7ae41f822269b145818af682f031}{
\index{Packet@{Packet}!prefetchSquashed@{prefetchSquashed}}
\index{prefetchSquashed@{prefetchSquashed}!Packet@{Packet}}
\subsubsection[{prefetchSquashed}]{\setlength{\rightskip}{0pt plus 5cm}bool prefetchSquashed () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a142c7ae41f822269b145818af682f031}



\begin{DoxyCode}
529 { return flags.isSet(PREFETCH_SNOOP_SQUASH); }
\end{DoxyCode}
\hypertarget{classPacket_ae8a5b5e9e0e6be3b115ee77fa7b4d0c8}{
\index{Packet@{Packet}!print@{print}}
\index{print@{print}!Packet@{Packet}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}std::string print () const}}
\label{classPacket_ae8a5b5e9e0e6be3b115ee77fa7b4d0c8}
A no-\/args wrapper of print(std::ostream...) meant to be invoked from DPRINTFs avoiding string overheads in fast mode \begin{DoxyReturn}{戻り値}
string with the request's type and start$<$-\/$>$end addresses 
\end{DoxyReturn}



\begin{DoxyCode}
348                     {
349     ostringstream str;
350     print(str);
351     return str.str();
352 }
\end{DoxyCode}
\hypertarget{classPacket_ae31e5ec0b459f751b386d17dd75855d1}{
\index{Packet@{Packet}!print@{print}}
\index{print@{print}!Packet@{Packet}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}void print (std::ostream \& {\em o}, \/  int {\em verbosity} = {\ttfamily 0}, \/  const std::string \& {\em prefix} = {\ttfamily \char`\"{}\char`\"{}}) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPacket_ae31e5ec0b459f751b386d17dd75855d1}


\hyperlink{classPrintable_a3be2c5a60e9670becc3259fc689833c5}{Printable}を実装しています。\hypertarget{classPacket_ad2656c333949d4b445823d47398829f2}{
\index{Packet@{Packet}!pushLabel@{pushLabel}}
\index{pushLabel@{pushLabel}!Packet@{Packet}}
\subsubsection[{pushLabel}]{\setlength{\rightskip}{0pt plus 5cm}void pushLabel (const std::string \& {\em lbl})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_ad2656c333949d4b445823d47398829f2}
Push label for PrintReq (safe to call unconditionally). 


\begin{DoxyCode}
932     {
933         if (isPrint())
934             safe_cast<PrintReqState*>(senderState)->pushLabel(lbl);
935     }
\end{DoxyCode}
\hypertarget{classPacket_a6a6aa11d6c2aec2df5aafeefe2847d8e}{
\index{Packet@{Packet}!pushSenderState@{pushSenderState}}
\index{pushSenderState@{pushSenderState}!Packet@{Packet}}
\subsubsection[{pushSenderState}]{\setlength{\rightskip}{0pt plus 5cm}void pushSenderState ({\bf Packet::SenderState} $\ast$ {\em sender\_\-state})}}
\label{classPacket_a6a6aa11d6c2aec2df5aafeefe2847d8e}
Push a new sender state to the packet and make the current sender state the predecessor of the new one. This should be prefered over direct manipulation of the senderState member variable.


\begin{DoxyParams}{引数}
\item[{\em sender\_\-state}]\hyperlink{structPacket_1_1SenderState}{SenderState} to push at the top of the stack \end{DoxyParams}



\begin{DoxyCode}
324 {
325     assert(sender_state != NULL);
326     sender_state->predecessor = senderState;
327     senderState = sender_state;
328 }
\end{DoxyCode}
\hypertarget{classPacket_a03e8085580e8f97f3177195fe2ed27e7}{
\index{Packet@{Packet}!reinitFromRequest@{reinitFromRequest}}
\index{reinitFromRequest@{reinitFromRequest}!Packet@{Packet}}
\subsubsection[{reinitFromRequest}]{\setlength{\rightskip}{0pt plus 5cm}void reinitFromRequest ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a03e8085580e8f97f3177195fe2ed27e7}
Reinitialize packet address and size from the associated \hyperlink{classRequest}{Request} object, and reset other fields that may have been modified by a previous transaction. Typically called when a statically allocated Request/Packet pair is reused for multiple transactions. 


\begin{DoxyCode}
695     {
696         assert(req->hasPaddr());
697         flags = 0;
698         addr = req->getPaddr();
699         _isSecure = req->isSecure();
700         size = req->getSize();
701 
702         src = InvalidPortID;
703         dest = InvalidPortID;
704         bytesValidStart = 0;
705         bytesValidEnd = 0;
706         busFirstWordDelay = 0;
707         busLastWordDelay = 0;
708 
709         flags.set(VALID_ADDR|VALID_SIZE);
710         deleteData();
711     }
\end{DoxyCode}
\hypertarget{classPacket_a64d947d8dd285398050238bf26c1d8d2}{
\index{Packet@{Packet}!set@{set}}
\index{set@{set}!Packet@{Packet}}
\subsubsection[{set}]{\setlength{\rightskip}{0pt plus 5cm}void set (T {\em v})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a64d947d8dd285398050238bf26c1d8d2}
set the value in the data pointer to v. 


\begin{DoxyCode}
60 {
61     assert(flags.isSet(STATIC_DATA|DYNAMIC_DATA));
62     assert(sizeof(T) <= size);
63     *(T*)data = TheISA::htog(v);
64 }
\end{DoxyCode}
\hypertarget{classPacket_ac449086ed3ddac64f5f55926907b6b0c}{
\index{Packet@{Packet}!setAddr@{setAddr}}
\index{setAddr@{setAddr}!Packet@{Packet}}
\subsubsection[{setAddr}]{\setlength{\rightskip}{0pt plus 5cm}void setAddr ({\bf Addr} {\em \_\-addr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_ac449086ed3ddac64f5f55926907b6b0c}
Update the address of this packet mid-\/transaction. This is used by the address mapper to change an already set address to a new one based on the system configuration. It is intended to remap an existing address, so it asserts that the current address is valid. 


\begin{DoxyCode}
568 { assert(flags.isSet(VALID_ADDR)); addr = _addr; }
\end{DoxyCode}
\hypertarget{classPacket_a44c3e4fcce6474af8052d68e75826c13}{
\index{Packet@{Packet}!setBadAddress@{setBadAddress}}
\index{setBadAddress@{setBadAddress}!Packet@{Packet}}
\subsubsection[{setBadAddress}]{\setlength{\rightskip}{0pt plus 5cm}void setBadAddress ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a44c3e4fcce6474af8052d68e75826c13}



\begin{DoxyCode}
536     {
537         assert(isResponse());
538         cmd = MemCmd::BadAddressError;
539     }
\end{DoxyCode}
\hypertarget{classPacket_aaa0b1cd19807fc630d9331be9f5d1d36}{
\index{Packet@{Packet}!setData@{setData}}
\index{setData@{setData}!Packet@{Packet}}
\subsubsection[{setData}]{\setlength{\rightskip}{0pt plus 5cm}void setData (uint8\_\-t $\ast$ {\em p})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_aaa0b1cd19807fc630d9331be9f5d1d36}
Copy data into the packet from the provided pointer. 


\begin{DoxyCode}
837     {
838        if(getSize()==16)
839         {
840           printf("setData is OK\n");
841           }
842         if (p != getPtr<uint8_t>())
843             std::memcpy(getPtr<uint8_t>(), p, getSize());
844     }
\end{DoxyCode}
\hypertarget{classPacket_a0001ad64c160390fba5d1351862195ff}{
\index{Packet@{Packet}!setDataFromBlock@{setDataFromBlock}}
\index{setDataFromBlock@{setDataFromBlock}!Packet@{Packet}}
\subsubsection[{setDataFromBlock}]{\setlength{\rightskip}{0pt plus 5cm}void setDataFromBlock (uint8\_\-t $\ast$ {\em blk\_\-data}, \/  int {\em blkSize})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a0001ad64c160390fba5d1351862195ff}
Copy data into the packet from the provided block pointer, which is aligned to the given block size. 


\begin{DoxyCode}
852     {
853         setData(blk_data + getOffset(blkSize));
854     }
\end{DoxyCode}
\hypertarget{classPacket_a20739d8f669d352681830025686158ce}{
\index{Packet@{Packet}!setDest@{setDest}}
\index{setDest@{setDest}!Packet@{Packet}}
\subsubsection[{setDest}]{\setlength{\rightskip}{0pt plus 5cm}void setDest ({\bf PortID} {\em \_\-dest})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a20739d8f669d352681830025686158ce}


Accessor function to set the destination index of the packet. 


\begin{DoxyCode}
556 { dest = _dest; }
\end{DoxyCode}
\hypertarget{classPacket_a556d03576cc3d726f41c7e1ad6fbb64a}{
\index{Packet@{Packet}!setExpressSnoop@{setExpressSnoop}}
\index{setExpressSnoop@{setExpressSnoop}!Packet@{Packet}}
\subsubsection[{setExpressSnoop}]{\setlength{\rightskip}{0pt plus 5cm}void setExpressSnoop ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a556d03576cc3d726f41c7e1ad6fbb64a}



\begin{DoxyCode}
521 { flags.set(EXPRESS_SNOOP); }
\end{DoxyCode}
\hypertarget{classPacket_a61715904f754e7788941e838fca1dcb9}{
\index{Packet@{Packet}!setFunctionalResponseStatus@{setFunctionalResponseStatus}}
\index{setFunctionalResponseStatus@{setFunctionalResponseStatus}!Packet@{Packet}}
\subsubsection[{setFunctionalResponseStatus}]{\setlength{\rightskip}{0pt plus 5cm}void setFunctionalResponseStatus (bool {\em success})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a61715904f754e7788941e838fca1dcb9}



\begin{DoxyCode}
750     {
751         if (!success) {
752             if (isWrite()) {
753                 cmd = MemCmd::FunctionalWriteError;
754             } else {
755                 cmd = MemCmd::FunctionalReadError;
756             }
757         }
758     }
\end{DoxyCode}
\hypertarget{classPacket_a49108ef8d9510ea6b9982e9e97ca971b}{
\index{Packet@{Packet}!setPrefetchSquashed@{setPrefetchSquashed}}
\index{setPrefetchSquashed@{setPrefetchSquashed}!Packet@{Packet}}
\subsubsection[{setPrefetchSquashed}]{\setlength{\rightskip}{0pt plus 5cm}void setPrefetchSquashed ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a49108ef8d9510ea6b9982e9e97ca971b}



\begin{DoxyCode}
528 { flags.set(PREFETCH_SNOOP_SQUASH); }
\end{DoxyCode}
\hypertarget{classPacket_a9ad6fec061170a98f1358fc86738e7b3}{
\index{Packet@{Packet}!setSize@{setSize}}
\index{setSize@{setSize}!Packet@{Packet}}
\subsubsection[{setSize}]{\setlength{\rightskip}{0pt plus 5cm}void setSize (unsigned {\em size})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a9ad6fec061170a98f1358fc86738e7b3}



\begin{DoxyCode}
762     {
763         assert(!flags.isSet(VALID_SIZE));
764 
765         this->size = size;
766         flags.set(VALID_SIZE);
767     }
\end{DoxyCode}
\hypertarget{classPacket_a6e173cf473a751a0e969c1561a4184cc}{
\index{Packet@{Packet}!setSrc@{setSrc}}
\index{setSrc@{setSrc}!Packet@{Packet}}
\subsubsection[{setSrc}]{\setlength{\rightskip}{0pt plus 5cm}void setSrc ({\bf PortID} {\em \_\-src})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a6e173cf473a751a0e969c1561a4184cc}


Accessor function to set the source index of the packet. 


\begin{DoxyCode}
548 { src = _src; }
\end{DoxyCode}
\hypertarget{classPacket_ad0e298222c7b6801ea282a177fac7c39}{
\index{Packet@{Packet}!setSupplyExclusive@{setSupplyExclusive}}
\index{setSupplyExclusive@{setSupplyExclusive}!Packet@{Packet}}
\subsubsection[{setSupplyExclusive}]{\setlength{\rightskip}{0pt plus 5cm}void setSupplyExclusive ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_ad0e298222c7b6801ea282a177fac7c39}



\begin{DoxyCode}
523 { flags.set(SUPPLY_EXCLUSIVE); }
\end{DoxyCode}
\hypertarget{classPacket_ad0ca097f61c7d5d16df21635617d8d07}{
\index{Packet@{Packet}!setSuppressFuncError@{setSuppressFuncError}}
\index{setSuppressFuncError@{setSuppressFuncError}!Packet@{Packet}}
\subsubsection[{setSuppressFuncError}]{\setlength{\rightskip}{0pt plus 5cm}void setSuppressFuncError ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_ad0ca097f61c7d5d16df21635617d8d07}



\begin{DoxyCode}
526 { flags.set(SUPPRESS_FUNC_ERROR); }
\end{DoxyCode}
\hypertarget{classPacket_a298938bfa2613955b13f630ce2b591e4}{
\index{Packet@{Packet}!sharedAsserted@{sharedAsserted}}
\index{sharedAsserted@{sharedAsserted}!Packet@{Packet}}
\subsubsection[{sharedAsserted}]{\setlength{\rightskip}{0pt plus 5cm}bool sharedAsserted () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a298938bfa2613955b13f630ce2b591e4}



\begin{DoxyCode}
518 { return flags.isSet(SHARED); }
\end{DoxyCode}
\hypertarget{classPacket_a181cb46d55a9f0f933fe649c6937d037}{
\index{Packet@{Packet}!suppressFuncError@{suppressFuncError}}
\index{suppressFuncError@{suppressFuncError}!Packet@{Packet}}
\subsubsection[{suppressFuncError}]{\setlength{\rightskip}{0pt plus 5cm}bool suppressFuncError () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a181cb46d55a9f0f933fe649c6937d037}



\begin{DoxyCode}
527 { return flags.isSet(SUPPRESS_FUNC_ERROR); }
\end{DoxyCode}
\hypertarget{classPacket_a2388a13bab41142d6e403b0e5a0fb649}{
\index{Packet@{Packet}!writeData@{writeData}}
\index{writeData@{writeData}!Packet@{Packet}}
\subsubsection[{writeData}]{\setlength{\rightskip}{0pt plus 5cm}void writeData (uint8\_\-t $\ast$ {\em p})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_a2388a13bab41142d6e403b0e5a0fb649}
Copy data from the packet to the provided block pointer, which is aligned to the given block size. 


\begin{DoxyCode}
862     {
863         std::memcpy(p, getPtr<uint8_t>(), getSize());
864     }
\end{DoxyCode}
\hypertarget{classPacket_ac14ab45b04f07f4aca586b773f2252db}{
\index{Packet@{Packet}!writeDataToBlock@{writeDataToBlock}}
\index{writeDataToBlock@{writeDataToBlock}!Packet@{Packet}}
\subsubsection[{writeDataToBlock}]{\setlength{\rightskip}{0pt plus 5cm}void writeDataToBlock (uint8\_\-t $\ast$ {\em blk\_\-data}, \/  int {\em blkSize})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPacket_ac14ab45b04f07f4aca586b773f2252db}
Copy data from the packet to the memory at the provided pointer. 


\begin{DoxyCode}
871     {
872         writeData(blk_data + getOffset(blkSize));
873     }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classPacket_a8575be38d53d73568838d5805df1cf63}{
\index{Packet@{Packet}!\_\-isSecure@{\_\-isSecure}}
\index{\_\-isSecure@{\_\-isSecure}!Packet@{Packet}}
\subsubsection[{\_\-isSecure}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \_\-isSecure}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPacket_a8575be38d53d73568838d5805df1cf63}


True if the request targets the secure memory space. \hypertarget{classPacket_a0bb77b4ba61e408313e1118250f9278c}{
\index{Packet@{Packet}!addr@{addr}}
\index{addr@{addr}!Packet@{Packet}}
\subsubsection[{addr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf addr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPacket_a0bb77b4ba61e408313e1118250f9278c}
The address of the request. This address could be virtual or physical, depending on the system configuration. \hypertarget{classPacket_a861863488f543d1fd5aaf422469ba27a}{
\index{Packet@{Packet}!ARRAY\_\-DATA@{ARRAY\_\-DATA}}
\index{ARRAY\_\-DATA@{ARRAY\_\-DATA}!Packet@{Packet}}
\subsubsection[{ARRAY\_\-DATA}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf FlagsType} {\bf ARRAY\_\-DATA} = 0x00004000\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classPacket_a861863488f543d1fd5aaf422469ba27a}
the data pointer points to an array (thus delete \mbox{[}\mbox{]}) needs to be called on it rather than simply delete. \hypertarget{classPacket_af8986a05caa6c5b96b0b01bb6cf47772}{
\index{Packet@{Packet}!busFirstWordDelay@{busFirstWordDelay}}
\index{busFirstWordDelay@{busFirstWordDelay}!Packet@{Packet}}
\subsubsection[{busFirstWordDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf busFirstWordDelay}}}
\label{classPacket_af8986a05caa6c5b96b0b01bb6cf47772}
The extra delay from seeing the packet until the first word is transmitted by the bus that provided it (if any). This delay is used to communicate the bus waiting time to the neighbouring object (e.g. a cache) that actually makes the packet wait. As the delay is relative, a 32-\/bit unsigned should be sufficient. \hypertarget{classPacket_a7bf8ae0a056329f751eda8b39ca4c268}{
\index{Packet@{Packet}!busLastWordDelay@{busLastWordDelay}}
\index{busLastWordDelay@{busLastWordDelay}!Packet@{Packet}}
\subsubsection[{busLastWordDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf busLastWordDelay}}}
\label{classPacket_a7bf8ae0a056329f751eda8b39ca4c268}
The extra delay from seeing the packet until the last word is transmitted by the bus that provided it (if any). Similar to the first word time, this is used to make up for the fact that the bus does not make the packet wait. As the delay is relative, a 32-\/bit unsigned should be sufficient. \hypertarget{classPacket_ae0d66052bfed50bce9fd141f1728b755}{
\index{Packet@{Packet}!bytesValidEnd@{bytesValidEnd}}
\index{bytesValidEnd@{bytesValidEnd}!Packet@{Packet}}
\subsubsection[{bytesValidEnd}]{\setlength{\rightskip}{0pt plus 5cm}uint16\_\-t {\bf bytesValidEnd}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPacket_ae0d66052bfed50bce9fd141f1728b755}
\hypertarget{classPacket_a5a3c6bfd022f6812ff7f168c5233ad23}{
\index{Packet@{Packet}!bytesValidStart@{bytesValidStart}}
\index{bytesValidStart@{bytesValidStart}!Packet@{Packet}}
\subsubsection[{bytesValidStart}]{\setlength{\rightskip}{0pt plus 5cm}uint16\_\-t {\bf bytesValidStart}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPacket_a5a3c6bfd022f6812ff7f168c5233ad23}
These values specify the range of bytes found that satisfy a functional read. \hypertarget{classPacket_af88eb56d484b750933cd2ea86594f001}{
\index{Packet@{Packet}!cmd@{cmd}}
\index{cmd@{cmd}!Packet@{Packet}}
\subsubsection[{cmd}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemCmd} {\bf cmd}}}
\label{classPacket_af88eb56d484b750933cd2ea86594f001}


The command field of the packet. \hypertarget{classPacket_af494771dbda61056aaad3f6ad7e2d84d}{
\index{Packet@{Packet}!COPY\_\-FLAGS@{COPY\_\-FLAGS}}
\index{COPY\_\-FLAGS@{COPY\_\-FLAGS}!Packet@{Packet}}
\subsubsection[{COPY\_\-FLAGS}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf FlagsType} {\bf COPY\_\-FLAGS} = 0x0000000F\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classPacket_af494771dbda61056aaad3f6ad7e2d84d}
\hypertarget{classPacket_a60f451ea06dccaf49b32633f67e7b16e}{
\index{Packet@{Packet}!data@{data}}
\index{data@{data}!Packet@{Packet}}
\subsubsection[{data}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketDataPtr} {\bf data}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPacket_a60f451ea06dccaf49b32633f67e7b16e}
A pointer to the data being transfered. It can be differnt sizes at each level of the heirarchy so it belongs in the packet, not request. This may or may not be populated when a responder recieves the packet. If not populated it memory should be allocated. \hypertarget{classPacket_a826324ce6e458b38e4010b9e0ca8f14a}{
\index{Packet@{Packet}!dest@{dest}}
\index{dest@{dest}!Packet@{Packet}}
\subsubsection[{dest}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PortID} {\bf dest}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPacket_a826324ce6e458b38e4010b9e0ca8f14a}
Destination port identifier that is present on all response packets that passed through a multiplexing component as a request packet. The source port identifier is turned into a destination port identifier when the packet is turned into a response, and the destination is used, e.g. by the bus, to select the appropriate path through the interconnect. \hypertarget{classPacket_a0100d751aaef8a927f7ba551550d142b}{
\index{Packet@{Packet}!DYNAMIC\_\-DATA@{DYNAMIC\_\-DATA}}
\index{DYNAMIC\_\-DATA@{DYNAMIC\_\-DATA}!Packet@{Packet}}
\subsubsection[{DYNAMIC\_\-DATA}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf FlagsType} {\bf DYNAMIC\_\-DATA} = 0x00002000\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classPacket_a0100d751aaef8a927f7ba551550d142b}
The data pointer points to a value that should be freed when the packet is destroyed. \hypertarget{classPacket_a0b5a042e640242aeaeeebef73a69df26}{
\index{Packet@{Packet}!EXPRESS\_\-SNOOP@{EXPRESS\_\-SNOOP}}
\index{EXPRESS\_\-SNOOP@{EXPRESS\_\-SNOOP}!Packet@{Packet}}
\subsubsection[{EXPRESS\_\-SNOOP}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf FlagsType} {\bf EXPRESS\_\-SNOOP} = 0x00000002\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classPacket_a0b5a042e640242aeaeeebef73a69df26}


Special timing-\/mode atomic snoop for multi-\/level coherence. \hypertarget{classPacket_aa991e2b209ef26272bf4fd920777bcda}{
\index{Packet@{Packet}!flags@{flags}}
\index{flags@{flags}!Packet@{Packet}}
\subsubsection[{flags}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Flags} {\bf flags}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPacket_aa991e2b209ef26272bf4fd920777bcda}
\hypertarget{classPacket_aae6e80e571cf0888e7583aa556c3f171}{
\index{Packet@{Packet}!MEM\_\-INHIBIT@{MEM\_\-INHIBIT}}
\index{MEM\_\-INHIBIT@{MEM\_\-INHIBIT}!Packet@{Packet}}
\subsubsection[{MEM\_\-INHIBIT}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf FlagsType} {\bf MEM\_\-INHIBIT} = 0x00000008\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classPacket_aae6e80e571cf0888e7583aa556c3f171}
\hypertarget{classPacket_a98424e5b505c05a999a7e03dd4caa0fa}{
\index{Packet@{Packet}!origCmd@{origCmd}}
\index{origCmd@{origCmd}!Packet@{Packet}}
\subsubsection[{origCmd}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemCmd} {\bf origCmd}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPacket_a98424e5b505c05a999a7e03dd4caa0fa}
The original value of the command field. Only valid when the current command field is an error condition; in that case, the previous contents of the command field are copied here. This field is $\ast$not$\ast$ set on non-\/error responses. \hypertarget{classPacket_ae2bdbe737a4cf46b8bedebcaa602d23a}{
\index{Packet@{Packet}!PREFETCH\_\-SNOOP\_\-SQUASH@{PREFETCH\_\-SNOOP\_\-SQUASH}}
\index{PREFETCH\_\-SNOOP\_\-SQUASH@{PREFETCH\_\-SNOOP\_\-SQUASH}!Packet@{Packet}}
\subsubsection[{PREFETCH\_\-SNOOP\_\-SQUASH}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf FlagsType} {\bf PREFETCH\_\-SNOOP\_\-SQUASH} = 0x00010000\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classPacket_ae2bdbe737a4cf46b8bedebcaa602d23a}
\hypertarget{classPacket_aa377b218207b557079f48b02e7acf167}{
\index{Packet@{Packet}!PRIVATE\_\-FLAGS@{PRIVATE\_\-FLAGS}}
\index{PRIVATE\_\-FLAGS@{PRIVATE\_\-FLAGS}!Packet@{Packet}}
\subsubsection[{PRIVATE\_\-FLAGS}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf FlagsType} {\bf PRIVATE\_\-FLAGS} = 0x00007F0F\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classPacket_aa377b218207b557079f48b02e7acf167}
\hypertarget{classPacket_aedf1d129016ac677627a1e3c2ee6b59a}{
\index{Packet@{Packet}!PUBLIC\_\-FLAGS@{PUBLIC\_\-FLAGS}}
\index{PUBLIC\_\-FLAGS@{PUBLIC\_\-FLAGS}!Packet@{Packet}}
\subsubsection[{PUBLIC\_\-FLAGS}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf FlagsType} {\bf PUBLIC\_\-FLAGS} = 0x00000000\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classPacket_aedf1d129016ac677627a1e3c2ee6b59a}
\hypertarget{classPacket_a956cd41d82347558b9c0a5b0474903f2}{
\index{Packet@{Packet}!req@{req}}
\index{req@{req}!Packet@{Packet}}
\subsubsection[{req}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RequestPtr} {\bf req}}}
\label{classPacket_a956cd41d82347558b9c0a5b0474903f2}


A pointer to the original request. \hypertarget{classPacket_a983ade0479f946c813284dcc65073367}{
\index{Packet@{Packet}!senderState@{senderState}}
\index{senderState@{senderState}!Packet@{Packet}}
\subsubsection[{senderState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SenderState}$\ast$ {\bf senderState}}}
\label{classPacket_a983ade0479f946c813284dcc65073367}
This packet's sender state. Devices should use dynamic\_\-cast$<$$>$ to cast to the state appropriate to the sender. The intent of this variable is to allow a device to attach extra information to a request. A response packet must return the sender state that was attached to the original request (even if a new packet is created). \hypertarget{classPacket_a3f87955b81ea6f9d7f89d5ab033074f9}{
\index{Packet@{Packet}!SHARED@{SHARED}}
\index{SHARED@{SHARED}!Packet@{Packet}}
\subsubsection[{SHARED}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf FlagsType} {\bf SHARED} = 0x00000001\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classPacket_a3f87955b81ea6f9d7f89d5ab033074f9}
\hypertarget{classPacket_a245260f6f74972558f61b85227df5aae}{
\index{Packet@{Packet}!size@{size}}
\index{size@{size}!Packet@{Packet}}
\subsubsection[{size}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf size}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPacket_a245260f6f74972558f61b85227df5aae}


The size of the request or transfer. \hypertarget{classPacket_ae47dce578a23ce59793947e009b087e3}{
\index{Packet@{Packet}!src@{src}}
\index{src@{src}!Packet@{Packet}}
\subsubsection[{src}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PortID} {\bf src}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPacket_ae47dce578a23ce59793947e009b087e3}
Source port identifier set on a request packet to enable appropriate routing of the responses. The source port identifier is set by any multiplexing component, e.g. a bus, as the timing responses need this information to be routed back to the appropriate port at a later point in time. The field can be updated (over-\/written) as the request packet passes through additional multiplexing components, and it is their responsibility to remember the original source port identifier, for example by using an appropriate sender state. The latter is done in the cache and bridge. \hypertarget{classPacket_a1736ff591124f446ce3ddbb16fb3f505}{
\index{Packet@{Packet}!STATIC\_\-DATA@{STATIC\_\-DATA}}
\index{STATIC\_\-DATA@{STATIC\_\-DATA}!Packet@{Packet}}
\subsubsection[{STATIC\_\-DATA}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf FlagsType} {\bf STATIC\_\-DATA} = 0x00001000\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classPacket_a1736ff591124f446ce3ddbb16fb3f505}
Is the data pointer set to a value that shouldn't be freed when the packet is destroyed? \hypertarget{classPacket_a064f460e5a6ed3522adc424c5d31646a}{
\index{Packet@{Packet}!SUPPLY\_\-EXCLUSIVE@{SUPPLY\_\-EXCLUSIVE}}
\index{SUPPLY\_\-EXCLUSIVE@{SUPPLY\_\-EXCLUSIVE}!Packet@{Packet}}
\subsubsection[{SUPPLY\_\-EXCLUSIVE}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf FlagsType} {\bf SUPPLY\_\-EXCLUSIVE} = 0x00000004\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classPacket_a064f460e5a6ed3522adc424c5d31646a}
Does supplier have exclusive copy? Useful for multi-\/level coherence. \hypertarget{classPacket_a5e3b50f943fac776d71dbe3ff03cc7a5}{
\index{Packet@{Packet}!SUPPRESS\_\-FUNC\_\-ERROR@{SUPPRESS\_\-FUNC\_\-ERROR}}
\index{SUPPRESS\_\-FUNC\_\-ERROR@{SUPPRESS\_\-FUNC\_\-ERROR}!Packet@{Packet}}
\subsubsection[{SUPPRESS\_\-FUNC\_\-ERROR}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf FlagsType} {\bf SUPPRESS\_\-FUNC\_\-ERROR} = 0x00008000\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classPacket_a5e3b50f943fac776d71dbe3ff03cc7a5}
suppress the error if this packet encounters a functional access failure. \hypertarget{classPacket_ac99ea8fdca503270882373e7a801a2b6}{
\index{Packet@{Packet}!VALID\_\-ADDR@{VALID\_\-ADDR}}
\index{VALID\_\-ADDR@{VALID\_\-ADDR}!Packet@{Packet}}
\subsubsection[{VALID\_\-ADDR}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf FlagsType} {\bf VALID\_\-ADDR} = 0x00000100\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classPacket_ac99ea8fdca503270882373e7a801a2b6}


Are the 'addr' and 'size' fields valid? \hypertarget{classPacket_a3e2067968b47a2acb352b48bced164cf}{
\index{Packet@{Packet}!VALID\_\-SIZE@{VALID\_\-SIZE}}
\index{VALID\_\-SIZE@{VALID\_\-SIZE}!Packet@{Packet}}
\subsubsection[{VALID\_\-SIZE}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf FlagsType} {\bf VALID\_\-SIZE} = 0x00000200\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classPacket_a3e2067968b47a2acb352b48bced164cf}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{packet_8hh}{packet.hh}\item 
mem/\hyperlink{packet_8cc}{packet.cc}\item 
mem/\hyperlink{packet__access_8hh}{packet\_\-access.hh}\end{DoxyCompactItemize}
