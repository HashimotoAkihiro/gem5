\hypertarget{classKvm}{
\section{クラス Kvm}
\label{classKvm}\index{Kvm@{Kvm}}
}


{\ttfamily \#include $<$vm.hh$>$}\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classstd_1_1vector}{std::vector}$<$ struct kvm\_\-cpuid\_\-entry2 $>$ \hyperlink{classKvm_af9d6fd6949b666ab0f41114891c201db}{CPUIDVector}
\item 
typedef \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} $>$ \hyperlink{classKvm_ab2ddfab51860a21d04f8ca0abe33a77f}{MSRIndexVector}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{classKvm_af634ce04aefb47ce4de9d029a9bc0642}{$\sim$Kvm} ()
\item 
\hyperlink{classKvm}{Kvm} $\ast$ \hyperlink{classKvm_a5a41f15f5b11ddab46bb5622409aea52}{create} ()
\item 
int \hyperlink{classKvm_a5bbf835d489e2bd0242d5b3840aa1304}{getAPIVersion} () const 
\item 
int \hyperlink{classKvm_a554cb4dd3512dba2169997c9c804d4ec}{getVCPUMMapSize} () const 
\item 
bool \hyperlink{classKvm_a74bec0050eeeffd21d5f85cb929c802b}{getSupportedCPUID} (struct kvm\_\-cpuid2 \&cpuid) const 
\item 
const \hyperlink{classstd_1_1vector}{CPUIDVector} \& \hyperlink{classKvm_aa0fc800a2144e592218a484d24b94f0f}{getSupportedCPUID} () const 
\item 
bool \hyperlink{classKvm_a3ae50dd2ddc035995d7578481b35e877}{getSupportedMSRs} (struct kvm\_\-msr\_\-list \&msrs) const 
\item 
const \hyperlink{classstd_1_1vector}{MSRIndexVector} \& \hyperlink{classKvm_ab43b4ff4aabd353eef30f8defba2718d}{getSupportedMSRs} () const 
\end{DoxyCompactItemize}
\begin{Indent}{\bf }\par
{\em \label{_amgrpd41d8cd98f00b204e9800998ecf8427e}
 }\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classKvm_a3f08fc1c466eca4129d52fa3b21023d1}{capUserMemory} () const 
\item 
bool \hyperlink{classKvm_a8bc7fe4f8395a54ef945822211a57228}{capSetTSSAddress} () const 
\item 
bool \hyperlink{classKvm_a6db5aefbe1a9535f5124ef07a04e23a5}{capExtendedCPUID} () const 
\item 
bool \hyperlink{classKvm_acf36e247bf7857c1c7b1e260eff7f7db}{capUserNMI} () const 
\item 
int \hyperlink{classKvm_a23013f2d078b52428edae7ecfb6b5b7b}{capCoalescedMMIO} () const 
\item 
bool \hyperlink{classKvm_af1ad3b73711f45008bcb240d012987f7}{capOneReg} () const 
\item 
bool \hyperlink{classKvm_ab3e6d2bb7ea83c6cdc20369bf3a274a6}{capIRQChip} () const 
\item 
bool \hyperlink{classKvm_a75f29a9991c1117d5182abfb23bfbc92}{capVCPUEvents} () const 
\item 
bool \hyperlink{classKvm_a4e15b92a17300f1d37ceca6e4a984086}{capDebugRegs} () const 
\item 
bool \hyperlink{classKvm_aa9b34836edde016c16df3006fb33b0a9}{capXCRs} () const 
\item 
bool \hyperlink{classKvm_a9c6bbe65d43e3f2708723fc21f00b4cd}{capXSave} () const 
\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classKvm_a8e6e0d0db01a127dd0798b0a87263a29}{checkExtension} (int extension) const 
\item 
int \hyperlink{group__KvmIoctl_ga106fe09b5e87d6c14884f8ffff7b338a}{ioctl} (int request, long p1) const 
\item 
int \hyperlink{group__KvmIoctl_ga89db87cb31fe2ba732de8fa68c8bd1f1}{ioctl} (int request, void $\ast$p1) const 
\item 
int \hyperlink{group__KvmIoctl_ga32cd3b0742689c29c9ab9e3e03feb5f2}{ioctl} (int request) const 
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classKvm_ac52c88ab9138b51acbd7dedc0b4203ea}{Kvm} ()
\item 
\hyperlink{classKvm_a74d2e5969f68c33262ef78b294a41555}{Kvm} (const \hyperlink{classKvm}{Kvm} \&kvm)
\item 
\hyperlink{classKvm}{Kvm} \& \hyperlink{classKvm_a99c5e2a3a05865b3109843939909b4f6}{operator=} (const \hyperlink{classKvm}{Kvm} \&kvm)
\item 
int \hyperlink{classKvm_acac1d5ae396f1e3fb2804d78bc986db2}{createVM} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classKvm_af331fe85a8df29abc3f2d301b0afddc2}{kvmFD}
\item 
int \hyperlink{classKvm_ab3562fc781db97a1faac4c863e257ca9}{apiVersion}
\item 
int \hyperlink{classKvm_a0915679bdc25b2c015f15996f6d4ff6d}{vcpuMMapSize}
\item 
\hyperlink{classstd_1_1vector}{CPUIDVector} \hyperlink{classKvm_a3d5dc75656640e2eb3b52c27e4497b75}{supportedCPUIDCache}
\item 
\hyperlink{classstd_1_1vector}{MSRIndexVector} \hyperlink{classKvm_a5553ee613be7488e7c7c28058dc7d487}{supportedMSRCache}
\end{DoxyCompactItemize}
\subsection*{Static Private 変数}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classKvm}{Kvm} $\ast$ \hyperlink{classKvm_a64c6606364bd27581f929800703a402e}{instance} = NULL
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classKvm_a9210c8f6e282c397940f37aff4d6c32d}{KvmVM}
\end{DoxyCompactItemize}


\subsection{説明}
KVM parent interface

The main \hyperlink{classKvm}{Kvm} object is used to provide functionality that is not specific to a VM or CPU. For example, it allows checking of the optional features and creation of VM containers. 

\subsection{型定義}
\hypertarget{classKvm_af9d6fd6949b666ab0f41114891c201db}{
\index{Kvm@{Kvm}!CPUIDVector@{CPUIDVector}}
\index{CPUIDVector@{CPUIDVector}!Kvm@{Kvm}}
\subsubsection[{CPUIDVector}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::vector}$<$struct kvm\_\-cpuid\_\-entry2$>$ {\bf CPUIDVector}}}
\label{classKvm_af9d6fd6949b666ab0f41114891c201db}
\hypertarget{classKvm_ab2ddfab51860a21d04f8ca0abe33a77f}{
\index{Kvm@{Kvm}!MSRIndexVector@{MSRIndexVector}}
\index{MSRIndexVector@{MSRIndexVector}!Kvm@{Kvm}}
\subsubsection[{MSRIndexVector}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::vector}$<${\bf uint32\_\-t}$>$ {\bf MSRIndexVector}}}
\label{classKvm_ab2ddfab51860a21d04f8ca0abe33a77f}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classKvm_af634ce04aefb47ce4de9d029a9bc0642}{
\index{Kvm@{Kvm}!$\sim$Kvm@{$\sim$Kvm}}
\index{$\sim$Kvm@{$\sim$Kvm}!Kvm@{Kvm}}
\subsubsection[{$\sim$Kvm}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf Kvm} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classKvm_af634ce04aefb47ce4de9d029a9bc0642}



\begin{DoxyCode}
80 {
81     close(kvmFD);
82 }
\end{DoxyCode}
\hypertarget{classKvm_ac52c88ab9138b51acbd7dedc0b4203ea}{
\index{Kvm@{Kvm}!Kvm@{Kvm}}
\index{Kvm@{Kvm}!Kvm@{Kvm}}
\subsubsection[{Kvm}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Kvm} ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classKvm_ac52c88ab9138b51acbd7dedc0b4203ea}



\begin{DoxyCode}
64     : kvmFD(-1), apiVersion(-1), vcpuMMapSize(0)
65 {
66     kvmFD = ::open("/dev/kvm", O_RDWR);
67     if (kvmFD == -1)
68         fatal("KVM: Failed to open /dev/kvm\n");
69 
70     apiVersion = ioctl(KVM_GET_API_VERSION);
71     if (apiVersion != EXPECTED_KVM_API_VERSION)
72         fatal("KVM: Incompatible API version\n");
73 
74     vcpuMMapSize = ioctl(KVM_GET_VCPU_MMAP_SIZE);
75     if (vcpuMMapSize == -1)
76         panic("KVM: Failed to get virtual CPU MMAP size\n");
77 }
\end{DoxyCode}
\hypertarget{classKvm_a74d2e5969f68c33262ef78b294a41555}{
\index{Kvm@{Kvm}!Kvm@{Kvm}}
\index{Kvm@{Kvm}!Kvm@{Kvm}}
\subsubsection[{Kvm}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Kvm} (const {\bf Kvm} \& {\em kvm})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classKvm_a74d2e5969f68c33262ef78b294a41555}


\subsection{関数}
\hypertarget{classKvm_a23013f2d078b52428edae7ecfb6b5b7b}{
\index{Kvm@{Kvm}!capCoalescedMMIO@{capCoalescedMMIO}}
\index{capCoalescedMMIO@{capCoalescedMMIO}!Kvm@{Kvm}}
\subsubsection[{capCoalescedMMIO}]{\setlength{\rightskip}{0pt plus 5cm}int capCoalescedMMIO () const}}
\label{classKvm_a23013f2d078b52428edae7ecfb6b5b7b}
\hyperlink{classCheck}{Check} if coalesced MMIO is supported and which page in the MMAP'ed structure it stores requests in.

\begin{DoxyReturn}{戻り値}
Offset (in pages) into the mmap'ed vCPU area where the MMIO buffer is stored. 0 if unsupported. 
\end{DoxyReturn}



\begin{DoxyCode}
123 {
124     return checkExtension(KVM_CAP_COALESCED_MMIO);
125 }
\end{DoxyCode}
\hypertarget{classKvm_a4e15b92a17300f1d37ceca6e4a984086}{
\index{Kvm@{Kvm}!capDebugRegs@{capDebugRegs}}
\index{capDebugRegs@{capDebugRegs}!Kvm@{Kvm}}
\subsubsection[{capDebugRegs}]{\setlength{\rightskip}{0pt plus 5cm}bool capDebugRegs () const}}
\label{classKvm_a4e15b92a17300f1d37ceca6e4a984086}
Support for getting and setting the kvm\_\-debugregs structure. 


\begin{DoxyCode}
155 {
156 #ifdef KVM_CAP_DEBUGREGS
157     return checkExtension(KVM_CAP_DEBUGREGS) != 0;
158 #else
159     return false;
160 #endif
161 }
\end{DoxyCode}
\hypertarget{classKvm_a6db5aefbe1a9535f5124ef07a04e23a5}{
\index{Kvm@{Kvm}!capExtendedCPUID@{capExtendedCPUID}}
\index{capExtendedCPUID@{capExtendedCPUID}!Kvm@{Kvm}}
\subsubsection[{capExtendedCPUID}]{\setlength{\rightskip}{0pt plus 5cm}bool capExtendedCPUID () const}}
\label{classKvm_a6db5aefbe1a9535f5124ef07a04e23a5}
Support for BaseKvmCPU::setCPUID2 and \hyperlink{classKvm_a74bec0050eeeffd21d5f85cb929c802b}{getSupportedCPUID()}. 


\begin{DoxyCode}
107 {
108     return checkExtension(KVM_CAP_EXT_CPUID) != 0;
109 }
\end{DoxyCode}
\hypertarget{classKvm_ab3e6d2bb7ea83c6cdc20369bf3a274a6}{
\index{Kvm@{Kvm}!capIRQChip@{capIRQChip}}
\index{capIRQChip@{capIRQChip}!Kvm@{Kvm}}
\subsubsection[{capIRQChip}]{\setlength{\rightskip}{0pt plus 5cm}bool capIRQChip () const}}
\label{classKvm_ab3e6d2bb7ea83c6cdc20369bf3a274a6}
Support for creating an in-\/kernel IRQ chip model.

\begin{DoxySeeAlso}{参照}
\hyperlink{group__KvmInterrupts_ga75f1140369bf3942bb93a75d1b3de2c9}{KvmVM::createIRQChip()} 
\end{DoxySeeAlso}



\begin{DoxyCode}
139 {
140     return checkExtension(KVM_CAP_IRQCHIP) != 0;
141 }
\end{DoxyCode}
\hypertarget{classKvm_af1ad3b73711f45008bcb240d012987f7}{
\index{Kvm@{Kvm}!capOneReg@{capOneReg}}
\index{capOneReg@{capOneReg}!Kvm@{Kvm}}
\subsubsection[{capOneReg}]{\setlength{\rightskip}{0pt plus 5cm}bool capOneReg () const}}
\label{classKvm_af1ad3b73711f45008bcb240d012987f7}
Support for reading and writing single registers.

\begin{DoxySeeAlso}{参照}
\hyperlink{classBaseKvmCPU_ab5a47c64ebf5a4de2539c6f71f7acc51}{BaseKvmCPU::getOneReg()}, and \hyperlink{classBaseKvmCPU_ad96695f9596f808056054f3c2026b818}{BaseKvmCPU::setOneReg()} 
\end{DoxySeeAlso}



\begin{DoxyCode}
129 {
130 #ifdef KVM_CAP_ONE_REG
131     return checkExtension(KVM_CAP_ONE_REG) != 0;
132 #else
133     return false;
134 #endif
135 }
\end{DoxyCode}
\hypertarget{classKvm_a8bc7fe4f8395a54ef945822211a57228}{
\index{Kvm@{Kvm}!capSetTSSAddress@{capSetTSSAddress}}
\index{capSetTSSAddress@{capSetTSSAddress}!Kvm@{Kvm}}
\subsubsection[{capSetTSSAddress}]{\setlength{\rightskip}{0pt plus 5cm}bool capSetTSSAddress () const}}
\label{classKvm_a8bc7fe4f8395a54ef945822211a57228}
Support for \hyperlink{classKvmVM_a04e3bed0038549a704fe5c04015ce46d}{KvmVM::setTSSAddress()} 


\begin{DoxyCode}
101 {
102     return checkExtension(KVM_CAP_SET_TSS_ADDR) != 0;
103 }
\end{DoxyCode}
\hypertarget{classKvm_a3f08fc1c466eca4129d52fa3b21023d1}{
\index{Kvm@{Kvm}!capUserMemory@{capUserMemory}}
\index{capUserMemory@{capUserMemory}!Kvm@{Kvm}}
\subsubsection[{capUserMemory}]{\setlength{\rightskip}{0pt plus 5cm}bool capUserMemory () const}}
\label{classKvm_a3f08fc1c466eca4129d52fa3b21023d1}
Support for \hyperlink{classKvmVM_a2d2ed492c91fc674db226f86fae39127}{KvmVM::setUserMemoryRegion()} 


\begin{DoxyCode}
95 {
96     return checkExtension(KVM_CAP_USER_MEMORY) != 0;
97 }
\end{DoxyCode}
\hypertarget{classKvm_acf36e247bf7857c1c7b1e260eff7f7db}{
\index{Kvm@{Kvm}!capUserNMI@{capUserNMI}}
\index{capUserNMI@{capUserNMI}!Kvm@{Kvm}}
\subsubsection[{capUserNMI}]{\setlength{\rightskip}{0pt plus 5cm}bool capUserNMI () const}}
\label{classKvm_acf36e247bf7857c1c7b1e260eff7f7db}
Support for \hyperlink{group__KvmInterrupts_gabc700469cba2d4bba666902e552e7c2e}{BaseKvmCPU::kvmNonMaskableInterrupt()}. 


\begin{DoxyCode}
113 {
114 #ifdef KVM_CAP_USER_NMI
115     return checkExtension(KVM_CAP_USER_NMI) != 0;
116 #else
117     return false;
118 #endif
119 }
\end{DoxyCode}
\hypertarget{classKvm_a75f29a9991c1117d5182abfb23bfbc92}{
\index{Kvm@{Kvm}!capVCPUEvents@{capVCPUEvents}}
\index{capVCPUEvents@{capVCPUEvents}!Kvm@{Kvm}}
\subsubsection[{capVCPUEvents}]{\setlength{\rightskip}{0pt plus 5cm}bool capVCPUEvents () const}}
\label{classKvm_a75f29a9991c1117d5182abfb23bfbc92}
Support for getting and setting the kvm\_\-vcpu\_\-events structure. 


\begin{DoxyCode}
145 {
146 #ifdef KVM_CAP_VCPU_EVENTS
147     return checkExtension(KVM_CAP_VCPU_EVENTS) != 0;
148 #else
149     return false;
150 #endif
151 }
\end{DoxyCode}
\hypertarget{classKvm_aa9b34836edde016c16df3006fb33b0a9}{
\index{Kvm@{Kvm}!capXCRs@{capXCRs}}
\index{capXCRs@{capXCRs}!Kvm@{Kvm}}
\subsubsection[{capXCRs}]{\setlength{\rightskip}{0pt plus 5cm}bool capXCRs () const}}
\label{classKvm_aa9b34836edde016c16df3006fb33b0a9}
Support for getting and setting the x86 XCRs. 


\begin{DoxyCode}
165 {
166 #ifdef KVM_CAP_XCRS
167     return checkExtension(KVM_CAP_XCRS) != 0;
168 #else
169     return false;
170 #endif
171 }
\end{DoxyCode}
\hypertarget{classKvm_a9c6bbe65d43e3f2708723fc21f00b4cd}{
\index{Kvm@{Kvm}!capXSave@{capXSave}}
\index{capXSave@{capXSave}!Kvm@{Kvm}}
\subsubsection[{capXSave}]{\setlength{\rightskip}{0pt plus 5cm}bool capXSave () const}}
\label{classKvm_a9c6bbe65d43e3f2708723fc21f00b4cd}
Support for getting and setting the kvm\_\-xsave structure. 


\begin{DoxyCode}
175 {
176 #ifdef KVM_CAP_XSAVE
177     return checkExtension(KVM_CAP_XSAVE) != 0;
178 #else
179     return false;
180 #endif
181 }
\end{DoxyCode}
\hypertarget{classKvm_a8e6e0d0db01a127dd0798b0a87263a29}{
\index{Kvm@{Kvm}!checkExtension@{checkExtension}}
\index{checkExtension@{checkExtension}!Kvm@{Kvm}}
\subsubsection[{checkExtension}]{\setlength{\rightskip}{0pt plus 5cm}int checkExtension (int {\em extension}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classKvm_a8e6e0d0db01a127dd0798b0a87263a29}
\hyperlink{classCheck}{Check} for the presence of an extension to the KVM API.

The return value depends on the extension, but is always zero if it is unsupported or positive otherwise. Some extensions use the return value provide additional data about the extension.

\begin{DoxyReturn}{戻り値}
0 if the extension is unsupported, positive integer otherwise. 
\end{DoxyReturn}



\begin{DoxyCode}
256 {
257     int ret = ioctl(KVM_CHECK_EXTENSION, extension);
258     if (ret == -1)
259         panic("KVM: ioctl failed when checking for extension\n");
260     return ret;
261 }
\end{DoxyCode}
\hypertarget{classKvm_a5a41f15f5b11ddab46bb5622409aea52}{
\index{Kvm@{Kvm}!create@{create}}
\index{create@{create}!Kvm@{Kvm}}
\subsubsection[{create}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Kvm} $\ast$ create ()}}
\label{classKvm_a5a41f15f5b11ddab46bb5622409aea52}



\begin{DoxyCode}
86 {
87     if (!instance)
88         instance = new Kvm();
89 
90     return instance;
91 }
\end{DoxyCode}
\hypertarget{classKvm_acac1d5ae396f1e3fb2804d78bc986db2}{
\index{Kvm@{Kvm}!createVM@{createVM}}
\index{createVM@{createVM}!Kvm@{Kvm}}
\subsubsection[{createVM}]{\setlength{\rightskip}{0pt plus 5cm}int createVM ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classKvm_acac1d5ae396f1e3fb2804d78bc986db2}
Create a KVM Virtual Machine

\begin{DoxyReturn}{戻り値}
File descriptor pointing to the VM 
\end{DoxyReturn}



\begin{DoxyCode}
273 {
274     int vmFD;
275 
276     vmFD = ioctl(KVM_CREATE_VM);
277     if (vmFD == -1)
278         panic("Failed to create KVM VM\n");
279 
280     return vmFD;
281 }
\end{DoxyCode}
\hypertarget{classKvm_a5bbf835d489e2bd0242d5b3840aa1304}{
\index{Kvm@{Kvm}!getAPIVersion@{getAPIVersion}}
\index{getAPIVersion@{getAPIVersion}!Kvm@{Kvm}}
\subsubsection[{getAPIVersion}]{\setlength{\rightskip}{0pt plus 5cm}int getAPIVersion () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classKvm_a5bbf835d489e2bd0242d5b3840aa1304}
Get the version of the KVM API implemented by the kernel. 


\begin{DoxyCode}
85 { return apiVersion; }
\end{DoxyCode}
\hypertarget{classKvm_aa0fc800a2144e592218a484d24b94f0f}{
\index{Kvm@{Kvm}!getSupportedCPUID@{getSupportedCPUID}}
\index{getSupportedCPUID@{getSupportedCPUID}!Kvm@{Kvm}}
\subsubsection[{getSupportedCPUID}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Kvm::CPUIDVector} \& getSupportedCPUID () const}}
\label{classKvm_aa0fc800a2144e592218a484d24b94f0f}
Get the CPUID features supported by the hardware and \hyperlink{classKvm}{Kvm}.

\begin{DoxyNote}{覚え書き}
Requires \hyperlink{classKvm_a6db5aefbe1a9535f5124ef07a04e23a5}{capExtendedCPUID()}.

This method uses an internal cache to minimize the number of calls into the kernel.
\end{DoxyNote}
\begin{DoxyReturn}{戻り値}
Reference to cached MSR index list. 
\end{DoxyReturn}



\begin{DoxyCode}
201 {
202     if (supportedCPUIDCache.empty()) {
203         std::unique_ptr<struct kvm_cpuid2> cpuid;
204         int i(1);
205         do {
206             cpuid.reset((struct kvm_cpuid2 *)operator new(
207                             sizeof(kvm_cpuid2) + i * sizeof(kvm_cpuid_entry2)));
208 
209             cpuid->nent = i;
210             ++i;
211         } while (!getSupportedCPUID(*cpuid));
212         supportedCPUIDCache.assign(cpuid->entries,
213                                    cpuid->entries + cpuid->nent);
214     }
215 
216     return supportedCPUIDCache;
217 }
\end{DoxyCode}
\hypertarget{classKvm_a74bec0050eeeffd21d5f85cb929c802b}{
\index{Kvm@{Kvm}!getSupportedCPUID@{getSupportedCPUID}}
\index{getSupportedCPUID@{getSupportedCPUID}!Kvm@{Kvm}}
\subsubsection[{getSupportedCPUID}]{\setlength{\rightskip}{0pt plus 5cm}bool getSupportedCPUID (struct kvm\_\-cpuid2 \& {\em cpuid}) const}}
\label{classKvm_a74bec0050eeeffd21d5f85cb929c802b}
Get the CPUID features supported by the hardware and \hyperlink{classKvm}{Kvm}.

\begin{DoxyNote}{覚え書き}
Requires \hyperlink{classKvm_a6db5aefbe1a9535f5124ef07a04e23a5}{capExtendedCPUID()}.
\end{DoxyNote}
\begin{DoxyReturn}{戻り値}
False if the allocation is too small, true on success. 
\end{DoxyReturn}



\begin{DoxyCode}
185 {
186 #if defined(__i386__) || defined(__x86_64__)
187     if (ioctl(KVM_GET_SUPPORTED_CPUID, (void *)&cpuid) == -1) {
188         if (errno == E2BIG)
189             return false;
190         else
191             panic("KVM: Failed to get supported CPUID (errno: %i)\n", errno);
192     } else
193         return true;
194 #else
195     panic("KVM: getSupportedCPUID is unsupported on this platform.\n");
196 #endif
197 }
\end{DoxyCode}
\hypertarget{classKvm_ab43b4ff4aabd353eef30f8defba2718d}{
\index{Kvm@{Kvm}!getSupportedMSRs@{getSupportedMSRs}}
\index{getSupportedMSRs@{getSupportedMSRs}!Kvm@{Kvm}}
\subsubsection[{getSupportedMSRs}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Kvm::MSRIndexVector} \& getSupportedMSRs () const}}
\label{classKvm_ab43b4ff4aabd353eef30f8defba2718d}
Get the MSRs supported by the hardware and \hyperlink{classKvm}{Kvm}.

\begin{DoxyNote}{覚え書き}
This method uses an internal cache to minimize the number of calls into the kernel.
\end{DoxyNote}
\begin{DoxyReturn}{戻り値}
Reference to cached MSR index list. 
\end{DoxyReturn}



\begin{DoxyCode}
237 {
238     if (supportedMSRCache.empty()) {
239         std::unique_ptr<struct kvm_msr_list> msrs;
240         int i(0);
241         do {
242             msrs.reset((struct kvm_msr_list *)operator new(
243                            sizeof(kvm_msr_list) + i * sizeof(uint32_t)));
244 
245             msrs->nmsrs = i;
246             ++i;
247         } while (!getSupportedMSRs(*msrs));
248         supportedMSRCache.assign(msrs->indices, msrs->indices + msrs->nmsrs);
249     }
250 
251     return supportedMSRCache;
252 }
\end{DoxyCode}
\hypertarget{classKvm_a3ae50dd2ddc035995d7578481b35e877}{
\index{Kvm@{Kvm}!getSupportedMSRs@{getSupportedMSRs}}
\index{getSupportedMSRs@{getSupportedMSRs}!Kvm@{Kvm}}
\subsubsection[{getSupportedMSRs}]{\setlength{\rightskip}{0pt plus 5cm}bool getSupportedMSRs (struct kvm\_\-msr\_\-list \& {\em msrs}) const}}
\label{classKvm_a3ae50dd2ddc035995d7578481b35e877}
Get the MSRs supported by the hardware and \hyperlink{classKvm}{Kvm}.

\begin{DoxyReturn}{戻り値}
False if the allocation is too small, true on success. 
\end{DoxyReturn}



\begin{DoxyCode}
221 {
222 #if defined(__i386__) || defined(__x86_64__)
223     if (ioctl(KVM_GET_MSR_INDEX_LIST, (void *)&msrs) == -1) {
224         if (errno == E2BIG)
225             return false;
226         else
227             panic("KVM: Failed to get supported CPUID (errno: %i)\n", errno);
228     } else
229         return true;
230 #else
231     panic("KVM: getSupportedCPUID is unsupported on this platform.\n");
232 #endif
233 }
\end{DoxyCode}
\hypertarget{classKvm_a554cb4dd3512dba2169997c9c804d4ec}{
\index{Kvm@{Kvm}!getVCPUMMapSize@{getVCPUMMapSize}}
\index{getVCPUMMapSize@{getVCPUMMapSize}!Kvm@{Kvm}}
\subsubsection[{getVCPUMMapSize}]{\setlength{\rightskip}{0pt plus 5cm}int getVCPUMMapSize () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classKvm_a554cb4dd3512dba2169997c9c804d4ec}
Get the size of the MMAPed parameter area used to communicate vCPU parameters between the kernel and userspace. This area, amongst other things, contains the kvm\_\-run data structure. 


\begin{DoxyCode}
91 { return vcpuMMapSize; }
\end{DoxyCode}
\hypertarget{classKvm_a99c5e2a3a05865b3109843939909b4f6}{
\index{Kvm@{Kvm}!operator=@{operator=}}
\index{operator=@{operator=}!Kvm@{Kvm}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Kvm}\& operator= (const {\bf Kvm} \& {\em kvm})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classKvm_a99c5e2a3a05865b3109843939909b4f6}


\subsection{フレンドと関連する関数}
\hypertarget{classKvm_a9210c8f6e282c397940f37aff4d6c32d}{
\index{Kvm@{Kvm}!KvmVM@{KvmVM}}
\index{KvmVM@{KvmVM}!Kvm@{Kvm}}
\subsubsection[{KvmVM}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf KvmVM}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classKvm_a9210c8f6e282c397940f37aff4d6c32d}


\subsection{変数}
\hypertarget{classKvm_ab3562fc781db97a1faac4c863e257ca9}{
\index{Kvm@{Kvm}!apiVersion@{apiVersion}}
\index{apiVersion@{apiVersion}!Kvm@{Kvm}}
\subsubsection[{apiVersion}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf apiVersion}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classKvm_ab3562fc781db97a1faac4c863e257ca9}
KVM API version \hypertarget{classKvm_a64c6606364bd27581f929800703a402e}{
\index{Kvm@{Kvm}!instance@{instance}}
\index{instance@{instance}!Kvm@{Kvm}}
\subsubsection[{instance}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Kvm} $\ast$ {\bf instance} = NULL\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classKvm_a64c6606364bd27581f929800703a402e}
Singleton instance \hypertarget{classKvm_af331fe85a8df29abc3f2d301b0afddc2}{
\index{Kvm@{Kvm}!kvmFD@{kvmFD}}
\index{kvmFD@{kvmFD}!Kvm@{Kvm}}
\subsubsection[{kvmFD}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf kvmFD}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classKvm_af331fe85a8df29abc3f2d301b0afddc2}
KVM VM file descriptor \hypertarget{classKvm_a3d5dc75656640e2eb3b52c27e4497b75}{
\index{Kvm@{Kvm}!supportedCPUIDCache@{supportedCPUIDCache}}
\index{supportedCPUIDCache@{supportedCPUIDCache}!Kvm@{Kvm}}
\subsubsection[{supportedCPUIDCache}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CPUIDVector} {\bf supportedCPUIDCache}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, private\mbox{]}}}}
\label{classKvm_a3d5dc75656640e2eb3b52c27e4497b75}
Cached vector of supported CPUID entries. \hypertarget{classKvm_a5553ee613be7488e7c7c28058dc7d487}{
\index{Kvm@{Kvm}!supportedMSRCache@{supportedMSRCache}}
\index{supportedMSRCache@{supportedMSRCache}!Kvm@{Kvm}}
\subsubsection[{supportedMSRCache}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSRIndexVector} {\bf supportedMSRCache}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, private\mbox{]}}}}
\label{classKvm_a5553ee613be7488e7c7c28058dc7d487}
Cached vector of supported MSRs. \hypertarget{classKvm_a0915679bdc25b2c015f15996f6d4ff6d}{
\index{Kvm@{Kvm}!vcpuMMapSize@{vcpuMMapSize}}
\index{vcpuMMapSize@{vcpuMMapSize}!Kvm@{Kvm}}
\subsubsection[{vcpuMMapSize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf vcpuMMapSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classKvm_a0915679bdc25b2c015f15996f6d4ff6d}
Size of the MMAPed vCPU parameter area. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/kvm/\hyperlink{vm_8hh}{vm.hh}\item 
cpu/kvm/\hyperlink{vm_8cc}{vm.cc}\end{DoxyCompactItemize}
