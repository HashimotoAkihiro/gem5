\hypertarget{classPciDevice}{
\section{クラス PciDevice}
\label{classPciDevice}\index{PciDevice@{PciDevice}}
}


{\ttfamily \#include $<$pcidev.hh$>$}PciDeviceに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=11cm]{classPciDevice}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classPciDevice_1_1PciConfigPort}{PciConfigPort}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef PciDeviceParams \hyperlink{classPciDevice_aefbfd3f2d9daf3173b779eeff32e8112}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
const \hyperlink{classPciDevice_aefbfd3f2d9daf3173b779eeff32e8112}{Params} $\ast$ \hyperlink{classPciDevice_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classPciDevice_a87078b3d3a28ae134f6736337e90dac3}{pciToDma} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} pciAddr) const 
\item 
void \hyperlink{classPciDevice_aba6fa755ca152cedafeb4150da6a2493}{intrPost} ()
\item 
void \hyperlink{classPciDevice_ac02b8a3b8685eca8bb4b237b29dfc762}{intrClear} ()
\item 
uint8\_\-t \hyperlink{classPciDevice_a439bff27e8dc8a1b3a8b04aaf8bf7a10}{interruptLine} ()
\item 
\hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classPciDevice_a36cf113d5e5e091ebddb32306c098fae}{getAddrRanges} () const 
\item 
\hyperlink{classPciDevice_ab3ecd08d152a6a949c1e6a2d48a9afd5}{PciDevice} (const \hyperlink{classPciDevice_aefbfd3f2d9daf3173b779eeff32e8112}{Params} $\ast$params)
\item 
virtual void \hyperlink{classPciDevice_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
virtual void \hyperlink{classPciDevice_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classPciDevice_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\item 
virtual unsigned int \hyperlink{classPciDevice_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)
\item 
virtual \hyperlink{classBaseSlavePort}{BaseSlavePort} \& \hyperlink{classPciDevice_a4edba7d5e567b66fcd93297802a97077}{getSlavePort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classPciDevice_ac8b92b4f9f4b7ec34ee7994cabdddc67}{isBAR} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, int bar) const 
\item 
int \hyperlink{classPciDevice_ad7fbff3ce8627dac12313ed7ac1ea44a}{getBAR} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr)
\item 
bool \hyperlink{classPciDevice_a0678ae6a6ecde363fbe15ab17ebce109}{getBAR} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, int \&bar, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \&offs)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classPciDevice_aac7b61a78530109bfa20923a53064bbf}{writeConfig} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classPciDevice_a9dfb5284eadd79fffef97ba1bd69f3c4}{readConfig} (\hyperlink{classPacket}{PacketPtr} pkt)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{unionPCIConfig}{PCIConfig} \hyperlink{classPciDevice_ade310e2edd87f54d175985e8f2a07169}{config}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{unionMSIXTable}{MSIXTable} $>$ \hyperlink{classPciDevice_ab0606d92415296978b3baa5dda5b5ae1}{msix\_\-table}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{structMSIXPbaEntry}{MSIXPbaEntry} $>$ \hyperlink{classPciDevice_ad51ec643d8bcd3569f6f888cda1459fe}{msix\_\-pba}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classPciDevice_ad96459f9cb0f58d55bfff45109038d7b}{BARSize} \mbox{[}6\mbox{]}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classPciDevice_af7b973e5ccbf88bd0019efd69c87e06c}{BARAddrs} \mbox{[}6\mbox{]}
\item 
bool \hyperlink{classPciDevice_ae450137518092f3968ce3fc4ee94d98d}{legacyIO} \mbox{[}6\mbox{]}
\item 
\hyperlink{classPlatform}{Platform} $\ast$ \hyperlink{classPciDevice_a75b48f1787959a4617f2a599d7c09aab}{platform}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classPciDevice_ac8e969635a78ab9ab123904ccca434cc}{pioDelay}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classPciDevice_a0448e6a6b68c3fa53f768cd05758f1f2}{configDelay}
\item 
\hyperlink{classPciDevice_1_1PciConfigPort}{PciConfigPort} \hyperlink{classPciDevice_a3c911166270cab77d55e5bc6626e8a05}{configPort}
\end{DoxyCompactItemize}
\begin{Indent}{\bf }\par
{\em \label{_amgrpd41d8cd98f00b204e9800998ecf8427e}
 }\begin{DoxyCompactItemize}
\item 
const int \hyperlink{classPciDevice_ae644f63414585f6d3398caee03da3969}{PMCAP\_\-BASE}
\item 
\hyperlink{structPMCAP}{PMCAP} \hyperlink{classPciDevice_ad40e66fa09f69d8ab4617217b7f1c62e}{pmcap}
\item 
const int \hyperlink{classPciDevice_ac80b4a250e5ead5d34f1808fcfadc1ef}{MSICAP\_\-BASE}
\item 
\hyperlink{structMSICAP}{MSICAP} \hyperlink{classPciDevice_a0a9cdf296cde2e245b0c12d2bb193779}{msicap}
\item 
const int \hyperlink{classPciDevice_a0be1d03890d2b90d9d212a0c069d22f1}{MSIXCAP\_\-BASE}
\item 
\hyperlink{structMSIXCAP}{MSIXCAP} \hyperlink{classPciDevice_aa12134834ad74b26d5592bce8b588842}{msixcap}
\item 
const int \hyperlink{classPciDevice_a7058a632ee6e497e2b436d06064716a0}{PXCAP\_\-BASE}
\item 
\hyperlink{structPXCAP}{PXCAP} \hyperlink{classPciDevice_a88e9ccb85708bfe445318375e8738ec8}{pxcap}
\end{DoxyCompactItemize}
\end{Indent}


\subsection{説明}
PCI device, base implementation is only config space. 

\subsection{型定義}
\hypertarget{classPciDevice_aefbfd3f2d9daf3173b779eeff32e8112}{
\index{PciDevice@{PciDevice}!Params@{Params}}
\index{Params@{Params}!PciDevice@{PciDevice}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef PciDeviceParams {\bf Params}}}
\label{classPciDevice_aefbfd3f2d9daf3173b779eeff32e8112}


\hyperlink{classDmaDevice_aea7daf6105ab956443385f5f5a9b88c5}{DmaDevice}を再定義しています。

\hyperlink{classCopyEngine_a0b0580d58d6a0384646682653aefb97a}{CopyEngine}, \hyperlink{classEtherDevice_afcf43c7944288000e850f783bdd66b9d}{EtherDevice}, \hyperlink{classIGbE_ad27b5cfed87f35a483863a73336d8258}{IGbE}, \hyperlink{classIdeController_ac3896424d9bf2d8a838f1e2c38870d02}{IdeController}, \hyperlink{classNSGigE_a3d96e676dc626c146631b6fa53a9d823}{NSGigE}, と \hyperlink{classSinic_1_1Base_ae32fbee6dea75ffbb01b7d869c7bedad}{Base}で再定義されています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classPciDevice_ab3ecd08d152a6a949c1e6a2d48a9afd5}{
\index{PciDevice@{PciDevice}!PciDevice@{PciDevice}}
\index{PciDevice@{PciDevice}!PciDevice@{PciDevice}}
\subsubsection[{PciDevice}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PciDevice} (const {\bf Params} $\ast$ {\em params})}}
\label{classPciDevice_ab3ecd08d152a6a949c1e6a2d48a9afd5}
Constructor for PCI Dev. This function copies data from the config file object PCIConfigData and registers the device with a \hyperlink{classPciConfigAll}{PciConfigAll} object. 


\begin{DoxyCode}
98     : DmaDevice(p),
99       PMCAP_BASE(p->PMCAPBaseOffset),
100       MSICAP_BASE(p->MSICAPBaseOffset),
101       MSIXCAP_BASE(p->MSIXCAPBaseOffset),
102       PXCAP_BASE(p->PXCAPBaseOffset),
103       platform(p->platform),
104       pioDelay(p->pio_latency),
105       configDelay(p->config_latency),
106       configPort(this, params()->pci_bus, params()->pci_dev,
107                  params()->pci_func, params()->platform)
108 {
109     config.vendor = htole(p->VendorID);
110     config.device = htole(p->DeviceID);
111     config.command = htole(p->Command);
112     config.status = htole(p->Status);
113     config.revision = htole(p->Revision);
114     config.progIF = htole(p->ProgIF);
115     config.subClassCode = htole(p->SubClassCode);
116     config.classCode = htole(p->ClassCode);
117     config.cacheLineSize = htole(p->CacheLineSize);
118     config.latencyTimer = htole(p->LatencyTimer);
119     config.headerType = htole(p->HeaderType);
120     config.bist = htole(p->BIST);
121 
122     config.baseAddr[0] = htole(p->BAR0);
123     config.baseAddr[1] = htole(p->BAR1);
124     config.baseAddr[2] = htole(p->BAR2);
125     config.baseAddr[3] = htole(p->BAR3);
126     config.baseAddr[4] = htole(p->BAR4);
127     config.baseAddr[5] = htole(p->BAR5);
128     config.cardbusCIS = htole(p->CardbusCIS);
129     config.subsystemVendorID = htole(p->SubsystemVendorID);
130     config.subsystemID = htole(p->SubsystemID);
131     config.expansionROM = htole(p->ExpansionROM);
132     config.capabilityPtr = htole(p->CapabilityPtr);
133     // Zero out the 7 bytes of reserved space in the PCI Config space register.
134     bzero(config.reserved, 7*sizeof(uint8_t));
135     config.interruptLine = htole(p->InterruptLine);
136     config.interruptPin = htole(p->InterruptPin);
137     config.minimumGrant = htole(p->MinimumGrant);
138     config.maximumLatency = htole(p->MaximumLatency);
139 
140     // Initialize the capability lists
141     // These structs are bitunions, meaning the data is stored in host
142     // endianess and must be converted to Little Endian when accessed
143     // by the guest
144     // PMCAP
145     pmcap.pid.cid = p->PMCAPCapId;
146     pmcap.pid.next = p->PMCAPNextCapability;
147     pmcap.pc = p->PMCAPCapabilities;
148     pmcap.pmcs = p->PMCAPCtrlStatus;
149 
150     // MSICAP
151     msicap.mid.cid = p->MSICAPCapId;
152     msicap.mid.next = p->MSICAPNextCapability;
153     msicap.mc = p->MSICAPMsgCtrl;
154     msicap.ma = p->MSICAPMsgAddr;
155     msicap.mua = p->MSICAPMsgUpperAddr;
156     msicap.md = p->MSICAPMsgData;
157     msicap.mmask = p->MSICAPMaskBits;
158     msicap.mpend = p->MSICAPPendingBits;
159 
160     // MSIXCAP
161     msixcap.mxid.cid = p->MSIXCAPCapId;
162     msixcap.mxid.next = p->MSIXCAPNextCapability;
163     msixcap.mxc = p->MSIXMsgCtrl;
164     msixcap.mtab = p->MSIXTableOffset;
165     msixcap.mpba = p->MSIXPbaOffset;
166 
167     // allocate MSIX structures if MSIXCAP_BASE
168     // indicates the MSIXCAP is being used by having a
169     // non-zero base address.
170     // The MSIX tables are stored by the guest in
171     // little endian byte-order as according the
172     // PCIe specification.  Make sure to take the proper
173     // actions when manipulating these tables on the host
174     if (MSIXCAP_BASE != 0x0) {
175         int msix_vecs = msixcap.mxc.ts + 1;
176         MSIXTable tmp1 = {{0UL,0UL,0UL,0UL}};
177         msix_table.resize(msix_vecs, tmp1);
178 
179         MSIXPbaEntry tmp2 = {0};
180         int pba_size = msix_vecs / MSIXVECS_PER_PBA;
181         if ((msix_vecs % MSIXVECS_PER_PBA) > 0) {
182             pba_size++;
183         }
184         msix_pba.resize(pba_size, tmp2);
185     }
186 
187     // PXCAP
188     pxcap.pxid.cid = p->PXCAPCapId;
189     pxcap.pxid.next = p->PXCAPNextCapability;
190     pxcap.pxcap = p->PXCAPCapabilities;
191     pxcap.pxdcap = p->PXCAPDevCapabilities;
192     pxcap.pxdc = p->PXCAPDevCtrl;
193     pxcap.pxds = p->PXCAPDevStatus;
194     pxcap.pxlcap = p->PXCAPLinkCap;
195     pxcap.pxlc = p->PXCAPLinkCtrl;
196     pxcap.pxls = p->PXCAPLinkStatus;
197     pxcap.pxdcap2 = p->PXCAPDevCap2;
198     pxcap.pxdc2 = p->PXCAPDevCtrl2;
199 
200     BARSize[0] = p->BAR0Size;
201     BARSize[1] = p->BAR1Size;
202     BARSize[2] = p->BAR2Size;
203     BARSize[3] = p->BAR3Size;
204     BARSize[4] = p->BAR4Size;
205     BARSize[5] = p->BAR5Size;
206 
207     legacyIO[0] = p->BAR0LegacyIO;
208     legacyIO[1] = p->BAR1LegacyIO;
209     legacyIO[2] = p->BAR2LegacyIO;
210     legacyIO[3] = p->BAR3LegacyIO;
211     legacyIO[4] = p->BAR4LegacyIO;
212     legacyIO[5] = p->BAR5LegacyIO;
213 
214     for (int i = 0; i < 6; ++i) {
215         if (legacyIO[i]) {
216             BARAddrs[i] = platform->calcPciIOAddr(letoh(config.baseAddr[i]));
217             config.baseAddr[i] = 0;
218         } else {
219             BARAddrs[i] = 0;
220             uint32_t barsize = BARSize[i];
221             if (barsize != 0 && !isPowerOf2(barsize)) {
222                 fatal("BAR %d size %d is not a power of 2\n", i, BARSize[i]);
223             }
224         }
225     }
226 
227     platform->registerPciDevice(p->pci_bus, p->pci_dev, p->pci_func,
228             letoh(config.interruptLine));
229 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classPciDevice_aa8a18d230dba7a674ac8a0b4f35bc36a}{
\index{PciDevice@{PciDevice}!drain@{drain}}
\index{drain@{drain}!PciDevice@{PciDevice}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em drainManger})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPciDevice_aa8a18d230dba7a674ac8a0b4f35bc36a}
Provide a default implementation of the drain interface that simply returns 0 (draining completed) and sets the drain state to Drained. 

\hyperlink{classDmaDevice_a6bf479c521c7c3eb473822d953275b26}{DmaDevice}を再定義しています。

\hyperlink{classCopyEngine_a6bf479c521c7c3eb473822d953275b26}{CopyEngine}, と \hyperlink{classIGbE_aa8a18d230dba7a674ac8a0b4f35bc36a}{IGbE}で再定義されています。


\begin{DoxyCode}
242 {
243     unsigned int count;
244     count = pioPort.drain(dm) + dmaPort.drain(dm) + configPort.drain(dm);
245     if (count)
246         setDrainState(Drainable::Draining);
247     else
248         setDrainState(Drainable::Drained);
249     return count;
250 }
\end{DoxyCode}
\hypertarget{classPciDevice_a36cf113d5e5e091ebddb32306c098fae}{
\index{PciDevice@{PciDevice}!getAddrRanges@{getAddrRanges}}
\index{getAddrRanges@{getAddrRanges}!PciDevice@{PciDevice}}
\subsubsection[{getAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRangeList} getAddrRanges () const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPciDevice_a36cf113d5e5e091ebddb32306c098fae}
Determine the address ranges that this device responds to.

\begin{DoxyReturn}{戻り値}
a list of non-\/overlapping address ranges 
\end{DoxyReturn}


\hyperlink{classPioDevice_a6e967f8921e80748eb2be35b6b481a7e}{PioDevice}を実装しています。


\begin{DoxyCode}
293 {
294     AddrRangeList ranges;
295     int x = 0;
296     for (x = 0; x < 6; x++)
297         if (BARAddrs[x] != 0)
298             ranges.push_back(RangeSize(BARAddrs[x],BARSize[x]));
299     return ranges;
300 }
\end{DoxyCode}
\hypertarget{classPciDevice_a0678ae6a6ecde363fbe15ab17ebce109}{
\index{PciDevice@{PciDevice}!getBAR@{getBAR}}
\index{getBAR@{getBAR}!PciDevice@{PciDevice}}
\subsubsection[{getBAR}]{\setlength{\rightskip}{0pt plus 5cm}bool getBAR ({\bf Addr} {\em addr}, \/  int \& {\em bar}, \/  {\bf Addr} \& {\em offs})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classPciDevice_a0678ae6a6ecde363fbe15ab17ebce109}
Which base address register (if any) maps the given address? 
\begin{DoxyParams}{引数}
\item[{\em addr}]The address to check. \end{DoxyParams}

\begin{DoxyRetVals}{戻り値}
\item[{\em bar}]The BAR number (0-\/5 inclusive), only valid if return value is true. \item[{\em offs}]The offset from the base address, only valid if return value is true. \end{DoxyRetVals}
\begin{DoxyReturn}{戻り値}
True iff address maps to a base address register's region. 
\end{DoxyReturn}



\begin{DoxyCode}
172     {
173         int b = getBAR(addr);
174         if (b < 0)
175             return false;
176 
177         offs = addr - BARAddrs[b];
178         bar = b;
179         return true;
180     }
\end{DoxyCode}
\hypertarget{classPciDevice_ad7fbff3ce8627dac12313ed7ac1ea44a}{
\index{PciDevice@{PciDevice}!getBAR@{getBAR}}
\index{getBAR@{getBAR}!PciDevice@{PciDevice}}
\subsubsection[{getBAR}]{\setlength{\rightskip}{0pt plus 5cm}int getBAR ({\bf Addr} {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classPciDevice_ad7fbff3ce8627dac12313ed7ac1ea44a}
Which base address register (if any) maps the given address? \begin{DoxyReturn}{戻り値}
The BAR number (0-\/5 inclusive), or -\/1 if none. 
\end{DoxyReturn}



\begin{DoxyCode}
153     {
154         for (int i = 0; i <= 5; ++i)
155             if (isBAR(addr, i))
156                 return i;
157 
158         return -1;
159     }
\end{DoxyCode}
\hypertarget{classPciDevice_a4edba7d5e567b66fcd93297802a97077}{
\index{PciDevice@{PciDevice}!getSlavePort@{getSlavePort}}
\index{getSlavePort@{getSlavePort}!PciDevice@{PciDevice}}
\subsubsection[{getSlavePort}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf BaseSlavePort}\& getSlavePort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classPciDevice_a4edba7d5e567b66fcd93297802a97077}
Get a slave port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classPioDevice_ac918a145092d7514ebc6dbd952dceafb}{PioDevice}を再定義しています。


\begin{DoxyCode}
255     {
256         if (if_name == "config") {
257             return configPort;
258         }
259         return DmaDevice::getSlavePort(if_name, idx);
260     }
\end{DoxyCode}
\hypertarget{classPciDevice_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{PciDevice@{PciDevice}!init@{init}}
\index{init@{init}!PciDevice@{PciDevice}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPciDevice_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classPciDevice_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classDmaDevice_a02fd73d861ef2e4aabb38c0c9ff82947}{DmaDevice}を再定義しています。

\hyperlink{classIGbE_a02fd73d861ef2e4aabb38c0c9ff82947}{IGbE}で再定義されています。


\begin{DoxyCode}
233 {
234     if (!configPort.isConnected())
235         panic("PCI config port on %s not connected to anything!\n", name());
236    configPort.sendRangeChange();
237    DmaDevice::init();
238 }
\end{DoxyCode}
\hypertarget{classPciDevice_a439bff27e8dc8a1b3a8b04aaf8bf7a10}{
\index{PciDevice@{PciDevice}!interruptLine@{interruptLine}}
\index{interruptLine@{interruptLine}!PciDevice@{PciDevice}}
\subsubsection[{interruptLine}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t interruptLine ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPciDevice_a439bff27e8dc8a1b3a8b04aaf8bf7a10}



\begin{DoxyCode}
219     { return letoh(config.interruptLine); }
\end{DoxyCode}
\hypertarget{classPciDevice_ac02b8a3b8685eca8bb4b237b29dfc762}{
\index{PciDevice@{PciDevice}!intrClear@{intrClear}}
\index{intrClear@{intrClear}!PciDevice@{PciDevice}}
\subsubsection[{intrClear}]{\setlength{\rightskip}{0pt plus 5cm}void intrClear ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPciDevice_ac02b8a3b8685eca8bb4b237b29dfc762}



\begin{DoxyCode}
215     { platform->clearPciInt(letoh(config.interruptLine)); }
\end{DoxyCode}
\hypertarget{classPciDevice_aba6fa755ca152cedafeb4150da6a2493}{
\index{PciDevice@{PciDevice}!intrPost@{intrPost}}
\index{intrPost@{intrPost}!PciDevice@{PciDevice}}
\subsubsection[{intrPost}]{\setlength{\rightskip}{0pt plus 5cm}void intrPost ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPciDevice_aba6fa755ca152cedafeb4150da6a2493}


\hyperlink{classIdeController_aba6fa755ca152cedafeb4150da6a2493}{IdeController}で再定義されています。


\begin{DoxyCode}
211     { platform->postPciInt(letoh(config.interruptLine)); }
\end{DoxyCode}
\hypertarget{classPciDevice_ac8b92b4f9f4b7ec34ee7994cabdddc67}{
\index{PciDevice@{PciDevice}!isBAR@{isBAR}}
\index{isBAR@{isBAR}!PciDevice@{PciDevice}}
\subsubsection[{isBAR}]{\setlength{\rightskip}{0pt plus 5cm}bool isBAR ({\bf Addr} {\em addr}, \/  int {\em bar}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classPciDevice_ac8b92b4f9f4b7ec34ee7994cabdddc67}
Does the given address lie within the space mapped by the given base address register? 


\begin{DoxyCode}
142     {
143         assert(bar >= 0 && bar < 6);
144         return BARAddrs[bar] <= addr && addr < BARAddrs[bar] + BARSize[bar];
145     }
\end{DoxyCode}
\hypertarget{classPciDevice_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{PciDevice@{PciDevice}!params@{params}}
\index{params@{params}!PciDevice@{PciDevice}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPciDevice_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classPioDevice_acd3c3feb78ae7a8f88fe0f110a718dff}{PioDevice}を再定義しています。

\hyperlink{classCopyEngine_acd3c3feb78ae7a8f88fe0f110a718dff}{CopyEngine}, \hyperlink{classEtherDevice_acd3c3feb78ae7a8f88fe0f110a718dff}{EtherDevice}, \hyperlink{classEtherDevBase_a24c177ef5d1124c3ff3e68a7e53532cf}{EtherDevBase}, \hyperlink{classIGbE_acd3c3feb78ae7a8f88fe0f110a718dff}{IGbE}, \hyperlink{classIdeController_acd3c3feb78ae7a8f88fe0f110a718dff}{IdeController}, \hyperlink{classNSGigE_acd3c3feb78ae7a8f88fe0f110a718dff}{NSGigE}, と \hyperlink{classSinic_1_1Base_acd3c3feb78ae7a8f88fe0f110a718dff}{Base}で再定義されています。


\begin{DoxyCode}
100     {
101         return dynamic_cast<const Params *>(_params);
102     }
\end{DoxyCode}
\hypertarget{classPciDevice_a87078b3d3a28ae134f6736337e90dac3}{
\index{PciDevice@{PciDevice}!pciToDma@{pciToDma}}
\index{pciToDma@{pciToDma}!PciDevice@{PciDevice}}
\subsubsection[{pciToDma}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} pciToDma ({\bf Addr} {\em pciAddr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPciDevice_a87078b3d3a28ae134f6736337e90dac3}



\begin{DoxyCode}
207     { return platform->pciToDma(pciAddr); }
\end{DoxyCode}
\hypertarget{classPciDevice_a9dfb5284eadd79fffef97ba1bd69f3c4}{
\index{PciDevice@{PciDevice}!readConfig@{readConfig}}
\index{readConfig@{readConfig}!PciDevice@{PciDevice}}
\subsubsection[{readConfig}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} readConfig ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classPciDevice_a9dfb5284eadd79fffef97ba1bd69f3c4}
Read from the PCI config space data that is stored locally. This may be overridden by the device but at some point it will eventually call this for normal operations that it does not need to override. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]packet containing the write the offset into config space \end{DoxyParams}


\hyperlink{classIdeController_a9dfb5284eadd79fffef97ba1bd69f3c4}{IdeController}で再定義されています。


\begin{DoxyCode}
254 {
255     int offset = pkt->getAddr() & PCI_CONFIG_SIZE;
256     if (offset >= PCI_DEVICE_SPECIFIC)
257         panic("Device specific PCI config space not implemented!\n");
258 
259     pkt->allocate();
260 
261     switch (pkt->getSize()) {
262       case sizeof(uint8_t):
263         pkt->set<uint8_t>(config.data[offset]);
264         DPRINTF(PCIDEV,
265             "readConfig:  dev %#x func %#x reg %#x 1 bytes: data = %#x\n",
266             params()->pci_dev, params()->pci_func, offset,
267             (uint32_t)pkt->get<uint8_t>());
268         break;
269       case sizeof(uint16_t):
270         pkt->set<uint16_t>(*(uint16_t*)&config.data[offset]);
271         DPRINTF(PCIDEV,
272             "readConfig:  dev %#x func %#x reg %#x 2 bytes: data = %#x\n",
273             params()->pci_dev, params()->pci_func, offset,
274             (uint32_t)pkt->get<uint16_t>());
275         break;
276       case sizeof(uint32_t):
277         pkt->set<uint32_t>(*(uint32_t*)&config.data[offset]);
278         DPRINTF(PCIDEV,
279             "readConfig:  dev %#x func %#x reg %#x 4 bytes: data = %#x\n",
280             params()->pci_dev, params()->pci_func, offset,
281             (uint32_t)pkt->get<uint32_t>());
282         break;
283       default:
284         panic("invalid access size(?) for PCI configspace!\n");
285     }
286     pkt->makeAtomicResponse();
287     return configDelay;
288 
289 }
\end{DoxyCode}
\hypertarget{classPciDevice_a53e036786d17361be4c7320d39c99b84}{
\index{PciDevice@{PciDevice}!serialize@{serialize}}
\index{serialize@{serialize}!PciDevice@{PciDevice}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPciDevice_a53e036786d17361be4c7320d39c99b84}
Serialize this object to the given output stream. 
\begin{DoxyParams}{引数}
\item[{\em os}]The stream to serialize to. \end{DoxyParams}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。

\hyperlink{classCopyEngine_a53e036786d17361be4c7320d39c99b84}{CopyEngine}, \hyperlink{classIGbE_a53e036786d17361be4c7320d39c99b84}{IGbE}, \hyperlink{classIdeController_a53e036786d17361be4c7320d39c99b84}{IdeController}, \hyperlink{classNSGigE_ad6272f80ae37e8331e3969b3f072a801}{NSGigE}, \hyperlink{classSinic_1_1Base_a53e036786d17361be4c7320d39c99b84}{Base}, と \hyperlink{classSinic_1_1Device_a53e036786d17361be4c7320d39c99b84}{Device}で再定義されています。


\begin{DoxyCode}
426 {
427     SERIALIZE_ARRAY(BARSize, sizeof(BARSize) / sizeof(BARSize[0]));
428     SERIALIZE_ARRAY(BARAddrs, sizeof(BARAddrs) / sizeof(BARAddrs[0]));
429     SERIALIZE_ARRAY(config.data, sizeof(config.data) / sizeof(config.data[0]));
430 
431     // serialize the capability list registers
432     paramOut(os, csprintf("pmcap.pid"), uint16_t(pmcap.pid));
433     paramOut(os, csprintf("pmcap.pc"), uint16_t(pmcap.pc));
434     paramOut(os, csprintf("pmcap.pmcs"), uint16_t(pmcap.pmcs));
435 
436     paramOut(os, csprintf("msicap.mid"), uint16_t(msicap.mid));
437     paramOut(os, csprintf("msicap.mc"), uint16_t(msicap.mc));
438     paramOut(os, csprintf("msicap.ma"), uint32_t(msicap.ma));
439     SERIALIZE_SCALAR(msicap.mua);
440     paramOut(os, csprintf("msicap.md"), uint16_t(msicap.md));
441     SERIALIZE_SCALAR(msicap.mmask);
442     SERIALIZE_SCALAR(msicap.mpend);
443 
444     paramOut(os, csprintf("msixcap.mxid"), uint16_t(msixcap.mxid));
445     paramOut(os, csprintf("msixcap.mxc"), uint16_t(msixcap.mxc));
446     paramOut(os, csprintf("msixcap.mtab"), uint32_t(msixcap.mtab));
447     paramOut(os, csprintf("msixcap.mpba"), uint32_t(msixcap.mpba));
448 
449     // Only serialize if we have a non-zero base address
450     if (MSIXCAP_BASE != 0x0) {
451         int msix_array_size = msixcap.mxc.ts + 1;
452         int pba_array_size = msix_array_size/MSIXVECS_PER_PBA;
453         if ((msix_array_size % MSIXVECS_PER_PBA) > 0) {
454             pba_array_size++;
455         }
456 
457         SERIALIZE_SCALAR(msix_array_size);
458         SERIALIZE_SCALAR(pba_array_size);
459 
460         for (int i = 0; i < msix_array_size; i++) {
461             paramOut(os, csprintf("msix_table[%d].addr_lo", i),
462                      msix_table[i].fields.addr_lo);
463             paramOut(os, csprintf("msix_table[%d].addr_hi", i),
464                      msix_table[i].fields.addr_hi);
465             paramOut(os, csprintf("msix_table[%d].msg_data", i),
466                      msix_table[i].fields.msg_data);
467             paramOut(os, csprintf("msix_table[%d].vec_ctrl", i),
468                      msix_table[i].fields.vec_ctrl);
469         }
470         for (int i = 0; i < pba_array_size; i++) {
471             paramOut(os, csprintf("msix_pba[%d].bits", i),
472                      msix_pba[i].bits);
473         }
474     }
475 
476     paramOut(os, csprintf("pxcap.pxid"), uint16_t(pxcap.pxid));
477     paramOut(os, csprintf("pxcap.pxcap"), uint16_t(pxcap.pxcap));
478     paramOut(os, csprintf("pxcap.pxdcap"), uint32_t(pxcap.pxdcap));
479     paramOut(os, csprintf("pxcap.pxdc"), uint16_t(pxcap.pxdc));
480     paramOut(os, csprintf("pxcap.pxds"), uint16_t(pxcap.pxds));
481     paramOut(os, csprintf("pxcap.pxlcap"), uint32_t(pxcap.pxlcap));
482     paramOut(os, csprintf("pxcap.pxlc"), uint16_t(pxcap.pxlc));
483     paramOut(os, csprintf("pxcap.pxls"), uint16_t(pxcap.pxls));
484     paramOut(os, csprintf("pxcap.pxdcap2"), uint32_t(pxcap.pxdcap2));
485     paramOut(os, csprintf("pxcap.pxdc2"), uint32_t(pxcap.pxdc2));
486 }
\end{DoxyCode}
\hypertarget{classPciDevice_af22e5d6d660b97db37003ac61ac4ee49}{
\index{PciDevice@{PciDevice}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!PciDevice@{PciDevice}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPciDevice_af22e5d6d660b97db37003ac61ac4ee49}
Reconstruct the state of this object from a checkpoint. 
\begin{DoxyParams}{引数}
\item[{\em \hyperlink{namespacecp}{cp}}]The checkpoint use. \item[{\em section}]The section name of this object \end{DoxyParams}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。

\hyperlink{classCopyEngine_af22e5d6d660b97db37003ac61ac4ee49}{CopyEngine}, \hyperlink{classIGbE_af22e5d6d660b97db37003ac61ac4ee49}{IGbE}, \hyperlink{classIdeController_af22e5d6d660b97db37003ac61ac4ee49}{IdeController}, \hyperlink{classNSGigE_af22e5d6d660b97db37003ac61ac4ee49}{NSGigE}, \hyperlink{classSinic_1_1Base_af22e5d6d660b97db37003ac61ac4ee49}{Base}, と \hyperlink{classSinic_1_1Device_af22e5d6d660b97db37003ac61ac4ee49}{Device}で再定義されています。


\begin{DoxyCode}
490 {
491     UNSERIALIZE_ARRAY(BARSize, sizeof(BARSize) / sizeof(BARSize[0]));
492     UNSERIALIZE_ARRAY(BARAddrs, sizeof(BARAddrs) / sizeof(BARAddrs[0]));
493     UNSERIALIZE_ARRAY(config.data,
494                       sizeof(config.data) / sizeof(config.data[0]));
495 
496     // unserialize the capability list registers
497     uint16_t tmp16;
498     uint32_t tmp32;
499     paramIn(cp, section, csprintf("pmcap.pid"), tmp16);
500     pmcap.pid = tmp16;
501     paramIn(cp, section, csprintf("pmcap.pc"), tmp16);
502     pmcap.pc = tmp16;
503     paramIn(cp, section, csprintf("pmcap.pmcs"), tmp16);
504     pmcap.pmcs = tmp16;
505 
506     paramIn(cp, section, csprintf("msicap.mid"), tmp16);
507     msicap.mid = tmp16;
508     paramIn(cp, section, csprintf("msicap.mc"), tmp16);
509     msicap.mc = tmp16;
510     paramIn(cp, section, csprintf("msicap.ma"), tmp32);
511     msicap.ma = tmp32;
512     UNSERIALIZE_SCALAR(msicap.mua);
513     paramIn(cp, section, csprintf("msicap.md"), tmp16);;
514     msicap.md = tmp16;
515     UNSERIALIZE_SCALAR(msicap.mmask);
516     UNSERIALIZE_SCALAR(msicap.mpend);
517 
518     paramIn(cp, section, csprintf("msixcap.mxid"), tmp16);
519     msixcap.mxid = tmp16;
520     paramIn(cp, section, csprintf("msixcap.mxc"), tmp16);
521     msixcap.mxc = tmp16;
522     paramIn(cp, section, csprintf("msixcap.mtab"), tmp32);
523     msixcap.mtab = tmp32;
524     paramIn(cp, section, csprintf("msixcap.mpba"), tmp32);
525     msixcap.mpba = tmp32;
526 
527     // Only allocate if MSIXCAP_BASE is not 0x0
528     if (MSIXCAP_BASE != 0x0) {
529         int msix_array_size;
530         int pba_array_size;
531 
532         UNSERIALIZE_SCALAR(msix_array_size);
533         UNSERIALIZE_SCALAR(pba_array_size);
534 
535         MSIXTable tmp1 = {{0UL, 0UL, 0UL, 0UL}};
536         msix_table.resize(msix_array_size, tmp1);
537 
538         MSIXPbaEntry tmp2 = {0};
539         msix_pba.resize(pba_array_size, tmp2);
540 
541         for (int i = 0; i < msix_array_size; i++) {
542             paramIn(cp, section, csprintf("msix_table[%d].addr_lo", i),
543                     msix_table[i].fields.addr_lo);
544             paramIn(cp, section, csprintf("msix_table[%d].addr_hi", i),
545                     msix_table[i].fields.addr_hi);
546             paramIn(cp, section, csprintf("msix_table[%d].msg_data", i),
547                     msix_table[i].fields.msg_data);
548             paramIn(cp, section, csprintf("msix_table[%d].vec_ctrl", i),
549                     msix_table[i].fields.vec_ctrl);
550         }
551         for (int i = 0; i < pba_array_size; i++) {
552             paramIn(cp, section, csprintf("msix_pba[%d].bits", i),
553                     msix_pba[i].bits);
554         }
555     }
556 
557     paramIn(cp, section, csprintf("pxcap.pxid"), tmp16);
558     pxcap.pxid = tmp16;
559     paramIn(cp, section, csprintf("pxcap.pxcap"), tmp16);
560     pxcap.pxcap = tmp16;
561     paramIn(cp, section, csprintf("pxcap.pxdcap"), tmp32);
562     pxcap.pxdcap = tmp32;
563     paramIn(cp, section, csprintf("pxcap.pxdc"), tmp16);
564     pxcap.pxdc = tmp16;
565     paramIn(cp, section, csprintf("pxcap.pxds"), tmp16);
566     pxcap.pxds = tmp16;
567     paramIn(cp, section, csprintf("pxcap.pxlcap"), tmp32);
568     pxcap.pxlcap = tmp32;
569     paramIn(cp, section, csprintf("pxcap.pxlc"), tmp16);
570     pxcap.pxlc = tmp16;
571     paramIn(cp, section, csprintf("pxcap.pxls"), tmp16);
572     pxcap.pxls = tmp16;
573     paramIn(cp, section, csprintf("pxcap.pxdcap2"), tmp32);
574     pxcap.pxdcap2 = tmp32;
575     paramIn(cp, section, csprintf("pxcap.pxdc2"), tmp32);
576     pxcap.pxdc2 = tmp32;
577     pioPort.sendRangeChange();
578 }
\end{DoxyCode}
\hypertarget{classPciDevice_aac7b61a78530109bfa20923a53064bbf}{
\index{PciDevice@{PciDevice}!writeConfig@{writeConfig}}
\index{writeConfig@{writeConfig}!PciDevice@{PciDevice}}
\subsubsection[{writeConfig}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} writeConfig ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classPciDevice_aac7b61a78530109bfa20923a53064bbf}
Write to the PCI config space data that is stored locally. This may be overridden by the device but at some point it will eventually call this for normal operations that it does not need to override. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]packet containing the write the offset into config space \end{DoxyParams}


\hyperlink{classIGbE_aac7b61a78530109bfa20923a53064bbf}{IGbE}, \hyperlink{classIdeController_aac7b61a78530109bfa20923a53064bbf}{IdeController}, と \hyperlink{classNSGigE_aac7b61a78530109bfa20923a53064bbf}{NSGigE}で再定義されています。


\begin{DoxyCode}
304 {
305     int offset = pkt->getAddr() & PCI_CONFIG_SIZE;
306     if (offset >= PCI_DEVICE_SPECIFIC)
307         panic("Device specific PCI config space not implemented!\n");
308 
309     switch (pkt->getSize()) {
310       case sizeof(uint8_t):
311         switch (offset) {
312           case PCI0_INTERRUPT_LINE:
313             config.interruptLine = pkt->get<uint8_t>();
314             break;
315           case PCI_CACHE_LINE_SIZE:
316             config.cacheLineSize = pkt->get<uint8_t>();
317             break;
318           case PCI_LATENCY_TIMER:
319             config.latencyTimer = pkt->get<uint8_t>();
320             break;
321           /* Do nothing for these read-only registers */
322           case PCI0_INTERRUPT_PIN:
323           case PCI0_MINIMUM_GRANT:
324           case PCI0_MAXIMUM_LATENCY:
325           case PCI_CLASS_CODE:
326           case PCI_REVISION_ID:
327             break;
328           default:
329             panic("writing to a read only register");
330         }
331         DPRINTF(PCIDEV,
332             "writeConfig: dev %#x func %#x reg %#x 1 bytes: data = %#x\n",
333             params()->pci_dev, params()->pci_func, offset,
334             (uint32_t)pkt->get<uint8_t>());
335         break;
336       case sizeof(uint16_t):
337         switch (offset) {
338           case PCI_COMMAND:
339             config.command = pkt->get<uint8_t>();
340             break;
341           case PCI_STATUS:
342             config.status = pkt->get<uint8_t>();
343             break;
344           case PCI_CACHE_LINE_SIZE:
345             config.cacheLineSize = pkt->get<uint8_t>();
346             break;
347           default:
348             panic("writing to a read only register");
349         }
350         DPRINTF(PCIDEV,
351             "writeConfig: dev %#x func %#x reg %#x 2 bytes: data = %#x\n",
352             params()->pci_dev, params()->pci_func, offset,
353             (uint32_t)pkt->get<uint16_t>());
354         break;
355       case sizeof(uint32_t):
356         switch (offset) {
357           case PCI0_BASE_ADDR0:
358           case PCI0_BASE_ADDR1:
359           case PCI0_BASE_ADDR2:
360           case PCI0_BASE_ADDR3:
361           case PCI0_BASE_ADDR4:
362           case PCI0_BASE_ADDR5:
363             {
364                 int barnum = BAR_NUMBER(offset);
365 
366                 if (!legacyIO[barnum]) {
367                     // convert BAR values to host endianness
368                     uint32_t he_old_bar = letoh(config.baseAddr[barnum]);
369                     uint32_t he_new_bar = letoh(pkt->get<uint32_t>());
370 
371                     uint32_t bar_mask =
372                         BAR_IO_SPACE(he_old_bar) ? BAR_IO_MASK : BAR_MEM_MASK;
373 
374                     // Writing 0xffffffff to a BAR tells the card to set the
375                     // value of the bar to a bitmask indicating the size of
376                     // memory it needs
377                     if (he_new_bar == 0xffffffff) {
378                         he_new_bar = ~(BARSize[barnum] - 1);
379                     } else {
380                         // does it mean something special to write 0 to a BAR?
381                         he_new_bar &= ~bar_mask;
382                         if (he_new_bar) {
383                             BARAddrs[barnum] = BAR_IO_SPACE(he_old_bar) ?
384                                 platform->calcPciIOAddr(he_new_bar) :
385                                 platform->calcPciMemAddr(he_new_bar);
386                             pioPort.sendRangeChange();
387                         }
388                     }
389                     config.baseAddr[barnum] = htole((he_new_bar & ~bar_mask) |
390                                                     (he_old_bar & bar_mask));
391                 }
392             }
393             break;
394 
395           case PCI0_ROM_BASE_ADDR:
396             if (letoh(pkt->get<uint32_t>()) == 0xfffffffe)
397                 config.expansionROM = htole((uint32_t)0xffffffff);
398             else
399                 config.expansionROM = pkt->get<uint32_t>();
400             break;
401 
402           case PCI_COMMAND:
403             // This could also clear some of the error bits in the Status
404             // register. However they should never get set, so lets ignore
405             // it for now
406             config.command = pkt->get<uint32_t>();
407             break;
408 
409           default:
410             DPRINTF(PCIDEV, "Writing to a read only register");
411         }
412         DPRINTF(PCIDEV,
413             "writeConfig: dev %#x func %#x reg %#x 4 bytes: data = %#x\n",
414             params()->pci_dev, params()->pci_func, offset,
415             (uint32_t)pkt->get<uint32_t>());
416         break;
417       default:
418         panic("invalid access size(?) for PCI configspace!\n");
419     }
420     pkt->makeAtomicResponse();
421     return configDelay;
422 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classPciDevice_af7b973e5ccbf88bd0019efd69c87e06c}{
\index{PciDevice@{PciDevice}!BARAddrs@{BARAddrs}}
\index{BARAddrs@{BARAddrs}!PciDevice@{PciDevice}}
\subsubsection[{BARAddrs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf BARAddrs}\mbox{[}6\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPciDevice_af7b973e5ccbf88bd0019efd69c87e06c}
The current address mapping of the BARs \hypertarget{classPciDevice_ad96459f9cb0f58d55bfff45109038d7b}{
\index{PciDevice@{PciDevice}!BARSize@{BARSize}}
\index{BARSize@{BARSize}!PciDevice@{PciDevice}}
\subsubsection[{BARSize}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf BARSize}\mbox{[}6\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPciDevice_ad96459f9cb0f58d55bfff45109038d7b}
The size of the BARs \hypertarget{classPciDevice_ade310e2edd87f54d175985e8f2a07169}{
\index{PciDevice@{PciDevice}!config@{config}}
\index{config@{config}!PciDevice@{PciDevice}}
\subsubsection[{config}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PCIConfig} {\bf config}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPciDevice_ade310e2edd87f54d175985e8f2a07169}
The current config space. \hypertarget{classPciDevice_a0448e6a6b68c3fa53f768cd05758f1f2}{
\index{PciDevice@{PciDevice}!configDelay@{configDelay}}
\index{configDelay@{configDelay}!PciDevice@{PciDevice}}
\subsubsection[{configDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf configDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPciDevice_a0448e6a6b68c3fa53f768cd05758f1f2}
\hypertarget{classPciDevice_a3c911166270cab77d55e5bc6626e8a05}{
\index{PciDevice@{PciDevice}!configPort@{configPort}}
\index{configPort@{configPort}!PciDevice@{PciDevice}}
\subsubsection[{configPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PciConfigPort} {\bf configPort}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPciDevice_a3c911166270cab77d55e5bc6626e8a05}
\hypertarget{classPciDevice_ae450137518092f3968ce3fc4ee94d98d}{
\index{PciDevice@{PciDevice}!legacyIO@{legacyIO}}
\index{legacyIO@{legacyIO}!PciDevice@{PciDevice}}
\subsubsection[{legacyIO}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf legacyIO}\mbox{[}6\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPciDevice_ae450137518092f3968ce3fc4ee94d98d}
Whether the BARs are really hardwired legacy IO locations. \hypertarget{classPciDevice_a0a9cdf296cde2e245b0c12d2bb193779}{
\index{PciDevice@{PciDevice}!msicap@{msicap}}
\index{msicap@{msicap}!PciDevice@{PciDevice}}
\subsubsection[{msicap}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSICAP} {\bf msicap}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPciDevice_a0a9cdf296cde2e245b0c12d2bb193779}
\hypertarget{classPciDevice_ac80b4a250e5ead5d34f1808fcfadc1ef}{
\index{PciDevice@{PciDevice}!MSICAP\_\-BASE@{MSICAP\_\-BASE}}
\index{MSICAP\_\-BASE@{MSICAP\_\-BASE}!PciDevice@{PciDevice}}
\subsubsection[{MSICAP\_\-BASE}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf MSICAP\_\-BASE}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPciDevice_ac80b4a250e5ead5d34f1808fcfadc1ef}
\hypertarget{classPciDevice_ad51ec643d8bcd3569f6f888cda1459fe}{
\index{PciDevice@{PciDevice}!msix\_\-pba@{msix\_\-pba}}
\index{msix\_\-pba@{msix\_\-pba}!PciDevice@{PciDevice}}
\subsubsection[{msix\_\-pba}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf MSIXPbaEntry}$>$ {\bf msix\_\-pba}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPciDevice_ad51ec643d8bcd3569f6f888cda1459fe}
\hypertarget{classPciDevice_ab0606d92415296978b3baa5dda5b5ae1}{
\index{PciDevice@{PciDevice}!msix\_\-table@{msix\_\-table}}
\index{msix\_\-table@{msix\_\-table}!PciDevice@{PciDevice}}
\subsubsection[{msix\_\-table}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf MSIXTable}$>$ {\bf msix\_\-table}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPciDevice_ab0606d92415296978b3baa5dda5b5ae1}
\hyperlink{structMSIX}{MSIX} Table and PBA Structures \hypertarget{classPciDevice_aa12134834ad74b26d5592bce8b588842}{
\index{PciDevice@{PciDevice}!msixcap@{msixcap}}
\index{msixcap@{msixcap}!PciDevice@{PciDevice}}
\subsubsection[{msixcap}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSIXCAP} {\bf msixcap}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPciDevice_aa12134834ad74b26d5592bce8b588842}
\hypertarget{classPciDevice_a0be1d03890d2b90d9d212a0c069d22f1}{
\index{PciDevice@{PciDevice}!MSIXCAP\_\-BASE@{MSIXCAP\_\-BASE}}
\index{MSIXCAP\_\-BASE@{MSIXCAP\_\-BASE}!PciDevice@{PciDevice}}
\subsubsection[{MSIXCAP\_\-BASE}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf MSIXCAP\_\-BASE}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPciDevice_a0be1d03890d2b90d9d212a0c069d22f1}
\hypertarget{classPciDevice_ac8e969635a78ab9ab123904ccca434cc}{
\index{PciDevice@{PciDevice}!pioDelay@{pioDelay}}
\index{pioDelay@{pioDelay}!PciDevice@{PciDevice}}
\subsubsection[{pioDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf pioDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPciDevice_ac8e969635a78ab9ab123904ccca434cc}
\hypertarget{classPciDevice_a75b48f1787959a4617f2a599d7c09aab}{
\index{PciDevice@{PciDevice}!platform@{platform}}
\index{platform@{platform}!PciDevice@{PciDevice}}
\subsubsection[{platform}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Platform}$\ast$ {\bf platform}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPciDevice_a75b48f1787959a4617f2a599d7c09aab}
\hypertarget{classPciDevice_ad40e66fa09f69d8ab4617217b7f1c62e}{
\index{PciDevice@{PciDevice}!pmcap@{pmcap}}
\index{pmcap@{pmcap}!PciDevice@{PciDevice}}
\subsubsection[{pmcap}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PMCAP} {\bf pmcap}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPciDevice_ad40e66fa09f69d8ab4617217b7f1c62e}
\hypertarget{classPciDevice_ae644f63414585f6d3398caee03da3969}{
\index{PciDevice@{PciDevice}!PMCAP\_\-BASE@{PMCAP\_\-BASE}}
\index{PMCAP\_\-BASE@{PMCAP\_\-BASE}!PciDevice@{PciDevice}}
\subsubsection[{PMCAP\_\-BASE}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf PMCAP\_\-BASE}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPciDevice_ae644f63414585f6d3398caee03da3969}
The capability list structures and base addresses \hypertarget{classPciDevice_a88e9ccb85708bfe445318375e8738ec8}{
\index{PciDevice@{PciDevice}!pxcap@{pxcap}}
\index{pxcap@{pxcap}!PciDevice@{PciDevice}}
\subsubsection[{pxcap}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PXCAP} {\bf pxcap}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPciDevice_a88e9ccb85708bfe445318375e8738ec8}
\hypertarget{classPciDevice_a7058a632ee6e497e2b436d06064716a0}{
\index{PciDevice@{PciDevice}!PXCAP\_\-BASE@{PXCAP\_\-BASE}}
\index{PXCAP\_\-BASE@{PXCAP\_\-BASE}!PciDevice@{PciDevice}}
\subsubsection[{PXCAP\_\-BASE}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf PXCAP\_\-BASE}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPciDevice_a7058a632ee6e497e2b436d06064716a0}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/\hyperlink{pcidev_8hh}{pcidev.hh}\item 
dev/\hyperlink{pcidev_8cc}{pcidev.cc}\end{DoxyCompactItemize}
