\hypertarget{classHDLcd}{
\section{クラス HDLcd}
\label{classHDLcd}\index{HDLcd@{HDLcd}}
}


{\ttfamily \#include $<$hdlcd.hh$>$}HDLcdに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=8cm]{classHDLcd}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classHDLcd_1_1DmaDoneEvent}{DmaDoneEvent}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef HDLcdParams \hyperlink{classHDLcd_a31ccb03af3b5962a67bed42eca6ce2f0}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
const \hyperlink{classHDLcd_a31ccb03af3b5962a67bed42eca6ce2f0}{Params} $\ast$ \hyperlink{classHDLcd_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{classHDLcd_a02114caff8968787e64ab481aeb6ae09}{HDLcd} (const \hyperlink{classHDLcd_a31ccb03af3b5962a67bed42eca6ce2f0}{Params} $\ast$p)
\item 
\hyperlink{classHDLcd_af9e41a7cf9baf266c10c60ea6fb4b529}{$\sim$HDLcd} ()
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classHDLcd_a613ec7d5e1ec64f8d21fec78ae8e568e}{read} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classHDLcd_a4cefab464e72b5dd42c003a0a4341802}{write} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual void \hyperlink{classHDLcd_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classHDLcd_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\item 
\hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classHDLcd_a36cf113d5e5e091ebddb32306c098fae}{getAddrRanges} () const 
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167a}{RegisterOffset} \{ \par
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aaaecf3eedf8cb9291bcba326089c9508a}{Version} =  0x0000, 
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aa1be27d857bb87a9ae6813b06cdcbab49}{Int\_\-RawStat} =  0x0010, 
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aafcaf90f877eec92e9d06f667da4ef93a}{Int\_\-Clear} =  0x0014, 
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aa41681a9749cd3e11f4e1a1981dda1c7f}{Int\_\-Mask} =  0x0018, 
\par
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aa0d141ad1f9a40ed4a7f80aed471dde27}{Int\_\-Status} =  0x001C, 
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aae73e315a15940c9ec92665d532b0ec3f}{Fb\_\-Base} =  0x0100, 
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aa4bb8d9aadacffc879da4c56a479deb50}{Fb\_\-Line\_\-Length} =  0x0104, 
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aab622dfd78db0239caba70c2465460563}{Fb\_\-Line\_\-Count} =  0x0108, 
\par
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aa1a1fed2414dcc0ebf810a266630dc615}{Fb\_\-Line\_\-Pitch} =  0x010C, 
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aa8ecde41db7d43d0f947af7a4990cadd8}{Bus\_\-Options} =  0x0110, 
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aa388f28a3d8b85e71937474d347f4e24d}{V\_\-Sync} =  0x0200, 
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aaf788d81eab9ff4992ff5550983392df7}{V\_\-Back\_\-Porch} =  0x0204, 
\par
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aa068573e257c781b4e4eb0af5fb26178e}{V\_\-Data} =  0x0208, 
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aa69c77a38764fbc5b5567f13b5eb4267b}{V\_\-Front\_\-Porch} =  0x020C, 
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aafad2bb41d868c428adc9f68b275fb34a}{H\_\-Sync} =  0x0210, 
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aa22ed0ca08a37a1c7a4a6266a3e90363f}{H\_\-Back\_\-Porch} =  0x0214, 
\par
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aafdec0d05c0c1116a7462d36544894da5}{H\_\-Data} =  0x0218, 
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aa8139349b5f0b13a4b21053d61c043f13}{H\_\-Front\_\-Porch} =  0x021C, 
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aa080ddbafa8544f5e1f9838d62cea53b5}{Polarities} =  0x0220, 
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aafe3054aee03156c2553151700236dc9c}{Command} =  0x0230, 
\par
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aad92abc727f017e41476afd828019fd6f}{Pixel\_\-Format} =  0x0240, 
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aa3c14c44e84578139168434c48cff7ae4}{Red\_\-Select} =  0x0244, 
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aa35c8bdcdce89f753d2e287a46bd09528}{Green\_\-Select} =  0x0248, 
\hyperlink{classHDLcd_a5589603d1462868f128ddcda455b167aa7866c291b06c767b524c00d58fd7e0da}{Blue\_\-Select} =  0x024C
 \}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
uint16\_\-t \hyperlink{classHDLcd_ac032891f1184bb5cfedef5c07217b0e9}{maxOutstandingDma} () const 
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classHDLcd_a83badcd3087541a2fd96f093739247cb}{bytesFreeInPixelBuffer} () const 
\item 
size\_\-t \hyperlink{classHDLcd_addfe179a028990a8ef8df5d347b5b7a9}{dmaBurstLength} () const 
\item 
size\_\-t \hyperlink{classHDLcd_aceeb8e7b68e5186d2459b6ec91a71169}{bytesPerPixel} () const 
\item 
size\_\-t \hyperlink{classHDLcd_a20646dd69e82674924c6e5eb1458eefa}{width} () const 
\item 
size\_\-t \hyperlink{classHDLcd_ac0e3c6ba1d3f8a8e50aa3e3897210a2b}{height} () const 
\item 
uint64\_\-t \hyperlink{classHDLcd_a7b7fa24d6d051f77c5554b18b422f016}{PClksPerLine} () const 
\item 
void \hyperlink{classHDLcd_a0eb6ee93145ff20e40a51ae7b8e4debf}{updateVideoParams} (bool unserializing)
\item 
void \hyperlink{classHDLcd_ab251ef5c4d9e1f0239542a9d8aa0dc3e}{generateInterrupt} ()
\item 
void \hyperlink{classHDLcd_a24932aa8063bd34ee82a44b55990fc56}{startFrame} ()
\item 
void \hyperlink{classHDLcd_a275cb0fc5850b339346d533d2e65aaa8}{endFrame} ()
\item 
void \hyperlink{classHDLcd_a8b6bacaad93cdca1a4f0697be74311c1}{fillPixelBuffer} ()
\item 
void \hyperlink{classHDLcd_aa86bef1e89693640a33feac9f6871f35}{dmaDone} (\hyperlink{classHDLcd_1_1DmaDoneEvent}{DmaDoneEvent} $\ast$event)
\item 
void \hyperlink{classHDLcd_a0a49e224296b89d614be23179d98d6a3}{renderPixel} ()
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
const \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classHDLcd_a1482911218ac61eabec3de2d904b8274}{pixelClock}
\item 
\hyperlink{classVncInput}{VncInput} $\ast$ \hyperlink{classHDLcd_a52d1b5d3426a30e18a452cd67d87ec13}{vnc}
\item 
\hyperlink{classBitmap}{Bitmap} $\ast$ \hyperlink{classHDLcd_ada429bf89af3356a338f9532d68623cc}{bmp}
\item 
std::ostream $\ast$ \hyperlink{classHDLcd_af724472dcdfb49ce72ef865c101a1c0d}{pic}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classHDLcd_a9c95baa754410596ad866c39aba696f4}{frameReadStartTime}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classHDLcd_ae74c38d13416c4966fdd5c7db4678607}{dmaStartAddr}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classHDLcd_afff19aa29c60ac58e1bfa8689c58b923}{dmaCurAddr}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classHDLcd_a49db4d0a53163e636aa5a9e23b93b50c}{dmaMaxAddr}
\item 
size\_\-t \hyperlink{classHDLcd_a4f93e5868d1229f860a8ca2bfeaa5a12}{dmaPendingNum}
\item 
bool \hyperlink{classHDLcd_a2c55466de4118724cb375f5d1c7844e8}{frameUnderrun}
\item 
uint8\_\-t $\ast$ \hyperlink{classHDLcd_af1670e6105cdc695dd52fdde8c18f3e1}{virtualDisplayBuffer}
\item 
size\_\-t \hyperlink{classHDLcd_a77d3768993df37b5ded2ce8a0567db9e}{pixelBufferSize}
\item 
size\_\-t \hyperlink{classHDLcd_a9b265584471f3f05939bd3891884ba23}{pixelIndex}
\item 
bool \hyperlink{classHDLcd_ad49d02ec4064ddf6d7055dcdc6128e20}{doUpdateParams}
\item 
bool \hyperlink{classHDLcd_a36c69169afb7a9e1f41eb2b5fc7516c5}{frameUnderway}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classHDLcd_afea33d6bd5ce3008fa372e08f27ca95e}{dmaBytesInFlight}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classHDLcd}{HDLcd},\&HDLcd::startFrame $>$ \hyperlink{classHDLcd_ac7738466b6b60afeb71551c4f830d4fa}{startFrameEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classHDLcd}{HDLcd},\&HDLcd::endFrame $>$ \hyperlink{classHDLcd_afec13618cf33587eef480a7e70dece76}{endFrameEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classHDLcd}{HDLcd},\&HDLcd::renderPixel $>$ \hyperlink{classHDLcd_af37803439ed3050f73510b0f8e0523fc}{renderPixelEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classHDLcd}{HDLcd},\&HDLcd::fillPixelBuffer $>$ \hyperlink{classHDLcd_a1735216e127216309b2b871f35b62fc7}{fillPixelBufferEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classHDLcd}{HDLcd},\&HDLcd::generateInterrupt $>$ \hyperlink{classHDLcd_a5ae08b242f478669f0686028d558332a}{intEvent}
\item 
bool \hyperlink{classHDLcd_abf8ed1a0152ea70d689ffce800cd32fd}{enableCapture}
\end{DoxyCompactItemize}
\begin{Indent}{\bf HDLCDRegisters}\par
{\em \label{_amgrp3601e4e51ceca70a1552af1813e558c3}
 HDLCD register contents. }\begin{DoxyCompactItemize}
\item 
InterruptReg \hyperlink{classHDLcd_af1d60d459d94a3bef2f6e83bdc4c1c43}{int\_\-rawstat}
\item 
InterruptReg \hyperlink{classHDLcd_ab96a978a299a4bf65839845c1c33f414}{int\_\-clear}
\item 
InterruptReg \hyperlink{classHDLcd_a8343af5ba122012f4b5b3515d8675b7e}{int\_\-mask}
\item 
InterruptReg \hyperlink{classHDLcd_a814b02fed91486dd6000055cd1c43e1d}{int\_\-status}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classHDLcd_ad9fd5ba71c5b40acdb6fd9adc4fa408b}{fb\_\-base}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classHDLcd_ab09d20d3fb341f97725e4f27efbee0bd}{fb\_\-line\_\-length}
\item 
FbLineCountReg \hyperlink{classHDLcd_a91b3e136cdfa6ff77cbb933239223919}{fb\_\-line\_\-count}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classHDLcd_a4f20b06285d7a67e4182c190c282ab9b}{fb\_\-line\_\-pitch}
\item 
BusOptsReg \hyperlink{classHDLcd_afdc67b9cdc0c178e0855cbe989449577}{bus\_\-options}
\item 
TimingReg \hyperlink{classHDLcd_ac1d1b9a4346f8ab7231a25ba0524ac99}{v\_\-sync}
\item 
TimingReg \hyperlink{classHDLcd_a47ccc8b58ab3dffa549476540cfff908}{v\_\-back\_\-porch}
\item 
TimingReg \hyperlink{classHDLcd_a5a46b3a3d299f421a250c4ca6ca7d17c}{v\_\-data}
\item 
TimingReg \hyperlink{classHDLcd_ad663411b973f7cad0938ca048f683088}{v\_\-front\_\-porch}
\item 
TimingReg \hyperlink{classHDLcd_a91efa037cb143bc92279f190b4423748}{h\_\-sync}
\item 
TimingReg \hyperlink{classHDLcd_a2bafb13ce63125c580ceb36a81af2817}{h\_\-back\_\-porch}
\item 
TimingReg \hyperlink{classHDLcd_a3610505ba43835b9d3dd548e1848644e}{h\_\-data}
\item 
TimingReg \hyperlink{classHDLcd_ab4874d5422f23d038b1a7274da8f43e7}{h\_\-front\_\-porch}
\item 
PolaritiesReg \hyperlink{classHDLcd_a1b4fe6c75f98c50fad2eebc75f143dd2}{polarities}
\item 
\hyperlink{structCommandReg}{CommandReg} \hyperlink{classHDLcd_a9c5f330aee81c99b318a53af189fbc98}{command}
\item 
PixelFormatReg \hyperlink{classHDLcd_aadff074534cd557dcaa412b3a5860be5}{pixel\_\-format}
\item 
ColorSelectReg \hyperlink{classHDLcd_afd72c0120af049b009667393e8d7ce77}{red\_\-select}
\item 
ColorSelectReg \hyperlink{classHDLcd_abe59898cf9345a10d5927b545e832923}{green\_\-select}
\item 
ColorSelectReg \hyperlink{classHDLcd_af7a5fa704ed84e7d98a264c3ddd8b794}{blue\_\-select}
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf }\par
{\em \label{_amgrpd41d8cd98f00b204e9800998ecf8427e}
 }\begin{DoxyCompactItemize}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classHDLcd_1_1DmaDoneEvent}{DmaDoneEvent} $>$ \hyperlink{classHDLcd_aa50a0179a2d530a0a45d74b014c425fe}{dmaDoneEventAll}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classHDLcd_1_1DmaDoneEvent}{DmaDoneEvent} $\ast$ $>$ \hyperlink{classHDLcd_ada9c1832b166debd201f034b2fcb4ab2}{dmaDoneEventFree}
\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Static Protected 変数}
\begin{DoxyCompactItemize}
\item 
static const uint64\_\-t \hyperlink{classHDLcd_ae438dff5177bb7a98567cd94061edab4}{AMBA\_\-ID} = ULL(0xb105f00d00141000)
\item 
static const size\_\-t \hyperlink{classHDLcd_aaf19ce46531fc85edba07a0a76b30a5f}{BUS\_\-OPTIONS\_\-RESETV} = 0x408
\item 
static const size\_\-t \hyperlink{classHDLcd_a0cd2a036c21a49eadcc056ff0f20f8dd}{VERSION\_\-RESETV} = 0x1CDC0000
\item 
static const size\_\-t \hyperlink{classHDLcd_a5f08b80b40d4315ead7617e660bab910}{MAX\_\-OUTSTANDING\_\-DMA\_\-REQ\_\-CAPACITY} = 16
\item 
static const size\_\-t \hyperlink{classHDLcd_aace62e6eea905bd83b1d848acf8e39c9}{MAX\_\-BURST\_\-LEN} = 16
\item 
static const size\_\-t \hyperlink{classHDLcd_a43f658311547cdd328f725c29f629d43}{PIXEL\_\-BUFFER\_\-CAPACITY} = 2048
\item 
static const size\_\-t \hyperlink{classHDLcd_a707d5982e8851aee47eb1250db1c4c3b}{AXI\_\-PORT\_\-WIDTH} = 8
\end{DoxyCompactItemize}
\subsection*{RegisterFieldLayouts}
\label{_amgrp9ce006e68f89a3acc0c2edded41390ec}
 Bit layout declarations for multi-\/field registers. \begin{DoxyCompactItemize}
\item 
\hyperlink{classHDLcd_a4f40fa952becdbdacf7434cd3c404b7d}{version\_\-minor}
\item 
Bitfield$<$ 15, 8 $>$ \hyperlink{classHDLcd_a74571fc488367403e0193898d0a5367e}{version\_\-major}
\item 
Bitfield$<$ 31, 16 $>$ \hyperlink{classHDLcd_ac95f3b4958485c9925b2cb7f0302921f}{product\_\-id}
\item 
Bitfield$<$ 1 $>$ \hyperlink{classHDLcd_ad92f2664318eb7510c5ef4ed537fff93}{bus\_\-error}
\item 
Bitfield$<$ 2 $>$ \hyperlink{classHDLcd_aacc2f986e357e2a77bd80683f3c976aa}{vsync}
\item 
Bitfield$<$ 3 $>$ \hyperlink{classHDLcd_a7db18d8a83ae23e4d06cf8d21379b664}{underrun}
\item 
\hyperlink{classHDLcd_adeb07f49b4b2b8898397dbec03f22bb3}{fb\_\-line\_\-count}
\item 
Bitfield$<$ 31, 12 $>$ \hyperlink{classHDLcd_a582dec2bf3d914fb5d2ddb8feaa38111}{reserved\_\-31\_\-12}
\item 
\hyperlink{classHDLcd_a74212c0c2707c7e25bad89d6ac3004c9}{burst\_\-len}
\item 
Bitfield$<$ 7, 5 $>$ \hyperlink{classHDLcd_ada612a1f3eac7720c95c8b754b004b62}{reserved\_\-7\_\-5}
\item 
Bitfield$<$ 11, 8 $>$ \hyperlink{classHDLcd_a5f39b2e7351f4500ef1eb5babcb10381}{max\_\-outstanding}
\item 
\hyperlink{classHDLcd_acb906433e1289aa1c251dc5057746a88}{val}
\item 
Bitfield$<$ 1 $>$ \hyperlink{classHDLcd_ae1b5cd178099ce9f30eafb12ccf1bde8}{hsync\_\-polarity}
\item 
Bitfield$<$ 2 $>$ \hyperlink{classHDLcd_a2e88cca6e78a84d49d34de5407d3d048}{dataen\_\-polarity}
\item 
Bitfield$<$ 3 $>$ \hyperlink{classHDLcd_a82bbce2c586afda0822949bce915be7c}{data\_\-polarity}
\item 
Bitfield$<$ 4 $>$ \hyperlink{classHDLcd_a4fa9bf08d013c014d2e73e86607b4bed}{pxlclk\_\-polarity}
\item 
Bitfield$<$ 31, 5 $>$ \hyperlink{classHDLcd_a1ac4b70cb79ab9e24b9a264c8b8be6e4}{reserved\_\-31\_\-5}
\item 
Bitfield$<$ 31, 1 $>$ \hyperlink{classHDLcd_a8b3d3dd450f66100b4fc3ee67662400f}{reserved\_\-31\_\-1}
\item 
\hyperlink{classHDLcd_ad1c96f2932104796b8b9c1dced5ea441}{reserved\_\-2\_\-0}
\item 
Bitfield$<$ 4, 3 $>$ \hyperlink{classHDLcd_a6d40f0125f53451c936adc705f608a2b}{bytes\_\-per\_\-pixel}
\item 
Bitfield$<$ 30, 5 $>$ \hyperlink{classHDLcd_ac7a399166fd9782945b54c1218b6aa3f}{reserved\_\-30\_\-5}
\item 
Bitfield$<$ 31 $>$ \hyperlink{classHDLcd_adba5c1ae8473b445f9be0125676b2852}{big\_\-endian}
\item 
\hyperlink{classHDLcd_a7a229a4786deeddd59c6091247a8c8a6}{offset}
\item 
Bitfield$<$ 11, 8 $>$ \hyperlink{classHDLcd_a9165522b50dc058c1a097ae26260fc61}{size}
\item 
Bitfield$<$ 15, 12 $>$ \hyperlink{classHDLcd_aead24f2eb2742ac7708882a7d9616412}{reserved\_\-15\_\-12}
\item 
Bitfield$<$ 23, 16 $>$ \hyperlink{classHDLcd_a8ff8f961eef85324f222954cc8ba53ee}{default\_\-color}
\item 
Bitfield$<$ 31, 24 $>$ \hyperlink{classHDLcd_a55b96b8eb8acba57e5ed38854674db7e}{reserved\_\-31\_\-24}
\item 
\hyperlink{classHDLcd_aec6571bbae7a34d8f4acc94770b38fad}{BitUnion32} (VersionReg) Bitfield$<$7
\item 
\hyperlink{classHDLcd_ae86db13e164e3134cde1780b881b5a2b}{EndBitUnion} (VersionReg) BitUnion32(InterruptReg) Bitfield$<$ 0 $>$ dma\_\-end
\item 
\hyperlink{classHDLcd_aab67db2435979ade75800819a6694c70}{EndBitUnion} (InterruptReg) BitUnion32(FbLineCountReg) Bitfield$<$ 11
\item 
\hyperlink{classHDLcd_aea5d211b3a25fc73ea615aef16360155}{EndBitUnion} (FbLineCountReg) BitUnion32(BusOptsReg) Bitfield$<$4
\item 
\hyperlink{classHDLcd_a6d14e80c9f7e2901c07bcb2971c9128f}{EndBitUnion} (BusOptsReg) BitUnion32(TimingReg) Bitfield$<$ 11
\item 
\hyperlink{classHDLcd_a77fc9b81e2f21847dd26ae5dfa7e7e2f}{EndBitUnion} (TimingReg) BitUnion32(PolaritiesReg) Bitfield$<$ 0 $>$ vsync\_\-polarity
\item 
\hyperlink{classHDLcd_a15872640ef504c5434a0d6d2f8d1370f}{EndBitUnion} (PolaritiesReg) BitUnion32(\hyperlink{structCommandReg}{CommandReg}) Bitfield$<$ 0 $>$ enable
\item 
\hyperlink{classHDLcd_ad18895590b07f37749435b9fcab06a1b}{EndBitUnion} (\hyperlink{structCommandReg}{CommandReg}) BitUnion32(PixelFormatReg) Bitfield$<$2
\item 
\hyperlink{classHDLcd_af0dba6bcb7a2dfa9fffb850df381fb35}{EndBitUnion} (PixelFormatReg) BitUnion32(ColorSelectReg) Bitfield$<$4
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classHDLcd_a31ccb03af3b5962a67bed42eca6ce2f0}{
\index{HDLcd@{HDLcd}!Params@{Params}}
\index{Params@{Params}!HDLcd@{HDLcd}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef HDLcdParams {\bf Params}}}
\label{classHDLcd_a31ccb03af3b5962a67bed42eca6ce2f0}


\hyperlink{classAmbaDmaDevice_ab612ceb7381438552927b7ed0aed5099}{AmbaDmaDevice}を再定義しています。

\subsection{列挙型}
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167a}{
\index{HDLcd@{HDLcd}!RegisterOffset@{RegisterOffset}}
\index{RegisterOffset@{RegisterOffset}!HDLcd@{HDLcd}}
\subsubsection[{RegisterOffset}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf RegisterOffset}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a5589603d1462868f128ddcda455b167a}
ARM \hyperlink{classHDLcd}{HDLcd} register offsets \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Version@{Version}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!Version@{Version}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aaaecf3eedf8cb9291bcba326089c9508a}{
Version}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aaaecf3eedf8cb9291bcba326089c9508a}
}]\index{Int\_\-RawStat@{Int\_\-RawStat}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!Int\_\-RawStat@{Int\_\-RawStat}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aa1be27d857bb87a9ae6813b06cdcbab49}{
Int\_\-RawStat}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aa1be27d857bb87a9ae6813b06cdcbab49}
}]\index{Int\_\-Clear@{Int\_\-Clear}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!Int\_\-Clear@{Int\_\-Clear}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aafcaf90f877eec92e9d06f667da4ef93a}{
Int\_\-Clear}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aafcaf90f877eec92e9d06f667da4ef93a}
}]\index{Int\_\-Mask@{Int\_\-Mask}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!Int\_\-Mask@{Int\_\-Mask}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aa41681a9749cd3e11f4e1a1981dda1c7f}{
Int\_\-Mask}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aa41681a9749cd3e11f4e1a1981dda1c7f}
}]\index{Int\_\-Status@{Int\_\-Status}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!Int\_\-Status@{Int\_\-Status}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aa0d141ad1f9a40ed4a7f80aed471dde27}{
Int\_\-Status}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aa0d141ad1f9a40ed4a7f80aed471dde27}
}]\index{Fb\_\-Base@{Fb\_\-Base}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!Fb\_\-Base@{Fb\_\-Base}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aae73e315a15940c9ec92665d532b0ec3f}{
Fb\_\-Base}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aae73e315a15940c9ec92665d532b0ec3f}
}]\index{Fb\_\-Line\_\-Length@{Fb\_\-Line\_\-Length}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!Fb\_\-Line\_\-Length@{Fb\_\-Line\_\-Length}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aa4bb8d9aadacffc879da4c56a479deb50}{
Fb\_\-Line\_\-Length}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aa4bb8d9aadacffc879da4c56a479deb50}
}]\index{Fb\_\-Line\_\-Count@{Fb\_\-Line\_\-Count}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!Fb\_\-Line\_\-Count@{Fb\_\-Line\_\-Count}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aab622dfd78db0239caba70c2465460563}{
Fb\_\-Line\_\-Count}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aab622dfd78db0239caba70c2465460563}
}]\index{Fb\_\-Line\_\-Pitch@{Fb\_\-Line\_\-Pitch}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!Fb\_\-Line\_\-Pitch@{Fb\_\-Line\_\-Pitch}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aa1a1fed2414dcc0ebf810a266630dc615}{
Fb\_\-Line\_\-Pitch}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aa1a1fed2414dcc0ebf810a266630dc615}
}]\index{Bus\_\-Options@{Bus\_\-Options}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!Bus\_\-Options@{Bus\_\-Options}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aa8ecde41db7d43d0f947af7a4990cadd8}{
Bus\_\-Options}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aa8ecde41db7d43d0f947af7a4990cadd8}
}]\index{V\_\-Sync@{V\_\-Sync}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!V\_\-Sync@{V\_\-Sync}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aa388f28a3d8b85e71937474d347f4e24d}{
V\_\-Sync}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aa388f28a3d8b85e71937474d347f4e24d}
}]\index{V\_\-Back\_\-Porch@{V\_\-Back\_\-Porch}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!V\_\-Back\_\-Porch@{V\_\-Back\_\-Porch}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aaf788d81eab9ff4992ff5550983392df7}{
V\_\-Back\_\-Porch}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aaf788d81eab9ff4992ff5550983392df7}
}]\index{V\_\-Data@{V\_\-Data}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!V\_\-Data@{V\_\-Data}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aa068573e257c781b4e4eb0af5fb26178e}{
V\_\-Data}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aa068573e257c781b4e4eb0af5fb26178e}
}]\index{V\_\-Front\_\-Porch@{V\_\-Front\_\-Porch}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!V\_\-Front\_\-Porch@{V\_\-Front\_\-Porch}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aa69c77a38764fbc5b5567f13b5eb4267b}{
V\_\-Front\_\-Porch}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aa69c77a38764fbc5b5567f13b5eb4267b}
}]\index{H\_\-Sync@{H\_\-Sync}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!H\_\-Sync@{H\_\-Sync}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aafad2bb41d868c428adc9f68b275fb34a}{
H\_\-Sync}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aafad2bb41d868c428adc9f68b275fb34a}
}]\index{H\_\-Back\_\-Porch@{H\_\-Back\_\-Porch}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!H\_\-Back\_\-Porch@{H\_\-Back\_\-Porch}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aa22ed0ca08a37a1c7a4a6266a3e90363f}{
H\_\-Back\_\-Porch}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aa22ed0ca08a37a1c7a4a6266a3e90363f}
}]\index{H\_\-Data@{H\_\-Data}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!H\_\-Data@{H\_\-Data}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aafdec0d05c0c1116a7462d36544894da5}{
H\_\-Data}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aafdec0d05c0c1116a7462d36544894da5}
}]\index{H\_\-Front\_\-Porch@{H\_\-Front\_\-Porch}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!H\_\-Front\_\-Porch@{H\_\-Front\_\-Porch}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aa8139349b5f0b13a4b21053d61c043f13}{
H\_\-Front\_\-Porch}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aa8139349b5f0b13a4b21053d61c043f13}
}]\index{Polarities@{Polarities}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!Polarities@{Polarities}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aa080ddbafa8544f5e1f9838d62cea53b5}{
Polarities}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aa080ddbafa8544f5e1f9838d62cea53b5}
}]\index{Command@{Command}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!Command@{Command}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aafe3054aee03156c2553151700236dc9c}{
Command}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aafe3054aee03156c2553151700236dc9c}
}]\index{Pixel\_\-Format@{Pixel\_\-Format}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!Pixel\_\-Format@{Pixel\_\-Format}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aad92abc727f017e41476afd828019fd6f}{
Pixel\_\-Format}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aad92abc727f017e41476afd828019fd6f}
}]\index{Red\_\-Select@{Red\_\-Select}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!Red\_\-Select@{Red\_\-Select}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aa3c14c44e84578139168434c48cff7ae4}{
Red\_\-Select}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aa3c14c44e84578139168434c48cff7ae4}
}]\index{Green\_\-Select@{Green\_\-Select}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!Green\_\-Select@{Green\_\-Select}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aa35c8bdcdce89f753d2e287a46bd09528}{
Green\_\-Select}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aa35c8bdcdce89f753d2e287a46bd09528}
}]\index{Blue\_\-Select@{Blue\_\-Select}!HDLcd@{HDLcd}}\index{HDLcd@{HDLcd}!Blue\_\-Select@{Blue\_\-Select}}\item[{\em 
\hypertarget{classHDLcd_a5589603d1462868f128ddcda455b167aa7866c291b06c767b524c00d58fd7e0da}{
Blue\_\-Select}
\label{classHDLcd_a5589603d1462868f128ddcda455b167aa7866c291b06c767b524c00d58fd7e0da}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
101                         {
102         Version          = 0x0000,
103         Int_RawStat      = 0x0010,
104         Int_Clear        = 0x0014,
105         Int_Mask         = 0x0018,
106         Int_Status       = 0x001C,
107         Fb_Base          = 0x0100,
108         Fb_Line_Length   = 0x0104,
109         Fb_Line_Count    = 0x0108,
110         Fb_Line_Pitch    = 0x010C,
111         Bus_Options      = 0x0110,
112         V_Sync           = 0x0200,
113         V_Back_Porch     = 0x0204,
114         V_Data           = 0x0208,
115         V_Front_Porch    = 0x020C,
116         H_Sync           = 0x0210,
117         H_Back_Porch     = 0x0214,
118         H_Data           = 0x0218,
119         H_Front_Porch    = 0x021C,
120         Polarities       = 0x0220,
121         Command          = 0x0230,
122         Pixel_Format     = 0x0240,
123         Red_Select       = 0x0244,
124         Green_Select     = 0x0248,
125         Blue_Select      = 0x024C };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classHDLcd_a02114caff8968787e64ab481aeb6ae09}{
\index{HDLcd@{HDLcd}!HDLcd@{HDLcd}}
\index{HDLcd@{HDLcd}!HDLcd@{HDLcd}}
\subsubsection[{HDLcd}]{\setlength{\rightskip}{0pt plus 5cm}{\bf HDLcd} (const {\bf Params} $\ast$ {\em p})}}
\label{classHDLcd_a02114caff8968787e64ab481aeb6ae09}



\begin{DoxyCode}
58     : AmbaDmaDevice(p), version(VERSION_RESETV),
59       int_rawstat(0), int_clear(0), int_mask(0), int_status(0),
60       fb_base(0), fb_line_length(0), fb_line_count(0), fb_line_pitch(0),
61       bus_options(BUS_OPTIONS_RESETV),
62       v_sync(0), v_back_porch(0), v_data(0), v_front_porch(0),
63       h_sync(0), h_back_porch(0), h_data(0), h_front_porch(0),
64       polarities(0), command(0), pixel_format(0),
65       red_select(0), green_select(0), blue_select(0),
66       pixelClock(p->pixel_clock), vnc(p->vnc), bmp(NULL), pic(NULL),
67       frameReadStartTime(0),
68       dmaStartAddr(0), dmaCurAddr(0), dmaMaxAddr(0), dmaPendingNum(0),
69       frameUnderrun(false), virtualDisplayBuffer(NULL), pixelBufferSize(0),
70       pixelIndex(0), doUpdateParams(false), frameUnderway(false),
71       dmaBytesInFlight(0),
72       startFrameEvent(this), endFrameEvent(this), renderPixelEvent(this),
73       fillPixelBufferEvent(this), intEvent(this),
74       dmaDoneEventAll(MAX_OUTSTANDING_DMA_REQ_CAPACITY, this),
75       dmaDoneEventFree(MAX_OUTSTANDING_DMA_REQ_CAPACITY),
76       enableCapture(p->enable_capture)
77 {
78     pioSize = 0xFFFF;
79 
80     for (int i = 0; i < MAX_OUTSTANDING_DMA_REQ_CAPACITY; ++i)
81         dmaDoneEventFree[i] = &dmaDoneEventAll[i];
82 
83     if (vnc)
84         vnc->setFramebufferAddr(NULL);
85 }
\end{DoxyCode}
\hypertarget{classHDLcd_af9e41a7cf9baf266c10c60ea6fb4b529}{
\index{HDLcd@{HDLcd}!$\sim$HDLcd@{$\sim$HDLcd}}
\index{$\sim$HDLcd@{$\sim$HDLcd}!HDLcd@{HDLcd}}
\subsubsection[{$\sim$HDLcd}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf HDLcd} ()}}
\label{classHDLcd_af9e41a7cf9baf266c10c60ea6fb4b529}



\begin{DoxyCode}
88 {
89     if (virtualDisplayBuffer)
90         delete [] virtualDisplayBuffer;
91 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classHDLcd_aec6571bbae7a34d8f4acc94770b38fad}{
\index{HDLcd@{HDLcd}!BitUnion32@{BitUnion32}}
\index{BitUnion32@{BitUnion32}!HDLcd@{HDLcd}}
\subsubsection[{BitUnion32}]{\setlength{\rightskip}{0pt plus 5cm}BitUnion32 (VersionReg)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_aec6571bbae7a34d8f4acc94770b38fad}
\hypertarget{classHDLcd_a83badcd3087541a2fd96f093739247cb}{
\index{HDLcd@{HDLcd}!bytesFreeInPixelBuffer@{bytesFreeInPixelBuffer}}
\index{bytesFreeInPixelBuffer@{bytesFreeInPixelBuffer}!HDLcd@{HDLcd}}
\subsubsection[{bytesFreeInPixelBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} bytesFreeInPixelBuffer () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classHDLcd_a83badcd3087541a2fd96f093739247cb}
Gets the number of bytes free in the pixel buffer.

\begin{DoxyReturn}{戻り値}
number of bytes free in the internal pixel buffer 
\end{DoxyReturn}



\begin{DoxyCode}
364                                                    {
365         return PIXEL_BUFFER_CAPACITY - (pixelBufferSize + dmaBytesInFlight);
366     }
\end{DoxyCode}
\hypertarget{classHDLcd_aceeb8e7b68e5186d2459b6ec91a71169}{
\index{HDLcd@{HDLcd}!bytesPerPixel@{bytesPerPixel}}
\index{bytesPerPixel@{bytesPerPixel}!HDLcd@{HDLcd}}
\subsubsection[{bytesPerPixel}]{\setlength{\rightskip}{0pt plus 5cm}size\_\-t bytesPerPixel () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classHDLcd_aceeb8e7b68e5186d2459b6ec91a71169}
Gets the number of bytes per pixel.

\begin{DoxyReturn}{戻り値}
bytes per pixel 
\end{DoxyReturn}



\begin{DoxyCode}
383                                         {
384         return pixel_format.bytes_per_pixel + 1;
385     }
\end{DoxyCode}
\hypertarget{classHDLcd_addfe179a028990a8ef8df5d347b5b7a9}{
\index{HDLcd@{HDLcd}!dmaBurstLength@{dmaBurstLength}}
\index{dmaBurstLength@{dmaBurstLength}!HDLcd@{HDLcd}}
\subsubsection[{dmaBurstLength}]{\setlength{\rightskip}{0pt plus 5cm}size\_\-t dmaBurstLength () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classHDLcd_addfe179a028990a8ef8df5d347b5b7a9}
Gets the number of beats-\/per-\/burst for bus transactions.

\begin{DoxyReturn}{戻り値}
number of beats-\/per-\/burst per \hyperlink{classHDLcd}{HDLcd} DMA transaction 
\end{DoxyReturn}



\begin{DoxyCode}
373                                          {
374         assert(bus_options.burst_len <= MAX_BURST_LEN);
375         return bus_options.burst_len;
376     }
\end{DoxyCode}
\hypertarget{classHDLcd_aa86bef1e89693640a33feac9f6871f35}{
\index{HDLcd@{HDLcd}!dmaDone@{dmaDone}}
\index{dmaDone@{dmaDone}!HDLcd@{HDLcd}}
\subsubsection[{dmaDone}]{\setlength{\rightskip}{0pt plus 5cm}void dmaDone ({\bf DmaDoneEvent} $\ast$ {\em event})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_aa86bef1e89693640a33feac9f6871f35}
DMA done event 


\begin{DoxyCode}
581 {
582     const size_t transactionLength = event->getTransactionSize();
583     assert(pixelBufferSize + transactionLength < PIXEL_BUFFER_CAPACITY);
584     assert(dmaCurAddr <= dmaMaxAddr);
585 
586     dmaDoneEventFree.push_back(event);
587     --dmaPendingNum;
588     assert(MAX_OUTSTANDING_DMA_REQ_CAPACITY - dmaDoneEventFree.size() ==
589             dmaPendingNum);
590 
591     // add the data to the pixel buffer
592     dmaBytesInFlight -= transactionLength;
593     pixelBufferSize += transactionLength;
594 
595     // schedule another dma transaction if:
596     // - we're not done reading the frame
597     // - there is sufficient room in the pixel buffer for another transaction
598     // - another fillPixelBufferEvent is not already scheduled
599     const size_t targetTransSize = dmaBurstLength() * AXI_PORT_WIDTH;
600     if ((dmaCurAddr < dmaMaxAddr) &&
601         (bytesFreeInPixelBuffer() + targetTransSize < PIXEL_BUFFER_CAPACITY) &&
602         !fillPixelBufferEvent.scheduled()) {
603         schedule(fillPixelBufferEvent, clockEdge());
604     }
605 }
\end{DoxyCode}
\hypertarget{classHDLcd_af0dba6bcb7a2dfa9fffb850df381fb35}{
\index{HDLcd@{HDLcd}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!HDLcd@{HDLcd}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion (PixelFormatReg)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_af0dba6bcb7a2dfa9fffb850df381fb35}
\hypertarget{classHDLcd_ad18895590b07f37749435b9fcab06a1b}{
\index{HDLcd@{HDLcd}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!HDLcd@{HDLcd}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion ({\bf CommandReg})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ad18895590b07f37749435b9fcab06a1b}
\hypertarget{classHDLcd_a15872640ef504c5434a0d6d2f8d1370f}{
\index{HDLcd@{HDLcd}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!HDLcd@{HDLcd}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion (PolaritiesReg)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a15872640ef504c5434a0d6d2f8d1370f}
\hypertarget{classHDLcd_a77fc9b81e2f21847dd26ae5dfa7e7e2f}{
\index{HDLcd@{HDLcd}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!HDLcd@{HDLcd}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion (TimingReg)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a77fc9b81e2f21847dd26ae5dfa7e7e2f}
\hypertarget{classHDLcd_a6d14e80c9f7e2901c07bcb2971c9128f}{
\index{HDLcd@{HDLcd}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!HDLcd@{HDLcd}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion (BusOptsReg)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a6d14e80c9f7e2901c07bcb2971c9128f}
\hypertarget{classHDLcd_aea5d211b3a25fc73ea615aef16360155}{
\index{HDLcd@{HDLcd}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!HDLcd@{HDLcd}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion (FbLineCountReg)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_aea5d211b3a25fc73ea615aef16360155}
\hypertarget{classHDLcd_aab67db2435979ade75800819a6694c70}{
\index{HDLcd@{HDLcd}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!HDLcd@{HDLcd}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion (InterruptReg)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_aab67db2435979ade75800819a6694c70}
\hypertarget{classHDLcd_ae86db13e164e3134cde1780b881b5a2b}{
\index{HDLcd@{HDLcd}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!HDLcd@{HDLcd}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion (VersionReg)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ae86db13e164e3134cde1780b881b5a2b}
\hypertarget{classHDLcd_a275cb0fc5850b339346d533d2e65aaa8}{
\index{HDLcd@{HDLcd}!endFrame@{endFrame}}
\index{endFrame@{endFrame}!HDLcd@{HDLcd}}
\subsubsection[{endFrame}]{\setlength{\rightskip}{0pt plus 5cm}void endFrame ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a275cb0fc5850b339346d533d2e65aaa8}
End of frame reached 


\begin{DoxyCode}
555                 {
556     assert(pixelBufferSize == 0);
557     assert(dmaPendingNum == 0);
558     assert(dmaBytesInFlight == 0);
559     assert(dmaDoneEventFree.size() == dmaDoneEventAll.size());
560 
561     if (vnc)
562         vnc->setDirty();
563 
564     if (enableCapture) {
565         if (!pic)
566             pic = simout.create(csprintf("%s.framebuffer.bmp", sys->name()), true
      );
567 
568         assert(bmp);
569         assert(pic);
570         pic->seekp(0);
571         bmp->write(pic);
572     }
573 
574     // start the next frame
575     frameUnderway = false;
576     startFrame();
577 }
\end{DoxyCode}
\hypertarget{classHDLcd_a8b6bacaad93cdca1a4f0697be74311c1}{
\index{HDLcd@{HDLcd}!fillPixelBuffer@{fillPixelBuffer}}
\index{fillPixelBuffer@{fillPixelBuffer}!HDLcd@{HDLcd}}
\subsubsection[{fillPixelBuffer}]{\setlength{\rightskip}{0pt plus 5cm}void fillPixelBuffer ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a8b6bacaad93cdca1a4f0697be74311c1}
Generate DMA read requests from frame buffer into pixel buffer 


\begin{DoxyCode}
458 {
459     // - am I under the LCD dma transaction total?
460     // - do I have more data to transfer?
461     // - have I not yet underrun for this frame?
462     // - is there room to put the data in the pixel buffer including any
463     //   outstanding dma transfers in flight?
464     while ((dmaPendingNum < maxOutstandingDma()) &&
465            (dmaMaxAddr > dmaCurAddr) &&
466            !frameUnderrun &&
467            bytesFreeInPixelBuffer() > dmaBurstLength() * AXI_PORT_WIDTH) {
468         // try largest transaction size allowed first but switch to smaller
469         // sizes for trailing bytes
470         size_t transaction_size = dmaBurstLength() * AXI_PORT_WIDTH;
471         while (transaction_size > (dmaMaxAddr - dmaCurAddr))
472             transaction_size >>= 1;
473         assert(transaction_size > 0);
474 
475         // concurrent dma reads need different dma done events
476         // due to assertion in scheduling state
477         ++dmaPendingNum;
478 
479         assert(!dmaDoneEventFree.empty());
480         DmaDoneEvent *event(dmaDoneEventFree.back());
481         dmaDoneEventFree.pop_back();
482         assert(event);
483         assert(!event->scheduled());
484 
485         // We use a uncachable request here because the requests from the CPU
486         // will be uncacheable as well. If we have uncacheable and cacheable
487         // requests in the memory system for the same address it won't be
488         // pleased
489         event->setTransactionSize(transaction_size);
490         dmaPort.dmaAction(MemCmd::ReadReq, dmaCurAddr, transaction_size, event,
491                           virtualDisplayBuffer + dmaCurAddr - dmaStartAddr,
492                           0, Request::UNCACHEABLE);
493         dmaCurAddr += transaction_size;
494         dmaBytesInFlight += transaction_size;
495     }
496 }
\end{DoxyCode}
\hypertarget{classHDLcd_ab251ef5c4d9e1f0239542a9d8aa0dc3e}{
\index{HDLcd@{HDLcd}!generateInterrupt@{generateInterrupt}}
\index{generateInterrupt@{generateInterrupt}!HDLcd@{HDLcd}}
\subsubsection[{generateInterrupt}]{\setlength{\rightskip}{0pt plus 5cm}void generateInterrupt ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ab251ef5c4d9e1f0239542a9d8aa0dc3e}
Generates an interrupt 


\begin{DoxyCode}
835 {
836     int_status = int_rawstat & int_mask;
837     DPRINTF(HDLcd, "Generate Interrupt: int_rawstat=0x%08x int_mask=0x%08x "
838             "int_status=0x%08x\n",
839             (uint32_t)int_rawstat, (uint32_t)int_mask, (uint32_t)int_status);
840 
841     if (int_status != 0) {
842         gic->sendInt(intNum);
843         DPRINTF(HDLcd, " -- Generated\n");
844     }
845 }
\end{DoxyCode}
\hypertarget{classHDLcd_a36cf113d5e5e091ebddb32306c098fae}{
\index{HDLcd@{HDLcd}!getAddrRanges@{getAddrRanges}}
\index{getAddrRanges@{getAddrRanges}!HDLcd@{HDLcd}}
\subsubsection[{getAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRangeList} getAddrRanges () const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classHDLcd_a36cf113d5e5e091ebddb32306c098fae}
Determine the address ranges that this device responds to.

\begin{DoxyReturn}{戻り値}
a list of non-\/overlapping address ranges 
\end{DoxyReturn}


\hyperlink{classPioDevice_a6e967f8921e80748eb2be35b6b481a7e}{PioDevice}を実装しています。


\begin{DoxyCode}
849 {
850     AddrRangeList ranges;
851     ranges.push_back(RangeSize(pioAddr, pioSize));
852     return ranges;
853 }
\end{DoxyCode}
\hypertarget{classHDLcd_ac0e3c6ba1d3f8a8e50aa3e3897210a2b}{
\index{HDLcd@{HDLcd}!height@{height}}
\index{height@{height}!HDLcd@{HDLcd}}
\subsubsection[{height}]{\setlength{\rightskip}{0pt plus 5cm}size\_\-t height () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classHDLcd_ac0e3c6ba1d3f8a8e50aa3e3897210a2b}
Gets frame buffer height.

\begin{DoxyReturn}{戻り値}
frame buffer height (lines per panel) 
\end{DoxyReturn}



\begin{DoxyCode}
401                                  {
402         return fb_line_count.fb_line_count;
403     }
\end{DoxyCode}
\hypertarget{classHDLcd_ac032891f1184bb5cfedef5c07217b0e9}{
\index{HDLcd@{HDLcd}!maxOutstandingDma@{maxOutstandingDma}}
\index{maxOutstandingDma@{maxOutstandingDma}!HDLcd@{HDLcd}}
\subsubsection[{maxOutstandingDma}]{\setlength{\rightskip}{0pt plus 5cm}uint16\_\-t maxOutstandingDma () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classHDLcd_ac032891f1184bb5cfedef5c07217b0e9}
Gets the number of oustanding DMA transactions allowed on the bus at a time.

\begin{DoxyReturn}{戻り値}
gets the driver-\/specified number of outstanding DMA transactions from the hdlcd controller that are allowed on the bus at a time 
\end{DoxyReturn}



\begin{DoxyCode}
355                                               {
356         return bus_options.max_outstanding;
357     }
\end{DoxyCode}
\hypertarget{classHDLcd_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{HDLcd@{HDLcd}!params@{params}}
\index{params@{params}!HDLcd@{HDLcd}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classHDLcd_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classPioDevice_acd3c3feb78ae7a8f88fe0f110a718dff}{PioDevice}を再定義しています。


\begin{DoxyCode}
484     {
485         return dynamic_cast<const Params *>(_params);
486     }
\end{DoxyCode}
\hypertarget{classHDLcd_a7b7fa24d6d051f77c5554b18b422f016}{
\index{HDLcd@{HDLcd}!PClksPerLine@{PClksPerLine}}
\index{PClksPerLine@{PClksPerLine}!HDLcd@{HDLcd}}
\subsubsection[{PClksPerLine}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t PClksPerLine () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classHDLcd_a7b7fa24d6d051f77c5554b18b422f016}
Gets the total number of pixel clocks per display line.

\begin{DoxyReturn}{戻り値}
number of pixel clocks per display line including porch delays and horizontal sync time 
\end{DoxyReturn}



\begin{DoxyCode}
411                                          {
412         return h_back_porch.val + 1 +
413                h_data.val + 1 +
414                h_front_porch.val + 1 +
415                h_sync.val + 1;
416     }
\end{DoxyCode}
\hypertarget{classHDLcd_a613ec7d5e1ec64f8d21fec78ae8e568e}{
\index{HDLcd@{HDLcd}!read@{read}}
\index{read@{read}!HDLcd@{HDLcd}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} read ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classHDLcd_a613ec7d5e1ec64f8d21fec78ae8e568e}
Pure virtual function that the device must implement. Called when a read command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_a842312590432036092c422c87a442358}{PioDevice}を実装しています。


\begin{DoxyCode}
96 {
97     uint32_t data = 0;
98     const Addr daddr = pkt->getAddr() - pioAddr;
99 
100     DPRINTF(HDLcd, "read register BASE+0x%04x size=%d\n", daddr,
101             pkt->getSize());
102 
103     assert(pkt->getAddr() >= pioAddr &&
104             pkt->getAddr() < pioAddr + pioSize &&
105             pkt->getSize() == 4);
106 
107     pkt->allocate();
108 
109     switch (daddr) {
110       case Version:
111         data = version;
112         break;
113       case Int_RawStat:
114         data = int_rawstat;
115         break;
116       case Int_Clear:
117         panic("HDLCD INT_CLEAR register is Write-Only\n");
118         break;
119       case Int_Mask:
120         data = int_mask;
121         break;
122       case Int_Status:
123         data = int_status;
124         break;
125       case Fb_Base:
126         data = fb_base;
127         break;
128       case Fb_Line_Length:
129         data = fb_line_length;
130         break;
131       case Fb_Line_Count:
132         data = fb_line_count;
133         break;
134       case Fb_Line_Pitch:
135         data = fb_line_pitch;
136         break;
137       case Bus_Options:
138         data = bus_options;
139         break;
140       case V_Sync:
141         data = v_sync;
142         break;
143       case V_Back_Porch:
144         data = v_back_porch;
145         break;
146       case V_Data:
147         data = v_data;
148         break;
149       case V_Front_Porch:
150         data = v_front_porch;
151         break;
152       case H_Sync:
153         data = h_sync;
154         break;
155       case H_Back_Porch:
156         data = h_back_porch;
157         break;
158       case H_Data:
159         data = h_data;
160         break;
161       case H_Front_Porch:
162         data = h_front_porch;
163         break;
164       case Polarities:
165         data = polarities;
166         break;
167       case Command:
168         data = command;
169         break;
170       case Pixel_Format:
171         data = pixel_format;
172         break;
173       case Red_Select:
174         data = red_select;
175         break;
176       case Green_Select:
177         data = green_select;
178         break;
179       case Blue_Select:
180         data = blue_select;
181         break;
182       default:
183         panic("Tried to read HDLCD register that doesn't  exist\n", daddr);
184         break;
185     }
186 
187     pkt->set<uint32_t>(data);
188     pkt->makeAtomicResponse();
189     return pioDelay;
190 }
\end{DoxyCode}
\hypertarget{classHDLcd_a0a49e224296b89d614be23179d98d6a3}{
\index{HDLcd@{HDLcd}!renderPixel@{renderPixel}}
\index{renderPixel@{renderPixel}!HDLcd@{HDLcd}}
\subsubsection[{renderPixel}]{\setlength{\rightskip}{0pt plus 5cm}void renderPixel ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a0a49e224296b89d614be23179d98d6a3}
Called when it is time to render a pixel 


\begin{DoxyCode}
500 {
501     // try to handle multiple pixels at a time; doing so reduces the accuracy
502     //   of the underrun detection but lowers simulation overhead
503     const size_t count = 32;
504     assert(width() % count == 0); // not set up to handle trailing pixels
505 
506     // have we underrun on this frame anytime before?
507     if (frameUnderrun) {
508         // the LCD controller gives up on a frame if an underrun occurs and
509         //   resumes regular operation on the next frame
510         pixelBufferSize = 0;
511     } else {
512         // did we underrun on this set of pixels?
513         if (pixelBufferSize < bytesPerPixel() * count) {
514             warn("HDLcd controller buffer underrun\n");
515             frameUnderrun = true;
516             int_rawstat.underrun = 1;
517             if (!intEvent.scheduled())
518                 schedule(intEvent, clockEdge());
519         } else {
520             // emulate the pixel read from the internal buffer
521             pixelBufferSize -= bytesPerPixel() * count;
522         }
523     }
524 
525     // the DMA may have previously stalled due to the buffer being full;
526     //   give it a kick; it knows not to fill if at end of frame, underrun, etc
527     if (!fillPixelBufferEvent.scheduled())
528         schedule(fillPixelBufferEvent, clockEdge());
529 
530     // schedule the next pixel read according to where it is in the frame
531     pixelIndex += count;
532     assert(pixelIndex <= width() * height());
533     size_t x = pixelIndex % width();
534     Tick nextEventTick = curTick();
535     if (x == 0) {
536         // start of new line
537         nextEventTick += pixelClock * ((h_front_porch.val + 1) +
538                                        (h_back_porch.val + 1) +
539                                        (h_sync.val + 1));
540         if (pixelIndex == width() * height()) {
541             // end of frame
542             nextEventTick += PClksPerLine() * (v_front_porch.val + 1) *
543                              pixelClock;
544             schedule(endFrameEvent, nextEventTick);
545             return;
546         }
547     } else {
548         nextEventTick += pixelClock * count;
549     }
550 
551     schedule(renderPixelEvent, nextEventTick);
552 }
\end{DoxyCode}
\hypertarget{classHDLcd_a53e036786d17361be4c7320d39c99b84}{
\index{HDLcd@{HDLcd}!serialize@{serialize}}
\index{serialize@{serialize}!HDLcd@{HDLcd}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classHDLcd_a53e036786d17361be4c7320d39c99b84}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。


\begin{DoxyCode}
609 {
610     DPRINTF(HDLcd, "Serializing ARM HDLCD\n");
611 
612     const uint32_t version_serial = version;
613     SERIALIZE_SCALAR(version_serial);
614     const uint32_t int_rawstat_serial = int_rawstat;
615     SERIALIZE_SCALAR(int_rawstat_serial);
616     const uint32_t int_clear_serial = int_clear;
617     SERIALIZE_SCALAR(int_clear_serial);
618     const uint32_t int_mask_serial = int_mask;
619     SERIALIZE_SCALAR(int_mask_serial);
620     const uint32_t int_status_serial = int_status;
621     SERIALIZE_SCALAR(int_status_serial);
622 
623     SERIALIZE_SCALAR(fb_base);
624     SERIALIZE_SCALAR(fb_line_length);
625 
626     const uint32_t fb_line_count_serial = fb_line_count;
627     SERIALIZE_SCALAR(fb_line_count_serial);
628 
629     SERIALIZE_SCALAR(fb_line_pitch);
630 
631     const uint32_t bus_options_serial = bus_options;
632     SERIALIZE_SCALAR(bus_options_serial);
633     const uint32_t v_sync_serial = v_sync;
634     SERIALIZE_SCALAR(v_sync_serial);
635     const uint32_t v_back_porch_serial = v_back_porch;
636     SERIALIZE_SCALAR(v_back_porch_serial);
637     const uint32_t v_data_serial = v_data;
638     SERIALIZE_SCALAR(v_data_serial);
639     const uint32_t v_front_porch_serial = v_front_porch;
640     SERIALIZE_SCALAR(v_front_porch_serial);
641     const uint32_t h_sync_serial = h_sync;
642     SERIALIZE_SCALAR(h_sync_serial);
643     const uint32_t h_back_porch_serial = h_back_porch;
644     SERIALIZE_SCALAR(h_back_porch_serial);
645     const uint32_t h_data_serial = h_data;
646     SERIALIZE_SCALAR(h_data_serial);
647     const uint32_t h_front_porch_serial = h_front_porch;
648     SERIALIZE_SCALAR(h_front_porch_serial);
649     const uint32_t polarities_serial = polarities;
650     SERIALIZE_SCALAR(polarities_serial);
651     const uint32_t command_serial = command;
652     SERIALIZE_SCALAR(command_serial);
653     const uint32_t pixel_format_serial = pixel_format;
654     SERIALIZE_SCALAR(pixel_format_serial);
655     const uint32_t red_select_serial = red_select;
656     SERIALIZE_SCALAR(red_select_serial);
657     const uint32_t green_select_serial = green_select;
658     SERIALIZE_SCALAR(green_select_serial);
659     const uint32_t blue_select_serial = blue_select;
660     SERIALIZE_SCALAR(blue_select_serial);
661 
662     SERIALIZE_SCALAR(frameReadStartTime);
663     SERIALIZE_SCALAR(dmaStartAddr);
664     SERIALIZE_SCALAR(dmaCurAddr);
665     SERIALIZE_SCALAR(dmaMaxAddr);
666     SERIALIZE_SCALAR(dmaPendingNum);
667     SERIALIZE_SCALAR(frameUnderrun);
668 
669     const size_t buffer_size = bytesPerPixel() * width() * height();
670     SERIALIZE_ARRAY(virtualDisplayBuffer, buffer_size);
671 
672     SERIALIZE_SCALAR(pixelBufferSize);
673     SERIALIZE_SCALAR(pixelIndex);
674     SERIALIZE_SCALAR(doUpdateParams);
675     SERIALIZE_SCALAR(frameUnderway);
676     SERIALIZE_SCALAR(dmaBytesInFlight);
677 
678     Tick start_event_time = 0;
679     Tick end_event_time = 0;
680     Tick render_pixel_event_time = 0;
681     Tick fill_pixel_buffer_event_time = 0;
682     Tick int_event_time = 0;
683     if (startFrameEvent.scheduled())
684         start_event_time = startFrameEvent.when();
685     if (endFrameEvent.scheduled())
686         end_event_time = endFrameEvent.when();
687     if (renderPixelEvent.scheduled())
688         render_pixel_event_time = renderPixelEvent.when();
689     if (fillPixelBufferEvent.scheduled())
690         fill_pixel_buffer_event_time = fillPixelBufferEvent.when();
691     if (intEvent.scheduled())
692         int_event_time = intEvent.when();
693     SERIALIZE_SCALAR(start_event_time);
694     SERIALIZE_SCALAR(end_event_time);
695     SERIALIZE_SCALAR(render_pixel_event_time);
696     SERIALIZE_SCALAR(fill_pixel_buffer_event_time);
697     SERIALIZE_SCALAR(int_event_time);
698 
699     vector<Tick> dma_done_event_tick(MAX_OUTSTANDING_DMA_REQ_CAPACITY);
700     vector<size_t> dma_done_event_burst_len(MAX_OUTSTANDING_DMA_REQ_CAPACITY);
701     for (int x = 0; x < MAX_OUTSTANDING_DMA_REQ_CAPACITY; ++x) {
702         dma_done_event_tick[x] = dmaDoneEventAll[x].scheduled() ?
703             dmaDoneEventAll[x].when() : 0;
704         dma_done_event_burst_len[x] = dmaDoneEventAll[x].scheduled() ?
705             dmaDoneEventAll[x].getTransactionSize() : 0;
706     }
707     arrayParamOut(os, "dma_done_event_tick", dma_done_event_tick);
708     arrayParamOut(os, "dma_done_event_burst_length", dma_done_event_burst_len);
709 }
\end{DoxyCode}
\hypertarget{classHDLcd_a24932aa8063bd34ee82a44b55990fc56}{
\index{HDLcd@{HDLcd}!startFrame@{startFrame}}
\index{startFrame@{startFrame}!HDLcd@{HDLcd}}
\subsubsection[{startFrame}]{\setlength{\rightskip}{0pt plus 5cm}void startFrame ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a24932aa8063bd34ee82a44b55990fc56}
Start reading the next frame 


\begin{DoxyCode}
418 {
419     // 0. Check that we are in the appropriate state
420     assert(!frameUnderway);
421     if (!command.enable)
422         return;
423     DPRINTF(HDLcd, "Frame read started\n");
424     if (doUpdateParams) {
425         updateVideoParams();
426         doUpdateParams = false;
427     }
428     frameUnderway = true;
429     assert(virtualDisplayBuffer);
430     assert(pixelBufferSize == 0);
431     assert(dmaBytesInFlight == 0);
432     assert(dmaPendingNum == 0);
433     assert(dmaDoneEventFree.size() == dmaDoneEventAll.size());
434     assert(!renderPixelEvent.scheduled());
435     // currently only support positive line pitches equal to the line length
436     assert(width() * bytesPerPixel() == fb_line_pitch);
437 
438     // 1. Start DMA'ing the frame; subsequent transactions created as we go
439     dmaCurAddr = dmaStartAddr = fb_base;
440     dmaMaxAddr = static_cast<Addr>(width() * height() * bytesPerPixel()) +
441                     dmaCurAddr;
442     frameReadStartTime = curTick();
443     pixelIndex = 0;
444     frameUnderrun = false;
445     fillPixelBuffer();
446 
447     // 2. Schedule first pixelclock read; subsequent reads generated as we go
448     Tick firstPixelReadTick = curTick() + pixelClock * (
449                                   PClksPerLine() * (v_sync.val + 1 +
450                                                     v_back_porch.val + 1) +
451                                   h_sync.val + 1 +
452                                   h_back_porch.val + 1);
453     schedule(renderPixelEvent, firstPixelReadTick);
454 }
\end{DoxyCode}
\hypertarget{classHDLcd_af22e5d6d660b97db37003ac61ac4ee49}{
\index{HDLcd@{HDLcd}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!HDLcd@{HDLcd}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classHDLcd_af22e5d6d660b97db37003ac61ac4ee49}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。


\begin{DoxyCode}
713 {
714     uint32_t version_serial, int_rawstat_serial, int_clear_serial,
715             int_mask_serial, int_status_serial, fb_line_count_serial,
716             bus_options_serial, v_sync_serial, v_back_porch_serial,
717             v_data_serial, v_front_porch_serial, h_sync_serial,
718             h_back_porch_serial, h_data_serial, h_front_porch_serial,
719             polarities_serial, command_serial, pixel_format_serial,
720             red_select_serial, green_select_serial, blue_select_serial;
721 
722     DPRINTF(HDLcd, "Unserializing ARM HDLCD\n");
723 
724     UNSERIALIZE_SCALAR(version_serial);
725     version = version_serial;
726     UNSERIALIZE_SCALAR(int_rawstat_serial);
727     int_rawstat = int_rawstat_serial;
728     UNSERIALIZE_SCALAR(int_clear_serial);
729     int_clear = int_clear_serial;
730     UNSERIALIZE_SCALAR(int_mask_serial);
731     int_mask = int_mask_serial;
732     UNSERIALIZE_SCALAR(int_status_serial);
733     int_status = int_status_serial;
734 
735     UNSERIALIZE_SCALAR(fb_base);
736     UNSERIALIZE_SCALAR(fb_line_length);
737 
738     UNSERIALIZE_SCALAR(fb_line_count_serial);
739     fb_line_count = fb_line_count_serial;
740 
741     UNSERIALIZE_SCALAR(fb_line_pitch);
742 
743     UNSERIALIZE_SCALAR(bus_options_serial);
744     bus_options = bus_options_serial;
745     UNSERIALIZE_SCALAR(v_sync_serial);
746     v_sync = v_sync_serial;
747     UNSERIALIZE_SCALAR(v_back_porch_serial);
748     v_back_porch = v_back_porch_serial;
749     UNSERIALIZE_SCALAR(v_data_serial);
750     v_data = v_data_serial;
751     UNSERIALIZE_SCALAR(v_front_porch_serial);
752     v_front_porch = v_front_porch_serial;
753     UNSERIALIZE_SCALAR(h_sync_serial);
754     h_sync = h_sync_serial;
755     UNSERIALIZE_SCALAR(h_back_porch_serial);
756     h_back_porch = h_back_porch_serial;
757     UNSERIALIZE_SCALAR(h_data_serial);
758     h_data = h_data_serial;
759     UNSERIALIZE_SCALAR(h_front_porch_serial);
760     h_front_porch = h_front_porch_serial;
761     UNSERIALIZE_SCALAR(polarities_serial);
762     polarities = polarities_serial;
763     UNSERIALIZE_SCALAR(command_serial);
764     command = command_serial;
765     UNSERIALIZE_SCALAR(pixel_format_serial);
766     pixel_format = pixel_format_serial;
767     UNSERIALIZE_SCALAR(red_select_serial);
768     red_select = red_select_serial;
769     UNSERIALIZE_SCALAR(green_select_serial);
770     green_select = green_select_serial;
771     UNSERIALIZE_SCALAR(blue_select_serial);
772     blue_select = blue_select_serial;
773 
774     UNSERIALIZE_SCALAR(frameReadStartTime);
775     UNSERIALIZE_SCALAR(dmaStartAddr);
776     UNSERIALIZE_SCALAR(dmaCurAddr);
777     UNSERIALIZE_SCALAR(dmaMaxAddr);
778     UNSERIALIZE_SCALAR(dmaPendingNum);
779     UNSERIALIZE_SCALAR(frameUnderrun);
780     UNSERIALIZE_SCALAR(dmaBytesInFlight);
781 
782     const size_t buffer_size = bytesPerPixel() * width() * height();
783     virtualDisplayBuffer = new uint8_t[buffer_size];
784     UNSERIALIZE_ARRAY(virtualDisplayBuffer, buffer_size);
785 
786     UNSERIALIZE_SCALAR(pixelBufferSize);
787     UNSERIALIZE_SCALAR(pixelIndex);
788     UNSERIALIZE_SCALAR(doUpdateParams);
789     UNSERIALIZE_SCALAR(frameUnderway);
790 
791     Tick start_event_time = 0;
792     Tick end_event_time = 0;
793     Tick render_pixel_event_time = 0;
794     Tick fill_pixel_buffer_event_time = 0;
795     Tick int_event_time = 0;
796     UNSERIALIZE_SCALAR(start_event_time);
797     UNSERIALIZE_SCALAR(end_event_time);
798     UNSERIALIZE_SCALAR(render_pixel_event_time);
799     UNSERIALIZE_SCALAR(fill_pixel_buffer_event_time);
800     UNSERIALIZE_SCALAR(int_event_time);
801     if (start_event_time)
802         schedule(startFrameEvent, start_event_time);
803     if (end_event_time)
804         schedule(endFrameEvent, end_event_time);
805     if (render_pixel_event_time)
806         schedule(renderPixelEvent, render_pixel_event_time);
807     if (fill_pixel_buffer_event_time)
808         schedule(fillPixelBufferEvent, fill_pixel_buffer_event_time);
809     if (int_event_time)
810         schedule(intEvent, int_event_time);
811 
812     vector<Tick> dma_done_event_tick(MAX_OUTSTANDING_DMA_REQ_CAPACITY);
813     vector<Tick> dma_done_event_burst_len(MAX_OUTSTANDING_DMA_REQ_CAPACITY);
814     arrayParamIn(cp, section, "dma_done_event_tick", dma_done_event_tick);
815     arrayParamIn(cp, section, "dma_done_event_burst_length", dma_done_event_burst
      _len);
816     dmaDoneEventFree.clear();
817     for (int x = 0; x < MAX_OUTSTANDING_DMA_REQ_CAPACITY; ++x) {
818         if (dma_done_event_tick[x]) {
819             dmaDoneEventAll[x].setTransactionSize(dma_done_event_burst_len[x]);
820             schedule(dmaDoneEventAll[x], dma_done_event_tick[x]);
821         } else
822             dmaDoneEventFree.push_back(&dmaDoneEventAll[x]);
823     }
824     assert(MAX_OUTSTANDING_DMA_REQ_CAPACITY - dmaDoneEventFree.size() == 
      dmaPendingNum);
825 
826     if (frameUnderway) {
827         updateVideoParams(true);
828         if (vnc)
829             vnc->setDirty();
830     }
831 }
\end{DoxyCode}
\hypertarget{classHDLcd_a0eb6ee93145ff20e40a51ae7b8e4debf}{
\index{HDLcd@{HDLcd}!updateVideoParams@{updateVideoParams}}
\index{updateVideoParams@{updateVideoParams}!HDLcd@{HDLcd}}
\subsubsection[{updateVideoParams}]{\setlength{\rightskip}{0pt plus 5cm}void updateVideoParams (bool {\em unserializing} = {\ttfamily false})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a0eb6ee93145ff20e40a51ae7b8e4debf}
Send updated parameters to the vnc server 


\begin{DoxyCode}
319 {
320     const uint16_t bpp = bytesPerPixel() << 3;
321     const size_t buffer_size = bytesPerPixel() * width() * height();
322 
323     // updating these parameters while LCD is enabled is not supported
324     if (frameUnderway && !unserializing)
325         panic("Attempting to change some HDLCD parameters while the controller"
326                 " is active is not allowed");
327 
328     // resize the virtualDisplayBuffer unless we are unserializing - it may
329     //   have changed size
330     // there must be no outstanding DMA transactions for this to work
331     if (!unserializing) {
332         assert(dmaPendingNum == 0);
333         if (virtualDisplayBuffer)
334             delete [] virtualDisplayBuffer;
335         virtualDisplayBuffer = new uint8_t[buffer_size];
336         memset(virtualDisplayBuffer, 0, buffer_size);
337     }
338 
339     assert(virtualDisplayBuffer);
340     if (vnc)
341         vnc->setFramebufferAddr(virtualDisplayBuffer);
342 
343     if (bmp)
344         delete bmp;
345 
346     DPRINTF(HDLcd, "bpp = %d\n", bpp);
347     DPRINTF(HDLcd, "display size = %d x %d\n", width(), height());
348 #if TRACING_ON
349     const size_t totalLinesPerFrame = v_back_porch.val + 1 +
350                                       v_data.val + 1 +
351                                       v_front_porch.val + 1 +
352                                       v_sync.val + 1;
353     const double fps = (double)SimClock::Frequency /
354             (double)(PClksPerLine() * totalLinesPerFrame * pixelClock);
355 #endif
356     DPRINTF(HDLcd, "simulated refresh rate ~ %.1ffps generating ~ %.1fMB/s "
357             "traffic ([%.1fMHz, T=%d sim clocks] pclk, %d bpp => %.1fMB/s peak re
      quirement)\n",
358             fps,
359             fps * buffer_size / 1024 / 1024,
360             (double)SimClock::Frequency / pixelClock / 1000000.0,
361             pixelClock,
362             bpp,
363             (double)(SimClock::Frequency / pixelClock * (bpp / 8)) / 1024 / 1024)
      ;
364 
365     if (pixel_format.big_endian)
366         panic("Big Endian pixel format not implemented by HDLcd controller");
367 
368     if (vnc) {
369         if ((bpp == 24) &&
370                 (red_select.size == 8) &&
371                 (blue_select.size == 8) &&
372                 (green_select.size == 8) &&
373                 (green_select.offset == 8)) {
374             if ((blue_select.offset == 0) &&
375                     (red_select.offset == 16)) {
376                 vnc->setFrameBufferParams(VideoConvert::rgb8888, width(),
377                         height());
378                 bmp = new Bitmap(VideoConvert::rgb8888, width(), height(),
379                         virtualDisplayBuffer);
380                 DPRINTF(HDLcd, "color mode:  rgb888\n");
381             } else if ((red_select.offset == 0) &&
382                     (blue_select.offset == 16)) {
383                 vnc->setFrameBufferParams(VideoConvert::bgr8888, width(),
384                         height());
385                 bmp = new Bitmap(VideoConvert::bgr8888, width(), height(),
386                         virtualDisplayBuffer);
387                 DPRINTF(HDLcd, "color mode:  bgr888\n");
388             }
389         } else if ((bpp == 16) &&
390                 (red_select.size == 5) &&
391                 (blue_select.size == 5) &&
392                 (green_select.size == 6) &&
393                 (green_select.offset == 5)) {
394             if ((blue_select.offset == 0) &&
395                     (red_select.offset == 11)) {
396                 vnc->setFrameBufferParams(VideoConvert::rgb565, width(),
397                         height());
398                 bmp = new Bitmap(VideoConvert::rgb565, width(), height(),
399                         virtualDisplayBuffer);
400                 DPRINTF(HDLcd, "color mode:  rgb565\n");
401             } else if ((red_select.offset == 0) &&
402                     (blue_select.offset == 11)) {
403                 vnc->setFrameBufferParams(VideoConvert::bgr565, width(),
404                         height());
405                 bmp = new Bitmap(VideoConvert::bgr565, width(), height(),
406                         virtualDisplayBuffer);
407                 DPRINTF(HDLcd, "color mode:  bgr565\n");
408             }
409         } else {
410             DPRINTF(HDLcd, "color mode:  undefined\n");
411             panic("Unimplemented video mode\n");
412         }
413     }
414 }
\end{DoxyCode}
\hypertarget{classHDLcd_a20646dd69e82674924c6e5eb1458eefa}{
\index{HDLcd@{HDLcd}!width@{width}}
\index{width@{width}!HDLcd@{HDLcd}}
\subsubsection[{width}]{\setlength{\rightskip}{0pt plus 5cm}size\_\-t width () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classHDLcd_a20646dd69e82674924c6e5eb1458eefa}
Gets frame buffer width.

\begin{DoxyReturn}{戻り値}
frame buffer width (pixels per line) 
\end{DoxyReturn}



\begin{DoxyCode}
392                                 {
393         return fb_line_length / bytesPerPixel();
394     }
\end{DoxyCode}
\hypertarget{classHDLcd_a4cefab464e72b5dd42c003a0a4341802}{
\index{HDLcd@{HDLcd}!write@{write}}
\index{write@{write}!HDLcd@{HDLcd}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} write ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classHDLcd_a4cefab464e72b5dd42c003a0a4341802}
Pure virtual function that the device must implement. Called when a write command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_afe8371668d023bb2516b286e5e399b6f}{PioDevice}を実装しています。


\begin{DoxyCode}
195 {
196     assert(pkt->getAddr() >= pioAddr &&
197            pkt->getAddr() < pioAddr + pioSize &&
198            pkt->getSize() == 4);
199 
200     const uint32_t data = pkt->get<uint32_t>();
201     const Addr daddr = pkt->getAddr() - pioAddr;
202 
203     DPRINTF(HDLcd, "write register BASE+%0x04x <= 0x%08x\n", daddr,
204             pkt->get<uint32_t>());
205 
206     switch (daddr) {
207       case Version:
208         panic("HDLCD VERSION register is read-Only\n");
209         break;
210       case Int_RawStat:
211         int_rawstat = data;
212         break;
213       case Int_Clear:
214         int_clear = data;
215         break;
216       case Int_Mask:
217         int_mask = data;
218         break;
219       case Int_Status:
220         panic("HDLCD INT_STATUS register is read-Only\n");
221         break;
222       case Fb_Base:
223         fb_base = data;
224         DPRINTF(HDLcd, "HDLCD Frame Buffer located at addr 0x%08x\n", fb_base);
225         break;
226       case Fb_Line_Length:
227         fb_line_length = data;
228         DPRINTF(HDLcd, "HDLCD res = %d x %d\n", width(), height());
229         break;
230       case Fb_Line_Count:
231         fb_line_count = data;
232         DPRINTF(HDLcd, "HDLCD res = %d x %d\n", width(), height());
233         break;
234       case Fb_Line_Pitch:
235         fb_line_pitch = data;
236         break;
237       case Bus_Options: {
238         BusOptsReg old_bus_options;
239         old_bus_options = bus_options;
240         bus_options = data;
241         if (bus_options.max_outstanding != old_bus_options.max_outstanding)
242             DPRINTF(HDLcd,
243                 "Changing HDLcd outstanding dma transactions from %d to %d\n",
244                 old_bus_options.max_outstanding, bus_options.max_outstanding);
245         if (bus_options.burst_len != old_bus_options.burst_len)
246             DPRINTF(HDLcd,
247                 "Changing HDLcd dma burst length from %d bytes to %d bytes\n",
248                 old_bus_options.burst_len, bus_options.burst_len); }
249         break;
250       case V_Sync:
251         v_sync = data;
252         break;
253       case V_Back_Porch:
254         v_back_porch = data;
255         break;
256       case V_Data:
257         v_data = data;
258         break;
259       case V_Front_Porch:
260         v_front_porch = data;
261         break;
262       case H_Sync:
263         h_sync = data;
264         break;
265       case H_Back_Porch:
266         h_back_porch = data;
267         break;
268       case H_Data:
269         h_data = data;
270         break;
271       case H_Front_Porch:
272         h_front_porch = data;
273         break;
274       case Polarities:
275         polarities = data;
276         break;
277       case Command: {
278         CommandReg new_command;
279         new_command = data;
280         if (new_command.enable != command.enable) {
281             DPRINTF(HDLcd, "HDLCD switched %s\n",
282                     new_command.enable==0 ? "off" : "on");
283             if (new_command.enable) {
284                 doUpdateParams = true;
285                 if (!frameUnderway) {
286                     schedule(startFrameEvent, clockEdge());
287                 }
288             }
289         }
290         command = new_command; }
291         break;
292       case Pixel_Format:
293         pixel_format = data;
294         DPRINTF(HDLcd, "HDLCD res = %d x %d\n", width(), height());
295         DPRINTF(HDLcd, "HDLCD bytes per pixel = %d\n", bytesPerPixel());
296         DPRINTF(HDLcd, "HDLCD endianness = %s\n",
297                 pixel_format.big_endian ? "big" : "little");
298         break;
299       case Red_Select:
300         red_select = data;
301         break;
302       case Green_Select:
303         green_select = data;
304         break;
305       case Blue_Select:
306         blue_select = data;
307         break;
308       default:
309         panic("Tried to write HDLCD register that doesn't exist\n", daddr);
310         break;
311     }
312 
313     pkt->makeAtomicResponse();
314     return pioDelay;
315 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classHDLcd_ae438dff5177bb7a98567cd94061edab4}{
\index{HDLcd@{HDLcd}!AMBA\_\-ID@{AMBA\_\-ID}}
\index{AMBA\_\-ID@{AMBA\_\-ID}!HDLcd@{HDLcd}}
\subsubsection[{AMBA\_\-ID}]{\setlength{\rightskip}{0pt plus 5cm}const uint64\_\-t {\bf AMBA\_\-ID} = ULL(0xb105f00d00141000)\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classHDLcd_ae438dff5177bb7a98567cd94061edab4}
fake AMBA ID -\/-\/ unused \hypertarget{classHDLcd_a707d5982e8851aee47eb1250db1c4c3b}{
\index{HDLcd@{HDLcd}!AXI\_\-PORT\_\-WIDTH@{AXI\_\-PORT\_\-WIDTH}}
\index{AXI\_\-PORT\_\-WIDTH@{AXI\_\-PORT\_\-WIDTH}!HDLcd@{HDLcd}}
\subsubsection[{AXI\_\-PORT\_\-WIDTH}]{\setlength{\rightskip}{0pt plus 5cm}const size\_\-t {\bf AXI\_\-PORT\_\-WIDTH} = 8\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classHDLcd_a707d5982e8851aee47eb1250db1c4c3b}
AXI port width in bytes \hypertarget{classHDLcd_adba5c1ae8473b445f9be0125676b2852}{
\index{HDLcd@{HDLcd}!big\_\-endian@{big\_\-endian}}
\index{big\_\-endian@{big\_\-endian}!HDLcd@{HDLcd}}
\subsubsection[{big\_\-endian}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$31$>$ {\bf big\_\-endian}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_adba5c1ae8473b445f9be0125676b2852}
\hypertarget{classHDLcd_af7a5fa704ed84e7d98a264c3ddd8b794}{
\index{HDLcd@{HDLcd}!blue\_\-select@{blue\_\-select}}
\index{blue\_\-select@{blue\_\-select}!HDLcd@{HDLcd}}
\subsubsection[{blue\_\-select}]{\setlength{\rightskip}{0pt plus 5cm}ColorSelectReg {\bf blue\_\-select}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_af7a5fa704ed84e7d98a264c3ddd8b794}
Blue color select register \hypertarget{classHDLcd_ada429bf89af3356a338f9532d68623cc}{
\index{HDLcd@{HDLcd}!bmp@{bmp}}
\index{bmp@{bmp}!HDLcd@{HDLcd}}
\subsubsection[{bmp}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Bitmap}$\ast$ {\bf bmp}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ada429bf89af3356a338f9532d68623cc}
Helper to write out bitmaps \hypertarget{classHDLcd_a74212c0c2707c7e25bad89d6ac3004c9}{
\index{HDLcd@{HDLcd}!burst\_\-len@{burst\_\-len}}
\index{burst\_\-len@{burst\_\-len}!HDLcd@{HDLcd}}
\subsubsection[{burst\_\-len}]{\setlength{\rightskip}{0pt plus 5cm}{\bf burst\_\-len}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a74212c0c2707c7e25bad89d6ac3004c9}
\hypertarget{classHDLcd_ad92f2664318eb7510c5ef4ed537fff93}{
\index{HDLcd@{HDLcd}!bus\_\-error@{bus\_\-error}}
\index{bus\_\-error@{bus\_\-error}!HDLcd@{HDLcd}}
\subsubsection[{bus\_\-error}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$1$>$ {\bf bus\_\-error}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ad92f2664318eb7510c5ef4ed537fff93}
\hypertarget{classHDLcd_afdc67b9cdc0c178e0855cbe989449577}{
\index{HDLcd@{HDLcd}!bus\_\-options@{bus\_\-options}}
\index{bus\_\-options@{bus\_\-options}!HDLcd@{HDLcd}}
\subsubsection[{bus\_\-options}]{\setlength{\rightskip}{0pt plus 5cm}BusOptsReg {\bf bus\_\-options}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_afdc67b9cdc0c178e0855cbe989449577}
\hyperlink{namespaceBus}{Bus} options register \hypertarget{classHDLcd_aaf19ce46531fc85edba07a0a76b30a5f}{
\index{HDLcd@{HDLcd}!BUS\_\-OPTIONS\_\-RESETV@{BUS\_\-OPTIONS\_\-RESETV}}
\index{BUS\_\-OPTIONS\_\-RESETV@{BUS\_\-OPTIONS\_\-RESETV}!HDLcd@{HDLcd}}
\subsubsection[{BUS\_\-OPTIONS\_\-RESETV}]{\setlength{\rightskip}{0pt plus 5cm}const size\_\-t {\bf BUS\_\-OPTIONS\_\-RESETV} = 0x408\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classHDLcd_aaf19ce46531fc85edba07a0a76b30a5f}
Reset value for Bus\_\-Options register \hypertarget{classHDLcd_a6d40f0125f53451c936adc705f608a2b}{
\index{HDLcd@{HDLcd}!bytes\_\-per\_\-pixel@{bytes\_\-per\_\-pixel}}
\index{bytes\_\-per\_\-pixel@{bytes\_\-per\_\-pixel}!HDLcd@{HDLcd}}
\subsubsection[{bytes\_\-per\_\-pixel}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$4,3$>$ {\bf bytes\_\-per\_\-pixel}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a6d40f0125f53451c936adc705f608a2b}
\hypertarget{classHDLcd_a9c5f330aee81c99b318a53af189fbc98}{
\index{HDLcd@{HDLcd}!command@{command}}
\index{command@{command}!HDLcd@{HDLcd}}
\subsubsection[{command}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CommandReg} {\bf command}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a9c5f330aee81c99b318a53af189fbc98}
Command register \hypertarget{classHDLcd_a82bbce2c586afda0822949bce915be7c}{
\index{HDLcd@{HDLcd}!data\_\-polarity@{data\_\-polarity}}
\index{data\_\-polarity@{data\_\-polarity}!HDLcd@{HDLcd}}
\subsubsection[{data\_\-polarity}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$3$>$ {\bf data\_\-polarity}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a82bbce2c586afda0822949bce915be7c}
\hypertarget{classHDLcd_a2e88cca6e78a84d49d34de5407d3d048}{
\index{HDLcd@{HDLcd}!dataen\_\-polarity@{dataen\_\-polarity}}
\index{dataen\_\-polarity@{dataen\_\-polarity}!HDLcd@{HDLcd}}
\subsubsection[{dataen\_\-polarity}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$2$>$ {\bf dataen\_\-polarity}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a2e88cca6e78a84d49d34de5407d3d048}
\hypertarget{classHDLcd_a8ff8f961eef85324f222954cc8ba53ee}{
\index{HDLcd@{HDLcd}!default\_\-color@{default\_\-color}}
\index{default\_\-color@{default\_\-color}!HDLcd@{HDLcd}}
\subsubsection[{default\_\-color}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$23,16$>$ {\bf default\_\-color}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a8ff8f961eef85324f222954cc8ba53ee}
\hypertarget{classHDLcd_afea33d6bd5ce3008fa372e08f27ca95e}{
\index{HDLcd@{HDLcd}!dmaBytesInFlight@{dmaBytesInFlight}}
\index{dmaBytesInFlight@{dmaBytesInFlight}!HDLcd@{HDLcd}}
\subsubsection[{dmaBytesInFlight}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf dmaBytesInFlight}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_afea33d6bd5ce3008fa372e08f27ca95e}
Number of bytes in flight from DMA that have not reached the pixel buffer yet \hypertarget{classHDLcd_afff19aa29c60ac58e1bfa8689c58b923}{
\index{HDLcd@{HDLcd}!dmaCurAddr@{dmaCurAddr}}
\index{dmaCurAddr@{dmaCurAddr}!HDLcd@{HDLcd}}
\subsubsection[{dmaCurAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf dmaCurAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_afff19aa29c60ac58e1bfa8689c58b923}
Next address the dma should read from \hypertarget{classHDLcd_aa50a0179a2d530a0a45d74b014c425fe}{
\index{HDLcd@{HDLcd}!dmaDoneEventAll@{dmaDoneEventAll}}
\index{dmaDoneEventAll@{dmaDoneEventAll}!HDLcd@{HDLcd}}
\subsubsection[{dmaDoneEventAll}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf DmaDoneEvent}$>$ {\bf dmaDoneEventAll}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_aa50a0179a2d530a0a45d74b014c425fe}
All pre-\/allocated DMA done events

The HDLCD model preallocates \hyperlink{classHDLcd_ac032891f1184bb5cfedef5c07217b0e9}{maxOutstandingDma()} number of DmaDoneEvents to avoid having to heap allocate every single event when it is needed. In order to keep track of which events are in flight and which are ready to be used, we use two different vectors. dmaDoneEventAll contains {\itshape all\/} DmaDoneEvents that the object may use, while dmaDoneEventFree contains a list of currently {\itshape unused\/} events. When an event needs to be scheduled, the last element of the dmaDoneEventFree is used and removed from the list. When an event fires, it is added to the end of the dmaEventFreeList. dmaDoneEventAll is never used except for in initialization and serialization. \hypertarget{classHDLcd_ada9c1832b166debd201f034b2fcb4ab2}{
\index{HDLcd@{HDLcd}!dmaDoneEventFree@{dmaDoneEventFree}}
\index{dmaDoneEventFree@{dmaDoneEventFree}!HDLcd@{HDLcd}}
\subsubsection[{dmaDoneEventFree}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf DmaDoneEvent} $\ast$$>$ {\bf dmaDoneEventFree}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ada9c1832b166debd201f034b2fcb4ab2}
Unused DMA done events that are ready to be scheduled \hypertarget{classHDLcd_a49db4d0a53163e636aa5a9e23b93b50c}{
\index{HDLcd@{HDLcd}!dmaMaxAddr@{dmaMaxAddr}}
\index{dmaMaxAddr@{dmaMaxAddr}!HDLcd@{HDLcd}}
\subsubsection[{dmaMaxAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf dmaMaxAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a49db4d0a53163e636aa5a9e23b93b50c}
One byte past the address of the last byte the dma should read from \hypertarget{classHDLcd_a4f93e5868d1229f860a8ca2bfeaa5a12}{
\index{HDLcd@{HDLcd}!dmaPendingNum@{dmaPendingNum}}
\index{dmaPendingNum@{dmaPendingNum}!HDLcd@{HDLcd}}
\subsubsection[{dmaPendingNum}]{\setlength{\rightskip}{0pt plus 5cm}size\_\-t {\bf dmaPendingNum}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a4f93e5868d1229f860a8ca2bfeaa5a12}
Number of pending dma reads \hypertarget{classHDLcd_ae74c38d13416c4966fdd5c7db4678607}{
\index{HDLcd@{HDLcd}!dmaStartAddr@{dmaStartAddr}}
\index{dmaStartAddr@{dmaStartAddr}!HDLcd@{HDLcd}}
\subsubsection[{dmaStartAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf dmaStartAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ae74c38d13416c4966fdd5c7db4678607}
Starting address for the current frame \hypertarget{classHDLcd_ad49d02ec4064ddf6d7055dcdc6128e20}{
\index{HDLcd@{HDLcd}!doUpdateParams@{doUpdateParams}}
\index{doUpdateParams@{doUpdateParams}!HDLcd@{HDLcd}}
\subsubsection[{doUpdateParams}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf doUpdateParams}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ad49d02ec4064ddf6d7055dcdc6128e20}
Flag indicating whether video parameters need updating \hypertarget{classHDLcd_abf8ed1a0152ea70d689ffce800cd32fd}{
\index{HDLcd@{HDLcd}!enableCapture@{enableCapture}}
\index{enableCapture@{enableCapture}!HDLcd@{HDLcd}}
\subsubsection[{enableCapture}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf enableCapture}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_abf8ed1a0152ea70d689ffce800cd32fd}
\hypertarget{classHDLcd_afec13618cf33587eef480a7e70dece76}{
\index{HDLcd@{HDLcd}!endFrameEvent@{endFrameEvent}}
\index{endFrameEvent@{endFrameEvent}!HDLcd@{HDLcd}}
\subsubsection[{endFrameEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf HDLcd}, \&HDLcd::endFrame$>$ {\bf endFrameEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_afec13618cf33587eef480a7e70dece76}
End of frame event \hypertarget{classHDLcd_ad9fd5ba71c5b40acdb6fd9adc4fa408b}{
\index{HDLcd@{HDLcd}!fb\_\-base@{fb\_\-base}}
\index{fb\_\-base@{fb\_\-base}!HDLcd@{HDLcd}}
\subsubsection[{fb\_\-base}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf fb\_\-base}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ad9fd5ba71c5b40acdb6fd9adc4fa408b}
Frame buffer base address register \hypertarget{classHDLcd_a91b3e136cdfa6ff77cbb933239223919}{
\index{HDLcd@{HDLcd}!fb\_\-line\_\-count@{fb\_\-line\_\-count}}
\index{fb\_\-line\_\-count@{fb\_\-line\_\-count}!HDLcd@{HDLcd}}
\subsubsection[{fb\_\-line\_\-count}]{\setlength{\rightskip}{0pt plus 5cm}FbLineCountReg {\bf fb\_\-line\_\-count}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a91b3e136cdfa6ff77cbb933239223919}
Frame buffer Line count register \hypertarget{classHDLcd_adeb07f49b4b2b8898397dbec03f22bb3}{
\index{HDLcd@{HDLcd}!fb\_\-line\_\-count@{fb\_\-line\_\-count}}
\index{fb\_\-line\_\-count@{fb\_\-line\_\-count}!HDLcd@{HDLcd}}
\subsubsection[{fb\_\-line\_\-count}]{\setlength{\rightskip}{0pt plus 5cm}{\bf fb\_\-line\_\-count}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_adeb07f49b4b2b8898397dbec03f22bb3}
\hypertarget{classHDLcd_ab09d20d3fb341f97725e4f27efbee0bd}{
\index{HDLcd@{HDLcd}!fb\_\-line\_\-length@{fb\_\-line\_\-length}}
\index{fb\_\-line\_\-length@{fb\_\-line\_\-length}!HDLcd@{HDLcd}}
\subsubsection[{fb\_\-line\_\-length}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf fb\_\-line\_\-length}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ab09d20d3fb341f97725e4f27efbee0bd}
Frame buffer Line length register \hypertarget{classHDLcd_a4f20b06285d7a67e4182c190c282ab9b}{
\index{HDLcd@{HDLcd}!fb\_\-line\_\-pitch@{fb\_\-line\_\-pitch}}
\index{fb\_\-line\_\-pitch@{fb\_\-line\_\-pitch}!HDLcd@{HDLcd}}
\subsubsection[{fb\_\-line\_\-pitch}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf fb\_\-line\_\-pitch}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a4f20b06285d7a67e4182c190c282ab9b}
Frame buffer Line pitch register \hypertarget{classHDLcd_a1735216e127216309b2b871f35b62fc7}{
\index{HDLcd@{HDLcd}!fillPixelBufferEvent@{fillPixelBufferEvent}}
\index{fillPixelBufferEvent@{fillPixelBufferEvent}!HDLcd@{HDLcd}}
\subsubsection[{fillPixelBufferEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf HDLcd}, \&HDLcd::fillPixelBuffer$>$ {\bf fillPixelBufferEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a1735216e127216309b2b871f35b62fc7}
Fill fifo \hypertarget{classHDLcd_a9c95baa754410596ad866c39aba696f4}{
\index{HDLcd@{HDLcd}!frameReadStartTime@{frameReadStartTime}}
\index{frameReadStartTime@{frameReadStartTime}!HDLcd@{HDLcd}}
\subsubsection[{frameReadStartTime}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf frameReadStartTime}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a9c95baa754410596ad866c39aba696f4}
Start time for frame buffer dma read \hypertarget{classHDLcd_a2c55466de4118724cb375f5d1c7844e8}{
\index{HDLcd@{HDLcd}!frameUnderrun@{frameUnderrun}}
\index{frameUnderrun@{frameUnderrun}!HDLcd@{HDLcd}}
\subsubsection[{frameUnderrun}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf frameUnderrun}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a2c55466de4118724cb375f5d1c7844e8}
Flag indicating whether current frame has underrun \hypertarget{classHDLcd_a36c69169afb7a9e1f41eb2b5fc7516c5}{
\index{HDLcd@{HDLcd}!frameUnderway@{frameUnderway}}
\index{frameUnderway@{frameUnderway}!HDLcd@{HDLcd}}
\subsubsection[{frameUnderway}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf frameUnderway}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a36c69169afb7a9e1f41eb2b5fc7516c5}
Flag indicating whether a frame read / display is in progress \hypertarget{classHDLcd_abe59898cf9345a10d5927b545e832923}{
\index{HDLcd@{HDLcd}!green\_\-select@{green\_\-select}}
\index{green\_\-select@{green\_\-select}!HDLcd@{HDLcd}}
\subsubsection[{green\_\-select}]{\setlength{\rightskip}{0pt plus 5cm}ColorSelectReg {\bf green\_\-select}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_abe59898cf9345a10d5927b545e832923}
Green color select register \hypertarget{classHDLcd_a2bafb13ce63125c580ceb36a81af2817}{
\index{HDLcd@{HDLcd}!h\_\-back\_\-porch@{h\_\-back\_\-porch}}
\index{h\_\-back\_\-porch@{h\_\-back\_\-porch}!HDLcd@{HDLcd}}
\subsubsection[{h\_\-back\_\-porch}]{\setlength{\rightskip}{0pt plus 5cm}TimingReg {\bf h\_\-back\_\-porch}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a2bafb13ce63125c580ceb36a81af2817}
Horizontal back porch width register \hypertarget{classHDLcd_a3610505ba43835b9d3dd548e1848644e}{
\index{HDLcd@{HDLcd}!h\_\-data@{h\_\-data}}
\index{h\_\-data@{h\_\-data}!HDLcd@{HDLcd}}
\subsubsection[{h\_\-data}]{\setlength{\rightskip}{0pt plus 5cm}TimingReg {\bf h\_\-data}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a3610505ba43835b9d3dd548e1848644e}
Horizontal data width register \hypertarget{classHDLcd_ab4874d5422f23d038b1a7274da8f43e7}{
\index{HDLcd@{HDLcd}!h\_\-front\_\-porch@{h\_\-front\_\-porch}}
\index{h\_\-front\_\-porch@{h\_\-front\_\-porch}!HDLcd@{HDLcd}}
\subsubsection[{h\_\-front\_\-porch}]{\setlength{\rightskip}{0pt plus 5cm}TimingReg {\bf h\_\-front\_\-porch}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ab4874d5422f23d038b1a7274da8f43e7}
Horizontal front porch width reg \hypertarget{classHDLcd_a91efa037cb143bc92279f190b4423748}{
\index{HDLcd@{HDLcd}!h\_\-sync@{h\_\-sync}}
\index{h\_\-sync@{h\_\-sync}!HDLcd@{HDLcd}}
\subsubsection[{h\_\-sync}]{\setlength{\rightskip}{0pt plus 5cm}TimingReg {\bf h\_\-sync}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a91efa037cb143bc92279f190b4423748}
Horizontal sync width register \hypertarget{classHDLcd_ae1b5cd178099ce9f30eafb12ccf1bde8}{
\index{HDLcd@{HDLcd}!hsync\_\-polarity@{hsync\_\-polarity}}
\index{hsync\_\-polarity@{hsync\_\-polarity}!HDLcd@{HDLcd}}
\subsubsection[{hsync\_\-polarity}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$1$>$ {\bf hsync\_\-polarity}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ae1b5cd178099ce9f30eafb12ccf1bde8}
\hypertarget{classHDLcd_ab96a978a299a4bf65839845c1c33f414}{
\index{HDLcd@{HDLcd}!int\_\-clear@{int\_\-clear}}
\index{int\_\-clear@{int\_\-clear}!HDLcd@{HDLcd}}
\subsubsection[{int\_\-clear}]{\setlength{\rightskip}{0pt plus 5cm}InterruptReg {\bf int\_\-clear}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ab96a978a299a4bf65839845c1c33f414}
Interrupt clear register \hypertarget{classHDLcd_a8343af5ba122012f4b5b3515d8675b7e}{
\index{HDLcd@{HDLcd}!int\_\-mask@{int\_\-mask}}
\index{int\_\-mask@{int\_\-mask}!HDLcd@{HDLcd}}
\subsubsection[{int\_\-mask}]{\setlength{\rightskip}{0pt plus 5cm}InterruptReg {\bf int\_\-mask}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a8343af5ba122012f4b5b3515d8675b7e}
Interrupt mask register \hypertarget{classHDLcd_af1d60d459d94a3bef2f6e83bdc4c1c43}{
\index{HDLcd@{HDLcd}!int\_\-rawstat@{int\_\-rawstat}}
\index{int\_\-rawstat@{int\_\-rawstat}!HDLcd@{HDLcd}}
\subsubsection[{int\_\-rawstat}]{\setlength{\rightskip}{0pt plus 5cm}InterruptReg {\bf int\_\-rawstat}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_af1d60d459d94a3bef2f6e83bdc4c1c43}
Interrupt raw status register \hypertarget{classHDLcd_a814b02fed91486dd6000055cd1c43e1d}{
\index{HDLcd@{HDLcd}!int\_\-status@{int\_\-status}}
\index{int\_\-status@{int\_\-status}!HDLcd@{HDLcd}}
\subsubsection[{int\_\-status}]{\setlength{\rightskip}{0pt plus 5cm}InterruptReg {\bf int\_\-status}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a814b02fed91486dd6000055cd1c43e1d}
Interrupt status register \hypertarget{classHDLcd_a5ae08b242f478669f0686028d558332a}{
\index{HDLcd@{HDLcd}!intEvent@{intEvent}}
\index{intEvent@{intEvent}!HDLcd@{HDLcd}}
\subsubsection[{intEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf HDLcd}, \&HDLcd::generateInterrupt$>$ {\bf intEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a5ae08b242f478669f0686028d558332a}
Wrapper to create an event out of the interrupt \hypertarget{classHDLcd_aace62e6eea905bd83b1d848acf8e39c9}{
\index{HDLcd@{HDLcd}!MAX\_\-BURST\_\-LEN@{MAX\_\-BURST\_\-LEN}}
\index{MAX\_\-BURST\_\-LEN@{MAX\_\-BURST\_\-LEN}!HDLcd@{HDLcd}}
\subsubsection[{MAX\_\-BURST\_\-LEN}]{\setlength{\rightskip}{0pt plus 5cm}const size\_\-t {\bf MAX\_\-BURST\_\-LEN} = 16\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classHDLcd_aace62e6eea905bd83b1d848acf8e39c9}
max number of beats delivered in one dma burst \hypertarget{classHDLcd_a5f39b2e7351f4500ef1eb5babcb10381}{
\index{HDLcd@{HDLcd}!max\_\-outstanding@{max\_\-outstanding}}
\index{max\_\-outstanding@{max\_\-outstanding}!HDLcd@{HDLcd}}
\subsubsection[{max\_\-outstanding}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$11,8$>$ {\bf max\_\-outstanding}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a5f39b2e7351f4500ef1eb5babcb10381}
\hypertarget{classHDLcd_a5f08b80b40d4315ead7617e660bab910}{
\index{HDLcd@{HDLcd}!MAX\_\-OUTSTANDING\_\-DMA\_\-REQ\_\-CAPACITY@{MAX\_\-OUTSTANDING\_\-DMA\_\-REQ\_\-CAPACITY}}
\index{MAX\_\-OUTSTANDING\_\-DMA\_\-REQ\_\-CAPACITY@{MAX\_\-OUTSTANDING\_\-DMA\_\-REQ\_\-CAPACITY}!HDLcd@{HDLcd}}
\subsubsection[{MAX\_\-OUTSTANDING\_\-DMA\_\-REQ\_\-CAPACITY}]{\setlength{\rightskip}{0pt plus 5cm}const size\_\-t {\bf MAX\_\-OUTSTANDING\_\-DMA\_\-REQ\_\-CAPACITY} = 16\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classHDLcd_a5f08b80b40d4315ead7617e660bab910}
max number of outstanding DMA requests possible \hypertarget{classHDLcd_a7a229a4786deeddd59c6091247a8c8a6}{
\index{HDLcd@{HDLcd}!offset@{offset}}
\index{offset@{offset}!HDLcd@{HDLcd}}
\subsubsection[{offset}]{\setlength{\rightskip}{0pt plus 5cm}{\bf offset}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a7a229a4786deeddd59c6091247a8c8a6}
\hypertarget{classHDLcd_af724472dcdfb49ce72ef865c101a1c0d}{
\index{HDLcd@{HDLcd}!pic@{pic}}
\index{pic@{pic}!HDLcd@{HDLcd}}
\subsubsection[{pic}]{\setlength{\rightskip}{0pt plus 5cm}std::ostream$\ast$ {\bf pic}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_af724472dcdfb49ce72ef865c101a1c0d}
Picture of what the current frame buffer looks like \hypertarget{classHDLcd_a43f658311547cdd328f725c29f629d43}{
\index{HDLcd@{HDLcd}!PIXEL\_\-BUFFER\_\-CAPACITY@{PIXEL\_\-BUFFER\_\-CAPACITY}}
\index{PIXEL\_\-BUFFER\_\-CAPACITY@{PIXEL\_\-BUFFER\_\-CAPACITY}!HDLcd@{HDLcd}}
\subsubsection[{PIXEL\_\-BUFFER\_\-CAPACITY}]{\setlength{\rightskip}{0pt plus 5cm}const size\_\-t {\bf PIXEL\_\-BUFFER\_\-CAPACITY} = 2048\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classHDLcd_a43f658311547cdd328f725c29f629d43}
size of internal buffer in bytes \hypertarget{classHDLcd_aadff074534cd557dcaa412b3a5860be5}{
\index{HDLcd@{HDLcd}!pixel\_\-format@{pixel\_\-format}}
\index{pixel\_\-format@{pixel\_\-format}!HDLcd@{HDLcd}}
\subsubsection[{pixel\_\-format}]{\setlength{\rightskip}{0pt plus 5cm}PixelFormatReg {\bf pixel\_\-format}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_aadff074534cd557dcaa412b3a5860be5}
Pixel format register \hypertarget{classHDLcd_a77d3768993df37b5ded2ce8a0567db9e}{
\index{HDLcd@{HDLcd}!pixelBufferSize@{pixelBufferSize}}
\index{pixelBufferSize@{pixelBufferSize}!HDLcd@{HDLcd}}
\subsubsection[{pixelBufferSize}]{\setlength{\rightskip}{0pt plus 5cm}size\_\-t {\bf pixelBufferSize}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a77d3768993df37b5ded2ce8a0567db9e}
Size of the pixel buffer \hypertarget{classHDLcd_a1482911218ac61eabec3de2d904b8274}{
\index{HDLcd@{HDLcd}!pixelClock@{pixelClock}}
\index{pixelClock@{pixelClock}!HDLcd@{HDLcd}}
\subsubsection[{pixelClock}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Tick} {\bf pixelClock}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a1482911218ac61eabec3de2d904b8274}
Pixel clock period \hypertarget{classHDLcd_a9b265584471f3f05939bd3891884ba23}{
\index{HDLcd@{HDLcd}!pixelIndex@{pixelIndex}}
\index{pixelIndex@{pixelIndex}!HDLcd@{HDLcd}}
\subsubsection[{pixelIndex}]{\setlength{\rightskip}{0pt plus 5cm}size\_\-t {\bf pixelIndex}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a9b265584471f3f05939bd3891884ba23}
Index of the next pixel to render \hypertarget{classHDLcd_a1b4fe6c75f98c50fad2eebc75f143dd2}{
\index{HDLcd@{HDLcd}!polarities@{polarities}}
\index{polarities@{polarities}!HDLcd@{HDLcd}}
\subsubsection[{polarities}]{\setlength{\rightskip}{0pt plus 5cm}PolaritiesReg {\bf polarities}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a1b4fe6c75f98c50fad2eebc75f143dd2}
Polarities register \hypertarget{classHDLcd_ac95f3b4958485c9925b2cb7f0302921f}{
\index{HDLcd@{HDLcd}!product\_\-id@{product\_\-id}}
\index{product\_\-id@{product\_\-id}!HDLcd@{HDLcd}}
\subsubsection[{product\_\-id}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$31,16$>$ {\bf product\_\-id}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ac95f3b4958485c9925b2cb7f0302921f}
\hypertarget{classHDLcd_a4fa9bf08d013c014d2e73e86607b4bed}{
\index{HDLcd@{HDLcd}!pxlclk\_\-polarity@{pxlclk\_\-polarity}}
\index{pxlclk\_\-polarity@{pxlclk\_\-polarity}!HDLcd@{HDLcd}}
\subsubsection[{pxlclk\_\-polarity}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$4$>$ {\bf pxlclk\_\-polarity}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a4fa9bf08d013c014d2e73e86607b4bed}
\hypertarget{classHDLcd_afd72c0120af049b009667393e8d7ce77}{
\index{HDLcd@{HDLcd}!red\_\-select@{red\_\-select}}
\index{red\_\-select@{red\_\-select}!HDLcd@{HDLcd}}
\subsubsection[{red\_\-select}]{\setlength{\rightskip}{0pt plus 5cm}ColorSelectReg {\bf red\_\-select}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_afd72c0120af049b009667393e8d7ce77}
Red color select register \hypertarget{classHDLcd_af37803439ed3050f73510b0f8e0523fc}{
\index{HDLcd@{HDLcd}!renderPixelEvent@{renderPixelEvent}}
\index{renderPixelEvent@{renderPixelEvent}!HDLcd@{HDLcd}}
\subsubsection[{renderPixelEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf HDLcd}, \&HDLcd::renderPixel$>$ {\bf renderPixelEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_af37803439ed3050f73510b0f8e0523fc}
Pixel render event \hypertarget{classHDLcd_aead24f2eb2742ac7708882a7d9616412}{
\index{HDLcd@{HDLcd}!reserved\_\-15\_\-12@{reserved\_\-15\_\-12}}
\index{reserved\_\-15\_\-12@{reserved\_\-15\_\-12}!HDLcd@{HDLcd}}
\subsubsection[{reserved\_\-15\_\-12}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$15,12$>$ {\bf reserved\_\-15\_\-12}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_aead24f2eb2742ac7708882a7d9616412}
\hypertarget{classHDLcd_ad1c96f2932104796b8b9c1dced5ea441}{
\index{HDLcd@{HDLcd}!reserved\_\-2\_\-0@{reserved\_\-2\_\-0}}
\index{reserved\_\-2\_\-0@{reserved\_\-2\_\-0}!HDLcd@{HDLcd}}
\subsubsection[{reserved\_\-2\_\-0}]{\setlength{\rightskip}{0pt plus 5cm}{\bf reserved\_\-2\_\-0}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ad1c96f2932104796b8b9c1dced5ea441}
\hypertarget{classHDLcd_ac7a399166fd9782945b54c1218b6aa3f}{
\index{HDLcd@{HDLcd}!reserved\_\-30\_\-5@{reserved\_\-30\_\-5}}
\index{reserved\_\-30\_\-5@{reserved\_\-30\_\-5}!HDLcd@{HDLcd}}
\subsubsection[{reserved\_\-30\_\-5}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$30,5$>$ {\bf reserved\_\-30\_\-5}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ac7a399166fd9782945b54c1218b6aa3f}
\hypertarget{classHDLcd_a8b3d3dd450f66100b4fc3ee67662400f}{
\index{HDLcd@{HDLcd}!reserved\_\-31\_\-1@{reserved\_\-31\_\-1}}
\index{reserved\_\-31\_\-1@{reserved\_\-31\_\-1}!HDLcd@{HDLcd}}
\subsubsection[{reserved\_\-31\_\-1}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$31,1$>$ {\bf reserved\_\-31\_\-1}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a8b3d3dd450f66100b4fc3ee67662400f}
\hypertarget{classHDLcd_a582dec2bf3d914fb5d2ddb8feaa38111}{
\index{HDLcd@{HDLcd}!reserved\_\-31\_\-12@{reserved\_\-31\_\-12}}
\index{reserved\_\-31\_\-12@{reserved\_\-31\_\-12}!HDLcd@{HDLcd}}
\subsubsection[{reserved\_\-31\_\-12}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$ 31, 12 $>$ {\bf reserved\_\-31\_\-12}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a582dec2bf3d914fb5d2ddb8feaa38111}
\hypertarget{classHDLcd_a55b96b8eb8acba57e5ed38854674db7e}{
\index{HDLcd@{HDLcd}!reserved\_\-31\_\-24@{reserved\_\-31\_\-24}}
\index{reserved\_\-31\_\-24@{reserved\_\-31\_\-24}!HDLcd@{HDLcd}}
\subsubsection[{reserved\_\-31\_\-24}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$31,24$>$ {\bf reserved\_\-31\_\-24}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a55b96b8eb8acba57e5ed38854674db7e}
\hypertarget{classHDLcd_a1ac4b70cb79ab9e24b9a264c8b8be6e4}{
\index{HDLcd@{HDLcd}!reserved\_\-31\_\-5@{reserved\_\-31\_\-5}}
\index{reserved\_\-31\_\-5@{reserved\_\-31\_\-5}!HDLcd@{HDLcd}}
\subsubsection[{reserved\_\-31\_\-5}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$31,5$>$ {\bf reserved\_\-31\_\-5}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a1ac4b70cb79ab9e24b9a264c8b8be6e4}
\hypertarget{classHDLcd_ada612a1f3eac7720c95c8b754b004b62}{
\index{HDLcd@{HDLcd}!reserved\_\-7\_\-5@{reserved\_\-7\_\-5}}
\index{reserved\_\-7\_\-5@{reserved\_\-7\_\-5}!HDLcd@{HDLcd}}
\subsubsection[{reserved\_\-7\_\-5}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$ 7, 5 $>$ {\bf reserved\_\-7\_\-5}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ada612a1f3eac7720c95c8b754b004b62}
\hypertarget{classHDLcd_a9165522b50dc058c1a097ae26260fc61}{
\index{HDLcd@{HDLcd}!size@{size}}
\index{size@{size}!HDLcd@{HDLcd}}
\subsubsection[{size}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$11,8$>$ {\bf size}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a9165522b50dc058c1a097ae26260fc61}
\hypertarget{classHDLcd_ac7738466b6b60afeb71551c4f830d4fa}{
\index{HDLcd@{HDLcd}!startFrameEvent@{startFrameEvent}}
\index{startFrameEvent@{startFrameEvent}!HDLcd@{HDLcd}}
\subsubsection[{startFrameEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf HDLcd}, \&HDLcd::startFrame$>$ {\bf startFrameEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ac7738466b6b60afeb71551c4f830d4fa}
Start of frame event \hypertarget{classHDLcd_a7db18d8a83ae23e4d06cf8d21379b664}{
\index{HDLcd@{HDLcd}!underrun@{underrun}}
\index{underrun@{underrun}!HDLcd@{HDLcd}}
\subsubsection[{underrun}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$3$>$ {\bf underrun}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a7db18d8a83ae23e4d06cf8d21379b664}
\hypertarget{classHDLcd_a47ccc8b58ab3dffa549476540cfff908}{
\index{HDLcd@{HDLcd}!v\_\-back\_\-porch@{v\_\-back\_\-porch}}
\index{v\_\-back\_\-porch@{v\_\-back\_\-porch}!HDLcd@{HDLcd}}
\subsubsection[{v\_\-back\_\-porch}]{\setlength{\rightskip}{0pt plus 5cm}TimingReg {\bf v\_\-back\_\-porch}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a47ccc8b58ab3dffa549476540cfff908}
Vertical back porch width register \hypertarget{classHDLcd_a5a46b3a3d299f421a250c4ca6ca7d17c}{
\index{HDLcd@{HDLcd}!v\_\-data@{v\_\-data}}
\index{v\_\-data@{v\_\-data}!HDLcd@{HDLcd}}
\subsubsection[{v\_\-data}]{\setlength{\rightskip}{0pt plus 5cm}TimingReg {\bf v\_\-data}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a5a46b3a3d299f421a250c4ca6ca7d17c}
Vertical data width register \hypertarget{classHDLcd_ad663411b973f7cad0938ca048f683088}{
\index{HDLcd@{HDLcd}!v\_\-front\_\-porch@{v\_\-front\_\-porch}}
\index{v\_\-front\_\-porch@{v\_\-front\_\-porch}!HDLcd@{HDLcd}}
\subsubsection[{v\_\-front\_\-porch}]{\setlength{\rightskip}{0pt plus 5cm}TimingReg {\bf v\_\-front\_\-porch}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ad663411b973f7cad0938ca048f683088}
Vertical front porch width register \hypertarget{classHDLcd_ac1d1b9a4346f8ab7231a25ba0524ac99}{
\index{HDLcd@{HDLcd}!v\_\-sync@{v\_\-sync}}
\index{v\_\-sync@{v\_\-sync}!HDLcd@{HDLcd}}
\subsubsection[{v\_\-sync}]{\setlength{\rightskip}{0pt plus 5cm}TimingReg {\bf v\_\-sync}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_ac1d1b9a4346f8ab7231a25ba0524ac99}
Vertical sync width register \hypertarget{classHDLcd_acb906433e1289aa1c251dc5057746a88}{
\index{HDLcd@{HDLcd}!val@{val}}
\index{val@{val}!HDLcd@{HDLcd}}
\subsubsection[{val}]{\setlength{\rightskip}{0pt plus 5cm}{\bf val}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_acb906433e1289aa1c251dc5057746a88}
\hypertarget{classHDLcd_a74571fc488367403e0193898d0a5367e}{
\index{HDLcd@{HDLcd}!version\_\-major@{version\_\-major}}
\index{version\_\-major@{version\_\-major}!HDLcd@{HDLcd}}
\subsubsection[{version\_\-major}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$15,8$>$ {\bf version\_\-major}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a74571fc488367403e0193898d0a5367e}
\hypertarget{classHDLcd_a4f40fa952becdbdacf7434cd3c404b7d}{
\index{HDLcd@{HDLcd}!version\_\-minor@{version\_\-minor}}
\index{version\_\-minor@{version\_\-minor}!HDLcd@{HDLcd}}
\subsubsection[{version\_\-minor}]{\setlength{\rightskip}{0pt plus 5cm}{\bf version\_\-minor}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a4f40fa952becdbdacf7434cd3c404b7d}
\hypertarget{classHDLcd_a0cd2a036c21a49eadcc056ff0f20f8dd}{
\index{HDLcd@{HDLcd}!VERSION\_\-RESETV@{VERSION\_\-RESETV}}
\index{VERSION\_\-RESETV@{VERSION\_\-RESETV}!HDLcd@{HDLcd}}
\subsubsection[{VERSION\_\-RESETV}]{\setlength{\rightskip}{0pt plus 5cm}const size\_\-t {\bf VERSION\_\-RESETV} = 0x1CDC0000\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classHDLcd_a0cd2a036c21a49eadcc056ff0f20f8dd}
Reset value for Version register \hypertarget{classHDLcd_af1670e6105cdc695dd52fdde8c18f3e1}{
\index{HDLcd@{HDLcd}!virtualDisplayBuffer@{virtualDisplayBuffer}}
\index{virtualDisplayBuffer@{virtualDisplayBuffer}!HDLcd@{HDLcd}}
\subsubsection[{virtualDisplayBuffer}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t$\ast$ {\bf virtualDisplayBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_af1670e6105cdc695dd52fdde8c18f3e1}
\hyperlink{classHDLcd}{HDLcd} virtual display buffer \hypertarget{classHDLcd_a52d1b5d3426a30e18a452cd67d87ec13}{
\index{HDLcd@{HDLcd}!vnc@{vnc}}
\index{vnc@{vnc}!HDLcd@{HDLcd}}
\subsubsection[{vnc}]{\setlength{\rightskip}{0pt plus 5cm}{\bf VncInput}$\ast$ {\bf vnc}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_a52d1b5d3426a30e18a452cd67d87ec13}
VNC server \hypertarget{classHDLcd_aacc2f986e357e2a77bd80683f3c976aa}{
\index{HDLcd@{HDLcd}!vsync@{vsync}}
\index{vsync@{vsync}!HDLcd@{HDLcd}}
\subsubsection[{vsync}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$2$>$ {\bf vsync}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classHDLcd_aacc2f986e357e2a77bd80683f3c976aa}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/arm/\hyperlink{hdlcd_8hh}{hdlcd.hh}\item 
dev/arm/\hyperlink{hdlcd_8cc}{hdlcd.cc}\end{DoxyCompactItemize}
