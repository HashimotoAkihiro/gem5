\hypertarget{classBaseRemoteGDB}{
\section{クラス BaseRemoteGDB}
\label{classBaseRemoteGDB}\index{BaseRemoteGDB@{BaseRemoteGDB}}
}


{\ttfamily \#include $<$remote\_\-gdb.hh$>$}BaseRemoteGDBに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=1.3913cm]{classBaseRemoteGDB}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classBaseRemoteGDB_1_1Event}{Event}
\item 
class \hyperlink{classBaseRemoteGDB_1_1GdbRegCache}{GdbRegCache}
\item 
class \hyperlink{classBaseRemoteGDB_1_1HardBreakpoint}{HardBreakpoint}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classBaseRemoteGDB_ae59ed2201db88c0668ca26040f6a3ad0}{breakpoint} ()
\item 
void \hyperlink{classBaseRemoteGDB_a36909ca9ba5d0978fe30241da42a0e10}{replaceThreadContext} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\item 
virtual \hyperlink{classBaseRemoteGDB_a04bcb8fd2ed15acbabc951b9a2714870}{$\sim$BaseRemoteGDB} ()
\item 
\hyperlink{classBaseRemoteGDB_a4adca95cc66bef1431e337cc867edf2d}{BaseRemoteGDB} (\hyperlink{classSystem}{System} $\ast$\hyperlink{classBaseRemoteGDB_af27ccd765f13a4b7bd119dc7579e2746}{system}, \hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{classBaseRemoteGDB_a9684dd9218c7836517670f8a0d8f3df7}{context}, size\_\-t cacheSize)
\item 
virtual \hyperlink{classBaseRemoteGDB_a8d9c4468359ca2d976af78ac0c15c0ec}{$\sim$BaseRemoteGDB} ()
\item 
void \hyperlink{classBaseRemoteGDB_a36909ca9ba5d0978fe30241da42a0e10}{replaceThreadContext} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\item 
void \hyperlink{classBaseRemoteGDB_a9b8a915c2058dbc784c223ff9b93f1a5}{attach} (int \hyperlink{classBaseRemoteGDB_a6f8059414f0228f0256115e024eeed4b}{fd})
\item 
void \hyperlink{classBaseRemoteGDB_ac295bade8aee589f6718dfa79edc2a34}{detach} ()
\item 
bool \hyperlink{classBaseRemoteGDB_ab1d071ce59a596e7db67b12d384469cc}{isattached} ()
\item 
virtual bool \hyperlink{classBaseRemoteGDB_ac0968a34e271b194ce3e808a2252d6a3}{acc} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, size\_\-t len)=0
\item 
bool \hyperlink{classBaseRemoteGDB_a24d0c1ce5672f7476a707b0cef30386d}{trap} (int type)
\item 
virtual bool \hyperlink{classBaseRemoteGDB_aa9fdfc3926a9047bc0fb3d7b13030064}{breakpoint} ()
\item 
std::string \hyperlink{classBaseRemoteGDB_aa62b508d2c0e7d9cec12924965276eb5}{name} ()
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
typedef std::map$<$ \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr}, \hyperlink{classBaseRemoteGDB_1_1HardBreakpoint}{HardBreakpoint} $\ast$ $>$ \hyperlink{classBaseRemoteGDB_a1d52d0c05b8ee640ddcd82fe5ec33593}{break\_\-map\_\-t}
\item 
typedef break\_\-map\_\-t::iterator \hyperlink{classBaseRemoteGDB_aa4f6467b8be2918c47e0db3c90948fa2}{break\_\-iter\_\-t}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classBaseRemoteGDB_a32f99cfc81ba23dc0b61a0e11373e1da}{digit2i} (char)
\item 
char \hyperlink{classBaseRemoteGDB_a380e69e2af0b61c399efe68818bed2e2}{i2digit} (int)
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classBaseRemoteGDB_a9d71b1350a41827aa3c4e34409222bc4}{hex2i} (const char $\ast$$\ast$)
\item 
virtual void \hyperlink{classBaseRemoteGDB_ae31bb2c456fc82307f7ab60a59d81e62}{mem2hex} (void $\ast$, const void $\ast$, int)
\item 
virtual const char $\ast$ \hyperlink{classBaseRemoteGDB_a1c09904ab1f0dfd53045815c8023ed99}{hex2mem} (void $\ast$, const char $\ast$, int)
\item 
virtual const char $\ast$ \hyperlink{classBaseRemoteGDB_a16c567d9c992eb13819358b18ab219b6}{break\_\-type} (char c)
\item 
virtual const char $\ast$ \hyperlink{classBaseRemoteGDB_a7bbbec7a5e05f7f9ae638bbe1b72b1d8}{gdb\_\-command} (char cmd)
\item 
uint8\_\-t \hyperlink{classBaseRemoteGDB_a605a0b1dc1ef87abf31b307291475efd}{getbyte} ()
\item 
void \hyperlink{classBaseRemoteGDB_af81af327543d8feab2b0bcc83170d68c}{putbyte} (uint8\_\-t b)
\item 
int \hyperlink{classBaseRemoteGDB_ad39aca9b61a4b34960108fd7c70a40ef}{recv} (char $\ast$data, int len)
\item 
void \hyperlink{classBaseRemoteGDB_ab5ecea9b4516973a35d89b23c4b7961f}{send} (const char $\ast$data)
\item 
virtual bool \hyperlink{classBaseRemoteGDB_a08b012fff4ed4c4cd0f91b482551c75c}{read} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, size\_\-t size, char $\ast$data)
\item 
virtual bool \hyperlink{classBaseRemoteGDB_afbada55bb9d0e9c8c26bb48cb5890111}{write} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, size\_\-t size, const char $\ast$data)
\item 
{\footnotesize template$<$class T $>$ }\\T \hyperlink{classBaseRemoteGDB_a3bfd45e5030624d2d72405e15a25d961}{read} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr)
\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{classBaseRemoteGDB_a45f7320d5f3976e7a792619ba1fb0798}{write} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, T data)
\item 
virtual void \hyperlink{classBaseRemoteGDB_aca04756a764f2ef2add9ee91be012659}{getregs} ()=0
\item 
virtual void \hyperlink{classBaseRemoteGDB_a6b0b51dc196f12756cc0ec49a3ae6a6a}{setregs} ()=0
\item 
virtual void \hyperlink{classBaseRemoteGDB_a69f1887d1310ab6f19cf5bbcdf9d7a1e}{clearSingleStep} ()=0
\item 
virtual void \hyperlink{classBaseRemoteGDB_a253d4b1107e84fe80036d1826067741a}{setSingleStep} ()=0
\item 
\hyperlink{classPCEventQueue}{PCEventQueue} $\ast$ \hyperlink{classBaseRemoteGDB_ac57b158f05697ff67c069696646db0b2}{getPcEventQueue} ()
\item 
bool \hyperlink{classBaseRemoteGDB_a1b9e575ee171c687b3ae8516ae5f8b06}{insertSoftBreak} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, size\_\-t len)
\item 
bool \hyperlink{classBaseRemoteGDB_a0ea4682895df85b1eba96a7050194393}{removeSoftBreak} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, size\_\-t len)
\item 
virtual bool \hyperlink{classBaseRemoteGDB_a6a65f23f1e316fc2362cced431fa2335}{insertHardBreak} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, size\_\-t len)
\item 
bool \hyperlink{classBaseRemoteGDB_a4c7eed355fe612b660050cbea42fb722}{removeHardBreak} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, size\_\-t len)
\item 
void \hyperlink{classBaseRemoteGDB_a93ff11d3bfcc225314165f7b416ec0eb}{clearTempBreakpoint} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \&bkpt)
\item 
void \hyperlink{classBaseRemoteGDB_a4d9f487f6c58b020861024b478729865}{setTempBreakpoint} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} bkpt)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classBaseRemoteGDB_1_1Event}{Event} $\ast$ \hyperlink{classBaseRemoteGDB_a765488c8f26c7f8713d5245212dcae01}{event}
\item 
\hyperlink{classGDBListener}{GDBListener} $\ast$ \hyperlink{classBaseRemoteGDB_a70415b68fb0739613a991b92c4d127a5}{listener}
\item 
int \hyperlink{classBaseRemoteGDB_a7106e2abc437ad981830d14176d15f09}{number}
\item 
int \hyperlink{classBaseRemoteGDB_a6f8059414f0228f0256115e024eeed4b}{fd}
\item 
bool \hyperlink{classBaseRemoteGDB_a03c996f9fcf0e10baeb3e700be0c409a}{active}
\item 
bool \hyperlink{classBaseRemoteGDB_a571d1b910d429b292be1f1c555733f62}{attached}
\item 
\hyperlink{classSystem}{System} $\ast$ \hyperlink{classBaseRemoteGDB_af27ccd765f13a4b7bd119dc7579e2746}{system}
\item 
\hyperlink{classThreadContext}{ThreadContext} $\ast$ \hyperlink{classBaseRemoteGDB_a9684dd9218c7836517670f8a0d8f3df7}{context}
\item 
\hyperlink{classBaseRemoteGDB_1_1GdbRegCache}{GdbRegCache} \hyperlink{classBaseRemoteGDB_a4dbf55c54f47727c96b2cb5d00ca7936}{gdbregs}
\item 
\hyperlink{classBaseRemoteGDB_a1d52d0c05b8ee640ddcd82fe5ec33593}{break\_\-map\_\-t} \hyperlink{classBaseRemoteGDB_a9786e8b1280562520a5041f18dd59b21}{hardBreakMap}
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classBaseRemoteGDB_a9759bc7ba80437d060e93ffb17361c55}{GDBListener}
\item 
class \hyperlink{classBaseRemoteGDB_a3c7b3c89bf96f51e80a919b3a82a3915}{Event}
\item 
class \hyperlink{classBaseRemoteGDB_ad185c0396aa4b55d7f1fbb3749759247}{HardBreakpoint}
\item 
void \hyperlink{classBaseRemoteGDB_a19c86e0d31779f284e91d4d016448264}{debugger} ()
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classBaseRemoteGDB_aa4f6467b8be2918c47e0db3c90948fa2}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!break\_\-iter\_\-t@{break\_\-iter\_\-t}}
\index{break\_\-iter\_\-t@{break\_\-iter\_\-t}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{break\_\-iter\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef break\_\-map\_\-t::iterator {\bf break\_\-iter\_\-t}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_aa4f6467b8be2918c47e0db3c90948fa2}
\hypertarget{classBaseRemoteGDB_a1d52d0c05b8ee640ddcd82fe5ec33593}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!break\_\-map\_\-t@{break\_\-map\_\-t}}
\index{break\_\-map\_\-t@{break\_\-map\_\-t}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{break\_\-map\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef std::map$<${\bf Addr}, {\bf HardBreakpoint} $\ast$$>$ {\bf break\_\-map\_\-t}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a1d52d0c05b8ee640ddcd82fe5ec33593}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classBaseRemoteGDB_a04bcb8fd2ed15acbabc951b9a2714870}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!$\sim$BaseRemoteGDB@{$\sim$BaseRemoteGDB}}
\index{$\sim$BaseRemoteGDB@{$\sim$BaseRemoteGDB}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{$\sim$BaseRemoteGDB}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf BaseRemoteGDB} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classBaseRemoteGDB_a04bcb8fd2ed15acbabc951b9a2714870}



\begin{DoxyCode}
53 {}
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a4adca95cc66bef1431e337cc867edf2d}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!BaseRemoteGDB@{BaseRemoteGDB}}
\index{BaseRemoteGDB@{BaseRemoteGDB}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{BaseRemoteGDB}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseRemoteGDB} ({\bf System} $\ast$ {\em system}, \/  {\bf ThreadContext} $\ast$ {\em context}, \/  size\_\-t {\em cacheSize})}}
\label{classBaseRemoteGDB_a4adca95cc66bef1431e337cc867edf2d}



\begin{DoxyCode}
256     : event(NULL), listener(NULL), number(-1), fd(-1),
257       active(false), attached(false),
258       system(_system), context(c),
259       gdbregs(cacheSize)
260 {
261     memset(gdbregs.regs, 0, gdbregs.bytes());
262 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a8d9c4468359ca2d976af78ac0c15c0ec}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!$\sim$BaseRemoteGDB@{$\sim$BaseRemoteGDB}}
\index{$\sim$BaseRemoteGDB@{$\sim$BaseRemoteGDB}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{$\sim$BaseRemoteGDB}]{\setlength{\rightskip}{0pt plus 5cm}virtual $\sim${\bf BaseRemoteGDB} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classBaseRemoteGDB_a8d9c4468359ca2d976af78ac0c15c0ec}


\subsection{関数}
\hypertarget{classBaseRemoteGDB_ac0968a34e271b194ce3e808a2252d6a3}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!acc@{acc}}
\index{acc@{acc}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{acc}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool acc ({\bf Addr} {\em addr}, \/  size\_\-t {\em len})\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classBaseRemoteGDB_ac0968a34e271b194ce3e808a2252d6a3}


\hyperlink{classPowerISA_1_1RemoteGDB_a07d679884d7893090266b44c9a1520cb}{RemoteGDB}, \hyperlink{classSparcISA_1_1RemoteGDB_ac4c7be164f087f2f53d137d9768809a7}{RemoteGDB}, と \hyperlink{classX86ISA_1_1RemoteGDB_ac4c7be164f087f2f53d137d9768809a7}{RemoteGDB}で実装されています。\hypertarget{classBaseRemoteGDB_a9b8a915c2058dbc784c223ff9b93f1a5}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!attach@{attach}}
\index{attach@{attach}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{attach}]{\setlength{\rightskip}{0pt plus 5cm}void attach (int {\em fd})}}
\label{classBaseRemoteGDB_a9b8a915c2058dbc784c223ff9b93f1a5}



\begin{DoxyCode}
282 {
283     fd = f;
284 
285     event = new Event(this, fd, POLLIN);
286     pollQueue.schedule(event);
287 
288     attached = true;
289     DPRINTFN("remote gdb attached\n");
290 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a16c567d9c992eb13819358b18ab219b6}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!break\_\-type@{break\_\-type}}
\index{break\_\-type@{break\_\-type}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{break\_\-type}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ break\_\-type (char {\em c})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBaseRemoteGDB_a16c567d9c992eb13819358b18ab219b6}



\begin{DoxyCode}
612 {
613     switch(c) {
614       case '0': return "software breakpoint";
615       case '1': return "hardware breakpoint";
616       case '2': return "write watchpoint";
617       case '3': return "read watchpoint";
618       case '4': return "access watchpoint";
619       default: return "unknown breakpoint/watchpoint";
620     }
621 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_aa9fdfc3926a9047bc0fb3d7b13030064}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!breakpoint@{breakpoint}}
\index{breakpoint@{breakpoint}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{breakpoint}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool breakpoint ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classBaseRemoteGDB_aa9fdfc3926a9047bc0fb3d7b13030064}



\begin{DoxyCode}
181     {
182         return trap(SIGTRAP);
183     }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_ae59ed2201db88c0668ca26040f6a3ad0}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!breakpoint@{breakpoint}}
\index{breakpoint@{breakpoint}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{breakpoint}]{\setlength{\rightskip}{0pt plus 5cm}bool breakpoint ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseRemoteGDB_ae59ed2201db88c0668ca26040f6a3ad0}



\begin{DoxyCode}
50 { return false; }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a69f1887d1310ab6f19cf5bbcdf9d7a1e}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!clearSingleStep@{clearSingleStep}}
\index{clearSingleStep@{clearSingleStep}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{clearSingleStep}]{\setlength{\rightskip}{0pt plus 5cm}virtual void clearSingleStep ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classBaseRemoteGDB_a69f1887d1310ab6f19cf5bbcdf9d7a1e}


\hyperlink{classAlphaISA_1_1RemoteGDB_afd89268069d9026378b06b08c97f65f8}{RemoteGDB}, \hyperlink{classArmISA_1_1RemoteGDB_afd89268069d9026378b06b08c97f65f8}{RemoteGDB}, \hyperlink{classMipsISA_1_1RemoteGDB_afd89268069d9026378b06b08c97f65f8}{RemoteGDB}, \hyperlink{classMipsISA_1_1RemoteGDB_afd89268069d9026378b06b08c97f65f8}{RemoteGDB}, \hyperlink{classPowerISA_1_1RemoteGDB_afd89268069d9026378b06b08c97f65f8}{RemoteGDB}, \hyperlink{classSparcISA_1_1RemoteGDB_afd89268069d9026378b06b08c97f65f8}{RemoteGDB}, と \hyperlink{classX86ISA_1_1RemoteGDB_afd89268069d9026378b06b08c97f65f8}{RemoteGDB}で実装されています。\hypertarget{classBaseRemoteGDB_a93ff11d3bfcc225314165f7b416ec0eb}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!clearTempBreakpoint@{clearTempBreakpoint}}
\index{clearTempBreakpoint@{clearTempBreakpoint}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{clearTempBreakpoint}]{\setlength{\rightskip}{0pt plus 5cm}void clearTempBreakpoint ({\bf Addr} \& {\em bkpt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a93ff11d3bfcc225314165f7b416ec0eb}



\begin{DoxyCode}
604 {
605     DPRINTF(GDBMisc, "setTempBreakpoint: addr=%#x\n", bkpt);
606     removeHardBreak(bkpt, sizeof(TheISA::MachInst));
607     bkpt = 0;
608 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_ac295bade8aee589f6718dfa79edc2a34}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!detach@{detach}}
\index{detach@{detach}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{detach}]{\setlength{\rightskip}{0pt plus 5cm}void detach ()}}
\label{classBaseRemoteGDB_ac295bade8aee589f6718dfa79edc2a34}



\begin{DoxyCode}
294 {
295     attached = false;
296     close(fd);
297     fd = -1;
298 
299     pollQueue.remove(event);
300     DPRINTFN("remote gdb detached\n");
301 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a32f99cfc81ba23dc0b61a0e11373e1da}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!digit2i@{digit2i}}
\index{digit2i@{digit2i}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{digit2i}]{\setlength{\rightskip}{0pt plus 5cm}int digit2i (char {\em c})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a32f99cfc81ba23dc0b61a0e11373e1da}



\begin{DoxyCode}
947 {
948     if (c >= '0' && c <= '9')
949         return (c - '0');
950     else if (c >= 'a' && c <= 'f')
951         return (c - 'a' + 10);
952     else if (c >= 'A' && c <= 'F')
953 
954         return (c - 'A' + 10);
955     else
956         return (-1);
957 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a7bbbec7a5e05f7f9ae638bbe1b72b1d8}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!gdb\_\-command@{gdb\_\-command}}
\index{gdb\_\-command@{gdb\_\-command}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{gdb\_\-command}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ gdb\_\-command (char {\em cmd})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBaseRemoteGDB_a7bbbec7a5e05f7f9ae638bbe1b72b1d8}



\begin{DoxyCode}
305 {
306     switch (cmd) {
307       case GDBSignal: return "KGDB_SIGNAL";
308       case GDBSetBaud: return "KGDB_SET_BAUD";
309       case GDBSetBreak: return "KGDB_SET_BREAK";
310       case GDBCont: return "KGDB_CONT";
311       case GDBAsyncCont: return "KGDB_ASYNC_CONT";
312       case GDBDebug: return "KGDB_DEBUG";
313       case GDBDetach: return "KGDB_DETACH";
314       case GDBRegR: return "KGDB_REG_R";
315       case GDBRegW: return "KGDB_REG_W";
316       case GDBSetThread: return "KGDB_SET_THREAD";
317       case GDBCycleStep: return "KGDB_CYCLE_STEP";
318       case GDBSigCycleStep: return "KGDB_SIG_CYCLE_STEP";
319       case GDBKill: return "KGDB_KILL";
320       case GDBMemW: return "KGDB_MEM_W";
321       case GDBMemR: return "KGDB_MEM_R";
322       case GDBSetReg: return "KGDB_SET_REG";
323       case GDBReadReg: return "KGDB_READ_REG";
324       case GDBQueryVar: return "KGDB_QUERY_VAR";
325       case GDBSetVar: return "KGDB_SET_VAR";
326       case GDBReset: return "KGDB_RESET";
327       case GDBStep: return "KGDB_STEP";
328       case GDBAsyncStep: return "KGDB_ASYNC_STEP";
329       case GDBThreadAlive: return "KGDB_THREAD_ALIVE";
330       case GDBTargetExit: return "KGDB_TARGET_EXIT";
331       case GDBBinaryDload: return "KGDB_BINARY_DLOAD";
332       case GDBClrHwBkpt: return "KGDB_CLR_HW_BKPT";
333       case GDBSetHwBkpt: return "KGDB_SET_HW_BKPT";
334       case GDBStart: return "KGDB_START";
335       case GDBEnd: return "KGDB_END";
336       case GDBGoodP: return "KGDB_GOODP";
337       case GDBBadP: return "KGDB_BADP";
338       default: return "KGDB_UNKNOWN";
339     }
340 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a605a0b1dc1ef87abf31b307291475efd}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!getbyte@{getbyte}}
\index{getbyte@{getbyte}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{getbyte}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t getbyte ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a605a0b1dc1ef87abf31b307291475efd}



\begin{DoxyCode}
348 {
349     uint8_t b;
350     if (::read(fd, &b, 1) != 1)
351         warn("could not read byte from debugger");
352     return b;
353 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_ac57b158f05697ff67c069696646db0b2}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!getPcEventQueue@{getPcEventQueue}}
\index{getPcEventQueue@{getPcEventQueue}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{getPcEventQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PCEventQueue} $\ast$ getPcEventQueue ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_ac57b158f05697ff67c069696646db0b2}



\begin{DoxyCode}
519 {
520     return &system->pcEventQueue;
521 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_aca04756a764f2ef2add9ee91be012659}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!getregs@{getregs}}
\index{getregs@{getregs}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{getregs}]{\setlength{\rightskip}{0pt plus 5cm}virtual void getregs ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classBaseRemoteGDB_aca04756a764f2ef2add9ee91be012659}


\hyperlink{classAlphaISA_1_1RemoteGDB_a62bc8adc5a48f1cbb5eb9bb64301d38d}{RemoteGDB}, \hyperlink{classArmISA_1_1RemoteGDB_a62bc8adc5a48f1cbb5eb9bb64301d38d}{RemoteGDB}, \hyperlink{classMipsISA_1_1RemoteGDB_a62bc8adc5a48f1cbb5eb9bb64301d38d}{RemoteGDB}, \hyperlink{classMipsISA_1_1RemoteGDB_a62bc8adc5a48f1cbb5eb9bb64301d38d}{RemoteGDB}, \hyperlink{classPowerISA_1_1RemoteGDB_a62bc8adc5a48f1cbb5eb9bb64301d38d}{RemoteGDB}, \hyperlink{classSparcISA_1_1RemoteGDB_a62bc8adc5a48f1cbb5eb9bb64301d38d}{RemoteGDB}, と \hyperlink{classX86ISA_1_1RemoteGDB_a62bc8adc5a48f1cbb5eb9bb64301d38d}{RemoteGDB}で実装されています。\hypertarget{classBaseRemoteGDB_a9d71b1350a41827aa3c4e34409222bc4}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!hex2i@{hex2i}}
\index{hex2i@{hex2i}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{hex2i}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} hex2i (const char $\ast$$\ast$ {\em srcp})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a9d71b1350a41827aa3c4e34409222bc4}



\begin{DoxyCode}
1007 {
1008     const char *src = *srcp;
1009     Addr r = 0;
1010     int nibble;
1011 
1012     while ((nibble = digit2i(*src)) >= 0) {
1013         r *= 16;
1014         r += nibble;
1015         src++;
1016     }
1017     *srcp = src;
1018     return (r);
1019 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a1c09904ab1f0dfd53045815c8023ed99}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!hex2mem@{hex2mem}}
\index{hex2mem@{hex2mem}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{hex2mem}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ hex2mem (void $\ast$ {\em vdst}, \/  const char $\ast$ {\em src}, \/  int {\em maxlen})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBaseRemoteGDB_a1c09904ab1f0dfd53045815c8023ed99}



\begin{DoxyCode}
986 {
987     char *dst = (char *)vdst;
988     int msb, lsb;
989 
990     while (*src && maxlen--) {
991         msb = digit2i(*src++);
992         if (msb < 0)
993             return (src - 1);
994         lsb = digit2i(*src++);
995         if (lsb < 0)
996             return (NULL);
997         *dst++ = (msb << 4) | lsb;
998     }
999     return (src);
1000 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a380e69e2af0b61c399efe68818bed2e2}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!i2digit@{i2digit}}
\index{i2digit@{i2digit}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{i2digit}]{\setlength{\rightskip}{0pt plus 5cm}char i2digit (int {\em n})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a380e69e2af0b61c399efe68818bed2e2}



\begin{DoxyCode}
962 {
963     return ("0123456789abcdef"[n & 0x0f]);
964 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a6a65f23f1e316fc2362cced431fa2335}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!insertHardBreak@{insertHardBreak}}
\index{insertHardBreak@{insertHardBreak}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{insertHardBreak}]{\setlength{\rightskip}{0pt plus 5cm}bool insertHardBreak ({\bf Addr} {\em addr}, \/  size\_\-t {\em len})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBaseRemoteGDB_a6a65f23f1e316fc2362cced431fa2335}



\begin{DoxyCode}
559 {
560     if (len != sizeof(MachInst))
561         panic("invalid length\n");
562 
563     DPRINTF(GDBMisc, "inserting hardware breakpoint at %#x\n", addr);
564 
565     HardBreakpoint *&bkpt = hardBreakMap[addr];
566     if (bkpt == 0)
567         bkpt = new HardBreakpoint(this, addr);
568 
569     bkpt->refcount++;
570 
571     return true;
572 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a1b9e575ee171c687b3ae8516ae5f8b06}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!insertSoftBreak@{insertSoftBreak}}
\index{insertSoftBreak@{insertSoftBreak}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{insertSoftBreak}]{\setlength{\rightskip}{0pt plus 5cm}bool insertSoftBreak ({\bf Addr} {\em addr}, \/  size\_\-t {\em len})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a1b9e575ee171c687b3ae8516ae5f8b06}



\begin{DoxyCode}
541 {
542     if (len != sizeof(TheISA::MachInst))
543         panic("invalid length\n");
544 
545     return insertHardBreak(addr, len);
546 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_ab1d071ce59a596e7db67b12d384469cc}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!isattached@{isattached}}
\index{isattached@{isattached}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{isattached}]{\setlength{\rightskip}{0pt plus 5cm}bool isattached ()}}
\label{classBaseRemoteGDB_ab1d071ce59a596e7db67b12d384469cc}



\begin{DoxyCode}
278 { return attached; }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_ae31bb2c456fc82307f7ab60a59d81e62}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!mem2hex@{mem2hex}}
\index{mem2hex@{mem2hex}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{mem2hex}]{\setlength{\rightskip}{0pt plus 5cm}void mem2hex (void $\ast$ {\em vdst}, \/  const void $\ast$ {\em vsrc}, \/  int {\em len})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBaseRemoteGDB_ae31bb2c456fc82307f7ab60a59d81e62}



\begin{DoxyCode}
969 {
970     char *dst = (char *)vdst;
971     const char *src = (const char *)vsrc;
972 
973     while (len--) {
974         *dst++ = i2digit(*src >> 4);
975         *dst++ = i2digit(*src++);
976     }
977     *dst = '\0';
978 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_aa62b508d2c0e7d9cec12924965276eb5}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!name@{name}}
\index{name@{name}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}string name ()}}
\label{classBaseRemoteGDB_aa62b508d2c0e7d9cec12924965276eb5}



\begin{DoxyCode}
272 {
273     return system->name() + ".remote_gdb";
274 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_af81af327543d8feab2b0bcc83170d68c}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!putbyte@{putbyte}}
\index{putbyte@{putbyte}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{putbyte}]{\setlength{\rightskip}{0pt plus 5cm}void putbyte (uint8\_\-t {\em b})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_af81af327543d8feab2b0bcc83170d68c}



\begin{DoxyCode}
357 {
358     if (::write(fd, &b, 1) != 1)
359         warn("could not write byte to debugger");
360 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a3bfd45e5030624d2d72405e15a25d961}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!read@{read}}
\index{read@{read}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}T read ({\bf Addr} {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classBaseRemoteGDB_a3bfd45e5030624d2d72405e15a25d961}



\begin{DoxyCode}
231 {
232     T temp;
233     read(addr, sizeof(T), (char *)&temp);
234     return temp;
235 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a08b012fff4ed4c4cd0f91b482551c75c}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!read@{read}}
\index{read@{read}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}bool read ({\bf Addr} {\em addr}, \/  size\_\-t {\em size}, \/  char $\ast$ {\em data})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBaseRemoteGDB_a08b012fff4ed4c4cd0f91b482551c75c}



\begin{DoxyCode}
453 {
454     static Addr lastaddr = 0;
455     static size_t lastsize = 0;
456 
457     if (vaddr < 10) {
458       DPRINTF(GDBRead, "read:  reading memory location zero!\n");
459       vaddr = lastaddr + lastsize;
460     }
461 
462     DPRINTF(GDBRead, "read:  addr=%#x, size=%d", vaddr, size);
463 
464     if (FullSystem) {
465         FSTranslatingPortProxy &proxy = context->getVirtProxy();
466         proxy.readBlob(vaddr, (uint8_t*)data, size);
467     } else {
468         SETranslatingPortProxy &proxy = context->getMemProxy();
469         proxy.readBlob(vaddr, (uint8_t*)data, size);
470     }
471 
472 #if TRACING_ON
473     if (DTRACE(GDBRead)) {
474         if (DTRACE(GDBExtra)) {
475             char buf[1024];
476             mem2hex(buf, data, size);
477             DPRINTFNR(": %s\n", buf);
478         } else
479             DPRINTFNR("\n");
480     }
481 #endif
482 
483     return true;
484 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_ad39aca9b61a4b34960108fd7c70a40ef}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!recv@{recv}}
\index{recv@{recv}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{recv}]{\setlength{\rightskip}{0pt plus 5cm}int recv (char $\ast$ {\em data}, \/  int {\em len})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_ad39aca9b61a4b34960108fd7c70a40ef}



\begin{DoxyCode}
393 {
394     char *p;
395     int c, csum;
396     int len;
397 
398     do {
399         p = bp;
400         csum = len = 0;
401         //Find the beginning of a packet
402         while ((c = getbyte()) != GDBStart)
403             ;
404 
405         //Read until you find the end of the data in the packet, and keep
406         //track of the check sum.
407         while ((c = getbyte()) != GDBEnd && len < maxlen) {
408             c &= 0x7f;
409             csum += c;
410             *p++ = c;
411             len++;
412         }
413 
414         //Mask the check sum, and terminate the command string.
415         csum &= 0xff;
416         *p = '\0';
417 
418         //If the command was too long, report an error.
419         if (len >= maxlen) {
420             putbyte(GDBBadP);
421             continue;
422         }
423 
424         //Bring in the checksum. If the check sum matches, csum will be 0.
425         csum -= digit2i(getbyte()) * 16;
426         csum -= digit2i(getbyte());
427 
428         //If the check sum was correct
429         if (csum == 0) {
430             //Report that the packet was received correctly
431             putbyte(GDBGoodP);
432             // Sequence present?
433             if (bp[2] == ':') {
434                 putbyte(bp[0]);
435                 putbyte(bp[1]);
436                 len -= 3;
437                 memcpy(bp, bp+3, len);
438             }
439             break;
440         }
441         //Otherwise, report that there was a mistake.
442         putbyte(GDBBadP);
443     } while (1);
444 
445     DPRINTF(GDBRecv, "recv:  %s: %s\n", gdb_command(*bp), bp);
446 
447     return (len);
448 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a4c7eed355fe612b660050cbea42fb722}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!removeHardBreak@{removeHardBreak}}
\index{removeHardBreak@{removeHardBreak}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{removeHardBreak}]{\setlength{\rightskip}{0pt plus 5cm}bool removeHardBreak ({\bf Addr} {\em addr}, \/  size\_\-t {\em len})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a4c7eed355fe612b660050cbea42fb722}



\begin{DoxyCode}
576 {
577     if (len != sizeof(MachInst))
578         panic("invalid length\n");
579 
580     DPRINTF(GDBMisc, "removing hardware breakpoint at %#x\n", addr);
581 
582     break_iter_t i = hardBreakMap.find(addr);
583     if (i == hardBreakMap.end())
584         return false;
585 
586     HardBreakpoint *hbp = (*i).second;
587     if (--hbp->refcount == 0) {
588         delete hbp;
589         hardBreakMap.erase(i);
590     }
591 
592     return true;
593 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a0ea4682895df85b1eba96a7050194393}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!removeSoftBreak@{removeSoftBreak}}
\index{removeSoftBreak@{removeSoftBreak}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{removeSoftBreak}]{\setlength{\rightskip}{0pt plus 5cm}bool removeSoftBreak ({\bf Addr} {\em addr}, \/  size\_\-t {\em len})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a0ea4682895df85b1eba96a7050194393}



\begin{DoxyCode}
550 {
551     if (len != sizeof(MachInst))
552         panic("invalid length\n");
553 
554     return removeHardBreak(addr, len);
555 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a36909ca9ba5d0978fe30241da42a0e10}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!replaceThreadContext@{replaceThreadContext}}
\index{replaceThreadContext@{replaceThreadContext}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{replaceThreadContext}]{\setlength{\rightskip}{0pt plus 5cm}void replaceThreadContext ({\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseRemoteGDB_a36909ca9ba5d0978fe30241da42a0e10}



\begin{DoxyCode}
172 { context = tc; }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a36909ca9ba5d0978fe30241da42a0e10}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!replaceThreadContext@{replaceThreadContext}}
\index{replaceThreadContext@{replaceThreadContext}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{replaceThreadContext}]{\setlength{\rightskip}{0pt plus 5cm}void replaceThreadContext ({\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBaseRemoteGDB_a36909ca9ba5d0978fe30241da42a0e10}



\begin{DoxyCode}
51 {}
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_ab5ecea9b4516973a35d89b23c4b7961f}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!send@{send}}
\index{send@{send}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{send}]{\setlength{\rightskip}{0pt plus 5cm}void send (const char $\ast$ {\em data})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_ab5ecea9b4516973a35d89b23c4b7961f}



\begin{DoxyCode}
365 {
366     const char *p;
367     uint8_t csum, c;
368 
369     DPRINTF(GDBSend, "send:  %s\n", bp);
370 
371     do {
372         p = bp;
373         //Start sending a packet
374         putbyte(GDBStart);
375         //Send the contents, and also keep a check sum.
376         for (csum = 0; (c = *p); p++) {
377             putbyte(c);
378             csum += c;
379         }
380         //Send the ending character.
381         putbyte(GDBEnd);
382         //Sent the checksum.
383         putbyte(i2digit(csum >> 4));
384         putbyte(i2digit(csum));
385         //Try transmitting over and over again until the other end doesn't send a
      n
386         //error back.
387     } while ((c = getbyte() & 0x7f) == GDBBadP);
388 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a6b0b51dc196f12756cc0ec49a3ae6a6a}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!setregs@{setregs}}
\index{setregs@{setregs}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{setregs}]{\setlength{\rightskip}{0pt plus 5cm}virtual void setregs ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classBaseRemoteGDB_a6b0b51dc196f12756cc0ec49a3ae6a6a}


\hyperlink{classAlphaISA_1_1RemoteGDB_a2051121b6bc93c8ca3856bbeeca7bdc1}{RemoteGDB}, \hyperlink{classArmISA_1_1RemoteGDB_a2051121b6bc93c8ca3856bbeeca7bdc1}{RemoteGDB}, \hyperlink{classMipsISA_1_1RemoteGDB_a2051121b6bc93c8ca3856bbeeca7bdc1}{RemoteGDB}, \hyperlink{classMipsISA_1_1RemoteGDB_a2051121b6bc93c8ca3856bbeeca7bdc1}{RemoteGDB}, \hyperlink{classPowerISA_1_1RemoteGDB_a2051121b6bc93c8ca3856bbeeca7bdc1}{RemoteGDB}, \hyperlink{classSparcISA_1_1RemoteGDB_a2051121b6bc93c8ca3856bbeeca7bdc1}{RemoteGDB}, と \hyperlink{classX86ISA_1_1RemoteGDB_a2051121b6bc93c8ca3856bbeeca7bdc1}{RemoteGDB}で実装されています。\hypertarget{classBaseRemoteGDB_a253d4b1107e84fe80036d1826067741a}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!setSingleStep@{setSingleStep}}
\index{setSingleStep@{setSingleStep}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{setSingleStep}]{\setlength{\rightskip}{0pt plus 5cm}virtual void setSingleStep ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classBaseRemoteGDB_a253d4b1107e84fe80036d1826067741a}


\hyperlink{classAlphaISA_1_1RemoteGDB_a40d5da340fdb741de8cd3ffbc69708fe}{RemoteGDB}, \hyperlink{classArmISA_1_1RemoteGDB_a40d5da340fdb741de8cd3ffbc69708fe}{RemoteGDB}, \hyperlink{classMipsISA_1_1RemoteGDB_a40d5da340fdb741de8cd3ffbc69708fe}{RemoteGDB}, \hyperlink{classMipsISA_1_1RemoteGDB_a40d5da340fdb741de8cd3ffbc69708fe}{RemoteGDB}, \hyperlink{classPowerISA_1_1RemoteGDB_a40d5da340fdb741de8cd3ffbc69708fe}{RemoteGDB}, \hyperlink{classSparcISA_1_1RemoteGDB_a40d5da340fdb741de8cd3ffbc69708fe}{RemoteGDB}, と \hyperlink{classX86ISA_1_1RemoteGDB_a40d5da340fdb741de8cd3ffbc69708fe}{RemoteGDB}で実装されています。\hypertarget{classBaseRemoteGDB_a4d9f487f6c58b020861024b478729865}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!setTempBreakpoint@{setTempBreakpoint}}
\index{setTempBreakpoint@{setTempBreakpoint}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{setTempBreakpoint}]{\setlength{\rightskip}{0pt plus 5cm}void setTempBreakpoint ({\bf Addr} {\em bkpt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a4d9f487f6c58b020861024b478729865}



\begin{DoxyCode}
597 {
598     DPRINTF(GDBMisc, "setTempBreakpoint: addr=%#x\n", bkpt);
599     insertHardBreak(bkpt, sizeof(TheISA::MachInst));
600 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a24d0c1ce5672f7476a707b0cef30386d}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!trap@{trap}}
\index{trap@{trap}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{trap}]{\setlength{\rightskip}{0pt plus 5cm}bool trap (int {\em type})}}
\label{classBaseRemoteGDB_a24d0c1ce5672f7476a707b0cef30386d}



\begin{DoxyCode}
630 {
631     uint64_t val;
632     size_t datalen, len;
633     char data[GDBPacketBufLen + 1];
634     char *buffer;
635     size_t bufferSize;
636     const char *p;
637     char command, subcmd;
638     string var;
639     bool ret;
640 
641     if (!attached)
642         return false;
643 
644     bufferSize = gdbregs.bytes() * 2 + 256;
645     buffer = (char*)malloc(bufferSize);
646 
647     DPRINTF(GDBMisc, "trap: PC=%s\n", context->pcState());
648 
649     clearSingleStep();
650 
651     /*
652      * The first entry to this function is normally through
653      * a breakpoint trap in kgdb_connect(), in which case we
654      * must advance past the breakpoint because gdb will not.
655      *
656      * On the first entry here, we expect that gdb is not yet
657      * listening to us, so just enter the interaction loop.
658      * After the debugger is "active" (connected) it will be
659      * waiting for a "signaled" message from us.
660      */
661     if (!active)
662         active = true;
663     else
664         // Tell remote host that an exception has occurred.
665         snprintf((char *)buffer, bufferSize, "S%02x", type);
666         send(buffer);
667 
668     // Stick frame regs into our reg cache.
669     getregs();
670 
671     for (;;) {
672         datalen = recv(data, sizeof(data));
673         data[sizeof(data) - 1] = 0; // Sentinel
674         command = data[0];
675         subcmd = 0;
676         p = data + 1;
677         switch (command) {
678 
679           case GDBSignal:
680             // if this command came from a running gdb, answer it --
681             // the other guy has no way of knowing if we're in or out
682             // of this loop when he issues a "remote-signal".
683             snprintf((char *)buffer, bufferSize,
684                     "S%02x", type);
685             send(buffer);
686             continue;
687 
688           case GDBRegR:
689             if (2 * gdbregs.bytes() > bufferSize)
690                 panic("buffer too small");
691 
692             mem2hex(buffer, gdbregs.regs, gdbregs.bytes());
693             send(buffer);
694             continue;
695 
696           case GDBRegW:
697             p = hex2mem(gdbregs.regs, p, gdbregs.bytes());
698             if (p == NULL || *p != '\0')
699                 send("E01");
700             else {
701                 setregs();
702                 send("OK");
703             }
704             continue;
705 
706 #if 0
707           case GDBSetReg:
708             val = hex2i(&p);
709             if (*p++ != '=') {
710                 send("E01");
711                 continue;
712             }
713             if (val < 0 && val >= KGDB_NUMREGS) {
714                 send("E01");
715                 continue;
716             }
717 
718             gdbregs.regs[val] = hex2i(&p);
719             setregs();
720             send("OK");
721 
722             continue;
723 #endif
724 
725           case GDBMemR:
726             val = hex2i(&p);
727             if (*p++ != ',') {
728                 send("E02");
729                 continue;
730             }
731             len = hex2i(&p);
732             if (*p != '\0') {
733                 send("E03");
734                 continue;
735             }
736             if (len > bufferSize) {
737                 send("E04");
738                 continue;
739             }
740             if (!acc(val, len)) {
741                 send("E05");
742                 continue;
743             }
744 
745             if (read(val, (size_t)len, (char *)buffer)) {
746                // variable length array would be nice, but C++ doesn't
747                // officially support those...
748                char *temp = new char[2*len+1];
749                mem2hex(temp, buffer, len);
750                send(temp);
751                delete [] temp;
752             } else {
753                send("E05");
754             }
755             continue;
756 
757           case GDBMemW:
758             val = hex2i(&p);
759             if (*p++ != ',') {
760                 send("E06");
761                 continue;
762             }
763             len = hex2i(&p);
764             if (*p++ != ':') {
765                 send("E07");
766                 continue;
767             }
768             if (len > datalen - (p - data)) {
769                 send("E08");
770                 continue;
771             }
772             p = hex2mem(buffer, p, bufferSize);
773             if (p == NULL) {
774                 send("E09");
775                 continue;
776             }
777             if (!acc(val, len)) {
778                 send("E0A");
779                 continue;
780             }
781             if (write(val, (size_t)len, (char *)buffer))
782               send("OK");
783             else
784               send("E0B");
785             continue;
786 
787           case GDBSetThread:
788             subcmd = *p++;
789             val = hex2i(&p);
790             if (val == 0)
791                 send("OK");
792             else
793                 send("E01");
794             continue;
795 
796           case GDBDetach:
797           case GDBKill:
798             active = false;
799             clearSingleStep();
800             detach();
801             goto out;
802 
803           case GDBAsyncCont:
804             subcmd = hex2i(&p);
805             if (*p++ == ';') {
806                 val = hex2i(&p);
807                 context->pcState(val);
808             }
809             clearSingleStep();
810             goto out;
811 
812           case GDBCont:
813             if (p - data < (ptrdiff_t)datalen) {
814                 val = hex2i(&p);
815                 context->pcState(val);
816             }
817             clearSingleStep();
818             goto out;
819 
820           case GDBAsyncStep:
821             subcmd = hex2i(&p);
822             if (*p++ == ';') {
823                 val = hex2i(&p);
824                 context->pcState(val);
825             }
826             setSingleStep();
827             goto out;
828 
829           case GDBStep:
830             if (p - data < (ptrdiff_t)datalen) {
831                 val = hex2i(&p);
832                 context->pcState(val);
833             }
834             setSingleStep();
835             goto out;
836 
837           case GDBClrHwBkpt:
838             subcmd = *p++;
839             if (*p++ != ',') send("E0D");
840             val = hex2i(&p);
841             if (*p++ != ',') send("E0D");
842             len = hex2i(&p);
843 
844             DPRINTF(GDBMisc, "clear %s, addr=%#x, len=%d\n",
845                     break_type(subcmd), val, len);
846 
847             ret = false;
848 
849             switch (subcmd) {
850               case '0': // software breakpoint
851                 ret = removeSoftBreak(val, len);
852                 break;
853 
854               case '1': // hardware breakpoint
855                 ret = removeHardBreak(val, len);
856                 break;
857 
858               case '2': // write watchpoint
859               case '3': // read watchpoint
860               case '4': // access watchpoint
861               default: // unknown
862                 send("");
863                 break;
864             }
865 
866             send(ret ? "OK" : "E0C");
867             continue;
868 
869           case GDBSetHwBkpt:
870             subcmd = *p++;
871             if (*p++ != ',') send("E0D");
872             val = hex2i(&p);
873             if (*p++ != ',') send("E0D");
874             len = hex2i(&p);
875 
876             DPRINTF(GDBMisc, "set %s, addr=%#x, len=%d\n",
877                     break_type(subcmd), val, len);
878 
879             ret = false;
880 
881             switch (subcmd) {
882               case '0': // software breakpoint
883                 ret = insertSoftBreak(val, len);
884                 break;
885 
886               case '1': // hardware breakpoint
887                 ret = insertHardBreak(val, len);
888                 break;
889 
890               case '2': // write watchpoint
891               case '3': // read watchpoint
892               case '4': // access watchpoint
893               default: // unknown
894                 send("");
895                 break;
896             }
897 
898             send(ret ? "OK" : "E0C");
899             continue;
900 
901           case GDBQueryVar:
902             var = string(p, datalen - 1);
903             if (var == "C")
904                 send("QC0");
905             else
906                 send("");
907             continue;
908 
909           case GDBSetBaud:
910           case GDBSetBreak:
911           case GDBDebug:
912           case GDBCycleStep:
913           case GDBSigCycleStep:
914           case GDBReadReg:
915           case GDBSetVar:
916           case GDBReset:
917           case GDBThreadAlive:
918           case GDBTargetExit:
919           case GDBBinaryDload:
920             // Unsupported command
921             DPRINTF(GDBMisc, "Unsupported command: %s\n",
922                     gdb_command(command));
923             DDUMP(GDBMisc, (uint8_t *)data, datalen);
924             send("");
925             continue;
926 
927           default:
928             // Unknown command.
929             DPRINTF(GDBMisc, "Unknown command: %c(%#x)\n",
930                     command, command);
931             send("");
932             continue;
933 
934 
935         }
936     }
937 
938   out:
939     free(buffer);
940     return true;
941 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a45f7320d5f3976e7a792619ba1fb0798}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!write@{write}}
\index{write@{write}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}void write ({\bf Addr} {\em addr}, \/  T {\em data})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classBaseRemoteGDB_a45f7320d5f3976e7a792619ba1fb0798}



\begin{DoxyCode}
240 { write(addr, sizeof(T), (const char *)&data); }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_afbada55bb9d0e9c8c26bb48cb5890111}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!write@{write}}
\index{write@{write}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}bool write ({\bf Addr} {\em addr}, \/  size\_\-t {\em size}, \/  const char $\ast$ {\em data})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBaseRemoteGDB_afbada55bb9d0e9c8c26bb48cb5890111}



\begin{DoxyCode}
489 {
490     static Addr lastaddr = 0;
491     static size_t lastsize = 0;
492 
493     if (vaddr < 10) {
494       DPRINTF(GDBWrite, "write: writing memory location zero!\n");
495       vaddr = lastaddr + lastsize;
496     }
497 
498     if (DTRACE(GDBWrite)) {
499         DPRINTFN("write: addr=%#x, size=%d", vaddr, size);
500         if (DTRACE(GDBExtra)) {
501             char buf[1024];
502             mem2hex(buf, data, size);
503             DPRINTFNR(": %s\n", buf);
504         } else
505             DPRINTFNR("\n");
506     }
507     if (FullSystem) {
508         FSTranslatingPortProxy &proxy = context->getVirtProxy();
509         proxy.writeBlob(vaddr, (uint8_t*)data, size);
510     } else {
511         SETranslatingPortProxy &proxy = context->getMemProxy();
512         proxy.writeBlob(vaddr, (uint8_t*)data, size);
513     }
514 
515     return true;
516 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classBaseRemoteGDB_a19c86e0d31779f284e91d4d016448264}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!debugger@{debugger}}
\index{debugger@{debugger}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{debugger}]{\setlength{\rightskip}{0pt plus 5cm}void debugger ()\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classBaseRemoteGDB_a19c86e0d31779f284e91d4d016448264}



\begin{DoxyCode}
150 {
151     static int current_debugger = -1;
152     if (current_debugger >= 0 && current_debugger < (int)debuggers.size()) {
153         BaseRemoteGDB *gdb = debuggers[current_debugger];
154         if (!gdb->isattached())
155             gdb->listener->accept();
156         if (gdb->isattached())
157             gdb->trap(SIGILL);
158     }
159 }
\end{DoxyCode}
\hypertarget{classBaseRemoteGDB_a3c7b3c89bf96f51e80a919b3a82a3915}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!Event@{Event}}
\index{Event@{Event}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{Event}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf Event}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classBaseRemoteGDB_a3c7b3c89bf96f51e80a919b3a82a3915}
\hypertarget{classBaseRemoteGDB_a9759bc7ba80437d060e93ffb17361c55}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!GDBListener@{GDBListener}}
\index{GDBListener@{GDBListener}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{GDBListener}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf GDBListener}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classBaseRemoteGDB_a9759bc7ba80437d060e93ffb17361c55}
\hypertarget{classBaseRemoteGDB_ad185c0396aa4b55d7f1fbb3749759247}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!HardBreakpoint@{HardBreakpoint}}
\index{HardBreakpoint@{HardBreakpoint}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{HardBreakpoint}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf HardBreakpoint}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classBaseRemoteGDB_ad185c0396aa4b55d7f1fbb3749759247}


\subsection{変数}
\hypertarget{classBaseRemoteGDB_a03c996f9fcf0e10baeb3e700be0c409a}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!active@{active}}
\index{active@{active}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{active}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf active}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a03c996f9fcf0e10baeb3e700be0c409a}
\hypertarget{classBaseRemoteGDB_a571d1b910d429b292be1f1c555733f62}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!attached@{attached}}
\index{attached@{attached}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{attached}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf attached}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a571d1b910d429b292be1f1c555733f62}
\hypertarget{classBaseRemoteGDB_a9684dd9218c7836517670f8a0d8f3df7}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!context@{context}}
\index{context@{context}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{context}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadContext}$\ast$ {\bf context}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a9684dd9218c7836517670f8a0d8f3df7}
\hypertarget{classBaseRemoteGDB_a765488c8f26c7f8713d5245212dcae01}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!event@{event}}
\index{event@{event}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{event}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Event}$\ast$ {\bf event}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a765488c8f26c7f8713d5245212dcae01}
\hypertarget{classBaseRemoteGDB_a6f8059414f0228f0256115e024eeed4b}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!fd@{fd}}
\index{fd@{fd}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{fd}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf fd}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a6f8059414f0228f0256115e024eeed4b}
\hypertarget{classBaseRemoteGDB_a4dbf55c54f47727c96b2cb5d00ca7936}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!gdbregs@{gdbregs}}
\index{gdbregs@{gdbregs}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{gdbregs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf GdbRegCache} {\bf gdbregs}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a4dbf55c54f47727c96b2cb5d00ca7936}
\hypertarget{classBaseRemoteGDB_a9786e8b1280562520a5041f18dd59b21}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!hardBreakMap@{hardBreakMap}}
\index{hardBreakMap@{hardBreakMap}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{hardBreakMap}]{\setlength{\rightskip}{0pt plus 5cm}{\bf break\_\-map\_\-t} {\bf hardBreakMap}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a9786e8b1280562520a5041f18dd59b21}
\hypertarget{classBaseRemoteGDB_a70415b68fb0739613a991b92c4d127a5}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!listener@{listener}}
\index{listener@{listener}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{listener}]{\setlength{\rightskip}{0pt plus 5cm}{\bf GDBListener}$\ast$ {\bf listener}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a70415b68fb0739613a991b92c4d127a5}
\hypertarget{classBaseRemoteGDB_a7106e2abc437ad981830d14176d15f09}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!number@{number}}
\index{number@{number}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{number}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf number}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_a7106e2abc437ad981830d14176d15f09}
\hypertarget{classBaseRemoteGDB_af27ccd765f13a4b7bd119dc7579e2746}{
\index{BaseRemoteGDB@{BaseRemoteGDB}!system@{system}}
\index{system@{system}!BaseRemoteGDB@{BaseRemoteGDB}}
\subsubsection[{system}]{\setlength{\rightskip}{0pt plus 5cm}{\bf System}$\ast$ {\bf system}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseRemoteGDB_af27ccd765f13a4b7bd119dc7579e2746}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/null/\hyperlink{arch_2null_2remote__gdb_8hh}{remote\_\-gdb.hh}\item 
base/\hyperlink{base_2remote__gdb_8hh}{remote\_\-gdb.hh}\item 
base/\hyperlink{base_2remote__gdb_8cc}{remote\_\-gdb.cc}\end{DoxyCompactItemize}
