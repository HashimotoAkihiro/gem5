\hypertarget{classArmISA_1_1PairMemOp}{
\section{クラス PairMemOp}
\label{classArmISA_1_1PairMemOp}\index{ArmISA::PairMemOp@{ArmISA::PairMemOp}}
}


{\ttfamily \#include $<$macromem.hh$>$}PairMemOpに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=6cm]{classArmISA_1_1PairMemOp}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classArmISA_1_1PairMemOp_abf132b4ad93f3557cd3956577592ba68}{AddrMode} \{ \hyperlink{classArmISA_1_1PairMemOp_abf132b4ad93f3557cd3956577592ba68a65551ba1b10e5734f879f0333cdcb7da}{AddrMd\_\-Offset}, 
\hyperlink{classArmISA_1_1PairMemOp_abf132b4ad93f3557cd3956577592ba68ae21d09df49cf2636f746abd6749e9a47}{AddrMd\_\-PreIndex}, 
\hyperlink{classArmISA_1_1PairMemOp_abf132b4ad93f3557cd3956577592ba68af7adc379284699304b17af32b41e8ea1}{AddrMd\_\-PostIndex}
 \}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classArmISA_1_1PairMemOp_a5bba341210b26c5e58c4672b264c3e1a}{PairMemOp} (const char $\ast$mnem, \hyperlink{classStaticInst_a5605d4fc727eae9e595325c90c0ec108}{ExtMachInst} \hyperlink{classStaticInst_a744598b194ca3d4201d9414ce4cc4af4}{machInst}, OpClass \_\-\_\-opClass, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} size, bool fp, bool load, bool noAlloc, bool signExt, bool exclusive, bool acrel, int64\_\-t \hyperlink{namespaceArmISA_a2308526fcc9af84548a72f9ba3102ec1}{imm}, \hyperlink{classArmISA_1_1PairMemOp_abf132b4ad93f3557cd3956577592ba68}{AddrMode} \hyperlink{namespaceArmISA_a5f3b9b97eb2dfa29d33e74878455f90d}{mode}, \hyperlink{namespaceArmISA_ae64680ba9fb526106829d6bf92fc791b}{IntRegIndex} \hyperlink{namespaceArmISA_adf8c6c579ad8729095a637a4f2181211}{rn}, \hyperlink{namespaceArmISA_ae64680ba9fb526106829d6bf92fc791b}{IntRegIndex} \hyperlink{namespaceArmISA_a445689c4b952c722ae5b0cec0311cd10}{rt}, \hyperlink{namespaceArmISA_ae64680ba9fb526106829d6bf92fc791b}{IntRegIndex} rt2)
\end{DoxyCompactItemize}


\subsection{説明}
Base class for pair load/store instructions. 

\subsection{列挙型}
\hypertarget{classArmISA_1_1PairMemOp_abf132b4ad93f3557cd3956577592ba68}{
\index{ArmISA::PairMemOp@{ArmISA::PairMemOp}!AddrMode@{AddrMode}}
\index{AddrMode@{AddrMode}!ArmISA::PairMemOp@{ArmISA::PairMemOp}}
\subsubsection[{AddrMode}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf AddrMode}}}
\label{classArmISA_1_1PairMemOp_abf132b4ad93f3557cd3956577592ba68}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{AddrMd\_\-Offset@{AddrMd\_\-Offset}!ArmISA::PairMemOp@{ArmISA::PairMemOp}}\index{ArmISA::PairMemOp@{ArmISA::PairMemOp}!AddrMd\_\-Offset@{AddrMd\_\-Offset}}\item[{\em 
\hypertarget{classArmISA_1_1PairMemOp_abf132b4ad93f3557cd3956577592ba68a65551ba1b10e5734f879f0333cdcb7da}{
AddrMd\_\-Offset}
\label{classArmISA_1_1PairMemOp_abf132b4ad93f3557cd3956577592ba68a65551ba1b10e5734f879f0333cdcb7da}
}]\index{AddrMd\_\-PreIndex@{AddrMd\_\-PreIndex}!ArmISA::PairMemOp@{ArmISA::PairMemOp}}\index{ArmISA::PairMemOp@{ArmISA::PairMemOp}!AddrMd\_\-PreIndex@{AddrMd\_\-PreIndex}}\item[{\em 
\hypertarget{classArmISA_1_1PairMemOp_abf132b4ad93f3557cd3956577592ba68ae21d09df49cf2636f746abd6749e9a47}{
AddrMd\_\-PreIndex}
\label{classArmISA_1_1PairMemOp_abf132b4ad93f3557cd3956577592ba68ae21d09df49cf2636f746abd6749e9a47}
}]\index{AddrMd\_\-PostIndex@{AddrMd\_\-PostIndex}!ArmISA::PairMemOp@{ArmISA::PairMemOp}}\index{ArmISA::PairMemOp@{ArmISA::PairMemOp}!AddrMd\_\-PostIndex@{AddrMd\_\-PostIndex}}\item[{\em 
\hypertarget{classArmISA_1_1PairMemOp_abf132b4ad93f3557cd3956577592ba68af7adc379284699304b17af32b41e8ea1}{
AddrMd\_\-PostIndex}
\label{classArmISA_1_1PairMemOp_abf132b4ad93f3557cd3956577592ba68af7adc379284699304b17af32b41e8ea1}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
415                   {
416         AddrMd_Offset,
417         AddrMd_PreIndex,
418         AddrMd_PostIndex
419     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classArmISA_1_1PairMemOp_a5bba341210b26c5e58c4672b264c3e1a}{
\index{ArmISA::PairMemOp@{ArmISA::PairMemOp}!PairMemOp@{PairMemOp}}
\index{PairMemOp@{PairMemOp}!ArmISA::PairMemOp@{ArmISA::PairMemOp}}
\subsubsection[{PairMemOp}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PairMemOp} (const char $\ast$ {\em mnem}, \/  {\bf ExtMachInst} {\em machInst}, \/  OpClass {\em \_\-\_\-opClass}, \/  {\bf uint32\_\-t} {\em size}, \/  bool {\em fp}, \/  bool {\em load}, \/  bool {\em noAlloc}, \/  bool {\em signExt}, \/  bool {\em exclusive}, \/  bool {\em acrel}, \/  int64\_\-t {\em imm}, \/  {\bf AddrMode} {\em mode}, \/  {\bf IntRegIndex} {\em rn}, \/  {\bf IntRegIndex} {\em rt}, \/  {\bf IntRegIndex} {\em rt2})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1PairMemOp_a5bba341210b26c5e58c4672b264c3e1a}



\begin{DoxyCode}
196                                                                       :
197     PredMacroOp(mnem, machInst, __opClass)
198 {
199     bool writeback = (mode != AddrMd_Offset);
200     numMicroops = 1 + (size / 4) + (writeback ? 1 : 0);
201     microOps = new StaticInstPtr[numMicroops];
202 
203     StaticInstPtr *uop = microOps;
204 
205     bool post = (mode == AddrMd_PostIndex);
206 
207     rn = makeSP(rn);
208 
209     *uop = new MicroAddXiSpAlignUop(machInst, INTREG_UREG0, rn, post ? 0 : imm);
210 
211     if (fp) {
212         if (size == 16) {
213             if (load) {
214                 *++uop = new MicroLdrQBFpXImmUop(machInst, rt,
215                         INTREG_UREG0, 0, noAlloc, exclusive, acrel);
216                 *++uop = new MicroLdrQTFpXImmUop(machInst, rt,
217                         INTREG_UREG0, 0, noAlloc, exclusive, acrel);
218                 *++uop = new MicroLdrQBFpXImmUop(machInst, rt2,
219                         INTREG_UREG0, 16, noAlloc, exclusive, acrel);
220                 *++uop = new MicroLdrQTFpXImmUop(machInst, rt2,
221                         INTREG_UREG0, 16, noAlloc, exclusive, acrel);
222             } else {
223                 *++uop = new MicroStrQBFpXImmUop(machInst, rt,
224                         INTREG_UREG0, 0, noAlloc, exclusive, acrel);
225                 *++uop = new MicroStrQTFpXImmUop(machInst, rt,
226                         INTREG_UREG0, 0, noAlloc, exclusive, acrel);
227                 *++uop = new MicroStrQBFpXImmUop(machInst, rt2,
228                         INTREG_UREG0, 16, noAlloc, exclusive, acrel);
229                 *++uop = new MicroStrQTFpXImmUop(machInst, rt2,
230                         INTREG_UREG0, 16, noAlloc, exclusive, acrel);
231             }
232         } else if (size == 8) {
233             if (load) {
234                 *++uop = new MicroLdrFpXImmUop(machInst, rt,
235                         INTREG_UREG0, 0, noAlloc, exclusive, acrel);
236                 *++uop = new MicroLdrFpXImmUop(machInst, rt2,
237                         INTREG_UREG0, 8, noAlloc, exclusive, acrel);
238             } else {
239                 *++uop = new MicroStrFpXImmUop(machInst, rt,
240                         INTREG_UREG0, 0, noAlloc, exclusive, acrel);
241                 *++uop = new MicroStrFpXImmUop(machInst, rt2,
242                         INTREG_UREG0, 8, noAlloc, exclusive, acrel);
243             }
244         } else if (size == 4) {
245             if (load) {
246                 *++uop = new MicroLdrDFpXImmUop(machInst, rt, rt2,
247                         INTREG_UREG0, 0, noAlloc, exclusive, acrel);
248             } else {
249                 *++uop = new MicroStrDFpXImmUop(machInst, rt, rt2,
250                         INTREG_UREG0, 0, noAlloc, exclusive, acrel);
251             }
252         }
253     } else {
254         if (size == 8) {
255             if (load) {
256                 *++uop = new MicroLdrXImmUop(machInst, rt, INTREG_UREG0,
257                         0, noAlloc, exclusive, acrel);
258                 *++uop = new MicroLdrXImmUop(machInst, rt2, INTREG_UREG0,
259                         size, noAlloc, exclusive, acrel);
260             } else {
261                 *++uop = new MicroStrXImmUop(machInst, rt, INTREG_UREG0,
262                         0, noAlloc, exclusive, acrel);
263                 *++uop = new MicroStrXImmUop(machInst, rt2, INTREG_UREG0,
264                         size, noAlloc, exclusive, acrel);
265             }
266         } else if (size == 4) {
267             if (load) {
268                 if (signExt) {
269                     *++uop = new MicroLdrDSXImmUop(machInst, rt, rt2,
270                             INTREG_UREG0, 0, noAlloc, exclusive, acrel);
271                 } else {
272                     *++uop = new MicroLdrDUXImmUop(machInst, rt, rt2,
273                             INTREG_UREG0, 0, noAlloc, exclusive, acrel);
274                 }
275             } else {
276                 *++uop = new MicroStrDXImmUop(machInst, rt, rt2,
277                         INTREG_UREG0, 0, noAlloc, exclusive, acrel);
278             }
279         }
280     }
281 
282     if (writeback) {
283         *++uop = new MicroAddXiUop(machInst, rn, INTREG_UREG0,
284                                    post ? imm : 0);
285     }
286 
287     (*uop)->setLastMicroop();
288 
289     for (StaticInstPtr *curUop = microOps;
290             !(*curUop)->isLastMicroop(); curUop++) {
291         (*curUop)->setDelayedCommit();
292     }
293 }

\end{DoxyCode}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/arm/insts/\hyperlink{macromem_8hh}{macromem.hh}\item 
arch/arm/insts/\hyperlink{macromem_8cc}{macromem.cc}\end{DoxyCompactItemize}
