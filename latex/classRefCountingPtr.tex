\hypertarget{classRefCountingPtr}{
\section{クラス テンプレート RefCountingPtr$<$ T $>$}
\label{classRefCountingPtr}\index{RefCountingPtr@{RefCountingPtr}}
}


{\ttfamily \#include $<$refcnt.hh$>$}\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classRefCountingPtr_a36626d973a3bfce9ea3deda94b2fafe0}{RefCountingPtr} ()
\begin{DoxyCompactList}\small\item\em Create an empty reference counting pointer. \item\end{DoxyCompactList}\item 
\hyperlink{classRefCountingPtr_ab36d4c5bc63188c9877bf4d552ea8071}{RefCountingPtr} (T $\ast$\hyperlink{classRefCountingPtr_ac88dceffbecaed1137b0e27783adbcc5}{data})
\item 
\hyperlink{classRefCountingPtr_a9049efc00f5d3c7a115a6d2e0fcec09c}{RefCountingPtr} (const \hyperlink{classRefCountingPtr}{RefCountingPtr} \&r)
\item 
\hyperlink{classRefCountingPtr_a4ebce3855f9a62d273930390acdbde50}{$\sim$RefCountingPtr} ()
\begin{DoxyCompactList}\small\item\em Destroy the pointer and any reference it may hold. \item\end{DoxyCompactList}\item 
T $\ast$ \hyperlink{classRefCountingPtr_ac0ddd007dfcfef3121f74d0665dfd0cd}{operator-\/$>$} () const 
\begin{DoxyCompactList}\small\item\em Access a member variable. \item\end{DoxyCompactList}\item 
T \& \hyperlink{classRefCountingPtr_abcc36ef133f26e7e3145b785df23eb18}{operator$\ast$} () const 
\begin{DoxyCompactList}\small\item\em Dereference the pointer. \item\end{DoxyCompactList}\item 
T $\ast$ \hyperlink{classRefCountingPtr_a07f851191ad3a7c5c1598ef14f710f96}{get} () const 
\begin{DoxyCompactList}\small\item\em Directly access the pointer itself without taking a reference. \item\end{DoxyCompactList}\item 
const \hyperlink{classRefCountingPtr}{RefCountingPtr} \& \hyperlink{classRefCountingPtr_abe913c8dc8f8a418383762d6688f08e4}{operator=} (T $\ast$p)
\begin{DoxyCompactList}\small\item\em Assign a new value to the pointer. \item\end{DoxyCompactList}\item 
const \hyperlink{classRefCountingPtr}{RefCountingPtr} \& \hyperlink{classRefCountingPtr_a5227acb51502321f8d32744c73b9f6e3}{operator=} (const \hyperlink{classRefCountingPtr}{RefCountingPtr} \&r)
\begin{DoxyCompactList}\small\item\em Copy the pointer from another \hyperlink{classRefCountingPtr}{RefCountingPtr}. \item\end{DoxyCompactList}\item 
bool \hyperlink{classRefCountingPtr_ac8b1d32dbd52d431450c70b151cfa205}{operator!} () const 
\begin{DoxyCompactList}\small\item\em \hyperlink{classCheck}{Check} if the pointer is empty. \item\end{DoxyCompactList}\item 
\hyperlink{classRefCountingPtr_aa385aa18f5e42db5a415c25a90f4193d}{operator bool} () const 
\begin{DoxyCompactList}\small\item\em \hyperlink{classCheck}{Check} if the pointer is non-\/empty. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classRefCountingPtr_a890d36110dbb21266898207adfb2a7d5}{copy} (T $\ast$d)
\item 
void \hyperlink{classRefCountingPtr_a13120ea5788aaacf44a89b193a0cceef}{del} ()
\item 
void \hyperlink{classRefCountingPtr_a4bc01a1a918510bef2013a1f089f19fd}{set} (T $\ast$d)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
T $\ast$ \hyperlink{classRefCountingPtr_ac88dceffbecaed1137b0e27783adbcc5}{data}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$class T$>$ class RefCountingPtr$<$ T $>$}

If you want a reference counting pointer to a mutable object, create it like this: 
\begin{DoxyCode}
 typedef RefCountingPtr<Foo> FooPtr;
\end{DoxyCode}


\begin{DoxyAttention}{注意}
Do not use \char`\"{}const FooPtr\char`\"{} To create a reference counting pointer to a const object, use this: 
\begin{DoxyCode}
 typedef RefCountingPtr<const Foo> ConstFooPtr;
\end{DoxyCode}

\end{DoxyAttention}
These two usages are analogous to iterator and const\_\-iterator in the stl. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classRefCountingPtr_a36626d973a3bfce9ea3deda94b2fafe0}{
\index{RefCountingPtr@{RefCountingPtr}!RefCountingPtr@{RefCountingPtr}}
\index{RefCountingPtr@{RefCountingPtr}!RefCountingPtr@{RefCountingPtr}}
\subsubsection[{RefCountingPtr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RefCountingPtr} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRefCountingPtr_a36626d973a3bfce9ea3deda94b2fafe0}


Create an empty reference counting pointer. 


\begin{DoxyCode}
163 : data(0) {}
\end{DoxyCode}
\hypertarget{classRefCountingPtr_ab36d4c5bc63188c9877bf4d552ea8071}{
\index{RefCountingPtr@{RefCountingPtr}!RefCountingPtr@{RefCountingPtr}}
\index{RefCountingPtr@{RefCountingPtr}!RefCountingPtr@{RefCountingPtr}}
\subsubsection[{RefCountingPtr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RefCountingPtr} (T $\ast$ {\em data})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRefCountingPtr_ab36d4c5bc63188c9877bf4d552ea8071}
Create a new reference counting pointer to some object (probably something newly created). Adds a reference. 


\begin{DoxyCode}
167 { copy(data); }
\end{DoxyCode}
\hypertarget{classRefCountingPtr_a9049efc00f5d3c7a115a6d2e0fcec09c}{
\index{RefCountingPtr@{RefCountingPtr}!RefCountingPtr@{RefCountingPtr}}
\index{RefCountingPtr@{RefCountingPtr}!RefCountingPtr@{RefCountingPtr}}
\subsubsection[{RefCountingPtr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RefCountingPtr} (const {\bf RefCountingPtr}$<$ T $>$ \& {\em r})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRefCountingPtr_a9049efc00f5d3c7a115a6d2e0fcec09c}
Create a new reference counting pointer by copying another one. Adds a reference. 


\begin{DoxyCode}
171 { copy(r.data); }
\end{DoxyCode}
\hypertarget{classRefCountingPtr_a4ebce3855f9a62d273930390acdbde50}{
\index{RefCountingPtr@{RefCountingPtr}!$\sim$RefCountingPtr@{$\sim$RefCountingPtr}}
\index{$\sim$RefCountingPtr@{$\sim$RefCountingPtr}!RefCountingPtr@{RefCountingPtr}}
\subsubsection[{$\sim$RefCountingPtr}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf RefCountingPtr} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRefCountingPtr_a4ebce3855f9a62d273930390acdbde50}


Destroy the pointer and any reference it may hold. 


\begin{DoxyCode}
174 { del(); }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classRefCountingPtr_a890d36110dbb21266898207adfb2a7d5}{
\index{RefCountingPtr@{RefCountingPtr}!copy@{copy}}
\index{copy@{copy}!RefCountingPtr@{RefCountingPtr}}
\subsubsection[{copy}]{\setlength{\rightskip}{0pt plus 5cm}void copy (T $\ast$ {\em d})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classRefCountingPtr_a890d36110dbb21266898207adfb2a7d5}
Copy a new pointer value and increment the reference count if it is a valid pointer. Note, this does not delete the reference any existing object. 
\begin{DoxyParams}{引数}
\item[{\em d}]Pointer to store. \end{DoxyParams}



\begin{DoxyCode}
121     {
122         data = d;
123         /*if(sizeof(T)=16)
124           {
125             *data.data[0] = *d.data[0];
126             *data.data[0] = *d.data[0];
127             *data.data[0] = *d.data[0];
128             *data.data[0] = *d.data[0];
129             }*/
130         if (data)
131             data->incref();
132     }
\end{DoxyCode}
\hypertarget{classRefCountingPtr_a13120ea5788aaacf44a89b193a0cceef}{
\index{RefCountingPtr@{RefCountingPtr}!del@{del}}
\index{del@{del}!RefCountingPtr@{RefCountingPtr}}
\subsubsection[{del}]{\setlength{\rightskip}{0pt plus 5cm}void del ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classRefCountingPtr_a13120ea5788aaacf44a89b193a0cceef}
Delete the reference to any existing object if it is non NULL. \begin{DoxyAttention}{注意}
this doesn't clear the pointer value, so a double decref could happen if not careful. 
\end{DoxyAttention}



\begin{DoxyCode}
141     {
142         if (data)
143             data->decref();
144     }
\end{DoxyCode}
\hypertarget{classRefCountingPtr_a07f851191ad3a7c5c1598ef14f710f96}{
\index{RefCountingPtr@{RefCountingPtr}!get@{get}}
\index{get@{get}!RefCountingPtr@{RefCountingPtr}}
\subsubsection[{get}]{\setlength{\rightskip}{0pt plus 5cm}T$\ast$ get () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRefCountingPtr_a07f851191ad3a7c5c1598ef14f710f96}


Directly access the pointer itself without taking a reference. 


\begin{DoxyCode}
187 { return data; }
\end{DoxyCode}
\hypertarget{classRefCountingPtr_aa385aa18f5e42db5a415c25a90f4193d}{
\index{RefCountingPtr@{RefCountingPtr}!operator bool@{operator bool}}
\index{operator bool@{operator bool}!RefCountingPtr@{RefCountingPtr}}
\subsubsection[{operator bool}]{\setlength{\rightskip}{0pt plus 5cm}operator bool () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRefCountingPtr_aa385aa18f5e42db5a415c25a90f4193d}


\hyperlink{classCheck}{Check} if the pointer is non-\/empty. 


\begin{DoxyCode}
200 { return data != 0; }
\end{DoxyCode}
\hypertarget{classRefCountingPtr_ac8b1d32dbd52d431450c70b151cfa205}{
\index{RefCountingPtr@{RefCountingPtr}!operator!@{operator!}}
\index{operator!@{operator!}!RefCountingPtr@{RefCountingPtr}}
\subsubsection[{operator!}]{\setlength{\rightskip}{0pt plus 5cm}bool operator! () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRefCountingPtr_ac8b1d32dbd52d431450c70b151cfa205}


\hyperlink{classCheck}{Check} if the pointer is empty. 


\begin{DoxyCode}
197 { return data == 0; }
\end{DoxyCode}
\hypertarget{classRefCountingPtr_abcc36ef133f26e7e3145b785df23eb18}{
\index{RefCountingPtr@{RefCountingPtr}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!RefCountingPtr@{RefCountingPtr}}
\subsubsection[{operator$\ast$}]{\setlength{\rightskip}{0pt plus 5cm}T\& operator$\ast$ () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRefCountingPtr_abcc36ef133f26e7e3145b785df23eb18}


Dereference the pointer. 


\begin{DoxyCode}
184 { return *data; }
\end{DoxyCode}
\hypertarget{classRefCountingPtr_ac0ddd007dfcfef3121f74d0665dfd0cd}{
\index{RefCountingPtr@{RefCountingPtr}!operator-\/$>$@{operator-\/$>$}}
\index{operator-\/$>$@{operator-\/$>$}!RefCountingPtr@{RefCountingPtr}}
\subsubsection[{operator-\/$>$}]{\setlength{\rightskip}{0pt plus 5cm}T$\ast$ operator-\/$>$ () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRefCountingPtr_ac0ddd007dfcfef3121f74d0665dfd0cd}


Access a member variable. 


\begin{DoxyCode}
181 { return data; }
\end{DoxyCode}
\hypertarget{classRefCountingPtr_a5227acb51502321f8d32744c73b9f6e3}{
\index{RefCountingPtr@{RefCountingPtr}!operator=@{operator=}}
\index{operator=@{operator=}!RefCountingPtr@{RefCountingPtr}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf RefCountingPtr}\& operator= (const {\bf RefCountingPtr}$<$ T $>$ \& {\em r})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRefCountingPtr_a5227acb51502321f8d32744c73b9f6e3}


Copy the pointer from another \hyperlink{classRefCountingPtr}{RefCountingPtr}. 


\begin{DoxyCode}
194     { return operator=(r.data); }
\end{DoxyCode}
\hypertarget{classRefCountingPtr_abe913c8dc8f8a418383762d6688f08e4}{
\index{RefCountingPtr@{RefCountingPtr}!operator=@{operator=}}
\index{operator=@{operator=}!RefCountingPtr@{RefCountingPtr}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf RefCountingPtr}\& operator= (T $\ast$ {\em p})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRefCountingPtr_abe913c8dc8f8a418383762d6688f08e4}


Assign a new value to the pointer. 


\begin{DoxyCode}
190 { set(p); return *this; }
\end{DoxyCode}
\hypertarget{classRefCountingPtr_a4bc01a1a918510bef2013a1f089f19fd}{
\index{RefCountingPtr@{RefCountingPtr}!set@{set}}
\index{set@{set}!RefCountingPtr@{RefCountingPtr}}
\subsubsection[{set}]{\setlength{\rightskip}{0pt plus 5cm}void set (T $\ast$ {\em d})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classRefCountingPtr_a4bc01a1a918510bef2013a1f089f19fd}
Drop the old reference and change it to something new. 


\begin{DoxyCode}
151     {
152         // Need to check if we're actually changing because otherwise
153         // we could delete the last reference before adding the new
154         // reference.
155         if (data != d) {
156             del();
157             copy(d);
158         }
159     }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classRefCountingPtr_ac88dceffbecaed1137b0e27783adbcc5}{
\index{RefCountingPtr@{RefCountingPtr}!data@{data}}
\index{data@{data}!RefCountingPtr@{RefCountingPtr}}
\subsubsection[{data}]{\setlength{\rightskip}{0pt plus 5cm}T$\ast$ {\bf data}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classRefCountingPtr_ac88dceffbecaed1137b0e27783adbcc5}
The stored pointer. Arguably this should be private. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
base/\hyperlink{refcnt_8hh}{refcnt.hh}\end{DoxyCompactItemize}
