\hypertarget{classRubyTester}{
\section{クラス RubyTester}
\label{classRubyTester}\index{RubyTester@{RubyTester}}
}


{\ttfamily \#include $<$RubyTester.hh$>$}RubyTesterに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=5cm]{classRubyTester}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classRubyTester_1_1CheckStartEvent}{CheckStartEvent}
\item 
class \hyperlink{classRubyTester_1_1CpuPort}{CpuPort}
\item 
class \hyperlink{classRubyTester_1_1RubyTester}{RubyTester}
\item 
struct \hyperlink{structRubyTester_1_1SenderState}{SenderState}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef RubyTesterParams \hyperlink{classRubyTester_a6785f65e1745860fc5b53cbf4aefc2f7}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classRubyTester_ae8f6793530023408995b1e046935c263}{RubyTester} (const \hyperlink{classRubyTester_a6785f65e1745860fc5b53cbf4aefc2f7}{Params} $\ast$p)
\item 
\hyperlink{classRubyTester_ac53d3f47921859fb0e3792c18c8643d7}{$\sim$RubyTester} ()
\item 
virtual \hyperlink{classBaseMasterPort}{BaseMasterPort} \& \hyperlink{classRubyTester_adc4e675e51defbdd1e354dac729d0703}{getMasterPort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
bool \hyperlink{classRubyTester_a42293ff3a28b9881992792d7fdee907b}{isInstReadableCpuPort} (int idx)
\item 
\hyperlink{classMasterPort}{MasterPort} $\ast$ \hyperlink{classRubyTester_aa82782a52c45fe9caea72eb6beee63c3}{getReadableCpuPort} (int idx)
\item 
\hyperlink{classMasterPort}{MasterPort} $\ast$ \hyperlink{classRubyTester_a77680df4a8d2917c7f961e56eff08e96}{getWritableCpuPort} (int idx)
\item 
virtual void \hyperlink{classRubyTester_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
void \hyperlink{classRubyTester_ae674290a26ecbd622c5160e38e8a4fe9}{wakeup} ()
\item 
void \hyperlink{classRubyTester_a7bf3ac9b8e83cf7ec4fd1462ead30b3b}{incrementCheckCompletions} ()
\item 
void \hyperlink{classRubyTester_a38f932a0a623730fe10783f46d243cef}{printStats} (std::ostream \&out) const 
\item 
void \hyperlink{classRubyTester_ac7ec7476159db4e2bb0372e30010fc9e}{clearStats} ()
\item 
void \hyperlink{classRubyTester_a773d0e977425600264039f8941f18496}{printConfig} (std::ostream \&out) const 
\item 
void \hyperlink{classRubyTester_ac55fe386a101fbae38c716067c9966a0}{print} (std::ostream \&out) const 
\item 
bool \hyperlink{classRubyTester_ae69c65056b8f5eb9fee22f365c58662c}{getCheckFlush} ()
\item 
\hyperlink{request_8hh_ac366b729262fd8e7cbd3283da6f775cf}{MasterID} \hyperlink{classRubyTester_a9b7d32db0521388c0953e531c79aab50}{masterId} ()
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classRubyTester_1_1CheckStartEvent}{CheckStartEvent} \hyperlink{classRubyTester_a9975e990a9801088084cd2d769a8039e}{checkStartEvent}
\item 
\hyperlink{request_8hh_ac366b729262fd8e7cbd3283da6f775cf}{MasterID} \hyperlink{classRubyTester_a23e4e74239f2919fd2f05d672fbf7cb7}{\_\-masterId}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classRubyTester_a8b71a10b528265ae6a63c53c28360d60}{hitCallback} (\hyperlink{TypeDefines_8hh_a83c14b4ae37e80071f6b3506a6c46151}{NodeID} proc, \hyperlink{classSubBlock}{SubBlock} $\ast$data)
\item 
void \hyperlink{classRubyTester_a514b854b1aebca4ab64690855d9588b9}{checkForDeadlock} ()
\item 
\hyperlink{classRubyTester_a48ff36f9d0f5c4edd6ef8231861867d6}{RubyTester} (const \hyperlink{classRubyTester_1_1RubyTester}{RubyTester} \&obj)
\item 
\hyperlink{classRubyTester_1_1RubyTester}{RubyTester} \& \hyperlink{classRubyTester_a71d9335b80022b21a3a95907e238efe6}{operator=} (const \hyperlink{classRubyTester_1_1RubyTester}{RubyTester} \&obj)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classCheckTable}{CheckTable} $\ast$ \hyperlink{classRubyTester_aea4972439fb74004b80eb744d5adaf03}{m\_\-checkTable\_\-ptr}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classTime}{Time} $>$ \hyperlink{classRubyTester_a64bbb232772e2688790c89678aafa89e}{m\_\-last\_\-progress\_\-vector}
\item 
int \hyperlink{classRubyTester_a696a7ada843596770ab04a749b5ffd67}{m\_\-num\_\-cpus}
\item 
\hyperlink{TypeDefines_8hh_a29940ae63ec06c9998bba873e25407ad}{uint64} \hyperlink{classRubyTester_a2cdd157694ca34abf0f26e715ed66907}{m\_\-checks\_\-completed}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMasterPort}{MasterPort} $\ast$ $>$ \hyperlink{classRubyTester_ac70f96ce30f653210523935c455b76f4}{writePorts}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMasterPort}{MasterPort} $\ast$ $>$ \hyperlink{classRubyTester_a932d2fee1f64944ee00898b8d4a17112}{readPorts}
\item 
\hyperlink{TypeDefines_8hh_a29940ae63ec06c9998bba873e25407ad}{uint64} \hyperlink{classRubyTester_a54fb656689e153912405d489825d2a90}{m\_\-checks\_\-to\_\-complete}
\item 
int \hyperlink{classRubyTester_ad5abdeaaf93c52d671abd33a762b4876}{m\_\-deadlock\_\-threshold}
\item 
int \hyperlink{classRubyTester_aedeaccd67403213e1e43d99ff1c70f44}{m\_\-num\_\-writers}
\item 
int \hyperlink{classRubyTester_a7d224a04c5f0d1049dd6c6ab070884cb}{m\_\-num\_\-readers}
\item 
int \hyperlink{classRubyTester_a40394bd6ef55e1c6f0d6d614b2039886}{m\_\-wakeup\_\-frequency}
\item 
bool \hyperlink{classRubyTester_a6c0bbb19bd909943c050b498ec1350ba}{m\_\-check\_\-flush}
\item 
int \hyperlink{classRubyTester_acf32e95ded135b636d78d731d850fc0f}{m\_\-num\_\-inst\_\-ports}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classRubyTester_a6785f65e1745860fc5b53cbf4aefc2f7}{
\index{RubyTester@{RubyTester}!Params@{Params}}
\index{Params@{Params}!RubyTester@{RubyTester}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef RubyTesterParams {\bf Params}}}
\label{classRubyTester_a6785f65e1745860fc5b53cbf4aefc2f7}


\hyperlink{classMemObject_a905bbc621eeec0ed08859e21c8c95412}{MemObject}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classRubyTester_ae8f6793530023408995b1e046935c263}{
\index{RubyTester@{RubyTester}!RubyTester@{RubyTester}}
\index{RubyTester@{RubyTester}!RubyTester@{RubyTester}}
\subsubsection[{RubyTester}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RubyTester} (const {\bf Params} $\ast$ {\em p})}}
\label{classRubyTester_ae8f6793530023408995b1e046935c263}



\begin{DoxyCode}
53   : MemObject(p), checkStartEvent(this),
54     _masterId(p->system->getMasterId(name())),
55     m_num_cpus(p->num_cpus),
56     m_checks_to_complete(p->checks_to_complete),
57     m_deadlock_threshold(p->deadlock_threshold),
58     m_wakeup_frequency(p->wakeup_frequency),
59     m_check_flush(p->check_flush),
60     m_num_inst_ports(p->port_cpuInstPort_connection_count)
61 {
62     m_checks_completed = 0;
63 
64     //
65     // Create the requested inst and data ports and place them on the
66     // appropriate read and write port lists.  The reason for the subtle
67     // difference between inst and data ports vs. read and write ports is
68     // from the tester's perspective, it only needs to know whether a port
69     // supports reads (checks) or writes (actions).  Meanwhile, the protocol
70     // controllers have data ports (support read and writes) or inst ports
71     // (support only reads).
72     // Note: the inst ports are the lowest elements of the readPort vector,
73     // then the data ports are added to the readPort vector
74     //
75     for (int i = 0; i < p->port_cpuInstPort_connection_count; ++i) {
76         readPorts.push_back(new CpuPort(csprintf("%s-instPort%d", name(), i),
77                                         this, i));
78     }
79     for (int i = 0; i < p->port_cpuDataPort_connection_count; ++i) {
80         CpuPort *port = new CpuPort(csprintf("%s-dataPort%d", name(), i),
81                                     this, i);
82         readPorts.push_back(port);
83         writePorts.push_back(port);
84     }
85 
86     // add the check start event to the event queue
87     schedule(checkStartEvent, 1);
88 }
\end{DoxyCode}
\hypertarget{classRubyTester_ac53d3f47921859fb0e3792c18c8643d7}{
\index{RubyTester@{RubyTester}!$\sim$RubyTester@{$\sim$RubyTester}}
\index{$\sim$RubyTester@{$\sim$RubyTester}!RubyTester@{RubyTester}}
\subsubsection[{$\sim$RubyTester}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf RubyTester} ()}}
\label{classRubyTester_ac53d3f47921859fb0e3792c18c8643d7}



\begin{DoxyCode}
91 {
92     delete m_checkTable_ptr;
93     // Only delete the readPorts since the writePorts are just a subset
94     for (int i = 0; i < readPorts.size(); i++)
95         delete readPorts[i];
96 }
\end{DoxyCode}
\hypertarget{classRubyTester_a48ff36f9d0f5c4edd6ef8231861867d6}{
\index{RubyTester@{RubyTester}!RubyTester@{RubyTester}}
\index{RubyTester@{RubyTester}!RubyTester@{RubyTester}}
\subsubsection[{RubyTester}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RubyTester} (const {\bf RubyTester} \& {\em obj})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyTester_a48ff36f9d0f5c4edd6ef8231861867d6}


\subsection{関数}
\hypertarget{classRubyTester_a514b854b1aebca4ab64690855d9588b9}{
\index{RubyTester@{RubyTester}!checkForDeadlock@{checkForDeadlock}}
\index{checkForDeadlock@{checkForDeadlock}!RubyTester@{RubyTester}}
\subsubsection[{checkForDeadlock}]{\setlength{\rightskip}{0pt plus 5cm}void checkForDeadlock ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyTester_a514b854b1aebca4ab64690855d9588b9}



\begin{DoxyCode}
226 {
227     int size = m_last_progress_vector.size();
228     Time current_time = curCycle();
229     for (int processor = 0; processor < size; processor++) {
230         if ((current_time - m_last_progress_vector[processor]) >
231                 m_deadlock_threshold) {
232             panic("Deadlock detected: current_time: %d last_progress_time: %d "
233                   "difference:  %d processor: %d\n",
234                   current_time, m_last_progress_vector[processor],
235                   current_time - m_last_progress_vector[processor], processor);
236         }
237     }
238 }
\end{DoxyCode}
\hypertarget{classRubyTester_ac7ec7476159db4e2bb0372e30010fc9e}{
\index{RubyTester@{RubyTester}!clearStats@{clearStats}}
\index{clearStats@{clearStats}!RubyTester@{RubyTester}}
\subsubsection[{clearStats}]{\setlength{\rightskip}{0pt plus 5cm}void clearStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRubyTester_ac7ec7476159db4e2bb0372e30010fc9e}



\begin{DoxyCode}
109 {}
\end{DoxyCode}
\hypertarget{classRubyTester_ae69c65056b8f5eb9fee22f365c58662c}{
\index{RubyTester@{RubyTester}!getCheckFlush@{getCheckFlush}}
\index{getCheckFlush@{getCheckFlush}!RubyTester@{RubyTester}}
\subsubsection[{getCheckFlush}]{\setlength{\rightskip}{0pt plus 5cm}bool getCheckFlush ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRubyTester_ae69c65056b8f5eb9fee22f365c58662c}



\begin{DoxyCode}
113 { return m_check_flush; }
\end{DoxyCode}
\hypertarget{classRubyTester_adc4e675e51defbdd1e354dac729d0703}{
\index{RubyTester@{RubyTester}!getMasterPort@{getMasterPort}}
\index{getMasterPort@{getMasterPort}!RubyTester@{RubyTester}}
\subsubsection[{getMasterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseMasterPort} \& getMasterPort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyTester_adc4e675e51defbdd1e354dac729d0703}
Get a master port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classMemObject_adc4e675e51defbdd1e354dac729d0703}{MemObject}を再定義しています。


\begin{DoxyCode}
116 {
117     if (if_name != "cpuInstPort" && if_name != "cpuDataPort") {
118         // pass it along to our super class
119         return MemObject::getMasterPort(if_name, idx);
120     } else {
121         if (if_name == "cpuInstPort") {
122             if (idx > m_num_inst_ports) {
123                 panic("RubyTester::getMasterPort: unknown inst port idx %d\n",
124                       idx);
125             }
126             //
127             // inst ports directly map to the lowest readPort elements
128             //
129             return *readPorts[idx];
130         } else {
131             assert(if_name == "cpuDataPort");
132             //
133             // add the inst port offset to translate to the correct read port
134             // index
135             //
136             int read_idx = idx + m_num_inst_ports;
137             if (read_idx >= static_cast<PortID>(readPorts.size())) {
138                 panic("RubyTester::getMasterPort: unknown data port idx %d\n",
139                       idx);
140             }
141             return *readPorts[read_idx];
142         }
143     }
144 }
\end{DoxyCode}
\hypertarget{classRubyTester_aa82782a52c45fe9caea72eb6beee63c3}{
\index{RubyTester@{RubyTester}!getReadableCpuPort@{getReadableCpuPort}}
\index{getReadableCpuPort@{getReadableCpuPort}!RubyTester@{RubyTester}}
\subsubsection[{getReadableCpuPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterPort} $\ast$ getReadableCpuPort (int {\em idx})}}
\label{classRubyTester_aa82782a52c45fe9caea72eb6beee63c3}



\begin{DoxyCode}
172 {
173     assert(idx >= 0 && idx < readPorts.size());
174 
175     return readPorts[idx];
176 }
\end{DoxyCode}
\hypertarget{classRubyTester_a77680df4a8d2917c7f961e56eff08e96}{
\index{RubyTester@{RubyTester}!getWritableCpuPort@{getWritableCpuPort}}
\index{getWritableCpuPort@{getWritableCpuPort}!RubyTester@{RubyTester}}
\subsubsection[{getWritableCpuPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterPort} $\ast$ getWritableCpuPort (int {\em idx})}}
\label{classRubyTester_a77680df4a8d2917c7f961e56eff08e96}



\begin{DoxyCode}
180 {
181     assert(idx >= 0 && idx < writePorts.size());
182 
183     return writePorts[idx];
184 }
\end{DoxyCode}
\hypertarget{classRubyTester_a8b71a10b528265ae6a63c53c28360d60}{
\index{RubyTester@{RubyTester}!hitCallback@{hitCallback}}
\index{hitCallback@{hitCallback}!RubyTester@{RubyTester}}
\subsubsection[{hitCallback}]{\setlength{\rightskip}{0pt plus 5cm}void hitCallback ({\bf NodeID} {\em proc}, \/  {\bf SubBlock} $\ast$ {\em data})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyTester_a8b71a10b528265ae6a63c53c28360d60}



\begin{DoxyCode}
188 {
189     // Mark that we made progress
190     m_last_progress_vector[proc] = curCycle();
191 
192     DPRINTF(RubyTest, "completed request for proc: %d\n", proc);
193     DPRINTF(RubyTest, "addr: 0x%x, size: %d, data: ",
194             data->getAddress(), data->getSize());
195     for (int byte = 0; byte < data->getSize(); byte++) {
196         DPRINTF(RubyTest, "%d", data->getByte(byte));
197     }
198     DPRINTF(RubyTest, "\n");
199 
200     // This tells us our store has 'completed' or for a load gives us
201     // back the data to make the check
202     Check* check_ptr = m_checkTable_ptr->getCheck(data->getAddress());
203     assert(check_ptr != NULL);
204     check_ptr->performCallback(proc, data, curCycle());
205 }
\end{DoxyCode}
\hypertarget{classRubyTester_a7bf3ac9b8e83cf7ec4fd1462ead30b3b}{
\index{RubyTester@{RubyTester}!incrementCheckCompletions@{incrementCheckCompletions}}
\index{incrementCheckCompletions@{incrementCheckCompletions}!RubyTester@{RubyTester}}
\subsubsection[{incrementCheckCompletions}]{\setlength{\rightskip}{0pt plus 5cm}void incrementCheckCompletions ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRubyTester_a7bf3ac9b8e83cf7ec4fd1462ead30b3b}



\begin{DoxyCode}
106 { m_checks_completed++; }
\end{DoxyCode}
\hypertarget{classRubyTester_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{RubyTester@{RubyTester}!init@{init}}
\index{init@{init}!RubyTester@{RubyTester}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyTester_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classRubyTester_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{SimObject}を再定義しています。


\begin{DoxyCode}
100 {
101     assert(writePorts.size() > 0 && readPorts.size() > 0);
102 
103     m_last_progress_vector.resize(m_num_cpus);
104     for (int i = 0; i < m_last_progress_vector.size(); i++) {
105         m_last_progress_vector[i] = 0;
106     }
107 
108     m_num_writers = writePorts.size();
109     m_num_readers = readPorts.size();
110 
111     m_checkTable_ptr = new CheckTable(m_num_writers, m_num_readers, this);
112 }
\end{DoxyCode}
\hypertarget{classRubyTester_a42293ff3a28b9881992792d7fdee907b}{
\index{RubyTester@{RubyTester}!isInstReadableCpuPort@{isInstReadableCpuPort}}
\index{isInstReadableCpuPort@{isInstReadableCpuPort}!RubyTester@{RubyTester}}
\subsubsection[{isInstReadableCpuPort}]{\setlength{\rightskip}{0pt plus 5cm}bool isInstReadableCpuPort (int {\em idx})}}
\label{classRubyTester_a42293ff3a28b9881992792d7fdee907b}



\begin{DoxyCode}
166 {
167     return idx < m_num_inst_ports;
168 }
\end{DoxyCode}
\hypertarget{classRubyTester_a9b7d32db0521388c0953e531c79aab50}{
\index{RubyTester@{RubyTester}!masterId@{masterId}}
\index{masterId@{masterId}!RubyTester@{RubyTester}}
\subsubsection[{masterId}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterID} masterId ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRubyTester_a9b7d32db0521388c0953e531c79aab50}



\begin{DoxyCode}
115 { return _masterId; }
\end{DoxyCode}
\hypertarget{classRubyTester_a71d9335b80022b21a3a95907e238efe6}{
\index{RubyTester@{RubyTester}!operator=@{operator=}}
\index{operator=@{operator=}!RubyTester@{RubyTester}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RubyTester}\& operator= (const {\bf RubyTester} \& {\em obj})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyTester_a71d9335b80022b21a3a95907e238efe6}
\hypertarget{classRubyTester_ac55fe386a101fbae38c716067c9966a0}{
\index{RubyTester@{RubyTester}!print@{print}}
\index{print@{print}!RubyTester@{RubyTester}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}void print (std::ostream \& {\em out}) const}}
\label{classRubyTester_ac55fe386a101fbae38c716067c9966a0}



\begin{DoxyCode}
242 {
243     out << "[RubyTester]" << std::endl;
244 }
\end{DoxyCode}
\hypertarget{classRubyTester_a773d0e977425600264039f8941f18496}{
\index{RubyTester@{RubyTester}!printConfig@{printConfig}}
\index{printConfig@{printConfig}!RubyTester@{RubyTester}}
\subsubsection[{printConfig}]{\setlength{\rightskip}{0pt plus 5cm}void printConfig (std::ostream \& {\em out}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRubyTester_a773d0e977425600264039f8941f18496}



\begin{DoxyCode}
110 {}
\end{DoxyCode}
\hypertarget{classRubyTester_a38f932a0a623730fe10783f46d243cef}{
\index{RubyTester@{RubyTester}!printStats@{printStats}}
\index{printStats@{printStats}!RubyTester@{RubyTester}}
\subsubsection[{printStats}]{\setlength{\rightskip}{0pt plus 5cm}void printStats (std::ostream \& {\em out}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRubyTester_a38f932a0a623730fe10783f46d243cef}



\begin{DoxyCode}
108 {}
\end{DoxyCode}
\hypertarget{classRubyTester_ae674290a26ecbd622c5160e38e8a4fe9}{
\index{RubyTester@{RubyTester}!wakeup@{wakeup}}
\index{wakeup@{wakeup}!RubyTester@{RubyTester}}
\subsubsection[{wakeup}]{\setlength{\rightskip}{0pt plus 5cm}void wakeup ()}}
\label{classRubyTester_ae674290a26ecbd622c5160e38e8a4fe9}



\begin{DoxyCode}
209 {
210     if (m_checks_completed < m_checks_to_complete) {
211         // Try to perform an action or check
212         Check* check_ptr = m_checkTable_ptr->getRandomCheck();
213         assert(check_ptr != NULL);
214         check_ptr->initiate();
215 
216         checkForDeadlock();
217 
218         schedule(checkStartEvent, curTick() + m_wakeup_frequency);
219     } else {
220         exitSimLoop("Ruby Tester completed");
221     }
222 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classRubyTester_a23e4e74239f2919fd2f05d672fbf7cb7}{
\index{RubyTester@{RubyTester}!\_\-masterId@{\_\-masterId}}
\index{\_\-masterId@{\_\-masterId}!RubyTester@{RubyTester}}
\subsubsection[{\_\-masterId}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterID} {\bf \_\-masterId}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classRubyTester_a23e4e74239f2919fd2f05d672fbf7cb7}
\hypertarget{classRubyTester_a9975e990a9801088084cd2d769a8039e}{
\index{RubyTester@{RubyTester}!checkStartEvent@{checkStartEvent}}
\index{checkStartEvent@{checkStartEvent}!RubyTester@{RubyTester}}
\subsubsection[{checkStartEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CheckStartEvent} {\bf checkStartEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classRubyTester_a9975e990a9801088084cd2d769a8039e}
\hypertarget{classRubyTester_a6c0bbb19bd909943c050b498ec1350ba}{
\index{RubyTester@{RubyTester}!m\_\-check\_\-flush@{m\_\-check\_\-flush}}
\index{m\_\-check\_\-flush@{m\_\-check\_\-flush}!RubyTester@{RubyTester}}
\subsubsection[{m\_\-check\_\-flush}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf m\_\-check\_\-flush}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyTester_a6c0bbb19bd909943c050b498ec1350ba}
\hypertarget{classRubyTester_a2cdd157694ca34abf0f26e715ed66907}{
\index{RubyTester@{RubyTester}!m\_\-checks\_\-completed@{m\_\-checks\_\-completed}}
\index{m\_\-checks\_\-completed@{m\_\-checks\_\-completed}!RubyTester@{RubyTester}}
\subsubsection[{m\_\-checks\_\-completed}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint64} {\bf m\_\-checks\_\-completed}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyTester_a2cdd157694ca34abf0f26e715ed66907}
\hypertarget{classRubyTester_a54fb656689e153912405d489825d2a90}{
\index{RubyTester@{RubyTester}!m\_\-checks\_\-to\_\-complete@{m\_\-checks\_\-to\_\-complete}}
\index{m\_\-checks\_\-to\_\-complete@{m\_\-checks\_\-to\_\-complete}!RubyTester@{RubyTester}}
\subsubsection[{m\_\-checks\_\-to\_\-complete}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint64} {\bf m\_\-checks\_\-to\_\-complete}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyTester_a54fb656689e153912405d489825d2a90}
\hypertarget{classRubyTester_aea4972439fb74004b80eb744d5adaf03}{
\index{RubyTester@{RubyTester}!m\_\-checkTable\_\-ptr@{m\_\-checkTable\_\-ptr}}
\index{m\_\-checkTable\_\-ptr@{m\_\-checkTable\_\-ptr}!RubyTester@{RubyTester}}
\subsubsection[{m\_\-checkTable\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CheckTable}$\ast$ {\bf m\_\-checkTable\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyTester_aea4972439fb74004b80eb744d5adaf03}
\hypertarget{classRubyTester_ad5abdeaaf93c52d671abd33a762b4876}{
\index{RubyTester@{RubyTester}!m\_\-deadlock\_\-threshold@{m\_\-deadlock\_\-threshold}}
\index{m\_\-deadlock\_\-threshold@{m\_\-deadlock\_\-threshold}!RubyTester@{RubyTester}}
\subsubsection[{m\_\-deadlock\_\-threshold}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-deadlock\_\-threshold}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyTester_ad5abdeaaf93c52d671abd33a762b4876}
\hypertarget{classRubyTester_a64bbb232772e2688790c89678aafa89e}{
\index{RubyTester@{RubyTester}!m\_\-last\_\-progress\_\-vector@{m\_\-last\_\-progress\_\-vector}}
\index{m\_\-last\_\-progress\_\-vector@{m\_\-last\_\-progress\_\-vector}!RubyTester@{RubyTester}}
\subsubsection[{m\_\-last\_\-progress\_\-vector}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf Time}$>$ {\bf m\_\-last\_\-progress\_\-vector}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyTester_a64bbb232772e2688790c89678aafa89e}
\hypertarget{classRubyTester_a696a7ada843596770ab04a749b5ffd67}{
\index{RubyTester@{RubyTester}!m\_\-num\_\-cpus@{m\_\-num\_\-cpus}}
\index{m\_\-num\_\-cpus@{m\_\-num\_\-cpus}!RubyTester@{RubyTester}}
\subsubsection[{m\_\-num\_\-cpus}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-num\_\-cpus}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyTester_a696a7ada843596770ab04a749b5ffd67}
\hypertarget{classRubyTester_acf32e95ded135b636d78d731d850fc0f}{
\index{RubyTester@{RubyTester}!m\_\-num\_\-inst\_\-ports@{m\_\-num\_\-inst\_\-ports}}
\index{m\_\-num\_\-inst\_\-ports@{m\_\-num\_\-inst\_\-ports}!RubyTester@{RubyTester}}
\subsubsection[{m\_\-num\_\-inst\_\-ports}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-num\_\-inst\_\-ports}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyTester_acf32e95ded135b636d78d731d850fc0f}
\hypertarget{classRubyTester_a7d224a04c5f0d1049dd6c6ab070884cb}{
\index{RubyTester@{RubyTester}!m\_\-num\_\-readers@{m\_\-num\_\-readers}}
\index{m\_\-num\_\-readers@{m\_\-num\_\-readers}!RubyTester@{RubyTester}}
\subsubsection[{m\_\-num\_\-readers}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-num\_\-readers}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyTester_a7d224a04c5f0d1049dd6c6ab070884cb}
\hypertarget{classRubyTester_aedeaccd67403213e1e43d99ff1c70f44}{
\index{RubyTester@{RubyTester}!m\_\-num\_\-writers@{m\_\-num\_\-writers}}
\index{m\_\-num\_\-writers@{m\_\-num\_\-writers}!RubyTester@{RubyTester}}
\subsubsection[{m\_\-num\_\-writers}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-num\_\-writers}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyTester_aedeaccd67403213e1e43d99ff1c70f44}
\hypertarget{classRubyTester_a40394bd6ef55e1c6f0d6d614b2039886}{
\index{RubyTester@{RubyTester}!m\_\-wakeup\_\-frequency@{m\_\-wakeup\_\-frequency}}
\index{m\_\-wakeup\_\-frequency@{m\_\-wakeup\_\-frequency}!RubyTester@{RubyTester}}
\subsubsection[{m\_\-wakeup\_\-frequency}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-wakeup\_\-frequency}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyTester_a40394bd6ef55e1c6f0d6d614b2039886}
\hypertarget{classRubyTester_a932d2fee1f64944ee00898b8d4a17112}{
\index{RubyTester@{RubyTester}!readPorts@{readPorts}}
\index{readPorts@{readPorts}!RubyTester@{RubyTester}}
\subsubsection[{readPorts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf MasterPort}$\ast$$>$ {\bf readPorts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyTester_a932d2fee1f64944ee00898b8d4a17112}
\hypertarget{classRubyTester_ac70f96ce30f653210523935c455b76f4}{
\index{RubyTester@{RubyTester}!writePorts@{writePorts}}
\index{writePorts@{writePorts}!RubyTester@{RubyTester}}
\subsubsection[{writePorts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf MasterPort}$\ast$$>$ {\bf writePorts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyTester_ac70f96ce30f653210523935c455b76f4}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/testers/rubytest/\hyperlink{RubyTester_8hh}{RubyTester.hh}\item 
cpu/testers/rubytest/\hyperlink{RubyTester_8cc}{RubyTester.cc}\end{DoxyCompactItemize}
