\hypertarget{RubySlicc__Util_8hh}{
\section{mem/ruby/slicc\_\-interface/RubySlicc\_\-Util.hh}
\label{RubySlicc__Util_8hh}\index{mem/ruby/slicc\_\-interface/RubySlicc\_\-Util.hh@{mem/ruby/slicc\_\-interface/RubySlicc\_\-Util.hh}}
}
{\ttfamily \#include $<$cassert$>$}\par
{\ttfamily \#include \char`\"{}debug/RubySlicc.hh\char`\"{}}\par
{\ttfamily \#include \char`\"{}mem/ruby/common/Address.hh\char`\"{}}\par
{\ttfamily \#include \char`\"{}mem/ruby/common/DataBlock.hh\char`\"{}}\par
{\ttfamily \#include \char`\"{}mem/packet.hh\char`\"{}}\par
\subsection*{関数}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{RubySlicc__Util_8hh_a054fe6e7aa3343d6fee7974f712d356f}{random} (int n)
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{RubySlicc__Util_8hh_ab26322bfb1b54466aa64f4004331c8a4}{zero\_\-time} ()
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{RubySlicc__Util_8hh_a66423efa415e5d2f9721444631d64b1d}{TimeToCycles} (\hyperlink{classTime}{Time} t)
\item 
\hyperlink{TypeDefines_8hh_a83c14b4ae37e80071f6b3506a6c46151}{NodeID} \hyperlink{RubySlicc__Util_8hh_af871f54b5dfa4d06d5fa4bf151073079}{intToID} (int nodenum)
\item 
int \hyperlink{RubySlicc__Util_8hh_a4c6867d6bf98689723bdaa91c9c5e1ab}{IDToInt} (\hyperlink{TypeDefines_8hh_a83c14b4ae37e80071f6b3506a6c46151}{NodeID} id)
\item 
\hyperlink{classAddress}{Address} \hyperlink{RubySlicc__Util_8hh_aefc491106ae51d13fd4de1da69584186}{setOffset} (\hyperlink{classAddress}{Address} addr, int offset)
\item 
\hyperlink{classAddress}{Address} \hyperlink{RubySlicc__Util_8hh_a34d8ac0b1033cd01b3c076a556e599ba}{makeLineAddress} (\hyperlink{classAddress}{Address} addr)
\item 
int \hyperlink{RubySlicc__Util_8hh_a23322cb58f9528f114aa3bc1c85377bf}{addressOffset} (\hyperlink{classAddress}{Address} addr)
\item 
int \hyperlink{RubySlicc__Util_8hh_a1ae500ce573418f748bb5c85167c3bfb}{mod} (int val, int mod)
\item 
int \hyperlink{RubySlicc__Util_8hh_a1998a5b4fa544ddc060d14af78eb6f0b}{max\_\-tokens} ()
\item 
bool \hyperlink{RubySlicc__Util_8hh_a2d64f5e793ff434a195baa19092fdc7c}{testAndRead} (\hyperlink{classAddress}{Address} addr, \hyperlink{classDataBlock}{DataBlock} \&blk, \hyperlink{classPacket}{Packet} $\ast$pkt)
\item 
bool \hyperlink{RubySlicc__Util_8hh_afb1f6e13327ac7be7fc8f3886453bba0}{testAndWrite} (\hyperlink{classAddress}{Address} addr, \hyperlink{classDataBlock}{DataBlock} \&blk, \hyperlink{classPacket}{Packet} $\ast$pkt)
\end{DoxyCompactItemize}


\subsection{関数}
\hypertarget{RubySlicc__Util_8hh_a23322cb58f9528f114aa3bc1c85377bf}{
\index{RubySlicc\_\-Util.hh@{RubySlicc\_\-Util.hh}!addressOffset@{addressOffset}}
\index{addressOffset@{addressOffset}!RubySlicc_Util.hh@{RubySlicc\_\-Util.hh}}
\subsubsection[{addressOffset}]{\setlength{\rightskip}{0pt plus 5cm}int addressOffset ({\bf Address} {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{RubySlicc__Util_8hh_a23322cb58f9528f114aa3bc1c85377bf}



\begin{DoxyCode}
86 {
87     return addr.getOffset();
88 }
\end{DoxyCode}
\hypertarget{RubySlicc__Util_8hh_a4c6867d6bf98689723bdaa91c9c5e1ab}{
\index{RubySlicc\_\-Util.hh@{RubySlicc\_\-Util.hh}!IDToInt@{IDToInt}}
\index{IDToInt@{IDToInt}!RubySlicc_Util.hh@{RubySlicc\_\-Util.hh}}
\subsubsection[{IDToInt}]{\setlength{\rightskip}{0pt plus 5cm}int IDToInt ({\bf NodeID} {\em id})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{RubySlicc__Util_8hh_a4c6867d6bf98689723bdaa91c9c5e1ab}



\begin{DoxyCode}
61 {
62     int nodenum = id;
63     return nodenum;
64 }
\end{DoxyCode}
\hypertarget{RubySlicc__Util_8hh_af871f54b5dfa4d06d5fa4bf151073079}{
\index{RubySlicc\_\-Util.hh@{RubySlicc\_\-Util.hh}!intToID@{intToID}}
\index{intToID@{intToID}!RubySlicc_Util.hh@{RubySlicc\_\-Util.hh}}
\subsubsection[{intToID}]{\setlength{\rightskip}{0pt plus 5cm}{\bf NodeID} intToID (int {\em nodenum})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{RubySlicc__Util_8hh_af871f54b5dfa4d06d5fa4bf151073079}



\begin{DoxyCode}
54 {
55     NodeID id = nodenum;
56     return id;
57 }
\end{DoxyCode}
\hypertarget{RubySlicc__Util_8hh_a34d8ac0b1033cd01b3c076a556e599ba}{
\index{RubySlicc\_\-Util.hh@{RubySlicc\_\-Util.hh}!makeLineAddress@{makeLineAddress}}
\index{makeLineAddress@{makeLineAddress}!RubySlicc_Util.hh@{RubySlicc\_\-Util.hh}}
\subsubsection[{makeLineAddress}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} makeLineAddress ({\bf Address} {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{RubySlicc__Util_8hh_a34d8ac0b1033cd01b3c076a556e599ba}



\begin{DoxyCode}
78 {
79     Address result = addr;
80     result.makeLineAddress();
81     return result;
82 }
\end{DoxyCode}
\hypertarget{RubySlicc__Util_8hh_a1998a5b4fa544ddc060d14af78eb6f0b}{
\index{RubySlicc\_\-Util.hh@{RubySlicc\_\-Util.hh}!max\_\-tokens@{max\_\-tokens}}
\index{max\_\-tokens@{max\_\-tokens}!RubySlicc_Util.hh@{RubySlicc\_\-Util.hh}}
\subsubsection[{max\_\-tokens}]{\setlength{\rightskip}{0pt plus 5cm}int max\_\-tokens ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{RubySlicc__Util_8hh_a1998a5b4fa544ddc060d14af78eb6f0b}



\begin{DoxyCode}
97 {
98   return 1024;
99 }
\end{DoxyCode}
\hypertarget{RubySlicc__Util_8hh_a1ae500ce573418f748bb5c85167c3bfb}{
\index{RubySlicc\_\-Util.hh@{RubySlicc\_\-Util.hh}!mod@{mod}}
\index{mod@{mod}!RubySlicc_Util.hh@{RubySlicc\_\-Util.hh}}
\subsubsection[{mod}]{\setlength{\rightskip}{0pt plus 5cm}int mod (int {\em val}, \/  int {\em mod})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{RubySlicc__Util_8hh_a1ae500ce573418f748bb5c85167c3bfb}



\begin{DoxyCode}
92 {
93     return val % mod;
94 }
\end{DoxyCode}
\hypertarget{RubySlicc__Util_8hh_a054fe6e7aa3343d6fee7974f712d356f}{
\index{RubySlicc\_\-Util.hh@{RubySlicc\_\-Util.hh}!random@{random}}
\index{random@{random}!RubySlicc_Util.hh@{RubySlicc\_\-Util.hh}}
\subsubsection[{random}]{\setlength{\rightskip}{0pt plus 5cm}int random (int {\em n})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{RubySlicc__Util_8hh_a054fe6e7aa3343d6fee7974f712d356f}



\begin{DoxyCode}
45 {
46   return random() % n;
47 }
\end{DoxyCode}
\hypertarget{RubySlicc__Util_8hh_aefc491106ae51d13fd4de1da69584186}{
\index{RubySlicc\_\-Util.hh@{RubySlicc\_\-Util.hh}!setOffset@{setOffset}}
\index{setOffset@{setOffset}!RubySlicc_Util.hh@{RubySlicc\_\-Util.hh}}
\subsubsection[{setOffset}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} setOffset ({\bf Address} {\em addr}, \/  int {\em offset})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{RubySlicc__Util_8hh_aefc491106ae51d13fd4de1da69584186}



\begin{DoxyCode}
69 {
70     Address result = addr;
71     result.setOffset(offset);
72     return result;
73 }
\end{DoxyCode}
\hypertarget{RubySlicc__Util_8hh_a2d64f5e793ff434a195baa19092fdc7c}{
\index{RubySlicc\_\-Util.hh@{RubySlicc\_\-Util.hh}!testAndRead@{testAndRead}}
\index{testAndRead@{testAndRead}!RubySlicc_Util.hh@{RubySlicc\_\-Util.hh}}
\subsubsection[{testAndRead}]{\setlength{\rightskip}{0pt plus 5cm}bool testAndRead ({\bf Address} {\em addr}, \/  {\bf DataBlock} \& {\em blk}, \/  {\bf Packet} $\ast$ {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{RubySlicc__Util_8hh_a2d64f5e793ff434a195baa19092fdc7c}
This function accepts an address, a data block and a packet. If the address range for the data block contains the address which the packet needs to read, then the data from the data block is written to the packet. True is returned if the data block was read, otherwise false is returned. 


\begin{DoxyCode}
109 {
110     Address pktLineAddr(pkt->getAddr());
111     pktLineAddr.makeLineAddress();
112 
113     Address lineAddr = addr;
114     lineAddr.makeLineAddress();
115 
116     if (pktLineAddr == lineAddr) {
117         uint8_t *data = pkt->getPtr<uint8_t>(true);
118         unsigned int size_in_bytes = pkt->getSize();
119         unsigned startByte = pkt->getAddr() - lineAddr.getAddress();
120 
121         for (unsigned i = 0; i < size_in_bytes; ++i) {
122             data[i] = blk.getByte(i + startByte);
123         }
124         return true;
125     }
126     return false;
127 }
\end{DoxyCode}
\hypertarget{RubySlicc__Util_8hh_afb1f6e13327ac7be7fc8f3886453bba0}{
\index{RubySlicc\_\-Util.hh@{RubySlicc\_\-Util.hh}!testAndWrite@{testAndWrite}}
\index{testAndWrite@{testAndWrite}!RubySlicc_Util.hh@{RubySlicc\_\-Util.hh}}
\subsubsection[{testAndWrite}]{\setlength{\rightskip}{0pt plus 5cm}bool testAndWrite ({\bf Address} {\em addr}, \/  {\bf DataBlock} \& {\em blk}, \/  {\bf Packet} $\ast$ {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{RubySlicc__Util_8hh_afb1f6e13327ac7be7fc8f3886453bba0}
This function accepts an address, a data block and a packet. If the address range for the data block contains the address which the packet needs to write, then the data from the packet is written to the data block. True is returned if the data block was written, otherwise false is returned. 


\begin{DoxyCode}
137 {
138     Address pktLineAddr(pkt->getAddr());
139     pktLineAddr.makeLineAddress();
140 
141     Address lineAddr = addr;
142     lineAddr.makeLineAddress();
143 
144     if (pktLineAddr == lineAddr) {
145         uint8_t *data = pkt->getPtr<uint8_t>(true);
146         unsigned int size_in_bytes = pkt->getSize();
147         unsigned startByte = pkt->getAddr() - lineAddr.getAddress();
148 
149         for (unsigned i = 0; i < size_in_bytes; ++i) {
150             blk.setByte(i + startByte, data[i]);
151         }
152         return true;
153     }
154     return false;
155 }
\end{DoxyCode}
\hypertarget{RubySlicc__Util_8hh_a66423efa415e5d2f9721444631d64b1d}{
\index{RubySlicc\_\-Util.hh@{RubySlicc\_\-Util.hh}!TimeToCycles@{TimeToCycles}}
\index{TimeToCycles@{TimeToCycles}!RubySlicc_Util.hh@{RubySlicc\_\-Util.hh}}
\subsubsection[{TimeToCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} TimeToCycles ({\bf Time} {\em t})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{RubySlicc__Util_8hh_a66423efa415e5d2f9721444631d64b1d}



\begin{DoxyCode}
50 { return Cycles(t); }
\end{DoxyCode}
\hypertarget{RubySlicc__Util_8hh_ab26322bfb1b54466aa64f4004331c8a4}{
\index{RubySlicc\_\-Util.hh@{RubySlicc\_\-Util.hh}!zero\_\-time@{zero\_\-time}}
\index{zero\_\-time@{zero\_\-time}!RubySlicc_Util.hh@{RubySlicc\_\-Util.hh}}
\subsubsection[{zero\_\-time}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} zero\_\-time ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{RubySlicc__Util_8hh_ab26322bfb1b54466aa64f4004331c8a4}



\begin{DoxyCode}
49 { return Cycles(0); }
\end{DoxyCode}
