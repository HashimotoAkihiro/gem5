\hypertarget{classCoherentBus}{
\section{クラス CoherentBus}
\label{classCoherentBus}\index{CoherentBus@{CoherentBus}}
}


{\ttfamily \#include $<$coherent\_\-bus.hh$>$}CoherentBusに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=6cm]{classCoherentBus}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classCoherentBus_1_1CoherentBusMasterPort}{CoherentBusMasterPort}
\item 
class \hyperlink{classCoherentBus_1_1CoherentBusSlavePort}{CoherentBusSlavePort}
\item 
class \hyperlink{classCoherentBus_1_1SnoopRespPort}{SnoopRespPort}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classCoherentBus_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
\hyperlink{classCoherentBus_a0ca3474701c095c96854cb430f4f6bba}{CoherentBus} (const CoherentBusParams $\ast$p)
\item 
virtual \hyperlink{classCoherentBus_a9f68bdf0f3ed90b32cf54e32f4bfc0b2}{$\sim$CoherentBus} ()
\item 
unsigned int \hyperlink{classCoherentBus_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)
\item 
virtual void \hyperlink{classCoherentBus_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classBaseBus_1_1Layer}{Layer}$<$ \hyperlink{classSlavePort}{SlavePort}, \hyperlink{classMasterPort}{MasterPort} $>$ \hyperlink{classCoherentBus_ae15f02c0dca186fbfbd2f7b732e5b441}{ReqLayer}
\item 
typedef \hyperlink{classBaseBus_1_1Layer}{Layer}$<$ \hyperlink{classMasterPort}{MasterPort}, \hyperlink{classSlavePort}{SlavePort} $>$ \hyperlink{classCoherentBus_a40797c56ea5eaf481f56dfdc3ab1b399}{RespLayer}
\item 
typedef \hyperlink{classBaseBus_1_1Layer}{Layer}$<$ \hyperlink{classSlavePort}{SlavePort}, \hyperlink{classMasterPort}{MasterPort} $>$ \hyperlink{classCoherentBus_a73f554be8ad7076f9403bb35d6af14f1}{SnoopLayer}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classCoherentBus_a8e2d7ccc3adb605e763f2bd1c64e5128}{recvTimingReq} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} slave\_\-port\_\-id)
\item 
bool \hyperlink{classCoherentBus_a47ba09f9a3b3998cac9c14ab596a7515}{recvTimingResp} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} master\_\-port\_\-id)
\item 
void \hyperlink{classCoherentBus_a8a06090652319e21031b8bc2f8018e2b}{recvTimingSnoopReq} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} master\_\-port\_\-id)
\item 
bool \hyperlink{classCoherentBus_a29d5427944c6a4e363cf42eb70f480b1}{recvTimingSnoopResp} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} slave\_\-port\_\-id)
\item 
void \hyperlink{classCoherentBus_a96f9cd33bfb9a8b7fb2b25078eaf75a1}{recvRetry} (\hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} master\_\-port\_\-id)
\item 
void \hyperlink{classCoherentBus_a63303c7524b820a7d0de62c07b097139}{forwardTiming} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} exclude\_\-slave\_\-port\_\-id)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classCoherentBus_ab0e34155d341f5561834eca8e4c97759}{recvAtomic} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} slave\_\-port\_\-id)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classCoherentBus_a533893555a1e2a7727e380a4747c33fb}{recvAtomicSnoop} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} master\_\-port\_\-id)
\item 
\hyperlink{classstd_1_1pair}{std::pair}$<$ \hyperlink{classMemCmd}{MemCmd}, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} $>$ \hyperlink{classCoherentBus_aec73b2af9058f907bf2cf6c2773d46ba}{forwardAtomic} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} exclude\_\-slave\_\-port\_\-id)
\item 
void \hyperlink{classCoherentBus_a5cdfa7d369ba37394403d3c2bd5cf6d1}{recvFunctional} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} slave\_\-port\_\-id)
\item 
void \hyperlink{classCoherentBus_aab366eefcf6b389a308a63c82e7b3116}{recvFunctionalSnoop} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} master\_\-port\_\-id)
\item 
void \hyperlink{classCoherentBus_a45d5f60100921e96c8635b20cd9e9fab}{forwardFunctional} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} exclude\_\-slave\_\-port\_\-id)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classBaseBus_1_1Layer}{ReqLayer} $\ast$ $>$ \hyperlink{classCoherentBus_ab124575386549f77de080cd9fcaf2ba0}{reqLayers}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classBaseBus_1_1Layer}{RespLayer} $\ast$ $>$ \hyperlink{classCoherentBus_a2f42dda70e78f1e5e9574f11b465d173}{respLayers}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classBaseBus_1_1Layer}{SnoopLayer} $\ast$ $>$ \hyperlink{classCoherentBus_ae6f8cf70846d8ee4b2314816863efbca}{snoopLayers}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classCoherentBus_1_1SnoopRespPort}{SnoopRespPort} $\ast$ $>$ \hyperlink{classCoherentBus_ae876574c554fa099bcd063e2e188b95b}{snoopRespPorts}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classSlavePort}{SlavePort} $\ast$ $>$ \hyperlink{classCoherentBus_acdbc947756de5f5071b88ce0702d557d}{snoopPorts}
\item 
m5::hash\_\-set$<$ \hyperlink{classRequest}{RequestPtr} $>$ \hyperlink{classCoherentBus_a8b5de6798515d1ac1236592c5ad7c521}{outstandingReq}
\item 
\hyperlink{classSystem}{System} $\ast$ \hyperlink{classCoherentBus_af27ccd765f13a4b7bd119dc7579e2746}{system}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classCoherentBus_a7040fa8d9fb24afb9f4fe245b135da19}{dataThroughBus}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classCoherentBus_a576c4936ce7bed70cd1751024670e75f}{snoopDataThroughBus}
\end{DoxyCompactItemize}


\subsection{説明}
A coherent bus connects a number of (potentially) snooping masters and slaves, and routes the request and response packets based on the address, and also forwards all requests to the snoopers and deals with the snoop responses.

The coherent bus can be used as a template for modelling QPI, HyperTransport, ACE and coherent OCP buses, and is typically used for the L1-\/to-\/L2 buses and as the main system interconnect. \begin{DoxySeeAlso}{参照}
gem5 Memory System 
\end{DoxySeeAlso}


\subsection{型定義}
\hypertarget{classCoherentBus_ae15f02c0dca186fbfbd2f7b732e5b441}{
\index{CoherentBus@{CoherentBus}!ReqLayer@{ReqLayer}}
\index{ReqLayer@{ReqLayer}!CoherentBus@{CoherentBus}}
\subsubsection[{ReqLayer}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Layer}$<${\bf SlavePort},{\bf MasterPort}$>$ {\bf ReqLayer}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_ae15f02c0dca186fbfbd2f7b732e5b441}
Declare the layers of this bus, one vector for requests, one for responses, and one for snoop responses \hypertarget{classCoherentBus_a40797c56ea5eaf481f56dfdc3ab1b399}{
\index{CoherentBus@{CoherentBus}!RespLayer@{RespLayer}}
\index{RespLayer@{RespLayer}!CoherentBus@{CoherentBus}}
\subsubsection[{RespLayer}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Layer}$<${\bf MasterPort},{\bf SlavePort}$>$ {\bf RespLayer}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_a40797c56ea5eaf481f56dfdc3ab1b399}
\hypertarget{classCoherentBus_a73f554be8ad7076f9403bb35d6af14f1}{
\index{CoherentBus@{CoherentBus}!SnoopLayer@{SnoopLayer}}
\index{SnoopLayer@{SnoopLayer}!CoherentBus@{CoherentBus}}
\subsubsection[{SnoopLayer}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Layer}$<${\bf SlavePort},{\bf MasterPort}$>$ {\bf SnoopLayer}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_a73f554be8ad7076f9403bb35d6af14f1}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classCoherentBus_a0ca3474701c095c96854cb430f4f6bba}{
\index{CoherentBus@{CoherentBus}!CoherentBus@{CoherentBus}}
\index{CoherentBus@{CoherentBus}!CoherentBus@{CoherentBus}}
\subsubsection[{CoherentBus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CoherentBus} (const CoherentBusParams $\ast$ {\em p})}}
\label{classCoherentBus_a0ca3474701c095c96854cb430f4f6bba}



\begin{DoxyCode}
58     : BaseBus(p), system(p->system)
59 {
60     // create the ports based on the size of the master and slave
61     // vector ports, and the presence of the default port, the ports
62     // are enumerated starting from zero
63     for (int i = 0; i < p->port_master_connection_count; ++i) {
64         std::string portName = csprintf("%s.master[%d]", name(), i);
65         MasterPort* bp = new CoherentBusMasterPort(portName, *this, i);
66         masterPorts.push_back(bp);
67         reqLayers.push_back(new ReqLayer(*bp, *this,
68                                          csprintf(".reqLayer%d", i)));
69         snoopLayers.push_back(new SnoopLayer(*bp, *this,
70                                              csprintf(".snoopLayer%d", i)));
71     }
72 
73     // see if we have a default slave device connected and if so add
74     // our corresponding master port
75     if (p->port_default_connection_count) {
76         defaultPortID = masterPorts.size();
77         std::string portName = name() + ".default";
78         MasterPort* bp = new CoherentBusMasterPort(portName, *this,
79                                                    defaultPortID);
80         masterPorts.push_back(bp);
81         reqLayers.push_back(new ReqLayer(*bp, *this, csprintf(".reqLayer%d",
82                                              defaultPortID)));
83         snoopLayers.push_back(new SnoopLayer(*bp, *this,
84                                              csprintf(".snoopLayer%d",
85                                                       defaultPortID)));
86     }
87 
88     // create the slave ports, once again starting at zero
89     for (int i = 0; i < p->port_slave_connection_count; ++i) {
90         std::string portName = csprintf("%s.slave[%d]", name(), i);
91         SlavePort* bp = new CoherentBusSlavePort(portName, *this, i);
92         slavePorts.push_back(bp);
93         respLayers.push_back(new RespLayer(*bp, *this,
94                                            csprintf(".respLayer%d", i)));
95         snoopRespPorts.push_back(new SnoopRespPort(*bp, *this));
96     }
97 
98     clearPortCache();
99 }
\end{DoxyCode}
\hypertarget{classCoherentBus_a9f68bdf0f3ed90b32cf54e32f4bfc0b2}{
\index{CoherentBus@{CoherentBus}!$\sim$CoherentBus@{$\sim$CoherentBus}}
\index{$\sim$CoherentBus@{$\sim$CoherentBus}!CoherentBus@{CoherentBus}}
\subsubsection[{$\sim$CoherentBus}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf CoherentBus} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCoherentBus_a9f68bdf0f3ed90b32cf54e32f4bfc0b2}



\begin{DoxyCode}
102 {
103     for (auto l = reqLayers.begin(); l != reqLayers.end(); ++l)
104         delete *l;
105     for (auto l = respLayers.begin(); l != respLayers.end(); ++l)
106         delete *l;
107     for (auto l = snoopLayers.begin(); l != snoopLayers.end(); ++l)
108         delete *l;
109     for (auto p = snoopRespPorts.begin(); p != snoopRespPorts.end(); ++p)
110         delete *p;
111 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classCoherentBus_aa8a18d230dba7a674ac8a0b4f35bc36a}{
\index{CoherentBus@{CoherentBus}!drain@{drain}}
\index{drain@{drain}!CoherentBus@{CoherentBus}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em drainManger})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCoherentBus_aa8a18d230dba7a674ac8a0b4f35bc36a}
Provide a default implementation of the drain interface that simply returns 0 (draining completed) and sets the drain state to Drained. 

\hyperlink{classBaseBus_ac8c1510f7e1591e75a5c79b4b873f6b4}{BaseBus}を実装しています。


\begin{DoxyCode}
636 {
637     // sum up the individual layers
638     unsigned int total = 0;
639     for (auto l = reqLayers.begin(); l != reqLayers.end(); ++l)
640         total += (*l)->drain(dm);
641     for (auto l = respLayers.begin(); l != respLayers.end(); ++l)
642         total += (*l)->drain(dm);
643     for (auto l = snoopLayers.begin(); l != snoopLayers.end(); ++l)
644         total += (*l)->drain(dm);
645     return total;
646 }
\end{DoxyCode}
\hypertarget{classCoherentBus_aec73b2af9058f907bf2cf6c2773d46ba}{
\index{CoherentBus@{CoherentBus}!forwardAtomic@{forwardAtomic}}
\index{forwardAtomic@{forwardAtomic}!CoherentBus@{CoherentBus}}
\subsubsection[{forwardAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::pair}$<$ {\bf MemCmd}, {\bf Tick} $>$ forwardAtomic ({\bf PacketPtr} {\em pkt}, \/  {\bf PortID} {\em exclude\_\-slave\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_aec73b2af9058f907bf2cf6c2773d46ba}
Forward an atomic packet to our snoopers, potentially excluding one of the connected coherent masters to avoid sending a packet back to where it came from.


\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} to forward \item[{\em exclude\_\-slave\_\-port\_\-id}]Id of slave port to exclude\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
a pair containing the snoop response and snoop latency 
\end{DoxyReturn}



\begin{DoxyCode}
527 {
528     // the packet may be changed on snoops, record the original
529     // command to enable us to restore it between snoops so that
530     // additional snoops can take place properly
531     MemCmd orig_cmd = pkt->cmd;
532     MemCmd snoop_response_cmd = MemCmd::InvalidCmd;
533     Tick snoop_response_latency = 0;
534 
535     // snoops should only happen if the system isn't bypassing caches
536     assert(!system->bypassCaches());
537 
538     for (SlavePortIter s = snoopPorts.begin(); s != snoopPorts.end(); ++s) {
539         SlavePort *p = *s;
540         // we could have gotten this request from a snooping master
541         // (corresponding to our own slave port that is also in
542         // snoopPorts) and should not send it back to where it came
543         // from
544         if (exclude_slave_port_id == InvalidPortID ||
545             p->getId() != exclude_slave_port_id) {
546             Tick latency = p->sendAtomicSnoop(pkt);
547             // in contrast to a functional access, we have to keep on
548             // going as all snoopers must be updated even if we get a
549             // response
550             if (pkt->isResponse()) {
551                 // response from snoop agent
552                 assert(pkt->cmd != orig_cmd);
553                 assert(pkt->memInhibitAsserted());
554                 // should only happen once
555                 assert(snoop_response_cmd == MemCmd::InvalidCmd);
556                 // save response state
557                 snoop_response_cmd = pkt->cmd;
558                 snoop_response_latency = latency;
559                 // restore original packet state for remaining snoopers
560                 pkt->cmd = orig_cmd;
561             }
562         }
563     }
564 
565     // the packet is restored as part of the loop and any potential
566     // snoop response is part of the returned pair
567     return std::make_pair(snoop_response_cmd, snoop_response_latency);
568 }
\end{DoxyCode}
\hypertarget{classCoherentBus_a45d5f60100921e96c8635b20cd9e9fab}{
\index{CoherentBus@{CoherentBus}!forwardFunctional@{forwardFunctional}}
\index{forwardFunctional@{forwardFunctional}!CoherentBus@{CoherentBus}}
\subsubsection[{forwardFunctional}]{\setlength{\rightskip}{0pt plus 5cm}void forwardFunctional ({\bf PacketPtr} {\em pkt}, \/  {\bf PortID} {\em exclude\_\-slave\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_a45d5f60100921e96c8635b20cd9e9fab}
Forward a functional packet to our snoopers, potentially excluding one of the connected coherent masters to avoid sending a packet back to where it came from.


\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} to forward \item[{\em exclude\_\-slave\_\-port\_\-id}]Id of slave port to exclude \end{DoxyParams}



\begin{DoxyCode}
613 {
614     // snoops should only happen if the system isn't bypassing caches
615     assert(!system->bypassCaches());
616 
617     for (SlavePortIter s = snoopPorts.begin(); s != snoopPorts.end(); ++s) {
618         SlavePort *p = *s;
619         // we could have gotten this request from a snooping master
620         // (corresponding to our own slave port that is also in
621         // snoopPorts) and should not send it back to where it came
622         // from
623         if (exclude_slave_port_id == InvalidPortID ||
624             p->getId() != exclude_slave_port_id)
625             p->sendFunctionalSnoop(pkt);
626 
627         // if we get a response we are done
628         if (pkt->isResponse()) {
629             break;
630         }
631     }
632 }
\end{DoxyCode}
\hypertarget{classCoherentBus_a63303c7524b820a7d0de62c07b097139}{
\index{CoherentBus@{CoherentBus}!forwardTiming@{forwardTiming}}
\index{forwardTiming@{forwardTiming}!CoherentBus@{CoherentBus}}
\subsubsection[{forwardTiming}]{\setlength{\rightskip}{0pt plus 5cm}void forwardTiming ({\bf PacketPtr} {\em pkt}, \/  {\bf PortID} {\em exclude\_\-slave\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_a63303c7524b820a7d0de62c07b097139}
Forward a timing packet to our snoopers, potentially excluding one of the connected coherent masters to avoid sending a packet back to where it came from.


\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} to forward \item[{\em exclude\_\-slave\_\-port\_\-id}]Id of slave port to exclude \end{DoxyParams}



\begin{DoxyCode}
421 {
422     DPRINTF(CoherentBus, "%s for %s address %x size %d\n", __func__,
423             pkt->cmdString(), pkt->getAddr(), pkt->getSize());
424 
425     // snoops should only happen if the system isn't bypassing caches
426     assert(!system->bypassCaches());
427 
428     for (SlavePortIter s = snoopPorts.begin(); s != snoopPorts.end(); ++s) {
429         SlavePort *p = *s;
430         // we could have gotten this request from a snooping master
431         // (corresponding to our own slave port that is also in
432         // snoopPorts) and should not send it back to where it came
433         // from
434         if (exclude_slave_port_id == InvalidPortID ||
435             p->getId() != exclude_slave_port_id) {
436             // cache is not allowed to refuse snoop
437             p->sendTimingSnoopReq(pkt);
438         }
439     }
440 }
\end{DoxyCode}
\hypertarget{classCoherentBus_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{CoherentBus@{CoherentBus}!init@{init}}
\index{init@{init}!CoherentBus@{CoherentBus}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCoherentBus_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classCoherentBus_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classBaseBus_a02fd73d861ef2e4aabb38c0c9ff82947}{BaseBus}を再定義しています。


\begin{DoxyCode}
115 {
116     // the base class is responsible for determining the block size
117     BaseBus::init();
118 
119     // iterate over our slave ports and determine which of our
120     // neighbouring master ports are snooping and add them as snoopers
121     for (SlavePortConstIter p = slavePorts.begin(); p != slavePorts.end();
122          ++p) {
123         // check if the connected master port is snooping
124         if ((*p)->isSnooping()) {
125             DPRINTF(BusAddrRanges, "Adding snooping master %s\n",
126                     (*p)->getMasterPort().name());
127             snoopPorts.push_back(*p);
128         }
129     }
130 
131     if (snoopPorts.empty())
132         warn("CoherentBus %s has no snooping ports attached!\n", name());
133 }
\end{DoxyCode}
\hypertarget{classCoherentBus_ab0e34155d341f5561834eca8e4c97759}{
\index{CoherentBus@{CoherentBus}!recvAtomic@{recvAtomic}}
\index{recvAtomic@{recvAtomic}!CoherentBus@{CoherentBus}}
\subsubsection[{recvAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvAtomic ({\bf PacketPtr} {\em pkt}, \/  {\bf PortID} {\em slave\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_ab0e34155d341f5561834eca8e4c97759}
Function called by the port when the bus is recieving a Atomic transaction. 


\begin{DoxyCode}
453 {
454     DPRINTF(CoherentBus, "recvAtomic: packet src %s addr 0x%x cmd %s\n",
455             slavePorts[slave_port_id]->name(), pkt->getAddr(),
456             pkt->cmdString());
457 
458     // add the request data
459     dataThroughBus += pkt->hasData() ? pkt->getSize() : 0;
460 
461     MemCmd snoop_response_cmd = MemCmd::InvalidCmd;
462     Tick snoop_response_latency = 0;
463 
464     // uncacheable requests need never be snooped
465     if (!pkt->req->isUncacheable() && !system->bypassCaches()) {
466         // forward to all snoopers but the source
467         std::pair<MemCmd, Tick> snoop_result =
468             forwardAtomic(pkt, slave_port_id);
469         snoop_response_cmd = snoop_result.first;
470         snoop_response_latency = snoop_result.second;
471     }
472 
473     // even if we had a snoop response, we must continue and also
474     // perform the actual request at the destination
475     PortID dest_id = findPort(pkt->getAddr());
476 
477     // forward the request to the appropriate destination
478     Tick response_latency = masterPorts[dest_id]->sendAtomic(pkt);
479 
480     // if we got a response from a snooper, restore it here
481     if (snoop_response_cmd != MemCmd::InvalidCmd) {
482         // no one else should have responded
483         assert(!pkt->isResponse());
484         pkt->cmd = snoop_response_cmd;
485         response_latency = snoop_response_latency;
486     }
487 
488     // add the response data
489     if (pkt->isResponse())
490         dataThroughBus += pkt->hasData() ? pkt->getSize() : 0;
491 
492     // @todo: Not setting first-word time
493     pkt->busLastWordDelay = response_latency;
494     return response_latency;
495 }
\end{DoxyCode}
\hypertarget{classCoherentBus_a533893555a1e2a7727e380a4747c33fb}{
\index{CoherentBus@{CoherentBus}!recvAtomicSnoop@{recvAtomicSnoop}}
\index{recvAtomicSnoop@{recvAtomicSnoop}!CoherentBus@{CoherentBus}}
\subsubsection[{recvAtomicSnoop}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvAtomicSnoop ({\bf PacketPtr} {\em pkt}, \/  {\bf PortID} {\em master\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_a533893555a1e2a7727e380a4747c33fb}
Function called by the port when the bus is recieving an atomic snoop transaction. 


\begin{DoxyCode}
499 {
500     DPRINTF(CoherentBus, "recvAtomicSnoop: packet src %s addr 0x%x cmd %s\n",
501             masterPorts[master_port_id]->name(), pkt->getAddr(),
502             pkt->cmdString());
503 
504     // add the request snoop data
505     snoopDataThroughBus += pkt->hasData() ? pkt->getSize() : 0;
506 
507     // forward to all snoopers
508     std::pair<MemCmd, Tick> snoop_result =
509         forwardAtomic(pkt, InvalidPortID);
510     MemCmd snoop_response_cmd = snoop_result.first;
511     Tick snoop_response_latency = snoop_result.second;
512 
513     if (snoop_response_cmd != MemCmd::InvalidCmd)
514         pkt->cmd = snoop_response_cmd;
515 
516     // add the response snoop data
517     if (pkt->isResponse())
518         snoopDataThroughBus += pkt->hasData() ? pkt->getSize() : 0;
519 
520     // @todo: Not setting first-word time
521     pkt->busLastWordDelay = snoop_response_latency;
522     return snoop_response_latency;
523 }
\end{DoxyCode}
\hypertarget{classCoherentBus_a5cdfa7d369ba37394403d3c2bd5cf6d1}{
\index{CoherentBus@{CoherentBus}!recvFunctional@{recvFunctional}}
\index{recvFunctional@{recvFunctional}!CoherentBus@{CoherentBus}}
\subsubsection[{recvFunctional}]{\setlength{\rightskip}{0pt plus 5cm}void recvFunctional ({\bf PacketPtr} {\em pkt}, \/  {\bf PortID} {\em slave\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_a5cdfa7d369ba37394403d3c2bd5cf6d1}
Function called by the port when the bus is recieving a Functional transaction. 


\begin{DoxyCode}
572 {
573     if (!pkt->isPrint()) {
574         // don't do DPRINTFs on PrintReq as it clutters up the output
575         DPRINTF(CoherentBus,
576                 "recvFunctional: packet src %s addr 0x%x cmd %s\n",
577                 slavePorts[slave_port_id]->name(), pkt->getAddr(),
578                 pkt->cmdString());
579     }
580 
581     // uncacheable requests need never be snooped
582     if (!pkt->req->isUncacheable() && !system->bypassCaches()) {
583         // forward to all snoopers but the source
584         forwardFunctional(pkt, slave_port_id);
585     }
586 
587     // there is no need to continue if the snooping has found what we
588     // were looking for and the packet is already a response
589     if (!pkt->isResponse()) {
590         PortID dest_id = findPort(pkt->getAddr());
591 
592         masterPorts[dest_id]->sendFunctional(pkt);
593     }
594 }
\end{DoxyCode}
\hypertarget{classCoherentBus_aab366eefcf6b389a308a63c82e7b3116}{
\index{CoherentBus@{CoherentBus}!recvFunctionalSnoop@{recvFunctionalSnoop}}
\index{recvFunctionalSnoop@{recvFunctionalSnoop}!CoherentBus@{CoherentBus}}
\subsubsection[{recvFunctionalSnoop}]{\setlength{\rightskip}{0pt plus 5cm}void recvFunctionalSnoop ({\bf PacketPtr} {\em pkt}, \/  {\bf PortID} {\em master\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_aab366eefcf6b389a308a63c82e7b3116}
Function called by the port when the bus is recieving a functional snoop transaction. 


\begin{DoxyCode}
598 {
599     if (!pkt->isPrint()) {
600         // don't do DPRINTFs on PrintReq as it clutters up the output
601         DPRINTF(CoherentBus,
602                 "recvFunctionalSnoop: packet src %s addr 0x%x cmd %s\n",
603                 masterPorts[master_port_id]->name(), pkt->getAddr(),
604                 pkt->cmdString());
605     }
606 
607     // forward to all snoopers
608     forwardFunctional(pkt, InvalidPortID);
609 }
\end{DoxyCode}
\hypertarget{classCoherentBus_a96f9cd33bfb9a8b7fb2b25078eaf75a1}{
\index{CoherentBus@{CoherentBus}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!CoherentBus@{CoherentBus}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetry ({\bf PortID} {\em master\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_a96f9cd33bfb9a8b7fb2b25078eaf75a1}
Timing function called by port when it is once again able to process requests. 


\begin{DoxyCode}
444 {
445     // responses and snoop responses never block on forwarding them,
446     // so the retry will always be coming from a port to which we
447     // tried to forward a request
448     reqLayers[master_port_id]->recvRetry();
449 }
\end{DoxyCode}
\hypertarget{classCoherentBus_a8e2d7ccc3adb605e763f2bd1c64e5128}{
\index{CoherentBus@{CoherentBus}!recvTimingReq@{recvTimingReq}}
\index{recvTimingReq@{recvTimingReq}!CoherentBus@{CoherentBus}}
\subsubsection[{recvTimingReq}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingReq ({\bf PacketPtr} {\em pkt}, \/  {\bf PortID} {\em slave\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_a8e2d7ccc3adb605e763f2bd1c64e5128}
Function called by the port when the bus is recieving a Timing request packet. 


\begin{DoxyCode}
137 {
138     // determine the source port based on the id
139     SlavePort *src_port = slavePorts[slave_port_id];
140 
141     // remember if the packet is an express snoop
142     bool is_express_snoop = pkt->isExpressSnoop();
143 
144     // determine the destination based on the address
145     PortID master_port_id = findPort(pkt->getAddr());
146 
147     // test if the bus should be considered occupied for the current
148     // port, and exclude express snoops from the check
149     if (!is_express_snoop && !reqLayers[master_port_id]->tryTiming(src_port)) {
150         DPRINTF(CoherentBus, "recvTimingReq: src %s %s 0x%x BUS BUSY\n",
151                 src_port->name(), pkt->cmdString(), pkt->getAddr());
152         return false;
153     }
154 
155     DPRINTF(CoherentBus, "recvTimingReq: src %s %s expr %d 0x%x\n",
156             src_port->name(), pkt->cmdString(), is_express_snoop,
157             pkt->getAddr());
158 
159     // store size and command as they might be modified when
160     // forwarding the packet
161     unsigned int pkt_size = pkt->hasData() ? pkt->getSize() : 0;
162     unsigned int pkt_cmd = pkt->cmdToIndex();
163 
164     // set the source port for routing of the response
165     pkt->setSrc(slave_port_id);
166 
167     calcPacketTiming(pkt);
168     Tick packetFinishTime = pkt->busLastWordDelay + curTick();
169 
170     // uncacheable requests need never be snooped
171     if (!pkt->req->isUncacheable() && !system->bypassCaches()) {
172         // the packet is a memory-mapped request and should be
173         // broadcasted to our snoopers but the source
174         forwardTiming(pkt, slave_port_id);
175     }
176 
177     // remember if we add an outstanding req so we can undo it if
178     // necessary, if the packet needs a response, we should add it
179     // as outstanding and express snoops never fail so there is
180     // not need to worry about them
181     bool add_outstanding = !is_express_snoop && pkt->needsResponse();
182 
183     // keep track that we have an outstanding request packet
184     // matching this request, this is used by the coherency
185     // mechanism in determining what to do with snoop responses
186     // (in recvTimingSnoop)
187     if (add_outstanding) {
188         // we should never have an exsiting request outstanding
189         assert(outstandingReq.find(pkt->req) == outstandingReq.end());
190         outstandingReq.insert(pkt->req);
191     }
192 
193     // since it is a normal request, attempt to send the packet
194     bool success = masterPorts[master_port_id]->sendTimingReq(pkt);
195 
196     // if this is an express snoop, we are done at this point
197     if (is_express_snoop) {
198         assert(success);
199         snoopDataThroughBus += pkt_size;
200     } else {
201         // for normal requests, check if successful
202         if (!success)  {
203             // inhibited packets should never be forced to retry
204             assert(!pkt->memInhibitAsserted());
205 
206             // if it was added as outstanding and the send failed, then
207             // erase it again
208             if (add_outstanding)
209                 outstandingReq.erase(pkt->req);
210 
211             // undo the calculation so we can check for 0 again
212             pkt->busFirstWordDelay = pkt->busLastWordDelay = 0;
213 
214             DPRINTF(CoherentBus, "recvTimingReq: src %s %s 0x%x RETRY\n",
215                     src_port->name(), pkt->cmdString(), pkt->getAddr());
216 
217             // update the bus state and schedule an idle event
218             reqLayers[master_port_id]->failedTiming(src_port,
219                                                     clockEdge(headerCycles));
220         } else {
221             // update the bus state and schedule an idle event
222             reqLayers[master_port_id]->succeededTiming(packetFinishTime);
223             dataThroughBus += pkt_size;
224         }
225     }
226 
227     // stats updates only consider packets that were successfully sent
228     if (success) {
229         pktCount[slave_port_id][master_port_id]++;
230         totPktSize[slave_port_id][master_port_id] += pkt_size;
231         transDist[pkt_cmd]++;
232     }
233 
234     return success;
235 }
\end{DoxyCode}
\hypertarget{classCoherentBus_a47ba09f9a3b3998cac9c14ab596a7515}{
\index{CoherentBus@{CoherentBus}!recvTimingResp@{recvTimingResp}}
\index{recvTimingResp@{recvTimingResp}!CoherentBus@{CoherentBus}}
\subsubsection[{recvTimingResp}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingResp ({\bf PacketPtr} {\em pkt}, \/  {\bf PortID} {\em master\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_a47ba09f9a3b3998cac9c14ab596a7515}
Function called by the port when the bus is recieving a Timing response packet. 


\begin{DoxyCode}
239 {
240     // determine the source port based on the id
241     MasterPort *src_port = masterPorts[master_port_id];
242 
243     // determine the destination based on what is stored in the packet
244     PortID slave_port_id = pkt->getDest();
245 
246     // test if the bus should be considered occupied for the current
247     // port
248     if (!respLayers[slave_port_id]->tryTiming(src_port)) {
249         DPRINTF(CoherentBus, "recvTimingResp: src %s %s 0x%x BUSY\n",
250                 src_port->name(), pkt->cmdString(), pkt->getAddr());
251         return false;
252     }
253 
254     DPRINTF(CoherentBus, "recvTimingResp: src %s %s 0x%x\n",
255             src_port->name(), pkt->cmdString(), pkt->getAddr());
256 
257     // store size and command as they might be modified when
258     // forwarding the packet
259     unsigned int pkt_size = pkt->hasData() ? pkt->getSize() : 0;
260     unsigned int pkt_cmd = pkt->cmdToIndex();
261 
262     calcPacketTiming(pkt);
263     Tick packetFinishTime = pkt->busLastWordDelay + curTick();
264 
265     // the packet is a normal response to a request that we should
266     // have seen passing through the bus
267     assert(outstandingReq.find(pkt->req) != outstandingReq.end());
268 
269     // remove it as outstanding
270     outstandingReq.erase(pkt->req);
271 
272     // send the packet through the destination slave port
273     bool success M5_VAR_USED = slavePorts[slave_port_id]->sendTimingResp(pkt);
274 
275     // currently it is illegal to block responses... can lead to
276     // deadlock
277     assert(success);
278 
279     respLayers[slave_port_id]->succeededTiming(packetFinishTime);
280 
281     // stats updates
282     dataThroughBus += pkt_size;
283     pktCount[slave_port_id][master_port_id]++;
284     totPktSize[slave_port_id][master_port_id] += pkt_size;
285     transDist[pkt_cmd]++;
286 
287     return true;
288 }
\end{DoxyCode}
\hypertarget{classCoherentBus_a8a06090652319e21031b8bc2f8018e2b}{
\index{CoherentBus@{CoherentBus}!recvTimingSnoopReq@{recvTimingSnoopReq}}
\index{recvTimingSnoopReq@{recvTimingSnoopReq}!CoherentBus@{CoherentBus}}
\subsubsection[{recvTimingSnoopReq}]{\setlength{\rightskip}{0pt plus 5cm}void recvTimingSnoopReq ({\bf PacketPtr} {\em pkt}, \/  {\bf PortID} {\em master\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_a8a06090652319e21031b8bc2f8018e2b}
Function called by the port when the bus is recieving a timing snoop request. 


\begin{DoxyCode}
292 {
293     DPRINTF(CoherentBus, "recvTimingSnoopReq: src %s %s 0x%x\n",
294             masterPorts[master_port_id]->name(), pkt->cmdString(),
295             pkt->getAddr());
296 
297     // update stats here as we know the forwarding will succeed
298     transDist[pkt->cmdToIndex()]++;
299     snoopDataThroughBus += pkt->hasData() ? pkt->getSize() : 0;
300 
301     // we should only see express snoops from caches
302     assert(pkt->isExpressSnoop());
303 
304     // set the source port for routing of the response
305     pkt->setSrc(master_port_id);
306 
307     // forward to all snoopers
308     forwardTiming(pkt, InvalidPortID);
309 
310     // a snoop request came from a connected slave device (one of
311     // our master ports), and if it is not coming from the slave
312     // device responsible for the address range something is
313     // wrong, hence there is nothing further to do as the packet
314     // would be going back to where it came from
315     assert(master_port_id == findPort(pkt->getAddr()));
316 }
\end{DoxyCode}
\hypertarget{classCoherentBus_a29d5427944c6a4e363cf42eb70f480b1}{
\index{CoherentBus@{CoherentBus}!recvTimingSnoopResp@{recvTimingSnoopResp}}
\index{recvTimingSnoopResp@{recvTimingSnoopResp}!CoherentBus@{CoherentBus}}
\subsubsection[{recvTimingSnoopResp}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingSnoopResp ({\bf PacketPtr} {\em pkt}, \/  {\bf PortID} {\em slave\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_a29d5427944c6a4e363cf42eb70f480b1}
Function called by the port when the bus is recieving a timing snoop response. 


\begin{DoxyCode}
320 {
321     // determine the source port based on the id
322     SlavePort* src_port = slavePorts[slave_port_id];
323 
324     // get the destination from the packet
325     PortID dest_port_id = pkt->getDest();
326 
327     // determine if the response is from a snoop request we
328     // created as the result of a normal request (in which case it
329     // should be in the outstandingReq), or if we merely forwarded
330     // someone else's snoop request
331     bool forwardAsSnoop = outstandingReq.find(pkt->req) ==
332         outstandingReq.end();
333 
334     // test if the bus should be considered occupied for the current
335     // port, note that the check is bypassed if the response is being
336     // passed on as a normal response since this is occupying the
337     // response layer rather than the snoop response layer
338     if (forwardAsSnoop) {
339         if (!snoopLayers[dest_port_id]->tryTiming(src_port)) {
340             DPRINTF(CoherentBus, "recvTimingSnoopResp: src %s %s 0x%x BUSY\n",
341                     src_port->name(), pkt->cmdString(), pkt->getAddr());
342             return false;
343         }
344     } else {
345         // get the master port that mirrors this slave port internally
346         MasterPort* snoop_port = snoopRespPorts[slave_port_id];
347         if (!respLayers[dest_port_id]->tryTiming(snoop_port)) {
348             DPRINTF(CoherentBus, "recvTimingSnoopResp: src %s %s 0x%x BUSY\n",
349                     snoop_port->name(), pkt->cmdString(), pkt->getAddr());
350             return false;
351         }
352     }
353 
354     DPRINTF(CoherentBus, "recvTimingSnoopResp: src %s %s 0x%x\n",
355             src_port->name(), pkt->cmdString(), pkt->getAddr());
356 
357     // store size and command as they might be modified when
358     // forwarding the packet
359     unsigned int pkt_size = pkt->hasData() ? pkt->getSize() : 0;
360     unsigned int pkt_cmd = pkt->cmdToIndex();
361 
362     // responses are never express snoops
363     assert(!pkt->isExpressSnoop());
364 
365     calcPacketTiming(pkt);
366     Tick packetFinishTime = pkt->busLastWordDelay + curTick();
367 
368     // forward it either as a snoop response or a normal response
369     if (forwardAsSnoop) {
370         // this is a snoop response to a snoop request we forwarded,
371         // e.g. coming from the L1 and going to the L2, and it should
372         // be forwarded as a snoop response
373         bool success M5_VAR_USED =
374             masterPorts[dest_port_id]->sendTimingSnoopResp(pkt);
375         pktCount[slave_port_id][dest_port_id]++;
376         totPktSize[slave_port_id][dest_port_id] += pkt_size;
377         assert(success);
378 
379         snoopLayers[dest_port_id]->succeededTiming(packetFinishTime);
380     } else {
381         // we got a snoop response on one of our slave ports,
382         // i.e. from a coherent master connected to the bus, and
383         // since we created the snoop request as part of
384         // recvTiming, this should now be a normal response again
385         outstandingReq.erase(pkt->req);
386 
387         // this is a snoop response from a coherent master, with a
388         // destination field set on its way through the bus as
389         // request, hence it should never go back to where the
390         // snoop response came from, but instead to where the
391         // original request came from
392         assert(slave_port_id != dest_port_id);
393 
394         // as a normal response, it should go back to a master through
395         // one of our slave ports, at this point we are ignoring the
396         // fact that the response layer could be busy and do not touch
397         // its state
398         bool success M5_VAR_USED =
399             slavePorts[dest_port_id]->sendTimingResp(pkt);
400 
401         // @todo Put the response in an internal FIFO and pass it on
402         // to the response layer from there
403 
404         // currently it is illegal to block responses... can lead
405         // to deadlock
406         assert(success);
407 
408         respLayers[dest_port_id]->succeededTiming(packetFinishTime);
409     }
410 
411     // stats updates
412     transDist[pkt_cmd]++;
413     snoopDataThroughBus += pkt_size;
414 
415     return true;
416 }
\end{DoxyCode}
\hypertarget{classCoherentBus_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{CoherentBus@{CoherentBus}!regStats@{regStats}}
\index{regStats@{regStats}!CoherentBus@{CoherentBus}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCoherentBus_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} statistics for this object. 

\hyperlink{classBaseBus_a4dc637449366fcdfc4e764cdf12d9b11}{BaseBus}を再定義しています。


\begin{DoxyCode}
650 {
651     // register the stats of the base class and our three bus layers
652     BaseBus::regStats();
653     for (auto l = reqLayers.begin(); l != reqLayers.end(); ++l)
654         (*l)->regStats();
655     for (auto l = respLayers.begin(); l != respLayers.end(); ++l)
656         (*l)->regStats();
657     for (auto l = snoopLayers.begin(); l != snoopLayers.end(); ++l)
658         (*l)->regStats();
659 
660     dataThroughBus
661         .name(name() + ".data_through_bus")
662         .desc("Total data (bytes)")
663         ;
664 
665     snoopDataThroughBus
666         .name(name() + ".snoop_data_through_bus")
667         .desc("Total snoop data (bytes)")
668     ;
669 
670     throughput
671         .name(name() + ".throughput")
672         .desc("Throughput (bytes/s)")
673         .precision(0)
674         ;
675 
676     throughput = (dataThroughBus + snoopDataThroughBus) / simSeconds;
677 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classCoherentBus_a7040fa8d9fb24afb9f4fe245b135da19}{
\index{CoherentBus@{CoherentBus}!dataThroughBus@{dataThroughBus}}
\index{dataThroughBus@{dataThroughBus}!CoherentBus@{CoherentBus}}
\subsubsection[{dataThroughBus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf dataThroughBus}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_a7040fa8d9fb24afb9f4fe245b135da19}
\hypertarget{classCoherentBus_a8b5de6798515d1ac1236592c5ad7c521}{
\index{CoherentBus@{CoherentBus}!outstandingReq@{outstandingReq}}
\index{outstandingReq@{outstandingReq}!CoherentBus@{CoherentBus}}
\subsubsection[{outstandingReq}]{\setlength{\rightskip}{0pt plus 5cm}m5::hash\_\-set$<${\bf RequestPtr}$>$ {\bf outstandingReq}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_a8b5de6798515d1ac1236592c5ad7c521}
Store the outstanding requests so we can determine which ones we generated and which ones were merely forwarded. This is used in the coherent bus when coherency responses come back. \hypertarget{classCoherentBus_ab124575386549f77de080cd9fcaf2ba0}{
\index{CoherentBus@{CoherentBus}!reqLayers@{reqLayers}}
\index{reqLayers@{reqLayers}!CoherentBus@{CoherentBus}}
\subsubsection[{reqLayers}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf ReqLayer}$\ast$$>$ {\bf reqLayers}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_ab124575386549f77de080cd9fcaf2ba0}
\hypertarget{classCoherentBus_a2f42dda70e78f1e5e9574f11b465d173}{
\index{CoherentBus@{CoherentBus}!respLayers@{respLayers}}
\index{respLayers@{respLayers}!CoherentBus@{CoherentBus}}
\subsubsection[{respLayers}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf RespLayer}$\ast$$>$ {\bf respLayers}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_a2f42dda70e78f1e5e9574f11b465d173}
\hypertarget{classCoherentBus_a576c4936ce7bed70cd1751024670e75f}{
\index{CoherentBus@{CoherentBus}!snoopDataThroughBus@{snoopDataThroughBus}}
\index{snoopDataThroughBus@{snoopDataThroughBus}!CoherentBus@{CoherentBus}}
\subsubsection[{snoopDataThroughBus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf snoopDataThroughBus}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_a576c4936ce7bed70cd1751024670e75f}
\hypertarget{classCoherentBus_ae6f8cf70846d8ee4b2314816863efbca}{
\index{CoherentBus@{CoherentBus}!snoopLayers@{snoopLayers}}
\index{snoopLayers@{snoopLayers}!CoherentBus@{CoherentBus}}
\subsubsection[{snoopLayers}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf SnoopLayer}$\ast$$>$ {\bf snoopLayers}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_ae6f8cf70846d8ee4b2314816863efbca}
\hypertarget{classCoherentBus_acdbc947756de5f5071b88ce0702d557d}{
\index{CoherentBus@{CoherentBus}!snoopPorts@{snoopPorts}}
\index{snoopPorts@{snoopPorts}!CoherentBus@{CoherentBus}}
\subsubsection[{snoopPorts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf SlavePort}$\ast$$>$ {\bf snoopPorts}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_acdbc947756de5f5071b88ce0702d557d}
\hypertarget{classCoherentBus_ae876574c554fa099bcd063e2e188b95b}{
\index{CoherentBus@{CoherentBus}!snoopRespPorts@{snoopRespPorts}}
\index{snoopRespPorts@{snoopRespPorts}!CoherentBus@{CoherentBus}}
\subsubsection[{snoopRespPorts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf SnoopRespPort}$\ast$$>$ {\bf snoopRespPorts}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_ae876574c554fa099bcd063e2e188b95b}
\hypertarget{classCoherentBus_af27ccd765f13a4b7bd119dc7579e2746}{
\index{CoherentBus@{CoherentBus}!system@{system}}
\index{system@{system}!CoherentBus@{CoherentBus}}
\subsubsection[{system}]{\setlength{\rightskip}{0pt plus 5cm}{\bf System}$\ast$ {\bf system}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCoherentBus_af27ccd765f13a4b7bd119dc7579e2746}
Keep a pointer to the system to be allow to querying memory system properties. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{coherent__bus_8hh}{coherent\_\-bus.hh}\item 
mem/\hyperlink{coherent__bus_8cc}{coherent\_\-bus.cc}\end{DoxyCompactItemize}
