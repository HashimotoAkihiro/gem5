<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>File&nbsp;GEM5&nbsp;Wrapper: クラス MetaSimObject</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- 作成： Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>メインページ</span></a></li>
      <li><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>構成</span></a></li>
      <li><a href="classes.html"><span>構成索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>構成メンバ</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacem5.html">m5</a>::<a class="el" href="namespacem5_1_1SimObject.html">SimObject</a>::<a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html">MetaSimObject</a>
  </div>
</div>
<div class="contents">
<h1>クラス MetaSimObject</h1><!-- doxytag: class="m5::SimObject::MetaSimObject" -->
<p><a href="classm5_1_1SimObject_1_1MetaSimObject-members.html">すべてのメンバ一覧</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#a2f15a4676204349e06bcced484b06b70">__new__</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#ac775ee34451fdfa742b318538164070e">__init__</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#a6287b7a16286568d5442b6e2e90215b5">__setattr__</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#a0a990b3ec3889d40889daca9ee5e4695">__getattr__</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#aa7a4b9bc0941308e362738503137460e">__str__</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#a0b408a11a14bd1d770e28f71a6e14ab5">cxx_predecls</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#ab3dbcf5716623eac67a8ccc074fa7e13">swig_predecls</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#ab373c5eaef9a7b80491a097389260f4a">export_methods</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#a4c94af862ca1bc3ebde2094d5e778ef1">export_method_cxx_predecls</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#ac19f60f4d41b7b37c7f282db24e5d743">export_method_swig_predecls</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#a83526365333b680bfcbd9b037527cc25">swig_decl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#af533aa789436bfde5727387a36ca9178">cxx_param_decl</a></td></tr>
<tr><td colspan="2"><h2>Static Public 変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dictionary&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#a608ecb4a2947d6894ab9594d7f59f0a8">init_keywords</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dictionary&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#a834325b701200b492fc4d7422529cc70">keywords</a> = { 'check' : FunctionType }</td></tr>
<tr><td colspan="2"><h2>Private メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#a5abb9e05651c6ebea8a449d8b9f631da">_set_keyword</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#ac8e49572c0c90b02af544331ef1fe28c">_new_param</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#ad9738835519febeb368f901e6185df14">_set_param</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#a0d41fdb3a505fbc4c37db240d67c1140">_add_cls_child</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#a6490df0f3d3befd9c38994fa46520f70">_new_port</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#aed37f2662342d9fb731fb7b3454eda7f">_cls_get_port_ref</a></td></tr>
</table>
<hr/><h2>関数</h2>
<a class="anchor" id="a0a990b3ec3889d40889daca9ee5e4695"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::__getattr__" ref="a0a990b3ec3889d40889daca9ee5e4695" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __getattr__ </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>attr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00360"></a><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#a0a990b3ec3889d40889daca9ee5e4695">00360</a>                               :
<a name="l00361"></a>00361         <span class="keywordflow">if</span> attr == <span class="stringliteral">&apos;cxx_class_path&apos;</span>:
<a name="l00362"></a>00362             <span class="keywordflow">return</span> cls.cxx_class.split(<span class="stringliteral">&apos;::&apos;</span>)
<a name="l00363"></a>00363 
<a name="l00364"></a>00364         <span class="keywordflow">if</span> attr == <span class="stringliteral">&apos;cxx_class_name&apos;</span>:
<a name="l00365"></a>00365             <span class="keywordflow">return</span> cls.cxx_class_path[-1]
<a name="l00366"></a>00366 
<a name="l00367"></a>00367         <span class="keywordflow">if</span> attr == <span class="stringliteral">&apos;cxx_namespaces&apos;</span>:
<a name="l00368"></a>00368             <span class="keywordflow">return</span> cls.cxx_class_path[:-1]
<a name="l00369"></a>00369 
<a name="l00370"></a>00370         <span class="keywordflow">if</span> cls._values.has_key(attr):
<a name="l00371"></a>00371             <span class="keywordflow">return</span> cls._values[attr]
<a name="l00372"></a>00372 
<a name="l00373"></a>00373         <span class="keywordflow">if</span> cls._children.has_key(attr):
<a name="l00374"></a>00374             <span class="keywordflow">return</span> cls._children[attr]
<a name="l00375"></a>00375 
<a name="l00376"></a>00376         <span class="keywordflow">raise</span> AttributeError, \
<a name="l00377"></a>00377               <span class="stringliteral">&quot;object &apos;%s&apos; has no attribute &apos;%s&apos;&quot;</span> % (cls.__name__, attr)
<a name="l00378"></a>00378 
    <span class="keyword">def </span><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#aa7a4b9bc0941308e362738503137460e">__str__</a>(cls):
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac775ee34451fdfa742b318538164070e"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::__init__" ref="ac775ee34451fdfa742b318538164070e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __init__ </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>dict</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00171"></a><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#ac775ee34451fdfa742b318538164070e">00171</a>                                         :
<a name="l00172"></a>00172         <span class="comment"># calls type.__init__()... I think that&apos;s a no-op, but leave</span>
<a name="l00173"></a>00173         <span class="comment"># it here just in case it&apos;s not.</span>
<a name="l00174"></a>00174         super(MetaSimObject, cls).__init__(name, bases, dict)
<a name="l00175"></a>00175 
<a name="l00176"></a>00176         <span class="comment"># initialize required attributes</span>
<a name="l00177"></a>00177 
<a name="l00178"></a>00178         <span class="comment"># class-only attributes</span>
<a name="l00179"></a>00179         cls._params = multidict() <span class="comment"># param descriptions</span>
<a name="l00180"></a>00180         cls._ports = multidict()  <span class="comment"># port descriptions</span>
<a name="l00181"></a>00181 
<a name="l00182"></a>00182         <span class="comment"># class or instance attributes</span>
<a name="l00183"></a>00183         cls._values = multidict()   <span class="comment"># param values</span>
<a name="l00184"></a>00184         cls._children = multidict() <span class="comment"># SimObject children</span>
<a name="l00185"></a>00185         cls._port_refs = multidict() <span class="comment"># port ref objects</span>
<a name="l00186"></a>00186         cls._instantiated = <span class="keyword">False</span> <span class="comment"># really instantiated, cloned, or subclassed</span>
<a name="l00187"></a>00187 
<a name="l00188"></a>00188         <span class="comment"># We don&apos;t support multiple inheritance of sim objects.  If you want</span>
<a name="l00189"></a>00189         <span class="comment"># to, you must fix multidict to deal with it properly. Non sim-objects</span>
<a name="l00190"></a>00190         <span class="comment"># are ok, though</span>
<a name="l00191"></a>00191         bTotal = 0
<a name="l00192"></a>00192         <span class="keywordflow">for</span> c <span class="keywordflow">in</span> bases:
<a name="l00193"></a>00193             <span class="keywordflow">if</span> isinstance(c, MetaSimObject):
<a name="l00194"></a>00194                 bTotal += 1
<a name="l00195"></a>00195             <span class="keywordflow">if</span> bTotal &gt; 1:
<a name="l00196"></a>00196                 <span class="keywordflow">raise</span> TypeError, <span class="stringliteral">&quot;SimObjects do not support multiple inheritance&quot;</span>
<a name="l00197"></a>00197 
<a name="l00198"></a>00198         base = bases[0]
<a name="l00199"></a>00199 
<a name="l00200"></a>00200         <span class="comment"># Set up general inheritance via multidicts.  A subclass will</span>
<a name="l00201"></a>00201         <span class="comment"># inherit all its settings from the base class.  The only time</span>
<a name="l00202"></a>00202         <span class="comment"># the following is not true is when we define the SimObject</span>
<a name="l00203"></a>00203         <span class="comment"># class itself (in which case the multidicts have no parent).</span>
<a name="l00204"></a>00204         <span class="keywordflow">if</span> isinstance(base, MetaSimObject):
<a name="l00205"></a>00205             cls._base = base
<a name="l00206"></a>00206             cls._params.parent = base._params
<a name="l00207"></a>00207             cls._ports.parent = base._ports
<a name="l00208"></a>00208             cls._values.parent = base._values
<a name="l00209"></a>00209             cls._children.parent = base._children
<a name="l00210"></a>00210             cls._port_refs.parent = base._port_refs
<a name="l00211"></a>00211             <span class="comment"># mark base as having been subclassed</span>
<a name="l00212"></a>00212             base._instantiated = <span class="keyword">True</span>
<a name="l00213"></a>00213         <span class="keywordflow">else</span>:
<a name="l00214"></a>00214             cls._base = <span class="keywordtype">None</span>
<a name="l00215"></a>00215 
<a name="l00216"></a>00216         <span class="comment"># default keyword values</span>
<a name="l00217"></a>00217         <span class="keywordflow">if</span> <span class="stringliteral">&apos;type&apos;</span> <span class="keywordflow">in</span> cls._value_dict:
<a name="l00218"></a>00218             <span class="keywordflow">if</span> <span class="stringliteral">&apos;cxx_class&apos;</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> cls._value_dict:
<a name="l00219"></a>00219                 cls._value_dict[<span class="stringliteral">&apos;cxx_class&apos;</span>] = cls._value_dict[<span class="stringliteral">&apos;type&apos;</span>]
<a name="l00220"></a>00220 
<a name="l00221"></a>00221             cls._value_dict[<span class="stringliteral">&apos;cxx_type&apos;</span>] = <span class="stringliteral">&apos;%s *&apos;</span> % cls._value_dict[<span class="stringliteral">&apos;cxx_class&apos;</span>]
<a name="l00222"></a>00222 
<a name="l00223"></a>00223             <span class="keywordflow">if</span> <span class="stringliteral">&apos;cxx_header&apos;</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> cls._value_dict:
<a name="l00224"></a>00224                 <span class="keyword">global</span> noCxxHeader
<a name="l00225"></a>00225                 noCxxHeader = <span class="keyword">True</span>
<a name="l00226"></a>00226                 warn(<span class="stringliteral">&quot;No header file specified for SimObject: %s&quot;</span>, name)
<a name="l00227"></a>00227 
<a name="l00228"></a>00228         <span class="comment"># Export methods are automatically inherited via C++, so we</span>
<a name="l00229"></a>00229         <span class="comment"># don&apos;t want the method declarations to get inherited on the</span>
<a name="l00230"></a>00230         <span class="comment"># python side (and thus end up getting repeated in the wrapped</span>
<a name="l00231"></a>00231         <span class="comment"># versions of derived classes).  The code below basicallly</span>
<a name="l00232"></a>00232         <span class="comment"># suppresses inheritance by substituting in the base (null)</span>
<a name="l00233"></a>00233         <span class="comment"># versions of these methods unless a different version is</span>
<a name="l00234"></a>00234         <span class="comment"># explicitly supplied.</span>
<a name="l00235"></a>00235         <span class="keywordflow">for</span> method_name <span class="keywordflow">in</span> (<span class="stringliteral">&apos;export_methods&apos;</span>, <span class="stringliteral">&apos;export_method_cxx_predecls&apos;</span>,
<a name="l00236"></a>00236                             <span class="stringliteral">&apos;export_method_swig_predecls&apos;</span>):
<a name="l00237"></a>00237             <span class="keywordflow">if</span> method_name <span class="keywordflow">not</span> <span class="keywordflow">in</span> cls.__dict__:
<a name="l00238"></a>00238                 base_method = getattr(MetaSimObject, method_name)
<a name="l00239"></a>00239                 m = MethodType(base_method, cls, MetaSimObject)
<a name="l00240"></a>00240                 setattr(cls, method_name, m)
<a name="l00241"></a>00241 
<a name="l00242"></a>00242         <span class="comment"># Now process the _value_dict items.  They could be defining</span>
<a name="l00243"></a>00243         <span class="comment"># new (or overriding existing) parameters or ports, setting</span>
<a name="l00244"></a>00244         <span class="comment"># class keywords (e.g., &apos;abstract&apos;), or setting parameter</span>
<a name="l00245"></a>00245         <span class="comment"># values or port bindings.  The first 3 can only be set when</span>
<a name="l00246"></a>00246         <span class="comment"># the class is defined, so we handle them here.  The others</span>
<a name="l00247"></a>00247         <span class="comment"># can be set later too, so just emulate that by calling</span>
<a name="l00248"></a>00248         <span class="comment"># setattr().</span>
<a name="l00249"></a>00249         <span class="keywordflow">for</span> key,val <span class="keywordflow">in</span> cls._value_dict.items():
<a name="l00250"></a>00250             <span class="comment"># param descriptions</span>
<a name="l00251"></a>00251             <span class="keywordflow">if</span> isinstance(val, ParamDesc):
<a name="l00252"></a>00252                 cls._new_param(key, val)
<a name="l00253"></a>00253 
<a name="l00254"></a>00254             <span class="comment"># port objects</span>
<a name="l00255"></a>00255             <span class="keywordflow">elif</span> isinstance(val, Port):
<a name="l00256"></a>00256                 cls._new_port(key, val)
<a name="l00257"></a>00257 
<a name="l00258"></a>00258             <span class="comment"># init-time-only keywords</span>
<a name="l00259"></a>00259             <span class="keywordflow">elif</span> cls.init_keywords.has_key(key):
<a name="l00260"></a>00260                 cls._set_keyword(key, val, cls.init_keywords[key])
<a name="l00261"></a>00261 
<a name="l00262"></a>00262             <span class="comment"># default: use normal path (ends up in __setattr__)</span>
<a name="l00263"></a>00263             <span class="keywordflow">else</span>:
<a name="l00264"></a>00264                 setattr(cls, key, val)
<a name="l00265"></a>00265 
    <span class="keyword">def </span><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#a5abb9e05651c6ebea8a449d8b9f631da">_set_keyword</a>(cls, keyword, val, kwtype):
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2f15a4676204349e06bcced484b06b70"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::__new__" ref="a2f15a4676204349e06bcced484b06b70" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __new__ </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>mcls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>dict</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00146"></a><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#a2f15a4676204349e06bcced484b06b70">00146</a>                                         :
<a name="l00147"></a>00147         <span class="keyword">assert</span> name <span class="keywordflow">not</span> <span class="keywordflow">in</span> allClasses, <span class="stringliteral">&quot;SimObject %s already present&quot;</span> % name
<a name="l00148"></a>00148 
<a name="l00149"></a>00149         <span class="comment"># Copy &quot;private&quot; attributes, functions, and classes to the</span>
<a name="l00150"></a>00150         <span class="comment"># official dict.  Everything else goes in _init_dict to be</span>
<a name="l00151"></a>00151         <span class="comment"># filtered in __init__.</span>
<a name="l00152"></a>00152         cls_dict = {}
<a name="l00153"></a>00153         value_dict = {}
<a name="l00154"></a>00154         <span class="keywordflow">for</span> key,val <span class="keywordflow">in</span> dict.items():
<a name="l00155"></a>00155             <span class="keywordflow">if</span> public_value(key, val):
<a name="l00156"></a>00156                 cls_dict[key] = val
<a name="l00157"></a>00157             <span class="keywordflow">else</span>:
<a name="l00158"></a>00158                 <span class="comment"># must be a param/port setting</span>
<a name="l00159"></a>00159                 value_dict[key] = val
<a name="l00160"></a>00160         <span class="keywordflow">if</span> <span class="stringliteral">&apos;abstract&apos;</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> value_dict:
<a name="l00161"></a>00161             value_dict[<span class="stringliteral">&apos;abstract&apos;</span>] = <span class="keyword">False</span>
<a name="l00162"></a>00162         <span class="keywordflow">if</span> <span class="stringliteral">&apos;cxx_bases&apos;</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> value_dict:
<a name="l00163"></a>00163             value_dict[<span class="stringliteral">&apos;cxx_bases&apos;</span>] = []
<a name="l00164"></a>00164         cls_dict[<span class="stringliteral">&apos;_value_dict&apos;</span>] = value_dict
<a name="l00165"></a>00165         cls = super(MetaSimObject, mcls).__new__(mcls, name, bases, cls_dict)
<a name="l00166"></a>00166         <span class="keywordflow">if</span> <span class="stringliteral">&apos;type&apos;</span> <span class="keywordflow">in</span> value_dict:
<a name="l00167"></a>00167             allClasses[name] = cls
<a name="l00168"></a>00168         <span class="keywordflow">return</span> cls
<a name="l00169"></a>00169 
<a name="l00170"></a>00170     <span class="comment"># subclass initialization</span>
    <span class="keyword">def </span><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#ac775ee34451fdfa742b318538164070e">__init__</a>(cls, name, bases, dict):
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6287b7a16286568d5442b6e2e90215b5"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::__setattr__" ref="a6287b7a16286568d5442b6e2e90215b5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __setattr__ </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00325"></a><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#a6287b7a16286568d5442b6e2e90215b5">00325</a>                                      :
<a name="l00326"></a>00326         <span class="comment"># normal processing for private attributes</span>
<a name="l00327"></a>00327         <span class="keywordflow">if</span> public_value(attr, value):
<a name="l00328"></a>00328             type.__setattr__(cls, attr, value)
<a name="l00329"></a>00329             <span class="keywordflow">return</span>
<a name="l00330"></a>00330 
<a name="l00331"></a>00331         <span class="keywordflow">if</span> cls.keywords.has_key(attr):
<a name="l00332"></a>00332             cls._set_keyword(attr, value, cls.keywords[attr])
<a name="l00333"></a>00333             <span class="keywordflow">return</span>
<a name="l00334"></a>00334 
<a name="l00335"></a>00335         <span class="keywordflow">if</span> cls._ports.has_key(attr):
<a name="l00336"></a>00336             cls._cls_get_port_ref(attr).connect(value)
<a name="l00337"></a>00337             <span class="keywordflow">return</span>
<a name="l00338"></a>00338 
<a name="l00339"></a>00339         <span class="keywordflow">if</span> isSimObjectOrSequence(value) <span class="keywordflow">and</span> cls._instantiated:
<a name="l00340"></a>00340             <span class="keywordflow">raise</span> RuntimeError, \
<a name="l00341"></a>00341                   <span class="stringliteral">&quot;cannot set SimObject parameter &apos;%s&apos; after\n&quot;</span> \
<a name="l00342"></a>00342                   <span class="stringliteral">&quot;    class %s has been instantiated or subclassed&quot;</span> \
<a name="l00343"></a>00343                   % (attr, cls.__name__)
<a name="l00344"></a>00344 
<a name="l00345"></a>00345         <span class="comment"># check for param</span>
<a name="l00346"></a>00346         param = cls._params.get(attr)
<a name="l00347"></a>00347         <span class="keywordflow">if</span> param:
<a name="l00348"></a>00348             cls._set_param(attr, value, param)
<a name="l00349"></a>00349             <span class="keywordflow">return</span>
<a name="l00350"></a>00350 
<a name="l00351"></a>00351         <span class="keywordflow">if</span> isSimObjectOrSequence(value):
<a name="l00352"></a>00352             <span class="comment"># If RHS is a SimObject, it&apos;s an implicit child assignment.</span>
<a name="l00353"></a>00353             cls._add_cls_child(attr, coerceSimObjectOrVector(value))
<a name="l00354"></a>00354             <span class="keywordflow">return</span>
<a name="l00355"></a>00355 
<a name="l00356"></a>00356         <span class="comment"># no valid assignment... raise exception</span>
<a name="l00357"></a>00357         <span class="keywordflow">raise</span> AttributeError, \
<a name="l00358"></a>00358               <span class="stringliteral">&quot;Class %s has no parameter \&apos;%s\&apos;&quot;</span> % (cls.__name__, attr)
<a name="l00359"></a>00359 
    <span class="keyword">def </span><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#a0a990b3ec3889d40889daca9ee5e4695">__getattr__</a>(cls, attr):
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa7a4b9bc0941308e362738503137460e"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::__str__" ref="aa7a4b9bc0941308e362738503137460e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __str__ </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cls</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00379"></a><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#aa7a4b9bc0941308e362738503137460e">00379</a>                     :
<a name="l00380"></a>00380         <span class="keywordflow">return</span> cls.__name__
<a name="l00381"></a>00381 
<a name="l00382"></a>00382     <span class="comment"># See ParamValue.cxx_predecls for description.</span>
    <span class="keyword">def </span><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#a0b408a11a14bd1d770e28f71a6e14ab5">cxx_predecls</a>(cls, code):
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0d41fdb3a505fbc4c37db240d67c1140"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::_add_cls_child" ref="a0d41fdb3a505fbc4c37db240d67c1140" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def _add_cls_child </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>child</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00297"></a><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#a0d41fdb3a505fbc4c37db240d67c1140">00297</a>                                         :
<a name="l00298"></a>00298         <span class="comment"># It&apos;s a little funky to have a class as a parent, but these</span>
<a name="l00299"></a>00299         <span class="comment"># objects should never be instantiated (only cloned, which</span>
<a name="l00300"></a>00300         <span class="comment"># clears the parent pointer), and this makes it clear that the</span>
<a name="l00301"></a>00301         <span class="comment"># object is not an orphan and can provide better error</span>
<a name="l00302"></a>00302         <span class="comment"># messages.</span>
<a name="l00303"></a>00303         child.set_parent(cls, name)
<a name="l00304"></a>00304         cls._children[name] = child
<a name="l00305"></a>00305 
    <span class="keyword">def </span><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#a6490df0f3d3befd9c38994fa46520f70">_new_port</a>(cls, name, port):
</pre></div></p>

</div>
</div>
<a class="anchor" id="aed37f2662342d9fb731fb7b3454eda7f"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::_cls_get_port_ref" ref="aed37f2662342d9fb731fb7b3454eda7f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def _cls_get_port_ref </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>attr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00313"></a><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#aed37f2662342d9fb731fb7b3454eda7f">00313</a>                                     :
<a name="l00314"></a>00314         <span class="comment"># Return reference that can be assigned to another port</span>
<a name="l00315"></a>00315         <span class="comment"># via __setattr__.  There is only ever one reference</span>
<a name="l00316"></a>00316         <span class="comment"># object per port, but we create them lazily here.</span>
<a name="l00317"></a>00317         ref = cls._port_refs.get(attr)
<a name="l00318"></a>00318         <span class="keywordflow">if</span> <span class="keywordflow">not</span> ref:
<a name="l00319"></a>00319             ref = cls._ports[attr].makeRef(cls)
<a name="l00320"></a>00320             cls._port_refs[attr] = ref
<a name="l00321"></a>00321         <span class="keywordflow">return</span> ref
<a name="l00322"></a>00322 
<a name="l00323"></a>00323     <span class="comment"># Set attribute (called on foo.attr = value when foo is an</span>
<a name="l00324"></a>00324     <span class="comment"># instance of class cls).</span>
    <span class="keyword">def </span><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#a6287b7a16286568d5442b6e2e90215b5">__setattr__</a>(cls, attr, value):
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac8e49572c0c90b02af544331ef1fe28c"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::_new_param" ref="ac8e49572c0c90b02af544331ef1fe28c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def _new_param </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>pdesc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00274"></a><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#ac8e49572c0c90b02af544331ef1fe28c">00274</a>                                     :
<a name="l00275"></a>00275         <span class="comment"># each param desc should be uniquely assigned to one variable</span>
<a name="l00276"></a>00276         <span class="keyword">assert</span>(<span class="keywordflow">not</span> hasattr(pdesc, <span class="stringliteral">&apos;name&apos;</span>))
<a name="l00277"></a>00277         pdesc.name = name
<a name="l00278"></a>00278         cls._params[name] = pdesc
<a name="l00279"></a>00279         <span class="keywordflow">if</span> hasattr(pdesc, <span class="stringliteral">&apos;default&apos;</span>):
<a name="l00280"></a>00280             cls._set_param(name, pdesc.default, pdesc)
<a name="l00281"></a>00281 
    <span class="keyword">def </span><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#ad9738835519febeb368f901e6185df14">_set_param</a>(cls, name, value, param):
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6490df0f3d3befd9c38994fa46520f70"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::_new_port" ref="a6490df0f3d3befd9c38994fa46520f70" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def _new_port </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00306"></a><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#a6490df0f3d3befd9c38994fa46520f70">00306</a>                                   :
<a name="l00307"></a>00307         <span class="comment"># each port should be uniquely assigned to one variable</span>
<a name="l00308"></a>00308         <span class="keyword">assert</span>(<span class="keywordflow">not</span> hasattr(port, <span class="stringliteral">&apos;name&apos;</span>))
<a name="l00309"></a>00309         port.name = name
<a name="l00310"></a>00310         cls._ports[name] = port
<a name="l00311"></a>00311 
<a name="l00312"></a>00312     <span class="comment"># same as _get_port_ref, effectively, but for classes</span>
    <span class="keyword">def </span><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#aed37f2662342d9fb731fb7b3454eda7f">_cls_get_port_ref</a>(cls, attr):
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5abb9e05651c6ebea8a449d8b9f631da"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::_set_keyword" ref="a5abb9e05651c6ebea8a449d8b9f631da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def _set_keyword </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>kwtype</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00266"></a><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#a5abb9e05651c6ebea8a449d8b9f631da">00266</a>                                                :
<a name="l00267"></a>00267         <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(val, kwtype):
<a name="l00268"></a>00268             <span class="keywordflow">raise</span> TypeError, <span class="stringliteral">&apos;keyword %s has bad type %s (expecting %s)&apos;</span> % \
<a name="l00269"></a>00269                   (keyword, type(val), kwtype)
<a name="l00270"></a>00270         <span class="keywordflow">if</span> isinstance(val, FunctionType):
<a name="l00271"></a>00271             val = classmethod(val)
<a name="l00272"></a>00272         type.__setattr__(cls, keyword, val)
<a name="l00273"></a>00273 
    <span class="keyword">def </span><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#ac8e49572c0c90b02af544331ef1fe28c">_new_param</a>(cls, name, pdesc):
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad9738835519febeb368f901e6185df14"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::_set_param" ref="ad9738835519febeb368f901e6185df14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def _set_param </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>param</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00282"></a><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#ad9738835519febeb368f901e6185df14">00282</a>                                            :
<a name="l00283"></a>00283         <span class="keyword">assert</span>(param.name == name)
<a name="l00284"></a>00284         <span class="keywordflow">try</span>:
<a name="l00285"></a>00285             value = param.convert(value)
<a name="l00286"></a>00286         <span class="keywordflow">except</span> Exception, e:
<a name="l00287"></a>00287             msg = <span class="stringliteral">&quot;%s\nError setting param %s.%s to %s\n&quot;</span> % \
<a name="l00288"></a>00288                   (e, cls.__name__, name, value)
<a name="l00289"></a>00289             e.args = (msg, )
<a name="l00290"></a>00290             <span class="keywordflow">raise</span>
<a name="l00291"></a>00291         cls._values[name] = value
<a name="l00292"></a>00292         <span class="comment"># if param value is a SimObject, make it a child too, so that</span>
<a name="l00293"></a>00293         <span class="comment"># it gets cloned properly when the class is instantiated</span>
<a name="l00294"></a>00294         <span class="keywordflow">if</span> isSimObjectOrVector(value) <span class="keywordflow">and</span> <span class="keywordflow">not</span> value.has_parent():
<a name="l00295"></a>00295             cls._add_cls_child(name, value)
<a name="l00296"></a>00296 
    <span class="keyword">def </span><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#a0d41fdb3a505fbc4c37db240d67c1140">_add_cls_child</a>(cls, name, child):
</pre></div></p>

</div>
</div>
<a class="anchor" id="af533aa789436bfde5727387a36ca9178"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::cxx_param_decl" ref="af533aa789436bfde5727387a36ca9178" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def cxx_param_decl </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>code</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00499"></a><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#af533aa789436bfde5727387a36ca9178">00499</a>                                  :
<a name="l00500"></a>00500         <span class="comment"># The &apos;local&apos; attribute restricts us to the params declared in</span>
<a name="l00501"></a>00501         <span class="comment"># the object itself, not including inherited params (which</span>
<a name="l00502"></a>00502         <span class="comment"># will also be inherited from the base class&apos;s param struct</span>
<a name="l00503"></a>00503         <span class="comment"># here).</span>
<a name="l00504"></a>00504         params = cls._params.local.values()
<a name="l00505"></a>00505         ports = cls._ports.local
<a name="l00506"></a>00506         <span class="keywordflow">try</span>:
<a name="l00507"></a>00507             ptypes = [p.ptype <span class="keywordflow">for</span> p <span class="keywordflow">in</span> params]
<a name="l00508"></a>00508         <span class="keywordflow">except</span>:
<a name="l00509"></a>00509             <span class="keywordflow">print</span> cls, p, p.ptype_str
<a name="l00510"></a>00510             <span class="keywordflow">print</span> params
<a name="l00511"></a>00511             <span class="keywordflow">raise</span>
<a name="l00512"></a>00512 
<a name="l00513"></a>00513         class_path = cls._value_dict[<span class="stringliteral">&apos;cxx_class&apos;</span>].split(<span class="stringliteral">&apos;::&apos;</span>)
<a name="l00514"></a>00514 
<a name="l00515"></a>00515         code(<span class="stringliteral">&apos;&apos;&apos;\</span>
<a name="l00516"></a>00516 <span class="stringliteral">#ifndef __PARAMS__${cls}__</span>
<a name="l00517"></a>00517 <span class="stringliteral">#define __PARAMS__${cls}__</span>
<a name="l00518"></a>00518 <span class="stringliteral"></span>
<a name="l00519"></a>00519 <span class="stringliteral">&apos;&apos;&apos;</span>)
<a name="l00520"></a>00520 
<a name="l00521"></a>00521         <span class="comment"># A forward class declaration is sufficient since we are just</span>
<a name="l00522"></a>00522         <span class="comment"># declaring a pointer.</span>
<a name="l00523"></a>00523         <span class="keywordflow">for</span> ns <span class="keywordflow">in</span> class_path[:-1]:
<a name="l00524"></a>00524             code(<span class="stringliteral">&apos;namespace $ns {&apos;</span>)
<a name="l00525"></a>00525         code(<span class="stringliteral">&apos;class $0;&apos;</span>, class_path[-1])
<a name="l00526"></a>00526         <span class="keywordflow">for</span> ns <span class="keywordflow">in</span> reversed(class_path[:-1]):
<a name="l00527"></a>00527             code(<span class="stringliteral">&apos;} // namespace $ns&apos;</span>)
<a name="l00528"></a>00528         code()
<a name="l00529"></a>00529 
<a name="l00530"></a>00530         <span class="comment"># The base SimObject has a couple of params that get</span>
<a name="l00531"></a>00531         <span class="comment"># automatically set from Python without being declared through</span>
<a name="l00532"></a>00532         <span class="comment"># the normal Param mechanism; we slip them in here (needed</span>
<a name="l00533"></a>00533         <span class="comment"># predecls now, actual declarations below)</span>
<a name="l00534"></a>00534         <span class="keywordflow">if</span> cls == SimObject:
<a name="l00535"></a>00535             code(<span class="stringliteral">&apos;&apos;&apos;</span>
<a name="l00536"></a>00536 <span class="stringliteral">#ifndef PY_VERSION</span>
<a name="l00537"></a>00537 <span class="stringliteral">struct PyObject;</span>
<a name="l00538"></a>00538 <span class="stringliteral">#endif</span>
<a name="l00539"></a>00539 <span class="stringliteral"></span>
<a name="l00540"></a>00540 <span class="stringliteral">#include &lt;string&gt;</span>
<a name="l00541"></a>00541 <span class="stringliteral">&apos;&apos;&apos;</span>)
<a name="l00542"></a>00542         <span class="keywordflow">for</span> param <span class="keywordflow">in</span> params:
<a name="l00543"></a>00543             param.cxx_predecls(code)
<a name="l00544"></a>00544         <span class="keywordflow">for</span> port <span class="keywordflow">in</span> ports.itervalues():
<a name="l00545"></a>00545             port.cxx_predecls(code)
<a name="l00546"></a>00546         code()
<a name="l00547"></a>00547 
<a name="l00548"></a>00548         <span class="keywordflow">if</span> cls._base:
<a name="l00549"></a>00549             code(<span class="stringliteral">&apos;#include &quot;params/${{cls._base.type}}.hh&quot;&apos;</span>)
<a name="l00550"></a>00550             code()
<a name="l00551"></a>00551 
<a name="l00552"></a>00552         <span class="keywordflow">for</span> ptype <span class="keywordflow">in</span> ptypes:
<a name="l00553"></a>00553             <span class="keywordflow">if</span> issubclass(ptype, Enum):
<a name="l00554"></a>00554                 code(<span class="stringliteral">&apos;#include &quot;enums/${{ptype.__name__}}.hh&quot;&apos;</span>)
<a name="l00555"></a>00555                 code()
<a name="l00556"></a>00556 
<a name="l00557"></a>00557         <span class="comment"># now generate the actual param struct</span>
<a name="l00558"></a>00558         code(<span class="stringliteral">&quot;struct ${cls}Params&quot;</span>)
<a name="l00559"></a>00559         <span class="keywordflow">if</span> cls._base:
<a name="l00560"></a>00560             code(<span class="stringliteral">&quot;    : public ${{cls._base.type}}Params&quot;</span>)
<a name="l00561"></a>00561         code(<span class="stringliteral">&quot;{&quot;</span>)
<a name="l00562"></a>00562         <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(cls, <span class="stringliteral">&apos;abstract&apos;</span>) <span class="keywordflow">or</span> <span class="keywordflow">not</span> cls.abstract:
<a name="l00563"></a>00563             <span class="keywordflow">if</span> <span class="stringliteral">&apos;type&apos;</span> <span class="keywordflow">in</span> cls.__dict__:
<a name="l00564"></a>00564                 code(<span class="stringliteral">&quot;    ${{cls.cxx_type}} create();&quot;</span>)
<a name="l00565"></a>00565 
<a name="l00566"></a>00566         code.indent()
<a name="l00567"></a>00567         <span class="keywordflow">if</span> cls == SimObject:
<a name="l00568"></a>00568             code(<span class="stringliteral">&apos;&apos;&apos;</span>
<a name="l00569"></a>00569 <span class="stringliteral">    SimObjectParams() {}</span>
<a name="l00570"></a>00570 <span class="stringliteral">    virtual ~SimObjectParams() {}</span>
<a name="l00571"></a>00571 <span class="stringliteral"></span>
<a name="l00572"></a>00572 <span class="stringliteral">    std::string name;</span>
<a name="l00573"></a>00573 <span class="stringliteral">    PyObject *pyobj;</span>
<a name="l00574"></a>00574 <span class="stringliteral">            &apos;&apos;&apos;</span>)
<a name="l00575"></a>00575         <span class="keywordflow">for</span> param <span class="keywordflow">in</span> params:
<a name="l00576"></a>00576             param.cxx_decl(code)
<a name="l00577"></a>00577         <span class="keywordflow">for</span> port <span class="keywordflow">in</span> ports.itervalues():
<a name="l00578"></a>00578             port.cxx_decl(code)
<a name="l00579"></a>00579 
<a name="l00580"></a>00580         code.dedent()
<a name="l00581"></a>00581         code(<span class="stringliteral">&apos;};&apos;</span>)
<a name="l00582"></a>00582 
<a name="l00583"></a>00583         code()
<a name="l00584"></a>00584         code(<span class="stringliteral">&apos;#endif // __PARAMS__${cls}__&apos;</span>)
<a name="l00585"></a>00585         <span class="keywordflow">return</span> code
<a name="l00586"></a>00586 
<a name="l00587"></a>00587 
<a name="l00588"></a>00588 <span class="comment"># This *temporary* definition is required to support calls from the</span>
<a name="l00589"></a>00589 <span class="comment"># SimObject class definition to the MetaSimObject methods (in</span>
<a name="l00590"></a>00590 <span class="comment"># particular _set_param, which gets called for parameters with default</span>
<a name="l00591"></a>00591 <span class="comment"># values defined on the SimObject class itself).  It will get</span>
<a name="l00592"></a>00592 <span class="comment"># overridden by the permanent definition (which requires that</span>
<a name="l00593"></a>00593 <span class="comment"># SimObject be defined) lower in this file.</span>
<span class="keyword">def </span><a class="code" href="namespacem5_1_1SimObject.html#a1679f62df3bf4fec72ee979c969a01ac">isSimObjectOrVector</a>(value):
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0b408a11a14bd1d770e28f71a6e14ab5"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::cxx_predecls" ref="a0b408a11a14bd1d770e28f71a6e14ab5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def cxx_predecls </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>code</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00383"></a><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#a0b408a11a14bd1d770e28f71a6e14ab5">00383</a>                                :
<a name="l00384"></a>00384         code(<span class="stringliteral">&apos;#include &quot;params/$cls.hh&quot;&apos;</span>)
<a name="l00385"></a>00385 
<a name="l00386"></a>00386     <span class="comment"># See ParamValue.swig_predecls for description.</span>
    <span class="keyword">def </span><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#ab3dbcf5716623eac67a8ccc074fa7e13">swig_predecls</a>(cls, code):
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4c94af862ca1bc3ebde2094d5e778ef1"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::export_method_cxx_predecls" ref="a4c94af862ca1bc3ebde2094d5e778ef1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def export_method_cxx_predecls </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>code</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00400"></a><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#a4c94af862ca1bc3ebde2094d5e778ef1">00400</a>                                              :
<a name="l00401"></a>00401         <span class="keywordflow">pass</span>
<a name="l00402"></a>00402 
<a name="l00403"></a>00403     <span class="comment"># Generate the code needed as a prerequisite for the C++ methods</span>
<a name="l00404"></a>00404     <span class="comment"># exported via export_methods() to be processed by SWIG.</span>
<a name="l00405"></a>00405     <span class="comment"># Typically generates one or more %include or %import statements.</span>
<a name="l00406"></a>00406     <span class="comment"># If any methods are exported, typically at least the C++ header</span>
<a name="l00407"></a>00407     <span class="comment"># declaring the relevant SimObject class must be included.</span>
    <span class="keyword">def </span><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#ac19f60f4d41b7b37c7f282db24e5d743">export_method_swig_predecls</a>(cls, code):
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac19f60f4d41b7b37c7f282db24e5d743"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::export_method_swig_predecls" ref="ac19f60f4d41b7b37c7f282db24e5d743" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def export_method_swig_predecls </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>code</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00408"></a><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#ac19f60f4d41b7b37c7f282db24e5d743">00408</a>                                               :
<a name="l00409"></a>00409         <span class="keywordflow">pass</span>
<a name="l00410"></a>00410 
<a name="l00411"></a>00411     <span class="comment"># Generate the declaration for this object for wrapping with SWIG.</span>
<a name="l00412"></a>00412     <span class="comment"># Generates code that goes into a SWIG .i file.  Called from</span>
<a name="l00413"></a>00413     <span class="comment"># src/SConscript.</span>
    <span class="keyword">def </span><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#a83526365333b680bfcbd9b037527cc25">swig_decl</a>(cls, code):
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab373c5eaef9a7b80491a097389260f4a"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::export_methods" ref="ab373c5eaef9a7b80491a097389260f4a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def export_methods </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>code</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00392"></a><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#ab373c5eaef9a7b80491a097389260f4a">00392</a>                                  :
<a name="l00393"></a>00393         <span class="keywordflow">pass</span>
<a name="l00394"></a>00394 
<a name="l00395"></a>00395     <span class="comment"># Generate the code needed as a prerequisite for the C++ methods</span>
<a name="l00396"></a>00396     <span class="comment"># exported via export_methods() to be compiled in the _wrap.cc</span>
<a name="l00397"></a>00397     <span class="comment"># file.  Typically generates one or more #include statements.  If</span>
<a name="l00398"></a>00398     <span class="comment"># any methods are exported, typically at least the C++ header</span>
<a name="l00399"></a>00399     <span class="comment"># declaring the relevant SimObject class must be included.</span>
    <span class="keyword">def </span><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#a4c94af862ca1bc3ebde2094d5e778ef1">export_method_cxx_predecls</a>(cls, code):
</pre></div></p>

</div>
</div>
<a class="anchor" id="a83526365333b680bfcbd9b037527cc25"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::swig_decl" ref="a83526365333b680bfcbd9b037527cc25" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def swig_decl </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>code</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00414"></a><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#a83526365333b680bfcbd9b037527cc25">00414</a>                             :
<a name="l00415"></a>00415         class_path = cls.cxx_class.split(<span class="stringliteral">&apos;::&apos;</span>)
<a name="l00416"></a>00416         classname = class_path[-1]
<a name="l00417"></a>00417         namespaces = class_path[:-1]
<a name="l00418"></a>00418 
<a name="l00419"></a>00419         <span class="comment"># The &apos;local&apos; attribute restricts us to the params declared in</span>
<a name="l00420"></a>00420         <span class="comment"># the object itself, not including inherited params (which</span>
<a name="l00421"></a>00421         <span class="comment"># will also be inherited from the base class&apos;s param struct</span>
<a name="l00422"></a>00422         <span class="comment"># here).</span>
<a name="l00423"></a>00423         params = cls._params.local.values()
<a name="l00424"></a>00424         ports = cls._ports.local
<a name="l00425"></a>00425 
<a name="l00426"></a>00426         code(<span class="stringliteral">&apos;%module(package=&quot;m5.internal&quot;) param_$cls&apos;</span>)
<a name="l00427"></a>00427         code()
<a name="l00428"></a>00428         code(<span class="stringliteral">&apos;%{&apos;</span>)
<a name="l00429"></a>00429         code(<span class="stringliteral">&apos;#include &quot;sim/sim_object.hh&quot;&apos;</span>)
<a name="l00430"></a>00430         code(<span class="stringliteral">&apos;#include &quot;params/$cls.hh&quot;&apos;</span>)
<a name="l00431"></a>00431         <span class="keywordflow">for</span> param <span class="keywordflow">in</span> params:
<a name="l00432"></a>00432             param.cxx_predecls(code)
<a name="l00433"></a>00433         code(<span class="stringliteral">&apos;#include &quot;${{cls.cxx_header}}&quot;&apos;</span>)
<a name="l00434"></a>00434         cls.export_method_cxx_predecls(code)
<a name="l00435"></a>00435         code(<span class="stringliteral">&apos;&apos;&apos;\</span>
<a name="l00436"></a>00436 <span class="stringliteral">/**</span>
<a name="l00437"></a>00437 <span class="stringliteral">  * This is a workaround for bug in swig. Prior to gcc 4.6.1 the STL</span>
<a name="l00438"></a>00438 <span class="stringliteral">  * headers like vector, string, etc. used to automatically pull in</span>
<a name="l00439"></a>00439 <span class="stringliteral">  * the cstddef header but starting with gcc 4.6.1 they no longer do.</span>
<a name="l00440"></a>00440 <span class="stringliteral">  * This leads to swig generated a file that does not compile so we</span>
<a name="l00441"></a>00441 <span class="stringliteral">  * explicitly include cstddef. Additionally, including version 2.0.4,</span>
<a name="l00442"></a>00442 <span class="stringliteral">  * swig uses ptrdiff_t without the std:: namespace prefix which is</span>
<a name="l00443"></a>00443 <span class="stringliteral">  * required with gcc 4.6.1. We explicitly provide access to it.</span>
<a name="l00444"></a>00444 <span class="stringliteral">  */</span>
<a name="l00445"></a>00445 <span class="stringliteral">#include &lt;cstddef&gt;</span>
<a name="l00446"></a>00446 <span class="stringliteral">using std::ptrdiff_t;</span>
<a name="l00447"></a>00447 <span class="stringliteral">&apos;&apos;&apos;</span>)
<a name="l00448"></a>00448         code(<span class="stringliteral">&apos;%}&apos;</span>)
<a name="l00449"></a>00449         code()
<a name="l00450"></a>00450 
<a name="l00451"></a>00451         <span class="keywordflow">for</span> param <span class="keywordflow">in</span> params:
<a name="l00452"></a>00452             param.swig_predecls(code)
<a name="l00453"></a>00453         cls.export_method_swig_predecls(code)
<a name="l00454"></a>00454 
<a name="l00455"></a>00455         code()
<a name="l00456"></a>00456         <span class="keywordflow">if</span> cls._base:
<a name="l00457"></a>00457             code(<span class="stringliteral">&apos;%import &quot;python/m5/internal/param_${{cls._base}}.i&quot;&apos;</span>)
<a name="l00458"></a>00458         code()
<a name="l00459"></a>00459 
<a name="l00460"></a>00460         <span class="keywordflow">for</span> ns <span class="keywordflow">in</span> namespaces:
<a name="l00461"></a>00461             code(<span class="stringliteral">&apos;namespace $ns {&apos;</span>)
<a name="l00462"></a>00462 
<a name="l00463"></a>00463         <span class="keywordflow">if</span> namespaces:
<a name="l00464"></a>00464             code(<span class="stringliteral">&apos;// avoid name conflicts&apos;</span>)
<a name="l00465"></a>00465             sep_string = <span class="stringliteral">&apos;_COLONS_&apos;</span>
<a name="l00466"></a>00466             flat_name = sep_string.join(class_path)
<a name="l00467"></a>00467             code(<span class="stringliteral">&apos;%rename($flat_name) $classname;&apos;</span>)
<a name="l00468"></a>00468 
<a name="l00469"></a>00469         code()
<a name="l00470"></a>00470         code(<span class="stringliteral">&apos;// stop swig from creating/wrapping default ctor/dtor&apos;</span>)
<a name="l00471"></a>00471         code(<span class="stringliteral">&apos;%nodefault $classname;&apos;</span>)
<a name="l00472"></a>00472         code(<span class="stringliteral">&apos;class $classname&apos;</span>)
<a name="l00473"></a>00473         <span class="keywordflow">if</span> cls._base:
<a name="l00474"></a>00474             bases = [ cls._base.cxx_class ] + cls.cxx_bases
<a name="l00475"></a>00475         <span class="keywordflow">else</span>:
<a name="l00476"></a>00476             bases = cls.cxx_bases
<a name="l00477"></a>00477         base_first = <span class="keyword">True</span>
<a name="l00478"></a>00478         <span class="keywordflow">for</span> base <span class="keywordflow">in</span> bases:
<a name="l00479"></a>00479             <span class="keywordflow">if</span> base_first:
<a name="l00480"></a>00480                 code(<span class="stringliteral">&apos;    : public ${{base}}&apos;</span>)
<a name="l00481"></a>00481                 base_first = <span class="keyword">False</span>
<a name="l00482"></a>00482             <span class="keywordflow">else</span>:
<a name="l00483"></a>00483                 code(<span class="stringliteral">&apos;    , public ${{base}}&apos;</span>)
<a name="l00484"></a>00484 
<a name="l00485"></a>00485         code(<span class="stringliteral">&apos;{&apos;</span>)
<a name="l00486"></a>00486         code(<span class="stringliteral">&apos;  public:&apos;</span>)
<a name="l00487"></a>00487         cls.export_methods(code)
<a name="l00488"></a>00488         code(<span class="stringliteral">&apos;};&apos;</span>)
<a name="l00489"></a>00489 
<a name="l00490"></a>00490         <span class="keywordflow">for</span> ns <span class="keywordflow">in</span> reversed(namespaces):
<a name="l00491"></a>00491             code(<span class="stringliteral">&apos;} // namespace $ns&apos;</span>)
<a name="l00492"></a>00492 
<a name="l00493"></a>00493         code()
<a name="l00494"></a>00494         code(<span class="stringliteral">&apos;%include &quot;params/$cls.hh&quot;&apos;</span>)
<a name="l00495"></a>00495 
<a name="l00496"></a>00496 
<a name="l00497"></a>00497     <span class="comment"># Generate the C++ declaration (.hh file) for this SimObject&apos;s</span>
<a name="l00498"></a>00498     <span class="comment"># param struct.  Called from src/SConscript.</span>
    <span class="keyword">def </span><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#af533aa789436bfde5727387a36ca9178">cxx_param_decl</a>(cls, code):
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab3dbcf5716623eac67a8ccc074fa7e13"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::swig_predecls" ref="ab3dbcf5716623eac67a8ccc074fa7e13" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def swig_predecls </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>code</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00387"></a><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#ab3dbcf5716623eac67a8ccc074fa7e13">00387</a>                                 :
<a name="l00388"></a>00388         code(<span class="stringliteral">&apos;%import &quot;python/m5/internal/param_$cls.i&quot;&apos;</span>)
<a name="l00389"></a>00389 
<a name="l00390"></a>00390     <span class="comment"># Hook for exporting additional C++ methods to Python via SWIG.</span>
<a name="l00391"></a>00391     <span class="comment"># Default is none, override using @classmethod in class definition.</span>
    <span class="keyword">def </span><a class="code" href="classm5_1_1SimObject_1_1MetaSimObject.html#ab373c5eaef9a7b80491a097389260f4a">export_methods</a>(cls, code):
</pre></div></p>

</div>
</div>
<hr/><h2>変数</h2>
<a class="anchor" id="a608ecb4a2947d6894ab9594d7f59f0a8"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::init_keywords" ref="a608ecb4a2947d6894ab9594d7f59f0a8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictionary <a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#a608ecb4a2947d6894ab9594d7f59f0a8">init_keywords</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>初期値:</b><div class="fragment"><pre class="fragment">{ <span class="stringliteral">&apos;abstract&apos;</span> : bool,
                      <span class="stringliteral">&apos;cxx_class&apos;</span> : str,
                      <span class="stringliteral">&apos;cxx_type&apos;</span> : str,
                      <span class="stringliteral">&apos;cxx_header&apos;</span> : str,
                      <span class="stringliteral">&apos;type&apos;</span> : str,
                      <span class="stringliteral">&apos;cxx_bases&apos;</span> : list }
</pre></div>
</div>
</div>
<a class="anchor" id="a834325b701200b492fc4d7422529cc70"></a><!-- doxytag: member="m5::SimObject::MetaSimObject::keywords" ref="a834325b701200b492fc4d7422529cc70" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictionary <a class="el" href="classm5_1_1SimObject_1_1MetaSimObject.html#a834325b701200b492fc4d7422529cc70">keywords</a> = { 'check' : FunctionType }<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>このクラスの説明は次のファイルから生成されました:<ul>
<li>python/m5/<a class="el" href="SimObject_8py.html">SimObject.py</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>File&nbsp;GEM5&nbsp;Wrapperに対して25 May 2015に生成されました。&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
