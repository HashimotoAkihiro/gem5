\hypertarget{classArmSystem}{
\section{クラス ArmSystem}
\label{classArmSystem}\index{ArmSystem@{ArmSystem}}
}


{\ttfamily \#include $<$system.hh$>$}ArmSystemに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=7cm]{classArmSystem}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef ArmSystemParams \hyperlink{classArmSystem_a8ae84e66b34bac08937a6bad4412ba5d}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
const \hyperlink{classArmSystem_a8ae84e66b34bac08937a6bad4412ba5d}{Params} $\ast$ \hyperlink{classArmSystem_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{classArmSystem_a770423e6e1a1f3470611eeebb5499e52}{ArmSystem} (\hyperlink{classArmSystem_a8ae84e66b34bac08937a6bad4412ba5d}{Params} $\ast$p)
\item 
\hyperlink{classArmSystem_a644c41d726bc3006918069971ed37c89}{$\sim$ArmSystem} ()
\item 
virtual void \hyperlink{classArmSystem_a3c34ea9b29f410748d4435a667484924}{initState} ()
\item 
virtual bool \hyperlink{classArmSystem_aa3d376f8ebebf8bc40b44b3ef359cf3d}{adderBootUncacheable} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} a)
\item 
virtual \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classArmSystem_aff94f650c5eef23b8dc350ea755bdef4}{fixFuncEventAddr} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr)
\item 
bool \hyperlink{classArmSystem_ae08900555a461016d6648524cba6e74c}{haveSecurity} () const 
\item 
bool \hyperlink{classArmSystem_a39b5e5d6cff3c8f5a248143a702d8f1a}{haveLPAE} () const 
\item 
bool \hyperlink{classArmSystem_afef641e959fe33dee8702b9bb5e1b9e4}{haveVirtualization} () const 
\item 
bool \hyperlink{classArmSystem_aecff777f050f73e02052a0a3691e0303}{haveGenericTimer} () const 
\item 
void \hyperlink{classArmSystem_a8d0ae73d8ff6797f8b38801bffd82454}{setGenericTimer} (\hyperlink{classGenericTimer}{GenericTimer} $\ast$generic\_\-timer)
\item 
\hyperlink{classGenericTimer_1_1SystemCounter}{GenericTimer::SystemCounter} $\ast$ \hyperlink{classArmSystem_af76ffe466ccc286510b4747521fabcfe}{getSystemCounter} () const 
\item 
\hyperlink{classGenericTimer_1_1ArchTimer}{GenericTimer::ArchTimer} $\ast$ \hyperlink{classArmSystem_af8bdff642693841d42bfdb92c78729a3}{getArchTimer} (int cpu\_\-id) const 
\item 
bool \hyperlink{classArmSystem_a87a962080af194d9996167c494c30ff1}{highestELIs64} () const 
\item 
ExceptionLevel \hyperlink{classArmSystem_ac97823fdad4c16dec297e6e92887ba5f}{highestEL} () const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classArmSystem_ab3ee6a4f5ccf871a1ec729401efa6df4}{resetAddr64} () const 
\item 
bool \hyperlink{classArmSystem_a47958664a46869f3fb4f9b043da32be5}{haveLargeAsid64} () const 
\item 
uint8\_\-t \hyperlink{classArmSystem_a4ab7e9eea0ca7202f2f83655f5dd1571}{physAddrRange64} () const 
\item 
uint8\_\-t \hyperlink{classArmSystem_aecc15d8d848b1cee0bbe7dac86d01ec1}{physAddrRange} () const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classArmSystem_a09d9a6ae0ebdd88ccfccc513e2157aef}{physAddrMask} () const 
\end{DoxyCompactItemize}
\subsection*{Static Public メソッド}
\begin{DoxyCompactItemize}
\item 
static bool \hyperlink{classArmSystem_abe179837e5b071fc8f9d6896bd7ff1e6}{haveSecurity} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\item 
static bool \hyperlink{classArmSystem_a1f64894290af14b147eda414e6588005}{haveVirtualization} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\item 
static bool \hyperlink{classArmSystem_aaab5472ead2be1873fa192e1f196b78b}{haveLPAE} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\item 
static bool \hyperlink{classArmSystem_a94d9b71637c8e790ebb6124498fd1252}{highestELIs64} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\item 
static ExceptionLevel \hyperlink{classArmSystem_afc4618ef69b2b5acf5723126b73ef1ac}{highestEL} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\item 
static \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classArmSystem_a04b1e5b5c4e565e6250ef5a38537205a}{resetAddr64} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\item 
static uint8\_\-t \hyperlink{classArmSystem_aa5d9f7bf62fd42274745654e63b0fbf8}{physAddrRange} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\item 
static \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classArmSystem_a9b41efe55e6e2a1ee6f8a44325c8213e}{physAddrMask} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\item 
static bool \hyperlink{classArmSystem_a7a86a1f7da253ac26a3bc9891e49e6cf}{haveLargeAsid64} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classArmSystem_a872f015757d394b551ccf79cfb2c7979}{multiProc}
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
Linux::DebugPrintkEvent $\ast$ \hyperlink{classArmSystem_aedceac66468548dd7c74a37cb968a83b}{debugPrintkEvent}
\item 
\hyperlink{classObjectFile}{ObjectFile} $\ast$ \hyperlink{classArmSystem_ac52aedcc0c513ce741fac3ea80c9b0d1}{bootldr}
\item 
const bool \hyperlink{classArmSystem_afc4f86a45efbe233466dde9b89cf3fd5}{\_\-haveSecurity}
\item 
const bool \hyperlink{classArmSystem_a1215984ae18da163f0042f3e1fc64403}{\_\-haveLPAE}
\item 
const bool \hyperlink{classArmSystem_a24146119795922982380e6b02b898a37}{\_\-haveVirtualization}
\item 
const bool \hyperlink{classArmSystem_aca3aa280f7b7c05a9b554608cfaf4418}{\_\-haveGenericTimer}
\item 
\hyperlink{classGenericTimer}{GenericTimer} $\ast$ \hyperlink{classArmSystem_a5402fcff3a17875626c3a32694fa7303}{\_\-genericTimer}
\item 
bool \hyperlink{classArmSystem_a34da8e2d4b4cf578fc6f605d89aec207}{\_\-highestELIs64}
\item 
const \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classArmSystem_a44d32244f9a93e43785fd25bf729ec55}{\_\-resetAddr64}
\item 
const uint8\_\-t \hyperlink{classArmSystem_aca8ae8dd2646e41f8b1e1db3bf8153e3}{\_\-physAddrRange64}
\item 
const bool \hyperlink{classArmSystem_aa8ec26eb0cbc124e0b9f5338b476ebfa}{\_\-haveLargeAsid64}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classArmSystem_a8ae84e66b34bac08937a6bad4412ba5d}{
\index{ArmSystem@{ArmSystem}!Params@{Params}}
\index{Params@{Params}!ArmSystem@{ArmSystem}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef ArmSystemParams {\bf Params}}}
\label{classArmSystem_a8ae84e66b34bac08937a6bad4412ba5d}


\hyperlink{classSystem_a5f461be6222ce76bffcb70f27d820c56}{System}を再定義しています。

\hyperlink{classLinuxArmSystem_ae0ebf28024a7bb607cc65e59c8faa9d5}{LinuxArmSystem}で再定義されています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classArmSystem_a770423e6e1a1f3470611eeebb5499e52}{
\index{ArmSystem@{ArmSystem}!ArmSystem@{ArmSystem}}
\index{ArmSystem@{ArmSystem}!ArmSystem@{ArmSystem}}
\subsubsection[{ArmSystem}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ArmSystem} ({\bf Params} $\ast$ {\em p})}}
\label{classArmSystem_a770423e6e1a1f3470611eeebb5499e52}



\begin{DoxyCode}
57     : System(p), bootldr(NULL), _haveSecurity(p->have_security),
58       _haveLPAE(p->have_lpae),
59       _haveVirtualization(p->have_virtualization),
60       _haveGenericTimer(p->have_generic_timer),
61       _highestELIs64(p->highest_el_is_64),
62       _resetAddr64(p->reset_addr_64),
63       _physAddrRange64(p->phys_addr_range_64),
64       _haveLargeAsid64(p->have_large_asid_64),
65       multiProc(p->multi_proc)
66 {
67     // Check if the physical address range is valid
68     if (_highestELIs64 && (
69             _physAddrRange64 < 32 ||
70             _physAddrRange64 > 48 ||
71             (_physAddrRange64 % 4 != 0 && _physAddrRange64 != 42))) {
72         fatal("Invalid physical address range (%d)\n", _physAddrRange64);
73     }
74 
75     if (p->boot_loader != "") {
76         bootldr = createObjectFile(p->boot_loader);
77 
78         if (!bootldr)
79             fatal("Could not read bootloader: %s\n", p->boot_loader);
80 
81         if ((bootldr->getArch() == ObjectFile::Arm64) && !_highestELIs64) {
82             warn("Highest ARM exception-level set to AArch32 but bootloader "
83                   "is for AArch64. Assuming you wanted these to match.\n");
84             _highestELIs64 = true;
85         } else if ((bootldr->getArch() == ObjectFile::Arm) && _highestELIs64) {
86             warn("Highest ARM exception-level set to AArch64 but bootloader "
87                   "is for AArch32. Assuming you wanted these to match.\n");
88             _highestELIs64 = false;
89         }
90 
91         bootldr->loadGlobalSymbols(debugSymbolTable);
92 
93     }
94     debugPrintkEvent = addKernelFuncEvent<DebugPrintkEvent>("dprintk");
95 }
\end{DoxyCode}
\hypertarget{classArmSystem_a644c41d726bc3006918069971ed37c89}{
\index{ArmSystem@{ArmSystem}!$\sim$ArmSystem@{$\sim$ArmSystem}}
\index{$\sim$ArmSystem@{$\sim$ArmSystem}!ArmSystem@{ArmSystem}}
\subsubsection[{$\sim$ArmSystem}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf ArmSystem} ()}}
\label{classArmSystem_a644c41d726bc3006918069971ed37c89}



\begin{DoxyCode}
184 {
185     if (debugPrintkEvent)
186         delete debugPrintkEvent;
187 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classArmSystem_aa3d376f8ebebf8bc40b44b3ef359cf3d}{
\index{ArmSystem@{ArmSystem}!adderBootUncacheable@{adderBootUncacheable}}
\index{adderBootUncacheable@{adderBootUncacheable}!ArmSystem@{ArmSystem}}
\subsubsection[{adderBootUncacheable}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool adderBootUncacheable ({\bf Addr} {\em a})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classArmSystem_aa3d376f8ebebf8bc40b44b3ef359cf3d}
\hyperlink{classCheck}{Check} if an address should be uncacheable until all caches are enabled. This exits because coherence on some addresses at boot is maintained via sw coherence until the caches are enbaled. Since we don't support sw coherence operations in gem5, this is a method that allows a system type to designate certain addresses that should remain uncachebale for a while. 

\hyperlink{classLinuxArmSystem_ac081da131af9bc2b37f4c4d7d99eaff1}{LinuxArmSystem}で再定義されています。


\begin{DoxyCode}
142 { return false; }
\end{DoxyCode}
\hypertarget{classArmSystem_aff94f650c5eef23b8dc350ea755bdef4}{
\index{ArmSystem@{ArmSystem}!fixFuncEventAddr@{fixFuncEventAddr}}
\index{fixFuncEventAddr@{fixFuncEventAddr}!ArmSystem@{ArmSystem}}
\subsubsection[{fixFuncEventAddr}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Addr} fixFuncEventAddr ({\bf Addr} {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classArmSystem_aff94f650c5eef23b8dc350ea755bdef4}
Fix up an address used to match PCs for hooking simulator events on to target function executions. See comment in system.cc for details. 

\hyperlink{classSystem_aff94f650c5eef23b8dc350ea755bdef4}{System}を再定義しています。


\begin{DoxyCode}
145     {
146         // Remove the low bit that thumb symbols have set
147         // but that aren't actually odd aligned
148         if (addr & 0x1)
149             return addr & ~1;
150         return addr;
151     }
\end{DoxyCode}
\hypertarget{classArmSystem_af8bdff642693841d42bfdb92c78729a3}{
\index{ArmSystem@{ArmSystem}!getArchTimer@{getArchTimer}}
\index{getArchTimer@{getArchTimer}!ArmSystem@{ArmSystem}}
\subsubsection[{getArchTimer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf GenericTimer::ArchTimer} $\ast$ getArchTimer (int {\em cpu\_\-id}) const}}
\label{classArmSystem_af8bdff642693841d42bfdb92c78729a3}
Returns a pointer to the appropriate architected timer. 


\begin{DoxyCode}
155 {
156     if (_genericTimer) {
157         return _genericTimer->getArchTimer(cpu_id);
158     }
159     return NULL;
160 }
\end{DoxyCode}
\hypertarget{classArmSystem_af76ffe466ccc286510b4747521fabcfe}{
\index{ArmSystem@{ArmSystem}!getSystemCounter@{getSystemCounter}}
\index{getSystemCounter@{getSystemCounter}!ArmSystem@{ArmSystem}}
\subsubsection[{getSystemCounter}]{\setlength{\rightskip}{0pt plus 5cm}{\bf GenericTimer::SystemCounter} $\ast$ getSystemCounter () const}}
\label{classArmSystem_af76ffe466ccc286510b4747521fabcfe}
Returns a pointer to the system counter. 


\begin{DoxyCode}
164 {
165     if (_genericTimer) {
166         return _genericTimer->getSystemCounter();
167     }
168     return NULL;
169 }
\end{DoxyCode}
\hypertarget{classArmSystem_aecff777f050f73e02052a0a3691e0303}{
\index{ArmSystem@{ArmSystem}!haveGenericTimer@{haveGenericTimer}}
\index{haveGenericTimer@{haveGenericTimer}!ArmSystem@{ArmSystem}}
\subsubsection[{haveGenericTimer}]{\setlength{\rightskip}{0pt plus 5cm}bool haveGenericTimer () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmSystem_aecff777f050f73e02052a0a3691e0303}
Returns true if this system implements the Generic Timer extension. 


\begin{DoxyCode}
169 { return _haveGenericTimer; }
\end{DoxyCode}
\hypertarget{classArmSystem_a7a86a1f7da253ac26a3bc9891e49e6cf}{
\index{ArmSystem@{ArmSystem}!haveLargeAsid64@{haveLargeAsid64}}
\index{haveLargeAsid64@{haveLargeAsid64}!ArmSystem@{ArmSystem}}
\subsubsection[{haveLargeAsid64}]{\setlength{\rightskip}{0pt plus 5cm}bool haveLargeAsid64 ({\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classArmSystem_a7a86a1f7da253ac26a3bc9891e49e6cf}
Returns true if ASID is 16 bits for the system of a specific thread context while in AArch64 (ARMv8) 


\begin{DoxyCode}
243 {
244     return dynamic_cast<ArmSystem *>(tc->getSystemPtr())->haveLargeAsid64();
245 }
\end{DoxyCode}
\hypertarget{classArmSystem_a47958664a46869f3fb4f9b043da32be5}{
\index{ArmSystem@{ArmSystem}!haveLargeAsid64@{haveLargeAsid64}}
\index{haveLargeAsid64@{haveLargeAsid64}!ArmSystem@{ArmSystem}}
\subsubsection[{haveLargeAsid64}]{\setlength{\rightskip}{0pt plus 5cm}bool haveLargeAsid64 () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmSystem_a47958664a46869f3fb4f9b043da32be5}
Returns true if ASID is 16 bits in AArch64 (ARMv8) 


\begin{DoxyCode}
203 { return _haveLargeAsid64; }
\end{DoxyCode}
\hypertarget{classArmSystem_aaab5472ead2be1873fa192e1f196b78b}{
\index{ArmSystem@{ArmSystem}!haveLPAE@{haveLPAE}}
\index{haveLPAE@{haveLPAE}!ArmSystem@{ArmSystem}}
\subsubsection[{haveLPAE}]{\setlength{\rightskip}{0pt plus 5cm}bool haveLPAE ({\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classArmSystem_aaab5472ead2be1873fa192e1f196b78b}
Returns true if the system of a specific thread context implements the Large Physical \hyperlink{classAddress}{Address} Extension 


\begin{DoxyCode}
191 {
192     if (!FullSystem)
193         return false;
194 
195     ArmSystem *a_sys = dynamic_cast<ArmSystem *>(tc->getSystemPtr());
196     assert(a_sys);
197     return a_sys->haveLPAE();
198 }
\end{DoxyCode}
\hypertarget{classArmSystem_a39b5e5d6cff3c8f5a248143a702d8f1a}{
\index{ArmSystem@{ArmSystem}!haveLPAE@{haveLPAE}}
\index{haveLPAE@{haveLPAE}!ArmSystem@{ArmSystem}}
\subsubsection[{haveLPAE}]{\setlength{\rightskip}{0pt plus 5cm}bool haveLPAE () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmSystem_a39b5e5d6cff3c8f5a248143a702d8f1a}
Returns true if this system implements the Large Physical \hyperlink{classAddress}{Address} Extension 


\begin{DoxyCode}
161 { return _haveLPAE; }
\end{DoxyCode}
\hypertarget{classArmSystem_abe179837e5b071fc8f9d6896bd7ff1e6}{
\index{ArmSystem@{ArmSystem}!haveSecurity@{haveSecurity}}
\index{haveSecurity@{haveSecurity}!ArmSystem@{ArmSystem}}
\subsubsection[{haveSecurity}]{\setlength{\rightskip}{0pt plus 5cm}bool haveSecurity ({\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classArmSystem_abe179837e5b071fc8f9d6896bd7ff1e6}
Returns true if the system of a specific thread context implements the Security Extensions 


\begin{DoxyCode}
173 {
174     if (!FullSystem)
175         return false;
176 
177     ArmSystem *a_sys = dynamic_cast<ArmSystem *>(tc->getSystemPtr());
178     assert(a_sys);
179     return a_sys->haveSecurity();
180 }
\end{DoxyCode}
\hypertarget{classArmSystem_ae08900555a461016d6648524cba6e74c}{
\index{ArmSystem@{ArmSystem}!haveSecurity@{haveSecurity}}
\index{haveSecurity@{haveSecurity}!ArmSystem@{ArmSystem}}
\subsubsection[{haveSecurity}]{\setlength{\rightskip}{0pt plus 5cm}bool haveSecurity () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmSystem_ae08900555a461016d6648524cba6e74c}
Returns true if this system implements the Security Extensions 


\begin{DoxyCode}
157 { return _haveSecurity; }
\end{DoxyCode}
\hypertarget{classArmSystem_a1f64894290af14b147eda414e6588005}{
\index{ArmSystem@{ArmSystem}!haveVirtualization@{haveVirtualization}}
\index{haveVirtualization@{haveVirtualization}!ArmSystem@{ArmSystem}}
\subsubsection[{haveVirtualization}]{\setlength{\rightskip}{0pt plus 5cm}bool haveVirtualization ({\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classArmSystem_a1f64894290af14b147eda414e6588005}
Returns true if the system of a specific thread context implements the virtualization Extensions 


\begin{DoxyCode}
202 {
203     if (!FullSystem)
204         return false;
205 
206     ArmSystem *a_sys = dynamic_cast<ArmSystem *>(tc->getSystemPtr());
207     assert(a_sys);
208     return a_sys->haveVirtualization();
209 }
\end{DoxyCode}
\hypertarget{classArmSystem_afef641e959fe33dee8702b9bb5e1b9e4}{
\index{ArmSystem@{ArmSystem}!haveVirtualization@{haveVirtualization}}
\index{haveVirtualization@{haveVirtualization}!ArmSystem@{ArmSystem}}
\subsubsection[{haveVirtualization}]{\setlength{\rightskip}{0pt plus 5cm}bool haveVirtualization () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmSystem_afef641e959fe33dee8702b9bb5e1b9e4}
Returns true if this system implements the virtualization Extensions 


\begin{DoxyCode}
166 { return _haveVirtualization; }
\end{DoxyCode}
\hypertarget{classArmSystem_afc4618ef69b2b5acf5723126b73ef1ac}{
\index{ArmSystem@{ArmSystem}!highestEL@{highestEL}}
\index{highestEL@{highestEL}!ArmSystem@{ArmSystem}}
\subsubsection[{highestEL}]{\setlength{\rightskip}{0pt plus 5cm}ExceptionLevel highestEL ({\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classArmSystem_afc4618ef69b2b5acf5723126b73ef1ac}
Returns the highest implemented exception level for the system of a specific thread context 


\begin{DoxyCode}
219 {
220     return dynamic_cast<ArmSystem *>(tc->getSystemPtr())->highestEL();
221 }
\end{DoxyCode}
\hypertarget{classArmSystem_ac97823fdad4c16dec297e6e92887ba5f}{
\index{ArmSystem@{ArmSystem}!highestEL@{highestEL}}
\index{highestEL@{highestEL}!ArmSystem@{ArmSystem}}
\subsubsection[{highestEL}]{\setlength{\rightskip}{0pt plus 5cm}ExceptionLevel highestEL () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmSystem_ac97823fdad4c16dec297e6e92887ba5f}
Returns the highest implemented exception level 


\begin{DoxyCode}
189     {
190         if (_haveSecurity)
191             return EL3;
192         // @todo: uncomment this to enable Virtualization
193         // if (_haveVirtualization)
194         //     return EL2;
195         return EL1;
196     }
\end{DoxyCode}
\hypertarget{classArmSystem_a94d9b71637c8e790ebb6124498fd1252}{
\index{ArmSystem@{ArmSystem}!highestELIs64@{highestELIs64}}
\index{highestELIs64@{highestELIs64}!ArmSystem@{ArmSystem}}
\subsubsection[{highestELIs64}]{\setlength{\rightskip}{0pt plus 5cm}bool highestELIs64 ({\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classArmSystem_a94d9b71637c8e790ebb6124498fd1252}
Returns true if the register width of the highest implemented exception level for the system of a specific thread context is 64 bits (ARMv8) 


\begin{DoxyCode}
213 {
214     return dynamic_cast<ArmSystem *>(tc->getSystemPtr())->highestELIs64();
215 }
\end{DoxyCode}
\hypertarget{classArmSystem_a87a962080af194d9996167c494c30ff1}{
\index{ArmSystem@{ArmSystem}!highestELIs64@{highestELIs64}}
\index{highestELIs64@{highestELIs64}!ArmSystem@{ArmSystem}}
\subsubsection[{highestELIs64}]{\setlength{\rightskip}{0pt plus 5cm}bool highestELIs64 () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmSystem_a87a962080af194d9996167c494c30ff1}
Returns true if the register width of the highest implemented exception level is 64 bits (ARMv8) 


\begin{DoxyCode}
185 { return _highestELIs64; }
\end{DoxyCode}
\hypertarget{classArmSystem_a3c34ea9b29f410748d4435a667484924}{
\index{ArmSystem@{ArmSystem}!initState@{initState}}
\index{initState@{initState}!ArmSystem@{ArmSystem}}
\subsubsection[{initState}]{\setlength{\rightskip}{0pt plus 5cm}void initState ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classArmSystem_a3c34ea9b29f410748d4435a667484924}
Initialise the system 

\hyperlink{classSystem_a3c34ea9b29f410748d4435a667484924}{System}を再定義しています。

\hyperlink{classLinuxArmSystem_a3c34ea9b29f410748d4435a667484924}{LinuxArmSystem}で再定義されています。


\begin{DoxyCode}
99 {
100     // Moved from the constructor to here since it relies on the
101     // address map being resolved in the interconnect
102 
103     // Call the initialisation of the super class
104     System::initState();
105 
106     const Params* p = params();
107 
108     if (bootldr) {
109         bootldr->loadSections(physProxy);
110 
111         uint8_t jump_to_bl_32[] =
112         {
113             0x07, 0xf0, 0xa0, 0xe1  // branch to r7 in aarch32
114         };
115 
116         uint8_t jump_to_bl_64[] =
117         {
118             0xe0, 0x00, 0x1f, 0xd6  // instruction "br x7" in aarch64
119         };
120 
121         // write the jump to branch table into address 0
122         if (!_highestELIs64)
123             physProxy.writeBlob(0x0, jump_to_bl_32, sizeof(jump_to_bl_32));
124         else
125             physProxy.writeBlob(0x0, jump_to_bl_64, sizeof(jump_to_bl_64));
126 
127         inform("Using bootloader at address %#x\n", bootldr->entryPoint());
128 
129         // Put the address of the boot loader into r7 so we know
130         // where to branch to after the reset fault
131         // All other values needed by the boot loader to know what to do
132         if (!p->gic_cpu_addr || !p->flags_addr)
133             fatal("gic_cpu_addr && flags_addr must be set with bootloader\n");
134 
135         for (int i = 0; i < threadContexts.size(); i++) {
136             if (!_highestELIs64)
137                 threadContexts[i]->setIntReg(3, (kernelEntry & loadAddrMask) +
138                         loadAddrOffset);
139             threadContexts[i]->setIntReg(4, params()->gic_cpu_addr);
140             threadContexts[i]->setIntReg(5, params()->flags_addr);
141             threadContexts[i]->setIntReg(7, bootldr->entryPoint());
142         }
143         inform("Using kernel entry physical address at %#x\n",
144                (kernelEntry & loadAddrMask) + loadAddrOffset);
145     } else {
146         // Set the initial PC to be at start of the kernel code
147         if (!_highestELIs64)
148             threadContexts[0]->pcState((kernelEntry & loadAddrMask) +
149                     loadAddrOffset);
150     }
151 }
\end{DoxyCode}
\hypertarget{classArmSystem_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{ArmSystem@{ArmSystem}!params@{params}}
\index{params@{params}!ArmSystem@{ArmSystem}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmSystem_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classSystem_acd3c3feb78ae7a8f88fe0f110a718dff}{System}を再定義しています。

\hyperlink{classLinuxArmSystem_acd3c3feb78ae7a8f88fe0f110a718dff}{LinuxArmSystem}で再定義されています。


\begin{DoxyCode}
123     {
124         return dynamic_cast<const Params *>(_params);
125     }
\end{DoxyCode}
\hypertarget{classArmSystem_a9b41efe55e6e2a1ee6f8a44325c8213e}{
\index{ArmSystem@{ArmSystem}!physAddrMask@{physAddrMask}}
\index{physAddrMask@{physAddrMask}!ArmSystem@{ArmSystem}}
\subsubsection[{physAddrMask}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} physAddrMask ({\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classArmSystem_a9b41efe55e6e2a1ee6f8a44325c8213e}
Returns the physical address mask for the system of a specific thread context 


\begin{DoxyCode}
237 {
238     return dynamic_cast<ArmSystem *>(tc->getSystemPtr())->physAddrMask();
239 }
\end{DoxyCode}
\hypertarget{classArmSystem_a09d9a6ae0ebdd88ccfccc513e2157aef}{
\index{ArmSystem@{ArmSystem}!physAddrMask@{physAddrMask}}
\index{physAddrMask@{physAddrMask}!ArmSystem@{ArmSystem}}
\subsubsection[{physAddrMask}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} physAddrMask () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmSystem_a09d9a6ae0ebdd88ccfccc513e2157aef}
Returns the physical address mask 


\begin{DoxyCode}
221     {
222         return mask(physAddrRange());
223     }
\end{DoxyCode}
\hypertarget{classArmSystem_aa5d9f7bf62fd42274745654e63b0fbf8}{
\index{ArmSystem@{ArmSystem}!physAddrRange@{physAddrRange}}
\index{physAddrRange@{physAddrRange}!ArmSystem@{ArmSystem}}
\subsubsection[{physAddrRange}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t physAddrRange ({\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classArmSystem_aa5d9f7bf62fd42274745654e63b0fbf8}
Returns the supported physical address range in bits for the system of a specific thread context 


\begin{DoxyCode}
231 {
232     return dynamic_cast<ArmSystem *>(tc->getSystemPtr())->physAddrRange();
233 }
\end{DoxyCode}
\hypertarget{classArmSystem_aecc15d8d848b1cee0bbe7dac86d01ec1}{
\index{ArmSystem@{ArmSystem}!physAddrRange@{physAddrRange}}
\index{physAddrRange@{physAddrRange}!ArmSystem@{ArmSystem}}
\subsubsection[{physAddrRange}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t physAddrRange () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmSystem_aecc15d8d848b1cee0bbe7dac86d01ec1}
Returns the supported physical address range in bits 


\begin{DoxyCode}
211     {
212         if (_highestELIs64)
213             return _physAddrRange64;
214         if (_haveLPAE)
215             return 40;
216         return 32;
217     }
\end{DoxyCode}
\hypertarget{classArmSystem_a4ab7e9eea0ca7202f2f83655f5dd1571}{
\index{ArmSystem@{ArmSystem}!physAddrRange64@{physAddrRange64}}
\index{physAddrRange64@{physAddrRange64}!ArmSystem@{ArmSystem}}
\subsubsection[{physAddrRange64}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t physAddrRange64 () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmSystem_a4ab7e9eea0ca7202f2f83655f5dd1571}
Returns the supported physical address range in bits if the highest implemented exception level is 64 bits (ARMv8) 


\begin{DoxyCode}
207 { return _physAddrRange64; }
\end{DoxyCode}
\hypertarget{classArmSystem_a04b1e5b5c4e565e6250ef5a38537205a}{
\index{ArmSystem@{ArmSystem}!resetAddr64@{resetAddr64}}
\index{resetAddr64@{resetAddr64}!ArmSystem@{ArmSystem}}
\subsubsection[{resetAddr64}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} resetAddr64 ({\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classArmSystem_a04b1e5b5c4e565e6250ef5a38537205a}
Returns the reset address if the highest implemented exception level for the system of a specific thread context is 64 bits (ARMv8) 


\begin{DoxyCode}
225 {
226     return dynamic_cast<ArmSystem *>(tc->getSystemPtr())->resetAddr64();
227 }
\end{DoxyCode}
\hypertarget{classArmSystem_ab3ee6a4f5ccf871a1ec729401efa6df4}{
\index{ArmSystem@{ArmSystem}!resetAddr64@{resetAddr64}}
\index{resetAddr64@{resetAddr64}!ArmSystem@{ArmSystem}}
\subsubsection[{resetAddr64}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} resetAddr64 () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmSystem_ab3ee6a4f5ccf871a1ec729401efa6df4}
Returns the reset address if the highest implemented exception level is 64 bits (ARMv8) 


\begin{DoxyCode}
200 { return _resetAddr64; }
\end{DoxyCode}
\hypertarget{classArmSystem_a8d0ae73d8ff6797f8b38801bffd82454}{
\index{ArmSystem@{ArmSystem}!setGenericTimer@{setGenericTimer}}
\index{setGenericTimer@{setGenericTimer}!ArmSystem@{ArmSystem}}
\subsubsection[{setGenericTimer}]{\setlength{\rightskip}{0pt plus 5cm}void setGenericTimer ({\bf GenericTimer} $\ast$ {\em generic\_\-timer})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmSystem_a8d0ae73d8ff6797f8b38801bffd82454}
Sets the pointer to the Generic Timer. 


\begin{DoxyCode}
173     {
174         _genericTimer = generic_timer;
175     }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classArmSystem_a5402fcff3a17875626c3a32694fa7303}{
\index{ArmSystem@{ArmSystem}!\_\-genericTimer@{\_\-genericTimer}}
\index{\_\-genericTimer@{\_\-genericTimer}!ArmSystem@{ArmSystem}}
\subsubsection[{\_\-genericTimer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf GenericTimer}$\ast$ {\bf \_\-genericTimer}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmSystem_a5402fcff3a17875626c3a32694fa7303}
Pointer to the Generic Timer wrapper. \hypertarget{classArmSystem_aca3aa280f7b7c05a9b554608cfaf4418}{
\index{ArmSystem@{ArmSystem}!\_\-haveGenericTimer@{\_\-haveGenericTimer}}
\index{\_\-haveGenericTimer@{\_\-haveGenericTimer}!ArmSystem@{ArmSystem}}
\subsubsection[{\_\-haveGenericTimer}]{\setlength{\rightskip}{0pt plus 5cm}const bool {\bf \_\-haveGenericTimer}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmSystem_aca3aa280f7b7c05a9b554608cfaf4418}
True if this system implements the Generic Timer extension \hypertarget{classArmSystem_aa8ec26eb0cbc124e0b9f5338b476ebfa}{
\index{ArmSystem@{ArmSystem}!\_\-haveLargeAsid64@{\_\-haveLargeAsid64}}
\index{\_\-haveLargeAsid64@{\_\-haveLargeAsid64}!ArmSystem@{ArmSystem}}
\subsubsection[{\_\-haveLargeAsid64}]{\setlength{\rightskip}{0pt plus 5cm}const bool {\bf \_\-haveLargeAsid64}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmSystem_aa8ec26eb0cbc124e0b9f5338b476ebfa}
True if ASID is 16 bits in AArch64 (ARMv8) \hypertarget{classArmSystem_a1215984ae18da163f0042f3e1fc64403}{
\index{ArmSystem@{ArmSystem}!\_\-haveLPAE@{\_\-haveLPAE}}
\index{\_\-haveLPAE@{\_\-haveLPAE}!ArmSystem@{ArmSystem}}
\subsubsection[{\_\-haveLPAE}]{\setlength{\rightskip}{0pt plus 5cm}const bool {\bf \_\-haveLPAE}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmSystem_a1215984ae18da163f0042f3e1fc64403}
True if this system implements the Large Physical \hyperlink{classAddress}{Address} Extension \hypertarget{classArmSystem_afc4f86a45efbe233466dde9b89cf3fd5}{
\index{ArmSystem@{ArmSystem}!\_\-haveSecurity@{\_\-haveSecurity}}
\index{\_\-haveSecurity@{\_\-haveSecurity}!ArmSystem@{ArmSystem}}
\subsubsection[{\_\-haveSecurity}]{\setlength{\rightskip}{0pt plus 5cm}const bool {\bf \_\-haveSecurity}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmSystem_afc4f86a45efbe233466dde9b89cf3fd5}
True if this system implements the Security Extensions \hypertarget{classArmSystem_a24146119795922982380e6b02b898a37}{
\index{ArmSystem@{ArmSystem}!\_\-haveVirtualization@{\_\-haveVirtualization}}
\index{\_\-haveVirtualization@{\_\-haveVirtualization}!ArmSystem@{ArmSystem}}
\subsubsection[{\_\-haveVirtualization}]{\setlength{\rightskip}{0pt plus 5cm}const bool {\bf \_\-haveVirtualization}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmSystem_a24146119795922982380e6b02b898a37}
True if this system implements the virtualization Extensions \hypertarget{classArmSystem_a34da8e2d4b4cf578fc6f605d89aec207}{
\index{ArmSystem@{ArmSystem}!\_\-highestELIs64@{\_\-highestELIs64}}
\index{\_\-highestELIs64@{\_\-highestELIs64}!ArmSystem@{ArmSystem}}
\subsubsection[{\_\-highestELIs64}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \_\-highestELIs64}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmSystem_a34da8e2d4b4cf578fc6f605d89aec207}
True if the register width of the highest implemented exception level is 64 bits (ARMv8) \hypertarget{classArmSystem_aca8ae8dd2646e41f8b1e1db3bf8153e3}{
\index{ArmSystem@{ArmSystem}!\_\-physAddrRange64@{\_\-physAddrRange64}}
\index{\_\-physAddrRange64@{\_\-physAddrRange64}!ArmSystem@{ArmSystem}}
\subsubsection[{\_\-physAddrRange64}]{\setlength{\rightskip}{0pt plus 5cm}const uint8\_\-t {\bf \_\-physAddrRange64}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmSystem_aca8ae8dd2646e41f8b1e1db3bf8153e3}
Supported physical address range in bits if the highest implemented exception level is 64 bits (ARMv8) \hypertarget{classArmSystem_a44d32244f9a93e43785fd25bf729ec55}{
\index{ArmSystem@{ArmSystem}!\_\-resetAddr64@{\_\-resetAddr64}}
\index{\_\-resetAddr64@{\_\-resetAddr64}!ArmSystem@{ArmSystem}}
\subsubsection[{\_\-resetAddr64}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Addr} {\bf \_\-resetAddr64}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmSystem_a44d32244f9a93e43785fd25bf729ec55}
Reset address if the highest implemented exception level is 64 bits (ARMv8) \hypertarget{classArmSystem_ac52aedcc0c513ce741fac3ea80c9b0d1}{
\index{ArmSystem@{ArmSystem}!bootldr@{bootldr}}
\index{bootldr@{bootldr}!ArmSystem@{ArmSystem}}
\subsubsection[{bootldr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ObjectFile}$\ast$ {\bf bootldr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmSystem_ac52aedcc0c513ce741fac3ea80c9b0d1}
Pointer to the bootloader object \hypertarget{classArmSystem_aedceac66468548dd7c74a37cb968a83b}{
\index{ArmSystem@{ArmSystem}!debugPrintkEvent@{debugPrintkEvent}}
\index{debugPrintkEvent@{debugPrintkEvent}!ArmSystem@{ArmSystem}}
\subsubsection[{debugPrintkEvent}]{\setlength{\rightskip}{0pt plus 5cm}Linux::DebugPrintkEvent$\ast$ {\bf debugPrintkEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmSystem_aedceac66468548dd7c74a37cb968a83b}
PC based event to skip the dprink() call and emulate its functionality \hypertarget{classArmSystem_a872f015757d394b551ccf79cfb2c7979}{
\index{ArmSystem@{ArmSystem}!multiProc@{multiProc}}
\index{multiProc@{multiProc}!ArmSystem@{ArmSystem}}
\subsubsection[{multiProc}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf multiProc}}}
\label{classArmSystem_a872f015757d394b551ccf79cfb2c7979}
true if this a multiprocessor system 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/arm/\hyperlink{arch_2arm_2system_8hh}{system.hh}\item 
arch/arm/\hyperlink{arch_2arm_2system_8cc}{system.cc}\end{DoxyCompactItemize}
