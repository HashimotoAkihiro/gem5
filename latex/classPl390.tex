\hypertarget{classPl390}{
\section{クラス Pl390}
\label{classPl390}\index{Pl390@{Pl390}}
}


{\ttfamily \#include $<$gic\_\-pl390.hh$>$}Pl390に対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=7cm]{classPl390}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classPl390_1_1PostIntEvent}{PostIntEvent}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef Pl390Params \hyperlink{classPl390_a1ac197c7f5e1a7b8d7178444a1474e45}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
const \hyperlink{classPl390_a1ac197c7f5e1a7b8d7178444a1474e45}{Params} $\ast$ \hyperlink{classPl390_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{classPl390_a0547d5a93535c7865012ca99652733c1}{Pl390} (const \hyperlink{classPl390_a1ac197c7f5e1a7b8d7178444a1474e45}{Params} $\ast$p)
\item 
virtual void \hyperlink{classPl390_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classPl390_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\begin{Indent}{\bf }\par
{\em \label{_amgrpd41d8cd98f00b204e9800998ecf8427e}
 }\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classPl390_a36cf113d5e5e091ebddb32306c098fae}{getAddrRanges} () const 
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classPl390_a613ec7d5e1ec64f8d21fec78ae8e568e}{read} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classPl390_a4cefab464e72b5dd42c003a0a4341802}{write} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classPl390_afbcaff37cd3cabac35c8fa0154de991f}{sendInt} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} number)
\item 
void \hyperlink{classPl390_a4780a1058316daff7b2c8f980c681101}{sendPPInt} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} num, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} cpu)
\item 
void \hyperlink{classPl390_a43d165dfc36b3fd1a965f2dc34eb1eda}{clearInt} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} number)
\item 
void \hyperlink{classPl390_a48c1db2ce97470c7d34ee199564c2929}{clearPPInt} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} num, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} cpu)
\item 
void \hyperlink{classPl390_a20535305eb1231d731f6f34a69e96d78}{driveSPI} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} spi)
\item 
void \hyperlink{classPl390_af2be17097e8a42c381ba82762df24562}{driveLegIRQ} (bool state)
\item 
void \hyperlink{classPl390_a113a9013ccbd1b5de2b9de1955ed009d}{driveLegFIQ} (bool state)
\item 
void \hyperlink{classPl390_a6bad935267245423d679e5138064ccba}{driveIrqEn} (bool state)
\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classPl390_aa9b0863223c08e95ba11ad9fce05f3fe}{BitUnion32} (SWI) Bitfield$<$3
\item 
\hyperlink{classPl390_a094c748f681520d1c676cc22f9542515}{EndBitUnion} (SWI) BitUnion32(IAR) Bitfield$<$9
\item 
\hyperlink{classPl390_af3e922c98e5df31ce49f179286cf9d48}{EndBitUnion} (IAR) \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} distAddr
\item 
void \hyperlink{classPl390_a682f28e23fc12360ec124caecc0247dd}{softInt} (int ctx\_\-id, SWI swi)
\item 
void \hyperlink{classPl390_affe49b35938d140039c9e4f8aac94409}{updateIntState} (int hint)
\item 
void \hyperlink{classPl390_a036668b76c53cab82ed983b838667b23}{updateRunPri} ()
\item 
uint64\_\-t \hyperlink{classPl390_a049810caa3741b4b2735ef8b793d4715}{genSwiMask} (int cpu)
\item 
int \hyperlink{classPl390_a297a4fe16fb79c127baa3558efb81261}{intNumToWord} (int num) const 
\item 
int \hyperlink{classPl390_a3ea7cede01d4b5413a1f54d9375d9c82}{intNumToBit} (int num) const 
\item 
void \hyperlink{classPl390_a3c861ed28942d7d4b1f556c221da9e0f}{postInt} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} cpu, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} when)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classPl390_a4eccad5b19d64abe6178573f999b2b3b}{readDistributor} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classPl390_a84ba155f907b634fa25ff18617946445}{readCpu} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classPl390_a1142f717b26e0ca228aa41f04a8c9b9c}{readMsix} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classPl390_aa2bced1a2b305cd5aa2e0f9fed1e1e2b}{writeDistributor} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classPl390_a1a1ae570cfae6908672073193a14ef6a}{writeCpu} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classPl390_a5842952b3d66843d825fc907816c9647}{writeMsix} (\hyperlink{classPacket}{PacketPtr} pkt)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classPl390_af2b76f78cc36e39f8782a67aa03afbd0}{sgi\_\-id}
\item 
Bitfield$<$ 23, 16 $>$ \hyperlink{classPl390_ae08ec5adcf38877d9f146a34871930c3}{cpu\_\-list}
\item 
Bitfield$<$ 25, 24 $>$ \hyperlink{classPl390_a6b56e232dd8fd3da34e2900f7f06039d}{list\_\-type}
\item 
\hyperlink{classPl390_ab1d4b1ab244021ea7a23b2cbcd2fbdb9}{ack\_\-id}
\item 
Bitfield$<$ 12, 10 $>$ \hyperlink{classPl390_a0fde3389d812c2863113c78e0d23108a}{cpu\_\-id}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classPl390_a604af0bb85a2a3f90c842febc7e8f87d}{cpuAddr}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classPl390_ab55f6a058ccebacb16d2032b086703af}{distPioDelay}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classPl390_a50352a1f6d1032a4be9c5884616a3233}{cpuPioDelay}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classPl390_a8acb46f8ecab4551225777951a774a62}{intLatency}
\item 
bool \hyperlink{classPl390_a8740ba80e30dd75e71d09fa1dcf04f3d}{enabled}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classPl390_a21dc662678d340891a1d579bf78955ce}{itLines}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classPl390_a6d73a4f61a4306d3aff3e9571eeccf47}{itLinesLog2}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classPl390_a1bce6fc9f9b30623d11815ada1bd4f56}{intEnabled} \mbox{[}\hyperlink{classPl390_ac0434966a31be307b3b2acd8975a169b}{INT\_\-BITS\_\-MAX}\mbox{]}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classPl390_a4a5f5a9735da74511b9d4e02c4ace364}{pendingInt} \mbox{[}\hyperlink{classPl390_ac0434966a31be307b3b2acd8975a169b}{INT\_\-BITS\_\-MAX}\mbox{]}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classPl390_a48d93d135c28a30df624e36d86856ab8}{activeInt} \mbox{[}\hyperlink{classPl390_ac0434966a31be307b3b2acd8975a169b}{INT\_\-BITS\_\-MAX}\mbox{]}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classPl390_afc5683cf049c7151320031fb200a4983}{iccrpr} \mbox{[}\hyperlink{classPl390_a4b102c882c8ecd5172c3f918fcde9c6d}{CPU\_\-MAX}\mbox{]}
\item 
uint8\_\-t \hyperlink{classPl390_a4f1f81194c08a716e3583d73588952c2}{intPriority} \mbox{[}\hyperlink{classPl390_a0158de396428c6145312576a210f1a59}{INT\_\-LINES\_\-MAX}\mbox{]}
\item 
uint8\_\-t \hyperlink{classPl390_aedf9bee3143d433dfabe7bc84f574df6}{cpuTarget} \mbox{[}\hyperlink{classPl390_a0158de396428c6145312576a210f1a59}{INT\_\-LINES\_\-MAX}\mbox{]}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classPl390_a0e6a663caacdba2b0b9192c0e2c8c315}{intConfig} \mbox{[}\hyperlink{classPl390_ac0434966a31be307b3b2acd8975a169b}{INT\_\-BITS\_\-MAX} $\ast$2\mbox{]}
\item 
bool \hyperlink{classPl390_aba2c5a4460094266172ecd62908b8724}{cpuEnabled} \mbox{[}\hyperlink{classPl390_a4b102c882c8ecd5172c3f918fcde9c6d}{CPU\_\-MAX}\mbox{]}
\item 
uint8\_\-t \hyperlink{classPl390_a8d3092e01e51b8ee0dd9787a9e44b795}{cpuPriority} \mbox{[}\hyperlink{classPl390_a4b102c882c8ecd5172c3f918fcde9c6d}{CPU\_\-MAX}\mbox{]}
\item 
uint8\_\-t \hyperlink{classPl390_ade84a14feb2db119b655dedf663ef829}{cpuBpr} \mbox{[}\hyperlink{classPl390_a4b102c882c8ecd5172c3f918fcde9c6d}{CPU\_\-MAX}\mbox{]}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classPl390_abe05250acc13d01ea2f994f0a2f58720}{cpuHighestInt} \mbox{[}\hyperlink{classPl390_a4b102c882c8ecd5172c3f918fcde9c6d}{CPU\_\-MAX}\mbox{]}
\item 
uint64\_\-t \hyperlink{classPl390_a78fdfd8252d9d31df17bc7799f30650d}{cpuSgiPending} \mbox{[}\hyperlink{classPl390_ab882d232a4976cf54e9cb73b44e1988f}{SGI\_\-MAX}\mbox{]}
\item 
uint64\_\-t \hyperlink{classPl390_aa8be2dd249b8372cdddb56197778b7a8}{cpuSgiActive} \mbox{[}\hyperlink{classPl390_ab882d232a4976cf54e9cb73b44e1988f}{SGI\_\-MAX}\mbox{]}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classPl390_a301af4f8223a97310920fc36160fb26d}{cpuPpiPending} \mbox{[}\hyperlink{classPl390_a4b102c882c8ecd5172c3f918fcde9c6d}{CPU\_\-MAX}\mbox{]}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classPl390_ac682ea7abccde0f7267b5215fda1ed5c}{cpuPpiActive} \mbox{[}\hyperlink{classPl390_a4b102c882c8ecd5172c3f918fcde9c6d}{CPU\_\-MAX}\mbox{]}
\item 
uint8\_\-t \hyperlink{classPl390_a30d4209f73a9d8d2478774b12a477910}{bankedIntPriority} \mbox{[}\hyperlink{classPl390_a4b102c882c8ecd5172c3f918fcde9c6d}{CPU\_\-MAX}\mbox{]}\mbox{[}\hyperlink{classPl390_ab882d232a4976cf54e9cb73b44e1988f}{SGI\_\-MAX}+\hyperlink{classPl390_a5ff528d1355008104939d20af447bac8}{PPI\_\-MAX}\mbox{]}
\item 
bool \hyperlink{classPl390_a4dd3993efeb04a5d9c8a0820b4b09d67}{irqEnable}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classPl390_ae9eb70129c76fd704086093bcdd21471}{msixRegAddr}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classPl390_aa646cfd25d072cc06bfb25fc3cb18890}{msixReg}
\item 
\hyperlink{classPl390_1_1PostIntEvent}{PostIntEvent} $\ast$ \hyperlink{classPl390_a22e64a003aa14067af4bb07701cb88a5}{postIntEvent} \mbox{[}\hyperlink{classPl390_a4b102c882c8ecd5172c3f918fcde9c6d}{CPU\_\-MAX}\mbox{]}
\end{DoxyCompactItemize}
\subsection*{Static Protected 変数}
\begin{DoxyCompactItemize}
\item 
static const int \hyperlink{classPl390_a0438fcd6c355e9ee0f4dfbb52a8df185}{ICDDCR} = 0x000
\item 
static const int \hyperlink{classPl390_a0c58ee924126812674213e9fbb97956f}{ICDICTR} = 0x004
\item 
static const int \hyperlink{classPl390_a3eb18d588046d1093762d2dd79f6b563}{ICDIIDR} = 0x008
\item 
static const int \hyperlink{classPl390_a967e1ae96980f25524ea435853fe54d1}{ICDISER\_\-ST} = 0x100
\item 
static const int \hyperlink{classPl390_a0f76976aa74415dcd9aec96a1f70758a}{ICDISER\_\-ED} = 0x17c
\item 
static const int \hyperlink{classPl390_a56ca3d402724ba490eed116c059f4bf1}{ICDICER\_\-ST} = 0x180
\item 
static const int \hyperlink{classPl390_adaa1179ddc7a651be29f72be0e19c4d4}{ICDICER\_\-ED} = 0x1fc
\item 
static const int \hyperlink{classPl390_aeafca9a9f217ac149ec11d59cf25da9a}{ICDISPR\_\-ST} = 0x200
\item 
static const int \hyperlink{classPl390_a5f1357dca4f87c003ecd67e6ce2a6840}{ICDISPR\_\-ED} = 0x27c
\item 
static const int \hyperlink{classPl390_af8249cc4f3e77d812877de9557be0cd0}{ICDICPR\_\-ST} = 0x280
\item 
static const int \hyperlink{classPl390_a98f072638834510ed1fe555392dbdd30}{ICDICPR\_\-ED} = 0x2fc
\item 
static const int \hyperlink{classPl390_ada9ed9528249cdb6ce90174e180c6e83}{ICDABR\_\-ST} = 0x300
\item 
static const int \hyperlink{classPl390_a90ba1a5529bf96f4dbd87ac105fa4a22}{ICDABR\_\-ED} = 0x37c
\item 
static const int \hyperlink{classPl390_a1483278b83c758d54081d9e4646da369}{ICDIPR\_\-ST} = 0x400
\item 
static const int \hyperlink{classPl390_a28b5a0626045b2093fec240d94ce73ff}{ICDIPR\_\-ED} = 0x7f8
\item 
static const int \hyperlink{classPl390_ac442d8d76d06e1e3a49c415c328664c2}{ICDIPTR\_\-ST} = 0x800
\item 
static const int \hyperlink{classPl390_a083710529636f2bd1b38a28ea3afbbfd}{ICDIPTR\_\-ED} = 0xbf8
\item 
static const int \hyperlink{classPl390_ada234b18d9cde5ac83bbea077bc269de}{ICDICFR\_\-ST} = 0xc00
\item 
static const int \hyperlink{classPl390_ab23fa73d7d71a9d54ac1ea1ff4661770}{ICDICFR\_\-ED} = 0xcfc
\item 
static const int \hyperlink{classPl390_ab757c4be11b50f9a009aa08c958ea058}{ICDSGIR} = 0xf00
\item 
static const int \hyperlink{classPl390_a0a6bf9b44fc240861af4c98cb13b212b}{DIST\_\-SIZE} = 0xfff
\item 
static const int \hyperlink{classPl390_acb144a8d8dc35a2e9060d96bc329fa60}{ICCICR} = 0x00
\item 
static const int \hyperlink{classPl390_a00368b6d72a37a6a7f42e7922d289e76}{ICCPMR} = 0x04
\item 
static const int \hyperlink{classPl390_ace280dd5776899099ebfe4f7b7bbc01f}{ICCBPR} = 0x08
\item 
static const int \hyperlink{classPl390_a15b9d48b0d0fe3e5f21d98c5b3579e98}{ICCIAR} = 0x0C
\item 
static const int \hyperlink{classPl390_a3ab6be2302e161f611641bcb679f70c4}{ICCEOIR} = 0x10
\item 
static const int \hyperlink{classPl390_a0d94eb1e4c2f76f0bf84221f0862c6ae}{ICCRPR} = 0x14
\item 
static const int \hyperlink{classPl390_a39d3ddf778fa125d6e9aa3183a72cd06}{ICCHPIR} = 0x18
\item 
static const int \hyperlink{classPl390_a0d8e9d466c4efc33cfd7dc2fd2eb59eb}{ICCABPR} = 0x1c
\item 
static const int \hyperlink{classPl390_ae00448ead7cf78b11d87238f956b1532}{ICCIIDR} = 0xfc
\item 
static const int \hyperlink{classPl390_a628e4ead2feec06369292346fb8867d8}{CPU\_\-SIZE} = 0xff
\item 
static const int \hyperlink{classPl390_ab882d232a4976cf54e9cb73b44e1988f}{SGI\_\-MAX} = 16
\item 
static const int \hyperlink{classPl390_a5ff528d1355008104939d20af447bac8}{PPI\_\-MAX} = 16
\item 
static const int \hyperlink{classPl390_a5a2357b28c8821b1d9da7fc86a2e1e46}{SGI\_\-MASK} = 0xFFFF0000
\item 
static const int \hyperlink{classPl390_a7595fc36770609b9fef1a639ce0b3c84}{NN\_\-CONFIG\_\-MASK} = 0x55555555
\item 
static const int \hyperlink{classPl390_a4b102c882c8ecd5172c3f918fcde9c6d}{CPU\_\-MAX} = 8
\item 
static const int \hyperlink{classPl390_a5c2ca5d88991c1b1cd77340bf56fdaef}{SPURIOUS\_\-INT} = 1023
\item 
static const int \hyperlink{classPl390_ac0434966a31be307b3b2acd8975a169b}{INT\_\-BITS\_\-MAX} = 32
\item 
static const int \hyperlink{classPl390_a0158de396428c6145312576a210f1a59}{INT\_\-LINES\_\-MAX} = 1020
\item 
static const int \hyperlink{classPl390_a75f82acd63e66c4ab659e0889281e35b}{MSIX\_\-SR} = 0x0
\item 
static const int \hyperlink{classPl390_a6f1a976e6a4f72a669c64334981f2220}{MSIX\_\-SIZE} = 0x4
\end{DoxyCompactItemize}


\subsection{説明}
\begin{Desc}
\item[\hyperlink{todo__todo000054}{TODO}]this code only assumes one processor for now. Low word of intEnabled and pendingInt need to be replicated per CPU. bottom 31 interrupts (7 words) need to be replicated for for interrupt priority register, processor target registers interrupt config registers \end{Desc}


\subsection{型定義}
\hypertarget{classPl390_a1ac197c7f5e1a7b8d7178444a1474e45}{
\index{Pl390@{Pl390}!Params@{Params}}
\index{Params@{Params}!Pl390@{Pl390}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef Pl390Params {\bf Params}}}
\label{classPl390_a1ac197c7f5e1a7b8d7178444a1474e45}


\hyperlink{classBaseGic_aacf2140b95fc8c326a11f01521f5018d}{BaseGic}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classPl390_a0547d5a93535c7865012ca99652733c1}{
\index{Pl390@{Pl390}!Pl390@{Pl390}}
\index{Pl390@{Pl390}!Pl390@{Pl390}}
\subsubsection[{Pl390}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pl390} (const {\bf Params} $\ast$ {\em p})}}
\label{classPl390_a0547d5a93535c7865012ca99652733c1}



\begin{DoxyCode}
56     : BaseGic(p), distAddr(p->dist_addr),
57       cpuAddr(p->cpu_addr), distPioDelay(p->dist_pio_delay),
58       cpuPioDelay(p->cpu_pio_delay), intLatency(p->int_latency),
59       enabled(false), itLines(p->it_lines), irqEnable(false),
60       msixRegAddr(p->msix_addr),
61       msixReg(0x0)
62 {
63     itLinesLog2 = ceilLog2(itLines);
64 
65     for (int x = 0; x < CPU_MAX; x++) {
66         cpuEnabled[x] = false;
67         cpuPriority[x] = 0xff;
68         cpuBpr[x] = 0;
69         // Initialize cpu highest int
70         cpuHighestInt[x] = SPURIOUS_INT;
71         postIntEvent[x] = new PostIntEvent(x, p->platform);
72     }
73     DPRINTF(Interrupt, "cpuEnabled[0]=%d cpuEnabled[1]=%d\n", cpuEnabled[0],
74             cpuEnabled[1]);
75 
76     for (int x = 0; x < INT_BITS_MAX; x++) {
77         intEnabled[x] = 0;
78         pendingInt[x] = 0;
79         activeInt[x] = 0;
80     }
81 
82     for (int x = 0; x < INT_LINES_MAX; x++) {
83         intPriority[x] = 0;
84         cpuTarget[x] = 0;
85     }
86 
87     for (int x = 0; x < INT_BITS_MAX*2; x++) {
88         intConfig[x] = 0;
89     }
90 
91     for (int x = 0; x < SGI_MAX; x++) {
92         cpuSgiActive[x] = 0;
93         cpuSgiPending[x] = 0;
94     }
95     for (int x = 0; x < CPU_MAX; x++) {
96         cpuPpiActive[x] = 0;
97         cpuPpiPending[x] = 0;
98     }
99 
100     for (int i = 0; i < CPU_MAX; i++) {
101         for (int j = 0; j < (SGI_MAX + PPI_MAX); j++) {
102             bankedIntPriority[i][j] = 0;
103         }
104     }
105 
106     RealView *rv = dynamic_cast<RealView*>(p->platform);
107     assert(rv);
108     rv->setGic(this);
109 
110 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classPl390_aa9b0863223c08e95ba11ad9fce05f3fe}{
\index{Pl390@{Pl390}!BitUnion32@{BitUnion32}}
\index{BitUnion32@{BitUnion32}!Pl390@{Pl390}}
\subsubsection[{BitUnion32}]{\setlength{\rightskip}{0pt plus 5cm}BitUnion32 (SWI)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_aa9b0863223c08e95ba11ad9fce05f3fe}
\hypertarget{classPl390_a43d165dfc36b3fd1a965f2dc34eb1eda}{
\index{Pl390@{Pl390}!clearInt@{clearInt}}
\index{clearInt@{clearInt}!Pl390@{Pl390}}
\subsubsection[{clearInt}]{\setlength{\rightskip}{0pt plus 5cm}void clearInt ({\bf uint32\_\-t} {\em number})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPl390_a43d165dfc36b3fd1a965f2dc34eb1eda}
Clear an interrupt from a device that is connected to the \hyperlink{namespaceGic}{Gic} Depending on the configuration, the gic may de-\/assert it's cpu line 
\begin{DoxyParams}{引数}
\item[{\em number}]number of interrupt to send \end{DoxyParams}


\hyperlink{classBaseGic_a969450946c91b2daf6aa8ab1a60aa8c2}{BaseGic}を実装しています。


\begin{DoxyCode}
758 {
759     /* @todo assume edge triggered only at the moment. Nothing to do. */
760 }
\end{DoxyCode}
\hypertarget{classPl390_a48c1db2ce97470c7d34ee199564c2929}{
\index{Pl390@{Pl390}!clearPPInt@{clearPPInt}}
\index{clearPPInt@{clearPPInt}!Pl390@{Pl390}}
\subsubsection[{clearPPInt}]{\setlength{\rightskip}{0pt plus 5cm}void clearPPInt ({\bf uint32\_\-t} {\em num}, \/  {\bf uint32\_\-t} {\em cpu})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPl390_a48c1db2ce97470c7d34ee199564c2929}
Clear a (level-\/sensitive) PPI 

\hyperlink{classBaseGic_ad6b86158511bccf53411efea34fb8b9a}{BaseGic}を実装しています。


\begin{DoxyCode}
764 {
765     DPRINTF(Interrupt, "Clearing PPI %d, cpuTarget %#x: \n",
766             num, cpu);
767     cpuPpiPending[cpu] &= ~(1 << (num - SGI_MAX));
768     updateIntState(intNumToWord(num));
769 }
\end{DoxyCode}
\hypertarget{classPl390_a6bad935267245423d679e5138064ccba}{
\index{Pl390@{Pl390}!driveIrqEn@{driveIrqEn}}
\index{driveIrqEn@{driveIrqEn}!Pl390@{Pl390}}
\subsubsection[{driveIrqEn}]{\setlength{\rightskip}{0pt plus 5cm}void driveIrqEn (bool {\em state})}}
\label{classPl390_a6bad935267245423d679e5138064ccba}



\begin{DoxyCode}
894 {
895     irqEnable = state;
896     DPRINTF(GIC, " Enabling Irq\n");
897     updateIntState(-1);
898 }
\end{DoxyCode}
\hypertarget{classPl390_a113a9013ccbd1b5de2b9de1955ed009d}{
\index{Pl390@{Pl390}!driveLegFIQ@{driveLegFIQ}}
\index{driveLegFIQ@{driveLegFIQ}!Pl390@{Pl390}}
\subsubsection[{driveLegFIQ}]{\setlength{\rightskip}{0pt plus 5cm}void driveLegFIQ (bool {\em state})}}
\label{classPl390_a113a9013ccbd1b5de2b9de1955ed009d}



\begin{DoxyCode}
914 {
915     if (state)
916         platform->intrctrl->post(0, ArmISA::INT_FIQ, 0);
917     else platform->intrctrl->clear(0, ArmISA::INT_FIQ, 0);
918 }
\end{DoxyCode}
\hypertarget{classPl390_af2be17097e8a42c381ba82762df24562}{
\index{Pl390@{Pl390}!driveLegIRQ@{driveLegIRQ}}
\index{driveLegIRQ@{driveLegIRQ}!Pl390@{Pl390}}
\subsubsection[{driveLegIRQ}]{\setlength{\rightskip}{0pt plus 5cm}void driveLegIRQ (bool {\em state})}}
\label{classPl390_af2be17097e8a42c381ba82762df24562}



\begin{DoxyCode}
902 {
903     if (irqEnable && !(!enabled && cpuEnabled[0])) {
904         if (state) {
905             DPRINTF(GIC, "Driving Legacy Irq\n");
906             platform->intrctrl->post(0, ArmISA::INT_IRQ, 0);
907         }
908         else platform->intrctrl->clear(0, ArmISA::INT_IRQ, 0);
909     }
910 }
\end{DoxyCode}
\hypertarget{classPl390_a20535305eb1231d731f6f34a69e96d78}{
\index{Pl390@{Pl390}!driveSPI@{driveSPI}}
\index{driveSPI@{driveSPI}!Pl390@{Pl390}}
\subsubsection[{driveSPI}]{\setlength{\rightskip}{0pt plus 5cm}void driveSPI ({\bf uint32\_\-t} {\em spi})}}
\label{classPl390_a20535305eb1231d731f6f34a69e96d78}



\begin{DoxyCode}
884 {
885     DPRINTF(GIC, "Received SPI Vector:%x Enable: %d\n", spiVect, irqEnable);
886     pendingInt[1] |= spiVect;
887     if (irqEnable && enabled) {
888         updateIntState(-1);
889     }
890 }
\end{DoxyCode}
\hypertarget{classPl390_af3e922c98e5df31ce49f179286cf9d48}{
\index{Pl390@{Pl390}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!Pl390@{Pl390}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion (IAR)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_af3e922c98e5df31ce49f179286cf9d48}
Distributor address GIC listens at \hypertarget{classPl390_a094c748f681520d1c676cc22f9542515}{
\index{Pl390@{Pl390}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!Pl390@{Pl390}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion (SWI)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a094c748f681520d1c676cc22f9542515}
\hypertarget{classPl390_a049810caa3741b4b2735ef8b793d4715}{
\index{Pl390@{Pl390}!genSwiMask@{genSwiMask}}
\index{genSwiMask@{genSwiMask}!Pl390@{Pl390}}
\subsubsection[{genSwiMask}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t genSwiMask (int {\em cpu})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a049810caa3741b4b2735ef8b793d4715}
generate a bit mask to check cpuSgi for an interrupt. 


\begin{DoxyCode}
627 {
628     if (cpu > 7)
629         panic("Invalid CPU ID\n");
630     return ULL(0x0101010101010101) << cpu;
631 }
\end{DoxyCode}
\hypertarget{classPl390_a36cf113d5e5e091ebddb32306c098fae}{
\index{Pl390@{Pl390}!getAddrRanges@{getAddrRanges}}
\index{getAddrRanges@{getAddrRanges}!Pl390@{Pl390}}
\subsubsection[{getAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRangeList} getAddrRanges () const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPl390_a36cf113d5e5e091ebddb32306c098fae}
Return the address ranges used by the \hyperlink{namespaceGic}{Gic} This is the distributor address + all cpu addresses 

\hyperlink{classPioDevice_a6e967f8921e80748eb2be35b6b481a7e}{PioDevice}を実装しています。


\begin{DoxyCode}
780 {
781     AddrRangeList ranges;
782     ranges.push_back(RangeSize(distAddr, DIST_SIZE));
783     ranges.push_back(RangeSize(cpuAddr, CPU_SIZE));
784     if (msixRegAddr != 0) {
785         ranges.push_back(RangeSize(msixRegAddr, MSIX_SIZE));
786     }
787     return ranges;
788 }
\end{DoxyCode}
\hypertarget{classPl390_a3ea7cede01d4b5413a1f54d9375d9c82}{
\index{Pl390@{Pl390}!intNumToBit@{intNumToBit}}
\index{intNumToBit@{intNumToBit}!Pl390@{Pl390}}
\subsubsection[{intNumToBit}]{\setlength{\rightskip}{0pt plus 5cm}int intNumToBit (int {\em num}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classPl390_a3ea7cede01d4b5413a1f54d9375d9c82}



\begin{DoxyCode}
236 { return num % 32; }
\end{DoxyCode}
\hypertarget{classPl390_a297a4fe16fb79c127baa3558efb81261}{
\index{Pl390@{Pl390}!intNumToWord@{intNumToWord}}
\index{intNumToWord@{intNumToWord}!Pl390@{Pl390}}
\subsubsection[{intNumToWord}]{\setlength{\rightskip}{0pt plus 5cm}int intNumToWord (int {\em num}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classPl390_a297a4fe16fb79c127baa3558efb81261}



\begin{DoxyCode}
235 { return num >> 5; }
\end{DoxyCode}
\hypertarget{classPl390_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{Pl390@{Pl390}!params@{params}}
\index{params@{params}!Pl390@{Pl390}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classPl390_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classBaseGic_ad80365b3b51c15f44416b1b835b23570}{BaseGic}を再定義しています。


\begin{DoxyCode}
262     {
263         return dynamic_cast<const Params *>(_params);
264     }
\end{DoxyCode}
\hypertarget{classPl390_a3c861ed28942d7d4b1f556c221da9e0f}{
\index{Pl390@{Pl390}!postInt@{postInt}}
\index{postInt@{postInt}!Pl390@{Pl390}}
\subsubsection[{postInt}]{\setlength{\rightskip}{0pt plus 5cm}void postInt ({\bf uint32\_\-t} {\em cpu}, \/  {\bf Tick} {\em when})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a3c861ed28942d7d4b1f556c221da9e0f}
Post an interrupt to a CPU 


\begin{DoxyCode}
773 {
774     if (!(postIntEvent[cpu]->scheduled()))
775         eventq->schedule(postIntEvent[cpu], when);
776 }
\end{DoxyCode}
\hypertarget{classPl390_a613ec7d5e1ec64f8d21fec78ae8e568e}{
\index{Pl390@{Pl390}!read@{read}}
\index{read@{read}!Pl390@{Pl390}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} read ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPl390_a613ec7d5e1ec64f8d21fec78ae8e568e}
A PIO read to the device, immediately split up into \hyperlink{classPl390_a4eccad5b19d64abe6178573f999b2b3b}{readDistributor()} or \hyperlink{classPl390_a84ba155f907b634fa25ff18617946445}{readCpu()} 

\hyperlink{classPioDevice_a842312590432036092c422c87a442358}{PioDevice}を実装しています。


\begin{DoxyCode}
114 {
115 
116     Addr addr = pkt->getAddr();
117 
118     if (addr >= distAddr && addr < distAddr + DIST_SIZE)
119         return readDistributor(pkt);
120     else if (addr >= cpuAddr && addr < cpuAddr + CPU_SIZE)
121         return readCpu(pkt);
122     else if (msixRegAddr != 0x0 &&
123              addr >= msixRegAddr &&
124              addr < msixRegAddr + MSIX_SIZE)
125         return readMsix(pkt);
126     else
127         panic("Read to unknown address %#x\n", pkt->getAddr());
128 }
\end{DoxyCode}
\hypertarget{classPl390_a84ba155f907b634fa25ff18617946445}{
\index{Pl390@{Pl390}!readCpu@{readCpu}}
\index{readCpu@{readCpu}!Pl390@{Pl390}}
\subsubsection[{readCpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} readCpu ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a84ba155f907b634fa25ff18617946445}
Handle a read to the cpu poriton of the GIC 
\begin{DoxyParams}{引数}
\item[{\em pkt}]packet to respond to \end{DoxyParams}



\begin{DoxyCode}
285 {
286     Addr daddr = pkt->getAddr() - cpuAddr;
287     pkt->allocate();
288 
289     assert(pkt->req->hasContextId());
290     int ctx_id = pkt->req->contextId();
291     assert(ctx_id < sys->numRunningContexts());
292 
293     DPRINTF(GIC, "gic cpu read register %#x cpu context: %d\n", daddr,
294             ctx_id);
295 
296     switch(daddr) {
297       case ICCICR:
298         pkt->set<uint32_t>(cpuEnabled[ctx_id]);
299         break;
300       case ICCPMR:
301         pkt->set<uint32_t>(cpuPriority[ctx_id]);
302         break;
303       case ICCBPR:
304         pkt->set<uint32_t>(cpuBpr[ctx_id]);
305         break;
306       case ICCIAR:
307         if (enabled && cpuEnabled[ctx_id]) {
308             int active_int = cpuHighestInt[ctx_id];
309             IAR iar = 0;
310             iar.ack_id = active_int;
311             iar.cpu_id = 0;
312             if (active_int < SGI_MAX) {
313                 // this is a software interrupt from another CPU
314                 if (!cpuSgiPending[active_int])
315                     panic("Interrupt %d active but no CPU generated it?\n",
316                             active_int);
317                 for (int x = 0; x < CPU_MAX; x++) {
318                     // See which CPU generated the interrupt
319                     uint8_t cpugen =
320                         bits(cpuSgiPending[active_int], 7 + 8 * x, 8 * x);
321                     if (cpugen & (1 << ctx_id)) {
322                         iar.cpu_id = x;
323                         break;
324                     }
325                 }
326                 uint64_t sgi_num = ULL(1) << (ctx_id + 8 * iar.cpu_id);
327                 cpuSgiActive[iar.ack_id] |= sgi_num;
328                 cpuSgiPending[iar.ack_id] &= ~sgi_num;
329             } else if (active_int < (SGI_MAX + PPI_MAX) ) {
330                 uint32_t int_num = 1 << (cpuHighestInt[ctx_id] - SGI_MAX);
331                 cpuPpiActive[ctx_id] |= int_num;
332                 updateRunPri();
333                 cpuPpiPending[ctx_id] &= ~int_num;
334 
335             } else {
336                 uint32_t int_num = 1 << intNumToBit(cpuHighestInt[ctx_id]);
337                 activeInt[intNumToWord(cpuHighestInt[ctx_id])] |= int_num;
338                 updateRunPri();
339                 pendingInt[intNumToWord(cpuHighestInt[ctx_id])] &= ~int_num;
340             }
341 
342             DPRINTF(Interrupt,"CPU %d reading IAR.id=%d IAR.cpu=%d, iar=0x%x\n",
343                     ctx_id, iar.ack_id, iar.cpu_id, iar);
344             cpuHighestInt[ctx_id] = SPURIOUS_INT;
345             updateIntState(-1);
346             pkt->set<uint32_t>(iar);
347             platform->intrctrl->clear(ctx_id, ArmISA::INT_IRQ, 0);
348         } else {
349              pkt->set<uint32_t>(SPURIOUS_INT);
350         }
351 
352         break;
353       case ICCRPR:
354         pkt->set<uint32_t>(iccrpr[0]);
355         break;
356       case ICCHPIR:
357         pkt->set<uint32_t>(0);
358         panic("Need to implement HPIR");
359         break;
360       default:
361         panic("Tried to read Gic cpu at offset %#x\n", daddr);
362         break;
363     }
364     pkt->makeAtomicResponse();
365     return cpuPioDelay;
366 }
\end{DoxyCode}
\hypertarget{classPl390_a4eccad5b19d64abe6178573f999b2b3b}{
\index{Pl390@{Pl390}!readDistributor@{readDistributor}}
\index{readDistributor@{readDistributor}!Pl390@{Pl390}}
\subsubsection[{readDistributor}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} readDistributor ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a4eccad5b19d64abe6178573f999b2b3b}
Handle a read to the distributor poriton of the GIC 
\begin{DoxyParams}{引数}
\item[{\em pkt}]packet to respond to \end{DoxyParams}


\begin{Desc}
\item[\hyperlink{todo__todo000053}{TODO}]software generated interrutps and PPIs can't be configured in some ways \end{Desc}



\begin{DoxyCode}
151 {
152     Addr daddr = pkt->getAddr() - distAddr;
153     pkt->allocate();
154 
155     int ctx_id = pkt->req->contextId();
156 
157     DPRINTF(GIC, "gic distributor read register %#x\n", daddr);
158 
159     if (daddr >= ICDISER_ST && daddr < ICDISER_ED + 4) {
160         assert((daddr-ICDISER_ST) >> 2 < 32);
161         pkt->set<uint32_t>(intEnabled[(daddr-ICDISER_ST)>>2]);
162         goto done;
163     }
164 
165     if (daddr >= ICDICER_ST && daddr < ICDICER_ED + 4) {
166         assert((daddr-ICDICER_ST) >> 2 < 32);
167         pkt->set<uint32_t>(intEnabled[(daddr-ICDICER_ST)>>2]);
168         goto done;
169     }
170 
171     if (daddr >= ICDISPR_ST && daddr < ICDISPR_ED + 4) {
172         assert((daddr-ICDISPR_ST) >> 2 < 32);
173         pkt->set<uint32_t>(pendingInt[(daddr-ICDISPR_ST)>>2]);
174         goto done;
175     }
176 
177     if (daddr >= ICDICPR_ST && daddr < ICDICPR_ED + 4) {
178         assert((daddr-ICDICPR_ST) >> 2 < 32);
179         pkt->set<uint32_t>(pendingInt[(daddr-ICDICPR_ST)>>2]);
180         goto done;
181     }
182 
183     if (daddr >= ICDABR_ST && daddr < ICDABR_ED + 4) {
184         assert((daddr-ICDABR_ST) >> 2 < 32);
185         pkt->set<uint32_t>(activeInt[(daddr-ICDABR_ST)>>2]);
186         goto done;
187     }
188 
189     if (daddr >= ICDIPR_ST && daddr < ICDIPR_ED + 4) {
190         Addr int_num;
191         int_num = daddr - ICDIPR_ST;
192         assert(int_num < INT_LINES_MAX);
193         DPRINTF(Interrupt, "Reading interrupt priority at int# %#x \n",int_num);
194 
195         uint8_t* int_p;
196         if (int_num < (SGI_MAX + PPI_MAX))
197             int_p = bankedIntPriority[ctx_id];
198         else
199             int_p = intPriority;
200 
201         switch (pkt->getSize()) {
202           case 1:
203             pkt->set<uint8_t>(int_p[int_num]);
204             break;
205           case 2:
206             assert((int_num + 1) < INT_LINES_MAX);
207             pkt->set<uint16_t>(int_p[int_num] |
208                                int_p[int_num+1] << 8);
209             break;
210           case 4:
211             assert((int_num + 3) < INT_LINES_MAX);
212             pkt->set<uint32_t>(int_p[int_num] |
213                                int_p[int_num+1] << 8 |
214                                int_p[int_num+2] << 16 |
215                                int_p[int_num+3] << 24);
216             break;
217           default:
218             panic("Invalid size while reading priority regs in GIC: %d\n",
219                    pkt->getSize());
220         }
221         goto done;
222     }
223 
224     if (daddr >= ICDIPTR_ST && daddr < ICDIPTR_ED + 4) {
225         Addr int_num;
226         int_num = (daddr-ICDIPTR_ST) ;
227         DPRINTF(GIC, "Reading processor target register for int# %#x \n",
228                  int_num);
229         assert(int_num < INT_LINES_MAX);
230 
231         // First 31 interrupts only target single processor (SGI)
232         if (int_num > 31) {
233             if (pkt->getSize() == 1) {
234                 pkt->set<uint8_t>(cpuTarget[int_num]);
235             } else {
236                 assert(pkt->getSize() == 4);
237                 int_num = mbits(int_num, 31, 2);
238                 pkt->set<uint32_t>(cpuTarget[int_num] |
239                                    cpuTarget[int_num+1] << 8 |
240                                    cpuTarget[int_num+2] << 16 |
241                                    cpuTarget[int_num+3] << 24) ;
242             }
243         } else {
244             assert(ctx_id < sys->numRunningContexts());
245             // convert the CPU id number into a bit mask
246             uint32_t ctx_mask = power(2, ctx_id);
247             // replicate the 8-bit mask 4 times in a 32-bit word
248             ctx_mask |= ctx_mask << 8;
249             ctx_mask |= ctx_mask << 16;
250             pkt->set<uint32_t>(ctx_mask);
251         }
252         goto done;
253     }
254 
255     if (daddr >= ICDICFR_ST && daddr < ICDICFR_ED + 4) {
256         assert((daddr-ICDICFR_ST) >> 2 < 64);
260         pkt->set<uint32_t>(intConfig[(daddr-ICDICFR_ST)>>2]);
261         goto done;
262     }
263 
264     switch(daddr) {
265       case ICDDCR:
266         pkt->set<uint32_t>(enabled);
267         break;
268       case ICDICTR:
269         uint32_t tmp;
270         tmp = ((sys->numRunningContexts() - 1) << 5) |
271               (itLines/INT_BITS_MAX -1);
272         pkt->set<uint32_t>(tmp);
273         break;
274       default:
275         panic("Tried to read Gic distributor at offset %#x\n", daddr);
276         break;
277     }
278 done:
279     pkt->makeAtomicResponse();
280     return distPioDelay;
281 }
\end{DoxyCode}
\hypertarget{classPl390_a1142f717b26e0ca228aa41f04a8c9b9c}{
\index{Pl390@{Pl390}!readMsix@{readMsix}}
\index{readMsix@{readMsix}!Pl390@{Pl390}}
\subsubsection[{readMsix}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} readMsix ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a1142f717b26e0ca228aa41f04a8c9b9c}
Handle a read to the MSI-\/X register on the GIC 
\begin{DoxyParams}{引数}
\item[{\em pkt}]packet to respond to \end{DoxyParams}



\begin{DoxyCode}
370 {
371     Addr daddr = pkt->getAddr() - msixRegAddr;
372     pkt->allocate();
373 
374     DPRINTF(GIC, "Gic MSIX read register %#x\n", daddr);
375 
376     switch (daddr) {
377         case MSIX_SR:
378             pkt->set<uint32_t>(msixReg);
379             break;
380         default:
381             panic("Tried to read Gic MSIX register at offset %#x\n", daddr);
382             break;
383     }
384 
385     pkt->makeAtomicResponse();
386     return distPioDelay;
387 }
\end{DoxyCode}
\hypertarget{classPl390_afbcaff37cd3cabac35c8fa0154de991f}{
\index{Pl390@{Pl390}!sendInt@{sendInt}}
\index{sendInt@{sendInt}!Pl390@{Pl390}}
\subsubsection[{sendInt}]{\setlength{\rightskip}{0pt plus 5cm}void sendInt ({\bf uint32\_\-t} {\em number})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPl390_afbcaff37cd3cabac35c8fa0154de991f}
Post an interrupt from a device that is connected to the \hyperlink{namespaceGic}{Gic}. Depending on the configuration, the gic will pass this interrupt on through to a CPU. 
\begin{DoxyParams}{引数}
\item[{\em number}]number of interrupt to send \end{DoxyParams}


\hyperlink{classBaseGic_ad6b2cb6b9a108c3852cb5a88126e5320}{BaseGic}を実装しています。


\begin{DoxyCode}
737 {
738     DPRINTF(Interrupt, "Received Interupt number %d,  cpuTarget %#x: \n",
739             num, cpuTarget[num]);
740     if (cpuTarget[num] & (cpuTarget[num] - 1))
741         panic("Multiple targets for peripheral interrupts is not supported\n");
742     pendingInt[intNumToWord(num)] |= 1 << intNumToBit(num);
743     updateIntState(intNumToWord(num));
744 
745 }
\end{DoxyCode}
\hypertarget{classPl390_a4780a1058316daff7b2c8f980c681101}{
\index{Pl390@{Pl390}!sendPPInt@{sendPPInt}}
\index{sendPPInt@{sendPPInt}!Pl390@{Pl390}}
\subsubsection[{sendPPInt}]{\setlength{\rightskip}{0pt plus 5cm}void sendPPInt ({\bf uint32\_\-t} {\em num}, \/  {\bf uint32\_\-t} {\em cpu})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPl390_a4780a1058316daff7b2c8f980c681101}
Interface call for private peripheral interrupts 

\hyperlink{classBaseGic_a89cc9c4f60c3456dca807a71da1e04a8}{BaseGic}を実装しています。


\begin{DoxyCode}
749 {
750     DPRINTF(Interrupt, "Received PPI %d, cpuTarget %#x: \n",
751             num, cpu);
752     cpuPpiPending[cpu] |= 1 << (num - SGI_MAX);
753     updateIntState(intNumToWord(num));
754 }
\end{DoxyCode}
\hypertarget{classPl390_a53e036786d17361be4c7320d39c99b84}{
\index{Pl390@{Pl390}!serialize@{serialize}}
\index{serialize@{serialize}!Pl390@{Pl390}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPl390_a53e036786d17361be4c7320d39c99b84}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。


\begin{DoxyCode}
793 {
794     DPRINTF(Checkpoint, "Serializing Arm GIC\n");
795 
796     SERIALIZE_SCALAR(distAddr);
797     SERIALIZE_SCALAR(cpuAddr);
798     SERIALIZE_SCALAR(distPioDelay);
799     SERIALIZE_SCALAR(cpuPioDelay);
800     SERIALIZE_SCALAR(enabled);
801     SERIALIZE_SCALAR(itLines);
802     SERIALIZE_SCALAR(itLinesLog2);
803     SERIALIZE_SCALAR(msixRegAddr);
804     SERIALIZE_SCALAR(msixReg);
805     SERIALIZE_ARRAY(intEnabled, INT_BITS_MAX);
806     SERIALIZE_ARRAY(pendingInt, INT_BITS_MAX);
807     SERIALIZE_ARRAY(activeInt, INT_BITS_MAX);
808     SERIALIZE_ARRAY(iccrpr, CPU_MAX);
809     SERIALIZE_ARRAY(intPriority, INT_LINES_MAX);
810     SERIALIZE_ARRAY(cpuTarget, INT_LINES_MAX);
811     SERIALIZE_ARRAY(intConfig, INT_BITS_MAX * 2);
812     SERIALIZE_ARRAY(cpuEnabled, CPU_MAX);
813     SERIALIZE_ARRAY(cpuPriority, CPU_MAX);
814     SERIALIZE_ARRAY(cpuBpr, CPU_MAX);
815     SERIALIZE_ARRAY(cpuHighestInt, CPU_MAX);
816     SERIALIZE_ARRAY(cpuSgiActive, SGI_MAX);
817     SERIALIZE_ARRAY(cpuSgiPending, SGI_MAX);
818     SERIALIZE_ARRAY(cpuPpiActive, CPU_MAX);
819     SERIALIZE_ARRAY(cpuPpiPending, CPU_MAX);
820     SERIALIZE_ARRAY(*bankedIntPriority, CPU_MAX * (SGI_MAX + PPI_MAX));
821     SERIALIZE_SCALAR(irqEnable);
822     Tick interrupt_time[CPU_MAX];
823     for (uint32_t cpu = 0; cpu < CPU_MAX; cpu++) {
824         interrupt_time[cpu] = 0;
825         if (postIntEvent[cpu]->scheduled()) {
826             interrupt_time[cpu] = postIntEvent[cpu]->when();
827         }
828     }
829     SERIALIZE_ARRAY(interrupt_time, CPU_MAX);
830 
831 }
\end{DoxyCode}
\hypertarget{classPl390_a682f28e23fc12360ec124caecc0247dd}{
\index{Pl390@{Pl390}!softInt@{softInt}}
\index{softInt@{softInt}!Pl390@{Pl390}}
\subsubsection[{softInt}]{\setlength{\rightskip}{0pt plus 5cm}void softInt (int {\em ctx\_\-id}, \/  SWI {\em swi})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a682f28e23fc12360ec124caecc0247dd}
software generated interrupt 
\begin{DoxyParams}{引数}
\item[{\em data}]data to decode that indicates which cpus to interrupt \end{DoxyParams}



\begin{DoxyCode}
595 {
596     switch (swi.list_type) {
597       case 1:
598         // interrupt all
599         uint8_t cpu_list;
600         cpu_list = 0;
601         for (int x = 0; x < CPU_MAX; x++)
602             cpu_list |= cpuEnabled[x] ? 1 << x : 0;
603         swi.cpu_list = cpu_list;
604         break;
605       case 2:
606         // interrupt requesting cpu only
607         swi.cpu_list = 1 << ctx_id;
608         break;
609         // else interrupt cpus specified
610     }
611 
612     DPRINTF(IPI, "Generating softIRQ from CPU %d for %#x\n", ctx_id,
613             swi.cpu_list);
614     for (int i = 0; i < CPU_MAX; i++) {
615         DPRINTF(IPI, "Processing CPU %d\n", i);
616         if (!cpuEnabled[i])
617             continue;
618         if (swi.cpu_list & (1 << i))
619             cpuSgiPending[swi.sgi_id] |= (1 << i) << (8 * ctx_id);
620         DPRINTF(IPI, "SGI[%d]=%#x\n", swi.sgi_id, cpuSgiPending[swi.sgi_id]);
621     }
622     updateIntState(-1);
623 }
\end{DoxyCode}
\hypertarget{classPl390_af22e5d6d660b97db37003ac61ac4ee49}{
\index{Pl390@{Pl390}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!Pl390@{Pl390}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPl390_af22e5d6d660b97db37003ac61ac4ee49}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。


\begin{DoxyCode}
835 {
836     DPRINTF(Checkpoint, "Unserializing Arm GIC\n");
837 
838     UNSERIALIZE_SCALAR(distAddr);
839     UNSERIALIZE_SCALAR(cpuAddr);
840     UNSERIALIZE_SCALAR(distPioDelay);
841     UNSERIALIZE_SCALAR(cpuPioDelay);
842     UNSERIALIZE_SCALAR(enabled);
843     UNSERIALIZE_SCALAR(itLines);
844     UNSERIALIZE_SCALAR(itLinesLog2);
845     UNSERIALIZE_SCALAR(msixRegAddr);
846     UNSERIALIZE_SCALAR(msixReg);
847     UNSERIALIZE_ARRAY(intEnabled, INT_BITS_MAX);
848     UNSERIALIZE_ARRAY(pendingInt, INT_BITS_MAX);
849     UNSERIALIZE_ARRAY(activeInt, INT_BITS_MAX);
850     UNSERIALIZE_ARRAY(iccrpr, CPU_MAX);
851     UNSERIALIZE_ARRAY(intPriority, INT_LINES_MAX);
852     UNSERIALIZE_ARRAY(cpuTarget, INT_LINES_MAX);
853     UNSERIALIZE_ARRAY(intConfig, INT_BITS_MAX * 2);
854     UNSERIALIZE_ARRAY(cpuEnabled, CPU_MAX);
855     UNSERIALIZE_ARRAY(cpuPriority, CPU_MAX);
856     UNSERIALIZE_ARRAY(cpuBpr, CPU_MAX);
857     UNSERIALIZE_ARRAY(cpuHighestInt, CPU_MAX);
858     UNSERIALIZE_ARRAY(cpuSgiActive, SGI_MAX);
859     UNSERIALIZE_ARRAY(cpuSgiPending, SGI_MAX);
860     UNSERIALIZE_ARRAY(cpuPpiActive, CPU_MAX);
861     UNSERIALIZE_ARRAY(cpuPpiPending, CPU_MAX);
862     UNSERIALIZE_ARRAY(*bankedIntPriority, CPU_MAX * (SGI_MAX + PPI_MAX));
863     UNSERIALIZE_SCALAR(irqEnable);
864 
865     Tick interrupt_time[CPU_MAX];
866     UNSERIALIZE_ARRAY(interrupt_time, CPU_MAX);
867 
868     for (uint32_t cpu = 0; cpu < CPU_MAX; cpu++) {
869         if (interrupt_time[cpu])
870             schedule(postIntEvent[cpu], interrupt_time[cpu]);
871     }
872 
873 }
\end{DoxyCode}
\hypertarget{classPl390_affe49b35938d140039c9e4f8aac94409}{
\index{Pl390@{Pl390}!updateIntState@{updateIntState}}
\index{updateIntState@{updateIntState}!Pl390@{Pl390}}
\subsubsection[{updateIntState}]{\setlength{\rightskip}{0pt plus 5cm}void updateIntState (int {\em hint})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_affe49b35938d140039c9e4f8aac94409}
See if some processor interrupt flags need to be enabled/disabled 
\begin{DoxyParams}{引数}
\item[{\em hint}]which set of interrupts needs to be checked \end{DoxyParams}



\begin{DoxyCode}
635 {
636     for (int cpu = 0; cpu < CPU_MAX; cpu++) {
637         if (!cpuEnabled[cpu])
638             continue;
639         if (cpu >= sys->numContexts())
640             break;
641 
642         /*@todo use hint to do less work. */
643         int highest_int = SPURIOUS_INT;
644         // Priorities below that set in ICCPMR can be ignored
645         uint8_t highest_pri = cpuPriority[cpu];
646 
647         // Check SGIs
648         for (int swi = 0; swi < SGI_MAX; swi++) {
649             if (!cpuSgiPending[swi])
650                 continue;
651             if (cpuSgiPending[swi] & genSwiMask(cpu))
652                 if (highest_pri > bankedIntPriority[cpu][swi]) {
653                     highest_pri = bankedIntPriority[cpu][swi];
654                     highest_int = swi;
655                 }
656         }
657 
658         // Check PPIs
659         if (cpuPpiPending[cpu]) {
660         for (int ppi = 0; ppi < PPI_MAX; ppi++) {
661             if (cpuPpiPending[cpu] & (1 << ppi))
662                 if (highest_pri > bankedIntPriority[cpu][SGI_MAX + ppi]) {
663                     highest_pri = bankedIntPriority[cpu][SGI_MAX + ppi];
664                     highest_int = SGI_MAX + ppi;
665                 }
666             }
667         }
668 
669         bool mp_sys = sys->numRunningContexts() > 1;
670         // Check other ints
671         for (int x = 0; x < (itLines/INT_BITS_MAX); x++) {
672             if (intEnabled[x] & pendingInt[x]) {
673                 for (int y = 0; y < INT_BITS_MAX; y++) {
674                    uint32_t int_nm = x * INT_BITS_MAX + y;
675                    DPRINTF(GIC, "Checking for interrupt# %d \n",int_nm);
676                     /* Set current pending int as highest int for current cpu
677                        if the interrupt's priority higher than current prioirty
678                        and if currrent cpu is the target (for mp configs only)
679                      */
680                     if ((bits(intEnabled[x], y) & bits(pendingInt[x], y)) &&
681                         (intPriority[int_nm] < highest_pri))
682                         if ( (!mp_sys) || (cpuTarget[int_nm] & (1 << cpu))) {
683                             highest_pri = intPriority[int_nm];
684                             highest_int = int_nm;
685                         }
686                 }
687             }
688         }
689 
690         cpuHighestInt[cpu] = highest_int;
691 
692         if (highest_int == SPURIOUS_INT)
693             continue;
694 
695         /* @todo make this work for more than one cpu, need to handle 1:N, N:N
696          * models */
697         if (enabled && cpuEnabled[cpu] && (highest_pri < cpuPriority[cpu]) &&
698             !(activeInt[intNumToWord(highest_int)]
699             & (1 << intNumToBit(highest_int)))) {
700 
701             DPRINTF(Interrupt, "Posting interrupt %d to cpu%d\n", highest_int,
702                     cpu);
703             postInt(cpu, curTick() + intLatency);
704         }
705     }
706 }
\end{DoxyCode}
\hypertarget{classPl390_a036668b76c53cab82ed983b838667b23}{
\index{Pl390@{Pl390}!updateRunPri@{updateRunPri}}
\index{updateRunPri@{updateRunPri}!Pl390@{Pl390}}
\subsubsection[{updateRunPri}]{\setlength{\rightskip}{0pt plus 5cm}void updateRunPri ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a036668b76c53cab82ed983b838667b23}
Update the register that records priority of the highest priority active interrupt 


\begin{DoxyCode}
710 {
711     for (int cpu = 0; cpu < CPU_MAX; cpu++) {
712         if (!cpuEnabled[cpu])
713             continue;
714         uint8_t maxPriority = 0xff;
715         for (int i = 0; i < itLines; i++){
716             if (i < SGI_MAX) {
717                 if ((cpuSgiActive[i] & genSwiMask(cpu)) &&
718                         (bankedIntPriority[cpu][i] < maxPriority))
719                     maxPriority = bankedIntPriority[cpu][i];
720             } else if (i < (SGI_MAX + PPI_MAX)) {
721                 if ((cpuPpiActive[cpu] & ( 1 << (i - SGI_MAX))) &&
722                         (bankedIntPriority[cpu][i] < maxPriority))
723                     maxPriority = bankedIntPriority[cpu][i];
724 
725             } else {
726                 if (activeInt[intNumToWord(i)] & (1 << intNumToBit(i)))
727                     if (intPriority[i] < maxPriority)
728                         maxPriority = intPriority[i];
729             }
730         }
731         iccrpr[cpu] = maxPriority;
732     }
733 }
\end{DoxyCode}
\hypertarget{classPl390_a4cefab464e72b5dd42c003a0a4341802}{
\index{Pl390@{Pl390}!write@{write}}
\index{write@{write}!Pl390@{Pl390}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} write ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPl390_a4cefab464e72b5dd42c003a0a4341802}
A PIO read to the device, immediately split up into \hyperlink{classPl390_aa2bced1a2b305cd5aa2e0f9fed1e1e2b}{writeDistributor()} or \hyperlink{classPl390_a1a1ae570cfae6908672073193a14ef6a}{writeCpu()} 

\hyperlink{classPioDevice_afe8371668d023bb2516b286e5e399b6f}{PioDevice}を実装しています。


\begin{DoxyCode}
133 {
134 
135     Addr addr = pkt->getAddr();
136 
137     if (addr >= distAddr && addr < distAddr + DIST_SIZE)
138         return writeDistributor(pkt);
139     else if (addr >= cpuAddr && addr < cpuAddr + CPU_SIZE)
140         return writeCpu(pkt);
141     else if (msixRegAddr != 0x0 &&
142              addr >= msixRegAddr &&
143              addr < msixRegAddr + MSIX_SIZE)
144         return writeMsix(pkt);
145     else
146         panic("Write to unknown address %#x\n", pkt->getAddr());
147 }
\end{DoxyCode}
\hypertarget{classPl390_a1a1ae570cfae6908672073193a14ef6a}{
\index{Pl390@{Pl390}!writeCpu@{writeCpu}}
\index{writeCpu@{writeCpu}!Pl390@{Pl390}}
\subsubsection[{writeCpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} writeCpu ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a1a1ae570cfae6908672073193a14ef6a}
Handle a write to the cpu poriton of the GIC 
\begin{DoxyParams}{引数}
\item[{\em pkt}]packet to respond to \end{DoxyParams}



\begin{DoxyCode}
515 {
516     Addr daddr = pkt->getAddr() - cpuAddr;
517     pkt->allocate();
518 
519     assert(pkt->req->hasContextId());
520     int ctx_id = pkt->req->contextId();
521     IAR iar;
522 
523     DPRINTF(GIC, "gic cpu write register cpu:%d %#x val: %#x\n",
524             ctx_id, daddr, pkt->get<uint32_t>());
525 
526     switch(daddr) {
527       case ICCICR:
528         cpuEnabled[ctx_id] = pkt->get<uint32_t>();
529         break;
530       case ICCPMR:
531         cpuPriority[ctx_id] = pkt->get<uint32_t>();
532         break;
533       case ICCBPR:
534         cpuBpr[ctx_id] = pkt->get<uint32_t>();
535         break;
536       case ICCEOIR:
537         iar = pkt->get<uint32_t>();
538         if (iar.ack_id < SGI_MAX) {
539             // Clear out the bit that corrseponds to the cleared int
540             uint64_t clr_int = ULL(1) << (ctx_id + 8 * iar.cpu_id);
541             if (!(cpuSgiActive[iar.ack_id] & clr_int))
542                 panic("Done handling a SGI that isn't active?\n");
543             cpuSgiActive[iar.ack_id] &= ~clr_int;
544         } else if (iar.ack_id < (SGI_MAX + PPI_MAX) ) {
545             uint32_t int_num = 1 << (iar.ack_id - SGI_MAX);
546             if (!(cpuPpiActive[ctx_id] & int_num))
547                 panic("CPU %d Done handling a PPI interrupt that isn't active?\n"
      , ctx_id);
548             cpuPpiActive[ctx_id] &= ~int_num;
549         } else {
550             uint32_t int_num = 1 << intNumToBit(iar.ack_id);
551             if (!(activeInt[intNumToWord(iar.ack_id)] & int_num))
552                 panic("Done handling interrupt that isn't active?\n");
553             activeInt[intNumToWord(iar.ack_id)] &= ~int_num;
554         }
555         updateRunPri();
556         DPRINTF(Interrupt, "CPU %d done handling intr IAR = %d from cpu %d\n",
557                 ctx_id, iar.ack_id, iar.cpu_id);
558         break;
559       default:
560         panic("Tried to write Gic cpu at offset %#x\n", daddr);
561         break;
562     }
563     if (cpuEnabled[ctx_id]) updateIntState(-1);
564     pkt->makeAtomicResponse();
565     return cpuPioDelay;
566 }
\end{DoxyCode}
\hypertarget{classPl390_aa2bced1a2b305cd5aa2e0f9fed1e1e2b}{
\index{Pl390@{Pl390}!writeDistributor@{writeDistributor}}
\index{writeDistributor@{writeDistributor}!Pl390@{Pl390}}
\subsubsection[{writeDistributor}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} writeDistributor ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_aa2bced1a2b305cd5aa2e0f9fed1e1e2b}
Handle a write to the distributor poriton of the GIC 
\begin{DoxyParams}{引数}
\item[{\em pkt}]packet to respond to \end{DoxyParams}



\begin{DoxyCode}
391 {
392     Addr daddr = pkt->getAddr() - distAddr;
393     pkt->allocate();
394 
395     assert(pkt->req->hasContextId());
396     int ctx_id = pkt->req->contextId();
397 
398     DPRINTF(GIC, "gic distributor write register %#x size %#x value %#x \n",
399             daddr, pkt->getSize(), pkt->get<uint32_t>());
400 
401     if (daddr >= ICDISER_ST && daddr < ICDISER_ED + 4) {
402         assert((daddr-ICDISER_ST) >> 2 < 32);
403         intEnabled[(daddr-ICDISER_ST) >> 2] |= pkt->get<uint32_t>();
404         goto done;
405     }
406 
407     if (daddr >= ICDICER_ST && daddr < ICDICER_ED + 4) {
408         assert((daddr-ICDICER_ST) >> 2 < 32);
409         intEnabled[(daddr-ICDICER_ST) >> 2] &= ~pkt->get<uint32_t>();
410         goto done;
411     }
412 
413     if (daddr >= ICDISPR_ST && daddr < ICDISPR_ED + 4) {
414         assert((daddr-ICDISPR_ST) >> 2 < 32);
415         pendingInt[(daddr-ICDISPR_ST) >> 2] |= pkt->get<uint32_t>();
416         pendingInt[0] &= SGI_MASK; // Don't allow SGIs to be changed
417         updateIntState((daddr-ICDISPR_ST) >> 2);
418         goto done;
419     }
420 
421     if (daddr >= ICDICPR_ST && daddr < ICDICPR_ED + 4) {
422         assert((daddr-ICDICPR_ST) >> 2 < 32);
423         pendingInt[(daddr-ICDICPR_ST) >> 2] &= ~pkt->get<uint32_t>();
424         pendingInt[0] &= SGI_MASK; // Don't allow SGIs to be changed
425         updateIntState((daddr-ICDICPR_ST) >> 2);
426         goto done;
427     }
428 
429     if (daddr >= ICDIPR_ST && daddr < ICDIPR_ED + 4) {
430         Addr int_num = daddr - ICDIPR_ST;
431         assert(int_num < INT_LINES_MAX);
432         uint8_t* int_p;
433         if (int_num < (SGI_MAX + PPI_MAX))
434             int_p = bankedIntPriority[ctx_id];
435         else
436             int_p = intPriority;
437         uint32_t tmp;
438         switch(pkt->getSize()) {
439           case 1:
440             tmp = pkt->get<uint8_t>();
441             int_p[int_num] = bits(tmp, 7, 0);
442             break;
443           case 2:
444             tmp = pkt->get<uint16_t>();
445             int_p[int_num] = bits(tmp, 7, 0);
446             int_p[int_num + 1] = bits(tmp, 15, 8);
447             break;
448           case 4:
449             tmp = pkt->get<uint32_t>();
450             int_p[int_num] = bits(tmp, 7, 0);
451             int_p[int_num + 1] = bits(tmp, 15, 8);
452             int_p[int_num + 2] = bits(tmp, 23, 16);
453             int_p[int_num + 3] = bits(tmp, 31, 24);
454             break;
455           default:
456             panic("Invalid size when writing to priority regs in Gic: %d\n",
457                    pkt->getSize());
458         }
459 
460         updateIntState(-1);
461         updateRunPri();
462         goto done;
463     }
464 
465     if (daddr >= ICDIPTR_ST && daddr < ICDIPTR_ED + 4) {
466         Addr int_num = (daddr-ICDIPTR_ST) ;
467         assert(int_num < INT_LINES_MAX);
468         // First 31 interrupts only target single processor
469         if (int_num >= SGI_MAX) {
470             if (pkt->getSize() == 1) {
471                 uint8_t tmp = pkt->get<uint8_t>();
472                 cpuTarget[int_num] = tmp & 0xff;
473             } else {
474                 assert (pkt->getSize() == 4);
475                 int_num = mbits(int_num, 31, 2);
476                 uint32_t tmp = pkt->get<uint32_t>();
477                 cpuTarget[int_num]   = bits(tmp, 7, 0);
478                 cpuTarget[int_num+1] = bits(tmp, 15, 8);
479                 cpuTarget[int_num+2] = bits(tmp, 23, 16);
480                 cpuTarget[int_num+3] = bits(tmp, 31, 24);
481             }
482             updateIntState((daddr-ICDIPTR_ST)>>2);
483         }
484         goto done;
485     }
486 
487     if (daddr >= ICDICFR_ST && daddr < ICDICFR_ED + 4) {
488         assert((daddr-ICDICFR_ST) >> 2 < 64);
489         intConfig[(daddr-ICDICFR_ST)>>2] = pkt->get<uint32_t>();
490         if (pkt->get<uint32_t>() & NN_CONFIG_MASK)
491             warn("GIC N:N mode selected and not supported at this time\n");
492         goto done;
493     }
494 
495     switch(daddr) {
496       case ICDDCR:
497         enabled = pkt->get<uint32_t>();
498         DPRINTF(Interrupt, "Distributor enable flag set to = %d\n", enabled);
499         break;
500       case ICDSGIR:
501         softInt(ctx_id, pkt->get<uint32_t>());
502         break;
503       default:
504         panic("Tried to write Gic distributor at offset %#x\n", daddr);
505         break;
506     }
507 
508 done:
509     pkt->makeAtomicResponse();
510     return distPioDelay;
511 }
\end{DoxyCode}
\hypertarget{classPl390_a5842952b3d66843d825fc907816c9647}{
\index{Pl390@{Pl390}!writeMsix@{writeMsix}}
\index{writeMsix@{writeMsix}!Pl390@{Pl390}}
\subsubsection[{writeMsix}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} writeMsix ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a5842952b3d66843d825fc907816c9647}
Handle a write to the MSI-\/X register on the GIC 
\begin{DoxyParams}{引数}
\item[{\em pkt}]packet to process \end{DoxyParams}



\begin{DoxyCode}
570 {
571     Addr daddr = pkt->getAddr() - msixRegAddr;
572     pkt->allocate();
573 
574     DPRINTF(GIC, "Gic MSI-X write register %#x data %d\n",
575                  daddr, pkt->get<uint32_t>());
576 
577     switch (daddr) {
578         case MSIX_SR:
579             // This value is little endian, just like the ARM guest
580             msixReg = pkt->get<uint32_t>();
581             pendingInt[intNumToWord(letoh(msixReg))] |= 1UL << intNumToBit(letoh(
      msixReg));
582             updateIntState(-1);
583             break;
584         default:
585             panic("Tried to write Gic MSI-X register at offset %#x\n", daddr);
586             break;
587     }
588 
589     pkt->makeAtomicResponse();
590     return distPioDelay;
591 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classPl390_ab1d4b1ab244021ea7a23b2cbcd2fbdb9}{
\index{Pl390@{Pl390}!ack\_\-id@{ack\_\-id}}
\index{ack\_\-id@{ack\_\-id}!Pl390@{Pl390}}
\subsubsection[{ack\_\-id}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ack\_\-id}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_ab1d4b1ab244021ea7a23b2cbcd2fbdb9}
\hypertarget{classPl390_a48d93d135c28a30df624e36d86856ab8}{
\index{Pl390@{Pl390}!activeInt@{activeInt}}
\index{activeInt@{activeInt}!Pl390@{Pl390}}
\subsubsection[{activeInt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf activeInt}\mbox{[}{\bf INT\_\-BITS\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a48d93d135c28a30df624e36d86856ab8}
interrupt active bits for all possible 1020 interupts. one bit per interrupt, 32 bit per word = 32 words \hypertarget{classPl390_a30d4209f73a9d8d2478774b12a477910}{
\index{Pl390@{Pl390}!bankedIntPriority@{bankedIntPriority}}
\index{bankedIntPriority@{bankedIntPriority}!Pl390@{Pl390}}
\subsubsection[{bankedIntPriority}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf bankedIntPriority}\mbox{[}{\bf CPU\_\-MAX}\mbox{]}\mbox{[}{\bf SGI\_\-MAX}+{\bf PPI\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a30d4209f73a9d8d2478774b12a477910}
Banked interrupt prioirty registers for SGIs and PPIs \hypertarget{classPl390_a0fde3389d812c2863113c78e0d23108a}{
\index{Pl390@{Pl390}!cpu\_\-id@{cpu\_\-id}}
\index{cpu\_\-id@{cpu\_\-id}!Pl390@{Pl390}}
\subsubsection[{cpu\_\-id}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$12,10$>$ {\bf cpu\_\-id}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a0fde3389d812c2863113c78e0d23108a}
\hypertarget{classPl390_ae08ec5adcf38877d9f146a34871930c3}{
\index{Pl390@{Pl390}!cpu\_\-list@{cpu\_\-list}}
\index{cpu\_\-list@{cpu\_\-list}!Pl390@{Pl390}}
\subsubsection[{cpu\_\-list}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$23,16$>$ {\bf cpu\_\-list}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_ae08ec5adcf38877d9f146a34871930c3}
\hypertarget{classPl390_a4b102c882c8ecd5172c3f918fcde9c6d}{
\index{Pl390@{Pl390}!CPU\_\-MAX@{CPU\_\-MAX}}
\index{CPU\_\-MAX@{CPU\_\-MAX}!Pl390@{Pl390}}
\subsubsection[{CPU\_\-MAX}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf CPU\_\-MAX} = 8\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a4b102c882c8ecd5172c3f918fcde9c6d}
\hypertarget{classPl390_a628e4ead2feec06369292346fb8867d8}{
\index{Pl390@{Pl390}!CPU\_\-SIZE@{CPU\_\-SIZE}}
\index{CPU\_\-SIZE@{CPU\_\-SIZE}!Pl390@{Pl390}}
\subsubsection[{CPU\_\-SIZE}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf CPU\_\-SIZE} = 0xff\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a628e4ead2feec06369292346fb8867d8}
\hypertarget{classPl390_a604af0bb85a2a3f90c842febc7e8f87d}{
\index{Pl390@{Pl390}!cpuAddr@{cpuAddr}}
\index{cpuAddr@{cpuAddr}!Pl390@{Pl390}}
\subsubsection[{cpuAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf cpuAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a604af0bb85a2a3f90c842febc7e8f87d}
CPU address GIC listens at \begin{Desc}
\item[\hyperlink{todo__todo000055}{TODO}]is this one per cpu? \end{Desc}
\hypertarget{classPl390_ade84a14feb2db119b655dedf663ef829}{
\index{Pl390@{Pl390}!cpuBpr@{cpuBpr}}
\index{cpuBpr@{cpuBpr}!Pl390@{Pl390}}
\subsubsection[{cpuBpr}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf cpuBpr}\mbox{[}{\bf CPU\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_ade84a14feb2db119b655dedf663ef829}
Binary point registers \hypertarget{classPl390_aba2c5a4460094266172ecd62908b8724}{
\index{Pl390@{Pl390}!cpuEnabled@{cpuEnabled}}
\index{cpuEnabled@{cpuEnabled}!Pl390@{Pl390}}
\subsubsection[{cpuEnabled}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf cpuEnabled}\mbox{[}{\bf CPU\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_aba2c5a4460094266172ecd62908b8724}
CPU enabled \hypertarget{classPl390_abe05250acc13d01ea2f994f0a2f58720}{
\index{Pl390@{Pl390}!cpuHighestInt@{cpuHighestInt}}
\index{cpuHighestInt@{cpuHighestInt}!Pl390@{Pl390}}
\subsubsection[{cpuHighestInt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf cpuHighestInt}\mbox{[}{\bf CPU\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_abe05250acc13d01ea2f994f0a2f58720}
highest interrupt that is interrupting CPU \hypertarget{classPl390_a50352a1f6d1032a4be9c5884616a3233}{
\index{Pl390@{Pl390}!cpuPioDelay@{cpuPioDelay}}
\index{cpuPioDelay@{cpuPioDelay}!Pl390@{Pl390}}
\subsubsection[{cpuPioDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf cpuPioDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a50352a1f6d1032a4be9c5884616a3233}
Latency for a cpu operation \hypertarget{classPl390_ac682ea7abccde0f7267b5215fda1ed5c}{
\index{Pl390@{Pl390}!cpuPpiActive@{cpuPpiActive}}
\index{cpuPpiActive@{cpuPpiActive}!Pl390@{Pl390}}
\subsubsection[{cpuPpiActive}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf cpuPpiActive}\mbox{[}{\bf CPU\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_ac682ea7abccde0f7267b5215fda1ed5c}
\hypertarget{classPl390_a301af4f8223a97310920fc36160fb26d}{
\index{Pl390@{Pl390}!cpuPpiPending@{cpuPpiPending}}
\index{cpuPpiPending@{cpuPpiPending}!Pl390@{Pl390}}
\subsubsection[{cpuPpiPending}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf cpuPpiPending}\mbox{[}{\bf CPU\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a301af4f8223a97310920fc36160fb26d}
One bit per private peripheral interrupt. Only upper 16 bits will be used since PPI interrupts are numberred from 16 to 32 \hypertarget{classPl390_a8d3092e01e51b8ee0dd9787a9e44b795}{
\index{Pl390@{Pl390}!cpuPriority@{cpuPriority}}
\index{cpuPriority@{cpuPriority}!Pl390@{Pl390}}
\subsubsection[{cpuPriority}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf cpuPriority}\mbox{[}{\bf CPU\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a8d3092e01e51b8ee0dd9787a9e44b795}
CPU priority \hypertarget{classPl390_aa8be2dd249b8372cdddb56197778b7a8}{
\index{Pl390@{Pl390}!cpuSgiActive@{cpuSgiActive}}
\index{cpuSgiActive@{cpuSgiActive}!Pl390@{Pl390}}
\subsubsection[{cpuSgiActive}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf cpuSgiActive}\mbox{[}{\bf SGI\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_aa8be2dd249b8372cdddb56197778b7a8}
\hypertarget{classPl390_a78fdfd8252d9d31df17bc7799f30650d}{
\index{Pl390@{Pl390}!cpuSgiPending@{cpuSgiPending}}
\index{cpuSgiPending@{cpuSgiPending}!Pl390@{Pl390}}
\subsubsection[{cpuSgiPending}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf cpuSgiPending}\mbox{[}{\bf SGI\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a78fdfd8252d9d31df17bc7799f30650d}
One bit per cpu per software interrupt that is pending for each possible sgi source. Indexed by SGI number. Each byte in generating cpu id and bits in position is destination id. e.g. 0x4 = CPU 0 generated interrupt for CPU 2. \hypertarget{classPl390_aedf9bee3143d433dfabe7bc84f574df6}{
\index{Pl390@{Pl390}!cpuTarget@{cpuTarget}}
\index{cpuTarget@{cpuTarget}!Pl390@{Pl390}}
\subsubsection[{cpuTarget}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf cpuTarget}\mbox{[}{\bf INT\_\-LINES\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_aedf9bee3143d433dfabe7bc84f574df6}
an 8 bit cpu target id for each shared peripheral interrupt of the 1020 possible supported interrupts. \hypertarget{classPl390_a0a6bf9b44fc240861af4c98cb13b212b}{
\index{Pl390@{Pl390}!DIST\_\-SIZE@{DIST\_\-SIZE}}
\index{DIST\_\-SIZE@{DIST\_\-SIZE}!Pl390@{Pl390}}
\subsubsection[{DIST\_\-SIZE}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf DIST\_\-SIZE} = 0xfff\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a0a6bf9b44fc240861af4c98cb13b212b}
\hypertarget{classPl390_ab55f6a058ccebacb16d2032b086703af}{
\index{Pl390@{Pl390}!distPioDelay@{distPioDelay}}
\index{distPioDelay@{distPioDelay}!Pl390@{Pl390}}
\subsubsection[{distPioDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf distPioDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_ab55f6a058ccebacb16d2032b086703af}
Latency for a distributor operation \hypertarget{classPl390_a8740ba80e30dd75e71d09fa1dcf04f3d}{
\index{Pl390@{Pl390}!enabled@{enabled}}
\index{enabled@{enabled}!Pl390@{Pl390}}
\subsubsection[{enabled}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf enabled}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a8740ba80e30dd75e71d09fa1dcf04f3d}
\hyperlink{namespaceGic}{Gic} enabled \hypertarget{classPl390_a0d8e9d466c4efc33cfd7dc2fd2eb59eb}{
\index{Pl390@{Pl390}!ICCABPR@{ICCABPR}}
\index{ICCABPR@{ICCABPR}!Pl390@{Pl390}}
\subsubsection[{ICCABPR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICCABPR} = 0x1c\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a0d8e9d466c4efc33cfd7dc2fd2eb59eb}
\hypertarget{classPl390_ace280dd5776899099ebfe4f7b7bbc01f}{
\index{Pl390@{Pl390}!ICCBPR@{ICCBPR}}
\index{ICCBPR@{ICCBPR}!Pl390@{Pl390}}
\subsubsection[{ICCBPR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICCBPR} = 0x08\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_ace280dd5776899099ebfe4f7b7bbc01f}
\hypertarget{classPl390_a3ab6be2302e161f611641bcb679f70c4}{
\index{Pl390@{Pl390}!ICCEOIR@{ICCEOIR}}
\index{ICCEOIR@{ICCEOIR}!Pl390@{Pl390}}
\subsubsection[{ICCEOIR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICCEOIR} = 0x10\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a3ab6be2302e161f611641bcb679f70c4}
\hypertarget{classPl390_a39d3ddf778fa125d6e9aa3183a72cd06}{
\index{Pl390@{Pl390}!ICCHPIR@{ICCHPIR}}
\index{ICCHPIR@{ICCHPIR}!Pl390@{Pl390}}
\subsubsection[{ICCHPIR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICCHPIR} = 0x18\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a39d3ddf778fa125d6e9aa3183a72cd06}
\hypertarget{classPl390_a15b9d48b0d0fe3e5f21d98c5b3579e98}{
\index{Pl390@{Pl390}!ICCIAR@{ICCIAR}}
\index{ICCIAR@{ICCIAR}!Pl390@{Pl390}}
\subsubsection[{ICCIAR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICCIAR} = 0x0C\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a15b9d48b0d0fe3e5f21d98c5b3579e98}
\hypertarget{classPl390_acb144a8d8dc35a2e9060d96bc329fa60}{
\index{Pl390@{Pl390}!ICCICR@{ICCICR}}
\index{ICCICR@{ICCICR}!Pl390@{Pl390}}
\subsubsection[{ICCICR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICCICR} = 0x00\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_acb144a8d8dc35a2e9060d96bc329fa60}
\hypertarget{classPl390_ae00448ead7cf78b11d87238f956b1532}{
\index{Pl390@{Pl390}!ICCIIDR@{ICCIIDR}}
\index{ICCIIDR@{ICCIIDR}!Pl390@{Pl390}}
\subsubsection[{ICCIIDR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICCIIDR} = 0xfc\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_ae00448ead7cf78b11d87238f956b1532}
\hypertarget{classPl390_a00368b6d72a37a6a7f42e7922d289e76}{
\index{Pl390@{Pl390}!ICCPMR@{ICCPMR}}
\index{ICCPMR@{ICCPMR}!Pl390@{Pl390}}
\subsubsection[{ICCPMR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICCPMR} = 0x04\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a00368b6d72a37a6a7f42e7922d289e76}
\hypertarget{classPl390_afc5683cf049c7151320031fb200a4983}{
\index{Pl390@{Pl390}!iccrpr@{iccrpr}}
\index{iccrpr@{iccrpr}!Pl390@{Pl390}}
\subsubsection[{iccrpr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf iccrpr}\mbox{[}{\bf CPU\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_afc5683cf049c7151320031fb200a4983}
read only running priroity register, 1 per cpu \hypertarget{classPl390_a0d94eb1e4c2f76f0bf84221f0862c6ae}{
\index{Pl390@{Pl390}!ICCRPR@{ICCRPR}}
\index{ICCRPR@{ICCRPR}!Pl390@{Pl390}}
\subsubsection[{ICCRPR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICCRPR} = 0x14\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a0d94eb1e4c2f76f0bf84221f0862c6ae}
\hypertarget{classPl390_a90ba1a5529bf96f4dbd87ac105fa4a22}{
\index{Pl390@{Pl390}!ICDABR\_\-ED@{ICDABR\_\-ED}}
\index{ICDABR\_\-ED@{ICDABR\_\-ED}!Pl390@{Pl390}}
\subsubsection[{ICDABR\_\-ED}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDABR\_\-ED} = 0x37c\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a90ba1a5529bf96f4dbd87ac105fa4a22}
\hypertarget{classPl390_ada9ed9528249cdb6ce90174e180c6e83}{
\index{Pl390@{Pl390}!ICDABR\_\-ST@{ICDABR\_\-ST}}
\index{ICDABR\_\-ST@{ICDABR\_\-ST}!Pl390@{Pl390}}
\subsubsection[{ICDABR\_\-ST}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDABR\_\-ST} = 0x300\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_ada9ed9528249cdb6ce90174e180c6e83}
\hypertarget{classPl390_a0438fcd6c355e9ee0f4dfbb52a8df185}{
\index{Pl390@{Pl390}!ICDDCR@{ICDDCR}}
\index{ICDDCR@{ICDDCR}!Pl390@{Pl390}}
\subsubsection[{ICDDCR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDDCR} = 0x000\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a0438fcd6c355e9ee0f4dfbb52a8df185}
\hypertarget{classPl390_adaa1179ddc7a651be29f72be0e19c4d4}{
\index{Pl390@{Pl390}!ICDICER\_\-ED@{ICDICER\_\-ED}}
\index{ICDICER\_\-ED@{ICDICER\_\-ED}!Pl390@{Pl390}}
\subsubsection[{ICDICER\_\-ED}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDICER\_\-ED} = 0x1fc\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_adaa1179ddc7a651be29f72be0e19c4d4}
\hypertarget{classPl390_a56ca3d402724ba490eed116c059f4bf1}{
\index{Pl390@{Pl390}!ICDICER\_\-ST@{ICDICER\_\-ST}}
\index{ICDICER\_\-ST@{ICDICER\_\-ST}!Pl390@{Pl390}}
\subsubsection[{ICDICER\_\-ST}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDICER\_\-ST} = 0x180\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a56ca3d402724ba490eed116c059f4bf1}
\hypertarget{classPl390_ab23fa73d7d71a9d54ac1ea1ff4661770}{
\index{Pl390@{Pl390}!ICDICFR\_\-ED@{ICDICFR\_\-ED}}
\index{ICDICFR\_\-ED@{ICDICFR\_\-ED}!Pl390@{Pl390}}
\subsubsection[{ICDICFR\_\-ED}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDICFR\_\-ED} = 0xcfc\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_ab23fa73d7d71a9d54ac1ea1ff4661770}
\hypertarget{classPl390_ada234b18d9cde5ac83bbea077bc269de}{
\index{Pl390@{Pl390}!ICDICFR\_\-ST@{ICDICFR\_\-ST}}
\index{ICDICFR\_\-ST@{ICDICFR\_\-ST}!Pl390@{Pl390}}
\subsubsection[{ICDICFR\_\-ST}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDICFR\_\-ST} = 0xc00\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_ada234b18d9cde5ac83bbea077bc269de}
\hypertarget{classPl390_a98f072638834510ed1fe555392dbdd30}{
\index{Pl390@{Pl390}!ICDICPR\_\-ED@{ICDICPR\_\-ED}}
\index{ICDICPR\_\-ED@{ICDICPR\_\-ED}!Pl390@{Pl390}}
\subsubsection[{ICDICPR\_\-ED}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDICPR\_\-ED} = 0x2fc\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a98f072638834510ed1fe555392dbdd30}
\hypertarget{classPl390_af8249cc4f3e77d812877de9557be0cd0}{
\index{Pl390@{Pl390}!ICDICPR\_\-ST@{ICDICPR\_\-ST}}
\index{ICDICPR\_\-ST@{ICDICPR\_\-ST}!Pl390@{Pl390}}
\subsubsection[{ICDICPR\_\-ST}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDICPR\_\-ST} = 0x280\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_af8249cc4f3e77d812877de9557be0cd0}
\hypertarget{classPl390_a0c58ee924126812674213e9fbb97956f}{
\index{Pl390@{Pl390}!ICDICTR@{ICDICTR}}
\index{ICDICTR@{ICDICTR}!Pl390@{Pl390}}
\subsubsection[{ICDICTR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDICTR} = 0x004\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a0c58ee924126812674213e9fbb97956f}
\hypertarget{classPl390_a3eb18d588046d1093762d2dd79f6b563}{
\index{Pl390@{Pl390}!ICDIIDR@{ICDIIDR}}
\index{ICDIIDR@{ICDIIDR}!Pl390@{Pl390}}
\subsubsection[{ICDIIDR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDIIDR} = 0x008\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a3eb18d588046d1093762d2dd79f6b563}
\hypertarget{classPl390_a28b5a0626045b2093fec240d94ce73ff}{
\index{Pl390@{Pl390}!ICDIPR\_\-ED@{ICDIPR\_\-ED}}
\index{ICDIPR\_\-ED@{ICDIPR\_\-ED}!Pl390@{Pl390}}
\subsubsection[{ICDIPR\_\-ED}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDIPR\_\-ED} = 0x7f8\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a28b5a0626045b2093fec240d94ce73ff}
\hypertarget{classPl390_a1483278b83c758d54081d9e4646da369}{
\index{Pl390@{Pl390}!ICDIPR\_\-ST@{ICDIPR\_\-ST}}
\index{ICDIPR\_\-ST@{ICDIPR\_\-ST}!Pl390@{Pl390}}
\subsubsection[{ICDIPR\_\-ST}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDIPR\_\-ST} = 0x400\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a1483278b83c758d54081d9e4646da369}
\hypertarget{classPl390_a083710529636f2bd1b38a28ea3afbbfd}{
\index{Pl390@{Pl390}!ICDIPTR\_\-ED@{ICDIPTR\_\-ED}}
\index{ICDIPTR\_\-ED@{ICDIPTR\_\-ED}!Pl390@{Pl390}}
\subsubsection[{ICDIPTR\_\-ED}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDIPTR\_\-ED} = 0xbf8\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a083710529636f2bd1b38a28ea3afbbfd}
\hypertarget{classPl390_ac442d8d76d06e1e3a49c415c328664c2}{
\index{Pl390@{Pl390}!ICDIPTR\_\-ST@{ICDIPTR\_\-ST}}
\index{ICDIPTR\_\-ST@{ICDIPTR\_\-ST}!Pl390@{Pl390}}
\subsubsection[{ICDIPTR\_\-ST}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDIPTR\_\-ST} = 0x800\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_ac442d8d76d06e1e3a49c415c328664c2}
\hypertarget{classPl390_a0f76976aa74415dcd9aec96a1f70758a}{
\index{Pl390@{Pl390}!ICDISER\_\-ED@{ICDISER\_\-ED}}
\index{ICDISER\_\-ED@{ICDISER\_\-ED}!Pl390@{Pl390}}
\subsubsection[{ICDISER\_\-ED}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDISER\_\-ED} = 0x17c\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a0f76976aa74415dcd9aec96a1f70758a}
\hypertarget{classPl390_a967e1ae96980f25524ea435853fe54d1}{
\index{Pl390@{Pl390}!ICDISER\_\-ST@{ICDISER\_\-ST}}
\index{ICDISER\_\-ST@{ICDISER\_\-ST}!Pl390@{Pl390}}
\subsubsection[{ICDISER\_\-ST}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDISER\_\-ST} = 0x100\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a967e1ae96980f25524ea435853fe54d1}
\hypertarget{classPl390_a5f1357dca4f87c003ecd67e6ce2a6840}{
\index{Pl390@{Pl390}!ICDISPR\_\-ED@{ICDISPR\_\-ED}}
\index{ICDISPR\_\-ED@{ICDISPR\_\-ED}!Pl390@{Pl390}}
\subsubsection[{ICDISPR\_\-ED}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDISPR\_\-ED} = 0x27c\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a5f1357dca4f87c003ecd67e6ce2a6840}
\hypertarget{classPl390_aeafca9a9f217ac149ec11d59cf25da9a}{
\index{Pl390@{Pl390}!ICDISPR\_\-ST@{ICDISPR\_\-ST}}
\index{ICDISPR\_\-ST@{ICDISPR\_\-ST}!Pl390@{Pl390}}
\subsubsection[{ICDISPR\_\-ST}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDISPR\_\-ST} = 0x200\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_aeafca9a9f217ac149ec11d59cf25da9a}
\hypertarget{classPl390_ab757c4be11b50f9a009aa08c958ea058}{
\index{Pl390@{Pl390}!ICDSGIR@{ICDSGIR}}
\index{ICDSGIR@{ICDSGIR}!Pl390@{Pl390}}
\subsubsection[{ICDSGIR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf ICDSGIR} = 0xf00\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_ab757c4be11b50f9a009aa08c958ea058}
\hypertarget{classPl390_ac0434966a31be307b3b2acd8975a169b}{
\index{Pl390@{Pl390}!INT\_\-BITS\_\-MAX@{INT\_\-BITS\_\-MAX}}
\index{INT\_\-BITS\_\-MAX@{INT\_\-BITS\_\-MAX}!Pl390@{Pl390}}
\subsubsection[{INT\_\-BITS\_\-MAX}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf INT\_\-BITS\_\-MAX} = 32\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_ac0434966a31be307b3b2acd8975a169b}
\hypertarget{classPl390_a0158de396428c6145312576a210f1a59}{
\index{Pl390@{Pl390}!INT\_\-LINES\_\-MAX@{INT\_\-LINES\_\-MAX}}
\index{INT\_\-LINES\_\-MAX@{INT\_\-LINES\_\-MAX}!Pl390@{Pl390}}
\subsubsection[{INT\_\-LINES\_\-MAX}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf INT\_\-LINES\_\-MAX} = 1020\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a0158de396428c6145312576a210f1a59}
\hypertarget{classPl390_a0e6a663caacdba2b0b9192c0e2c8c315}{
\index{Pl390@{Pl390}!intConfig@{intConfig}}
\index{intConfig@{intConfig}!Pl390@{Pl390}}
\subsubsection[{intConfig}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf intConfig}\mbox{[}{\bf INT\_\-BITS\_\-MAX} $\ast$2\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a0e6a663caacdba2b0b9192c0e2c8c315}
2 bit per interrupt signaling if it's level or edge sensitive and if it is 1:N or N:N \hypertarget{classPl390_a1bce6fc9f9b30623d11815ada1bd4f56}{
\index{Pl390@{Pl390}!intEnabled@{intEnabled}}
\index{intEnabled@{intEnabled}!Pl390@{Pl390}}
\subsubsection[{intEnabled}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf intEnabled}\mbox{[}{\bf INT\_\-BITS\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a1bce6fc9f9b30623d11815ada1bd4f56}
interrupt enable bits for all possible 1020 interupts. one bit per interrupt, 32 bit per word = 32 words \hypertarget{classPl390_a8acb46f8ecab4551225777951a774a62}{
\index{Pl390@{Pl390}!intLatency@{intLatency}}
\index{intLatency@{intLatency}!Pl390@{Pl390}}
\subsubsection[{intLatency}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf intLatency}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a8acb46f8ecab4551225777951a774a62}
Latency for a interrupt to get to CPU \hypertarget{classPl390_a4f1f81194c08a716e3583d73588952c2}{
\index{Pl390@{Pl390}!intPriority@{intPriority}}
\index{intPriority@{intPriority}!Pl390@{Pl390}}
\subsubsection[{intPriority}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf intPriority}\mbox{[}{\bf INT\_\-LINES\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a4f1f81194c08a716e3583d73588952c2}
an 8 bit priority (lower is higher priority) for each of the 1020 possible supported interrupts. \hypertarget{classPl390_a4dd3993efeb04a5d9c8a0820b4b09d67}{
\index{Pl390@{Pl390}!irqEnable@{irqEnable}}
\index{irqEnable@{irqEnable}!Pl390@{Pl390}}
\subsubsection[{irqEnable}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf irqEnable}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a4dd3993efeb04a5d9c8a0820b4b09d67}
IRQ Enable Used for debug \hypertarget{classPl390_a21dc662678d340891a1d579bf78955ce}{
\index{Pl390@{Pl390}!itLines@{itLines}}
\index{itLines@{itLines}!Pl390@{Pl390}}
\subsubsection[{itLines}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf itLines}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a21dc662678d340891a1d579bf78955ce}
Number of itLines enabled \hypertarget{classPl390_a6d73a4f61a4306d3aff3e9571eeccf47}{
\index{Pl390@{Pl390}!itLinesLog2@{itLinesLog2}}
\index{itLinesLog2@{itLinesLog2}!Pl390@{Pl390}}
\subsubsection[{itLinesLog2}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf itLinesLog2}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a6d73a4f61a4306d3aff3e9571eeccf47}
\hypertarget{classPl390_a6b56e232dd8fd3da34e2900f7f06039d}{
\index{Pl390@{Pl390}!list\_\-type@{list\_\-type}}
\index{list\_\-type@{list\_\-type}!Pl390@{Pl390}}
\subsubsection[{list\_\-type}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$25,24$>$ {\bf list\_\-type}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a6b56e232dd8fd3da34e2900f7f06039d}
\hypertarget{classPl390_a6f1a976e6a4f72a669c64334981f2220}{
\index{Pl390@{Pl390}!MSIX\_\-SIZE@{MSIX\_\-SIZE}}
\index{MSIX\_\-SIZE@{MSIX\_\-SIZE}!Pl390@{Pl390}}
\subsubsection[{MSIX\_\-SIZE}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf MSIX\_\-SIZE} = 0x4\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a6f1a976e6a4f72a669c64334981f2220}
\hypertarget{classPl390_a75f82acd63e66c4ab659e0889281e35b}{
\index{Pl390@{Pl390}!MSIX\_\-SR@{MSIX\_\-SR}}
\index{MSIX\_\-SR@{MSIX\_\-SR}!Pl390@{Pl390}}
\subsubsection[{MSIX\_\-SR}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf MSIX\_\-SR} = 0x0\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a75f82acd63e66c4ab659e0889281e35b}
MSI-\/X register offset and size \hypertarget{classPl390_aa646cfd25d072cc06bfb25fc3cb18890}{
\index{Pl390@{Pl390}!msixReg@{msixReg}}
\index{msixReg@{msixReg}!Pl390@{Pl390}}
\subsubsection[{msixReg}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf msixReg}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_aa646cfd25d072cc06bfb25fc3cb18890}
\hypertarget{classPl390_ae9eb70129c76fd704086093bcdd21471}{
\index{Pl390@{Pl390}!msixRegAddr@{msixRegAddr}}
\index{msixRegAddr@{msixRegAddr}!Pl390@{Pl390}}
\subsubsection[{msixRegAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf msixRegAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_ae9eb70129c76fd704086093bcdd21471}
\hyperlink{structMSIX}{MSIX} \hyperlink{classRegister}{Register} \hypertarget{classPl390_a7595fc36770609b9fef1a639ce0b3c84}{
\index{Pl390@{Pl390}!NN\_\-CONFIG\_\-MASK@{NN\_\-CONFIG\_\-MASK}}
\index{NN\_\-CONFIG\_\-MASK@{NN\_\-CONFIG\_\-MASK}!Pl390@{Pl390}}
\subsubsection[{NN\_\-CONFIG\_\-MASK}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf NN\_\-CONFIG\_\-MASK} = 0x55555555\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a7595fc36770609b9fef1a639ce0b3c84}
Mask for bits that config N:N mode in ICDICFR's \hypertarget{classPl390_a4a5f5a9735da74511b9d4e02c4ace364}{
\index{Pl390@{Pl390}!pendingInt@{pendingInt}}
\index{pendingInt@{pendingInt}!Pl390@{Pl390}}
\subsubsection[{pendingInt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf pendingInt}\mbox{[}{\bf INT\_\-BITS\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a4a5f5a9735da74511b9d4e02c4ace364}
interrupt pending bits for all possible 1020 interupts. one bit per interrupt, 32 bit per word = 32 words \hypertarget{classPl390_a22e64a003aa14067af4bb07701cb88a5}{
\index{Pl390@{Pl390}!postIntEvent@{postIntEvent}}
\index{postIntEvent@{postIntEvent}!Pl390@{Pl390}}
\subsubsection[{postIntEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PostIntEvent}$\ast$ {\bf postIntEvent}\mbox{[}{\bf CPU\_\-MAX}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_a22e64a003aa14067af4bb07701cb88a5}
\hypertarget{classPl390_a5ff528d1355008104939d20af447bac8}{
\index{Pl390@{Pl390}!PPI\_\-MAX@{PPI\_\-MAX}}
\index{PPI\_\-MAX@{PPI\_\-MAX}!Pl390@{Pl390}}
\subsubsection[{PPI\_\-MAX}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf PPI\_\-MAX} = 16\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a5ff528d1355008104939d20af447bac8}
\hypertarget{classPl390_af2b76f78cc36e39f8782a67aa03afbd0}{
\index{Pl390@{Pl390}!sgi\_\-id@{sgi\_\-id}}
\index{sgi\_\-id@{sgi\_\-id}!Pl390@{Pl390}}
\subsubsection[{sgi\_\-id}]{\setlength{\rightskip}{0pt plus 5cm}{\bf sgi\_\-id}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPl390_af2b76f78cc36e39f8782a67aa03afbd0}
\hypertarget{classPl390_a5a2357b28c8821b1d9da7fc86a2e1e46}{
\index{Pl390@{Pl390}!SGI\_\-MASK@{SGI\_\-MASK}}
\index{SGI\_\-MASK@{SGI\_\-MASK}!Pl390@{Pl390}}
\subsubsection[{SGI\_\-MASK}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf SGI\_\-MASK} = 0xFFFF0000\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a5a2357b28c8821b1d9da7fc86a2e1e46}
Mask off SGI's when setting/clearing pending bits \hypertarget{classPl390_ab882d232a4976cf54e9cb73b44e1988f}{
\index{Pl390@{Pl390}!SGI\_\-MAX@{SGI\_\-MAX}}
\index{SGI\_\-MAX@{SGI\_\-MAX}!Pl390@{Pl390}}
\subsubsection[{SGI\_\-MAX}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf SGI\_\-MAX} = 16\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_ab882d232a4976cf54e9cb73b44e1988f}
\hypertarget{classPl390_a5c2ca5d88991c1b1cd77340bf56fdaef}{
\index{Pl390@{Pl390}!SPURIOUS\_\-INT@{SPURIOUS\_\-INT}}
\index{SPURIOUS\_\-INT@{SPURIOUS\_\-INT}!Pl390@{Pl390}}
\subsubsection[{SPURIOUS\_\-INT}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf SPURIOUS\_\-INT} = 1023\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classPl390_a5c2ca5d88991c1b1cd77340bf56fdaef}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/arm/\hyperlink{gic__pl390_8hh}{gic\_\-pl390.hh}\item 
dev/arm/\hyperlink{gic__pl390_8cc}{gic\_\-pl390.cc}\end{DoxyCompactItemize}
