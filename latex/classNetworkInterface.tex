\hypertarget{classNetworkInterface}{
\section{クラス NetworkInterface}
\label{classNetworkInterface}\index{NetworkInterface@{NetworkInterface}}
}


{\ttfamily \#include $<$NetworkInterface.hh$>$}NetworkInterfaceに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4cm]{classNetworkInterface}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef GarnetNetworkInterfaceParams \hyperlink{classNetworkInterface_a24441f24d6be514d5461dd3b86ea9e99}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classNetworkInterface_aaf2a99dc56c8a507bc84059dac4db78b}{NetworkInterface} (const \hyperlink{classNetworkInterface_a24441f24d6be514d5461dd3b86ea9e99}{Params} $\ast$p)
\item 
\hyperlink{classNetworkInterface_adb551ec6b647bebdc200a6f3d856be0b}{$\sim$NetworkInterface} ()
\item 
void \hyperlink{classNetworkInterface_a861b99bda673a31b1b48132ed9369f28}{addInPort} (\hyperlink{classNetworkLink}{NetworkLink} $\ast$in\_\-link)
\item 
void \hyperlink{classNetworkInterface_ab38acc0d5f8c54260955ae391bb77715}{addOutPort} (\hyperlink{classNetworkLink}{NetworkLink} $\ast$out\_\-link)
\item 
void \hyperlink{classNetworkInterface_ae674290a26ecbd622c5160e38e8a4fe9}{wakeup} ()
\item 
void \hyperlink{classNetworkInterface_abb78e667f7f184a1989354ba522d32a9}{addNode} (\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMessageBuffer}{MessageBuffer} $\ast$ $>$ \&inNode, \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMessageBuffer}{MessageBuffer} $\ast$ $>$ \&outNode)
\item 
void \hyperlink{classNetworkInterface_af90fb6c473130244fe64e30e61b714f6}{grant\_\-vc} (int out\_\-port, int vc, \hyperlink{classCycles}{Cycles} grant\_\-time)
\item 
void \hyperlink{classNetworkInterface_adced7fd7d25eb0d6a869fff14085e8c3}{release\_\-vc} (int out\_\-port, int vc, \hyperlink{classCycles}{Cycles} release\_\-time)
\item 
bool \hyperlink{classNetworkInterface_af3465adbf20f8764ea878ce2d28d2bc8}{isBufferNotFull} (int vc, int inport)
\item 
void \hyperlink{classNetworkInterface_ac2db714adfe0dfd2c3ac2b88bd6a5308}{request\_\-vc} (int in\_\-vc, int in\_\-port, \hyperlink{classNetDest}{NetDest} destination, \hyperlink{classCycles}{Cycles} request\_\-time)
\item 
void \hyperlink{classNetworkInterface_ac55fe386a101fbae38c716067c9966a0}{print} (std::ostream \&out) const 
\item 
bool \hyperlink{classNetworkInterface_a6db56c593ee28a561c47e75a859300dd}{functionalRead} (\hyperlink{classPacket}{Packet} $\ast$)
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classNetworkInterface_aba9037f662122b5f2e85647d35670e5c}{functionalWrite} (\hyperlink{classPacket}{Packet} $\ast$)
\item 
void \hyperlink{classNetworkInterface_ab5da6a3c41f86ad2993eb11f4894ef00}{init\_\-net\_\-ptr} (\hyperlink{classGarnetNetwork}{GarnetNetwork} $\ast$net\_\-ptr)
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classNetworkInterface_a12a9945591ab6cd27b4cf0df84786cf8}{flitisizeMessage} (\hyperlink{classRefCountingPtr}{MsgPtr} msg\_\-ptr, int vnet)
\item 
int \hyperlink{classNetworkInterface_ab27658cc3136de94d2d08c78ac499aff}{calculateVC} (int vnet)
\item 
void \hyperlink{classNetworkInterface_a0b5091af4210988da9a7eeb44e5691e4}{scheduleOutputLink} ()
\item 
void \hyperlink{classNetworkInterface_af954e8e2150e2ce2e1b87081bbd9c678}{checkReschedule} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classGarnetNetwork}{GarnetNetwork} $\ast$ \hyperlink{classNetworkInterface_a6f69c0ff922be798fa1cfce69f83244e}{m\_\-net\_\-ptr}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classNetworkInterface_a3c1d97c5d987e52985843dcb76edc7fb}{m\_\-virtual\_\-networks}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classNetworkInterface_a42c554e0c38c6d9572a889f296afcd38}{m\_\-num\_\-vcs}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classNetworkInterface_a5391ff1054ec6311f1c449e769c14f83}{m\_\-vc\_\-per\_\-vnet}
\item 
\hyperlink{TypeDefines_8hh_a83c14b4ae37e80071f6b3506a6c46151}{NodeID} \hyperlink{classNetworkInterface_aaed4e1d0badfbd8b21e43869898ed184}{m\_\-id}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classOutVcState}{OutVcState} $\ast$ $>$ \hyperlink{classNetworkInterface_adeb08e3a1efa0be9efa58648b1edfb5c}{m\_\-out\_\-vc\_\-state}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ int $>$ \hyperlink{classNetworkInterface_a4e31a4f4aad8462157e797cdb1e3e00c}{m\_\-vc\_\-allocator}
\item 
int \hyperlink{classNetworkInterface_a4e50d04fbae98d5e7eac566ab56f4227}{m\_\-vc\_\-round\_\-robin}
\item 
\hyperlink{classflitBuffer}{flitBuffer} $\ast$ \hyperlink{classNetworkInterface_a7c2f0247427488afa8f925d46c82195e}{outSrcQueue}
\item 
\hyperlink{classNetworkLink}{NetworkLink} $\ast$ \hyperlink{classNetworkInterface_a7ce7214ee8901e3eebaf74366e556c20}{inNetLink}
\item 
\hyperlink{classNetworkLink}{NetworkLink} $\ast$ \hyperlink{classNetworkInterface_a6175110fc176a7aeb64b1ea1df878c6f}{outNetLink}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classflitBuffer}{flitBuffer} $\ast$ $>$ \hyperlink{classNetworkInterface_a278caf0cf6647c7e2bc1cb787662ea4e}{m\_\-ni\_\-buffers}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMessageBuffer}{MessageBuffer} $\ast$ $>$ \hyperlink{classNetworkInterface_a933eda70266204185e6bc2a65f0add98}{inNode\_\-ptr}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMessageBuffer}{MessageBuffer} $\ast$ $>$ \hyperlink{classNetworkInterface_aff22e632df88a83fbcbac281efec0dcc}{outNode\_\-ptr}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classNetworkInterface_a24441f24d6be514d5461dd3b86ea9e99}{
\index{NetworkInterface@{NetworkInterface}!Params@{Params}}
\index{Params@{Params}!NetworkInterface@{NetworkInterface}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef GarnetNetworkInterfaceParams {\bf Params}}}
\label{classNetworkInterface_a24441f24d6be514d5461dd3b86ea9e99}


\hyperlink{classSimObject_a0f0761d2db586a23bb2a2880b8f387bb}{SimObject}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classNetworkInterface_aaf2a99dc56c8a507bc84059dac4db78b}{
\index{NetworkInterface@{NetworkInterface}!NetworkInterface@{NetworkInterface}}
\index{NetworkInterface@{NetworkInterface}!NetworkInterface@{NetworkInterface}}
\subsubsection[{NetworkInterface}]{\setlength{\rightskip}{0pt plus 5cm}{\bf NetworkInterface} (const {\bf Params} $\ast$ {\em p})}}
\label{classNetworkInterface_aaf2a99dc56c8a507bc84059dac4db78b}



\begin{DoxyCode}
46     : ClockedObject(p), FlexibleConsumer(this)
47 {
48     m_id = p->id;
49     m_virtual_networks  = p->virt_nets;
50     m_vc_per_vnet = p->vcs_per_vnet;
51     m_num_vcs = m_vc_per_vnet*m_virtual_networks;
52 
53     m_vc_round_robin = 0;
54     m_ni_buffers.resize(m_num_vcs);
55     inNode_ptr.resize(m_virtual_networks);
56     outNode_ptr.resize(m_virtual_networks);
57 
58     // instantiating the NI flit buffers
59     for (int i =0; i < m_num_vcs; i++)
60         m_ni_buffers[i] = new flitBuffer();
61 
62     m_vc_allocator.resize(m_virtual_networks);
63     for (int i = 0; i < m_virtual_networks; i++) {
64         m_vc_allocator[i] = 0;
65     }
66 
67     for (int i = 0; i < m_num_vcs; i++) {
68         m_out_vc_state.push_back(new OutVcState(i));
69     }
70 }
\end{DoxyCode}
\hypertarget{classNetworkInterface_adb551ec6b647bebdc200a6f3d856be0b}{
\index{NetworkInterface@{NetworkInterface}!$\sim$NetworkInterface@{$\sim$NetworkInterface}}
\index{$\sim$NetworkInterface@{$\sim$NetworkInterface}!NetworkInterface@{NetworkInterface}}
\subsubsection[{$\sim$NetworkInterface}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf NetworkInterface} ()}}
\label{classNetworkInterface_adb551ec6b647bebdc200a6f3d856be0b}



\begin{DoxyCode}
73 {
74     deletePointers(m_out_vc_state);
75     deletePointers(m_ni_buffers);
76     delete outSrcQueue;
77 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classNetworkInterface_a861b99bda673a31b1b48132ed9369f28}{
\index{NetworkInterface@{NetworkInterface}!addInPort@{addInPort}}
\index{addInPort@{addInPort}!NetworkInterface@{NetworkInterface}}
\subsubsection[{addInPort}]{\setlength{\rightskip}{0pt plus 5cm}void addInPort ({\bf NetworkLink} $\ast$ {\em in\_\-link})}}
\label{classNetworkInterface_a861b99bda673a31b1b48132ed9369f28}



\begin{DoxyCode}
81 {
82     inNetLink = in_link;
83     in_link->setLinkConsumer(this);
84 }
\end{DoxyCode}
\hypertarget{classNetworkInterface_abb78e667f7f184a1989354ba522d32a9}{
\index{NetworkInterface@{NetworkInterface}!addNode@{addNode}}
\index{addNode@{addNode}!NetworkInterface@{NetworkInterface}}
\subsubsection[{addNode}]{\setlength{\rightskip}{0pt plus 5cm}void addNode ({\bf std::vector}$<$ {\bf MessageBuffer} $\ast$ $>$ \& {\em inNode}, \/  {\bf std::vector}$<$ {\bf MessageBuffer} $\ast$ $>$ \& {\em outNode})}}
\label{classNetworkInterface_abb78e667f7f184a1989354ba522d32a9}



\begin{DoxyCode}
98 {
99     assert(in.size() == m_virtual_networks);
100     inNode_ptr = in;
101     outNode_ptr = out;
102 
103     // protocol injects messages into the NI
104     for (int j = 0; j < m_virtual_networks; j++) {
105         inNode_ptr[j]->setConsumer(this);
106         inNode_ptr[j]->setReceiver(this);
107         outNode_ptr[j]->setSender(this);
108     }
109 }
\end{DoxyCode}
\hypertarget{classNetworkInterface_ab38acc0d5f8c54260955ae391bb77715}{
\index{NetworkInterface@{NetworkInterface}!addOutPort@{addOutPort}}
\index{addOutPort@{addOutPort}!NetworkInterface@{NetworkInterface}}
\subsubsection[{addOutPort}]{\setlength{\rightskip}{0pt plus 5cm}void addOutPort ({\bf NetworkLink} $\ast$ {\em out\_\-link})}}
\label{classNetworkInterface_ab38acc0d5f8c54260955ae391bb77715}



\begin{DoxyCode}
88 {
89     outNetLink = out_link;
90     outSrcQueue = new flitBuffer();
91     out_link->setSourceQueue(outSrcQueue);
92     out_link->setSource(this);
93 }
\end{DoxyCode}
\hypertarget{classNetworkInterface_ab27658cc3136de94d2d08c78ac499aff}{
\index{NetworkInterface@{NetworkInterface}!calculateVC@{calculateVC}}
\index{calculateVC@{calculateVC}!NetworkInterface@{NetworkInterface}}
\subsubsection[{calculateVC}]{\setlength{\rightskip}{0pt plus 5cm}int calculateVC (int {\em vnet})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface_ab27658cc3136de94d2d08c78ac499aff}



\begin{DoxyCode}
209 {
210     int vc_per_vnet;
211     if (m_net_ptr->isVNetOrdered(vnet))
212         vc_per_vnet = 1;
213     else
214         vc_per_vnet = m_vc_per_vnet;
215 
216     for (int i = 0; i < vc_per_vnet; i++) {
217         int delta = m_vc_allocator[vnet];
218         m_vc_allocator[vnet]++;
219         if (m_vc_allocator[vnet] == vc_per_vnet)
220             m_vc_allocator[vnet] = 0;
221 
222         if (m_out_vc_state[(vnet*m_vc_per_vnet) + delta]->
223                 isInState(IDLE_, curCycle())) {
224             return ((vnet*m_vc_per_vnet) + delta);
225         }
226     }
227     return -1;
228 }
\end{DoxyCode}
\hypertarget{classNetworkInterface_af954e8e2150e2ce2e1b87081bbd9c678}{
\index{NetworkInterface@{NetworkInterface}!checkReschedule@{checkReschedule}}
\index{checkReschedule@{checkReschedule}!NetworkInterface@{NetworkInterface}}
\subsubsection[{checkReschedule}]{\setlength{\rightskip}{0pt plus 5cm}void checkReschedule ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface_af954e8e2150e2ce2e1b87081bbd9c678}



\begin{DoxyCode}
326 {
327     for (int vnet = 0; vnet < m_virtual_networks; vnet++) {
328         if (inNode_ptr[vnet]->isReady()) { // Is there a message waiting
329             scheduleEvent(Cycles(1));
330             return;
331         }
332     }
333     for (int vc = 0; vc < m_num_vcs; vc++) {
334         if (m_ni_buffers[vc]->isReadyForNext(curCycle())) {
335             scheduleEvent(Cycles(1));
336             return;
337         }
338     }
339 }
\end{DoxyCode}
\hypertarget{classNetworkInterface_a12a9945591ab6cd27b4cf0df84786cf8}{
\index{NetworkInterface@{NetworkInterface}!flitisizeMessage@{flitisizeMessage}}
\index{flitisizeMessage@{flitisizeMessage}!NetworkInterface@{NetworkInterface}}
\subsubsection[{flitisizeMessage}]{\setlength{\rightskip}{0pt plus 5cm}bool flitisizeMessage ({\bf MsgPtr} {\em msg\_\-ptr}, \/  int {\em vnet})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface_a12a9945591ab6cd27b4cf0df84786cf8}



\begin{DoxyCode}
120 {
121     NetworkMessage *net_msg_ptr = safe_cast<NetworkMessage *>(msg_ptr.get());
122     NetDest net_msg_dest = net_msg_ptr->getInternalDestination();
123 
124     // get all the destinations associated with this message.
125     vector<NodeID> dest_nodes = net_msg_dest.getAllDest();
126 
127     // Number of flits is dependent on the link bandwidth available.
128     // This is expressed in terms of bytes/cycle or the flit size
129 
130     int num_flits = (int) ceil((double) m_net_ptr->MessageSizeType_to_int(
131                 net_msg_ptr->getMessageSize())/m_net_ptr->getNiFlitSize());
132 
133     // loop to convert all multicast messages into unicast messages
134     for (int ctr = 0; ctr < dest_nodes.size(); ctr++) {
135         int vc = calculateVC(vnet); // this will return a free output vc
136 
137         if (vc == -1) {
138             // did not find a free output vc
139             return false ;
140         }
141         MsgPtr new_msg_ptr = msg_ptr->clone();
142         NodeID destID = dest_nodes[ctr];
143 
144         NetworkMessage *new_net_msg_ptr =
145             safe_cast<NetworkMessage *>(new_msg_ptr.get());
146         if (dest_nodes.size() > 1) {
147             NetDest personal_dest;
148             for (int m = 0; m < (int) MachineType_NUM; m++) {
149                 if ((destID >= MachineType_base_number((MachineType) m)) &&
150                     destID < MachineType_base_number((MachineType) (m+1))) {
151                     // calculating the NetDest associated with this destID
152                     personal_dest.clear();
153                     personal_dest.add((MachineID) {(MachineType) m, (destID -
154                         MachineType_base_number((MachineType) m))});
155                     new_net_msg_ptr->getInternalDestination() = personal_dest;
156                     break;
157                 }
158             }
159             net_msg_dest.removeNetDest(personal_dest);
160 
161             // removing the destination from the original message to reflect
162             // that a message with this particular destination has been
163             // flitisized and an output vc is acquired
164             net_msg_ptr->getInternalDestination().removeNetDest(personal_dest);
165         }
166         for (int i = 0; i < num_flits; i++) {
167             m_net_ptr->increment_injected_flits(vnet);
168             flit *fl = new flit(i, vc, vnet, num_flits, new_msg_ptr,
169                                 curCycle());
170             fl->set_delay(curCycle() - ticksToCycles(msg_ptr->getTime()));
171             m_ni_buffers[vc]->insert(fl);
172         }
173 
174         m_out_vc_state[vc]->setState(VC_AB_, curCycle());
175 
176         // setting an output vc request for the next hop.
177         // This flit will be ready to traverse the link and into the next hop
178         // only when an output vc is acquired at the next hop
179         outNetLink->request_vc_link(
180                 vc, new_net_msg_ptr->getInternalDestination(), curCycle());
181     }
182 
183     return true ;
184 }
\end{DoxyCode}
\hypertarget{classNetworkInterface_a6db56c593ee28a561c47e75a859300dd}{
\index{NetworkInterface@{NetworkInterface}!functionalRead@{functionalRead}}
\index{functionalRead@{functionalRead}!NetworkInterface@{NetworkInterface}}
\subsubsection[{functionalRead}]{\setlength{\rightskip}{0pt plus 5cm}bool functionalRead ({\bf Packet} $\ast$ {\em pkt})}}
\label{classNetworkInterface_a6db56c593ee28a561c47e75a859300dd}



\begin{DoxyCode}
343 {
344     // Go through the internal buffers
345     for (unsigned int i = 0; i < m_ni_buffers.size(); ++i) {
346         if (m_ni_buffers[i]->functionalRead(pkt)) {
347             return true;
348         }
349     }
350 
351     // Go through the buffer between this network interface and the router
352     if (outSrcQueue->functionalRead(pkt)) {
353         return true;
354     }
355 
356     return false;
357 }
\end{DoxyCode}
\hypertarget{classNetworkInterface_aba9037f662122b5f2e85647d35670e5c}{
\index{NetworkInterface@{NetworkInterface}!functionalWrite@{functionalWrite}}
\index{functionalWrite@{functionalWrite}!NetworkInterface@{NetworkInterface}}
\subsubsection[{functionalWrite}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} functionalWrite ({\bf Packet} $\ast$ {\em pkt})}}
\label{classNetworkInterface_aba9037f662122b5f2e85647d35670e5c}



\begin{DoxyCode}
361 {
362     uint32_t num_functional_writes = 0;
363     for (unsigned int i = 0; i < m_ni_buffers.size(); ++i) {
364         num_functional_writes += m_ni_buffers[i]->functionalWrite(pkt);
365     }
366 
367     num_functional_writes += outSrcQueue->functionalWrite(pkt);
368     return num_functional_writes;
369 }
\end{DoxyCode}
\hypertarget{classNetworkInterface_af90fb6c473130244fe64e30e61b714f6}{
\index{NetworkInterface@{NetworkInterface}!grant\_\-vc@{grant\_\-vc}}
\index{grant\_\-vc@{grant\_\-vc}!NetworkInterface@{NetworkInterface}}
\subsubsection[{grant\_\-vc}]{\setlength{\rightskip}{0pt plus 5cm}void grant\_\-vc (int {\em out\_\-port}, \/  int {\em vc}, \/  {\bf Cycles} {\em grant\_\-time})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classNetworkInterface_af90fb6c473130244fe64e30e61b714f6}


\hyperlink{classFlexibleConsumer_a775e8414113748731990f3979cdd4632}{FlexibleConsumer}を再定義しています。


\begin{DoxyCode}
190 {
191     assert(m_out_vc_state[vc]->isInState(VC_AB_, grant_time));
192     m_out_vc_state[vc]->grant_vc(grant_time);
193     scheduleEvent(Cycles(1));
194 }
\end{DoxyCode}
\hypertarget{classNetworkInterface_ab5da6a3c41f86ad2993eb11f4894ef00}{
\index{NetworkInterface@{NetworkInterface}!init\_\-net\_\-ptr@{init\_\-net\_\-ptr}}
\index{init\_\-net\_\-ptr@{init\_\-net\_\-ptr}!NetworkInterface@{NetworkInterface}}
\subsubsection[{init\_\-net\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}void init\_\-net\_\-ptr ({\bf GarnetNetwork} $\ast$ {\em net\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classNetworkInterface_ab5da6a3c41f86ad2993eb11f4894ef00}



\begin{DoxyCode}
75 { m_net_ptr = net_ptr; }
\end{DoxyCode}
\hypertarget{classNetworkInterface_af3465adbf20f8764ea878ce2d28d2bc8}{
\index{NetworkInterface@{NetworkInterface}!isBufferNotFull@{isBufferNotFull}}
\index{isBufferNotFull@{isBufferNotFull}!NetworkInterface@{NetworkInterface}}
\subsubsection[{isBufferNotFull}]{\setlength{\rightskip}{0pt plus 5cm}bool isBufferNotFull (int {\em vc}, \/  int {\em inport})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classNetworkInterface_af3465adbf20f8764ea878ce2d28d2bc8}


\hyperlink{classFlexibleConsumer_aa3732d20c1f3f94fb27ef60ac660f363}{FlexibleConsumer}を再定義しています。


\begin{DoxyCode}
66 { return true; }
\end{DoxyCode}
\hypertarget{classNetworkInterface_ac55fe386a101fbae38c716067c9966a0}{
\index{NetworkInterface@{NetworkInterface}!print@{print}}
\index{print@{print}!NetworkInterface@{NetworkInterface}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}void print (std::ostream \& {\em out}) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classNetworkInterface_ac55fe386a101fbae38c716067c9966a0}


\hyperlink{classConsumer_a3ea5f7af5db62cc24f4e40df9ea5c971}{Consumer}を実装しています。


\begin{DoxyCode}
373 {
374     out << "[Network Interface]";
375 }
\end{DoxyCode}
\hypertarget{classNetworkInterface_adced7fd7d25eb0d6a869fff14085e8c3}{
\index{NetworkInterface@{NetworkInterface}!release\_\-vc@{release\_\-vc}}
\index{release\_\-vc@{release\_\-vc}!NetworkInterface@{NetworkInterface}}
\subsubsection[{release\_\-vc}]{\setlength{\rightskip}{0pt plus 5cm}void release\_\-vc (int {\em out\_\-port}, \/  int {\em vc}, \/  {\bf Cycles} {\em release\_\-time})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classNetworkInterface_adced7fd7d25eb0d6a869fff14085e8c3}


\hyperlink{classFlexibleConsumer_a54d4f8948ced53110ed96024a64adf7e}{FlexibleConsumer}を再定義しています。


\begin{DoxyCode}
200 {
201     assert(m_out_vc_state[vc]->isInState(ACTIVE_, release_time));
202     m_out_vc_state[vc]->setState(IDLE_, release_time);
203     scheduleEvent(Cycles(1));
204 }
\end{DoxyCode}
\hypertarget{classNetworkInterface_ac2db714adfe0dfd2c3ac2b88bd6a5308}{
\index{NetworkInterface@{NetworkInterface}!request\_\-vc@{request\_\-vc}}
\index{request\_\-vc@{request\_\-vc}!NetworkInterface@{NetworkInterface}}
\subsubsection[{request\_\-vc}]{\setlength{\rightskip}{0pt plus 5cm}void request\_\-vc (int {\em in\_\-vc}, \/  int {\em in\_\-port}, \/  {\bf NetDest} {\em destination}, \/  {\bf Cycles} {\em request\_\-time})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classNetworkInterface_ac2db714adfe0dfd2c3ac2b88bd6a5308}


\hyperlink{classFlexibleConsumer_aa0ffe58ceb5a05129736d59f3eeabcf0}{FlexibleConsumer}を再定義しています。


\begin{DoxyCode}
114 {
115     inNetLink->grant_vc_link(in_vc, request_time);
116 }
\end{DoxyCode}
\hypertarget{classNetworkInterface_a0b5091af4210988da9a7eeb44e5691e4}{
\index{NetworkInterface@{NetworkInterface}!scheduleOutputLink@{scheduleOutputLink}}
\index{scheduleOutputLink@{scheduleOutputLink}!NetworkInterface@{NetworkInterface}}
\subsubsection[{scheduleOutputLink}]{\setlength{\rightskip}{0pt plus 5cm}void scheduleOutputLink ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface_a0b5091af4210988da9a7eeb44e5691e4}



\begin{DoxyCode}
296 {
297     int vc = m_vc_round_robin;
298     m_vc_round_robin++;
299     if (m_vc_round_robin == m_num_vcs)
300         m_vc_round_robin = 0;
301 
302     for (int i = 0; i < m_num_vcs; i++) {
303         vc++;
304         if (vc == m_num_vcs)
305             vc = 0;
306         if (m_ni_buffers[vc]->isReady(curCycle())) {
307             if (m_out_vc_state[vc]->isInState(ACTIVE_, curCycle()) &&
308                outNetLink->isBufferNotFull_link(vc)) {  // buffer backpressure
309 
310                 // Just removing the flit
311                 flit *t_flit = m_ni_buffers[vc]->getTopFlit();
312                 t_flit->set_time(curCycle() + Cycles(1));
313                 outSrcQueue->insert(t_flit);
314 
315                 // schedule the out link
316                 outNetLink->
317                     scheduleEventAbsolute(clockEdge(Cycles(1)));
318                 return;
319             }
320         }
321     }
322 }
\end{DoxyCode}
\hypertarget{classNetworkInterface_ae674290a26ecbd622c5160e38e8a4fe9}{
\index{NetworkInterface@{NetworkInterface}!wakeup@{wakeup}}
\index{wakeup@{wakeup}!NetworkInterface@{NetworkInterface}}
\subsubsection[{wakeup}]{\setlength{\rightskip}{0pt plus 5cm}void wakeup ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classNetworkInterface_ae674290a26ecbd622c5160e38e8a4fe9}


\hyperlink{classConsumer_a623e3e7d1b1c725d70009f7b01a421b9}{Consumer}を実装しています。


\begin{DoxyCode}
241 {
242     MsgPtr msg_ptr;
243 
244     //Checking for messages coming from the protocol
245     // can pick up a message/cycle for each virtual net
246     for (int vnet = 0; vnet < m_virtual_networks; vnet++) {
247         while (inNode_ptr[vnet]->isReady()) // Is there a message waiting
248         {
249             msg_ptr = inNode_ptr[vnet]->peekMsgPtr();
250             if (flitisizeMessage(msg_ptr, vnet)) {
251                 inNode_ptr[vnet]->dequeue();
252             } else {
253                 break;
254             }
255         }
256     }
257 
258     scheduleOutputLink();
259     checkReschedule();
260 
261     /*********** Picking messages destined for this NI **********/
262 
263     if (inNetLink->isReady()) {
264         flit *t_flit = inNetLink->consumeLink();
265         if (t_flit->get_type() == TAIL_ || t_flit->get_type() == HEAD_TAIL_) {
266             DPRINTF(RubyNetwork, "m_id: %d, Message delivered at time: %lld\n",
267                     m_id, curCycle());
268 
269             outNode_ptr[t_flit->get_vnet()]->enqueue(
270                 t_flit->get_msg_ptr(), Cycles(1));
271 
272             // signal the upstream router that this vc can be freed now
273             inNetLink->release_vc_link(t_flit->get_vc(),
274                     curCycle() + Cycles(1));
275         }
276 
277         int vnet = t_flit->get_vnet();
278         m_net_ptr->increment_received_flits(vnet);
279         Cycles network_delay = curCycle() - t_flit->get_enqueue_time();
280         Cycles queueing_delay = t_flit->get_delay();
281 
282         m_net_ptr->increment_network_latency(network_delay, vnet);
283         m_net_ptr->increment_queueing_latency(queueing_delay, vnet);
284         delete t_flit;
285     }
286 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classNetworkInterface_a7ce7214ee8901e3eebaf74366e556c20}{
\index{NetworkInterface@{NetworkInterface}!inNetLink@{inNetLink}}
\index{inNetLink@{inNetLink}!NetworkInterface@{NetworkInterface}}
\subsubsection[{inNetLink}]{\setlength{\rightskip}{0pt plus 5cm}{\bf NetworkLink}$\ast$ {\bf inNetLink}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface_a7ce7214ee8901e3eebaf74366e556c20}
\hypertarget{classNetworkInterface_a933eda70266204185e6bc2a65f0add98}{
\index{NetworkInterface@{NetworkInterface}!inNode\_\-ptr@{inNode\_\-ptr}}
\index{inNode\_\-ptr@{inNode\_\-ptr}!NetworkInterface@{NetworkInterface}}
\subsubsection[{inNode\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf MessageBuffer} $\ast$$>$ {\bf inNode\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface_a933eda70266204185e6bc2a65f0add98}
\hypertarget{classNetworkInterface_aaed4e1d0badfbd8b21e43869898ed184}{
\index{NetworkInterface@{NetworkInterface}!m\_\-id@{m\_\-id}}
\index{m\_\-id@{m\_\-id}!NetworkInterface@{NetworkInterface}}
\subsubsection[{m\_\-id}]{\setlength{\rightskip}{0pt plus 5cm}{\bf NodeID} {\bf m\_\-id}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface_aaed4e1d0badfbd8b21e43869898ed184}
\hypertarget{classNetworkInterface_a6f69c0ff922be798fa1cfce69f83244e}{
\index{NetworkInterface@{NetworkInterface}!m\_\-net\_\-ptr@{m\_\-net\_\-ptr}}
\index{m\_\-net\_\-ptr@{m\_\-net\_\-ptr}!NetworkInterface@{NetworkInterface}}
\subsubsection[{m\_\-net\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf GarnetNetwork}$\ast$ {\bf m\_\-net\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface_a6f69c0ff922be798fa1cfce69f83244e}
\hypertarget{classNetworkInterface_a278caf0cf6647c7e2bc1cb787662ea4e}{
\index{NetworkInterface@{NetworkInterface}!m\_\-ni\_\-buffers@{m\_\-ni\_\-buffers}}
\index{m\_\-ni\_\-buffers@{m\_\-ni\_\-buffers}!NetworkInterface@{NetworkInterface}}
\subsubsection[{m\_\-ni\_\-buffers}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf flitBuffer} $\ast$$>$ {\bf m\_\-ni\_\-buffers}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface_a278caf0cf6647c7e2bc1cb787662ea4e}
\hypertarget{classNetworkInterface_a42c554e0c38c6d9572a889f296afcd38}{
\index{NetworkInterface@{NetworkInterface}!m\_\-num\_\-vcs@{m\_\-num\_\-vcs}}
\index{m\_\-num\_\-vcs@{m\_\-num\_\-vcs}!NetworkInterface@{NetworkInterface}}
\subsubsection[{m\_\-num\_\-vcs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf m\_\-num\_\-vcs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface_a42c554e0c38c6d9572a889f296afcd38}
\hypertarget{classNetworkInterface_adeb08e3a1efa0be9efa58648b1edfb5c}{
\index{NetworkInterface@{NetworkInterface}!m\_\-out\_\-vc\_\-state@{m\_\-out\_\-vc\_\-state}}
\index{m\_\-out\_\-vc\_\-state@{m\_\-out\_\-vc\_\-state}!NetworkInterface@{NetworkInterface}}
\subsubsection[{m\_\-out\_\-vc\_\-state}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf OutVcState} $\ast$$>$ {\bf m\_\-out\_\-vc\_\-state}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface_adeb08e3a1efa0be9efa58648b1edfb5c}
\hypertarget{classNetworkInterface_a4e31a4f4aad8462157e797cdb1e3e00c}{
\index{NetworkInterface@{NetworkInterface}!m\_\-vc\_\-allocator@{m\_\-vc\_\-allocator}}
\index{m\_\-vc\_\-allocator@{m\_\-vc\_\-allocator}!NetworkInterface@{NetworkInterface}}
\subsubsection[{m\_\-vc\_\-allocator}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<$int$>$ {\bf m\_\-vc\_\-allocator}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface_a4e31a4f4aad8462157e797cdb1e3e00c}
\hypertarget{classNetworkInterface_a5391ff1054ec6311f1c449e769c14f83}{
\index{NetworkInterface@{NetworkInterface}!m\_\-vc\_\-per\_\-vnet@{m\_\-vc\_\-per\_\-vnet}}
\index{m\_\-vc\_\-per\_\-vnet@{m\_\-vc\_\-per\_\-vnet}!NetworkInterface@{NetworkInterface}}
\subsubsection[{m\_\-vc\_\-per\_\-vnet}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf m\_\-vc\_\-per\_\-vnet}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface_a5391ff1054ec6311f1c449e769c14f83}
\hypertarget{classNetworkInterface_a4e50d04fbae98d5e7eac566ab56f4227}{
\index{NetworkInterface@{NetworkInterface}!m\_\-vc\_\-round\_\-robin@{m\_\-vc\_\-round\_\-robin}}
\index{m\_\-vc\_\-round\_\-robin@{m\_\-vc\_\-round\_\-robin}!NetworkInterface@{NetworkInterface}}
\subsubsection[{m\_\-vc\_\-round\_\-robin}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-vc\_\-round\_\-robin}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface_a4e50d04fbae98d5e7eac566ab56f4227}
\hypertarget{classNetworkInterface_a3c1d97c5d987e52985843dcb76edc7fb}{
\index{NetworkInterface@{NetworkInterface}!m\_\-virtual\_\-networks@{m\_\-virtual\_\-networks}}
\index{m\_\-virtual\_\-networks@{m\_\-virtual\_\-networks}!NetworkInterface@{NetworkInterface}}
\subsubsection[{m\_\-virtual\_\-networks}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf m\_\-virtual\_\-networks}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface_a3c1d97c5d987e52985843dcb76edc7fb}
\hypertarget{classNetworkInterface_a6175110fc176a7aeb64b1ea1df878c6f}{
\index{NetworkInterface@{NetworkInterface}!outNetLink@{outNetLink}}
\index{outNetLink@{outNetLink}!NetworkInterface@{NetworkInterface}}
\subsubsection[{outNetLink}]{\setlength{\rightskip}{0pt plus 5cm}{\bf NetworkLink}$\ast$ {\bf outNetLink}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface_a6175110fc176a7aeb64b1ea1df878c6f}
\hypertarget{classNetworkInterface_aff22e632df88a83fbcbac281efec0dcc}{
\index{NetworkInterface@{NetworkInterface}!outNode\_\-ptr@{outNode\_\-ptr}}
\index{outNode\_\-ptr@{outNode\_\-ptr}!NetworkInterface@{NetworkInterface}}
\subsubsection[{outNode\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf MessageBuffer} $\ast$$>$ {\bf outNode\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface_aff22e632df88a83fbcbac281efec0dcc}
\hypertarget{classNetworkInterface_a7c2f0247427488afa8f925d46c82195e}{
\index{NetworkInterface@{NetworkInterface}!outSrcQueue@{outSrcQueue}}
\index{outSrcQueue@{outSrcQueue}!NetworkInterface@{NetworkInterface}}
\subsubsection[{outSrcQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf flitBuffer}$\ast$ {\bf outSrcQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classNetworkInterface_a7c2f0247427488afa8f925d46c82195e}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/ruby/network/garnet/flexible-\/pipeline/\hyperlink{NetworkInterface_8hh}{NetworkInterface.hh}\item 
mem/ruby/network/garnet/flexible-\/pipeline/\hyperlink{NetworkInterface_8cc}{NetworkInterface.cc}\end{DoxyCompactItemize}
