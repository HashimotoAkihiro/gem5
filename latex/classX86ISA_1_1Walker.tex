\hypertarget{classX86ISA_1_1Walker}{
\section{クラス Walker}
\label{classX86ISA_1_1Walker}\index{X86ISA::Walker@{X86ISA::Walker}}
}


{\ttfamily \#include $<$pagetable\_\-walker.hh$>$}Walkerに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=5cm]{classX86ISA_1_1Walker}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classX86ISA_1_1Walker_1_1WalkerPort}{WalkerPort}
\item 
struct \hyperlink{structX86ISA_1_1Walker_1_1WalkerSenderState}{WalkerSenderState}
\item 
class \hyperlink{classX86ISA_1_1Walker_1_1WalkerState}{WalkerState}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef X86PagetableWalkerParams \hyperlink{classX86ISA_1_1Walker_a55ceaa41cdace6176b677cc22eb01bf6}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classX86ISA_1_1Walker_af431777dfd02888658d8bf01cc7ee789}{start} (\hyperlink{classThreadContext}{ThreadContext} $\ast$\_\-tc, \hyperlink{classBaseTLB_1_1Translation}{BaseTLB::Translation} $\ast$translation, \hyperlink{classRequest}{RequestPtr} req, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{BaseTLB::Mode} mode)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classX86ISA_1_1Walker_ad0337e2c2472a149328d21cd4310165f}{startFunctional} (\hyperlink{classThreadContext}{ThreadContext} $\ast$\_\-tc, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \&\hyperlink{namespaceX86ISA_ab705917f60c5566f9ce56a93f798b2e2}{addr}, unsigned \&logBytes, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{BaseTLB::Mode} mode)
\item 
\hyperlink{classBaseMasterPort}{BaseMasterPort} \& \hyperlink{classX86ISA_1_1Walker_adc4e675e51defbdd1e354dac729d0703}{getMasterPort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
void \hyperlink{classX86ISA_1_1Walker_a57c4132ed7eb199686bbcfb0de7722ac}{setTLB} (\hyperlink{classX86ISA_1_1TLB}{TLB} $\ast$\_\-tlb)
\item 
const \hyperlink{classX86ISA_1_1Walker_a55ceaa41cdace6176b677cc22eb01bf6}{Params} $\ast$ \hyperlink{classX86ISA_1_1Walker_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{classX86ISA_1_1Walker_a9a124fc3abef67f86629216ab6699ec0}{Walker} (const \hyperlink{classX86ISA_1_1Walker_a55ceaa41cdace6176b677cc22eb01bf6}{Params} $\ast$params)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classX86ISA_1_1Walker_a5cbf57f9ccdc6270d898ddca6d54905a}{startWalkWrapper} ()
\item 
bool \hyperlink{classX86ISA_1_1Walker_a482dba5588f4bee43e498875a61e5e0b}{recvTimingResp} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classX86ISA_1_1Walker_a29cb5a4f98063ce6e9210eacbdb35298}{recvRetry} ()
\item 
bool \hyperlink{classX86ISA_1_1Walker_ad26bf3182653f73846811f045dcaafb6}{sendTiming} (\hyperlink{classX86ISA_1_1Walker_1_1WalkerState}{WalkerState} $\ast$sendingState, \hyperlink{classPacket}{PacketPtr} pkt)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classX86ISA_1_1Walker_1_1WalkerPort}{WalkerPort} \hyperlink{classX86ISA_1_1Walker_a5934d4dbd0362d5d5d65c63ff6f247b0}{port}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classX86ISA_1_1Walker_1_1WalkerState}{WalkerState} $\ast$ $>$ \hyperlink{classX86ISA_1_1Walker_a5d2384e533dcdc7ac9570b89d6f39807}{currStates}
\item 
\hyperlink{classX86ISA_1_1Walker_1_1WalkerState}{WalkerState} \hyperlink{classX86ISA_1_1Walker_a5d3b5c10c016916fae2a38d5affcb907}{funcState}
\item 
\hyperlink{classX86ISA_1_1TLB}{TLB} $\ast$ \hyperlink{classX86ISA_1_1Walker_a9f0e11329a702fd34819769c899e4bd3}{tlb}
\item 
\hyperlink{classSystem}{System} $\ast$ \hyperlink{classX86ISA_1_1Walker_a8ae37465ba84acfef6af3e9b9e6dbbd5}{sys}
\item 
\hyperlink{request_8hh_ac366b729262fd8e7cbd3283da6f775cf}{MasterID} \hyperlink{classX86ISA_1_1Walker_a96ec6a422ac492d05f8b3edc5b58532b}{masterId}
\item 
unsigned \hyperlink{classX86ISA_1_1Walker_acd34c708c5a97f4ce631bb3b00404045}{numSquashable}
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classX86ISA_1_1Walker_a707eeb53fafd90cd7776b08a7acf6214}{WalkerPort}
\item 
class \hyperlink{classX86ISA_1_1Walker_ade52153fce1d8cac346d2287dc441289}{WalkerState}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classX86ISA_1_1Walker_a55ceaa41cdace6176b677cc22eb01bf6}{
\index{X86ISA::Walker@{X86ISA::Walker}!Params@{Params}}
\index{Params@{Params}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef X86PagetableWalkerParams {\bf Params}}}
\label{classX86ISA_1_1Walker_a55ceaa41cdace6176b677cc22eb01bf6}


\hyperlink{classMemObject_a905bbc621eeec0ed08859e21c8c95412}{MemObject}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classX86ISA_1_1Walker_a9a124fc3abef67f86629216ab6699ec0}{
\index{X86ISA::Walker@{X86ISA::Walker}!Walker@{Walker}}
\index{Walker@{Walker}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{Walker}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Walker} (const {\bf Params} $\ast$ {\em params})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Walker_a9a124fc3abef67f86629216ab6699ec0}



\begin{DoxyCode}
206                                      :
207             MemObject(params), port(name() + ".port", this),
208             funcState(this, NULL, NULL, true), tlb(NULL), sys(params->system),
209             masterId(sys->getMasterId(name())),
210             numSquashable(params->num_squash_per_cycle)
211         {
212         }
    };
\end{DoxyCode}


\subsection{関数}
\hypertarget{classX86ISA_1_1Walker_adc4e675e51defbdd1e354dac729d0703}{
\index{X86ISA::Walker@{X86ISA::Walker}!getMasterPort@{getMasterPort}}
\index{getMasterPort@{getMasterPort}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{getMasterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseMasterPort} \& getMasterPort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86ISA_1_1Walker_adc4e675e51defbdd1e354dac729d0703}
Get a master port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classMemObject_adc4e675e51defbdd1e354dac729d0703}{MemObject}を再定義しています。


\begin{DoxyCode}
184 {
185     if (if_name == "port")
186         return port;
187     else
188         return MemObject::getMasterPort(if_name, idx);
189 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{X86ISA::Walker@{X86ISA::Walker}!params@{params}}
\index{params@{params}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Walker_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classMemObject_acd3c3feb78ae7a8f88fe0f110a718dff}{MemObject}を再定義しています。


\begin{DoxyCode}
202         {
203             return static_cast<const Params *>(_params);
204         }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_a29cb5a4f98063ce6e9210eacbdb35298}{
\index{X86ISA::Walker@{X86ISA::Walker}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetry ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_a29cb5a4f98063ce6e9210eacbdb35298}



\begin{DoxyCode}
156 {
157     std::list<WalkerState *>::iterator iter;
158     for (iter = currStates.begin(); iter != currStates.end(); iter++) {
159         WalkerState * walkerState = *(iter);
160         if (walkerState->isRetrying()) {
161             walkerState->retry();
162         }
163     }
164 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_a482dba5588f4bee43e498875a61e5e0b}{
\index{X86ISA::Walker@{X86ISA::Walker}!recvTimingResp@{recvTimingResp}}
\index{recvTimingResp@{recvTimingResp}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{recvTimingResp}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingResp ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_a482dba5588f4bee43e498875a61e5e0b}



\begin{DoxyCode}
124 {
125     WalkerSenderState * senderState =
126         dynamic_cast<WalkerSenderState *>(pkt->popSenderState());
127     WalkerState * senderWalk = senderState->senderWalk;
128     bool walkComplete = senderWalk->recvPacket(pkt);
129     delete senderState;
130     if (walkComplete) {
131         std::list<WalkerState *>::iterator iter;
132         for (iter = currStates.begin(); iter != currStates.end(); iter++) {
133             WalkerState * walkerState = *(iter);
134             if (walkerState == senderWalk) {
135                 iter = currStates.erase(iter);
136                 break;
137             }
138         }
139         delete senderWalk;
140         // Since we block requests when another is outstanding, we
141         // need to check if there is a waiting request to be serviced
142         if (currStates.size())
143             startWalkWrapper();
144     }
145     return true;
146 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_ad26bf3182653f73846811f045dcaafb6}{
\index{X86ISA::Walker@{X86ISA::Walker}!sendTiming@{sendTiming}}
\index{sendTiming@{sendTiming}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{sendTiming}]{\setlength{\rightskip}{0pt plus 5cm}bool sendTiming ({\bf WalkerState} $\ast$ {\em sendingState}, \/  {\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_ad26bf3182653f73846811f045dcaafb6}



\begin{DoxyCode}
167 {
168     WalkerSenderState* walker_state = new WalkerSenderState(sendingState);
169     pkt->pushSenderState(walker_state);
170     if (port.sendTimingReq(pkt)) {
171         return true;
172     } else {
173         // undo the adding of the sender state and delete it, as we
174         // will do it again the next time we attempt to send it
175         pkt->popSenderState();
176         delete walker_state;
177         return false;
178     }
179 
180 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_a57c4132ed7eb199686bbcfb0de7722ac}{
\index{X86ISA::Walker@{X86ISA::Walker}!setTLB@{setTLB}}
\index{setTLB@{setTLB}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{setTLB}]{\setlength{\rightskip}{0pt plus 5cm}void setTLB ({\bf TLB} $\ast$ {\em \_\-tlb})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Walker_a57c4132ed7eb199686bbcfb0de7722ac}



\begin{DoxyCode}
194         {
195             tlb = _tlb;
196         }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_af431777dfd02888658d8bf01cc7ee789}{
\index{X86ISA::Walker@{X86ISA::Walker}!start@{start}}
\index{start@{start}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{start}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} start ({\bf ThreadContext} $\ast$ {\em \_\-tc}, \/  {\bf BaseTLB::Translation} $\ast$ {\em translation}, \/  {\bf RequestPtr} {\em req}, \/  {\bf BaseTLB::Mode} {\em mode})}}
\label{classX86ISA_1_1Walker_af431777dfd02888658d8bf01cc7ee789}
\hypertarget{classX86ISA_1_1Walker_ad0337e2c2472a149328d21cd4310165f}{
\index{X86ISA::Walker@{X86ISA::Walker}!startFunctional@{startFunctional}}
\index{startFunctional@{startFunctional}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{startFunctional}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} startFunctional ({\bf ThreadContext} $\ast$ {\em \_\-tc}, \/  {\bf Addr} \& {\em addr}, \/  unsigned \& {\em logBytes}, \/  {\bf BaseTLB::Mode} {\em mode})}}
\label{classX86ISA_1_1Walker_ad0337e2c2472a149328d21cd4310165f}



\begin{DoxyCode}
111 {
112     funcState.initState(_tc, _mode);
113     return funcState.startFunctional(addr, logBytes);
114 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_a5cbf57f9ccdc6270d898ddca6d54905a}{
\index{X86ISA::Walker@{X86ISA::Walker}!startWalkWrapper@{startWalkWrapper}}
\index{startWalkWrapper@{startWalkWrapper}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{startWalkWrapper}]{\setlength{\rightskip}{0pt plus 5cm}void startWalkWrapper ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_a5cbf57f9ccdc6270d898ddca6d54905a}



\begin{DoxyCode}
204 {
205     unsigned num_squashed = 0;
206     WalkerState *currState = currStates.front();
207     while ((num_squashed < numSquashable) && currState &&
208         currState->translation->squashed()) {
209         currStates.pop_front();
210         num_squashed++;
211 
212         DPRINTF(PageTableWalker, "Squashing table walk for address %#x\n",
213             currState->req->getVaddr());
214 
215         // finish the translation which will delete the translation object
216         currState->translation->finish(new UnimpFault("Squashed Inst"),
217                 currState->req, currState->tc, currState->mode);
218 
219         // delete the current request
220         delete currState;
221 
222         // check the next translation request, if it exists
223         if (currStates.size())
224             currState = currStates.front();
225         else
226             currState = NULL;
227     }
228     if (currState && !currState->wasStarted())
229         currState->startWalk();
230 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classX86ISA_1_1Walker_a707eeb53fafd90cd7776b08a7acf6214}{
\index{X86ISA::Walker@{X86ISA::Walker}!WalkerPort@{WalkerPort}}
\index{WalkerPort@{WalkerPort}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{WalkerPort}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf WalkerPort}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classX86ISA_1_1Walker_a707eeb53fafd90cd7776b08a7acf6214}
\hypertarget{classX86ISA_1_1Walker_ade52153fce1d8cac346d2287dc441289}{
\index{X86ISA::Walker@{X86ISA::Walker}!WalkerState@{WalkerState}}
\index{WalkerState@{WalkerState}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{WalkerState}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf WalkerState}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classX86ISA_1_1Walker_ade52153fce1d8cac346d2287dc441289}


\subsection{変数}
\hypertarget{classX86ISA_1_1Walker_a5d2384e533dcdc7ac9570b89d6f39807}{
\index{X86ISA::Walker@{X86ISA::Walker}!currStates@{currStates}}
\index{currStates@{currStates}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{currStates}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf WalkerState} $\ast$$>$ {\bf currStates}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_a5d2384e533dcdc7ac9570b89d6f39807}
\hypertarget{classX86ISA_1_1Walker_a5d3b5c10c016916fae2a38d5affcb907}{
\index{X86ISA::Walker@{X86ISA::Walker}!funcState@{funcState}}
\index{funcState@{funcState}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{funcState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf WalkerState} {\bf funcState}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_a5d3b5c10c016916fae2a38d5affcb907}
\hypertarget{classX86ISA_1_1Walker_a96ec6a422ac492d05f8b3edc5b58532b}{
\index{X86ISA::Walker@{X86ISA::Walker}!masterId@{masterId}}
\index{masterId@{masterId}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{masterId}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterID} {\bf masterId}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_a96ec6a422ac492d05f8b3edc5b58532b}
\hypertarget{classX86ISA_1_1Walker_acd34c708c5a97f4ce631bb3b00404045}{
\index{X86ISA::Walker@{X86ISA::Walker}!numSquashable@{numSquashable}}
\index{numSquashable@{numSquashable}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{numSquashable}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf numSquashable}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_acd34c708c5a97f4ce631bb3b00404045}
\hypertarget{classX86ISA_1_1Walker_a5934d4dbd0362d5d5d65c63ff6f247b0}{
\index{X86ISA::Walker@{X86ISA::Walker}!port@{port}}
\index{port@{port}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{port}]{\setlength{\rightskip}{0pt plus 5cm}{\bf WalkerPort} {\bf port}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_a5934d4dbd0362d5d5d65c63ff6f247b0}
\hypertarget{classX86ISA_1_1Walker_a8ae37465ba84acfef6af3e9b9e6dbbd5}{
\index{X86ISA::Walker@{X86ISA::Walker}!sys@{sys}}
\index{sys@{sys}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{sys}]{\setlength{\rightskip}{0pt plus 5cm}{\bf System}$\ast$ {\bf sys}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_a8ae37465ba84acfef6af3e9b9e6dbbd5}
\hypertarget{classX86ISA_1_1Walker_a9f0e11329a702fd34819769c899e4bd3}{
\index{X86ISA::Walker@{X86ISA::Walker}!tlb@{tlb}}
\index{tlb@{tlb}!X86ISA::Walker@{X86ISA::Walker}}
\subsubsection[{tlb}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TLB}$\ast$ {\bf tlb}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_a9f0e11329a702fd34819769c899e4bd3}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/x86/\hyperlink{pagetable__walker_8hh}{pagetable\_\-walker.hh}\item 
arch/x86/\hyperlink{pagetable__walker_8cc}{pagetable\_\-walker.cc}\end{DoxyCompactItemize}
