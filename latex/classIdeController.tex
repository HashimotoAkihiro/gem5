\hypertarget{classIdeController}{
\section{クラス IdeController}
\label{classIdeController}\index{IdeController@{IdeController}}
}


{\ttfamily \#include $<$ide\_\-ctrl.hh$>$}IdeControllerに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=8cm]{classIdeController}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef IdeControllerParams \hyperlink{classIdeController_ac3896424d9bf2d8a838f1e2c38870d02}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
const \hyperlink{classIdeController_ac3896424d9bf2d8a838f1e2c38870d02}{Params} $\ast$ \hyperlink{classIdeController_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{classIdeController_a3e91790659f429bea2b288d4809e97ab}{IdeController} (\hyperlink{classIdeController_ac3896424d9bf2d8a838f1e2c38870d02}{Params} $\ast$p)
\item 
bool \hyperlink{classIdeController_ab16ba5b7c8f5e314b4003eb4bf9d40bf}{isDiskSelected} (\hyperlink{classIdeDisk}{IdeDisk} $\ast$diskPtr)
\item 
void \hyperlink{classIdeController_aba6fa755ca152cedafeb4150da6a2493}{intrPost} ()
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIdeController_aac7b61a78530109bfa20923a53064bbf}{writeConfig} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIdeController_a9dfb5284eadd79fffef97ba1bd69f3c4}{readConfig} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classIdeController_ab3f8a4d9fa9f33c71d23a803142e9faa}{setDmaComplete} (\hyperlink{classIdeDisk}{IdeDisk} $\ast$disk)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIdeController_a613ec7d5e1ec64f8d21fec78ae8e568e}{read} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIdeController_a4cefab464e72b5dd42c003a0a4341802}{write} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classIdeController_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
void \hyperlink{classIdeController_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classIdeController_a72e04acd6bb1c97077b13a250648674e}{BitUnion8} (BMIStatusReg) Bitfield$<$ 6 $>$ dmaCap0
\item 
\hyperlink{classIdeController_af3c5b204b2ea4a04c542ab8f915dae04}{EndBitUnion} (BMIStatusReg) BitUnion8(BMICommandReg) Bitfield$<$ 3 $>$ rw
\item 
\hyperlink{classIdeController_a104cf32518c5d5e9cd2b85d06e4783a9}{EndBitUnion} (BMICommandReg) struct Channel
\item 
void \hyperlink{classIdeController_ada0391144816c248c9824a65d02e9bad}{dispatchAccess} (\hyperlink{classPacket}{PacketPtr} pkt, bool read)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
Bitfield$<$ 5 $>$ \hyperlink{classIdeController_aba4f51816e2ec54f12f4c9724d3b281f}{dmaCap1}
\item 
Bitfield$<$ 2 $>$ \hyperlink{classIdeController_a6bf8072c32ffee0d4d03eb90ce4a3810}{intStatus}
\item 
Bitfield$<$ 1 $>$ \hyperlink{classIdeController_a3f71da290d4bdbfb6f14d5055a556d20}{dmaError}
\item 
Bitfield$<$ 0 $>$ \hyperlink{classIdeController_a12698e64814a9728d71424fcf5148f4d}{active}
\item 
Bitfield$<$ 0 $>$ \hyperlink{classIdeController_ace5af3160a3a76b4a51e864f74b16ae5}{startStop}
\item 
Channel \hyperlink{classIdeController_ab99c7b03cc88be094081c9dee0d4f3d7}{primary}
\item 
Channel \hyperlink{classIdeController_a9ffe401d4b082d4a20f74809ed096f62}{secondary}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classIdeController_aeea2cd1022ed55ebf9ba284ea44b1b3b}{bmiAddr}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classIdeController_a52be8db14c9c7207569db87b8a153c08}{bmiSize}
\item 
uint16\_\-t \hyperlink{classIdeController_ae3a3e441e5eccb9c386260eeb3968878}{primaryTiming}
\item 
uint16\_\-t \hyperlink{classIdeController_a1611c0c216198aa88de03e3ebfd22b43}{secondaryTiming}
\item 
uint8\_\-t \hyperlink{classIdeController_a11159e29742cfa070446c2ae522aadb2}{deviceTiming}
\item 
uint8\_\-t \hyperlink{classIdeController_a3bc817e4be51f2e1aeb1701ce144cbf1}{udmaControl}
\item 
uint16\_\-t \hyperlink{classIdeController_af5a85382debfe463bfebc5ab59624aa5}{udmaTiming}
\item 
uint16\_\-t \hyperlink{classIdeController_accc39274caa412bf5447d8fad2822dda}{ideConfig}
\item 
bool \hyperlink{classIdeController_ab91aa36ae35d81d85815bd14a704c736}{ioEnabled}
\item 
bool \hyperlink{classIdeController_a9e6c0c0f31990b6cde50661d497ab70f}{bmEnabled}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classIdeController_a717c1373270d47ce8b3da7a0bf9ba29e}{ioShift}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classIdeController_a6f85d0e8ddf9ba7c01968f1b37725067}{ctrlOffset}
\end{DoxyCompactItemize}


\subsection{説明}
\hyperlink{namespaceDevice}{Device} model for an Intel PIIX4 IDE controller 

\subsection{型定義}
\hypertarget{classIdeController_ac3896424d9bf2d8a838f1e2c38870d02}{
\index{IdeController@{IdeController}!Params@{Params}}
\index{Params@{Params}!IdeController@{IdeController}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef IdeControllerParams {\bf Params}}}
\label{classIdeController_ac3896424d9bf2d8a838f1e2c38870d02}


\hyperlink{classPciDevice_aefbfd3f2d9daf3173b779eeff32e8112}{PciDevice}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classIdeController_a3e91790659f429bea2b288d4809e97ab}{
\index{IdeController@{IdeController}!IdeController@{IdeController}}
\index{IdeController@{IdeController}!IdeController@{IdeController}}
\subsubsection[{IdeController}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IdeController} ({\bf Params} $\ast$ {\em p})}}
\label{classIdeController_a3e91790659f429bea2b288d4809e97ab}



\begin{DoxyCode}
95     : PciDevice(p), primary(name() + ".primary", BARSize[0], BARSize[1]),
96     secondary(name() + ".secondary", BARSize[2], BARSize[3]),
97     bmiAddr(0), bmiSize(BARSize[4]),
98     primaryTiming(htole(timeRegWithDecodeEn)),
99     secondaryTiming(htole(timeRegWithDecodeEn)),
100     deviceTiming(0), udmaControl(0), udmaTiming(0), ideConfig(0),
101     ioEnabled(false), bmEnabled(false),
102     ioShift(p->io_shift), ctrlOffset(p->ctrl_offset)
103 {
104     if (params()->disks.size() > 3)
105         panic("IDE controllers support a maximum of 4 devices attached!\n");
106 
107     // Assign the disks to channels
108     int numDisks = params()->disks.size();
109     if (numDisks > 0)
110         primary.master = params()->disks[0];
111     if (numDisks > 1)
112         primary.slave = params()->disks[1];
113     if (numDisks > 2)
114         secondary.master = params()->disks[2];
115     if (numDisks > 3)
116         secondary.slave = params()->disks[3];
117 
118     for (int i = 0; i < params()->disks.size(); i++) {
119         params()->disks[i]->setController(this);
120     }
121     primary.select(false);
122     secondary.select(false);
123 
124     if ((BARAddrs[0] & ~BAR_IO_MASK) && (!legacyIO[0] || ioShift)) {
125         primary.cmdAddr = BARAddrs[0];  primary.cmdSize = BARSize[0];
126         primary.ctrlAddr = BARAddrs[1]; primary.ctrlSize = BARSize[1];
127     }
128     if ((BARAddrs[2] & ~BAR_IO_MASK) && (!legacyIO[2] || ioShift)) {
129         secondary.cmdAddr = BARAddrs[2];  secondary.cmdSize = BARSize[2];
130         secondary.ctrlAddr = BARAddrs[3]; secondary.ctrlSize = BARSize[3];
131     }
132 
133     ioEnabled = (config.command & htole(PCI_CMD_IOSE));
134     bmEnabled = (config.command & htole(PCI_CMD_BME));
135 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classIdeController_a72e04acd6bb1c97077b13a250648674e}{
\index{IdeController@{IdeController}!BitUnion8@{BitUnion8}}
\index{BitUnion8@{BitUnion8}!IdeController@{IdeController}}
\subsubsection[{BitUnion8}]{\setlength{\rightskip}{0pt plus 5cm}BitUnion8 (BMIStatusReg)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_a72e04acd6bb1c97077b13a250648674e}
\hypertarget{classIdeController_ada0391144816c248c9824a65d02e9bad}{
\index{IdeController@{IdeController}!dispatchAccess@{dispatchAccess}}
\index{dispatchAccess@{dispatchAccess}!IdeController@{IdeController}}
\subsubsection[{dispatchAccess}]{\setlength{\rightskip}{0pt plus 5cm}void dispatchAccess ({\bf PacketPtr} {\em pkt}, \/  bool {\em read})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_ada0391144816c248c9824a65d02e9bad}



\begin{DoxyCode}
464 {
465     pkt->allocate();
466     if (pkt->getSize() != 1 && pkt->getSize() != 2 && pkt->getSize() !=4)
467          panic("Bad IDE read size: %d\n", pkt->getSize());
468 
469     if (!ioEnabled) {
470         pkt->makeAtomicResponse();
471         DPRINTF(IdeCtrl, "io not enabled\n");
472         return;
473     }
474 
475     Addr addr = pkt->getAddr();
476     int size = pkt->getSize();
477     uint8_t *dataPtr = pkt->getPtr<uint8_t>();
478 
479     if (addr >= primary.cmdAddr &&
480             addr < (primary.cmdAddr + primary.cmdSize)) {
481         addr -= primary.cmdAddr;
482         // linux may have shifted the address by ioShift,
483         // here we shift it back, similarly for ctrlOffset.
484         addr >>= ioShift;
485         primary.accessCommand(addr, size, dataPtr, read);
486     } else if (addr >= primary.ctrlAddr &&
487                addr < (primary.ctrlAddr + primary.ctrlSize)) {
488         addr -= primary.ctrlAddr;
489         addr += ctrlOffset;
490         primary.accessControl(addr, size, dataPtr, read);
491     } else if (addr >= secondary.cmdAddr &&
492                addr < (secondary.cmdAddr + secondary.cmdSize)) {
493         addr -= secondary.cmdAddr;
494         secondary.accessCommand(addr, size, dataPtr, read);
495     } else if (addr >= secondary.ctrlAddr &&
496                addr < (secondary.ctrlAddr + secondary.ctrlSize)) {
497         addr -= secondary.ctrlAddr;
498         secondary.accessControl(addr, size, dataPtr, read);
499     } else if (addr >= bmiAddr && addr < (bmiAddr + bmiSize)) {
500         if (!read && !bmEnabled)
501             return;
502         addr -= bmiAddr;
503         if (addr < sizeof(Channel::BMIRegs)) {
504             primary.accessBMI(addr, size, dataPtr, read);
505         } else {
506             addr -= sizeof(Channel::BMIRegs);
507             secondary.accessBMI(addr, size, dataPtr, read);
508         }
509     } else {
510         panic("IDE controller access to invalid address: %#x\n", addr);
511     }
512 
513 #ifndef NDEBUG
514     uint32_t data;
515     if (pkt->getSize() == 1)
516         data = pkt->get<uint8_t>();
517     else if (pkt->getSize() == 2)
518         data = pkt->get<uint16_t>();
519     else
520         data = pkt->get<uint32_t>();
521     DPRINTF(IdeCtrl, "%s from offset: %#x size: %#x data: %#x\n",
522             read ? "Read" : "Write", pkt->getAddr(), pkt->getSize(), data);
523 #endif
524 
525     pkt->makeAtomicResponse();
526 }
\end{DoxyCode}
\hypertarget{classIdeController_a104cf32518c5d5e9cd2b85d06e4783a9}{
\index{IdeController@{IdeController}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!IdeController@{IdeController}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion (BMICommandReg)\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classIdeController_a104cf32518c5d5e9cd2b85d06e4783a9}


Command and control block registers

Registers used for bus master interface

IDE disks connected to this controller

Currently selected disk 


\begin{DoxyCode}
70     {
71         std::string _name;
72 
73         const std::string
74         name()
75         {
76             return _name;
77         }
78 
80         Addr cmdAddr, cmdSize, ctrlAddr, ctrlSize;
81 
83         struct BMIRegs
84         {
85             BMICommandReg command;
86             uint8_t reserved0;
87             BMIStatusReg status;
88             uint8_t reserved1;
89             uint32_t bmidtp;
90         } bmiRegs;
91 
93         IdeDisk *master, *slave;
94 
96         IdeDisk *selected;
97 
98         bool selectBit;
99 
100         void
101         select(bool selSlave)
102         {
103             selectBit = selSlave;
104             selected = selectBit ? slave : master;
105         }
106 
107         void accessCommand(Addr offset, int size, uint8_t *data, bool read);
108         void accessControl(Addr offset, int size, uint8_t *data, bool read);
109         void accessBMI(Addr offset, int size, uint8_t *data, bool read);
110 
111         Channel(std::string newName, Addr _cmdSize, Addr _ctrlSize);
112         ~Channel();
113 
114         void serialize(const std::string &base, std::ostream &os);
115         void unserialize(const std::string &base, Checkpoint *cp,
116             const std::string &section);
117     };
\end{DoxyCode}
\hypertarget{classIdeController_af3c5b204b2ea4a04c542ab8f915dae04}{
\index{IdeController@{IdeController}!EndBitUnion@{EndBitUnion}}
\index{EndBitUnion@{EndBitUnion}!IdeController@{IdeController}}
\subsubsection[{EndBitUnion}]{\setlength{\rightskip}{0pt plus 5cm}EndBitUnion (BMIStatusReg)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_af3c5b204b2ea4a04c542ab8f915dae04}
\hypertarget{classIdeController_aba6fa755ca152cedafeb4150da6a2493}{
\index{IdeController@{IdeController}!intrPost@{intrPost}}
\index{intrPost@{intrPost}!IdeController@{IdeController}}
\subsubsection[{intrPost}]{\setlength{\rightskip}{0pt plus 5cm}void intrPost ()}}
\label{classIdeController_aba6fa755ca152cedafeb4150da6a2493}


\hyperlink{classPciDevice_aba6fa755ca152cedafeb4150da6a2493}{PciDevice}を再定義しています。


\begin{DoxyCode}
145 {
146     primary.bmiRegs.status.intStatus = 1;
147     PciDevice::intrPost();
148 }
\end{DoxyCode}
\hypertarget{classIdeController_ab16ba5b7c8f5e314b4003eb4bf9d40bf}{
\index{IdeController@{IdeController}!isDiskSelected@{isDiskSelected}}
\index{isDiskSelected@{isDiskSelected}!IdeController@{IdeController}}
\subsubsection[{isDiskSelected}]{\setlength{\rightskip}{0pt plus 5cm}bool isDiskSelected ({\bf IdeDisk} $\ast$ {\em diskPtr})}}
\label{classIdeController_ab16ba5b7c8f5e314b4003eb4bf9d40bf}
See if a disk is selected based on its pointer 


\begin{DoxyCode}
139 {
140     return (primary.selected == diskPtr || secondary.selected == diskPtr);
141 }
\end{DoxyCode}
\hypertarget{classIdeController_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{IdeController@{IdeController}!params@{params}}
\index{params@{params}!IdeController@{IdeController}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classIdeController_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classPciDevice_acd3c3feb78ae7a8f88fe0f110a718dff}{PciDevice}を再定義しています。


\begin{DoxyCode}
142 { return (const Params *)_params; }
\end{DoxyCode}
\hypertarget{classIdeController_a613ec7d5e1ec64f8d21fec78ae8e568e}{
\index{IdeController@{IdeController}!read@{read}}
\index{read@{read}!IdeController@{IdeController}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} read ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIdeController_a613ec7d5e1ec64f8d21fec78ae8e568e}
Pure virtual function that the device must implement. Called when a read command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_a842312590432036092c422c87a442358}{PioDevice}を実装しています。


\begin{DoxyCode}
530 {
531     dispatchAccess(pkt, true);
532     return pioDelay;
533 }
\end{DoxyCode}
\hypertarget{classIdeController_a9dfb5284eadd79fffef97ba1bd69f3c4}{
\index{IdeController@{IdeController}!readConfig@{readConfig}}
\index{readConfig@{readConfig}!IdeController@{IdeController}}
\subsubsection[{readConfig}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} readConfig ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIdeController_a9dfb5284eadd79fffef97ba1bd69f3c4}
Read from the PCI config space data that is stored locally. This may be overridden by the device but at some point it will eventually call this for normal operations that it does not need to override. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]packet containing the write the offset into config space \end{DoxyParams}


\hyperlink{classPciDevice_a9dfb5284eadd79fffef97ba1bd69f3c4}{PciDevice}を再定義しています。


\begin{DoxyCode}
169 {
170     int offset = pkt->getAddr() & PCI_CONFIG_SIZE;
171     if (offset < PCI_DEVICE_SPECIFIC) {
172         return PciDevice::readConfig(pkt);
173     }
174 
175     pkt->allocate();
176 
177     switch (pkt->getSize()) {
178       case sizeof(uint8_t):
179         switch (offset) {
180           case DeviceTiming:
181             pkt->set<uint8_t>(deviceTiming);
182             break;
183           case UDMAControl:
184             pkt->set<uint8_t>(udmaControl);
185             break;
186           case PrimaryTiming + 1:
187             pkt->set<uint8_t>(bits(htole(primaryTiming), 15, 8));
188             break;
189           case SecondaryTiming + 1:
190             pkt->set<uint8_t>(bits(htole(secondaryTiming), 15, 8));
191             break;
192           case IDEConfig:
193             pkt->set<uint8_t>(bits(htole(ideConfig), 7, 0));
194             break;
195           case IDEConfig + 1:
196             pkt->set<uint8_t>(bits(htole(ideConfig), 15, 8));
197             break;
198           default:
199             panic("Invalid PCI configuration read for size 1 at offset: %#x!\n",
200                     offset);
201         }
202         DPRINTF(IdeCtrl, "PCI read offset: %#x size: 1 data: %#x\n", offset,
203                 (uint32_t)pkt->get<uint8_t>());
204         break;
205       case sizeof(uint16_t):
206         switch (offset) {
207           case PrimaryTiming:
208             pkt->set<uint16_t>(primaryTiming);
209             break;
210           case SecondaryTiming:
211             pkt->set<uint16_t>(secondaryTiming);
212             break;
213           case UDMATiming:
214             pkt->set<uint16_t>(udmaTiming);
215             break;
216           case IDEConfig:
217             pkt->set<uint16_t>(ideConfig);
218             break;
219           default:
220             panic("Invalid PCI configuration read for size 2 offset: %#x!\n",
221                     offset);
222         }
223         DPRINTF(IdeCtrl, "PCI read offset: %#x size: 2 data: %#x\n", offset,
224                 (uint32_t)pkt->get<uint16_t>());
225         break;
226       case sizeof(uint32_t):
227         if (offset == IDEConfig)
228             pkt->set<uint32_t>(ideConfig);
229         else
230             panic("No 32bit reads implemented for this device.");
231         DPRINTF(IdeCtrl, "PCI read offset: %#x size: 4 data: %#x\n", offset,
232                 (uint32_t)pkt->get<uint32_t>());
233         break;
234       default:
235         panic("invalid access size(?) for PCI configspace!\n");
236     }
237     pkt->makeAtomicResponse();
238     return configDelay;
239 }
\end{DoxyCode}
\hypertarget{classIdeController_a53e036786d17361be4c7320d39c99b84}{
\index{IdeController@{IdeController}!serialize@{serialize}}
\index{serialize@{serialize}!IdeController@{IdeController}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIdeController_a53e036786d17361be4c7320d39c99b84}
Serialize this object to the given output stream. 
\begin{DoxyParams}{引数}
\item[{\em os}]The stream to serialize to. \end{DoxyParams}


\hyperlink{classPciDevice_a53e036786d17361be4c7320d39c99b84}{PciDevice}を再定義しています。


\begin{DoxyCode}
544 {
545     // Serialize the PciDevice base class
546     PciDevice::serialize(os);
547 
548     // Serialize channels
549     primary.serialize("primary", os);
550     secondary.serialize("secondary", os);
551 
552     // Serialize config registers
553     SERIALIZE_SCALAR(primaryTiming);
554     SERIALIZE_SCALAR(secondaryTiming);
555     SERIALIZE_SCALAR(deviceTiming);
556     SERIALIZE_SCALAR(udmaControl);
557     SERIALIZE_SCALAR(udmaTiming);
558     SERIALIZE_SCALAR(ideConfig);
559 
560     // Serialize internal state
561     SERIALIZE_SCALAR(ioEnabled);
562     SERIALIZE_SCALAR(bmEnabled);
563     SERIALIZE_SCALAR(bmiAddr);
564     SERIALIZE_SCALAR(bmiSize);
565 }
\end{DoxyCode}
\hypertarget{classIdeController_ab3f8a4d9fa9f33c71d23a803142e9faa}{
\index{IdeController@{IdeController}!setDmaComplete@{setDmaComplete}}
\index{setDmaComplete@{setDmaComplete}!IdeController@{IdeController}}
\subsubsection[{setDmaComplete}]{\setlength{\rightskip}{0pt plus 5cm}void setDmaComplete ({\bf IdeDisk} $\ast$ {\em disk})}}
\label{classIdeController_ab3f8a4d9fa9f33c71d23a803142e9faa}



\begin{DoxyCode}
152 {
153     Channel *channel;
154     if (disk == primary.master || disk == primary.slave) {
155         channel = &primary;
156     } else if (disk == secondary.master || disk == secondary.slave) {
157         channel = &secondary;
158     } else {
159         panic("Unable to find disk based on pointer %#x\n", disk);
160     }
161 
162     channel->bmiRegs.command.startStop = 0;
163     channel->bmiRegs.status.active = 0;
164     channel->bmiRegs.status.intStatus = 1;
165 }
\end{DoxyCode}
\hypertarget{classIdeController_af22e5d6d660b97db37003ac61ac4ee49}{
\index{IdeController@{IdeController}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!IdeController@{IdeController}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIdeController_af22e5d6d660b97db37003ac61ac4ee49}
Reconstruct the state of this object from a checkpoint. 
\begin{DoxyParams}{引数}
\item[{\em \hyperlink{namespacecp}{cp}}]The checkpoint use. \item[{\em section}]The section name of this object \end{DoxyParams}


\hyperlink{classPciDevice_af22e5d6d660b97db37003ac61ac4ee49}{PciDevice}を再定義しています。


\begin{DoxyCode}
586 {
587     // Unserialize the PciDevice base class
588     PciDevice::unserialize(cp, section);
589 
590     // Unserialize channels
591     primary.unserialize("primary", cp, section);
592     secondary.unserialize("secondary", cp, section);
593 
594     // Unserialize config registers
595     UNSERIALIZE_SCALAR(primaryTiming);
596     UNSERIALIZE_SCALAR(secondaryTiming);
597     UNSERIALIZE_SCALAR(deviceTiming);
598     UNSERIALIZE_SCALAR(udmaControl);
599     UNSERIALIZE_SCALAR(udmaTiming);
600     UNSERIALIZE_SCALAR(ideConfig);
601 
602     // Unserialize internal state
603     UNSERIALIZE_SCALAR(ioEnabled);
604     UNSERIALIZE_SCALAR(bmEnabled);
605     UNSERIALIZE_SCALAR(bmiAddr);
606     UNSERIALIZE_SCALAR(bmiSize);
607 }
\end{DoxyCode}
\hypertarget{classIdeController_a4cefab464e72b5dd42c003a0a4341802}{
\index{IdeController@{IdeController}!write@{write}}
\index{write@{write}!IdeController@{IdeController}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} write ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIdeController_a4cefab464e72b5dd42c003a0a4341802}
Pure virtual function that the device must implement. Called when a write command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_afe8371668d023bb2516b286e5e399b6f}{PioDevice}を実装しています。


\begin{DoxyCode}
537 {
538     dispatchAccess(pkt, false);
539     return pioDelay;
540 }
\end{DoxyCode}
\hypertarget{classIdeController_aac7b61a78530109bfa20923a53064bbf}{
\index{IdeController@{IdeController}!writeConfig@{writeConfig}}
\index{writeConfig@{writeConfig}!IdeController@{IdeController}}
\subsubsection[{writeConfig}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} writeConfig ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIdeController_aac7b61a78530109bfa20923a53064bbf}
Write to the PCI config space data that is stored locally. This may be overridden by the device but at some point it will eventually call this for normal operations that it does not need to override. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]packet containing the write the offset into config space \end{DoxyParams}


\hyperlink{classPciDevice_aac7b61a78530109bfa20923a53064bbf}{PciDevice}を再定義しています。


\begin{DoxyCode}
244 {
245     int offset = pkt->getAddr() & PCI_CONFIG_SIZE;
246     if (offset < PCI_DEVICE_SPECIFIC) {
247         PciDevice::writeConfig(pkt);
248     } else {
249         switch (pkt->getSize()) {
250           case sizeof(uint8_t):
251             switch (offset) {
252               case DeviceTiming:
253                 deviceTiming = pkt->get<uint8_t>();
254                 break;
255               case UDMAControl:
256                 udmaControl = pkt->get<uint8_t>();
257                 break;
258               case IDEConfig:
259                 replaceBits(ideConfig, 7, 0, pkt->get<uint8_t>());
260                 break;
261               case IDEConfig + 1:
262                 replaceBits(ideConfig, 15, 8, pkt->get<uint8_t>());
263                 break;
264               default:
265                 panic("Invalid PCI configuration write "
266                         "for size 1 offset: %#x!\n", offset);
267             }
268             DPRINTF(IdeCtrl, "PCI write offset: %#x size: 1 data: %#x\n",
269                     offset, (uint32_t)pkt->get<uint8_t>());
270             break;
271           case sizeof(uint16_t):
272             switch (offset) {
273               case PrimaryTiming:
274                 primaryTiming = pkt->get<uint16_t>();
275                 break;
276               case SecondaryTiming:
277                 secondaryTiming = pkt->get<uint16_t>();
278                 break;
279               case UDMATiming:
280                 udmaTiming = pkt->get<uint16_t>();
281                 break;
282               case IDEConfig:
283                 ideConfig = pkt->get<uint16_t>();
284                 break;
285               default:
286                 panic("Invalid PCI configuration write "
287                         "for size 2 offset: %#x!\n",
288                         offset);
289             }
290             DPRINTF(IdeCtrl, "PCI write offset: %#x size: 2 data: %#x\n",
291                     offset, (uint32_t)pkt->get<uint16_t>());
292             break;
293           case sizeof(uint32_t):
294             if (offset == IDEConfig)
295                 ideConfig = pkt->get<uint32_t>();
296             else
297                 panic("Write of unimplemented PCI config. register: %x\n", offset
      );
298             break;
299           default:
300             panic("invalid access size(?) for PCI configspace!\n");
301         }
302         pkt->makeAtomicResponse();
303     }
304 
305     /* Trap command register writes and enable IO/BM as appropriate as well as
306      * BARs. */
307     switch(offset) {
308       case PCI0_BASE_ADDR0:
309         if (BARAddrs[0] != 0)
310             primary.cmdAddr = BARAddrs[0];
311         break;
312 
313       case PCI0_BASE_ADDR1:
314         if (BARAddrs[1] != 0)
315             primary.ctrlAddr = BARAddrs[1];
316         break;
317 
318       case PCI0_BASE_ADDR2:
319         if (BARAddrs[2] != 0)
320             secondary.cmdAddr = BARAddrs[2];
321         break;
322 
323       case PCI0_BASE_ADDR3:
324         if (BARAddrs[3] != 0)
325             secondary.ctrlAddr = BARAddrs[3];
326         break;
327 
328       case PCI0_BASE_ADDR4:
329         if (BARAddrs[4] != 0)
330             bmiAddr = BARAddrs[4];
331         break;
332 
333       case PCI_COMMAND:
334         DPRINTF(IdeCtrl, "Writing to PCI Command val: %#x\n", config.command);
335         ioEnabled = (config.command & htole(PCI_CMD_IOSE));
336         bmEnabled = (config.command & htole(PCI_CMD_BME));
337         break;
338     }
339     return configDelay;
340 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classIdeController_a12698e64814a9728d71424fcf5148f4d}{
\index{IdeController@{IdeController}!active@{active}}
\index{active@{active}!IdeController@{IdeController}}
\subsubsection[{active}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$0$>$ {\bf active}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_a12698e64814a9728d71424fcf5148f4d}
\hypertarget{classIdeController_a9e6c0c0f31990b6cde50661d497ab70f}{
\index{IdeController@{IdeController}!bmEnabled@{bmEnabled}}
\index{bmEnabled@{bmEnabled}!IdeController@{IdeController}}
\subsubsection[{bmEnabled}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf bmEnabled}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_a9e6c0c0f31990b6cde50661d497ab70f}
\hypertarget{classIdeController_aeea2cd1022ed55ebf9ba284ea44b1b3b}{
\index{IdeController@{IdeController}!bmiAddr@{bmiAddr}}
\index{bmiAddr@{bmiAddr}!IdeController@{IdeController}}
\subsubsection[{bmiAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf bmiAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_aeea2cd1022ed55ebf9ba284ea44b1b3b}
\hyperlink{namespaceBus}{Bus} master interface (BMI) registers \hypertarget{classIdeController_a52be8db14c9c7207569db87b8a153c08}{
\index{IdeController@{IdeController}!bmiSize@{bmiSize}}
\index{bmiSize@{bmiSize}!IdeController@{IdeController}}
\subsubsection[{bmiSize}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf bmiSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_a52be8db14c9c7207569db87b8a153c08}
\hypertarget{classIdeController_a6f85d0e8ddf9ba7c01968f1b37725067}{
\index{IdeController@{IdeController}!ctrlOffset@{ctrlOffset}}
\index{ctrlOffset@{ctrlOffset}!IdeController@{IdeController}}
\subsubsection[{ctrlOffset}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf ctrlOffset}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_a6f85d0e8ddf9ba7c01968f1b37725067}
\hypertarget{classIdeController_a11159e29742cfa070446c2ae522aadb2}{
\index{IdeController@{IdeController}!deviceTiming@{deviceTiming}}
\index{deviceTiming@{deviceTiming}!IdeController@{IdeController}}
\subsubsection[{deviceTiming}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf deviceTiming}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_a11159e29742cfa070446c2ae522aadb2}
\hypertarget{classIdeController_aba4f51816e2ec54f12f4c9724d3b281f}{
\index{IdeController@{IdeController}!dmaCap1@{dmaCap1}}
\index{dmaCap1@{dmaCap1}!IdeController@{IdeController}}
\subsubsection[{dmaCap1}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$5$>$ {\bf dmaCap1}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_aba4f51816e2ec54f12f4c9724d3b281f}
\hypertarget{classIdeController_a3f71da290d4bdbfb6f14d5055a556d20}{
\index{IdeController@{IdeController}!dmaError@{dmaError}}
\index{dmaError@{dmaError}!IdeController@{IdeController}}
\subsubsection[{dmaError}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$1$>$ {\bf dmaError}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_a3f71da290d4bdbfb6f14d5055a556d20}
\hypertarget{classIdeController_accc39274caa412bf5447d8fad2822dda}{
\index{IdeController@{IdeController}!ideConfig@{ideConfig}}
\index{ideConfig@{ideConfig}!IdeController@{IdeController}}
\subsubsection[{ideConfig}]{\setlength{\rightskip}{0pt plus 5cm}uint16\_\-t {\bf ideConfig}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_accc39274caa412bf5447d8fad2822dda}
\hypertarget{classIdeController_a6bf8072c32ffee0d4d03eb90ce4a3810}{
\index{IdeController@{IdeController}!intStatus@{intStatus}}
\index{intStatus@{intStatus}!IdeController@{IdeController}}
\subsubsection[{intStatus}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$2$>$ {\bf intStatus}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_a6bf8072c32ffee0d4d03eb90ce4a3810}
\hypertarget{classIdeController_ab91aa36ae35d81d85815bd14a704c736}{
\index{IdeController@{IdeController}!ioEnabled@{ioEnabled}}
\index{ioEnabled@{ioEnabled}!IdeController@{IdeController}}
\subsubsection[{ioEnabled}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf ioEnabled}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_ab91aa36ae35d81d85815bd14a704c736}
\hypertarget{classIdeController_a717c1373270d47ce8b3da7a0bf9ba29e}{
\index{IdeController@{IdeController}!ioShift@{ioShift}}
\index{ioShift@{ioShift}!IdeController@{IdeController}}
\subsubsection[{ioShift}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf ioShift}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_a717c1373270d47ce8b3da7a0bf9ba29e}
\hypertarget{classIdeController_ab99c7b03cc88be094081c9dee0d4f3d7}{
\index{IdeController@{IdeController}!primary@{primary}}
\index{primary@{primary}!IdeController@{IdeController}}
\subsubsection[{primary}]{\setlength{\rightskip}{0pt plus 5cm}Channel {\bf primary}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_ab99c7b03cc88be094081c9dee0d4f3d7}
\hypertarget{classIdeController_ae3a3e441e5eccb9c386260eeb3968878}{
\index{IdeController@{IdeController}!primaryTiming@{primaryTiming}}
\index{primaryTiming@{primaryTiming}!IdeController@{IdeController}}
\subsubsection[{primaryTiming}]{\setlength{\rightskip}{0pt plus 5cm}uint16\_\-t {\bf primaryTiming}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_ae3a3e441e5eccb9c386260eeb3968878}
Registers used in device specific PCI configuration \hypertarget{classIdeController_a9ffe401d4b082d4a20f74809ed096f62}{
\index{IdeController@{IdeController}!secondary@{secondary}}
\index{secondary@{secondary}!IdeController@{IdeController}}
\subsubsection[{secondary}]{\setlength{\rightskip}{0pt plus 5cm}Channel {\bf secondary}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_a9ffe401d4b082d4a20f74809ed096f62}
\hypertarget{classIdeController_a1611c0c216198aa88de03e3ebfd22b43}{
\index{IdeController@{IdeController}!secondaryTiming@{secondaryTiming}}
\index{secondaryTiming@{secondaryTiming}!IdeController@{IdeController}}
\subsubsection[{secondaryTiming}]{\setlength{\rightskip}{0pt plus 5cm}uint16\_\-t {\bf secondaryTiming}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_a1611c0c216198aa88de03e3ebfd22b43}
\hypertarget{classIdeController_ace5af3160a3a76b4a51e864f74b16ae5}{
\index{IdeController@{IdeController}!startStop@{startStop}}
\index{startStop@{startStop}!IdeController@{IdeController}}
\subsubsection[{startStop}]{\setlength{\rightskip}{0pt plus 5cm}Bitfield$<$0$>$ {\bf startStop}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_ace5af3160a3a76b4a51e864f74b16ae5}
\hypertarget{classIdeController_a3bc817e4be51f2e1aeb1701ce144cbf1}{
\index{IdeController@{IdeController}!udmaControl@{udmaControl}}
\index{udmaControl@{udmaControl}!IdeController@{IdeController}}
\subsubsection[{udmaControl}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf udmaControl}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_a3bc817e4be51f2e1aeb1701ce144cbf1}
\hypertarget{classIdeController_af5a85382debfe463bfebc5ab59624aa5}{
\index{IdeController@{IdeController}!udmaTiming@{udmaTiming}}
\index{udmaTiming@{udmaTiming}!IdeController@{IdeController}}
\subsubsection[{udmaTiming}]{\setlength{\rightskip}{0pt plus 5cm}uint16\_\-t {\bf udmaTiming}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIdeController_af5a85382debfe463bfebc5ab59624aa5}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/\hyperlink{ide__ctrl_8hh}{ide\_\-ctrl.hh}\item 
dev/\hyperlink{ide__ctrl_8cc}{ide\_\-ctrl.cc}\end{DoxyCompactItemize}
