\hypertarget{classQueuedSlavePort}{
\section{クラス QueuedSlavePort}
\label{classQueuedSlavePort}\index{QueuedSlavePort@{QueuedSlavePort}}
}


{\ttfamily \#include $<$qport.hh$>$}QueuedSlavePortに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=5.18519cm]{classQueuedSlavePort}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classQueuedSlavePort_a150e71ad6ae4ad6eb65adc52ca8ff294}{QueuedSlavePort} (const std::string \&name, \hyperlink{classMemObject}{MemObject} $\ast$\hyperlink{classPort_aba966efb6c1df4b015be3a396df6c318}{owner}, \hyperlink{classSlavePacketQueue}{SlavePacketQueue} \&\hyperlink{classQueuedSlavePort_a89fcdbe2ab63d24f2112bc7e05bf2413}{queue}, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} \hyperlink{classPort_a0a67444fc1c33a60fe4a92bfff05d0cb}{id}=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
virtual \hyperlink{classQueuedSlavePort_a15b90c8a70a02ac8423cf5cd5b24bbb4}{$\sim$QueuedSlavePort} ()
\item 
void \hyperlink{classQueuedSlavePort_a31c2fe79e7cbd7319eb327074e412675}{schedTimingResp} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} when)
\item 
bool \hyperlink{classQueuedSlavePort_a8eb60d4744b6212ad749f3a586759266}{checkFunctional} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
unsigned int \hyperlink{classQueuedSlavePort_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classQueuedSlavePort_a7ec461ad187b82b4b21e27c86e45cf9c}{recvRetry} ()
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSlavePacketQueue}{SlavePacketQueue} \& \hyperlink{classQueuedSlavePort_a89fcdbe2ab63d24f2112bc7e05bf2413}{queue}
\end{DoxyCompactItemize}


\subsection{説明}
A queued port is a port that has an infinite queue for outgoing packets and thus decouples the module that wants to send request/responses from the flow control (retry mechanism) of the port. A queued port can be used by both a master and a slave. The queue is a parameter to allow tailoring of the queue implementation (used in the cache). 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classQueuedSlavePort_a150e71ad6ae4ad6eb65adc52ca8ff294}{
\index{QueuedSlavePort@{QueuedSlavePort}!QueuedSlavePort@{QueuedSlavePort}}
\index{QueuedSlavePort@{QueuedSlavePort}!QueuedSlavePort@{QueuedSlavePort}}
\subsubsection[{QueuedSlavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf QueuedSlavePort} (const std::string \& {\em name}, \/  {\bf MemObject} $\ast$ {\em owner}, \/  {\bf SlavePacketQueue} \& {\em queue}, \/  {\bf PortID} {\em id} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classQueuedSlavePort_a150e71ad6ae4ad6eb65adc52ca8ff294}
Create a QueuedPort with a given name, owner, and a supplied implementation of a packet queue. The external definition of the queue enables e.g. the cache to implement a specific queue behaviuor in a subclass, and provide the latter to the QueuePort constructor. 


\begin{DoxyCode}
81                                                                         :
82         SlavePort(name, owner, id), queue(queue)
83     { }

\end{DoxyCode}
\hypertarget{classQueuedSlavePort_a15b90c8a70a02ac8423cf5cd5b24bbb4}{
\index{QueuedSlavePort@{QueuedSlavePort}!$\sim$QueuedSlavePort@{$\sim$QueuedSlavePort}}
\index{$\sim$QueuedSlavePort@{$\sim$QueuedSlavePort}!QueuedSlavePort@{QueuedSlavePort}}
\subsubsection[{$\sim$QueuedSlavePort}]{\setlength{\rightskip}{0pt plus 5cm}virtual $\sim${\bf QueuedSlavePort} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classQueuedSlavePort_a15b90c8a70a02ac8423cf5cd5b24bbb4}



\begin{DoxyCode}
85 { }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classQueuedSlavePort_a8eb60d4744b6212ad749f3a586759266}{
\index{QueuedSlavePort@{QueuedSlavePort}!checkFunctional@{checkFunctional}}
\index{checkFunctional@{checkFunctional}!QueuedSlavePort@{QueuedSlavePort}}
\subsubsection[{checkFunctional}]{\setlength{\rightskip}{0pt plus 5cm}bool checkFunctional ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classQueuedSlavePort_a8eb60d4744b6212ad749f3a586759266}
\hyperlink{classCheck}{Check} the list of buffered packets against the supplied functional request. 


\begin{DoxyCode}
98 { return queue.checkFunctional(pkt); }
\end{DoxyCode}
\hypertarget{classQueuedSlavePort_aa8a18d230dba7a674ac8a0b4f35bc36a}{
\index{QueuedSlavePort@{QueuedSlavePort}!drain@{drain}}
\index{drain@{drain}!QueuedSlavePort@{QueuedSlavePort}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em dm})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classQueuedSlavePort_aa8a18d230dba7a674ac8a0b4f35bc36a}



\begin{DoxyCode}
100 { return queue.drain(dm); }
\end{DoxyCode}
\hypertarget{classQueuedSlavePort_a7ec461ad187b82b4b21e27c86e45cf9c}{
\index{QueuedSlavePort@{QueuedSlavePort}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!QueuedSlavePort@{QueuedSlavePort}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}virtual void recvRetry ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classQueuedSlavePort_a7ec461ad187b82b4b21e27c86e45cf9c}
This function is notification that the device should attempt to send a packet again. 

\hyperlink{classSlavePort_ac1ccc3bcf7ebabb20b57fab99b2be5b0}{SlavePort}を実装しています。


\begin{DoxyCode}
69 { queue.retry(); }
\end{DoxyCode}
\hypertarget{classQueuedSlavePort_a31c2fe79e7cbd7319eb327074e412675}{
\index{QueuedSlavePort@{QueuedSlavePort}!schedTimingResp@{schedTimingResp}}
\index{schedTimingResp@{schedTimingResp}!QueuedSlavePort@{QueuedSlavePort}}
\subsubsection[{schedTimingResp}]{\setlength{\rightskip}{0pt plus 5cm}void schedTimingResp ({\bf PacketPtr} {\em pkt}, \/  {\bf Tick} {\em when})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classQueuedSlavePort_a31c2fe79e7cbd7319eb327074e412675}
Schedule the sending of a timing response.


\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} to send \item[{\em when}]Absolute time (in ticks) to send packet \end{DoxyParams}



\begin{DoxyCode}
94     { queue.schedSendTiming(pkt, when); }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classQueuedSlavePort_a89fcdbe2ab63d24f2112bc7e05bf2413}{
\index{QueuedSlavePort@{QueuedSlavePort}!queue@{queue}}
\index{queue@{queue}!QueuedSlavePort@{QueuedSlavePort}}
\subsubsection[{queue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SlavePacketQueue}\& {\bf queue}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classQueuedSlavePort_a89fcdbe2ab63d24f2112bc7e05bf2413}
\hyperlink{classPacket}{Packet} queue used to store outgoing requests and responses. 

\hyperlink{classBaseCache_1_1CacheSlavePort_a3055168363a9ed42f38173363b6c1975}{CacheSlavePort}, \hyperlink{classDRAMCtrl_1_1MemoryPort_a3055168363a9ed42f38173363b6c1975}{MemoryPort}, \hyperlink{classRubyPort_1_1MemSlavePort_a3055168363a9ed42f38173363b6c1975}{MemSlavePort}, と \hyperlink{classRubyPort_1_1PioSlavePort_a3055168363a9ed42f38173363b6c1975}{PioSlavePort}で再定義されています。

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{qport_8hh}{qport.hh}\end{DoxyCompactItemize}
