\hypertarget{classOzoneLWLSQ}{
\section{クラス テンプレート OzoneLWLSQ$<$ Impl $>$}
\label{classOzoneLWLSQ}\index{OzoneLWLSQ@{OzoneLWLSQ}}
}


{\ttfamily \#include $<$lw\_\-lsq.hh$>$}\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classOzoneLWLSQ_1_1DcachePort}{DcachePort}
\item 
struct \hyperlink{structOzoneLWLSQ_1_1HashFn}{HashFn}
\item 
class \hyperlink{classOzoneLWLSQ_1_1LSQSenderState}{LSQSenderState}
\item 
struct \hyperlink{structOzoneLWLSQ_1_1SQEntry}{SQEntry}
\item 
class \hyperlink{classOzoneLWLSQ_1_1WritebackEvent}{WritebackEvent}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classOzoneLWLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \{ \hyperlink{classOzoneLWLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}{Running}, 
\hyperlink{classOzoneLWLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}{Idle}, 
\hyperlink{classOzoneLWLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70ba4ba5ae5815b190bd652669e2fdea5ed7}{DcacheMissStall}, 
\hyperlink{classOzoneLWLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70bad01f64e5e67cc64e6ad4152f187a034d}{DcacheMissSwitch}
 \}
\item 
typedef Impl::Params \hyperlink{classOzoneLWLSQ_a818e103eae798a24a06a0a34631849ea}{Params}
\item 
typedef Impl::OzoneCPU \hyperlink{classOzoneLWLSQ_a9730cc41bccb218cae8f32869b8d887e}{OzoneCPU}
\item 
typedef Impl::BackEnd \hyperlink{classOzoneLWLSQ_a3de526baa0cbb2b55bf669a6f7bf81cc}{BackEnd}
\item 
typedef Impl::DynInstPtr \hyperlink{classOzoneLWLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}
\item 
typedef Impl::IssueStruct \hyperlink{classOzoneLWLSQ_a568c86f6403070f1cb743e994405ba8b}{IssueStruct}
\item 
typedef TheISA::IntReg \hyperlink{classOzoneLWLSQ_a1355cb78d031430d4d70eb5080267604}{IntReg}
\item 
typedef std::map$<$ \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum}, \hyperlink{classOzoneLWLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$::iterator \hyperlink{classOzoneLWLSQ_a8b43ca5318a59872c61492868e50bab6}{LdMapIt}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classOzoneLWLSQ_aa933366a7f11b182f805d690c533776a}{OzoneLWLSQ} ()
\item 
void \hyperlink{classOzoneLWLSQ_ae8565b0968a8115705f1585e8aa21f75}{init} (\hyperlink{classOzoneLWLSQ_a818e103eae798a24a06a0a34631849ea}{Params} $\ast$params, unsigned maxLQEntries, unsigned maxSQEntries, unsigned id)
\item 
std::string \hyperlink{classOzoneLWLSQ_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classOzoneLWLSQ_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classOzoneLWLSQ_ab8056057b67b41f234f56940cc115cc1}{setCPU} (\hyperlink{classOzoneCPU}{OzoneCPU} $\ast$cpu\_\-ptr)
\item 
void \hyperlink{classOzoneLWLSQ_a9134276ed85820d74779ad5826580822}{setBE} (\hyperlink{classBackEnd}{BackEnd} $\ast$be\_\-ptr)
\item 
\hyperlink{classPort}{Port} $\ast$ \hyperlink{classOzoneLWLSQ_a32e64f82b805fe23a17b01dda0f44fb0}{getDcachePort} ()
\item 
void \hyperlink{classOzoneLWLSQ_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\item 
void \hyperlink{classOzoneLWLSQ_a773e88db1aa010c3755e603493bf40ec}{insert} (\hyperlink{classOzoneLWLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classOzoneLWLSQ_ad22b3ecafed2bcd9c59fcab049a1cb98}{insertLoad} (\hyperlink{classOzoneLWLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&load\_\-inst)
\item 
void \hyperlink{classOzoneLWLSQ_a6a4b4e51bfff3639932ebaba45e8a282}{insertStore} (\hyperlink{classOzoneLWLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&store\_\-inst)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classOzoneLWLSQ_a30c6332142c2ecca389ed6ee463c692b}{executeLoad} (\hyperlink{classOzoneLWLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classOzoneLWLSQ_aad78b8a37ee5c61e47df58dd39980340}{executeStore} (\hyperlink{classOzoneLWLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classOzoneLWLSQ_a8ddd26e169a62ec5ae591a9f95934839}{commitLoad} ()
\item 
void \hyperlink{classOzoneLWLSQ_a1ae517a923a864a4e3a5aa1eeb2dd2d6}{commitLoads} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&youngest\_\-inst)
\item 
void \hyperlink{classOzoneLWLSQ_a954ce1ce58b67cae49ba127d5ea40701}{commitStores} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&youngest\_\-inst)
\item 
void \hyperlink{classOzoneLWLSQ_a5f04e29d6f6feb8b86460491f2ba7547}{writebackStores} ()
\item 
void \hyperlink{classOzoneLWLSQ_a0f7f0d3412bbf494cd3d0c0f48e5fcf2}{completeDataAccess} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classOzoneLWLSQ_ae3af532345dbe6519e8272d9cd677230}{clearLQ} ()
\item 
void \hyperlink{classOzoneLWLSQ_a171cd7891063f418b1ee217f5c03537b}{clearSQ} ()
\item 
void \hyperlink{classOzoneLWLSQ_a3bc9500810cb2d5615e29206e2d6499f}{resizeLQ} (unsigned size)
\item 
void \hyperlink{classOzoneLWLSQ_a341dd6a3bd8d240659fd9d698c3b5c65}{resizeSQ} (unsigned size)
\item 
void \hyperlink{classOzoneLWLSQ_a51dd7e304d5413447717826fac6f4921}{squash} (const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&squashed\_\-num)
\item 
bool \hyperlink{classOzoneLWLSQ_a4f720bbfb5fdefdb23516500eeb0b4de}{violation} ()
\item 
\hyperlink{classOzoneLWLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classOzoneLWLSQ_a30adaf6f5fb6b38b5747f35c419e3f31}{getMemDepViolator} ()
\item 
bool \hyperlink{classOzoneLWLSQ_a05c413ba417c6453e99f75d87c958590}{loadBlocked} ()
\item 
void \hyperlink{classOzoneLWLSQ_aaa9628e569d007b553e6830774b8548c}{clearLoadBlocked} ()
\item 
bool \hyperlink{classOzoneLWLSQ_ad0aa91a7b51ca925abf9c9992abad314}{isLoadBlockedHandled} ()
\item 
void \hyperlink{classOzoneLWLSQ_ac8bfb1e163f7ba2261d702623226973d}{setLoadBlockedHandled} ()
\item 
unsigned \hyperlink{classOzoneLWLSQ_a028971a565aca048c67ea1c36a6a9d51}{numFreeEntries} ()
\item 
int \hyperlink{classOzoneLWLSQ_a9aa5d5a61b2229931008ac2ea802a3ab}{numLoadsReady} ()
\item 
int \hyperlink{classOzoneLWLSQ_a54460b759fb06e2b18e26657279a6f49}{numLoads} ()
\item 
int \hyperlink{classOzoneLWLSQ_aa0fc32a4a9d77696f5907f4d25e7d07f}{numStores} ()
\item 
bool \hyperlink{classOzoneLWLSQ_a3e70330939fdfc4dbc2f60c1a660584d}{isFull} ()
\item 
bool \hyperlink{classOzoneLWLSQ_a5893daf623130be826f492bbff58f757}{lqFull} ()
\item 
bool \hyperlink{classOzoneLWLSQ_a477981d1f905d2d398a1527f7149e3c4}{sqFull} ()
\item 
void \hyperlink{classOzoneLWLSQ_a80587b4fe043bbe1995536cb3b361588}{dumpInsts} ()
\item 
unsigned \hyperlink{classOzoneLWLSQ_a24ba9cb3fa1e726321780a20a960c8cd}{getCount} ()
\item 
bool \hyperlink{classOzoneLWLSQ_ad2e4b46255cfb53e85522adeed4e2089}{hasStoresToWB} ()
\item 
int \hyperlink{classOzoneLWLSQ_a276cdbdaf4551f1b846c4e2535c5f882}{numStoresToWB} ()
\item 
bool \hyperlink{classOzoneLWLSQ_a338be821734603396bfef8d9fb8f04b0}{willWB} ()
\item 
void \hyperlink{classOzoneLWLSQ_a05f299b443f8cc73a93d61572edc0218}{switchOut} ()
\item 
void \hyperlink{classOzoneLWLSQ_a5a901e7ec5b94a55bd61fde88ad0b7f1}{takeOverFrom} (\hyperlink{classThreadContext}{ThreadContext} $\ast$old\_\-tc=NULL)
\item 
bool \hyperlink{classOzoneLWLSQ_a471165257f311a78136ce991a3bad31a}{isSwitchedOut} ()
\item 
{\footnotesize template$<$class T $>$ }\\\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classOzoneLWLSQ_a0747777ac998dabdc20fa0c554d378d3}{read} (\hyperlink{classRequest}{RequestPtr} req, T \&data, int load\_\-idx)
\item 
{\footnotesize template$<$class T $>$ }\\\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classOzoneLWLSQ_abbf7bcc93511421a1787650a43e2642a}{write} (\hyperlink{classRequest}{RequestPtr} req, T \&data, int store\_\-idx)
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classOzoneLWLSQ_aee7352adadc6b43b7ce36a8c052eb222}{getLoadHeadSeqNum} ()
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classOzoneLWLSQ_a1813b58ab7569d6aeefb5d4e235cceda}{getStoreHeadSeqNum} ()
\item 
bool \hyperlink{classOzoneLWLSQ_af8eb8590fbfa6ecd2f796390677a4c00}{isStalled} ()
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classOzoneLWLSQ_a1aee6db9bfb75cf02e38a82e5d02847f}{switchedOut}
\item 
int \hyperlink{classOzoneLWLSQ_a04638dcfe9b4f8584453bb178bd2da5e}{storesInFlight}
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{structOzoneLWLSQ_1_1SQEntry}{SQEntry} $>$::iterator \hyperlink{classOzoneLWLSQ_a3b2dd16f487adc977c43201cd7f51558}{SQIt}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classOzoneLWLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$::iterator \hyperlink{classOzoneLWLSQ_a363c8c15e054d23b34f72063429933b8}{LQIt}
\item 
typedef m5::hash\_\-map$<$ int, \hyperlink{classOzoneLWLSQ_a363c8c15e054d23b34f72063429933b8}{LQIt}, \hyperlink{structOzoneLWLSQ_1_1HashFn}{HashFn} $>$::iterator \hyperlink{classOzoneLWLSQ_ac0ca3d8ca19168e251c7233ec1f9a171}{LQHashIt}
\item 
typedef m5::hash\_\-map$<$ int, \hyperlink{classOzoneLWLSQ_a3b2dd16f487adc977c43201cd7f51558}{SQIt}, \hyperlink{structOzoneLWLSQ_1_1HashFn}{HashFn} $>$::iterator \hyperlink{classOzoneLWLSQ_af476de7b08376a4d7d7cd4b8dbbabb7a}{SQHashIt}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classOzoneLWLSQ_a3911bacb8817c31cfbeefd125dba0217}{writeback} (\hyperlink{classOzoneLWLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst, \hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classOzoneLWLSQ_af841afeea43eb2b2272f0dfaf17c3f4e}{storePostSend} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{classOzoneLWLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classOzoneLWLSQ_a14bf528b217d02373076ed257f448dbf}{completeStore} (\hyperlink{classOzoneLWLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classOzoneLWLSQ_ad5ff9e08c63a01ac86a8f80765b37365}{removeStore} (int store\_\-idx)
\item 
void \hyperlink{classOzoneLWLSQ_a29cb5a4f98063ce6e9210eacbdb35298}{recvRetry} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classOzoneCPU}{OzoneCPU} $\ast$ \hyperlink{classOzoneLWLSQ_a61b5f503eec141308b0cd6b4322b405b}{cpu}
\item 
\hyperlink{classBackEnd}{BackEnd} $\ast$ \hyperlink{classOzoneLWLSQ_a84f815aa1fa864ba2e6d75f5ad2b52d1}{be}
\item 
\hyperlink{classOzoneLWLSQ_1_1DcachePort}{DcachePort} \hyperlink{classOzoneLWLSQ_a38b03978ad7720fdc910ff6a8b44585f}{dcachePort}
\item 
unsigned \hyperlink{classOzoneLWLSQ_adfd96fbbaa327a31d20f0d4134418fad}{lsqID}
\item 
\hyperlink{classOzoneLWLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \hyperlink{classOzoneLWLSQ_a6cdf6e6db875a442f3ab6db542bd2bb5}{\_\-status}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{structOzoneLWLSQ_1_1SQEntry}{SQEntry} $>$ \hyperlink{classOzoneLWLSQ_aadda2adf789b0c8a3eb952ac5d65d4ed}{storeQueue}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classOzoneLWLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classOzoneLWLSQ_a6800290ffd43f3207c629be7f2d6228f}{loadQueue}
\item 
m5::hash\_\-map$<$ int, \hyperlink{classOzoneLWLSQ_a3b2dd16f487adc977c43201cd7f51558}{SQIt}, \hyperlink{structOzoneLWLSQ_1_1HashFn}{HashFn} $>$ \hyperlink{classOzoneLWLSQ_a3eb9bc9d55fde5b98e8d28a220d247f6}{SQItHash}
\item 
std::queue$<$ int $>$ \hyperlink{classOzoneLWLSQ_a94838aca72c880423d2328ae17f065e6}{SQIndices}
\item 
m5::hash\_\-map$<$ int, \hyperlink{classOzoneLWLSQ_a363c8c15e054d23b34f72063429933b8}{LQIt}, \hyperlink{structOzoneLWLSQ_1_1HashFn}{HashFn} $>$ \hyperlink{classOzoneLWLSQ_afd55cfcf685cda7dafc7c52d5105e129}{LQItHash}
\item 
std::queue$<$ int $>$ \hyperlink{classOzoneLWLSQ_a78218da891879fae16fe75c73981f75f}{LQIndices}
\item 
unsigned \hyperlink{classOzoneLWLSQ_aafa99d800d574095881acbacdbbbcc47}{LQEntries}
\item 
unsigned \hyperlink{classOzoneLWLSQ_a38c8af5392da70119dc5cce4e3637cbc}{SQEntries}
\item 
int \hyperlink{classOzoneLWLSQ_a867971f18e464abd16193e069c64a8ad}{loads}
\item 
int \hyperlink{classOzoneLWLSQ_ade9e895aa9c5ace27779c985c4f43326}{stores}
\item 
int \hyperlink{classOzoneLWLSQ_a3831a7965ffbe90df177026988476f9c}{storesToWB}
\item 
int \hyperlink{classOzoneLWLSQ_ab2e23636971c40e7ed945026b2a184e1}{cachePorts}
\item 
int \hyperlink{classOzoneLWLSQ_a03435d626b7567ed154de5d7d8c3d419}{usedPorts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classOzoneLWLSQ_ac499fc2b461e03a110deae7c695f75bc}{lsqMemOrderViolation}
\item 
\hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classOzoneLWLSQ_a8b4696062ef09ab956804a7a99491853}{lastDcacheStall}
\item 
bool \hyperlink{classOzoneLWLSQ_a6f8bff553ad30865c7d0c62e05421eb8}{stalled}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classOzoneLWLSQ_afe1cdcfca6b44c28581d862228adc3da}{stallingStoreIsn}
\item 
\hyperlink{classOzoneLWLSQ_a363c8c15e054d23b34f72063429933b8}{LQIt} \hyperlink{classOzoneLWLSQ_a567a64b358df6ae6162124cfe4d00db3}{stallingLoad}
\item 
\hyperlink{classPacket}{PacketPtr} \hyperlink{classOzoneLWLSQ_a314ae93c04b3ca96e79e1b1f39a8e478}{retryPkt}
\item 
bool \hyperlink{classOzoneLWLSQ_a89d931c74b63e0b0e7ad856fe9525ff6}{isStoreBlocked}
\item 
bool \hyperlink{classOzoneLWLSQ_a95dc31b4ce3ebcb6b9d75a510b3a128c}{isLoadBlocked}
\item 
bool \hyperlink{classOzoneLWLSQ_a2c1620029c162c7180e523b089e56ed5}{loadBlockedHandled}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classOzoneLWLSQ_a3fca34b247fd8d081557578f8ca60fe3}{blockedLoadSeqNum}
\item 
\hyperlink{classOzoneLWLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classOzoneLWLSQ_a7123aa8b10829cc4712dff5454e13978}{loadFaultInst}
\item 
\hyperlink{classOzoneLWLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classOzoneLWLSQ_ab98cf7d5235b7402e8916e78569f4ab2}{storeFaultInst}
\item 
\hyperlink{classOzoneLWLSQ_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classOzoneLWLSQ_a270a20c3fa52139e0538288275db9d22}{memDepViolator}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$class Impl$>$ class OzoneLWLSQ$<$ Impl $>$}

Class that implements the actual LQ and SQ for each specific thread. Both are circular queues; load entries are freed upon committing, while store entries are freed once they writeback. The \hyperlink{classLSQUnit}{LSQUnit} tracks if there are memory ordering violations, and also detects partial load to store forwarding cases (a store only has part of a load's data) that requires the load to wait until the store writes back. In the former case it holds onto the instruction until the dependence unit looks at it, and in the latter it stalls the \hyperlink{classLSQ}{LSQ} until the store writes back. At that point the load is replayed. 

\subsection{型定義}
\hypertarget{classOzoneLWLSQ_a3de526baa0cbb2b55bf669a6f7bf81cc}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!BackEnd@{BackEnd}}
\index{BackEnd@{BackEnd}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{BackEnd}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::BackEnd {\bf BackEnd}}}
\label{classOzoneLWLSQ_a3de526baa0cbb2b55bf669a6f7bf81cc}
\hypertarget{classOzoneLWLSQ_a028ce10889c5f6450239d9e9a7347976}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInstPtr {\bf DynInstPtr}}}
\label{classOzoneLWLSQ_a028ce10889c5f6450239d9e9a7347976}
\hypertarget{classOzoneLWLSQ_a1355cb78d031430d4d70eb5080267604}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!IntReg@{IntReg}}
\index{IntReg@{IntReg}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{IntReg}]{\setlength{\rightskip}{0pt plus 5cm}typedef TheISA::IntReg {\bf IntReg}}}
\label{classOzoneLWLSQ_a1355cb78d031430d4d70eb5080267604}
\hypertarget{classOzoneLWLSQ_a568c86f6403070f1cb743e994405ba8b}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!IssueStruct@{IssueStruct}}
\index{IssueStruct@{IssueStruct}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{IssueStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::IssueStruct {\bf IssueStruct}}}
\label{classOzoneLWLSQ_a568c86f6403070f1cb743e994405ba8b}
\hypertarget{classOzoneLWLSQ_a8b43ca5318a59872c61492868e50bab6}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!LdMapIt@{LdMapIt}}
\index{LdMapIt@{LdMapIt}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{LdMapIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef std::map$<${\bf InstSeqNum}, {\bf DynInstPtr}$>$::iterator {\bf LdMapIt}}}
\label{classOzoneLWLSQ_a8b43ca5318a59872c61492868e50bab6}
\hypertarget{classOzoneLWLSQ_ac0ca3d8ca19168e251c7233ec1f9a171}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!LQHashIt@{LQHashIt}}
\index{LQHashIt@{LQHashIt}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{LQHashIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef m5::hash\_\-map$<$int, {\bf LQIt}, {\bf HashFn}$>$::iterator {\bf LQHashIt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_ac0ca3d8ca19168e251c7233ec1f9a171}
\hypertarget{classOzoneLWLSQ_a363c8c15e054d23b34f72063429933b8}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!LQIt@{LQIt}}
\index{LQIt@{LQIt}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{LQIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf DynInstPtr}$>$::iterator {\bf LQIt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a363c8c15e054d23b34f72063429933b8}
\hypertarget{classOzoneLWLSQ_a9730cc41bccb218cae8f32869b8d887e}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!OzoneCPU@{OzoneCPU}}
\index{OzoneCPU@{OzoneCPU}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{OzoneCPU}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::OzoneCPU {\bf OzoneCPU}}}
\label{classOzoneLWLSQ_a9730cc41bccb218cae8f32869b8d887e}
\hypertarget{classOzoneLWLSQ_a818e103eae798a24a06a0a34631849ea}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!Params@{Params}}
\index{Params@{Params}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::Params {\bf Params}}}
\label{classOzoneLWLSQ_a818e103eae798a24a06a0a34631849ea}
\hypertarget{classOzoneLWLSQ_af476de7b08376a4d7d7cd4b8dbbabb7a}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!SQHashIt@{SQHashIt}}
\index{SQHashIt@{SQHashIt}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{SQHashIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef m5::hash\_\-map$<$int, {\bf SQIt}, {\bf HashFn}$>$::iterator {\bf SQHashIt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_af476de7b08376a4d7d7cd4b8dbbabb7a}
\hypertarget{classOzoneLWLSQ_a3b2dd16f487adc977c43201cd7f51558}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!SQIt@{SQIt}}
\index{SQIt@{SQIt}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{SQIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf SQEntry}$>$::iterator {\bf SQIt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a3b2dd16f487adc977c43201cd7f51558}


\subsection{列挙型}
\hypertarget{classOzoneLWLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70b}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!Status@{Status}}
\index{Status@{Status}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{Status}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Status}}}
\label{classOzoneLWLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70b}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Running@{Running}!OzoneLWLSQ@{OzoneLWLSQ}}\index{OzoneLWLSQ@{OzoneLWLSQ}!Running@{Running}}\item[{\em 
\hypertarget{classOzoneLWLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}{
Running}
\label{classOzoneLWLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}
}]\index{Idle@{Idle}!OzoneLWLSQ@{OzoneLWLSQ}}\index{OzoneLWLSQ@{OzoneLWLSQ}!Idle@{Idle}}\item[{\em 
\hypertarget{classOzoneLWLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}{
Idle}
\label{classOzoneLWLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}
}]\index{DcacheMissStall@{DcacheMissStall}!OzoneLWLSQ@{OzoneLWLSQ}}\index{OzoneLWLSQ@{OzoneLWLSQ}!DcacheMissStall@{DcacheMissStall}}\item[{\em 
\hypertarget{classOzoneLWLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70ba4ba5ae5815b190bd652669e2fdea5ed7}{
DcacheMissStall}
\label{classOzoneLWLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70ba4ba5ae5815b190bd652669e2fdea5ed7}
}]\index{DcacheMissSwitch@{DcacheMissSwitch}!OzoneLWLSQ@{OzoneLWLSQ}}\index{OzoneLWLSQ@{OzoneLWLSQ}!DcacheMissSwitch@{DcacheMissSwitch}}\item[{\em 
\hypertarget{classOzoneLWLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70bad01f64e5e67cc64e6ad4152f187a034d}{
DcacheMissSwitch}
\label{classOzoneLWLSQ_a67a0db04d321a74b7e7fcfd3f1a3f70bad01f64e5e67cc64e6ad4152f187a034d}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
344                 {
345         Running,
346         Idle,
347         DcacheMissStall,
348         DcacheMissSwitch
349     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classOzoneLWLSQ_aa933366a7f11b182f805d690c533776a}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!OzoneLWLSQ@{OzoneLWLSQ}}
\index{OzoneLWLSQ@{OzoneLWLSQ}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{OzoneLWLSQ}]{\setlength{\rightskip}{0pt plus 5cm}{\bf OzoneLWLSQ} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_aa933366a7f11b182f805d690c533776a}
Constructs an \hyperlink{classLSQ}{LSQ} unit. \hyperlink{classOzoneLWLSQ_ae8565b0968a8115705f1585e8aa21f75}{init()} must be called prior to use. 


\begin{DoxyCode}
126     : switchedOut(false), dcachePort(this), loads(0), stores(0),
127       storesToWB(0), storesInFlight(0), stalled(false), isStoreBlocked(false),
128       isLoadBlocked(false), loadBlockedHandled(false)
129 {
130 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classOzoneLWLSQ_aaa9628e569d007b553e6830774b8548c}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!clearLoadBlocked@{clearLoadBlocked}}
\index{clearLoadBlocked@{clearLoadBlocked}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{clearLoadBlocked}]{\setlength{\rightskip}{0pt plus 5cm}void clearLoadBlocked ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_aaa9628e569d007b553e6830774b8548c}



\begin{DoxyCode}
166     { isLoadBlocked = false; }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_ae3af532345dbe6519e8272d9cd677230}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!clearLQ@{clearLQ}}
\index{clearLQ@{clearLQ}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{clearLQ}]{\setlength{\rightskip}{0pt plus 5cm}void clearLQ ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_ae3af532345dbe6519e8272d9cd677230}
Clears all the entries in the LQ. 


\begin{DoxyCode}
188 {
189     loadQueue.clear();
190 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a171cd7891063f418b1ee217f5c03537b}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!clearSQ@{clearSQ}}
\index{clearSQ@{clearSQ}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{clearSQ}]{\setlength{\rightskip}{0pt plus 5cm}void clearSQ ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a171cd7891063f418b1ee217f5c03537b}
Clears all the entries in the SQ. 


\begin{DoxyCode}
195 {
196     storeQueue.clear();
197 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a8ddd26e169a62ec5ae591a9f95934839}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!commitLoad@{commitLoad}}
\index{commitLoad@{commitLoad}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{commitLoad}]{\setlength{\rightskip}{0pt plus 5cm}void commitLoad ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a8ddd26e169a62ec5ae591a9f95934839}
Commits the head load. 


\begin{DoxyCode}
482 {
483     assert(!loadQueue.empty());
484 
485     DPRINTF(OzoneLSQ, "[sn:%lli] Committing head load instruction, PC %#x\n",
486             loadQueue.back()->seqNum, loadQueue.back()->readPC());
487 
488     LQIndices.push(loadQueue.back()->lqIdx);
489     LQItHash.erase(loadQueue.back()->lqIdx);
490 
491     loadQueue.pop_back();
492 
493     --loads;
494 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a1ae517a923a864a4e3a5aa1eeb2dd2d6}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!commitLoads@{commitLoads}}
\index{commitLoads@{commitLoads}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{commitLoads}]{\setlength{\rightskip}{0pt plus 5cm}void commitLoads ({\bf InstSeqNum} \& {\em youngest\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a1ae517a923a864a4e3a5aa1eeb2dd2d6}
Commits loads older than a specific sequence number. 


\begin{DoxyCode}
499 {
500     assert(loads == 0 || !loadQueue.empty());
501 
502     while (loads != 0 &&
503            loadQueue.back()->seqNum <= youngest_inst) {
504         commitLoad();
505     }
506 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a954ce1ce58b67cae49ba127d5ea40701}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!commitStores@{commitStores}}
\index{commitStores@{commitStores}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{commitStores}]{\setlength{\rightskip}{0pt plus 5cm}void commitStores ({\bf InstSeqNum} \& {\em youngest\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a954ce1ce58b67cae49ba127d5ea40701}
Commits stores older than a specific sequence number. 


\begin{DoxyCode}
511 {
512     assert(stores == 0 || !storeQueue.empty());
513 
514     SQIt sq_it = --(storeQueue.end());
515     while (!storeQueue.empty() && sq_it != storeQueue.end()) {
516         assert((*sq_it).inst);
517         if (!(*sq_it).canWB) {
518             if ((*sq_it).inst->seqNum > youngest_inst) {
519                 break;
520             }
521             ++storesToWB;
522 
523             DPRINTF(OzoneLSQ, "Marking store as able to write back, PC "
524                     "%#x [sn:%lli], storesToWB:%i\n",
525                     (*sq_it).inst->readPC(),
526                     (*sq_it).inst->seqNum,
527                     storesToWB);
528 
529             (*sq_it).canWB = true;
530         }
531 
532         sq_it--;
533     }
534 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a0f7f0d3412bbf494cd3d0c0f48e5fcf2}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!completeDataAccess@{completeDataAccess}}
\index{completeDataAccess@{completeDataAccess}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{completeDataAccess}]{\setlength{\rightskip}{0pt plus 5cm}void completeDataAccess ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a0f7f0d3412bbf494cd3d0c0f48e5fcf2}
Completes the data access that has been returned from the memory system. 


\begin{DoxyCode}
98 {
99     LSQSenderState *state = dynamic_cast<LSQSenderState *>(pkt->senderState);
100     DynInstPtr inst = state->inst;
101     DPRINTF(IEW, "Writeback event [sn:%lli]\n", inst->seqNum);
102     DPRINTF(Activity, "Activity: Writeback event [sn:%lli]\n", inst->seqNum);
103 
104     //iewStage->ldstQueue.removeMSHR(inst->threadNumber,inst->seqNum);
105 
106     if (isSwitchedOut() || inst->isSquashed()) {
107         delete state;
108         delete pkt;
109         return;
110     } else {
111         if (!state->noWB) {
112             writeback(inst, pkt);
113         }
114 
115         if (inst->isStore()) {
116             completeStore(inst);
117         }
118     }
119 
120     delete state;
121     delete pkt;
122 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a14bf528b217d02373076ed257f448dbf}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!completeStore@{completeStore}}
\index{completeStore@{completeStore}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{completeStore}]{\setlength{\rightskip}{0pt plus 5cm}void completeStore ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classOzoneLWLSQ_a14bf528b217d02373076ed257f448dbf}
Completes the store at the specified index. 


\begin{DoxyCode}
904 {
905     --storesToWB;
906     --stores;
907 
908     inst->setCompleted();
909     if (cpu->checker) {
910         cpu->checker->verify(inst);
911     }
912 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a80587b4fe043bbe1995536cb3b361588}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!dumpInsts@{dumpInsts}}
\index{dumpInsts@{dumpInsts}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{dumpInsts}]{\setlength{\rightskip}{0pt plus 5cm}void dumpInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a80587b4fe043bbe1995536cb3b361588}
Debugging function to dump instructions in the \hyperlink{classLSQ}{LSQ}. 


\begin{DoxyCode}
790 {
791     cprintf("Load store queue: Dumping instructions.\n");
792     cprintf("Load queue size: %i\n", loads);
793     cprintf("Load queue: ");
794 
795     LQIt lq_it = --(loadQueue.end());
796 
797     while (lq_it != loadQueue.end() && (*lq_it)) {
798         cprintf("[sn:%lli] %#x ", (*lq_it)->seqNum,
799                 (*lq_it)->readPC());
800 
801         lq_it--;
802     }
803 
804     cprintf("\nStore queue size: %i\n", stores);
805     cprintf("Store queue: ");
806 
807     SQIt sq_it = --(storeQueue.end());
808 
809     while (sq_it != storeQueue.end() && (*sq_it).inst) {
810         cprintf("[sn:%lli]\nPC:%#x\nSize:%i\nCommitted:%i\nCompleted:%i\ncanWB:%i
      \n",
811                 (*sq_it).inst->seqNum,
812                 (*sq_it).inst->readPC(),
813                 (*sq_it).size,
814                 (*sq_it).committed,
815                 (*sq_it).completed,
816                 (*sq_it).canWB);
817 
818         sq_it--;
819     }
820 
821     cprintf("\n");
822 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a30c6332142c2ecca389ed6ee463c692b}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!executeLoad@{executeLoad}}
\index{executeLoad@{executeLoad}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{executeLoad}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} executeLoad ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a30c6332142c2ecca389ed6ee463c692b}
Executes a load instruction. 


\begin{DoxyCode}
352 {
353     // Execute a specific load.
354     Fault load_fault = NoFault;
355 
356     DPRINTF(OzoneLSQ, "Executing load PC %#x, [sn:%lli]\n",
357             inst->readPC(),inst->seqNum);
358 
359     // Make sure it's really in the list.
360     // Normally it should always be in the list.  However,
361     /* due to a syscall it may not be the list.
362 #ifdef DEBUG
363     int i = loadHead;
364     while (1) {
365         if (i == loadTail && !find(inst)) {
366             assert(0 && "Load not in the queue!");
367         } else if (loadQueue[i] == inst) {
368             break;
369         }
370 
371         i = i + 1;
372         if (i >= LQEntries) {
373             i = 0;
374         }
375     }
376 #endif // DEBUG*/
377 
378     load_fault = inst->initiateAcc();
379 
380     // Might want to make sure that I'm not overwriting a previously faulting
381     // instruction that hasn't been checked yet.
382     // Actually probably want the oldest faulting load
383     if (load_fault != NoFault) {
384         DPRINTF(OzoneLSQ, "Load [sn:%lli] has a fault\n", inst->seqNum);
385         if (!(inst->req->isUncacheable() && !inst->isAtCommit())) {
386             inst->setExecuted();
387         }
388         // Maybe just set it as can commit here, although that might cause
389         // some other problems with sending traps to the ROB too quickly.
390         be->instToCommit(inst);
391 //        iewStage->activityThisCycle();
392     }
393 
394     return load_fault;
395 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_aad78b8a37ee5c61e47df58dd39980340}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!executeStore@{executeStore}}
\index{executeStore@{executeStore}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{executeStore}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} executeStore ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_aad78b8a37ee5c61e47df58dd39980340}
Executes a store instruction. 


\begin{DoxyCode}
400 {
401     // Make sure that a store exists.
402     assert(stores != 0);
403 
404     int store_idx = store_inst->sqIdx;
405     SQHashIt sq_hash_it = SQItHash.find(store_idx);
406     assert(sq_hash_it != SQItHash.end());
407     DPRINTF(OzoneLSQ, "Executing store PC %#x [sn:%lli]\n",
408             store_inst->readPC(), store_inst->seqNum);
409 
410     SQIt sq_it = (*sq_hash_it).second;
411 
412     Fault store_fault = store_inst->initiateAcc();
413 
414     // Store size should now be available.  Use it to get proper offset for
415     // addr comparisons.
416     int size = (*sq_it).size;
417 
418     if (size == 0) {
419         DPRINTF(OzoneLSQ,"Fault on Store PC %#x, [sn:%lli],Size = 0\n",
420                 store_inst->readPC(),store_inst->seqNum);
421 
422         return store_fault;
423     }
424 
425     assert(store_fault == NoFault);
426 
427     if (!storeFaultInst) {
428         if (store_fault != NoFault) {
429             panic("Fault in a store instruction!");
430             storeFaultInst = store_inst;
431         } else if (store_inst->isStoreConditional()) {
432             // Store conditionals need to set themselves as able to
433             // writeback if we haven't had a fault by here.
434             (*sq_it).canWB = true;
435 
436             ++storesToWB;
437             DPRINTF(OzoneLSQ, "Nonspeculative store! storesToWB:%i\n",
438                     storesToWB);
439         }
440     }
441 
442     LQIt lq_it = --(loadQueue.end());
443 
444     if (!memDepViolator) {
445         while (lq_it != loadQueue.end()) {
446             if ((*lq_it)->seqNum < store_inst->seqNum) {
447                 lq_it--;
448                 continue;
449             }
450             // Actually should only check loads that have actually executed
451             // Might be safe because effAddr is set to InvalAddr when the
452             // dyn inst is created.
453 
454             // Must actually check all addrs in the proper size range
455             // Which is more correct than needs to be.  What if for now we just
456             // assume all loads are quad-word loads, and do the addr based
457             // on that.
458             // @todo: Fix this, magic number being used here
459             if (((*lq_it)->effAddr >> 8) ==
460                 (store_inst->effAddr >> 8)) {
461                 // A load incorrectly passed this store.  Squash and refetch.
462                 // For now return a fault to show that it was unsuccessful.
463                 memDepViolator = (*lq_it);
464                 ++lsqMemOrderViolation;
465 
466                 return TheISA::genMachineCheckFault();
467             }
468 
469             lq_it--;
470         }
471 
472         // If we've reached this point, there was no violation.
473         memDepViolator = NULL;
474     }
475 
476     return store_fault;
477 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a24ba9cb3fa1e726321780a20a960c8cd}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!getCount@{getCount}}
\index{getCount@{getCount}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{getCount}]{\setlength{\rightskip}{0pt plus 5cm}unsigned getCount ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a24ba9cb3fa1e726321780a20a960c8cd}
Returns the number of instructions in the \hyperlink{classLSQ}{LSQ}. 


\begin{DoxyCode}
199 { return loads + stores; }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a32e64f82b805fe23a17b01dda0f44fb0}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!getDcachePort@{getDcachePort}}
\index{getDcachePort@{getDcachePort}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{getDcachePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Port}$\ast$ getDcachePort ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a32e64f82b805fe23a17b01dda0f44fb0}



\begin{DoxyCode}
96 { return &dcachePort; }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_aee7352adadc6b43b7ce36a8c052eb222}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!getLoadHeadSeqNum@{getLoadHeadSeqNum}}
\index{getLoadHeadSeqNum@{getLoadHeadSeqNum}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{getLoadHeadSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} getLoadHeadSeqNum ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_aee7352adadc6b43b7ce36a8c052eb222}
Returns the sequence number of the head load instruction. 


\begin{DoxyCode}
465     {
466         if (!loadQueue.empty()) {
467             return loadQueue.back()->seqNum;
468         } else {
469             return 0;
470         }
471 
472     }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a30adaf6f5fb6b38b5747f35c419e3f31}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!getMemDepViolator@{getMemDepViolator}}
\index{getMemDepViolator@{getMemDepViolator}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{getMemDepViolator}]{\setlength{\rightskip}{0pt plus 5cm}Impl::DynInstPtr getMemDepViolator ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a30adaf6f5fb6b38b5747f35c419e3f31}
Returns the memory ordering violator. 


\begin{DoxyCode}
308 {
309     DynInstPtr temp = memDepViolator;
310 
311     memDepViolator = NULL;
312 
313     return temp;
314 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a1813b58ab7569d6aeefb5d4e235cceda}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!getStoreHeadSeqNum@{getStoreHeadSeqNum}}
\index{getStoreHeadSeqNum@{getStoreHeadSeqNum}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{getStoreHeadSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} getStoreHeadSeqNum ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a1813b58ab7569d6aeefb5d4e235cceda}
Returns the sequence number of the head store instruction. 


\begin{DoxyCode}
476     {
477         if (!storeQueue.empty()) {
478             return storeQueue.back().inst->seqNum;
479         } else {
480             return 0;
481         }
482 
483     }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_ad2e4b46255cfb53e85522adeed4e2089}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!hasStoresToWB@{hasStoresToWB}}
\index{hasStoresToWB@{hasStoresToWB}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{hasStoresToWB}]{\setlength{\rightskip}{0pt plus 5cm}bool hasStoresToWB ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_ad2e4b46255cfb53e85522adeed4e2089}
Returns if there are any stores to writeback. 


\begin{DoxyCode}
202 { return storesToWB; }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_ae8565b0968a8115705f1585e8aa21f75}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!init@{init}}
\index{init@{init}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ({\bf Params} $\ast$ {\em params}, \/  unsigned {\em maxLQEntries}, \/  unsigned {\em maxSQEntries}, \/  unsigned {\em id})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_ae8565b0968a8115705f1585e8aa21f75}
Initializes the \hyperlink{classLSQ}{LSQ} unit with the specified number of entries. 


\begin{DoxyCode}
136 {
137     DPRINTF(OzoneLSQ, "Creating OzoneLWLSQ%i object.\n",id);
138 
139     lsqID = id;
140 
141     LQEntries = maxLQEntries;
142     SQEntries = maxSQEntries;
143 
144     for (int i = 0; i < LQEntries * 2; i++) {
145         LQIndices.push(i);
146         SQIndices.push(i);
147     }
148 
149     usedPorts = 0;
150     cachePorts = params->cachePorts;
151 
152     loadFaultInst = storeFaultInst = memDepViolator = NULL;
153 
154     blockedLoadSeqNum = 0;
155 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a773e88db1aa010c3755e603493bf40ec}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!insert@{insert}}
\index{insert@{insert}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{insert}]{\setlength{\rightskip}{0pt plus 5cm}void insert ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a773e88db1aa010c3755e603493bf40ec}
Inserts an instruction. 


\begin{DoxyCode}
243 {
244     // Make sure we really have a memory reference.
245     assert(inst->isMemRef());
246 
247     // Make sure it's one of the two classes of memory references.
248     assert(inst->isLoad() || inst->isStore());
249 
250     if (inst->isLoad()) {
251         insertLoad(inst);
252     } else {
253         insertStore(inst);
254     }
255 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_ad22b3ecafed2bcd9c59fcab049a1cb98}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!insertLoad@{insertLoad}}
\index{insertLoad@{insertLoad}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{insertLoad}]{\setlength{\rightskip}{0pt plus 5cm}void insertLoad ({\bf DynInstPtr} \& {\em load\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_ad22b3ecafed2bcd9c59fcab049a1cb98}
Inserts a load instruction. 


\begin{DoxyCode}
260 {
261     assert(loads < LQEntries * 2);
262     assert(!LQIndices.empty());
263     int load_index = LQIndices.front();
264     LQIndices.pop();
265 
266     DPRINTF(OzoneLSQ, "Inserting load PC %#x, idx:%i [sn:%lli]\n",
267             load_inst->readPC(), load_index, load_inst->seqNum);
268 
269     load_inst->lqIdx = load_index;
270 
271     loadQueue.push_front(load_inst);
272     LQItHash[load_index] = loadQueue.begin();
273 
274     ++loads;
275 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a6a4b4e51bfff3639932ebaba45e8a282}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!insertStore@{insertStore}}
\index{insertStore@{insertStore}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{insertStore}]{\setlength{\rightskip}{0pt plus 5cm}void insertStore ({\bf DynInstPtr} \& {\em store\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a6a4b4e51bfff3639932ebaba45e8a282}
Inserts a store instruction. 


\begin{DoxyCode}
280 {
281     // Make sure it is not full before inserting an instruction.
282     assert(stores - storesToWB < SQEntries);
283 
284     assert(!SQIndices.empty());
285     int store_index = SQIndices.front();
286     SQIndices.pop();
287 
288     DPRINTF(OzoneLSQ, "Inserting store PC %#x, idx:%i [sn:%lli]\n",
289             store_inst->readPC(), store_index, store_inst->seqNum);
290 
291     store_inst->sqIdx = store_index;
292     SQEntry entry(store_inst);
293     if (loadQueue.empty()) {
294         entry.lqIt = loadQueue.end();
295     } else {
296         entry.lqIt = loadQueue.begin();
297     }
298     storeQueue.push_front(entry);
299 
300     SQItHash[store_index] = storeQueue.begin();
301 
302     ++stores;
303 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a3e70330939fdfc4dbc2f60c1a660584d}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!isFull@{isFull}}
\index{isFull@{isFull}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{isFull}]{\setlength{\rightskip}{0pt plus 5cm}bool isFull ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a3e70330939fdfc4dbc2f60c1a660584d}
Returns if either the LQ or SQ is full. 


\begin{DoxyCode}
187 { return lqFull() || sqFull(); }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_ad0aa91a7b51ca925abf9c9992abad314}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!isLoadBlockedHandled@{isLoadBlockedHandled}}
\index{isLoadBlockedHandled@{isLoadBlockedHandled}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{isLoadBlockedHandled}]{\setlength{\rightskip}{0pt plus 5cm}bool isLoadBlockedHandled ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_ad0aa91a7b51ca925abf9c9992abad314}



\begin{DoxyCode}
169     { return loadBlockedHandled; }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_af8eb8590fbfa6ecd2f796390677a4c00}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!isStalled@{isStalled}}
\index{isStalled@{isStalled}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{isStalled}]{\setlength{\rightskip}{0pt plus 5cm}bool isStalled ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_af8eb8590fbfa6ecd2f796390677a4c00}
Returns whether or not the \hyperlink{classLSQ}{LSQ} unit is stalled. 


\begin{DoxyCode}
486 { return stalled; }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a471165257f311a78136ce991a3bad31a}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!isSwitchedOut@{isSwitchedOut}}
\index{isSwitchedOut@{isSwitchedOut}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{isSwitchedOut}]{\setlength{\rightskip}{0pt plus 5cm}bool isSwitchedOut ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a471165257f311a78136ce991a3bad31a}



\begin{DoxyCode}
216 { return switchedOut; }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a05c413ba417c6453e99f75d87c958590}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!loadBlocked@{loadBlocked}}
\index{loadBlocked@{loadBlocked}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{loadBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool loadBlocked ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a05c413ba417c6453e99f75d87c958590}
Returns if a load became blocked due to the memory system. It clears the bool's value upon this being called. 


\begin{DoxyCode}
163     { return isLoadBlocked; }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a5893daf623130be826f492bbff58f757}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!lqFull@{lqFull}}
\index{lqFull@{lqFull}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{lqFull}]{\setlength{\rightskip}{0pt plus 5cm}bool lqFull ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a5893daf623130be826f492bbff58f757}
Returns if the LQ is full. 


\begin{DoxyCode}
190 { return loads >= (LQEntries - 1); }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!name@{name}}
\index{name@{name}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a37627d5d5bba7f4a8690c71c2ab3cb07}
Returns the name of the \hyperlink{classLSQ}{LSQ} unit. 


\begin{DoxyCode}
160 {
161     return "lsqunit";
162 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a028971a565aca048c67ea1c36a6a9d51}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!numFreeEntries@{numFreeEntries}}
\index{numFreeEntries@{numFreeEntries}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{numFreeEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned numFreeEntries ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a028971a565aca048c67ea1c36a6a9d51}
Returns the number of free entries (min of free LQ and SQ entries). 


\begin{DoxyCode}
319 {
320     unsigned free_lq_entries = LQEntries - loads;
321     unsigned free_sq_entries = SQEntries - (stores + storesInFlight);
322 
323     // Both the LQ and SQ entries have an extra dummy entry to differentiate
324     // empty/full conditions.  Subtract 1 from the free entries.
325     if (free_lq_entries < free_sq_entries) {
326         return free_lq_entries - 1;
327     } else {
328         return free_sq_entries - 1;
329     }
330 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a54460b759fb06e2b18e26657279a6f49}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!numLoads@{numLoads}}
\index{numLoads@{numLoads}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{numLoads}]{\setlength{\rightskip}{0pt plus 5cm}int numLoads ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a54460b759fb06e2b18e26657279a6f49}
Returns the number of loads in the LQ. 


\begin{DoxyCode}
181 { return loads; }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a9aa5d5a61b2229931008ac2ea802a3ab}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!numLoadsReady@{numLoadsReady}}
\index{numLoadsReady@{numLoadsReady}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{numLoadsReady}]{\setlength{\rightskip}{0pt plus 5cm}int numLoadsReady ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a9aa5d5a61b2229931008ac2ea802a3ab}
Returns the number of loads ready to execute. 


\begin{DoxyCode}
335 {
336     int retval = 0;
337     LQIt lq_it = loadQueue.begin();
338     LQIt end_it = loadQueue.end();
339 
340     while (lq_it != end_it) {
341         if ((*lq_it)->readyToIssue()) {
342             ++retval;
343         }
344     }
345 
346     return retval;
347 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_aa0fc32a4a9d77696f5907f4d25e7d07f}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!numStores@{numStores}}
\index{numStores@{numStores}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{numStores}]{\setlength{\rightskip}{0pt plus 5cm}int numStores ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_aa0fc32a4a9d77696f5907f4d25e7d07f}
Returns the number of stores in the SQ. 


\begin{DoxyCode}
184 { return stores + storesInFlight; }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a276cdbdaf4551f1b846c4e2535c5f882}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!numStoresToWB@{numStoresToWB}}
\index{numStoresToWB@{numStoresToWB}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{numStoresToWB}]{\setlength{\rightskip}{0pt plus 5cm}int numStoresToWB ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a276cdbdaf4551f1b846c4e2535c5f882}
Returns the number of stores to writeback. 


\begin{DoxyCode}
205 { return storesToWB; }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a0747777ac998dabdc20fa0c554d378d3}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!read@{read}}
\index{read@{read}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} read ({\bf RequestPtr} {\em req}, \/  T \& {\em data}, \/  int {\em load\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a0747777ac998dabdc20fa0c554d378d3}
Executes the load at the given index. 


\begin{DoxyCode}
493 {
494     //Depending on issue2execute delay a squashed load could
495     //execute if it is found to be squashed in the same
496     //cycle it is scheduled to execute
497     typename m5::hash_map<int, LQIt, HashFn>::iterator
498         lq_hash_it = LQItHash.find(load_idx);
499     assert(lq_hash_it != LQItHash.end());
500     DynInstPtr inst = (*(*lq_hash_it).second);
501 
502     // Make sure this isn't an uncacheable access
503     // A bit of a hackish way to get uncached accesses to work only if they're
504     // at the head of the LSQ and are ready to commit (at the head of the ROB
505     // too).
506     // @todo: Fix uncached accesses.
507     if (req->isUncacheable() &&
508         (inst != loadQueue.back() || !inst->isAtCommit())) {
509         DPRINTF(OzoneLSQ, "[sn:%lli] Uncached load and not head of "
510                 "commit/LSQ!\n",
511                 inst->seqNum);
512         be->rescheduleMemInst(inst);
513         return TheISA::genMachineCheckFault();
514     }
515 
516     // Check the SQ for any previous stores that might lead to forwarding
517     SQIt sq_it = storeQueue.begin();
518     int store_size = 0;
519 
520     DPRINTF(OzoneLSQ, "Read called, load idx: %i addr: %#x\n",
521             load_idx, req->getPaddr());
522 
523     while (sq_it != storeQueue.end() && (*sq_it).inst->seqNum > inst->seqNum)
524         ++sq_it;
525 
526     while (1) {
527         // End once we've reached the top of the LSQ
528         if (sq_it == storeQueue.end()) {
529             break;
530         }
531 
532         assert((*sq_it).inst);
533 
534         store_size = (*sq_it).size;
535 
536         if (store_size == 0 || (*sq_it).committed) {
537             sq_it++;
538             continue;
539         }
540 
541         // Check if the store data is within the lower and upper bounds of
542         // addresses that the request needs.
543         bool store_has_lower_limit =
544             req->getVaddr() >= (*sq_it).inst->effAddr;
545         bool store_has_upper_limit =
546             (req->getVaddr() + req->getSize()) <= ((*sq_it).inst->effAddr +
547                                                    store_size);
548         bool lower_load_has_store_part =
549             req->getVaddr() < ((*sq_it).inst->effAddr +
550                                store_size);
551         bool upper_load_has_store_part =
552             (req->getVaddr() + req->getSize()) > (*sq_it).inst->effAddr;
553 
554         // If the store's data has all of the data needed, we can forward.
555         if (store_has_lower_limit && store_has_upper_limit) {
556             int shift_amt = req->getVaddr() & (store_size - 1);
557             // Assumes byte addressing
558             shift_amt = shift_amt << 3;
559 
560             // Cast this to type T?
561             data = (*sq_it).data >> shift_amt;
562 
563             assert(!inst->memData);
564             inst->memData = new uint8_t[64];
565 
566             memcpy(inst->memData, &data, req->getSize());
567 
568             DPRINTF(OzoneLSQ, "Forwarding from store [sn:%lli] to load to "
569                     "[sn:%lli] addr %#x, data %#x\n",
570                     (*sq_it).inst->seqNum, inst->seqNum, req->getVaddr(),
571                     *(inst->memData));
572 
573             PacketPtr data_pkt = new Packet(req, Packet::ReadReq);
574             data_pkt->dataStatic(inst->memData);
575 
576             WritebackEvent *wb = new WritebackEvent(inst, data_pkt, this);
577 
578             // We'll say this has a 1 cycle load-store forwarding latency
579             // for now.
580             // @todo: Need to make this a parameter.
581             wb->schedule(curTick());
582 
583             // Should keep track of stat for forwarded data
584             return NoFault;
585         } else if ((store_has_lower_limit && lower_load_has_store_part) ||
586                    (store_has_upper_limit && upper_load_has_store_part) ||
587                    (lower_load_has_store_part && upper_load_has_store_part)) {
588             // This is the partial store-load forwarding case where a store
589             // has only part of the load's data.
590 
591             // If it's already been written back, then don't worry about
592             // stalling on it.
593             if ((*sq_it).completed) {
594                 sq_it++;
595                 break;
596             }
597 
598             // Must stall load and force it to retry, so long as it's the oldest
599             // load that needs to do so.
600             if (!stalled ||
601                 (stalled &&
602                  inst->seqNum <
603                  (*stallingLoad)->seqNum)) {
604                 stalled = true;
605                 stallingStoreIsn = (*sq_it).inst->seqNum;
606                 stallingLoad = (*lq_hash_it).second;
607             }
608 
609             // Tell IQ/mem dep unit that this instruction will need to be
610             // rescheduled eventually
611             be->rescheduleMemInst(inst);
612 
613             DPRINTF(OzoneLSQ, "Load-store forwarding mis-match. "
614                     "Store [sn:%lli] to load addr %#x\n",
615                     (*sq_it).inst->seqNum, req->getVaddr());
616 
617             return NoFault;
618         }
619         sq_it++;
620     }
621 
622     // If there's no forwarding case, then go access memory
623     DPRINTF(OzoneLSQ, "Doing functional access for inst PC %#x\n",
624             inst->readPC());
625 
626     assert(!inst->memData);
627     inst->memData = new uint8_t[64];
628 
629     ++usedPorts;
630 
631     DPRINTF(OzoneLSQ, "Doing timing access for inst PC %#x\n",
632             inst->readPC());
633 
634     PacketPtr data_pkt =
635         new Packet(req,
636                    (req->isLLSC() ?
637                     MemCmd::LoadLockedReq : Packet::ReadReq));
638     data_pkt->dataStatic(inst->memData);
639 
640     LSQSenderState *state = new LSQSenderState;
641     state->isLoad = true;
642     state->idx = load_idx;
643     state->inst = inst;
644     data_pkt->senderState = state;
645 
646     // if we have a cache, do cache access too
647     if (!dcachePort.sendTiming(data_pkt)) {
648         // There's an older load that's already going to squash.
649         if (isLoadBlocked && blockedLoadSeqNum < inst->seqNum)
650             return NoFault;
651 
652         // Record that the load was blocked due to memory.  This
653         // load will squash all instructions after it, be
654         // refetched, and re-executed.
655         isLoadBlocked = true;
656         loadBlockedHandled = false;
657         blockedLoadSeqNum = inst->seqNum;
658         // No fault occurred, even though the interface is blocked.
659         return NoFault;
660     }
661 
662     if (req->isLLSC()) {
663         cpu->lockFlag = true;
664     }
665 
666     return NoFault;
667 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a29cb5a4f98063ce6e9210eacbdb35298}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetry ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classOzoneLWLSQ_a29cb5a4f98063ce6e9210eacbdb35298}
Handles doing the retry. 


\begin{DoxyCode}
917 {
918     panic("Unimplemented!");
919 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!regStats@{regStats}}
\index{regStats@{regStats}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a4dc637449366fcdfc4e764cdf12d9b11}



\begin{DoxyCode}
167 {
168     lsqMemOrderViolation
169         .name(name() + ".memOrderViolation")
170         .desc("Number of memory ordering violations");
171 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_ad5ff9e08c63a01ac86a8f80765b37365}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!removeStore@{removeStore}}
\index{removeStore@{removeStore}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{removeStore}]{\setlength{\rightskip}{0pt plus 5cm}void removeStore (int {\em store\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classOzoneLWLSQ_ad5ff9e08c63a01ac86a8f80765b37365}



\begin{DoxyCode}
873 {
874     SQHashIt sq_hash_it = SQItHash.find(store_idx);
875     assert(sq_hash_it != SQItHash.end());
876     SQIt sq_it = (*sq_hash_it).second;
877 
878     assert((*sq_it).inst);
879     (*sq_it).completed = true;
880     DynInstPtr inst = (*sq_it).inst;
881 
882     if (isStalled() &&
883         inst->seqNum == stallingStoreIsn) {
884         DPRINTF(OzoneLSQ, "Unstalling, stalling store [sn:%lli] "
885                 "load [sn:%lli]\n",
886                 stallingStoreIsn, (*stallingLoad)->seqNum);
887         stalled = false;
888         stallingStoreIsn = 0;
889         be->replayMemInst((*stallingLoad));
890     }
891 
892     DPRINTF(OzoneLSQ, "Completing store idx:%i [sn:%lli], storesToWB:%i\n",
893             inst->sqIdx, inst->seqNum, storesToWB);
894 
895     assert(!storeQueue.empty());
896     SQItHash.erase(sq_hash_it);
897     SQIndices.push(inst->sqIdx);
898     storeQueue.erase(sq_it);
899 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a3bc9500810cb2d5615e29206e2d6499f}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!resizeLQ@{resizeLQ}}
\index{resizeLQ@{resizeLQ}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{resizeLQ}]{\setlength{\rightskip}{0pt plus 5cm}void resizeLQ (unsigned {\em size})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a3bc9500810cb2d5615e29206e2d6499f}
Resizes the LQ to a given size. 


\begin{DoxyCode}
210 {
211     assert( size >= LQEntries);
212 
213     if (size > LQEntries) {
214         while (size > loadQueue.size()) {
215             DynInstPtr dummy;
216             loadQueue.push_back(dummy);
217             LQEntries++;
218         }
219     } else {
220         LQEntries = size;
221     }
222 
223 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a341dd6a3bd8d240659fd9d698c3b5c65}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!resizeSQ@{resizeSQ}}
\index{resizeSQ@{resizeSQ}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{resizeSQ}]{\setlength{\rightskip}{0pt plus 5cm}void resizeSQ (unsigned {\em size})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a341dd6a3bd8d240659fd9d698c3b5c65}
Resizes the SQ to a given size. 


\begin{DoxyCode}
228 {
229     if (size > SQEntries) {
230         while (size > storeQueue.size()) {
231             SQEntry dummy;
232             storeQueue.push_back(dummy);
233             SQEntries++;
234         }
235     } else {
236         SQEntries = size;
237     }
238 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a9134276ed85820d74779ad5826580822}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!setBE@{setBE}}
\index{setBE@{setBE}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{setBE}]{\setlength{\rightskip}{0pt plus 5cm}void setBE ({\bf BackEnd} $\ast$ {\em be\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a9134276ed85820d74779ad5826580822}
Sets the back-\/end stage pointer. 


\begin{DoxyCode}
94     { be = be_ptr; }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_ab8056057b67b41f234f56940cc115cc1}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!setCPU@{setCPU}}
\index{setCPU@{setCPU}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{setCPU}]{\setlength{\rightskip}{0pt plus 5cm}void setCPU ({\bf OzoneCPU} $\ast$ {\em cpu\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_ab8056057b67b41f234f56940cc115cc1}
Sets the CPU pointer. 


\begin{DoxyCode}
176 {
177     cpu = cpu_ptr;
178     dcachePort.setName(this->name() + "-dport");
179 
180     if (cpu->checker) {
181         cpu->checker->setDcachePort(&dcachePort);
182     }
183 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_ac8bfb1e163f7ba2261d702623226973d}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!setLoadBlockedHandled@{setLoadBlockedHandled}}
\index{setLoadBlockedHandled@{setLoadBlockedHandled}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{setLoadBlockedHandled}]{\setlength{\rightskip}{0pt plus 5cm}void setLoadBlockedHandled ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_ac8bfb1e163f7ba2261d702623226973d}



\begin{DoxyCode}
172     { loadBlockedHandled = true; }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a477981d1f905d2d398a1527f7149e3c4}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!sqFull@{sqFull}}
\index{sqFull@{sqFull}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{sqFull}]{\setlength{\rightskip}{0pt plus 5cm}bool sqFull ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a477981d1f905d2d398a1527f7149e3c4}
Returns if the SQ is full. 


\begin{DoxyCode}
193 { return (stores + storesInFlight) >= (SQEntries - 1); }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a51dd7e304d5413447717826fac6f4921}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!squash@{squash}}
\index{squash@{squash}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash (const {\bf InstSeqNum} \& {\em squashed\_\-num})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a51dd7e304d5413447717826fac6f4921}
Squashes all instructions younger than a specific sequence number. 


\begin{DoxyCode}
713 {
714     DPRINTF(OzoneLSQ, "Squashing until [sn:%lli]!"
715             "(Loads:%i Stores:%i)\n",squashed_num,loads,stores+storesInFlight);
716 
717 
718     LQIt lq_it = loadQueue.begin();
719 
720     while (loads != 0 && (*lq_it)->seqNum > squashed_num) {
721         assert(!loadQueue.empty());
722         // Clear the smart pointer to make sure it is decremented.
723         DPRINTF(OzoneLSQ,"Load Instruction PC %#x squashed, "
724                 "[sn:%lli]\n",
725                 (*lq_it)->readPC(),
726                 (*lq_it)->seqNum);
727 
728         if (isStalled() && lq_it == stallingLoad) {
729             stalled = false;
730             stallingStoreIsn = 0;
731             stallingLoad = NULL;
732         }
733 
734         --loads;
735 
736         // Inefficient!
737         LQHashIt lq_hash_it = LQItHash.find((*lq_it)->lqIdx);
738         assert(lq_hash_it != LQItHash.end());
739         LQItHash.erase(lq_hash_it);
740         LQIndices.push((*lq_it)->lqIdx);
741         loadQueue.erase(lq_it++);
742     }
743 
744     if (isLoadBlocked) {
745         if (squashed_num < blockedLoadSeqNum) {
746             isLoadBlocked = false;
747             loadBlockedHandled = false;
748             blockedLoadSeqNum = 0;
749         }
750     }
751 
752     SQIt sq_it = storeQueue.begin();
753 
754     while (stores != 0 && (*sq_it).inst->seqNum > squashed_num) {
755         assert(!storeQueue.empty());
756 
757         if ((*sq_it).canWB) {
758             break;
759         }
760 
761         // Clear the smart pointer to make sure it is decremented.
762         DPRINTF(OzoneLSQ,"Store Instruction PC %#x idx:%i squashed [sn:%lli]\n",
763                 (*sq_it).inst->readPC(), (*sq_it).inst->sqIdx,
764                 (*sq_it).inst->seqNum);
765 
766         // I don't think this can happen.  It should have been cleared by the
767         // stalling load.
768         if (isStalled() &&
769             (*sq_it).inst->seqNum == stallingStoreIsn) {
770             panic("Is stalled should have been cleared by stalling load!\n");
771             stalled = false;
772             stallingStoreIsn = 0;
773         }
774 
775         SQHashIt sq_hash_it = SQItHash.find((*sq_it).inst->sqIdx);
776         assert(sq_hash_it != SQItHash.end());
777         SQItHash.erase(sq_hash_it);
778         SQIndices.push((*sq_it).inst->sqIdx);
779         (*sq_it).inst = NULL;
780         (*sq_it).canWB = 0;
781         (*sq_it).req = NULL;
782         --stores;
783         storeQueue.erase(sq_it++);
784     }
785 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_af841afeea43eb2b2272f0dfaf17c3f4e}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!storePostSend@{storePostSend}}
\index{storePostSend@{storePostSend}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{storePostSend}]{\setlength{\rightskip}{0pt plus 5cm}void storePostSend ({\bf PacketPtr} {\em pkt}, \/  {\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classOzoneLWLSQ_af841afeea43eb2b2272f0dfaf17c3f4e}
Handles completing the send of a store to memory. 


\begin{DoxyCode}
827 {
828     if (isStalled() &&
829         inst->seqNum == stallingStoreIsn) {
830         DPRINTF(OzoneLSQ, "Unstalling, stalling store [sn:%lli] "
831                 "load [sn:%lli]\n",
832                 stallingStoreIsn, (*stallingLoad)->seqNum);
833         stalled = false;
834         stallingStoreIsn = 0;
835         be->replayMemInst((*stallingLoad));
836     }
837 
838     if (!inst->isStoreConditional()) {
839         // The store is basically completed at this time. This
840         // only works so long as the checker doesn't try to
841         // verify the value in memory for stores.
842         inst->setCompleted();
843         if (cpu->checker) {
844             cpu->checker->verify(inst);
845         }
846     }
847 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a05f299b443f8cc73a93d61572edc0218}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!switchOut@{switchOut}}
\index{switchOut@{switchOut}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{switchOut}]{\setlength{\rightskip}{0pt plus 5cm}void switchOut ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a05f299b443f8cc73a93d61572edc0218}



\begin{DoxyCode}
924 {
925     assert(storesToWB == 0);
926     switchedOut = true;
927 
928     // Clear the queue to free up resources
929     assert(stores == 0);
930     assert(storeQueue.empty());
931     assert(loads == 0);
932     assert(loadQueue.empty());
933     assert(storesInFlight == 0);
934     storeQueue.clear();
935     loadQueue.clear();
936     loads = stores = storesToWB = storesInFlight = 0;
937 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a5a901e7ec5b94a55bd61fde88ad0b7f1}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ({\bf ThreadContext} $\ast$ {\em old\_\-tc} = {\ttfamily NULL})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a5a901e7ec5b94a55bd61fde88ad0b7f1}



\begin{DoxyCode}
942 {
943     // Clear out any old state. May be redundant if this is the first time
944     // the CPU is being used.
945     stalled = false;
946     isLoadBlocked = false;
947     loadBlockedHandled = false;
948     switchedOut = false;
949 
950     // Could do simple checks here to see if indices are on twice
951     while (!LQIndices.empty())
952         LQIndices.pop();
953     while (!SQIndices.empty())
954         SQIndices.pop();
955 
956     for (int i = 0; i < LQEntries * 2; i++) {
957         LQIndices.push(i);
958         SQIndices.push(i);
959     }
960 
961     usedPorts = 0;
962 
963     loadFaultInst = storeFaultInst = memDepViolator = NULL;
964 
965     blockedLoadSeqNum = 0;
966 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a873dd91783f9efb4a590aded1f70d6b0}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!tick@{tick}}
\index{tick@{tick}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a873dd91783f9efb4a590aded1f70d6b0}
Ticks the \hyperlink{classLSQ}{LSQ} unit, which in this case only resets the number of used cache ports. \begin{Desc}
\item[\hyperlink{todo__todo000046}{TODO}]: Move the number of used ports up to the \hyperlink{classLSQ}{LSQ} level so it can be shared by all \hyperlink{classLSQ}{LSQ} units. \end{Desc}



\begin{DoxyCode}
103 { usedPorts = 0; }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a4f720bbfb5fdefdb23516500eeb0b4de}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!violation@{violation}}
\index{violation@{violation}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{violation}]{\setlength{\rightskip}{0pt plus 5cm}bool violation ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a4f720bbfb5fdefdb23516500eeb0b4de}
Returns if there is a memory ordering violation. Value is reset upon call to \hyperlink{classOzoneLWLSQ_a30adaf6f5fb6b38b5747f35c419e3f31}{getMemDepViolator()}. 


\begin{DoxyCode}
154 { return memDepViolator; }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a338be821734603396bfef8d9fb8f04b0}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!willWB@{willWB}}
\index{willWB@{willWB}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{willWB}]{\setlength{\rightskip}{0pt plus 5cm}bool willWB ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a338be821734603396bfef8d9fb8f04b0}
Returns if the \hyperlink{classLSQ}{LSQ} unit will writeback on this cycle. 


\begin{DoxyCode}
208                   { return storeQueue.back().canWB &&
209                         !storeQueue.back().completed &&
210                         !isStoreBlocked; }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_abbf7bcc93511421a1787650a43e2642a}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!write@{write}}
\index{write@{write}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} write ({\bf RequestPtr} {\em req}, \/  T \& {\em data}, \/  int {\em store\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_abbf7bcc93511421a1787650a43e2642a}
Executes the store at the given index. 


\begin{DoxyCode}
673 {
674     SQHashIt sq_hash_it = SQItHash.find(store_idx);
675     assert(sq_hash_it != SQItHash.end());
676 
677     SQIt sq_it = (*sq_hash_it).second;
678     assert((*sq_it).inst);
679 
680     DPRINTF(OzoneLSQ, "Doing write to store idx %i, addr %#x data %#x"
681             " | [sn:%lli]\n",
682             store_idx, req->getPaddr(), data, (*sq_it).inst->seqNum);
683 
684     (*sq_it).req = req;
685     (*sq_it).size = sizeof(T);
686     (*sq_it).data = data;
687 /*
688     assert(!req->data);
689     req->data = new uint8_t[64];
690     memcpy(req->data, (uint8_t *)&(*sq_it).data, req->size);
691 */
692 
693     // This function only writes the data to the store queue, so no fault
694     // can happen here.
695     return NoFault;
696 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a3911bacb8817c31cfbeefd125dba0217}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!writeback@{writeback}}
\index{writeback@{writeback}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{writeback}]{\setlength{\rightskip}{0pt plus 5cm}void writeback ({\bf DynInstPtr} \& {\em inst}, \/  {\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classOzoneLWLSQ_a3911bacb8817c31cfbeefd125dba0217}
Writes back the instruction, sending it to IEW. 


\begin{DoxyCode}
852 {
853     // Squashed instructions do not need to complete their access.
854     if (inst->isSquashed()) {
855         assert(!inst->isStore());
856         return;
857     }
858 
859     if (!inst->isExecuted()) {
860         inst->setExecuted();
861 
862         // Complete access to copy data to proper place.
863         inst->completeAcc(pkt);
864     }
865 
866     // Need to insert instruction into queue to commit
867     be->instToCommit(inst);
868 }
\end{DoxyCode}
\hypertarget{classOzoneLWLSQ_a5f04e29d6f6feb8b86460491f2ba7547}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!writebackStores@{writebackStores}}
\index{writebackStores@{writebackStores}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{writebackStores}]{\setlength{\rightskip}{0pt plus 5cm}void writebackStores ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classOzoneLWLSQ_a5f04e29d6f6feb8b86460491f2ba7547}
Writes back stores. 


\begin{DoxyCode}
539 {
540     SQIt sq_it = --(storeQueue.end());
541     while (storesToWB > 0 &&
542            sq_it != storeQueue.end() &&
543            (*sq_it).inst &&
544            (*sq_it).canWB &&
545            usedPorts < cachePorts) {
546 
547         if (isStoreBlocked) {
548             DPRINTF(OzoneLSQ, "Unable to write back any more stores, cache"
549                     " is blocked!\n");
550             break;
551         }
552 
553         DynInstPtr inst = (*sq_it).inst;
554 
555         if ((*sq_it).size == 0 && !(*sq_it).completed) {
556             sq_it--;
557             removeStore(inst->sqIdx);
558             completeStore(inst);
559             continue;
560         }
561 
562         if (inst->isDataPrefetch() || (*sq_it).committed) {
563             sq_it--;
564             continue;
565         }
566 
567         ++usedPorts;
568 
569         assert((*sq_it).req);
570         assert(!(*sq_it).committed);
571 
572         Request *req = (*sq_it).req;
573         (*sq_it).committed = true;
574 
575         assert(!inst->memData);
576         inst->memData = new uint8_t[64];
577         memcpy(inst->memData, (uint8_t *)&(*sq_it).data,
578                req->getSize());
579 
580         MemCmd command =
581             req->isSwap() ? MemCmd::SwapReq :
582             (req->isLLSC() ? MemCmd::WriteReq : MemCmd::StoreCondReq);
583         PacketPtr data_pkt = new Packet(req, command);
584         data_pkt->dataStatic(inst->memData);
585 
586         LSQSenderState *state = new LSQSenderState;
587         state->isLoad = false;
588         state->idx = inst->sqIdx;
589         state->inst = inst;
590         data_pkt->senderState = state;
591 
592         DPRINTF(OzoneLSQ, "D-Cache: Writing back store PC:%#x "
593                 "to Addr:%#x, data:%#x [sn:%lli]\n",
594                 (*sq_it).inst->readPC(),
595                 req->getPaddr(), *(inst->memData),
596                 inst->seqNum);
597 
598         // @todo: Remove this SC hack once the memory system handles it.
599         if (req->isLLSC()) {
600             if (req->isUncacheable()) {
601                 req->setExtraData(2);
602             } else {
603                 if (cpu->lockFlag) {
604                     req->setExtraData(1);
605                 } else {
606                     req->setExtraData(0);
607                     // Hack: Instantly complete this store.
608                     completeDataAccess(data_pkt);
609                     --sq_it;
610                     continue;
611                 }
612             }
613         } else {
614             // Non-store conditionals do not need a writeback.
615             state->noWB = true;
616         }
617 
618         if (!dcachePort.sendTiming(data_pkt)) {
619             // Need to handle becoming blocked on a store.
620             isStoreBlocked = true;
621             assert(retryPkt == NULL);
622             retryPkt = data_pkt;
623         } else {
624             storePostSend(data_pkt, inst);
625             --sq_it;
626         }
627 /*
628         DPRINTF(OzoneLSQ, "D-Cache: Writing back store idx:%i PC:%#x "
629                 "to Addr:%#x, data:%#x [sn:%lli]\n",
630                 inst->sqIdx,inst->readPC(),
631                 req->paddr, *(req->data),
632                 inst->seqNum);
633         DPRINTF(OzoneLSQ, "StoresInFlight: %i\n",
634                 storesInFlight + 1);
635 
636         if (dcacheInterface) {
637             assert(!req->completionEvent);
638             StoreCompletionEvent *store_event = new
639                 StoreCompletionEvent(inst, be, NULL, this);
640             req->completionEvent = store_event;
641 
642             MemAccessResult result = dcacheInterface->access(req);
643 
644             if (isStalled() &&
645                 inst->seqNum == stallingStoreIsn) {
646                 DPRINTF(OzoneLSQ, "Unstalling, stalling store [sn:%lli] "
647                         "load [sn:%lli]\n",
648                         stallingStoreIsn, (*stallingLoad)->seqNum);
649                 stalled = false;
650                 stallingStoreIsn = 0;
651                 be->replayMemInst((*stallingLoad));
652             }
653 
654             if (result != MA_HIT && dcacheInterface->doEvents()) {
655                 store_event->miss = true;
656                 typename BackEnd::LdWritebackEvent *wb = NULL;
657                 if (req->isLLSC()) {
658                     wb = new typename BackEnd::LdWritebackEvent(inst,
659                                                             be);
660                     store_event->wbEvent = wb;
661                 }
662 
663                 DPRINTF(OzoneLSQ,"D-Cache Write Miss!\n");
664 
665 //                DPRINTF(Activity, "Active st accessing mem miss [sn:%lli]\n",
666 //                        inst->seqNum);
667 
668                 be->addDcacheMiss(inst);
669 
670                 lastDcacheStall = curTick();
671 
672                 _status = DcacheMissStall;
673 
674                 // Increment stat here or something
675 
676                 sq_it--;
677             } else {
678                 DPRINTF(OzoneLSQ,"D-Cache: Write Hit on idx:%i !\n",
679                         inst->sqIdx);
680 
681 //                DPRINTF(Activity, "Active st accessing mem hit [sn:%lli]\n",
682 //                        inst->seqNum);
683 
684                 if (req->isLLSC()) {
685                     // Stx_C does not generate a system port
686                     // transaction in the 21264, but that might be
687                     // hard to accomplish in this model.
688 
689                     typename BackEnd::LdWritebackEvent *wb =
690                         new typename BackEnd::LdWritebackEvent(inst,
691                                                                be);
692                     store_event->wbEvent = wb;
693                 }
694                 sq_it--;
695             }
696             ++storesInFlight;
697 //            removeStore(inst->sqIdx);
698         } else {
699             panic("Must HAVE DCACHE!!!!!\n");
700         }
701 */
702     }
703 
704     // Not sure this should set it to 0.
705     usedPorts = 0;
706 
707     assert(stores >= 0 && storesToWB >= 0);
708 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classOzoneLWLSQ_a6cdf6e6db875a442f3ab6db542bd2bb5}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!\_\-status@{\_\-status}}
\index{\_\-status@{\_\-status}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{\_\-status}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Status} {\bf \_\-status}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a6cdf6e6db875a442f3ab6db542bd2bb5}
The status of the \hyperlink{classLSQ}{LSQ} unit. \hypertarget{classOzoneLWLSQ_a84f815aa1fa864ba2e6d75f5ad2b52d1}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!be@{be}}
\index{be@{be}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{be}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BackEnd}$\ast$ {\bf be}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a84f815aa1fa864ba2e6d75f5ad2b52d1}
Pointer to the back-\/end stage. \hypertarget{classOzoneLWLSQ_a3fca34b247fd8d081557578f8ca60fe3}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!blockedLoadSeqNum@{blockedLoadSeqNum}}
\index{blockedLoadSeqNum@{blockedLoadSeqNum}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{blockedLoadSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf blockedLoadSeqNum}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a3fca34b247fd8d081557578f8ca60fe3}
\hypertarget{classOzoneLWLSQ_ab2e23636971c40e7ed945026b2a184e1}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!cachePorts@{cachePorts}}
\index{cachePorts@{cachePorts}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{cachePorts}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf cachePorts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_ab2e23636971c40e7ed945026b2a184e1}
\begin{Desc}
\item[\hyperlink{todo__todo000047}{TODO}]Consider moving to a more advanced model with write vs read ports \end{Desc}
The number of cache ports available each cycle. \hypertarget{classOzoneLWLSQ_a61b5f503eec141308b0cd6b4322b405b}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!cpu@{cpu}}
\index{cpu@{cpu}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf OzoneCPU}$\ast$ {\bf cpu}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a61b5f503eec141308b0cd6b4322b405b}
Pointer to the CPU. \hypertarget{classOzoneLWLSQ_a38b03978ad7720fdc910ff6a8b44585f}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!dcachePort@{dcachePort}}
\index{dcachePort@{dcachePort}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{dcachePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DcachePort} {\bf dcachePort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a38b03978ad7720fdc910ff6a8b44585f}
D-\/cache port. \hypertarget{classOzoneLWLSQ_a95dc31b4ce3ebcb6b9d75a510b3a128c}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!isLoadBlocked@{isLoadBlocked}}
\index{isLoadBlocked@{isLoadBlocked}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{isLoadBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf isLoadBlocked}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a95dc31b4ce3ebcb6b9d75a510b3a128c}
Whether or not a load is blocked due to the memory system. It is cleared when this value is checked via \hyperlink{classOzoneLWLSQ_a05c413ba417c6453e99f75d87c958590}{loadBlocked()}. \hypertarget{classOzoneLWLSQ_a89d931c74b63e0b0e7ad856fe9525ff6}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!isStoreBlocked@{isStoreBlocked}}
\index{isStoreBlocked@{isStoreBlocked}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{isStoreBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf isStoreBlocked}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a89d931c74b63e0b0e7ad856fe9525ff6}
Whehter or not a store is blocked due to the memory system. \hypertarget{classOzoneLWLSQ_a8b4696062ef09ab956804a7a99491853}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!lastDcacheStall@{lastDcacheStall}}
\index{lastDcacheStall@{lastDcacheStall}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{lastDcacheStall}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Counter} {\bf lastDcacheStall}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a8b4696062ef09ab956804a7a99491853}
\hypertarget{classOzoneLWLSQ_a2c1620029c162c7180e523b089e56ed5}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!loadBlockedHandled@{loadBlockedHandled}}
\index{loadBlockedHandled@{loadBlockedHandled}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{loadBlockedHandled}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf loadBlockedHandled}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a2c1620029c162c7180e523b089e56ed5}
\hypertarget{classOzoneLWLSQ_a7123aa8b10829cc4712dff5454e13978}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!loadFaultInst@{loadFaultInst}}
\index{loadFaultInst@{loadFaultInst}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{loadFaultInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf loadFaultInst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a7123aa8b10829cc4712dff5454e13978}
The oldest faulting load instruction. \hypertarget{classOzoneLWLSQ_a6800290ffd43f3207c629be7f2d6228f}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!loadQueue@{loadQueue}}
\index{loadQueue@{loadQueue}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{loadQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf loadQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a6800290ffd43f3207c629be7f2d6228f}
The load queue. \hypertarget{classOzoneLWLSQ_a867971f18e464abd16193e069c64a8ad}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!loads@{loads}}
\index{loads@{loads}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{loads}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf loads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a867971f18e464abd16193e069c64a8ad}
The number of load instructions in the LQ. \hypertarget{classOzoneLWLSQ_aafa99d800d574095881acbacdbbbcc47}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!LQEntries@{LQEntries}}
\index{LQEntries@{LQEntries}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{LQEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf LQEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_aafa99d800d574095881acbacdbbbcc47}
The number of LQ entries. \hypertarget{classOzoneLWLSQ_a78218da891879fae16fe75c73981f75f}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!LQIndices@{LQIndices}}
\index{LQIndices@{LQIndices}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{LQIndices}]{\setlength{\rightskip}{0pt plus 5cm}std::queue$<$int$>$ {\bf LQIndices}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a78218da891879fae16fe75c73981f75f}
\hypertarget{classOzoneLWLSQ_afd55cfcf685cda7dafc7c52d5105e129}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!LQItHash@{LQItHash}}
\index{LQItHash@{LQItHash}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{LQItHash}]{\setlength{\rightskip}{0pt plus 5cm}m5::hash\_\-map$<$int, {\bf LQIt}, {\bf HashFn}$>$ {\bf LQItHash}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_afd55cfcf685cda7dafc7c52d5105e129}
\hypertarget{classOzoneLWLSQ_adfd96fbbaa327a31d20f0d4134418fad}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!lsqID@{lsqID}}
\index{lsqID@{lsqID}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{lsqID}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf lsqID}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_adfd96fbbaa327a31d20f0d4134418fad}
The \hyperlink{classOzoneLWLSQ}{OzoneLWLSQ} thread id. \hypertarget{classOzoneLWLSQ_ac499fc2b461e03a110deae7c695f75bc}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!lsqMemOrderViolation@{lsqMemOrderViolation}}
\index{lsqMemOrderViolation@{lsqMemOrderViolation}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{lsqMemOrderViolation}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf lsqMemOrderViolation}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_ac499fc2b461e03a110deae7c695f75bc}
Tota number of memory ordering violations. \hypertarget{classOzoneLWLSQ_a270a20c3fa52139e0538288275db9d22}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!memDepViolator@{memDepViolator}}
\index{memDepViolator@{memDepViolator}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{memDepViolator}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf memDepViolator}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a270a20c3fa52139e0538288275db9d22}
The oldest load that caused a memory ordering violation. \hypertarget{classOzoneLWLSQ_a314ae93c04b3ca96e79e1b1f39a8e478}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!retryPkt@{retryPkt}}
\index{retryPkt@{retryPkt}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{retryPkt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketPtr} {\bf retryPkt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a314ae93c04b3ca96e79e1b1f39a8e478}
The packet that needs to be retried. \hypertarget{classOzoneLWLSQ_a38c8af5392da70119dc5cce4e3637cbc}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!SQEntries@{SQEntries}}
\index{SQEntries@{SQEntries}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{SQEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf SQEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a38c8af5392da70119dc5cce4e3637cbc}
The number of SQ entries. \hypertarget{classOzoneLWLSQ_a94838aca72c880423d2328ae17f065e6}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!SQIndices@{SQIndices}}
\index{SQIndices@{SQIndices}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{SQIndices}]{\setlength{\rightskip}{0pt plus 5cm}std::queue$<$int$>$ {\bf SQIndices}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a94838aca72c880423d2328ae17f065e6}
\hypertarget{classOzoneLWLSQ_a3eb9bc9d55fde5b98e8d28a220d247f6}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!SQItHash@{SQItHash}}
\index{SQItHash@{SQItHash}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{SQItHash}]{\setlength{\rightskip}{0pt plus 5cm}m5::hash\_\-map$<$int, {\bf SQIt}, {\bf HashFn}$>$ {\bf SQItHash}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a3eb9bc9d55fde5b98e8d28a220d247f6}
\hypertarget{classOzoneLWLSQ_a6f8bff553ad30865c7d0c62e05421eb8}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!stalled@{stalled}}
\index{stalled@{stalled}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{stalled}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf stalled}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a6f8bff553ad30865c7d0c62e05421eb8}
Whether or not the \hyperlink{classLSQ}{LSQ} is stalled. \hypertarget{classOzoneLWLSQ_a567a64b358df6ae6162124cfe4d00db3}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!stallingLoad@{stallingLoad}}
\index{stallingLoad@{stallingLoad}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{stallingLoad}]{\setlength{\rightskip}{0pt plus 5cm}{\bf LQIt} {\bf stallingLoad}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a567a64b358df6ae6162124cfe4d00db3}
The index of the above store. \hypertarget{classOzoneLWLSQ_afe1cdcfca6b44c28581d862228adc3da}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!stallingStoreIsn@{stallingStoreIsn}}
\index{stallingStoreIsn@{stallingStoreIsn}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{stallingStoreIsn}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf stallingStoreIsn}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_afe1cdcfca6b44c28581d862228adc3da}
The store that causes the stall due to partial store to load forwarding. \hypertarget{classOzoneLWLSQ_ab98cf7d5235b7402e8916e78569f4ab2}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!storeFaultInst@{storeFaultInst}}
\index{storeFaultInst@{storeFaultInst}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{storeFaultInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf storeFaultInst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_ab98cf7d5235b7402e8916e78569f4ab2}
The oldest faulting store instruction. \hypertarget{classOzoneLWLSQ_aadda2adf789b0c8a3eb952ac5d65d4ed}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!storeQueue@{storeQueue}}
\index{storeQueue@{storeQueue}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{storeQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf SQEntry}$>$ {\bf storeQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_aadda2adf789b0c8a3eb952ac5d65d4ed}
The store queue. \hypertarget{classOzoneLWLSQ_ade9e895aa9c5ace27779c985c4f43326}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!stores@{stores}}
\index{stores@{stores}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{stores}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf stores}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_ade9e895aa9c5ace27779c985c4f43326}
The number of store instructions in the SQ (excludes those waiting to writeback). \hypertarget{classOzoneLWLSQ_a04638dcfe9b4f8584453bb178bd2da5e}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!storesInFlight@{storesInFlight}}
\index{storesInFlight@{storesInFlight}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{storesInFlight}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf storesInFlight}}}
\label{classOzoneLWLSQ_a04638dcfe9b4f8584453bb178bd2da5e}
\hypertarget{classOzoneLWLSQ_a3831a7965ffbe90df177026988476f9c}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!storesToWB@{storesToWB}}
\index{storesToWB@{storesToWB}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{storesToWB}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf storesToWB}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a3831a7965ffbe90df177026988476f9c}
\hypertarget{classOzoneLWLSQ_a1aee6db9bfb75cf02e38a82e5d02847f}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!switchedOut@{switchedOut}}
\index{switchedOut@{switchedOut}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{switchedOut}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf switchedOut}}}
\label{classOzoneLWLSQ_a1aee6db9bfb75cf02e38a82e5d02847f}
\hypertarget{classOzoneLWLSQ_a03435d626b7567ed154de5d7d8c3d419}{
\index{OzoneLWLSQ@{OzoneLWLSQ}!usedPorts@{usedPorts}}
\index{usedPorts@{usedPorts}!OzoneLWLSQ@{OzoneLWLSQ}}
\subsubsection[{usedPorts}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf usedPorts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classOzoneLWLSQ_a03435d626b7567ed154de5d7d8c3d419}
The number of used cache ports in this cycle. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/ozone/\hyperlink{lw__lsq_8hh}{lw\_\-lsq.hh}\item 
cpu/ozone/\hyperlink{lw__lsq__impl_8hh}{lw\_\-lsq\_\-impl.hh}\end{DoxyCompactItemize}
