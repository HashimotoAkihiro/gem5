\hypertarget{classArmKvmCPU}{
\section{クラス ArmKvmCPU}
\label{classArmKvmCPU}\index{ArmKvmCPU@{ArmKvmCPU}}
}


{\ttfamily \#include $<$arm\_\-cpu.hh$>$}ArmKvmCPUに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classArmKvmCPU}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classArmKvmCPU_1_1ArmKvmCPU}{ArmKvmCPU}
\item 
struct \hyperlink{structArmKvmCPU_1_1KvmCoreMiscRegInfo}{KvmCoreMiscRegInfo}
\item 
struct \hyperlink{structArmKvmCPU_1_1KvmIntRegInfo}{KvmIntRegInfo}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classArmKvmCPU_ab1eb352efa2b1da33f37cf592ffb2b00}{ArmKvmCPU} (ArmKvmCPUParams $\ast$params)
\item 
virtual \hyperlink{classArmKvmCPU_a5a7b2abd8e0f6124ff58343a788dfc1d}{$\sim$ArmKvmCPU} ()
\item 
void \hyperlink{classArmKvmCPU_aecc7d8debf54990ffeaaed5bac7d7d81}{startup} ()
\item 
void \hyperlink{classArmKvmCPU_accd2600060dbaee3a3b41aed4034c63c}{dump} ()
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classstd_1_1vector}{std::vector}$<$ uint64\_\-t $>$ \hyperlink{classArmKvmCPU_acba61563c19ad813c8026d8746e8bded}{RegIndexVector}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classArmKvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}{kvmRun} (\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} ticks)
\item 
void \hyperlink{classArmKvmCPU_a93c6e8c82dfb63c7039f0cbf064fae5d}{updateKvmState} ()
\item 
void \hyperlink{classArmKvmCPU_adbd5e38eae7c8c3021f2c4f430b399fd}{updateThreadContext} ()
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classArmKvmCPU_ac0b773030a2340b7bdac78ccc7227449}{onKvmExitHypercall} ()
\item 
const \hyperlink{classstd_1_1vector}{RegIndexVector} \& \hyperlink{classArmKvmCPU_ae852422eea452a5cdcf96e300ec91cc7}{getRegList} () const 
\item 
void \hyperlink{classArmKvmCPU_a2b5088861eb66dc69fc8dc2f39f6174e}{kvmArmVCpuInit} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} target)
\item 
void \hyperlink{classArmKvmCPU_a019059b30bdbbd0e5b4a2e41794f5e57}{kvmArmVCpuInit} (const struct kvm\_\-vcpu\_\-init \&init)
\item 
\hyperlink{namespaceArmISA_a1e522017e015d4c7efd6b2360143aa67}{ArmISA::MiscRegIndex} \hyperlink{classArmKvmCPU_a9b185ea78411f18604ed826462d010d7}{decodeCoProcReg} (uint64\_\-t id) const 
\item 
\hyperlink{namespaceArmISA_a1e522017e015d4c7efd6b2360143aa67}{ArmISA::MiscRegIndex} \hyperlink{classArmKvmCPU_acf6fe05c1274f3c7d8d6b452f193522b}{decodeVFPCtrlReg} (uint64\_\-t id) const 
\item 
bool \hyperlink{classArmKvmCPU_a901923fcf22651d3f67b8c4e0874868f}{isInvariantReg} (uint64\_\-t id)
\end{DoxyCompactItemize}
\subsection*{Static Protected 変数}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{structArmKvmCPU_1_1KvmIntRegInfo}{KvmIntRegInfo} \hyperlink{classArmKvmCPU_a610b9b2e17374a59cb14ab6e1b7c3dd0}{kvmIntRegs} \mbox{[}$\,$\mbox{]}
\item 
static \hyperlink{structArmKvmCPU_1_1KvmCoreMiscRegInfo}{KvmCoreMiscRegInfo} \hyperlink{classArmKvmCPU_a7f2a34be5f2a6e8b6812657f935461cf}{kvmCoreMiscRegs} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classArmKvmCPU_a8a90fa6e1883cd37fc5cd411a56331a7}{getRegList} (struct kvm\_\-reg\_\-list \&regs) const 
\item 
void \hyperlink{classArmKvmCPU_a54d58f77f2887428772599f7ddd8652e}{dumpKvmStateCore} ()
\item 
void \hyperlink{classArmKvmCPU_a7e82213fbf8527640f993114c92f97eb}{dumpKvmStateMisc} ()
\item 
void \hyperlink{classArmKvmCPU_a07eee5a82f9b81c1959175281ed1e12e}{dumpKvmStateCoProc} (uint64\_\-t id)
\item 
void \hyperlink{classArmKvmCPU_a3d102e15d4e84df462b8c31ec2f7ee0c}{dumpKvmStateVFP} (uint64\_\-t id)
\item 
void \hyperlink{classArmKvmCPU_ad705a24136d19a3497a77e57888e2111}{updateKvmStateCore} ()
\item 
void \hyperlink{classArmKvmCPU_a322cf85c38b68e9d2b62700eb61797f9}{updateKvmStateMisc} ()
\item 
void \hyperlink{classArmKvmCPU_a2647fd1f3839c4716dcec7ccfb567c33}{updateKvmStateCoProc} (uint64\_\-t id, bool show\_\-warnings)
\item 
void \hyperlink{classArmKvmCPU_ad423a1f901d535a33ee19130f1892350}{updateKvmStateVFP} (uint64\_\-t id, bool show\_\-warnings)
\item 
void \hyperlink{classArmKvmCPU_a72bbd13b32502607c6297268cace4868}{updateTCStateCore} ()
\item 
void \hyperlink{classArmKvmCPU_aa29d443c292712c817d1464fba8943d7}{updateTCStateMisc} ()
\item 
void \hyperlink{classArmKvmCPU_a398ea9eff7b6848bc2c92fe43999011d}{updateTCStateCoProc} (uint64\_\-t id, bool show\_\-warnings)
\item 
void \hyperlink{classArmKvmCPU_a94714d5528a5c80d1e0f9fe250514a07}{updateTCStateVFP} (uint64\_\-t id, bool show\_\-warnings)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classArmKvmCPU_af61d21c5b06aff9f758f797b2c8d422f}{irqAsserted}
\item 
bool \hyperlink{classArmKvmCPU_a980f87872f421bd8c54c0f347ad8bfcc}{fiqAsserted}
\item 
\hyperlink{classstd_1_1vector}{RegIndexVector} \hyperlink{classArmKvmCPU_ada25a9ee0667e58ed655eec2be09b133}{\_\-regIndexList}
\end{DoxyCompactItemize}
\subsection*{Static Private 変数}
\begin{DoxyCompactItemize}
\item 
static const std::set$<$ uint64\_\-t $>$ \hyperlink{classArmKvmCPU_a0183ebe7a406948461e8b808c5a3677d}{invariant\_\-regs}
\end{DoxyCompactItemize}


\subsection{説明}
ARM implementation of a KVM-\/based hardware virtualized CPU. Architecture specific limitations: $\ast$ LPAE is currently not supported by gem5. We therefore panic if LPAE is enabled when returning to gem5. $\ast$ The co-\/processor based interface to the architected timer is unsupported. We can't support this due to limitations in the KVM API on ARM. $\ast$ M5 ops are currently not supported. This requires either a kernel hack or a memory mapped device that handles the guest$<$-\/$>$\hyperlink{namespacem5}{m5} interface. 

\subsection{型定義}
\hypertarget{classArmKvmCPU_acba61563c19ad813c8026d8746e8bded}{
\index{ArmKvmCPU@{ArmKvmCPU}!RegIndexVector@{RegIndexVector}}
\index{RegIndexVector@{RegIndexVector}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{RegIndexVector}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::vector}$<$uint64\_\-t$>$ {\bf RegIndexVector}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmKvmCPU_acba61563c19ad813c8026d8746e8bded}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classArmKvmCPU_ab1eb352efa2b1da33f37cf592ffb2b00}{
\index{ArmKvmCPU@{ArmKvmCPU}!ArmKvmCPU@{ArmKvmCPU}}
\index{ArmKvmCPU@{ArmKvmCPU}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{ArmKvmCPU}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ArmKvmCPU} (ArmKvmCPUParams $\ast$ {\em params})}}
\label{classArmKvmCPU_ab1eb352efa2b1da33f37cf592ffb2b00}



\begin{DoxyCode}
245     : BaseKvmCPU(params),
246       irqAsserted(false), fiqAsserted(false)
247 {
248 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_a5a7b2abd8e0f6124ff58343a788dfc1d}{
\index{ArmKvmCPU@{ArmKvmCPU}!$\sim$ArmKvmCPU@{$\sim$ArmKvmCPU}}
\index{$\sim$ArmKvmCPU@{$\sim$ArmKvmCPU}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{$\sim$ArmKvmCPU}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf ArmKvmCPU} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classArmKvmCPU_a5a7b2abd8e0f6124ff58343a788dfc1d}



\begin{DoxyCode}
251 {
252 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classArmKvmCPU_a9b185ea78411f18604ed826462d010d7}{
\index{ArmKvmCPU@{ArmKvmCPU}!decodeCoProcReg@{decodeCoProcReg}}
\index{decodeCoProcReg@{decodeCoProcReg}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{decodeCoProcReg}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MiscRegIndex} decodeCoProcReg (uint64\_\-t {\em id}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmKvmCPU_a9b185ea78411f18604ed826462d010d7}



\begin{DoxyCode}
376 {
377     const unsigned cp(REG_CP(id));
378     const bool is_reg32(REG_IS_32BIT(id));
379     const bool is_reg64(REG_IS_64BIT(id));
380 
381     // CP numbers larger than 15 are reserved for KVM extensions
382     if (cp > 15)
383         return NUM_MISCREGS;
384 
385     const unsigned crm(REG_CRM(id));
386     const unsigned crn(REG_CRN(id));
387     const unsigned opc1(REG_OPC1(id));
388     const unsigned opc2(REG_OPC2(id));
389 
390     if (is_reg32) {
391         switch (cp) {
392           case 14:
393             return decodeCP14Reg(crn, opc1, crm, opc2);
394 
395           case 15:
396             return decodeCP15Reg(crn, opc1, crm, opc2);
397 
398           default:
399             return NUM_MISCREGS;
400         }
401     } else if(is_reg64) {
402         return NUM_MISCREGS;
403     } else {
404         warn("Unhandled register length, register (0x%x) ignored.\n");
405         return NUM_MISCREGS;
406     }
407 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_acf6fe05c1274f3c7d8d6b452f193522b}{
\index{ArmKvmCPU@{ArmKvmCPU}!decodeVFPCtrlReg@{decodeVFPCtrlReg}}
\index{decodeVFPCtrlReg@{decodeVFPCtrlReg}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{decodeVFPCtrlReg}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ArmISA::MiscRegIndex} decodeVFPCtrlReg (uint64\_\-t {\em id}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmKvmCPU_acf6fe05c1274f3c7d8d6b452f193522b}



\begin{DoxyCode}
411 {
412     if (!REG_IS_ARM(id) || !REG_IS_VFP(id) || !REG_IS_VFP_CTRL(id))
413         return NUM_MISCREGS;
414 
415     const unsigned vfp_reg(REG_VFP_REG(id));
416     switch (vfp_reg) {
417       case KVM_REG_ARM_VFP_FPSID: return MISCREG_FPSID;
418       case KVM_REG_ARM_VFP_FPSCR: return MISCREG_FPSCR;
419       case KVM_REG_ARM_VFP_MVFR0: return MISCREG_MVFR0;
420       case KVM_REG_ARM_VFP_MVFR1: return MISCREG_MVFR1;
421       case KVM_REG_ARM_VFP_FPEXC: return MISCREG_FPEXC;
422 
423       case KVM_REG_ARM_VFP_FPINST:
424       case KVM_REG_ARM_VFP_FPINST2:
425         warn_once("KVM: FPINST not implemented.\n");
426         return NUM_MISCREGS;
427 
428       default:
429         return NUM_MISCREGS;
430     }
431 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_accd2600060dbaee3a3b41aed4034c63c}{
\index{ArmKvmCPU@{ArmKvmCPU}!dump@{dump}}
\index{dump@{dump}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{dump}]{\setlength{\rightskip}{0pt plus 5cm}void dump ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classArmKvmCPU_accd2600060dbaee3a3b41aed4034c63c}
Dump the internal state to the terminal. 

\hyperlink{classBaseKvmCPU_accd2600060dbaee3a3b41aed4034c63c}{BaseKvmCPU}を再定義しています。


\begin{DoxyCode}
291 {
292     dumpKvmStateCore();
293     dumpKvmStateMisc();
294 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_a07eee5a82f9b81c1959175281ed1e12e}{
\index{ArmKvmCPU@{ArmKvmCPU}!dumpKvmStateCoProc@{dumpKvmStateCoProc}}
\index{dumpKvmStateCoProc@{dumpKvmStateCoProc}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{dumpKvmStateCoProc}]{\setlength{\rightskip}{0pt plus 5cm}void dumpKvmStateCoProc (uint64\_\-t {\em id})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmKvmCPU_a07eee5a82f9b81c1959175281ed1e12e}



\begin{DoxyCode}
523 {
524     assert(REG_IS_ARM(id));
525     assert(REG_CP(id) <= 15);
526 
527     if (REG_IS_32BIT(id)) {
528         // 32-bit co-proc registers
529         MiscRegIndex idx(decodeCoProcReg(id));
530         uint32_t value(getOneRegU32(id));
531 
532         if (idx != NUM_MISCREGS &&
533             !(idx >= MISCREG_CP15_UNIMP_START && idx < MISCREG_CP15_END)) {
534             const char *name(miscRegName[idx]);
535             const unsigned m5_ne(tc->readMiscRegNoEffect(idx));
536             const unsigned m5_e(tc->readMiscReg(idx));
537             inform("CP%i: [CRn: c%i opc1: %.2i CRm: c%i opc2: %i inv: %i]: "
538                    "[%s]: 0x%x/0x%x\n",
539                    REG_CP(id), REG_CRN(id), REG_OPC1(id), REG_CRM(id),
540                    REG_OPC2(id), isInvariantReg(id),
541                    name, value, m5_e);
542             if (m5_e != m5_ne) {
543                 inform("readMiscReg: %x, readMiscRegNoEffect: %x\n",
544                        m5_e, m5_ne);
545             }
546         } else {
547             const char *name(idx != NUM_MISCREGS ? miscRegName[idx] : "-");
548             inform("CP%i: [CRn: c%i opc1: %.2i CRm: c%i opc2: %i inv: %i]: [%s]: 
      "
549                    "0x%x\n",
550                    REG_CP(id), REG_CRN(id), REG_OPC1(id), REG_CRM(id),
551                    REG_OPC2(id), isInvariantReg(id), name, value);
552         }
553     } else {
554         inform("CP%i: [CRn: c%i opc1: %.2i CRm: c%i opc2: %i inv: %i "
555                "len: 0x%x]: %s\n",
556                REG_CP(id), REG_CRN(id), REG_OPC1(id), REG_CRM(id),
557                REG_OPC2(id), isInvariantReg(id),
558                EXTRACT_FIELD(id, KVM_REG_SIZE_MASK, KVM_REG_SIZE_SHIFT),
559                getAndFormatOneReg(id));
560     }
561 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_a54d58f77f2887428772599f7ddd8652e}{
\index{ArmKvmCPU@{ArmKvmCPU}!dumpKvmStateCore@{dumpKvmStateCore}}
\index{dumpKvmStateCore@{dumpKvmStateCore}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{dumpKvmStateCore}]{\setlength{\rightskip}{0pt plus 5cm}void dumpKvmStateCore ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmKvmCPU_a54d58f77f2887428772599f7ddd8652e}



\begin{DoxyCode}
462 {
463     /* Print core registers */
464     uint32_t pc(getOneRegU32(REG_CORE32(usr_regs.ARM_pc)));
465     inform("PC: 0x%x\n", pc);
466 
467     for (const KvmIntRegInfo *ri(kvmIntRegs);
468          ri->idx != NUM_INTREGS; ++ri) {
469 
470         uint32_t value(getOneRegU32(ri->id));
471         inform("%s: 0x%x\n", ri->name, value);
472     }
473 
474     for (const KvmCoreMiscRegInfo *ri(kvmCoreMiscRegs);
475          ri->idx != NUM_MISCREGS; ++ri) {
476 
477         uint32_t value(getOneRegU32(ri->id));
478         inform("%s: 0x%x\n", miscRegName[ri->idx], value);
479     }
480 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_a7e82213fbf8527640f993114c92f97eb}{
\index{ArmKvmCPU@{ArmKvmCPU}!dumpKvmStateMisc@{dumpKvmStateMisc}}
\index{dumpKvmStateMisc@{dumpKvmStateMisc}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{dumpKvmStateMisc}]{\setlength{\rightskip}{0pt plus 5cm}void dumpKvmStateMisc ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmKvmCPU_a7e82213fbf8527640f993114c92f97eb}



\begin{DoxyCode}
484 {
485     /* Print co-processor registers */
486     const RegIndexVector &reg_ids(getRegList());;
487     for (RegIndexVector::const_iterator it(reg_ids.begin());
488          it != reg_ids.end(); ++it) {
489         uint64_t id(*it);
490 
491         if (REG_IS_ARM(id) && REG_CP(id) <= 15) {
492             dumpKvmStateCoProc(id);
493         } else if (REG_IS_ARM(id) && REG_IS_VFP(id)) {
494             dumpKvmStateVFP(id);
495         } else if (REG_IS_ARM(id) && REG_IS_DEMUX(id)) {
496             switch (id & KVM_REG_ARM_DEMUX_ID_MASK) {
497               case KVM_REG_ARM_DEMUX_ID_CCSIDR:
498                 inform("CCSIDR [0x%x]: %s\n",
499                        EXTRACT_FIELD(id,
500                                      KVM_REG_ARM_DEMUX_VAL_MASK,
501                                      KVM_REG_ARM_DEMUX_VAL_SHIFT),
502                        getAndFormatOneReg(id));
503                 break;
504               default:
505                 inform("DEMUX [0x%x, 0x%x]: %s\n",
506                        EXTRACT_FIELD(id,
507                                      KVM_REG_ARM_DEMUX_ID_MASK,
508                                      KVM_REG_ARM_DEMUX_ID_SHIFT),
509                        EXTRACT_FIELD(id,
510                                      KVM_REG_ARM_DEMUX_VAL_MASK,
511                                      KVM_REG_ARM_DEMUX_VAL_SHIFT),
512                        getAndFormatOneReg(id));
513                 break;
514             }
515         } else if (!REG_IS_CORE(id)) {
516             inform("0x%x: %s\n", id, getAndFormatOneReg(id));
517         }
518     }
519 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_a3d102e15d4e84df462b8c31ec2f7ee0c}{
\index{ArmKvmCPU@{ArmKvmCPU}!dumpKvmStateVFP@{dumpKvmStateVFP}}
\index{dumpKvmStateVFP@{dumpKvmStateVFP}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{dumpKvmStateVFP}]{\setlength{\rightskip}{0pt plus 5cm}void dumpKvmStateVFP (uint64\_\-t {\em id})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmKvmCPU_a3d102e15d4e84df462b8c31ec2f7ee0c}



\begin{DoxyCode}
565 {
566     assert(REG_IS_ARM(id));
567     assert(REG_IS_VFP(id));
568 
569     if (REG_IS_VFP_REG(id)) {
570         const unsigned idx(id & KVM_REG_ARM_VFP_MASK);
571         inform("VFP reg %i: %s", idx, getAndFormatOneReg(id));
572     } else if (REG_IS_VFP_CTRL(id)) {
573         MiscRegIndex idx(decodeVFPCtrlReg(id));
574         if (idx != NUM_MISCREGS) {
575             inform("VFP [%s]: %s", miscRegName[idx], getAndFormatOneReg(id));
576         } else {
577             inform("VFP [0x%x]: %s", id, getAndFormatOneReg(id));
578         }
579     } else {
580         inform("VFP [0x%x]: %s", id, getAndFormatOneReg(id));
581     }
582 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_a8a90fa6e1883cd37fc5cd411a56331a7}{
\index{ArmKvmCPU@{ArmKvmCPU}!getRegList@{getRegList}}
\index{getRegList@{getRegList}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{getRegList}]{\setlength{\rightskip}{0pt plus 5cm}bool getRegList (struct kvm\_\-reg\_\-list \& {\em regs}) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmKvmCPU_a8a90fa6e1883cd37fc5cd411a56331a7}
Get a list of registers supported by \hyperlink{classBaseKvmCPU_ab5a47c64ebf5a4de2539c6f71f7acc51}{getOneReg()} and \hyperlink{classBaseKvmCPU_ad96695f9596f808056054f3c2026b818}{setOneReg()}.

\begin{DoxyReturn}{戻り値}
False if the number of elements allocated in the list is too small to hold the complete register list (the required value is written into n in this case). True on success. 
\end{DoxyReturn}



\begin{DoxyCode}
447 {
448     if (ioctl(KVM_GET_REG_LIST, (void *)&regs) == -1) {
449         if (errno == E2BIG) {
450             return false;
451         } else {
452             panic("KVM: Failed to get vCPU register list (errno: %i)\n",
453                   errno);
454         }
455     } else {
456         return true;
457     }
458 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_ae852422eea452a5cdcf96e300ec91cc7}{
\index{ArmKvmCPU@{ArmKvmCPU}!getRegList@{getRegList}}
\index{getRegList@{getRegList}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{getRegList}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf ArmKvmCPU::RegIndexVector} \& getRegList () const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmKvmCPU_ae852422eea452a5cdcf96e300ec91cc7}
Get a list of registers supported by \hyperlink{classBaseKvmCPU_ab5a47c64ebf5a4de2539c6f71f7acc51}{getOneReg()} and \hyperlink{classBaseKvmCPU_ad96695f9596f808056054f3c2026b818}{setOneReg()}. 


\begin{DoxyCode}
336 {
337     if (_regIndexList.size() == 0) {
338         std::unique_ptr<struct kvm_reg_list> regs;
339         uint64_t i(1);
340 
341         do {
342             i <<= 1;
343             regs.reset((struct kvm_reg_list *)
344                        operator new(sizeof(struct kvm_reg_list) +
345                                     i * sizeof(uint64_t)));
346             regs->n = i;
347         } while (!getRegList(*regs));
348         _regIndexList.assign(regs->reg,
349                              regs->reg + regs->n);
350     }
351 
352     return _regIndexList;
353 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_a901923fcf22651d3f67b8c4e0874868f}{
\index{ArmKvmCPU@{ArmKvmCPU}!isInvariantReg@{isInvariantReg}}
\index{isInvariantReg@{isInvariantReg}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{isInvariantReg}]{\setlength{\rightskip}{0pt plus 5cm}bool isInvariantReg (uint64\_\-t {\em id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmKvmCPU_a901923fcf22651d3f67b8c4e0874868f}
Determine if a register is invariant.

Some registers must have the same value in both the host and the guest. Such registers are referred to as \char`\"{}invariant\char`\"{} registers in KVM. This is a restriction imposed by KVM as having different values in ID registers (e.g., the cache identification registers) would confuse the guest kernel. 


\begin{DoxyCode}
435 {
436     /* Mask away the value field from multiplexed registers, we assume
437      * that entire groups of multiplexed registers can be treated as
438      * invariant. */
439     if (REG_IS_ARM(id) && REG_IS_DEMUX(id))
440         id &= ~KVM_REG_ARM_DEMUX_VAL_MASK;
441 
442     return invariant_regs.find(id) != invariant_regs.end();
443 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_a019059b30bdbbd0e5b4a2e41794f5e57}{
\index{ArmKvmCPU@{ArmKvmCPU}!kvmArmVCpuInit@{kvmArmVCpuInit}}
\index{kvmArmVCpuInit@{kvmArmVCpuInit}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{kvmArmVCpuInit}]{\setlength{\rightskip}{0pt plus 5cm}void kvmArmVCpuInit (const struct kvm\_\-vcpu\_\-init \& {\em init})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmKvmCPU_a019059b30bdbbd0e5b4a2e41794f5e57}



\begin{DoxyCode}
369 {
370     if (ioctl(KVM_ARM_VCPU_INIT, (void *)&init) == -1)
371         panic("KVM: Failed to initialize vCPU\n");
372 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_a2b5088861eb66dc69fc8dc2f39f6174e}{
\index{ArmKvmCPU@{ArmKvmCPU}!kvmArmVCpuInit@{kvmArmVCpuInit}}
\index{kvmArmVCpuInit@{kvmArmVCpuInit}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{kvmArmVCpuInit}]{\setlength{\rightskip}{0pt plus 5cm}void kvmArmVCpuInit ({\bf uint32\_\-t} {\em target})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmKvmCPU_a2b5088861eb66dc69fc8dc2f39f6174e}



\begin{DoxyCode}
357 {
358     struct kvm_vcpu_init init;
359 
360     memset(&init, 0, sizeof(init));
361 
362     init.target = target;
363 
364     kvmArmVCpuInit(init);
365 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}{
\index{ArmKvmCPU@{ArmKvmCPU}!kvmRun@{kvmRun}}
\index{kvmRun@{kvmRun}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{kvmRun}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} kvmRun ({\bf Tick} {\em ticks})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classArmKvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}
\hyperlink{classRequest}{Request} KVM to run the guest for a given number of ticks. The method returns the approximate number of ticks executed.

\begin{DoxyNote}{覚え書き}
The returned number of ticks can be both larger or smaller than the requested number of ticks. A smaller number can, for example, occur when the guest executes MMIO. A larger number is typically due to performance counter inaccuracies.

This method is virtual in order to allow implementations to check for architecture specific events (e.g., interrupts) before entering the VM.

It is the response of the caller (normally \hyperlink{classBaseKvmCPU_a873dd91783f9efb4a590aded1f70d6b0}{tick()}) to make sure that the KVM state is synchronized and that the TC is invalidated after entering KVM.

This method does not normally cause any state transitions. However, if it may suspend the CPU by suspending the thread, which leads to a transition to the Idle state. In such a case, kvm {\itshape must not\/} be entered.
\end{DoxyNote}

\begin{DoxyParams}{引数}
\item[{\em ticks}]Number of ticks to execute, set to 0 to exit immediately after finishing pending operations. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Number of ticks executed (see note) 
\end{DoxyReturn}


\hyperlink{classBaseKvmCPU_aed3dbd0c0bf26d82ee56367a3f350506}{BaseKvmCPU}を再定義しています。


\begin{DoxyCode}
271 {
272     bool simFIQ(interrupts->checkRaw(INT_FIQ));
273     bool simIRQ(interrupts->checkRaw(INT_IRQ));
274 
275     if (fiqAsserted != simFIQ) {
276         fiqAsserted = simFIQ;
277         DPRINTF(KvmInt, "KVM: Update FIQ state: %i\n", simFIQ);
278         vm.setIRQLine(INTERRUPT_VCPU_FIQ(vcpuID), simFIQ);
279     }
280     if (irqAsserted != simIRQ) {
281         irqAsserted = simIRQ;
282         DPRINTF(KvmInt, "KVM: Update IRQ state: %i\n", simIRQ);
283         vm.setIRQLine(INTERRUPT_VCPU_IRQ(vcpuID), simIRQ);
284     }
285 
286     return BaseKvmCPU::kvmRun(ticks);
287 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_ac0b773030a2340b7bdac78ccc7227449}{
\index{ArmKvmCPU@{ArmKvmCPU}!onKvmExitHypercall@{onKvmExitHypercall}}
\index{onKvmExitHypercall@{onKvmExitHypercall}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{onKvmExitHypercall}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} onKvmExitHypercall ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmKvmCPU_ac0b773030a2340b7bdac78ccc7227449}



\begin{DoxyCode}
316 {
317     ThreadContext *tc(getContext(0));
318     const uint32_t reg_ip(tc->readIntRegFlat(INTREG_R12));
319     const uint8_t func((reg_ip >> 8) & 0xFF);
320     const uint8_t subfunc(reg_ip & 0xFF);
321 
322     DPRINTF(Kvm, "KVM Hypercall: 0x%x/0x%x\n", func, subfunc);
323     const uint64_t ret(PseudoInst::pseudoInst(getContext(0), func, subfunc));
324 
325     // Just set the return value using the KVM API instead of messing
326     // with the context. We could have used the context, but that
327     // would have required us to request a full context sync.
328     setOneReg(REG_CORE32(usr_regs.ARM_r0), ret & 0xFFFFFFFF);
329     setOneReg(REG_CORE32(usr_regs.ARM_r1), (ret >> 32) & 0xFFFFFFFF);
330 
331     return 0;
332 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_aecc7d8debf54990ffeaaed5bac7d7d81}{
\index{ArmKvmCPU@{ArmKvmCPU}!startup@{startup}}
\index{startup@{startup}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{startup}]{\setlength{\rightskip}{0pt plus 5cm}void startup ()}}
\label{classArmKvmCPU_aecc7d8debf54990ffeaaed5bac7d7d81}


\hyperlink{classBaseKvmCPU_aecc7d8debf54990ffeaaed5bac7d7d81}{BaseKvmCPU}を再定義しています。


\begin{DoxyCode}
256 {
257     BaseKvmCPU::startup();
258 
259     /* TODO: This needs to be moved when we start to support VMs with
260      * multiple threads since kvmArmVCpuInit requires that all CPUs in
261      * the VM have been created.
262      */
263     /* TODO: The CPU type needs to be configurable once KVM on ARM
264      * starts to support more CPUs.
265      */
266     kvmArmVCpuInit(KVM_ARM_TARGET_CORTEX_A15);
267 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_a93c6e8c82dfb63c7039f0cbf064fae5d}{
\index{ArmKvmCPU@{ArmKvmCPU}!updateKvmState@{updateKvmState}}
\index{updateKvmState@{updateKvmState}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{updateKvmState}]{\setlength{\rightskip}{0pt plus 5cm}void updateKvmState ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classArmKvmCPU_a93c6e8c82dfb63c7039f0cbf064fae5d}
Update the KVM state from the current thread context

The base CPU calls this method before starting the guest CPU when the contextDirty flag is set. The architecture dependent CPU implementation is expected to update all guest state (registers, special registers, and FPU state). 

\hyperlink{classBaseKvmCPU_a48817be7bf03ef44cc5114ecf4df9b27}{BaseKvmCPU}を実装しています。


\begin{DoxyCode}
298 {
299     DPRINTF(KvmContext, "Updating KVM state...\n");
300 
301     updateKvmStateCore();
302     updateKvmStateMisc();
303 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_a2647fd1f3839c4716dcec7ccfb567c33}{
\index{ArmKvmCPU@{ArmKvmCPU}!updateKvmStateCoProc@{updateKvmStateCoProc}}
\index{updateKvmStateCoProc@{updateKvmStateCoProc}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{updateKvmStateCoProc}]{\setlength{\rightskip}{0pt plus 5cm}void updateKvmStateCoProc (uint64\_\-t {\em id}, \/  bool {\em show\_\-warnings})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmKvmCPU_a2647fd1f3839c4716dcec7ccfb567c33}



\begin{DoxyCode}
650 {
651     MiscRegIndex reg(decodeCoProcReg(id));
652 
653     assert(REG_IS_ARM(id));
654     assert(REG_CP(id) <= 15);
655 
656     if (id == KVM_REG64_TTBR0 || id == KVM_REG64_TTBR1) {
657         // HACK HACK HACK: Workaround for 64-bit TTBRx
658         reg = (id == KVM_REG64_TTBR0 ? MISCREG_TTBR0 : MISCREG_TTBR1);
659         if (show_warnings)
660             hack("KVM: 64-bit TTBBRx workaround\n");
661     }
662 
663     if (reg == NUM_MISCREGS) {
664         if (show_warnings) {
665             warn("KVM: Ignoring unknown KVM co-processor register (0x%.8x):\n",
666                  id);
667             warn("\t0x%x: [CP: %i 64: %i CRn: c%i opc1: %.2i CRm: c%i"
668                  " opc2: %i]\n",
669                  id, REG_CP(id), REG_IS_64BIT(id), REG_CRN(id),
670                  REG_OPC1(id), REG_CRM(id), REG_OPC2(id));
671         }
672     } else if (reg >= MISCREG_CP15_UNIMP_START && reg < MISCREG_CP15_END) {
673         if (show_warnings)
674             warn("KVM: Co-processor reg. %s not implemented by gem5.\n",
675                  miscRegName[reg]);
676     } else {
677         setOneReg(id, tc->readMiscRegNoEffect(reg));
678     }
679 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_ad705a24136d19a3497a77e57888e2111}{
\index{ArmKvmCPU@{ArmKvmCPU}!updateKvmStateCore@{updateKvmStateCore}}
\index{updateKvmStateCore@{updateKvmStateCore}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{updateKvmStateCore}]{\setlength{\rightskip}{0pt plus 5cm}void updateKvmStateCore ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmKvmCPU_ad705a24136d19a3497a77e57888e2111}



\begin{DoxyCode}
586 {
587     for (const KvmIntRegInfo *ri(kvmIntRegs);
588          ri->idx != NUM_INTREGS; ++ri) {
589 
590         uint64_t value(tc->readIntRegFlat(ri->idx));
591         DPRINTF(KvmContext, "kvm(%s) := 0x%x\n", ri->name, value);
592         setOneReg(ri->id, value);
593     }
594 
595     DPRINTF(KvmContext, "kvm(PC) := 0x%x\n", tc->instAddr());
596     setOneReg(REG_CORE32(usr_regs.ARM_pc), tc->instAddr());
597 
598     for (const KvmCoreMiscRegInfo *ri(kvmCoreMiscRegs);
599          ri->idx != NUM_MISCREGS; ++ri) {
600 
601         uint64_t value(tc->readMiscReg(ri->idx));
602         DPRINTF(KvmContext, "kvm(%s) := 0x%x\n", ri->name, value);
603         setOneReg(ri->id, value);
604     }
605 
606     if (DTRACE(KvmContext))
607         dumpKvmStateCore();
608 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_a322cf85c38b68e9d2b62700eb61797f9}{
\index{ArmKvmCPU@{ArmKvmCPU}!updateKvmStateMisc@{updateKvmStateMisc}}
\index{updateKvmStateMisc@{updateKvmStateMisc}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{updateKvmStateMisc}]{\setlength{\rightskip}{0pt plus 5cm}void updateKvmStateMisc ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmKvmCPU_a322cf85c38b68e9d2b62700eb61797f9}



\begin{DoxyCode}
612 {
613     static bool warned(false); // We can't use warn_once since we want
614                                // to show /all/ registers
615 
616     const RegIndexVector &regs(getRegList());
617 
618     for (RegIndexVector::const_iterator it(regs.begin());
619          it != regs.end();
620          ++it) {
621 
622         if (!REG_IS_ARM(*it)) {
623             if (!warned)
624                 warn("Skipping non-ARM register: 0x%x\n", *it);
625         } else if (isInvariantReg(*it)) {
626             DPRINTF(Kvm, "Skipping invariant register: 0x%x\n", *it);
627         } else if (REG_IS_CORE(*it)) {
628             // Core registers are handled in updateKvmStateCore
629             continue;
630         } else if (REG_CP(*it) <= 15) {
631             updateKvmStateCoProc(*it, !warned);
632         } else if (REG_IS_VFP(*it)) {
633             updateKvmStateVFP(*it, !warned);
634         } else {
635             if (!warned) {
636                 warn("Skipping register with unknown CP (%i) id: 0x%x\n",
637                      REG_CP(*it), *it);
638             }
639         }
640 
641     }
642 
643     warned = true;
644     if (DTRACE(KvmContext))
645         dumpKvmStateMisc();
646 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_ad423a1f901d535a33ee19130f1892350}{
\index{ArmKvmCPU@{ArmKvmCPU}!updateKvmStateVFP@{updateKvmStateVFP}}
\index{updateKvmStateVFP@{updateKvmStateVFP}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{updateKvmStateVFP}]{\setlength{\rightskip}{0pt plus 5cm}void updateKvmStateVFP (uint64\_\-t {\em id}, \/  bool {\em show\_\-warnings})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmKvmCPU_ad423a1f901d535a33ee19130f1892350}



\begin{DoxyCode}
684 {
685     assert(REG_IS_ARM(id));
686     assert(REG_IS_VFP(id));
687 
688     if (REG_IS_VFP_REG(id)) {
689         if (!REG_IS_64BIT(id)) {
690             if (show_warnings)
691                 warn("Unexpected VFP register length (reg: 0x%x).\n", id);
692             return;
693         }
694         const unsigned idx(id & KVM_REG_ARM_VFP_MASK);
695         const unsigned idx_base(idx << 1);
696         const unsigned idx_hi(idx_base + 1);
697         const unsigned idx_lo(idx_base + 0);
698         uint64_t value(
699             ((uint64_t)tc->readFloatRegBitsFlat(idx_hi) << 32) |
700             tc->readFloatRegBitsFlat(idx_lo));
701 
702         setOneReg(id, value);
703     } else if (REG_IS_VFP_CTRL(id)) {
704         MiscRegIndex idx(decodeVFPCtrlReg(id));
705         if (idx == NUM_MISCREGS) {
706             if (show_warnings)
707                 warn("Unhandled VFP control register: 0x%x\n", id);
708             return;
709         }
710         if (!REG_IS_32BIT(id)) {
711             if (show_warnings)
712                 warn("Ignoring VFP control register (%s) with "
713                      "unexpected size.\n",
714                      miscRegName[idx]);
715             return;
716         }
717         setOneReg(id, (uint32_t)tc->readMiscReg(idx));
718     } else {
719         if (show_warnings)
720             warn("Unhandled VFP register: 0x%x\n", id);
721     }
722 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_a398ea9eff7b6848bc2c92fe43999011d}{
\index{ArmKvmCPU@{ArmKvmCPU}!updateTCStateCoProc@{updateTCStateCoProc}}
\index{updateTCStateCoProc@{updateTCStateCoProc}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{updateTCStateCoProc}]{\setlength{\rightskip}{0pt plus 5cm}void updateTCStateCoProc (uint64\_\-t {\em id}, \/  bool {\em show\_\-warnings})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmKvmCPU_a398ea9eff7b6848bc2c92fe43999011d}



\begin{DoxyCode}
789 {
790     MiscRegIndex reg(decodeCoProcReg(id));
791 
792     assert(REG_IS_ARM(id));
793     assert(REG_CP(id) <= 15);
794 
795     if (id == KVM_REG64_TTBR0 || id == KVM_REG64_TTBR1) {
796         // HACK HACK HACK: We don't currently support 64-bit TTBR0/TTBR1
797         hack_once("KVM: 64-bit TTBRx workaround\n");
798         tc->setMiscRegNoEffect(
799             id == KVM_REG64_TTBR0 ? MISCREG_TTBR0 : MISCREG_TTBR1,
800             (uint32_t)(getOneRegU64(id) & 0xFFFFFFFF));
801     } else if (reg == MISCREG_TTBCR) {
802         uint32_t value(getOneRegU64(id));
803         if (value & 0x80000000)
804             panic("KVM: Guest tried to enable LPAE.\n");
805         tc->setMiscRegNoEffect(reg, value);
806     } else if (reg == NUM_MISCREGS) {
807         if (show_warnings) {
808             warn("KVM: Ignoring unknown KVM co-processor register:\n", id);
809             warn("\t0x%x: [CP: %i 64: %i CRn: c%i opc1: %.2i CRm: c%i"
810                  " opc2: %i]\n",
811                  id, REG_CP(id), REG_IS_64BIT(id), REG_CRN(id),
812                  REG_OPC1(id), REG_CRM(id), REG_OPC2(id));
813         }
814     } else if (reg >= MISCREG_CP15_UNIMP_START && reg < MISCREG_CP15_END) {
815         if (show_warnings)
816             warn_once("KVM: Co-processor reg. %s not implemented by gem5.\n",
817                       miscRegName[reg]);
818     } else {
819         tc->setMiscRegNoEffect(reg, getOneRegU32(id));
820     }
821 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_a72bbd13b32502607c6297268cace4868}{
\index{ArmKvmCPU@{ArmKvmCPU}!updateTCStateCore@{updateTCStateCore}}
\index{updateTCStateCore@{updateTCStateCore}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{updateTCStateCore}]{\setlength{\rightskip}{0pt plus 5cm}void updateTCStateCore ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmKvmCPU_a72bbd13b32502607c6297268cace4868}



\begin{DoxyCode}
726 {
727     for (const KvmIntRegInfo *ri(kvmIntRegs);
728          ri->idx != NUM_INTREGS; ++ri) {
729 
730         tc->setIntRegFlat(ri->idx, getOneRegU32(ri->id));
731     }
732 
733     for (const KvmCoreMiscRegInfo *ri(kvmCoreMiscRegs);
734          ri->idx != NUM_MISCREGS; ++ri) {
735 
736         tc->setMiscRegNoEffect(ri->idx, getOneRegU32(ri->id));
737     }
738 
739     /* We want the simulator to execute all side-effects of the CPSR
740      * update since this updates PC state and register maps.
741      */
742     tc->setMiscReg(MISCREG_CPSR, tc->readMiscRegNoEffect(MISCREG_CPSR));
743 
744     // We update the PC state after we have updated the CPSR the
745     // contents of the CPSR affects how the npc is updated.
746     PCState pc(tc->pcState());
747     pc.set(getOneRegU32(REG_CORE32(usr_regs.ARM_pc)));
748     tc->pcState(pc);
749 
750     if (DTRACE(KvmContext))
751         dumpKvmStateCore();
752 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_aa29d443c292712c817d1464fba8943d7}{
\index{ArmKvmCPU@{ArmKvmCPU}!updateTCStateMisc@{updateTCStateMisc}}
\index{updateTCStateMisc@{updateTCStateMisc}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{updateTCStateMisc}]{\setlength{\rightskip}{0pt plus 5cm}void updateTCStateMisc ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmKvmCPU_aa29d443c292712c817d1464fba8943d7}



\begin{DoxyCode}
756 {
757     static bool warned(false); // We can't use warn_once since we want
758                                // to show /all/ registers
759 
760     const RegIndexVector &reg_ids(getRegList());;
761     for (RegIndexVector::const_iterator it(reg_ids.begin());
762          it != reg_ids.end(); ++it) {
763 
764         if (!REG_IS_ARM(*it)) {
765             if (!warned)
766                 warn("Skipping non-ARM register: 0x%x\n", *it);
767         } else if (REG_IS_CORE(*it)) {
768             // Core registers are handled in updateKvmStateCore
769         } else if (REG_CP(*it) <= 15) {
770             updateTCStateCoProc(*it, !warned);
771         } else if (REG_IS_VFP(*it)) {
772             updateTCStateVFP(*it, !warned);
773         } else {
774             if (!warned) {
775                 warn("Skipping register with unknown CP (%i) id: 0x%x\n",
776                      REG_CP(*it), *it);
777             }
778         }
779     }
780 
781     warned = true;
782 
783     if (DTRACE(KvmContext))
784         dumpKvmStateMisc();
785 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_a94714d5528a5c80d1e0f9fe250514a07}{
\index{ArmKvmCPU@{ArmKvmCPU}!updateTCStateVFP@{updateTCStateVFP}}
\index{updateTCStateVFP@{updateTCStateVFP}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{updateTCStateVFP}]{\setlength{\rightskip}{0pt plus 5cm}void updateTCStateVFP (uint64\_\-t {\em id}, \/  bool {\em show\_\-warnings})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmKvmCPU_a94714d5528a5c80d1e0f9fe250514a07}



\begin{DoxyCode}
825 {
826     assert(REG_IS_ARM(id));
827     assert(REG_IS_VFP(id));
828 
829     if (REG_IS_VFP_REG(id)) {
830         if (!REG_IS_64BIT(id)) {
831             if (show_warnings)
832                 warn("Unexpected VFP register length (reg: 0x%x).\n", id);
833             return;
834         }
835         const unsigned idx(id & KVM_REG_ARM_VFP_MASK);
836         const unsigned idx_base(idx << 1);
837         const unsigned idx_hi(idx_base + 1);
838         const unsigned idx_lo(idx_base + 0);
839         uint64_t value(getOneRegU64(id));
840 
841         tc->setFloatRegBitsFlat(idx_hi, (value >> 32) & 0xFFFFFFFF);
842         tc->setFloatRegBitsFlat(idx_lo, value & 0xFFFFFFFF);
843     } else if (REG_IS_VFP_CTRL(id)) {
844         MiscRegIndex idx(decodeVFPCtrlReg(id));
845         if (idx == NUM_MISCREGS) {
846             if (show_warnings)
847                 warn("Unhandled VFP control register: 0x%x\n", id);
848             return;
849         }
850         if (!REG_IS_32BIT(id)) {
851             if (show_warnings)
852                 warn("Ignoring VFP control register (%s) with "
853                      "unexpected size.\n",
854                      miscRegName[idx]);
855             return;
856         }
857         tc->setMiscReg(idx, getOneRegU64(id));
858     } else {
859         if (show_warnings)
860             warn("Unhandled VFP register: 0x%x\n", id);
861     }
862 }
\end{DoxyCode}
\hypertarget{classArmKvmCPU_adbd5e38eae7c8c3021f2c4f430b399fd}{
\index{ArmKvmCPU@{ArmKvmCPU}!updateThreadContext@{updateThreadContext}}
\index{updateThreadContext@{updateThreadContext}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{updateThreadContext}]{\setlength{\rightskip}{0pt plus 5cm}void updateThreadContext ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classArmKvmCPU_adbd5e38eae7c8c3021f2c4f430b399fd}
Update the current thread context with the KVM state

The base CPU after the guest updates any of the KVM state. In practice, this happens after kvmRun is called. The architecture dependent code is expected to read the state of the guest CPU and update gem5's thread state. 

\hyperlink{classBaseKvmCPU_ac47bfb587580ca76050e0c9bc753c10d}{BaseKvmCPU}を実装しています。


\begin{DoxyCode}
307 {
308     DPRINTF(KvmContext, "Updating gem5 state...\n");
309 
310     updateTCStateCore();
311     updateTCStateMisc();
312 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classArmKvmCPU_ada25a9ee0667e58ed655eec2be09b133}{
\index{ArmKvmCPU@{ArmKvmCPU}!\_\-regIndexList@{\_\-regIndexList}}
\index{\_\-regIndexList@{\_\-regIndexList}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{\_\-regIndexList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RegIndexVector} {\bf \_\-regIndexList}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, private\mbox{]}}}}
\label{classArmKvmCPU_ada25a9ee0667e58ed655eec2be09b133}
Cached copy of the list of co-\/processor registers supported by KVM \hypertarget{classArmKvmCPU_a980f87872f421bd8c54c0f347ad8bfcc}{
\index{ArmKvmCPU@{ArmKvmCPU}!fiqAsserted@{fiqAsserted}}
\index{fiqAsserted@{fiqAsserted}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{fiqAsserted}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf fiqAsserted}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmKvmCPU_a980f87872f421bd8c54c0f347ad8bfcc}
Cached state of the FIQ line \hypertarget{classArmKvmCPU_a0183ebe7a406948461e8b808c5a3677d}{
\index{ArmKvmCPU@{ArmKvmCPU}!invariant\_\-regs@{invariant\_\-regs}}
\index{invariant\_\-regs@{invariant\_\-regs}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{invariant\_\-regs}]{\setlength{\rightskip}{0pt plus 5cm}const std::set$<$ uint64\_\-t $>$ {\bf invariant\_\-regs}\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classArmKvmCPU_a0183ebe7a406948461e8b808c5a3677d}
List of co-\/processor registers that KVM requires to be identical on both the host and the guest. KVM does not allow writes to these registers. \hypertarget{classArmKvmCPU_af61d21c5b06aff9f758f797b2c8d422f}{
\index{ArmKvmCPU@{ArmKvmCPU}!irqAsserted@{irqAsserted}}
\index{irqAsserted@{irqAsserted}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{irqAsserted}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf irqAsserted}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmKvmCPU_af61d21c5b06aff9f758f797b2c8d422f}
Cached state of the IRQ line \hypertarget{classArmKvmCPU_a7f2a34be5f2a6e8b6812657f935461cf}{
\index{ArmKvmCPU@{ArmKvmCPU}!kvmCoreMiscRegs@{kvmCoreMiscRegs}}
\index{kvmCoreMiscRegs@{kvmCoreMiscRegs}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{kvmCoreMiscRegs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ArmKvmCPU::KvmCoreMiscRegInfo} {\bf kvmCoreMiscRegs}\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classArmKvmCPU_a7f2a34be5f2a6e8b6812657f935461cf}
{\bfseries 初期値:}
\begin{DoxyCode}
 {
    { REG_CORE32(usr_regs.ARM_cpsr), MISCREG_CPSR, "CPSR" },
    { REG_CORE32(svc_regs[2]), MISCREG_SPSR_SVC, "SPSR(SVC)" },
    { REG_CORE32(abt_regs[2]), MISCREG_SPSR_ABT, "SPSR(ABT)" },
    { REG_CORE32(und_regs[2]), MISCREG_SPSR_UND, "SPSR(UND)" },
    { REG_CORE32(irq_regs[2]), MISCREG_SPSR_IRQ, "SPSR(IRQ)" },
    { REG_CORE32(fiq_regs[2]), MISCREG_SPSR_FIQ, "SPSR(FIQ)" },
    { 0, NUM_MISCREGS }
}
\end{DoxyCode}
\hypertarget{classArmKvmCPU_a610b9b2e17374a59cb14ab6e1b7c3dd0}{
\index{ArmKvmCPU@{ArmKvmCPU}!kvmIntRegs@{kvmIntRegs}}
\index{kvmIntRegs@{kvmIntRegs}!ArmKvmCPU@{ArmKvmCPU}}
\subsubsection[{kvmIntRegs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ArmKvmCPU::KvmIntRegInfo} {\bf kvmIntRegs}\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classArmKvmCPU_a610b9b2e17374a59cb14ab6e1b7c3dd0}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/kvm/\hyperlink{arm__cpu_8hh}{arm\_\-cpu.hh}\item 
cpu/kvm/\hyperlink{arm__cpu_8cc}{arm\_\-cpu.cc}\end{DoxyCompactItemize}
