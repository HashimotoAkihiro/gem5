\hypertarget{classSinic_1_1Device}{
\section{クラス Device}
\label{classSinic_1_1Device}\index{Sinic::Device@{Sinic::Device}}
}


{\ttfamily \#include $<$sinic.hh$>$}Deviceに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=11cm]{classSinic_1_1Device}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structSinic_1_1Device_1_1VirtualReg}{VirtualReg}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classSinic_1_1Device_ad54e71348f53dfb5444979e9bfaf3164}{recvPacket} (\hyperlink{classRefCountingPtr}{EthPacketPtr} packet)
\item 
void \hyperlink{classSinic_1_1Device_ac47b2c25cccfafe7e2c12673a1b3e793}{transferDone} ()
\item 
virtual \hyperlink{classEtherInt}{EtherInt} $\ast$ \hyperlink{classSinic_1_1Device_a10260c5a583c0894dcdcd1ced50a53ae}{getEthPort} (const std::string \&if\_\-name, int idx)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classSinic_1_1Device_a613ec7d5e1ec64f8d21fec78ae8e568e}{read} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classSinic_1_1Device_a4cefab464e72b5dd42c003a0a4341802}{write} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual void \hyperlink{classSinic_1_1Device_a8f020d3237536fe007fc488c4125c5d8}{drainResume} ()
\item 
void \hyperlink{classSinic_1_1Device_a65d0ce31d782d0d1233ce4a464e21fe3}{prepareIO} (int cpu, int index)
\item 
void \hyperlink{classSinic_1_1Device_a90e004f9ca30532075cace46234c6ad5}{prepareRead} (int cpu, int index)
\item 
void \hyperlink{classSinic_1_1Device_a8527de0a20c247f91f96abe895bf4448}{prepareWrite} (int cpu, int index)
\item 
virtual void \hyperlink{classSinic_1_1Device_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
virtual void \hyperlink{classSinic_1_1Device_a65880e61108132689a1bd769b9187fb7}{resetStats} ()
\item 
virtual void \hyperlink{classSinic_1_1Device_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classSinic_1_1Device_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\item 
\hyperlink{classSinic_1_1Device_a3e931e68104ea04933647b3c2e08097b}{Device} (const \hyperlink{classSinic_1_1Base_ae32fbee6dea75ffbb01b7d869c7bedad}{Params} $\ast$p)
\item 
\hyperlink{classSinic_1_1Device_a3b1601f6f775f47420713f755d1ef320}{$\sim$Device} ()
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82}{RxState} \{ \par
\hyperlink{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82ab702fffa03e4cec4b054f71cfe34ce7c}{rxIdle}, 
\hyperlink{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82acd42510cc5c902cc3b338fee8106b4ca}{rxFifoBlock}, 
\hyperlink{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82ad650f06241a5757f0fa65acae2960b1f}{rxBeginCopy}, 
\hyperlink{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82acc200faa35bf75419147de6b805d083b}{rxCopy}, 
\par
\hyperlink{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82a8fbf22d6f8cc55993cc2a09d07418446}{rxCopyDone}
 \}
\item 
enum \hyperlink{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6a}{TxState} \{ \par
\hyperlink{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6aa6ae23f58218fed48a3f17abba689fcb6}{txIdle}, 
\hyperlink{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6aaf6571d0685a78da76fe4116ae36afdc3}{txFifoBlock}, 
\hyperlink{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6aaf2c21c54301af068a37b641c220915c1}{txBeginCopy}, 
\hyperlink{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6aa76918a4583683f130898f157b820164c}{txCopy}, 
\par
\hyperlink{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6aa60ba4d6a047deb74d1eccb2904472127}{txCopyDone}
 \}
\item 
typedef \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{structSinic_1_1Device_1_1VirtualReg}{VirtualReg} $>$ \hyperlink{classSinic_1_1Device_aa30f329d058c1b4134f557c529c86ca2}{VirtualRegs}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ unsigned $>$ \hyperlink{classSinic_1_1Device_a825103ea4ae04062ca13fa65d29bcfc6}{VirtualList}
\item 
typedef \hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classSinic_1_1Device}{Device},\&Device::rxKick $>$ \hyperlink{classSinic_1_1Device_a1094ea52a2a9cb27d833549a0407932d}{RxKickEvent}
\item 
typedef \hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classSinic_1_1Device}{Device},\&Device::txKick $>$ \hyperlink{classSinic_1_1Device_ad902ad2446ba2b0506a150072f971da5}{TxKickEvent}
\item 
typedef \hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classSinic_1_1Device}{Device},\&Device::txEventTransmit $>$ \hyperlink{classSinic_1_1Device_a9a650a51d23bb10d0de3cb621d918e50}{TxEvent}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
uint8\_\-t \& \hyperlink{classSinic_1_1Device_ab9d3fc8abcb0bc9a41665d6311d64106}{regData8} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} daddr)
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \& \hyperlink{classSinic_1_1Device_af3697c3ddcc9030231a62c95ddcd193b}{regData32} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} daddr)
\item 
uint64\_\-t \& \hyperlink{classSinic_1_1Device_a107fa1384335bcf976734520e213a501}{regData64} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} daddr)
\item 
void \hyperlink{classSinic_1_1Device_ad20897c5c8bd47f5d4005989bead0e55}{reset} ()
\item 
void \hyperlink{classSinic_1_1Device_a5fa946a73db6f59c9819d457c991486a}{rxKick} ()
\item 
void \hyperlink{classSinic_1_1Device_ac5484e8debdd6a2d3cf4c2902b832a76}{txKick} ()
\item 
void \hyperlink{classSinic_1_1Device_af04463ca216d10ffa94db8463cee04c9}{transmit} ()
\item 
void \hyperlink{classSinic_1_1Device_a2b61c48d7a63b50007517c67e35dfd20}{txEventTransmit} ()
\item 
void \hyperlink{classSinic_1_1Device_afe787c5d7928546256f34b65f485be32}{txDump} () const 
\item 
void \hyperlink{classSinic_1_1Device_aa1b380dc961134ace0f88ee7743b32b6}{rxDump} () const 
\item 
bool \hyperlink{classSinic_1_1Device_a5bcec2e17f6aca766b063f7a92289bdb}{rxFilter} (const \hyperlink{classRefCountingPtr}{EthPacketPtr} \&packet)
\item 
void \hyperlink{classSinic_1_1Device_abac0082da5c2420162cd3d183fab4f1f}{changeConfig} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} newconfig)
\item 
void \hyperlink{classSinic_1_1Device_a8747db3299e3afcb225c4e64f725f453}{command} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} command)
\item 
void \hyperlink{classSinic_1_1Device_ae8fff6d9b2bdd860ce365599560f67e7}{rxDmaDone} ()
\item 
void \hyperlink{classSinic_1_1Device_a5204e0ceaa6484825f9506e447e072c6}{txDmaDone} ()
\item 
void \hyperlink{classSinic_1_1Device_ad1a6ea4f31e657c02d56bdf168fb988a}{devIntrPost} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} interrupts)
\item 
void \hyperlink{classSinic_1_1Device_af2e6de78cabe5fab3233fb1b29fb478b}{devIntrClear} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} interrupts=Regs::Intr\_\-All)
\item 
void \hyperlink{classSinic_1_1Device_a776f6f1cbea3e0200c28319eb0d5446b}{devIntrChangeMask} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} newmask)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
struct \{\\
\>\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_t} \hyperlink{classSinic_1_1Device_a4ce7377178b8c0ee57726e8a73c06e66}{Config}\\
\>\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_t} \hyperlink{classSinic_1_1Device_a04596aab9f96da6679ea03286f74b3df}{Command}\\
\>\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_t} \hyperlink{classSinic_1_1Device_a48050ef73aa0e6da5537fca47130d76f}{IntrStatus}\\
\>\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_t} \hyperlink{classSinic_1_1Device_aa3e3d884e5a8b959eeccc3660451c7ed}{IntrMask}\\
\>\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_t} \hyperlink{classSinic_1_1Device_a40cf84e9a58828b94d92f3f4af8e2132}{RxMaxCopy}\\
\>\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_t} \hyperlink{classSinic_1_1Device_a8dfcab9c852a1e3e564b4ccceb9a594d}{TxMaxCopy}\\
\>\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_t} \hyperlink{classSinic_1_1Device_a0a6cb3337e941db43aff26f90444592a}{ZeroCopySize}\\
\>\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_t} \hyperlink{classSinic_1_1Device_a93d85f8e9d6efa8d85cce98ef514c54d}{ZeroCopyMark}\\
\>\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_t} \hyperlink{classSinic_1_1Device_a8e55d9d438f57f1cf9bee803876daf7e}{VirtualCount}\\
\>\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_t} \hyperlink{classSinic_1_1Device_a29b4ff4ee34664ea46879c0fed891fe6}{RxMaxIntr}\\
\>\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_t} \hyperlink{classSinic_1_1Device_ad95eeec9a1e7f6804da0d44916333d3c}{RxFifoSize}\\
\>\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_t} \hyperlink{classSinic_1_1Device_a07afc60b5230368629f6b0eb9ab6c51a}{TxFifoSize}\\
\>\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_t} \hyperlink{classSinic_1_1Device_a4d0eb17fd55782f70d98e6b96ccd8d16}{RxFifoLow}\\
\>\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_t} \hyperlink{classSinic_1_1Device_a72783e023c789fe9ff7b3d526a202417}{TxFifoLow}\\
\>\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_t} \hyperlink{classSinic_1_1Device_a5f1b0015444b58705dd253c2e0aed9b4}{RxFifoHigh}\\
\>\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_t} \hyperlink{classSinic_1_1Device_ae282c8042fb1e67c966a0040eed2c37f}{TxFifoHigh}\\
\>uint64\_t \hyperlink{classSinic_1_1Device_a6c9104d7b097720d299cae2ffe977554}{RxData}\\
\>uint64\_t \hyperlink{classSinic_1_1Device_a3eeed0cb70c02a0da59c7a4c407dd6e9}{RxDone}\\
\>uint64\_t \hyperlink{classSinic_1_1Device_a49b873aef0e771896569f73b69ed5f6a}{RxWait}\\
\>uint64\_t \hyperlink{classSinic_1_1Device_a6f031a974796558748f14b7ba7f64985}{TxData}\\
\>uint64\_t \hyperlink{classSinic_1_1Device_ab0c6a1c886fdea04c1107ab914188fe7}{TxDone}\\
\>uint64\_t \hyperlink{classSinic_1_1Device_aee07d31d26bcedc3ec903158356f7d06}{TxWait}\\
\>uint64\_t \hyperlink{classSinic_1_1Device_acc1119b12c1f476a7aa533a975ac4249}{HwAddr}\\
\>uint64\_t \hyperlink{classSinic_1_1Device_a1d5b24603a5677cd3cf0a67f8c44d540}{RxStatus}\\
\} \hyperlink{classSinic_1_1Device_a1898630b26f531edc311e99e742572af}{regs}\\

\end{tabbing}\item 
\hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classSinic_1_1Device_a98e0c2747f2107c6f81f51e9ba3bdc8a}{rxUnique}
\item 
\hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classSinic_1_1Device_addcc8e87969e32011941cd144fe23c73}{txUnique}
\item 
\hyperlink{classstd_1_1vector}{VirtualRegs} \hyperlink{classSinic_1_1Device_acb438fcaae56ab29f35376e8b0726c23}{virtualRegs}
\item 
\hyperlink{classstd_1_1list}{VirtualList} \hyperlink{classSinic_1_1Device_a45202257b5522a1436d8130249ee0a0d}{rxList}
\item 
\hyperlink{classstd_1_1list}{VirtualList} \hyperlink{classSinic_1_1Device_afd33bf96a9045d1f90d0685ad3e33253}{rxBusy}
\item 
int \hyperlink{classSinic_1_1Device_a560efaee55571ea588551a80aadc6cda}{rxActive}
\item 
\hyperlink{classstd_1_1list}{VirtualList} \hyperlink{classSinic_1_1Device_a7010216dd085a0c2dac9d6b830a64f35}{txList}
\item 
int \hyperlink{classSinic_1_1Device_a508dbc989a9476f10e7622b054aac7e1}{rxBusyCount}
\item 
int \hyperlink{classSinic_1_1Device_a41d5a12c120010c50c75ea0dc2f01241}{rxMappedCount}
\item 
int \hyperlink{classSinic_1_1Device_a9e5a18ec7025db57fa6ff2f05a289804}{rxDirtyCount}
\item 
\hyperlink{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82}{RxState} \hyperlink{classSinic_1_1Device_a17c506ad3a705ec9dbd1762e6a80fbf5}{rxState}
\item 
\hyperlink{classPacketFifo}{PacketFifo} \hyperlink{classSinic_1_1Device_a45c9c6a3665bcd91e57ff35aa9089fa7}{rxFifo}
\item 
\hyperlink{classPacketFifo_a6905b6d8863a2eecd86b633802b68fda}{PacketFifo::iterator} \hyperlink{classSinic_1_1Device_aee345bc47c94b616b04d8f502dab1826}{rxFifoPtr}
\item 
bool \hyperlink{classSinic_1_1Device_a62b6a5f468811226da2581374919b1a5}{rxEmpty}
\item 
bool \hyperlink{classSinic_1_1Device_a1ef589f4a0a6d9baae11626a0d89b5ec}{rxLow}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classSinic_1_1Device_a4a609f84c6849bcfb6dee08329773fca}{rxDmaAddr}
\item 
uint8\_\-t $\ast$ \hyperlink{classSinic_1_1Device_ae917f4bc2a610fed06749a854fb89d14}{rxDmaData}
\item 
unsigned \hyperlink{classSinic_1_1Device_a0efc207ddfcff656cbe0237c3bc237c1}{rxDmaLen}
\item 
\hyperlink{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6a}{TxState} \hyperlink{classSinic_1_1Device_a12e3a80bef638cd15c067541b96a4756}{txState}
\item 
\hyperlink{classPacketFifo}{PacketFifo} \hyperlink{classSinic_1_1Device_ae699c324753236e0a59aa2465920eb46}{txFifo}
\item 
bool \hyperlink{classSinic_1_1Device_aa09cc8a4752916111328b7353e64f3bb}{txFull}
\item 
\hyperlink{classRefCountingPtr}{EthPacketPtr} \hyperlink{classSinic_1_1Device_a8d22e1a154942ff0d4ab9048e7e844bb}{txPacket}
\item 
int \hyperlink{classSinic_1_1Device_ac0d074adcc00053882737a0009c84adb}{txPacketOffset}
\item 
int \hyperlink{classSinic_1_1Device_a1e82240f06ef6f0c8d8c0bb1a141a600}{txPacketBytes}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classSinic_1_1Device_aef3a8dd866e8017fd7a675414596ec6b}{txDmaAddr}
\item 
uint8\_\-t $\ast$ \hyperlink{classSinic_1_1Device_af56464970a8957faf3a1d35026db6a12}{txDmaData}
\item 
int \hyperlink{classSinic_1_1Device_a5782be4cae30f9377ab0c645a9f65892}{txDmaLen}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classSinic_1_1Device_aa36d466a86f77d2c7afdc014e3a6f8b3}{rxKickTick}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classSinic_1_1Device_acfce4fae6fa03f94e3d91d71302fe349}{txKickTick}
\item 
\hyperlink{classEventWrapper}{TxEvent} \hyperlink{classSinic_1_1Device_a324fed072a29716c20a98a82927bd2a2}{txEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classSinic_1_1Device}{Device},\&Device::rxDmaDone $>$ \hyperlink{classSinic_1_1Device_a50d4f78a0a458835572bb101383bf692}{rxDmaEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classSinic_1_1Device}{Device},\&Device::txDmaDone $>$ \hyperlink{classSinic_1_1Device_a3d31afcc8e7130b3e43e5dc1a0ef0e37}{txDmaEvent}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classSinic_1_1Device_abff269bf1752a04839eb356b47d4348b}{dmaReadDelay}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classSinic_1_1Device_a632abfe8a89dfa1d944547874f1b4fe4}{dmaReadFactor}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classSinic_1_1Device_add556e09206ac9f4675d3e2da53339e8}{dmaWriteDelay}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classSinic_1_1Device_a396f950eb0d0a011cfa5790861e32608}{dmaWriteFactor}
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classSinic_1_1Device_aceabe9d2fb5f87ee602c22e0d0141479}{totalVnicDistance}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classSinic_1_1Device_a489a76c8b17d7dec4865d06b211218fb}{numVnicDistance}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classSinic_1_1Device_a55159ce061f8632637c330b0b101d370}{maxVnicDistance}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classSinic_1_1Device_a6846633bb8f156a544f88825a26a3090}{avgVnicDistance}
\item 
int \hyperlink{classSinic_1_1Device_a3eb6949618cb5ab7fcb963974eb980a0}{\_\-maxVnicDistance}
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classSinic_1_1Device_aeca94de76c2e5173eca0cd628c06cb43}{EventWrapper$<$ Device,\&Device::rxDmaDone $>$}
\item 
class \hyperlink{classSinic_1_1Device_af2d0621641d94343bd091391cd6cf46f}{EventWrapper$<$ Device,\&Device::txDmaDone $>$}
\item 
void \hyperlink{classSinic_1_1Device_a97dc465a9dffe1cb8fcb2775d67610ca}{RxKickEvent::process} ()
\item 
void \hyperlink{classSinic_1_1Device_ab1e1e9de6b0b4cbeee1a4c0bb61e07d9}{TxKickEvent::process} ()
\item 
void \hyperlink{classSinic_1_1Device_ac669bd618effa3395173bc2905568d54}{TxEvent::process} ()
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classSinic_1_1Device_a1094ea52a2a9cb27d833549a0407932d}{
\index{Sinic::Device@{Sinic::Device}!RxKickEvent@{RxKickEvent}}
\index{RxKickEvent@{RxKickEvent}!Sinic::Device@{Sinic::Device}}
\subsubsection[{RxKickEvent}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf EventWrapper}$<${\bf Device}, \&Device::rxKick$>$ {\bf RxKickEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a1094ea52a2a9cb27d833549a0407932d}
\hypertarget{classSinic_1_1Device_a9a650a51d23bb10d0de3cb621d918e50}{
\index{Sinic::Device@{Sinic::Device}!TxEvent@{TxEvent}}
\index{TxEvent@{TxEvent}!Sinic::Device@{Sinic::Device}}
\subsubsection[{TxEvent}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf EventWrapper}$<${\bf Device}, \&Device::txEventTransmit$>$ {\bf TxEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a9a650a51d23bb10d0de3cb621d918e50}
\hypertarget{classSinic_1_1Device_ad902ad2446ba2b0506a150072f971da5}{
\index{Sinic::Device@{Sinic::Device}!TxKickEvent@{TxKickEvent}}
\index{TxKickEvent@{TxKickEvent}!Sinic::Device@{Sinic::Device}}
\subsubsection[{TxKickEvent}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf EventWrapper}$<${\bf Device}, \&Device::txKick$>$ {\bf TxKickEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_ad902ad2446ba2b0506a150072f971da5}
\hypertarget{classSinic_1_1Device_a825103ea4ae04062ca13fa65d29bcfc6}{
\index{Sinic::Device@{Sinic::Device}!VirtualList@{VirtualList}}
\index{VirtualList@{VirtualList}!Sinic::Device@{Sinic::Device}}
\subsubsection[{VirtualList}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<$unsigned$>$ {\bf VirtualList}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a825103ea4ae04062ca13fa65d29bcfc6}
\hypertarget{classSinic_1_1Device_aa30f329d058c1b4134f557c529c86ca2}{
\index{Sinic::Device@{Sinic::Device}!VirtualRegs@{VirtualRegs}}
\index{VirtualRegs@{VirtualRegs}!Sinic::Device@{Sinic::Device}}
\subsubsection[{VirtualRegs}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::vector}$<${\bf VirtualReg}$>$ {\bf VirtualRegs}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_aa30f329d058c1b4134f557c529c86ca2}


\subsection{列挙型}
\hypertarget{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82}{
\index{Sinic::Device@{Sinic::Device}!RxState@{RxState}}
\index{RxState@{RxState}!Sinic::Device@{Sinic::Device}}
\subsubsection[{RxState}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf RxState}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82}
Receive State Machine States \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{rxIdle@{rxIdle}!Sinic::Device@{Sinic::Device}}\index{Sinic::Device@{Sinic::Device}!rxIdle@{rxIdle}}\item[{\em 
\hypertarget{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82ab702fffa03e4cec4b054f71cfe34ce7c}{
rxIdle}
\label{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82ab702fffa03e4cec4b054f71cfe34ce7c}
}]\index{rxFifoBlock@{rxFifoBlock}!Sinic::Device@{Sinic::Device}}\index{Sinic::Device@{Sinic::Device}!rxFifoBlock@{rxFifoBlock}}\item[{\em 
\hypertarget{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82acd42510cc5c902cc3b338fee8106b4ca}{
rxFifoBlock}
\label{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82acd42510cc5c902cc3b338fee8106b4ca}
}]\index{rxBeginCopy@{rxBeginCopy}!Sinic::Device@{Sinic::Device}}\index{Sinic::Device@{Sinic::Device}!rxBeginCopy@{rxBeginCopy}}\item[{\em 
\hypertarget{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82ad650f06241a5757f0fa65acae2960b1f}{
rxBeginCopy}
\label{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82ad650f06241a5757f0fa65acae2960b1f}
}]\index{rxCopy@{rxCopy}!Sinic::Device@{Sinic::Device}}\index{Sinic::Device@{Sinic::Device}!rxCopy@{rxCopy}}\item[{\em 
\hypertarget{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82acc200faa35bf75419147de6b805d083b}{
rxCopy}
\label{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82acc200faa35bf75419147de6b805d083b}
}]\index{rxCopyDone@{rxCopyDone}!Sinic::Device@{Sinic::Device}}\index{Sinic::Device@{Sinic::Device}!rxCopyDone@{rxCopyDone}}\item[{\em 
\hypertarget{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82a8fbf22d6f8cc55993cc2a09d07418446}{
rxCopyDone}
\label{classSinic_1_1Device_afa22e66eb5ea0daab0f0cd0360936f82a8fbf22d6f8cc55993cc2a09d07418446}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
92                  {
93         rxIdle,
94         rxFifoBlock,
95         rxBeginCopy,
96         rxCopy,
97         rxCopyDone
98     };
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6a}{
\index{Sinic::Device@{Sinic::Device}!TxState@{TxState}}
\index{TxState@{TxState}!Sinic::Device@{Sinic::Device}}
\subsubsection[{TxState}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf TxState}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6a}
Transmit State Machine states \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{txIdle@{txIdle}!Sinic::Device@{Sinic::Device}}\index{Sinic::Device@{Sinic::Device}!txIdle@{txIdle}}\item[{\em 
\hypertarget{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6aa6ae23f58218fed48a3f17abba689fcb6}{
txIdle}
\label{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6aa6ae23f58218fed48a3f17abba689fcb6}
}]\index{txFifoBlock@{txFifoBlock}!Sinic::Device@{Sinic::Device}}\index{Sinic::Device@{Sinic::Device}!txFifoBlock@{txFifoBlock}}\item[{\em 
\hypertarget{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6aaf6571d0685a78da76fe4116ae36afdc3}{
txFifoBlock}
\label{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6aaf6571d0685a78da76fe4116ae36afdc3}
}]\index{txBeginCopy@{txBeginCopy}!Sinic::Device@{Sinic::Device}}\index{Sinic::Device@{Sinic::Device}!txBeginCopy@{txBeginCopy}}\item[{\em 
\hypertarget{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6aaf2c21c54301af068a37b641c220915c1}{
txBeginCopy}
\label{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6aaf2c21c54301af068a37b641c220915c1}
}]\index{txCopy@{txCopy}!Sinic::Device@{Sinic::Device}}\index{Sinic::Device@{Sinic::Device}!txCopy@{txCopy}}\item[{\em 
\hypertarget{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6aa76918a4583683f130898f157b820164c}{
txCopy}
\label{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6aa76918a4583683f130898f157b820164c}
}]\index{txCopyDone@{txCopyDone}!Sinic::Device@{Sinic::Device}}\index{Sinic::Device@{Sinic::Device}!txCopyDone@{txCopyDone}}\item[{\em 
\hypertarget{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6aa60ba4d6a047deb74d1eccb2904472127}{
txCopyDone}
\label{classSinic_1_1Device_a96f29317c7f6628ea6a0c1bc5ab05d6aa60ba4d6a047deb74d1eccb2904472127}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
101                  {
102         txIdle,
103         txFifoBlock,
104         txBeginCopy,
105         txCopy,
106         txCopyDone
107     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classSinic_1_1Device_a3e931e68104ea04933647b3c2e08097b}{
\index{Sinic::Device@{Sinic::Device}!Device@{Device}}
\index{Device@{Device}!Sinic::Device@{Sinic::Device}}
\subsubsection[{Device}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Device} (const {\bf Params} $\ast$ {\em p})}}
\label{classSinic_1_1Device_a3e931e68104ea04933647b3c2e08097b}



\begin{DoxyCode}
88     : Base(p), rxUnique(0), txUnique(0),
89       virtualRegs(p->virtual_count < 1 ? 1 : p->virtual_count),
90       rxFifo(p->rx_fifo_size), txFifo(p->tx_fifo_size),
91       rxKickTick(0), txKickTick(0),
92       txEvent(this), rxDmaEvent(this), txDmaEvent(this),
93       dmaReadDelay(p->dma_read_delay), dmaReadFactor(p->dma_read_factor),
94       dmaWriteDelay(p->dma_write_delay), dmaWriteFactor(p->dma_write_factor)
95 {
96     interface = new Interface(name() + ".int0", this);
97     reset();
98 
99 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_a3b1601f6f775f47420713f755d1ef320}{
\index{Sinic::Device@{Sinic::Device}!$\sim$Device@{$\sim$Device}}
\index{$\sim$Device@{$\sim$Device}!Sinic::Device@{Sinic::Device}}
\subsubsection[{$\sim$Device}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf Device} ()}}
\label{classSinic_1_1Device_a3b1601f6f775f47420713f755d1ef320}



\begin{DoxyCode}
102 {}
\end{DoxyCode}


\subsection{関数}
\hypertarget{classSinic_1_1Device_abac0082da5c2420162cd3d183fab4f1f}{
\index{Sinic::Device@{Sinic::Device}!changeConfig@{changeConfig}}
\index{changeConfig@{changeConfig}!Sinic::Device@{Sinic::Device}}
\subsubsection[{changeConfig}]{\setlength{\rightskip}{0pt plus 5cm}void changeConfig ({\bf uint32\_\-t} {\em newconfig})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_abac0082da5c2420162cd3d183fab4f1f}
device configuration 


\begin{DoxyCode}
591 {
592     uint32_t changed = regs.Config ^ newconf;
593     if (!changed)
594         return;
595 
596     regs.Config = newconf;
597 
598     if ((changed & Regs::Config_IntEn)) {
599         cpuIntrEnable = regs.Config & Regs::Config_IntEn;
600         if (cpuIntrEnable) {
601             if (regs.IntrStatus & regs.IntrMask)
602                 cpuIntrPost(curTick());
603         } else {
604             cpuIntrClear();
605         }
606     }
607 
608     if ((changed & Regs::Config_TxEn)) {
609         txEnable = regs.Config & Regs::Config_TxEn;
610         if (txEnable)
611             txKick();
612     }
613 
614     if ((changed & Regs::Config_RxEn)) {
615         rxEnable = regs.Config & Regs::Config_RxEn;
616         if (rxEnable)
617             rxKick();
618     }
619 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_a8747db3299e3afcb225c4e64f725f453}{
\index{Sinic::Device@{Sinic::Device}!command@{command}}
\index{command@{command}!Sinic::Device@{Sinic::Device}}
\subsubsection[{command}]{\setlength{\rightskip}{0pt plus 5cm}void command ({\bf uint32\_\-t} {\em command})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a8747db3299e3afcb225c4e64f725f453}



\begin{DoxyCode}
623 {
624     if (command & Regs::Command_Intr)
625         devIntrPost(Regs::Intr_Soft);
626 
627     if (command & Regs::Command_Reset)
628         reset();
629 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_a776f6f1cbea3e0200c28319eb0d5446b}{
\index{Sinic::Device@{Sinic::Device}!devIntrChangeMask@{devIntrChangeMask}}
\index{devIntrChangeMask@{devIntrChangeMask}!Sinic::Device@{Sinic::Device}}
\subsubsection[{devIntrChangeMask}]{\setlength{\rightskip}{0pt plus 5cm}void devIntrChangeMask ({\bf uint32\_\-t} {\em newmask})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a776f6f1cbea3e0200c28319eb0d5446b}



\begin{DoxyCode}
486 {
487     if (regs.IntrMask == newmask)
488         return;
489 
490     regs.IntrMask = newmask;
491 
492     DPRINTF(EthernetIntr,
493             "interrupt mask changed: intStatus=%x intMask=%x masked=%x\n",
494             regs.IntrStatus, regs.IntrMask, regs.IntrStatus & regs.IntrMask);
495 
496     if (regs.IntrStatus & regs.IntrMask)
497         cpuIntrPost(curTick());
498     else
499         cpuIntrClear();
500 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_af2e6de78cabe5fab3233fb1b29fb478b}{
\index{Sinic::Device@{Sinic::Device}!devIntrClear@{devIntrClear}}
\index{devIntrClear@{devIntrClear}!Sinic::Device@{Sinic::Device}}
\subsubsection[{devIntrClear}]{\setlength{\rightskip}{0pt plus 5cm}void devIntrClear ({\bf uint32\_\-t} {\em interrupts} = {\ttfamily Regs::Intr\_\-All})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_af2e6de78cabe5fab3233fb1b29fb478b}



\begin{DoxyCode}
470 {
471     if ((interrupts & Regs::Intr_Res))
472         panic("Cannot clear a reserved interrupt");
473 
474     regs.IntrStatus &= ~interrupts;
475 
476     DPRINTF(EthernetIntr,
477             "interrupt cleared from intStatus: intr=%x status=%x mask=%x\n",
478             interrupts, regs.IntrStatus, regs.IntrMask);
479 
480     if (!(regs.IntrStatus & regs.IntrMask))
481         cpuIntrClear();
482 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_ad1a6ea4f31e657c02d56bdf168fb988a}{
\index{Sinic::Device@{Sinic::Device}!devIntrPost@{devIntrPost}}
\index{devIntrPost@{devIntrPost}!Sinic::Device@{Sinic::Device}}
\subsubsection[{devIntrPost}]{\setlength{\rightskip}{0pt plus 5cm}void devIntrPost ({\bf uint32\_\-t} {\em interrupts})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_ad1a6ea4f31e657c02d56bdf168fb988a}
Interrupt management 


\begin{DoxyCode}
434 {
435     if ((interrupts & Regs::Intr_Res))
436         panic("Cannot set a reserved interrupt");
437 
438     regs.IntrStatus |= interrupts;
439 
440     DPRINTF(EthernetIntr,
441             "interrupt written to intStatus: intr=%#x status=%#x mask=%#x\n",
442             interrupts, regs.IntrStatus, regs.IntrMask);
443 
444     interrupts = regs.IntrStatus & regs.IntrMask;
445 
446     // Intr_RxHigh is special, we only signal it if we've emptied the fifo
447     // and then filled it above the high watermark
448     if (rxEmpty)
449         rxEmpty = false;
450     else
451         interrupts &= ~Regs::Intr_RxHigh;
452 
453     // Intr_TxLow is special, we only signal it if we've filled up the fifo
454     // and then dropped below the low watermark
455     if (txFull)
456         txFull = false;
457     else
458         interrupts &= ~Regs::Intr_TxLow;
459 
460     if (interrupts) {
461         Tick when = curTick();
462         if ((interrupts & Regs::Intr_NoDelay) == 0)
463             when += intrDelay;
464         cpuIntrPost(when);
465     }
466 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_a8f020d3237536fe007fc488c4125c5d8}{
\index{Sinic::Device@{Sinic::Device}!drainResume@{drainResume}}
\index{drainResume@{drainResume}!Sinic::Device@{Sinic::Device}}
\subsubsection[{drainResume}]{\setlength{\rightskip}{0pt plus 5cm}void drainResume ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSinic_1_1Device_a8f020d3237536fe007fc488c4125c5d8}
Resume execution after a successful drain.

\begin{DoxyNote}{覚え書き}
This method is normally only called from the simulation scripts. 
\end{DoxyNote}


\hyperlink{classDrainable_a8f020d3237536fe007fc488c4125c5d8}{Drainable}を再定義しています。


\begin{DoxyCode}
1250 {
1251     Drainable::drainResume();
1252 
1253     // During drain we could have left the state machines in a waiting state and
1254     // they wouldn't get out until some other event occured to kick them.
1255     // This way they'll get out immediately
1256     txKick();
1257     rxKick();
1258 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_a10260c5a583c0894dcdcd1ced50a53ae}{
\index{Sinic::Device@{Sinic::Device}!getEthPort@{getEthPort}}
\index{getEthPort@{getEthPort}!Sinic::Device@{Sinic::Device}}
\subsubsection[{getEthPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EtherInt} $\ast$ getEthPort (const std::string \& {\em if\_\-name}, \/  int {\em idx})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSinic_1_1Device_a10260c5a583c0894dcdcd1ced50a53ae}
Additional function to return the \hyperlink{classPort}{Port} of a memory object. 

\hyperlink{classEtherDevice_ac1aa24c1f8c0f1ee8bdc3f3d3799f67c}{EtherDevice}を実装しています。


\begin{DoxyCode}
143 {
144     if (if_name == "interface") {
145         if (interface->getPeer())
146             panic("interface already connected to\n");
147 
148         return interface;
149     }
150     return NULL;
151 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_a65d0ce31d782d0d1233ce4a464e21fe3}{
\index{Sinic::Device@{Sinic::Device}!prepareIO@{prepareIO}}
\index{prepareIO@{prepareIO}!Sinic::Device@{Sinic::Device}}
\subsubsection[{prepareIO}]{\setlength{\rightskip}{0pt plus 5cm}void prepareIO (int {\em cpu}, \/  int {\em index})}}
\label{classSinic_1_1Device_a65d0ce31d782d0d1233ce4a464e21fe3}



\begin{DoxyCode}
156 {
157     int size = virtualRegs.size();
158     if (index > size)
159         panic("Trying to access a vnic that doesn't exist %d > %d\n",
160               index, size);
161 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_a90e004f9ca30532075cace46234c6ad5}{
\index{Sinic::Device@{Sinic::Device}!prepareRead@{prepareRead}}
\index{prepareRead@{prepareRead}!Sinic::Device@{Sinic::Device}}
\subsubsection[{prepareRead}]{\setlength{\rightskip}{0pt plus 5cm}void prepareRead (int {\em cpu}, \/  int {\em index})}}
\label{classSinic_1_1Device_a90e004f9ca30532075cace46234c6ad5}



\begin{DoxyCode}
169 {
170     using namespace Regs;
171     prepareIO(cpu, index);
172 
173     VirtualReg &vnic = virtualRegs[index];
174 
175     // update rx registers
176     uint64_t rxdone = vnic.RxDone;
177     rxdone = set_RxDone_Packets(rxdone, rxFifo.countPacketsAfter(rxFifoPtr));
178     rxdone = set_RxDone_Empty(rxdone, rxFifo.empty());
179     rxdone = set_RxDone_High(rxdone, rxFifo.size() > regs.RxFifoHigh);
180     rxdone = set_RxDone_NotHigh(rxdone, rxLow);
181     regs.RxData = vnic.RxData;
182     regs.RxDone = rxdone;
183     regs.RxWait = rxdone;
184 
185     // update tx regsiters
186     uint64_t txdone = vnic.TxDone;
187     txdone = set_TxDone_Packets(txdone, txFifo.packets());
188     txdone = set_TxDone_Full(txdone, txFifo.avail() < regs.TxMaxCopy);
189     txdone = set_TxDone_Low(txdone, txFifo.size() < regs.TxFifoLow);
190     regs.TxData = vnic.TxData;
191     regs.TxDone = txdone;
192     regs.TxWait = txdone;
193 
194     int head = 0xffff;
195 
196     if (!rxFifo.empty()) {
197         int vnic = rxFifo.begin()->priv;
198         if (vnic != -1 && virtualRegs[vnic].rxPacketOffset > 0)
199             head = vnic;
200     }
201 
202     regs.RxStatus = set_RxStatus_Head(regs.RxStatus, head);
203     regs.RxStatus = set_RxStatus_Busy(regs.RxStatus, rxBusyCount);
204     regs.RxStatus = set_RxStatus_Mapped(regs.RxStatus, rxMappedCount);
205     regs.RxStatus = set_RxStatus_Dirty(regs.RxStatus, rxDirtyCount);
206 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_a8527de0a20c247f91f96abe895bf4448}{
\index{Sinic::Device@{Sinic::Device}!prepareWrite@{prepareWrite}}
\index{prepareWrite@{prepareWrite}!Sinic::Device@{Sinic::Device}}
\subsubsection[{prepareWrite}]{\setlength{\rightskip}{0pt plus 5cm}void prepareWrite (int {\em cpu}, \/  int {\em index})}}
\label{classSinic_1_1Device_a8527de0a20c247f91f96abe895bf4448}



\begin{DoxyCode}
210 {
211     prepareIO(cpu, index);
212 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_a613ec7d5e1ec64f8d21fec78ae8e568e}{
\index{Sinic::Device@{Sinic::Device}!read@{read}}
\index{read@{read}!Sinic::Device@{Sinic::Device}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} read ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSinic_1_1Device_a613ec7d5e1ec64f8d21fec78ae8e568e}
Memory \hyperlink{classSinic_1_1Interface}{Interface}

I/O read of device register 

\hyperlink{classPioDevice_a842312590432036092c422c87a442358}{PioDevice}を実装しています。


\begin{DoxyCode}
219 {
220     assert(config.command & PCI_CMD_MSE);
221     assert(pkt->getAddr() >= BARAddrs[0] && pkt->getSize() < BARSize[0]);
222 
223     int cpu = pkt->req->contextId();
224     Addr daddr = pkt->getAddr() - BARAddrs[0];
225     Addr index = daddr >> Regs::VirtualShift;
226     Addr raddr = daddr & Regs::VirtualMask;
227 
228     pkt->allocate();
229 
230     if (!regValid(raddr))
231         panic("invalid register: cpu=%d vnic=%d da=%#x pa=%#x size=%d",
232               cpu, index, daddr, pkt->getAddr(), pkt->getSize());
233 
234     const Regs::Info &info = regInfo(raddr);
235     if (!info.read)
236         panic("read %s (write only): "
237               "cpu=%d vnic=%d da=%#x pa=%#x size=%d",
238               info.name, cpu, index, daddr, pkt->getAddr(), pkt->getSize());
239 
240         panic("read %s (invalid size): "
241               "cpu=%d vnic=%d da=%#x pa=%#x size=%d",
242               info.name, cpu, index, daddr, pkt->getAddr(), pkt->getSize());
243 
244     prepareRead(cpu, index);
245 
246     uint64_t value M5_VAR_USED = 0;
247     if (pkt->getSize() == 4) {
248         uint32_t reg = regData32(raddr);
249         pkt->set(reg);
250         value = reg;
251     }
252 
253     if (pkt->getSize() == 8) {
254         uint64_t reg = regData64(raddr);
255         pkt->set(reg);
256         value = reg;
257     }
258 
259     DPRINTF(EthernetPIO,
260             "read %s: cpu=%d vnic=%d da=%#x pa=%#x size=%d val=%#x\n",
261             info.name, cpu, index, daddr, pkt->getAddr(), pkt->getSize(), value);
      
262 
263     // reading the interrupt status register has the side effect of
264     // clearing it
265     if (raddr == Regs::IntrStatus)
266         devIntrClear();
267 
268     return pioDelay;
269 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_ad54e71348f53dfb5444979e9bfaf3164}{
\index{Sinic::Device@{Sinic::Device}!recvPacket@{recvPacket}}
\index{recvPacket@{recvPacket}!Sinic::Device@{Sinic::Device}}
\subsubsection[{recvPacket}]{\setlength{\rightskip}{0pt plus 5cm}bool recvPacket ({\bf EthPacketPtr} {\em packet})}}
\label{classSinic_1_1Device_ad54e71348f53dfb5444979e9bfaf3164}
device ethernet interface 


\begin{DoxyCode}
1212 {
1213     rxBytes += packet->length;
1214     rxPackets++;
1215 
1216     DPRINTF(Ethernet, "Receiving packet from wire, rxFifo Available is %d\n",
1217             rxFifo.avail());
1218 
1219     if (!rxEnable) {
1220         DPRINTF(Ethernet, "receive disabled...packet dropped\n");
1221         return true;
1222     }
1223 
1224     if (rxFilter(packet)) {
1225         DPRINTF(Ethernet, "packet filtered...dropped\n");
1226         return true;
1227     }
1228 
1229     if (rxFifo.size() >= regs.RxFifoHigh)
1230         devIntrPost(Regs::Intr_RxHigh);
1231 
1232     if (!rxFifo.push(packet)) {
1233         DPRINTF(Ethernet,
1234                 "packet will not fit in receive buffer...packet dropped\n");
1235         return false;
1236     }
1237 
1238     // If we were at the last element, back up one ot go to the new
1239     // last element of the list.
1240     if (rxFifoPtr == rxFifo.end())
1241         --rxFifoPtr;
1242 
1243     devIntrPost(Regs::Intr_RxPacket);
1244     rxKick();
1245     return true;
1246 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_af3697c3ddcc9030231a62c95ddcd193b}{
\index{Sinic::Device@{Sinic::Device}!regData32@{regData32}}
\index{regData32@{regData32}!Sinic::Device@{Sinic::Device}}
\subsubsection[{regData32}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t}\& regData32 ({\bf Addr} {\em daddr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classSinic_1_1Device_af3697c3ddcc9030231a62c95ddcd193b}



\begin{DoxyCode}
171 { return *(uint32_t *)&regData8(daddr); }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_a107fa1384335bcf976734520e213a501}{
\index{Sinic::Device@{Sinic::Device}!regData64@{regData64}}
\index{regData64@{regData64}!Sinic::Device@{Sinic::Device}}
\subsubsection[{regData64}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t\& regData64 ({\bf Addr} {\em daddr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classSinic_1_1Device_a107fa1384335bcf976734520e213a501}



\begin{DoxyCode}
172 { return *(uint64_t *)&regData8(daddr); }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_ab9d3fc8abcb0bc9a41665d6311d64106}{
\index{Sinic::Device@{Sinic::Device}!regData8@{regData8}}
\index{regData8@{regData8}!Sinic::Device@{Sinic::Device}}
\subsubsection[{regData8}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t\& regData8 ({\bf Addr} {\em daddr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classSinic_1_1Device_ab9d3fc8abcb0bc9a41665d6311d64106}



\begin{DoxyCode}
170 { return *((uint8_t *)&regs + daddr); }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{Sinic::Device@{Sinic::Device}!regStats@{regStats}}
\index{regStats@{regStats}!Sinic::Device@{Sinic::Device}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSinic_1_1Device_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} statistics for this object. 

\hyperlink{classEtherDevice_a4dc637449366fcdfc4e764cdf12d9b11}{EtherDevice}を再定義しています。


\begin{DoxyCode}
106 {
107     Base::regStats();
108 
109     _maxVnicDistance = 0;
110 
111     maxVnicDistance
112         .name(name() + ".maxVnicDistance")
113         .desc("maximum vnic distance")
114         ;
115 
116     totalVnicDistance
117         .name(name() + ".totalVnicDistance")
118         .desc("total vnic distance")
119         ;
120     numVnicDistance
121         .name(name() + ".numVnicDistance")
122         .desc("number of vnic distance measurements")
123         ;
124 
125     avgVnicDistance
126         .name(name() + ".avgVnicDistance")
127         .desc("average vnic distance")
128         ;
129 
130     avgVnicDistance = totalVnicDistance / numVnicDistance;
131 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_ad20897c5c8bd47f5d4005989bead0e55}{
\index{Sinic::Device@{Sinic::Device}!reset@{reset}}
\index{reset@{reset}!Sinic::Device@{Sinic::Device}}
\subsubsection[{reset}]{\setlength{\rightskip}{0pt plus 5cm}void reset ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_ad20897c5c8bd47f5d4005989bead0e55}



\begin{DoxyCode}
633 {
634     using namespace Regs;
635 
636     memset(&regs, 0, sizeof(regs));
637 
638     regs.Config = 0;
639     if (params()->rx_thread)
640         regs.Config |= Config_RxThread;
641     if (params()->tx_thread)
642         regs.Config |= Config_TxThread;
643     if (params()->rss)
644         regs.Config |= Config_RSS;
645     if (params()->zero_copy)
646         regs.Config |= Config_ZeroCopy;
647     if (params()->delay_copy)
648         regs.Config |= Config_DelayCopy;
649     if (params()->virtual_addr)
650         regs.Config |= Config_Vaddr;
651 
652     if (params()->delay_copy && params()->zero_copy)
653         panic("Can't delay copy and zero copy");
654 
655     regs.IntrMask = Intr_Soft | Intr_RxHigh | Intr_RxPacket | Intr_TxLow;
656     regs.RxMaxCopy = params()->rx_max_copy;
657     regs.TxMaxCopy = params()->tx_max_copy;
658     regs.ZeroCopySize = params()->zero_copy_size;
659     regs.ZeroCopyMark = params()->zero_copy_threshold;
660     regs.VirtualCount = params()->virtual_count;
661     regs.RxMaxIntr = params()->rx_max_intr;
662     regs.RxFifoSize = params()->rx_fifo_size;
663     regs.TxFifoSize = params()->tx_fifo_size;
664     regs.RxFifoLow = params()->rx_fifo_low_mark;
665     regs.TxFifoLow = params()->tx_fifo_threshold;
666     regs.RxFifoHigh = params()->rx_fifo_threshold;
667     regs.TxFifoHigh = params()->tx_fifo_high_mark;
668     regs.HwAddr = params()->hardware_address;
669 
670     if (regs.RxMaxCopy < regs.ZeroCopyMark)
671         panic("Must be able to copy at least as many bytes as the threshold");
672 
673     if (regs.ZeroCopySize >= regs.ZeroCopyMark)
674         panic("The number of bytes to copy must be less than the threshold");
675 
676     rxList.clear();
677     rxBusy.clear();
678     rxActive = -1;
679     txList.clear();
680     rxBusyCount = 0;
681     rxDirtyCount = 0;
682     rxMappedCount = 0;
683 
684     rxState = rxIdle;
685     txState = txIdle;
686 
687     rxFifo.clear();
688     rxFifoPtr = rxFifo.end();
689     txFifo.clear();
690     rxEmpty = false;
691     rxLow = true;
692     txFull = false;
693 
694     int size = virtualRegs.size();
695     virtualRegs.clear();
696     virtualRegs.resize(size);
697     for (int i = 0; i < size; ++i)
698         virtualRegs[i].rxIndex = rxFifo.end();
699 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_a65880e61108132689a1bd769b9187fb7}{
\index{Sinic::Device@{Sinic::Device}!resetStats@{resetStats}}
\index{resetStats@{resetStats}!Sinic::Device@{Sinic::Device}}
\subsubsection[{resetStats}]{\setlength{\rightskip}{0pt plus 5cm}void resetStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSinic_1_1Device_a65880e61108132689a1bd769b9187fb7}
Reset statistics associated with this object. 

\hyperlink{classSimObject_a65880e61108132689a1bd769b9187fb7}{SimObject}を再定義しています。


\begin{DoxyCode}
135 {
136     Base::resetStats();
137 
138     _maxVnicDistance = 0;
139 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_ae8fff6d9b2bdd860ce365599560f67e7}{
\index{Sinic::Device@{Sinic::Device}!rxDmaDone@{rxDmaDone}}
\index{rxDmaDone@{rxDmaDone}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxDmaDone}]{\setlength{\rightskip}{0pt plus 5cm}void rxDmaDone ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_ae8fff6d9b2bdd860ce365599560f67e7}
DMA parameters 


\begin{DoxyCode}
703 {
704     assert(rxState == rxCopy);
705     rxState = rxCopyDone;
706     DPRINTF(EthernetDMA, "end rx dma write paddr=%#x len=%d\n",
707             rxDmaAddr, rxDmaLen);
708     DDUMP(EthernetData, rxDmaData, rxDmaLen);
709 
710     // If the transmit state machine  has a pending DMA, let it go first
711     if (txState == txBeginCopy)
712         txKick();
713 
714     rxKick();
715 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_aa1b380dc961134ace0f88ee7743b32b6}{
\index{Sinic::Device@{Sinic::Device}!rxDump@{rxDump}}
\index{rxDump@{rxDump}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxDump}]{\setlength{\rightskip}{0pt plus 5cm}void rxDump () const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_aa1b380dc961134ace0f88ee7743b32b6}
\hypertarget{classSinic_1_1Device_a5bcec2e17f6aca766b063f7a92289bdb}{
\index{Sinic::Device@{Sinic::Device}!rxFilter@{rxFilter}}
\index{rxFilter@{rxFilter}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxFilter}]{\setlength{\rightskip}{0pt plus 5cm}bool rxFilter (const {\bf EthPacketPtr} \& {\em packet})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a5bcec2e17f6aca766b063f7a92289bdb}
receive address filter 


\begin{DoxyCode}
1167 {
1168     if (!Regs::get_Config_Filter(regs.Config))
1169         return false;
1170 
1171     panic("receive filter not implemented\n");
1172     bool drop = true;
1173 
1174 #if 0
1175     string type;
1176 
1177     EthHdr *eth = packet->eth();
1178     if (eth->unicast()) {
1179         // If we're accepting all unicast addresses
1180         if (acceptUnicast)
1181             drop = false;
1182 
1183         // If we make a perfect match
1184         if (acceptPerfect && params->eaddr == eth.dst())
1185             drop = false;
1186 
1187         if (acceptArp && eth->type() == ETH_TYPE_ARP)
1188             drop = false;
1189 
1190     } else if (eth->broadcast()) {
1191         // if we're accepting broadcasts
1192         if (acceptBroadcast)
1193             drop = false;
1194 
1195     } else if (eth->multicast()) {
1196         // if we're accepting all multicasts
1197         if (acceptMulticast)
1198             drop = false;
1199 
1200     }
1201 
1202     if (drop) {
1203         DPRINTF(Ethernet, "rxFilter drop\n");
1204         DDUMP(EthernetData, packet->data, packet->length);
1205     }
1206 #endif
1207     return drop;
1208 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_a5fa946a73db6f59c9819d457c991486a}{
\index{Sinic::Device@{Sinic::Device}!rxKick@{rxKick}}
\index{rxKick@{rxKick}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxKick}]{\setlength{\rightskip}{0pt plus 5cm}void rxKick ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a5fa946a73db6f59c9819d457c991486a}


\begin{Desc}
\item[\hyperlink{todo__todo000071}{TODO}]do we want to schedule a future kick? \end{Desc}



\begin{DoxyCode}
719 {
720     VirtualReg *vnic = NULL;
721 
722     DPRINTF(EthernetSM, "rxKick: rxState=%s (rxFifo.size=%d)\n",
723             RxStateStrings[rxState], rxFifo.size());
724 
725     if (rxKickTick > curTick()) {
726         DPRINTF(EthernetSM, "rxKick: exiting, can't run till %d\n",
727                 rxKickTick);
728         return;
729     }
730 
731   next:
732     rxFifo.check();
733     if (rxState == rxIdle)
734         goto exit;
735 
736     if (rxActive == -1) {
737         if (rxState != rxFifoBlock)
738             panic("no active vnic while in state %s", RxStateStrings[rxState]);
739 
740         DPRINTF(EthernetSM, "processing rxState=%s\n",
741                 RxStateStrings[rxState]);
742     } else {
743         vnic = &virtualRegs[rxActive];
744         DPRINTF(EthernetSM,
745                 "processing rxState=%s for vnic %d (rxunique %d)\n",
746                 RxStateStrings[rxState], rxActive, vnic->rxUnique);
747     }
748 
749     switch (rxState) {
750       case rxFifoBlock:
751         if (DTRACE(EthernetSM)) {
752             PacketFifo::iterator end = rxFifo.end();
753             int size = virtualRegs.size();
754             for (int i = 0; i < size; ++i) {
755                 VirtualReg *vn = &virtualRegs[i];
756                 bool busy = Regs::get_RxDone_Busy(vn->RxDone);
757                 if (vn->rxIndex != end) {
758 #ifndef NDEBUG
759                     bool dirty = vn->rxPacketOffset > 0;
760                     const char *status;
761 
762                     if (busy && dirty)
763                         status = "busy,dirty";
764                     else if (busy)
765                         status = "busy";
766                     else if (dirty)
767                         status = "dirty";
768                     else
769                         status = "mapped";
770 
771                     DPRINTF(EthernetSM,
772                             "vnic %d %s (rxunique %d), packet %d, slack %d\n",
773                             i, status, vn->rxUnique,
774                             rxFifo.countPacketsBefore(vn->rxIndex),
775                             vn->rxIndex->slack);
776 #endif
777                 } else if (busy) {
778                     DPRINTF(EthernetSM, "vnic %d unmapped (rxunique %d)\n",
779                             i, vn->rxUnique);
780                 }
781             }
782         }
783 
784         if (!rxBusy.empty()) {
785             rxActive = rxBusy.front();
786             rxBusy.pop_front();
787             vnic = &virtualRegs[rxActive];
788 
789             if (vnic->rxIndex == rxFifo.end())
790                 panic("continuing vnic without packet\n");
791 
792             DPRINTF(EthernetSM,
793                     "continue processing for vnic %d (rxunique %d)\n",
794                     rxActive, vnic->rxUnique);
795 
796             rxState = rxBeginCopy;
797 
798             int vnic_distance = rxFifo.countPacketsBefore(vnic->rxIndex);
799             totalVnicDistance += vnic_distance;
800             numVnicDistance += 1;
801             if (vnic_distance > _maxVnicDistance) {
802                 maxVnicDistance = vnic_distance;
803                 _maxVnicDistance = vnic_distance;
804             }
805 
806             break;
807         }
808 
809         if (rxFifoPtr == rxFifo.end()) {
810             DPRINTF(EthernetSM, "receive waiting for data.  Nothing to do.\n");
811             goto exit;
812         }
813 
814         if (rxList.empty())
815             panic("Not idle, but nothing to do!");
816 
817         assert(!rxFifo.empty());
818 
819         rxActive = rxList.front();
820         rxList.pop_front();
821         vnic = &virtualRegs[rxActive];
822 
823         DPRINTF(EthernetSM,
824                 "processing new packet for vnic %d (rxunique %d)\n",
825                 rxActive, vnic->rxUnique);
826 
827         // Grab a new packet from the fifo.
828         vnic->rxIndex = rxFifoPtr++;
829         vnic->rxIndex->priv = rxActive;
830         vnic->rxPacketOffset = 0;
831         vnic->rxPacketBytes = vnic->rxIndex->packet->length;
832         assert(vnic->rxPacketBytes);
833         rxMappedCount++;
834 
835         vnic->rxDoneData = 0;
836         /* scope for variables */ {
837             IpPtr ip(vnic->rxIndex->packet);
838             if (ip) {
839                 DPRINTF(Ethernet, "ID is %d\n", ip->id());
840                 vnic->rxDoneData |= Regs::RxDone_IpPacket;
841                 rxIpChecksums++;
842                 if (cksum(ip) != 0) {
843                     DPRINTF(EthernetCksum, "Rx IP Checksum Error\n");
844                     vnic->rxDoneData |= Regs::RxDone_IpError;
845                 }
846                 TcpPtr tcp(ip);
847                 UdpPtr udp(ip);
848                 if (tcp) {
849                     DPRINTF(Ethernet,
850                             "Src Port=%d, Dest Port=%d, Seq=%d, Ack=%d\n",
851                             tcp->sport(), tcp->dport(), tcp->seq(),
852                             tcp->ack());
853                     vnic->rxDoneData |= Regs::RxDone_TcpPacket;
854                     rxTcpChecksums++;
855                     if (cksum(tcp) != 0) {
856                         DPRINTF(EthernetCksum, "Rx TCP Checksum Error\n");
857                         vnic->rxDoneData |= Regs::RxDone_TcpError;
858                     }
859                 } else if (udp) {
860                     vnic->rxDoneData |= Regs::RxDone_UdpPacket;
861                     rxUdpChecksums++;
862                     if (cksum(udp) != 0) {
863                         DPRINTF(EthernetCksum, "Rx UDP Checksum Error\n");
864                         vnic->rxDoneData |= Regs::RxDone_UdpError;
865                     }
866                 }
867             }
868         }
869         rxState = rxBeginCopy;
870         break;
871 
872       case rxBeginCopy:
873         if (dmaPending() || getDrainState() != Drainable::Running)
874             goto exit;
875 
876         rxDmaAddr = params()->platform->pciToDma(
877                 Regs::get_RxData_Addr(vnic->RxData));
878         rxDmaLen = min<unsigned>(Regs::get_RxData_Len(vnic->RxData),
879                                  vnic->rxPacketBytes);
880 
881         /*
882          * if we're doing zero/delay copy and we're below the fifo
883          * threshold, see if we should try to do the zero/defer copy
884          */
885         if ((Regs::get_Config_ZeroCopy(regs.Config) ||
886              Regs::get_Config_DelayCopy(regs.Config)) &&
887             !Regs::get_RxData_NoDelay(vnic->RxData) && rxLow) {
888             if (rxDmaLen > regs.ZeroCopyMark)
889                 rxDmaLen = regs.ZeroCopySize;
890         }
891         rxDmaData = vnic->rxIndex->packet->data + vnic->rxPacketOffset;
892         rxState = rxCopy;
893         if (rxDmaAddr == 1LL) {
894             rxState = rxCopyDone;
895             break;
896         }
897 
898         dmaWrite(rxDmaAddr, rxDmaLen, &rxDmaEvent, rxDmaData);
899         break;
900 
901       case rxCopy:
902         DPRINTF(EthernetSM, "receive machine still copying\n");
903         goto exit;
904 
905       case rxCopyDone:
906         vnic->RxDone = vnic->rxDoneData;
907         vnic->RxDone |= Regs::RxDone_Complete;
908         rxBusyCount--;
909 
910         if (vnic->rxPacketBytes == rxDmaLen) {
911             if (vnic->rxPacketOffset)
912                 rxDirtyCount--;
913 
914             // Packet is complete.  Indicate how many bytes were copied
915             vnic->RxDone = Regs::set_RxDone_CopyLen(vnic->RxDone, rxDmaLen);
916 
917             DPRINTF(EthernetSM,
918                     "rxKick: packet complete on vnic %d (rxunique %d)\n",
919                     rxActive, vnic->rxUnique);
920             rxFifo.remove(vnic->rxIndex);
921             vnic->rxIndex = rxFifo.end();
922             rxMappedCount--;
923         } else {
924             if (!vnic->rxPacketOffset)
925                 rxDirtyCount++;
926 
927             vnic->rxPacketBytes -= rxDmaLen;
928             vnic->rxPacketOffset += rxDmaLen;
929             vnic->RxDone |= Regs::RxDone_More;
930             vnic->RxDone = Regs::set_RxDone_CopyLen(vnic->RxDone,
931                                                     vnic->rxPacketBytes);
932             DPRINTF(EthernetSM,
933                     "rxKick: packet not complete on vnic %d (rxunique %d): "
934                     "%d bytes left\n",
935                     rxActive, vnic->rxUnique, vnic->rxPacketBytes);
936         }
937 
938         rxActive = -1;
939         rxState = rxBusy.empty() && rxList.empty() ? rxIdle : rxFifoBlock;
940 
941         if (rxFifo.empty()) {
942             devIntrPost(Regs::Intr_RxEmpty);
943             rxEmpty = true;
944         }
945 
946         if (rxFifo.size() < regs.RxFifoLow)
947             rxLow = true;
948 
949         if (rxFifo.size() > regs.RxFifoHigh)
950             rxLow = false;
951 
952         devIntrPost(Regs::Intr_RxDMA);
953         break;
954 
955       default:
956         panic("Invalid rxState!");
957     }
958 
959     DPRINTF(EthernetSM, "entering next rxState=%s\n",
960             RxStateStrings[rxState]);
961 
962     goto next;
963 
964   exit:
968     DPRINTF(EthernetSM, "rx state machine exited rxState=%s\n",
969             RxStateStrings[rxState]);
970 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_a53e036786d17361be4c7320d39c99b84}{
\index{Sinic::Device@{Sinic::Device}!serialize@{serialize}}
\index{serialize@{serialize}!Sinic::Device@{Sinic::Device}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSinic_1_1Device_a53e036786d17361be4c7320d39c99b84}
Serialization stuff 

\hyperlink{classSinic_1_1Base_a53e036786d17361be4c7320d39c99b84}{Base}を再定義しています。


\begin{DoxyCode}
1309 {
1310     int count;
1311 
1312     // Serialize the PciDevice base class
1313     Base::serialize(os);
1314 
1315     if (rxState == rxCopy)
1316         panic("can't serialize with an in flight dma request rxState=%s",
1317               RxStateStrings[rxState]);
1318 
1319     if (txState == txCopy)
1320         panic("can't serialize with an in flight dma request txState=%s",
1321               TxStateStrings[txState]);
1322 
1323     /*
1324      * Serialize the device registers that could be modified by the OS.
1325      */
1326     SERIALIZE_SCALAR(regs.Config);
1327     SERIALIZE_SCALAR(regs.IntrStatus);
1328     SERIALIZE_SCALAR(regs.IntrMask);
1329     SERIALIZE_SCALAR(regs.RxData);
1330     SERIALIZE_SCALAR(regs.TxData);
1331 
1332     /*
1333      * Serialize the virtual nic state
1334      */
1335     int virtualRegsSize = virtualRegs.size();
1336     SERIALIZE_SCALAR(virtualRegsSize);
1337     for (int i = 0; i < virtualRegsSize; ++i) {
1338         VirtualReg *vnic = &virtualRegs[i];
1339 
1340         std::string reg = csprintf("vnic%d", i);
1341         paramOut(os, reg + ".RxData", vnic->RxData);
1342         paramOut(os, reg + ".RxDone", vnic->RxDone);
1343         paramOut(os, reg + ".TxData", vnic->TxData);
1344         paramOut(os, reg + ".TxDone", vnic->TxDone);
1345 
1346         bool rxPacketExists = vnic->rxIndex != rxFifo.end();
1347         paramOut(os, reg + ".rxPacketExists", rxPacketExists);
1348         if (rxPacketExists) {
1349             int rxPacket = 0;
1350             PacketFifo::iterator i = rxFifo.begin();
1351             while (i != vnic->rxIndex) {
1352                 assert(i != rxFifo.end());
1353                 ++i;
1354                 ++rxPacket;
1355             }
1356 
1357             paramOut(os, reg + ".rxPacket", rxPacket);
1358             paramOut(os, reg + ".rxPacketOffset", vnic->rxPacketOffset);
1359             paramOut(os, reg + ".rxPacketBytes", vnic->rxPacketBytes);
1360         }
1361         paramOut(os, reg + ".rxDoneData", vnic->rxDoneData);
1362     }
1363 
1364     int rxFifoPtr = -1;
1365     if (this->rxFifoPtr != rxFifo.end())
1366         rxFifoPtr = rxFifo.countPacketsBefore(this->rxFifoPtr);
1367     SERIALIZE_SCALAR(rxFifoPtr);
1368 
1369     SERIALIZE_SCALAR(rxActive);
1370     SERIALIZE_SCALAR(rxBusyCount);
1371     SERIALIZE_SCALAR(rxDirtyCount);
1372     SERIALIZE_SCALAR(rxMappedCount);
1373 
1374     VirtualList::iterator i, end;
1375     for (count = 0, i = rxList.begin(), end = rxList.end(); i != end; ++i)
1376         paramOut(os, csprintf("rxList%d", count++), *i);
1377     int rxListSize = count;
1378     SERIALIZE_SCALAR(rxListSize);
1379 
1380     for (count = 0, i = rxBusy.begin(), end = rxBusy.end(); i != end; ++i)
1381         paramOut(os, csprintf("rxBusy%d", count++), *i);
1382     int rxBusySize = count;
1383     SERIALIZE_SCALAR(rxBusySize);
1384 
1385     for (count = 0, i = txList.begin(), end = txList.end(); i != end; ++i)
1386         paramOut(os, csprintf("txList%d", count++), *i);
1387     int txListSize = count;
1388     SERIALIZE_SCALAR(txListSize);
1389 
1390     /*
1391      * Serialize rx state machine
1392      */
1393     int rxState = this->rxState;
1394     SERIALIZE_SCALAR(rxState);
1395     SERIALIZE_SCALAR(rxEmpty);
1396     SERIALIZE_SCALAR(rxLow);
1397     rxFifo.serialize("rxFifo", os);
1398 
1399     /*
1400      * Serialize tx state machine
1401      */
1402     int txState = this->txState;
1403     SERIALIZE_SCALAR(txState);
1404     SERIALIZE_SCALAR(txFull);
1405     txFifo.serialize("txFifo", os);
1406     bool txPacketExists = txPacket;
1407     SERIALIZE_SCALAR(txPacketExists);
1408     if (txPacketExists) {
1409         txPacket->serialize("txPacket", os);
1410         SERIALIZE_SCALAR(txPacketOffset);
1411         SERIALIZE_SCALAR(txPacketBytes);
1412     }
1413 
1414     /*
1415      * If there's a pending transmit, store the time so we can
1416      * reschedule it later
1417      */
1418     Tick transmitTick = txEvent.scheduled() ? txEvent.when() - curTick() : 0;
1419     SERIALIZE_SCALAR(transmitTick);
1420 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_ac47b2c25cccfafe7e2c12673a1b3e793}{
\index{Sinic::Device@{Sinic::Device}!transferDone@{transferDone}}
\index{transferDone@{transferDone}!Sinic::Device@{Sinic::Device}}
\subsubsection[{transferDone}]{\setlength{\rightskip}{0pt plus 5cm}void transferDone ()}}
\label{classSinic_1_1Device_ac47b2c25cccfafe7e2c12673a1b3e793}



\begin{DoxyCode}
1154 {
1155     if (txFifo.empty()) {
1156         DPRINTF(Ethernet, "transfer complete: txFifo empty...nothing to do\n");
1157         return;
1158     }
1159 
1160     DPRINTF(Ethernet, "transfer complete: data in txFifo...schedule xmit\n");
1161 
1162     reschedule(txEvent, clockEdge(Cycles(1)), true);
1163 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_af04463ca216d10ffa94db8463cee04c9}{
\index{Sinic::Device@{Sinic::Device}!transmit@{transmit}}
\index{transmit@{transmit}!Sinic::Device@{Sinic::Device}}
\subsubsection[{transmit}]{\setlength{\rightskip}{0pt plus 5cm}void transmit ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_af04463ca216d10ffa94db8463cee04c9}
Retransmit event 


\begin{DoxyCode}
990 {
991     if (txFifo.empty()) {
992         DPRINTF(Ethernet, "nothing to transmit\n");
993         return;
994     }
995 
996     uint32_t interrupts;
997     EthPacketPtr packet = txFifo.front();
998     if (!interface->sendPacket(packet)) {
999         DPRINTF(Ethernet, "Packet Transmit: failed txFifo available %d\n",
1000                 txFifo.avail());
1001         return;
1002     }
1003 
1004     txFifo.pop();
1005 #if TRACING_ON
1006     if (DTRACE(Ethernet)) {
1007         IpPtr ip(packet);
1008         if (ip) {
1009             DPRINTF(Ethernet, "ID is %d\n", ip->id());
1010             TcpPtr tcp(ip);
1011             if (tcp) {
1012                 DPRINTF(Ethernet,
1013                         "Src Port=%d, Dest Port=%d, Seq=%d, Ack=%d\n",
1014                         tcp->sport(), tcp->dport(), tcp->seq(),
1015                         tcp->ack());
1016             }
1017         }
1018     }
1019 #endif
1020 
1021     DDUMP(EthernetData, packet->data, packet->length);
1022     txBytes += packet->length;
1023     txPackets++;
1024 
1025     DPRINTF(Ethernet, "Packet Transmit: successful txFifo Available %d\n",
1026             txFifo.avail());
1027 
1028     interrupts = Regs::Intr_TxPacket;
1029     if (txFifo.size() < regs.TxFifoLow)
1030         interrupts |= Regs::Intr_TxLow;
1031     devIntrPost(interrupts);
1032 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_a5204e0ceaa6484825f9506e447e072c6}{
\index{Sinic::Device@{Sinic::Device}!txDmaDone@{txDmaDone}}
\index{txDmaDone@{txDmaDone}!Sinic::Device@{Sinic::Device}}
\subsubsection[{txDmaDone}]{\setlength{\rightskip}{0pt plus 5cm}void txDmaDone ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a5204e0ceaa6484825f9506e447e072c6}



\begin{DoxyCode}
974 {
975     assert(txState == txCopy);
976     txState = txCopyDone;
977     DPRINTF(EthernetDMA, "tx dma read paddr=%#x len=%d\n",
978             txDmaAddr, txDmaLen);
979     DDUMP(EthernetData, txDmaData, txDmaLen);
980 
981     // If the receive state machine  has a pending DMA, let it go first
982     if (rxState == rxBeginCopy)
983         rxKick();
984 
985     txKick();
986 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_afe787c5d7928546256f34b65f485be32}{
\index{Sinic::Device@{Sinic::Device}!txDump@{txDump}}
\index{txDump@{txDump}!Sinic::Device@{Sinic::Device}}
\subsubsection[{txDump}]{\setlength{\rightskip}{0pt plus 5cm}void txDump () const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_afe787c5d7928546256f34b65f485be32}
\hypertarget{classSinic_1_1Device_a2b61c48d7a63b50007517c67e35dfd20}{
\index{Sinic::Device@{Sinic::Device}!txEventTransmit@{txEventTransmit}}
\index{txEventTransmit@{txEventTransmit}!Sinic::Device@{Sinic::Device}}
\subsubsection[{txEventTransmit}]{\setlength{\rightskip}{0pt plus 5cm}void txEventTransmit ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classSinic_1_1Device_a2b61c48d7a63b50007517c67e35dfd20}



\begin{DoxyCode}
212     {
213         transmit();
214         if (txState == txFifoBlock)
215             txKick();
216     }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_ac5484e8debdd6a2d3cf4c2902b832a76}{
\index{Sinic::Device@{Sinic::Device}!txKick@{txKick}}
\index{txKick@{txKick}!Sinic::Device@{Sinic::Device}}
\subsubsection[{txKick}]{\setlength{\rightskip}{0pt plus 5cm}void txKick ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_ac5484e8debdd6a2d3cf4c2902b832a76}


\begin{Desc}
\item[\hyperlink{todo__todo000072}{TODO}]do we want to schedule a future kick? \end{Desc}



\begin{DoxyCode}
1036 {
1037     VirtualReg *vnic;
1038     DPRINTF(EthernetSM, "txKick: txState=%s (txFifo.size=%d)\n",
1039             TxStateStrings[txState], txFifo.size());
1040 
1041     if (txKickTick > curTick()) {
1042         DPRINTF(EthernetSM, "txKick: exiting, can't run till %d\n",
1043                 txKickTick);
1044         return;
1045     }
1046 
1047   next:
1048     if (txState == txIdle)
1049         goto exit;
1050 
1051     assert(!txList.empty());
1052     vnic = &virtualRegs[txList.front()];
1053 
1054     switch (txState) {
1055       case txFifoBlock:
1056         assert(Regs::get_TxDone_Busy(vnic->TxDone));
1057         if (!txPacket) {
1058             // Grab a new packet from the fifo.
1059             txPacket = new EthPacketData(16384);
1060             txPacketOffset = 0;
1061         }
1062 
1063         if (txFifo.avail() - txPacket->length <
1064             Regs::get_TxData_Len(vnic->TxData)) {
1065             DPRINTF(EthernetSM, "transmit fifo full.  Nothing to do.\n");
1066             goto exit;
1067         }
1068 
1069         txState = txBeginCopy;
1070         break;
1071 
1072       case txBeginCopy:
1073         if (dmaPending() || getDrainState() != Drainable::Running)
1074             goto exit;
1075 
1076         txDmaAddr = params()->platform->pciToDma(
1077                 Regs::get_TxData_Addr(vnic->TxData));
1078         txDmaLen = Regs::get_TxData_Len(vnic->TxData);
1079         txDmaData = txPacket->data + txPacketOffset;
1080         txState = txCopy;
1081 
1082         dmaRead(txDmaAddr, txDmaLen, &txDmaEvent, txDmaData);
1083         break;
1084 
1085       case txCopy:
1086         DPRINTF(EthernetSM, "transmit machine still copying\n");
1087         goto exit;
1088 
1089       case txCopyDone:
1090         vnic->TxDone = txDmaLen | Regs::TxDone_Complete;
1091         txPacket->length += txDmaLen;
1092         if ((vnic->TxData & Regs::TxData_More)) {
1093             txPacketOffset += txDmaLen;
1094             txState = txIdle;
1095             devIntrPost(Regs::Intr_TxDMA);
1096             break;
1097         }
1098 
1099         assert(txPacket->length <= txFifo.avail());
1100         if ((vnic->TxData & Regs::TxData_Checksum)) {
1101             IpPtr ip(txPacket);
1102             if (ip) {
1103                 TcpPtr tcp(ip);
1104                 if (tcp) {
1105                     tcp->sum(0);
1106                     tcp->sum(cksum(tcp));
1107                     txTcpChecksums++;
1108                 }
1109 
1110                 UdpPtr udp(ip);
1111                 if (udp) {
1112                     udp->sum(0);
1113                     udp->sum(cksum(udp));
1114                     txUdpChecksums++;
1115                 }
1116 
1117                 ip->sum(0);
1118                 ip->sum(cksum(ip));
1119                 txIpChecksums++;
1120             }
1121         }
1122 
1123         txFifo.push(txPacket);
1124         if (txFifo.avail() < regs.TxMaxCopy) {
1125             devIntrPost(Regs::Intr_TxFull);
1126             txFull = true;
1127         }
1128         txPacket = 0;
1129         transmit();
1130         txList.pop_front();
1131         txState = txList.empty() ? txIdle : txFifoBlock;
1132         devIntrPost(Regs::Intr_TxDMA);
1133         break;
1134 
1135       default:
1136         panic("Invalid txState!");
1137     }
1138 
1139     DPRINTF(EthernetSM, "entering next txState=%s\n",
1140             TxStateStrings[txState]);
1141 
1142     goto next;
1143 
1144   exit:
1148     DPRINTF(EthernetSM, "tx state machine exited txState=%s\n",
1149             TxStateStrings[txState]);
1150 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_af22e5d6d660b97db37003ac61ac4ee49}{
\index{Sinic::Device@{Sinic::Device}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!Sinic::Device@{Sinic::Device}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSinic_1_1Device_af22e5d6d660b97db37003ac61ac4ee49}
Reconstruct the state of this object from a checkpoint. 
\begin{DoxyParams}{引数}
\item[{\em \hyperlink{namespacecp}{cp}}]The checkpoint use. \item[{\em section}]The section name of this object \end{DoxyParams}


\hyperlink{classSinic_1_1Base_af22e5d6d660b97db37003ac61ac4ee49}{Base}を再定義しています。


\begin{DoxyCode}
1424 {
1425     // Unserialize the PciDevice base class
1426     Base::unserialize(cp, section);
1427 
1428     /*
1429      * Unserialize the device registers that may have been written by the OS.
1430      */
1431     UNSERIALIZE_SCALAR(regs.Config);
1432     UNSERIALIZE_SCALAR(regs.IntrStatus);
1433     UNSERIALIZE_SCALAR(regs.IntrMask);
1434     UNSERIALIZE_SCALAR(regs.RxData);
1435     UNSERIALIZE_SCALAR(regs.TxData);
1436 
1437     UNSERIALIZE_SCALAR(rxActive);
1438     UNSERIALIZE_SCALAR(rxBusyCount);
1439     UNSERIALIZE_SCALAR(rxDirtyCount);
1440     UNSERIALIZE_SCALAR(rxMappedCount);
1441 
1442     int rxListSize;
1443     UNSERIALIZE_SCALAR(rxListSize);
1444     rxList.clear();
1445     for (int i = 0; i < rxListSize; ++i) {
1446         int value;
1447         paramIn(cp, section, csprintf("rxList%d", i), value);
1448         rxList.push_back(value);
1449     }
1450 
1451     int rxBusySize;
1452     UNSERIALIZE_SCALAR(rxBusySize);
1453     rxBusy.clear();
1454     for (int i = 0; i < rxBusySize; ++i) {
1455         int value;
1456         paramIn(cp, section, csprintf("rxBusy%d", i), value);
1457         rxBusy.push_back(value);
1458     }
1459 
1460     int txListSize;
1461     UNSERIALIZE_SCALAR(txListSize);
1462     txList.clear();
1463     for (int i = 0; i < txListSize; ++i) {
1464         int value;
1465         paramIn(cp, section, csprintf("txList%d", i), value);
1466         txList.push_back(value);
1467     }
1468 
1469     /*
1470      * Unserialize rx state machine
1471      */
1472     int rxState;
1473     UNSERIALIZE_SCALAR(rxState);
1474     UNSERIALIZE_SCALAR(rxEmpty);
1475     UNSERIALIZE_SCALAR(rxLow);
1476     this->rxState = (RxState) rxState;
1477     rxFifo.unserialize("rxFifo", cp, section);
1478 
1479     int rxFifoPtr;
1480     UNSERIALIZE_SCALAR(rxFifoPtr);
1481     if (rxFifoPtr >= 0) {
1482         this->rxFifoPtr = rxFifo.begin();
1483         for (int i = 0; i < rxFifoPtr; ++i)
1484             ++this->rxFifoPtr;
1485     } else {
1486         this->rxFifoPtr = rxFifo.end();
1487     }
1488 
1489     /*
1490      * Unserialize tx state machine
1491      */
1492     int txState;
1493     UNSERIALIZE_SCALAR(txState);
1494     UNSERIALIZE_SCALAR(txFull);
1495     this->txState = (TxState) txState;
1496     txFifo.unserialize("txFifo", cp, section);
1497     bool txPacketExists;
1498     UNSERIALIZE_SCALAR(txPacketExists);
1499     txPacket = 0;
1500     if (txPacketExists) {
1501         txPacket = new EthPacketData(16384);
1502         txPacket->unserialize("txPacket", cp, section);
1503         UNSERIALIZE_SCALAR(txPacketOffset);
1504         UNSERIALIZE_SCALAR(txPacketBytes);
1505     }
1506 
1507     /*
1508      * unserialize the virtual nic registers/state
1509      *
1510      * this must be done after the unserialization of the rxFifo
1511      * because the packet iterators depend on the fifo being populated
1512      */
1513     int virtualRegsSize;
1514     UNSERIALIZE_SCALAR(virtualRegsSize);
1515     virtualRegs.clear();
1516     virtualRegs.resize(virtualRegsSize);
1517     for (int i = 0; i < virtualRegsSize; ++i) {
1518         VirtualReg *vnic = &virtualRegs[i];
1519         std::string reg = csprintf("vnic%d", i);
1520 
1521         paramIn(cp, section, reg + ".RxData", vnic->RxData);
1522         paramIn(cp, section, reg + ".RxDone", vnic->RxDone);
1523         paramIn(cp, section, reg + ".TxData", vnic->TxData);
1524         paramIn(cp, section, reg + ".TxDone", vnic->TxDone);
1525 
1526         vnic->rxUnique = rxUnique++;
1527         vnic->txUnique = txUnique++;
1528 
1529         bool rxPacketExists;
1530         paramIn(cp, section, reg + ".rxPacketExists", rxPacketExists);
1531         if (rxPacketExists) {
1532             int rxPacket;
1533             paramIn(cp, section, reg + ".rxPacket", rxPacket);
1534             vnic->rxIndex = rxFifo.begin();
1535             while (rxPacket--)
1536                 ++vnic->rxIndex;
1537 
1538             paramIn(cp, section, reg + ".rxPacketOffset",
1539                     vnic->rxPacketOffset);
1540             paramIn(cp, section, reg + ".rxPacketBytes", vnic->rxPacketBytes);
1541         } else {
1542             vnic->rxIndex = rxFifo.end();
1543         }
1544         paramIn(cp, section, reg + ".rxDoneData", vnic->rxDoneData);
1545     }
1546 
1547     /*
1548      * If there's a pending transmit, reschedule it now
1549      */
1550     Tick transmitTick;
1551     UNSERIALIZE_SCALAR(transmitTick);
1552     if (transmitTick)
1553         schedule(txEvent, curTick() + transmitTick);
1554 
1555     pioPort.sendRangeChange();
1556 
1557 }
\end{DoxyCode}
\hypertarget{classSinic_1_1Device_a4cefab464e72b5dd42c003a0a4341802}{
\index{Sinic::Device@{Sinic::Device}!write@{write}}
\index{write@{write}!Sinic::Device@{Sinic::Device}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} write ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSinic_1_1Device_a4cefab464e72b5dd42c003a0a4341802}
IPR read of device register

Fault Device::iprRead(Addr daddr, int cpu, uint64\_\-t \&result) \{ if (!regValid(daddr)) panic(\char`\"{}invalid address: da=\%\#x\char`\"{}, daddr);

const \hyperlink{structSinic_1_1Regs_1_1Info}{Regs::Info} \&info = regInfo(daddr); if (!info.read) panic(\char`\"{}reading \%s (write only): cpu=\%d da=\%\#x\char`\"{}, \hyperlink{trace_8hh_a166fa10b86d8faa127fb7c78191e3e60}{info.name}, cpu, daddr);

DPRINTF(EthernetPIO, \char`\"{}IPR read \%s: cpu=\%d da=\%\#x$\backslash$n\char`\"{}, \hyperlink{trace_8hh_a166fa10b86d8faa127fb7c78191e3e60}{info.name}, cpu, daddr);

prepareRead(cpu, 0);

if (info.size == 4) result = regData32(daddr);

if (info.size == 8) result = regData64(daddr);

DPRINTF(EthernetPIO, \char`\"{}IPR read \%s: cpu=\%s da=\%\#x val=\%\#x$\backslash$n\char`\"{}, \hyperlink{trace_8hh_a166fa10b86d8faa127fb7c78191e3e60}{info.name}, cpu, result);

return NoFault; \} I/O write of device register 

\hyperlink{classPioDevice_afe8371668d023bb2516b286e5e399b6f}{PioDevice}を実装しています。


\begin{DoxyCode}
306 {
307     assert(config.command & PCI_CMD_MSE);
308     assert(pkt->getAddr() >= BARAddrs[0] && pkt->getSize() < BARSize[0]);
309 
310     int cpu = pkt->req->contextId();
311     Addr daddr = pkt->getAddr() - BARAddrs[0];
312     Addr index = daddr >> Regs::VirtualShift;
313     Addr raddr = daddr & Regs::VirtualMask;
314 
315     if (!regValid(raddr))
316         panic("invalid register: cpu=%d, da=%#x pa=%#x size=%d",
317                 cpu, daddr, pkt->getAddr(), pkt->getSize());
318 
319     const Regs::Info &info = regInfo(raddr);
320     if (!info.write)
321         panic("write %s (read only): "
322               "cpu=%d vnic=%d da=%#x pa=%#x size=%d",
323               info.name, cpu, index, daddr, pkt->getAddr(), pkt->getSize());
324 
325     if (pkt->getSize() != info.size)
326         panic("write %s (invalid size): "
327               "cpu=%d vnic=%d da=%#x pa=%#x size=%d",
328               info.name, cpu, index, daddr, pkt->getAddr(), pkt->getSize());
329 
330     VirtualReg &vnic = virtualRegs[index];
331 
332     DPRINTF(EthernetPIO,
333             "write %s vnic %d: cpu=%d val=%#x da=%#x pa=%#x size=%d\n",
334             info.name, index, cpu, info.size == 4 ? pkt->get<uint32_t>() :
335             pkt->get<uint64_t>(), daddr, pkt->getAddr(), pkt->getSize());
336 
337     prepareWrite(cpu, index);
338 
339     switch (raddr) {
340       case Regs::Config:
341         changeConfig(pkt->get<uint32_t>());
342         break;
343 
344       case Regs::Command:
345         command(pkt->get<uint32_t>());
346         break;
347 
348       case Regs::IntrStatus:
349         devIntrClear(regs.IntrStatus & pkt->get<uint32_t>());
350         break;
351 
352       case Regs::IntrMask:
353         devIntrChangeMask(pkt->get<uint32_t>());
354         break;
355 
356       case Regs::RxData:
357         if (Regs::get_RxDone_Busy(vnic.RxDone))
358             panic("receive machine busy with another request! rxState=%s",
359                   RxStateStrings[rxState]);
360 
361         vnic.rxUnique = rxUnique++;
362         vnic.RxDone = Regs::RxDone_Busy;
363         vnic.RxData = pkt->get<uint64_t>();
364         rxBusyCount++;
365 
366         if (Regs::get_RxData_Vaddr(pkt->get<uint64_t>())) {
367             panic("vtophys not implemented in newmem");
368 #ifdef SINIC_VTOPHYS
369             Addr vaddr = Regs::get_RxData_Addr(reg64);
370             Addr paddr = vtophys(req->xc, vaddr);
371             DPRINTF(EthernetPIO, "write RxData vnic %d (rxunique %d): "
372                     "vaddr=%#x, paddr=%#x\n",
373                     index, vnic.rxUnique, vaddr, paddr);
374 
375             vnic.RxData = Regs::set_RxData_Addr(vnic.RxData, paddr);
376 #endif
377         } else {
378             DPRINTF(EthernetPIO, "write RxData vnic %d (rxunique %d)\n",
379                     index, vnic.rxUnique);
380         }
381 
382         if (vnic.rxIndex == rxFifo.end()) {
383             DPRINTF(EthernetPIO, "request new packet...appending to rxList\n");
384             rxList.push_back(index);
385         } else {
386             DPRINTF(EthernetPIO, "packet exists...appending to rxBusy\n");
387             rxBusy.push_back(index);
388         }
389 
390         if (rxEnable && (rxState == rxIdle || rxState == rxFifoBlock)) {
391             rxState = rxFifoBlock;
392             rxKick();
393         }
394         break;
395 
396       case Regs::TxData:
397         if (Regs::get_TxDone_Busy(vnic.TxDone))
398             panic("transmit machine busy with another request! txState=%s",
399                   TxStateStrings[txState]);
400 
401         vnic.txUnique = txUnique++;
402         vnic.TxDone = Regs::TxDone_Busy;
403 
404         if (Regs::get_TxData_Vaddr(pkt->get<uint64_t>())) {
405             panic("vtophys won't work here in newmem.\n");
406 #ifdef SINIC_VTOPHYS
407             Addr vaddr = Regs::get_TxData_Addr(reg64);
408             Addr paddr = vtophys(req->xc, vaddr);
409             DPRINTF(EthernetPIO, "write TxData vnic %d (txunique %d): "
410                     "vaddr=%#x, paddr=%#x\n",
411                     index, vnic.txUnique, vaddr, paddr);
412 
413             vnic.TxData = Regs::set_TxData_Addr(vnic.TxData, paddr);
414 #endif
415         } else {
416             DPRINTF(EthernetPIO, "write TxData vnic %d (txunique %d)\n",
417                     index, vnic.txUnique);
418         }
419 
420         if (txList.empty() || txList.front() != index)
421             txList.push_back(index);
422         if (txEnable && txState == txIdle && txList.front() == index) {
423             txState = txFifoBlock;
424             txKick();
425         }
426         break;
427     }
428 
429     return pioDelay;
430 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classSinic_1_1Device_aeca94de76c2e5173eca0cd628c06cb43}{
\index{Sinic::Device@{Sinic::Device}!EventWrapper$<$ Device,\&Device::rxDmaDone $>$@{EventWrapper$<$ Device,\&Device::rxDmaDone $>$}}
\index{EventWrapper$<$ Device,\&Device::rxDmaDone $>$@{EventWrapper$<$ Device,\&Device::rxDmaDone $>$}!Sinic::Device@{Sinic::Device}}
\subsubsection[{EventWrapper$<$ Device,\&Device::rxDmaDone $>$}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf EventWrapper}$<$ {\bf Device},\&Device::rxDmaDone $>$\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classSinic_1_1Device_aeca94de76c2e5173eca0cd628c06cb43}
\hypertarget{classSinic_1_1Device_af2d0621641d94343bd091391cd6cf46f}{
\index{Sinic::Device@{Sinic::Device}!EventWrapper$<$ Device,\&Device::txDmaDone $>$@{EventWrapper$<$ Device,\&Device::txDmaDone $>$}}
\index{EventWrapper$<$ Device,\&Device::txDmaDone $>$@{EventWrapper$<$ Device,\&Device::txDmaDone $>$}!Sinic::Device@{Sinic::Device}}
\subsubsection[{EventWrapper$<$ Device,\&Device::txDmaDone $>$}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf EventWrapper}$<$ {\bf Device},\&Device::txDmaDone $>$\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classSinic_1_1Device_af2d0621641d94343bd091391cd6cf46f}
\hypertarget{classSinic_1_1Device_a97dc465a9dffe1cb8fcb2775d67610ca}{
\index{Sinic::Device@{Sinic::Device}!RxKickEvent::process@{RxKickEvent::process}}
\index{RxKickEvent::process@{RxKickEvent::process}!Sinic::Device@{Sinic::Device}}
\subsubsection[{RxKickEvent::process}]{\setlength{\rightskip}{0pt plus 5cm}void RxKickEvent::process ()\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classSinic_1_1Device_a97dc465a9dffe1cb8fcb2775d67610ca}
\hypertarget{classSinic_1_1Device_ac669bd618effa3395173bc2905568d54}{
\index{Sinic::Device@{Sinic::Device}!TxEvent::process@{TxEvent::process}}
\index{TxEvent::process@{TxEvent::process}!Sinic::Device@{Sinic::Device}}
\subsubsection[{TxEvent::process}]{\setlength{\rightskip}{0pt plus 5cm}void TxEvent::process ()\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classSinic_1_1Device_ac669bd618effa3395173bc2905568d54}
\hypertarget{classSinic_1_1Device_ab1e1e9de6b0b4cbeee1a4c0bb61e07d9}{
\index{Sinic::Device@{Sinic::Device}!TxKickEvent::process@{TxKickEvent::process}}
\index{TxKickEvent::process@{TxKickEvent::process}!Sinic::Device@{Sinic::Device}}
\subsubsection[{TxKickEvent::process}]{\setlength{\rightskip}{0pt plus 5cm}void TxKickEvent::process ()\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classSinic_1_1Device_ab1e1e9de6b0b4cbeee1a4c0bb61e07d9}


\subsection{変数}
\hypertarget{classSinic_1_1Device_a3eb6949618cb5ab7fcb963974eb980a0}{
\index{Sinic::Device@{Sinic::Device}!\_\-maxVnicDistance@{\_\-maxVnicDistance}}
\index{\_\-maxVnicDistance@{\_\-maxVnicDistance}!Sinic::Device@{Sinic::Device}}
\subsubsection[{\_\-maxVnicDistance}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf \_\-maxVnicDistance}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSinic_1_1Device_a3eb6949618cb5ab7fcb963974eb980a0}
\hypertarget{classSinic_1_1Device_a6846633bb8f156a544f88825a26a3090}{
\index{Sinic::Device@{Sinic::Device}!avgVnicDistance@{avgVnicDistance}}
\index{avgVnicDistance@{avgVnicDistance}!Sinic::Device@{Sinic::Device}}
\subsubsection[{avgVnicDistance}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf avgVnicDistance}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSinic_1_1Device_a6846633bb8f156a544f88825a26a3090}
\hypertarget{classSinic_1_1Device_a04596aab9f96da6679ea03286f74b3df}{
\index{Sinic::Device@{Sinic::Device}!Command@{Command}}
\index{Command@{Command}!Sinic::Device@{Sinic::Device}}
\subsubsection[{Command}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf Command}}}
\label{classSinic_1_1Device_a04596aab9f96da6679ea03286f74b3df}
\hypertarget{classSinic_1_1Device_a4ce7377178b8c0ee57726e8a73c06e66}{
\index{Sinic::Device@{Sinic::Device}!Config@{Config}}
\index{Config@{Config}!Sinic::Device@{Sinic::Device}}
\subsubsection[{Config}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf Config}}}
\label{classSinic_1_1Device_a4ce7377178b8c0ee57726e8a73c06e66}
\hypertarget{classSinic_1_1Device_abff269bf1752a04839eb356b47d4348b}{
\index{Sinic::Device@{Sinic::Device}!dmaReadDelay@{dmaReadDelay}}
\index{dmaReadDelay@{dmaReadDelay}!Sinic::Device@{Sinic::Device}}
\subsubsection[{dmaReadDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf dmaReadDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_abff269bf1752a04839eb356b47d4348b}
\hypertarget{classSinic_1_1Device_a632abfe8a89dfa1d944547874f1b4fe4}{
\index{Sinic::Device@{Sinic::Device}!dmaReadFactor@{dmaReadFactor}}
\index{dmaReadFactor@{dmaReadFactor}!Sinic::Device@{Sinic::Device}}
\subsubsection[{dmaReadFactor}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf dmaReadFactor}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a632abfe8a89dfa1d944547874f1b4fe4}
\hypertarget{classSinic_1_1Device_add556e09206ac9f4675d3e2da53339e8}{
\index{Sinic::Device@{Sinic::Device}!dmaWriteDelay@{dmaWriteDelay}}
\index{dmaWriteDelay@{dmaWriteDelay}!Sinic::Device@{Sinic::Device}}
\subsubsection[{dmaWriteDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf dmaWriteDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_add556e09206ac9f4675d3e2da53339e8}
\hypertarget{classSinic_1_1Device_a396f950eb0d0a011cfa5790861e32608}{
\index{Sinic::Device@{Sinic::Device}!dmaWriteFactor@{dmaWriteFactor}}
\index{dmaWriteFactor@{dmaWriteFactor}!Sinic::Device@{Sinic::Device}}
\subsubsection[{dmaWriteFactor}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf dmaWriteFactor}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a396f950eb0d0a011cfa5790861e32608}
\hypertarget{classSinic_1_1Device_acc1119b12c1f476a7aa533a975ac4249}{
\index{Sinic::Device@{Sinic::Device}!HwAddr@{HwAddr}}
\index{HwAddr@{HwAddr}!Sinic::Device@{Sinic::Device}}
\subsubsection[{HwAddr}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf HwAddr}}}
\label{classSinic_1_1Device_acc1119b12c1f476a7aa533a975ac4249}
\hypertarget{classSinic_1_1Device_aa3e3d884e5a8b959eeccc3660451c7ed}{
\index{Sinic::Device@{Sinic::Device}!IntrMask@{IntrMask}}
\index{IntrMask@{IntrMask}!Sinic::Device@{Sinic::Device}}
\subsubsection[{IntrMask}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf IntrMask}}}
\label{classSinic_1_1Device_aa3e3d884e5a8b959eeccc3660451c7ed}
\hypertarget{classSinic_1_1Device_a48050ef73aa0e6da5537fca47130d76f}{
\index{Sinic::Device@{Sinic::Device}!IntrStatus@{IntrStatus}}
\index{IntrStatus@{IntrStatus}!Sinic::Device@{Sinic::Device}}
\subsubsection[{IntrStatus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf IntrStatus}}}
\label{classSinic_1_1Device_a48050ef73aa0e6da5537fca47130d76f}
\hypertarget{classSinic_1_1Device_a55159ce061f8632637c330b0b101d370}{
\index{Sinic::Device@{Sinic::Device}!maxVnicDistance@{maxVnicDistance}}
\index{maxVnicDistance@{maxVnicDistance}!Sinic::Device@{Sinic::Device}}
\subsubsection[{maxVnicDistance}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf maxVnicDistance}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSinic_1_1Device_a55159ce061f8632637c330b0b101d370}
\hypertarget{classSinic_1_1Device_a489a76c8b17d7dec4865d06b211218fb}{
\index{Sinic::Device@{Sinic::Device}!numVnicDistance@{numVnicDistance}}
\index{numVnicDistance@{numVnicDistance}!Sinic::Device@{Sinic::Device}}
\subsubsection[{numVnicDistance}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numVnicDistance}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSinic_1_1Device_a489a76c8b17d7dec4865d06b211218fb}
\hypertarget{classSinic_1_1Device_a1898630b26f531edc311e99e742572af}{
\index{Sinic::Device@{Sinic::Device}!regs@{regs}}
\index{regs@{regs}!Sinic::Device@{Sinic::Device}}
\subsubsection[{regs}]{\setlength{\rightskip}{0pt plus 5cm}struct \{ ... \}   {\bf regs}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a1898630b26f531edc311e99e742572af}
device register file \hypertarget{classSinic_1_1Device_a560efaee55571ea588551a80aadc6cda}{
\index{Sinic::Device@{Sinic::Device}!rxActive@{rxActive}}
\index{rxActive@{rxActive}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxActive}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf rxActive}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a560efaee55571ea588551a80aadc6cda}
\hypertarget{classSinic_1_1Device_afd33bf96a9045d1f90d0685ad3e33253}{
\index{Sinic::Device@{Sinic::Device}!rxBusy@{rxBusy}}
\index{rxBusy@{rxBusy}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxBusy}]{\setlength{\rightskip}{0pt plus 5cm}{\bf VirtualList} {\bf rxBusy}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_afd33bf96a9045d1f90d0685ad3e33253}
\hypertarget{classSinic_1_1Device_a508dbc989a9476f10e7622b054aac7e1}{
\index{Sinic::Device@{Sinic::Device}!rxBusyCount@{rxBusyCount}}
\index{rxBusyCount@{rxBusyCount}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxBusyCount}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf rxBusyCount}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a508dbc989a9476f10e7622b054aac7e1}
\hypertarget{classSinic_1_1Device_a6c9104d7b097720d299cae2ffe977554}{
\index{Sinic::Device@{Sinic::Device}!RxData@{RxData}}
\index{RxData@{RxData}!Sinic::Device@{Sinic::Device}}
\subsubsection[{RxData}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf RxData}}}
\label{classSinic_1_1Device_a6c9104d7b097720d299cae2ffe977554}
\hypertarget{classSinic_1_1Device_a9e5a18ec7025db57fa6ff2f05a289804}{
\index{Sinic::Device@{Sinic::Device}!rxDirtyCount@{rxDirtyCount}}
\index{rxDirtyCount@{rxDirtyCount}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxDirtyCount}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf rxDirtyCount}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a9e5a18ec7025db57fa6ff2f05a289804}
\hypertarget{classSinic_1_1Device_a4a609f84c6849bcfb6dee08329773fca}{
\index{Sinic::Device@{Sinic::Device}!rxDmaAddr@{rxDmaAddr}}
\index{rxDmaAddr@{rxDmaAddr}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxDmaAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf rxDmaAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a4a609f84c6849bcfb6dee08329773fca}
\hypertarget{classSinic_1_1Device_ae917f4bc2a610fed06749a854fb89d14}{
\index{Sinic::Device@{Sinic::Device}!rxDmaData@{rxDmaData}}
\index{rxDmaData@{rxDmaData}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxDmaData}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t$\ast$ {\bf rxDmaData}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_ae917f4bc2a610fed06749a854fb89d14}
\hypertarget{classSinic_1_1Device_a50d4f78a0a458835572bb101383bf692}{
\index{Sinic::Device@{Sinic::Device}!rxDmaEvent@{rxDmaEvent}}
\index{rxDmaEvent@{rxDmaEvent}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxDmaEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf Device}, \&Device::rxDmaDone$>$ {\bf rxDmaEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a50d4f78a0a458835572bb101383bf692}
\hypertarget{classSinic_1_1Device_a0efc207ddfcff656cbe0237c3bc237c1}{
\index{Sinic::Device@{Sinic::Device}!rxDmaLen@{rxDmaLen}}
\index{rxDmaLen@{rxDmaLen}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxDmaLen}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf rxDmaLen}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a0efc207ddfcff656cbe0237c3bc237c1}
\hypertarget{classSinic_1_1Device_a3eeed0cb70c02a0da59c7a4c407dd6e9}{
\index{Sinic::Device@{Sinic::Device}!RxDone@{RxDone}}
\index{RxDone@{RxDone}!Sinic::Device@{Sinic::Device}}
\subsubsection[{RxDone}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf RxDone}}}
\label{classSinic_1_1Device_a3eeed0cb70c02a0da59c7a4c407dd6e9}
\hypertarget{classSinic_1_1Device_a62b6a5f468811226da2581374919b1a5}{
\index{Sinic::Device@{Sinic::Device}!rxEmpty@{rxEmpty}}
\index{rxEmpty@{rxEmpty}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf rxEmpty}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a62b6a5f468811226da2581374919b1a5}
\hypertarget{classSinic_1_1Device_a45c9c6a3665bcd91e57ff35aa9089fa7}{
\index{Sinic::Device@{Sinic::Device}!rxFifo@{rxFifo}}
\index{rxFifo@{rxFifo}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxFifo}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketFifo} {\bf rxFifo}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a45c9c6a3665bcd91e57ff35aa9089fa7}
\hypertarget{classSinic_1_1Device_a5f1b0015444b58705dd253c2e0aed9b4}{
\index{Sinic::Device@{Sinic::Device}!RxFifoHigh@{RxFifoHigh}}
\index{RxFifoHigh@{RxFifoHigh}!Sinic::Device@{Sinic::Device}}
\subsubsection[{RxFifoHigh}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf RxFifoHigh}}}
\label{classSinic_1_1Device_a5f1b0015444b58705dd253c2e0aed9b4}
\hypertarget{classSinic_1_1Device_a4d0eb17fd55782f70d98e6b96ccd8d16}{
\index{Sinic::Device@{Sinic::Device}!RxFifoLow@{RxFifoLow}}
\index{RxFifoLow@{RxFifoLow}!Sinic::Device@{Sinic::Device}}
\subsubsection[{RxFifoLow}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf RxFifoLow}}}
\label{classSinic_1_1Device_a4d0eb17fd55782f70d98e6b96ccd8d16}
\hypertarget{classSinic_1_1Device_aee345bc47c94b616b04d8f502dab1826}{
\index{Sinic::Device@{Sinic::Device}!rxFifoPtr@{rxFifoPtr}}
\index{rxFifoPtr@{rxFifoPtr}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxFifoPtr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketFifo::iterator} {\bf rxFifoPtr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_aee345bc47c94b616b04d8f502dab1826}
\hypertarget{classSinic_1_1Device_ad95eeec9a1e7f6804da0d44916333d3c}{
\index{Sinic::Device@{Sinic::Device}!RxFifoSize@{RxFifoSize}}
\index{RxFifoSize@{RxFifoSize}!Sinic::Device@{Sinic::Device}}
\subsubsection[{RxFifoSize}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf RxFifoSize}}}
\label{classSinic_1_1Device_ad95eeec9a1e7f6804da0d44916333d3c}
\hypertarget{classSinic_1_1Device_aa36d466a86f77d2c7afdc014e3a6f8b3}{
\index{Sinic::Device@{Sinic::Device}!rxKickTick@{rxKickTick}}
\index{rxKickTick@{rxKickTick}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxKickTick}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf rxKickTick}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_aa36d466a86f77d2c7afdc014e3a6f8b3}
\hypertarget{classSinic_1_1Device_a45202257b5522a1436d8130249ee0a0d}{
\index{Sinic::Device@{Sinic::Device}!rxList@{rxList}}
\index{rxList@{rxList}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf VirtualList} {\bf rxList}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a45202257b5522a1436d8130249ee0a0d}
\hypertarget{classSinic_1_1Device_a1ef589f4a0a6d9baae11626a0d89b5ec}{
\index{Sinic::Device@{Sinic::Device}!rxLow@{rxLow}}
\index{rxLow@{rxLow}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxLow}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf rxLow}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a1ef589f4a0a6d9baae11626a0d89b5ec}
\hypertarget{classSinic_1_1Device_a41d5a12c120010c50c75ea0dc2f01241}{
\index{Sinic::Device@{Sinic::Device}!rxMappedCount@{rxMappedCount}}
\index{rxMappedCount@{rxMappedCount}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxMappedCount}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf rxMappedCount}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a41d5a12c120010c50c75ea0dc2f01241}
\hypertarget{classSinic_1_1Device_a40cf84e9a58828b94d92f3f4af8e2132}{
\index{Sinic::Device@{Sinic::Device}!RxMaxCopy@{RxMaxCopy}}
\index{RxMaxCopy@{RxMaxCopy}!Sinic::Device@{Sinic::Device}}
\subsubsection[{RxMaxCopy}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf RxMaxCopy}}}
\label{classSinic_1_1Device_a40cf84e9a58828b94d92f3f4af8e2132}
\hypertarget{classSinic_1_1Device_a29b4ff4ee34664ea46879c0fed891fe6}{
\index{Sinic::Device@{Sinic::Device}!RxMaxIntr@{RxMaxIntr}}
\index{RxMaxIntr@{RxMaxIntr}!Sinic::Device@{Sinic::Device}}
\subsubsection[{RxMaxIntr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf RxMaxIntr}}}
\label{classSinic_1_1Device_a29b4ff4ee34664ea46879c0fed891fe6}
\hypertarget{classSinic_1_1Device_a17c506ad3a705ec9dbd1762e6a80fbf5}{
\index{Sinic::Device@{Sinic::Device}!rxState@{rxState}}
\index{rxState@{rxState}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RxState} {\bf rxState}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a17c506ad3a705ec9dbd1762e6a80fbf5}
\hypertarget{classSinic_1_1Device_a1d5b24603a5677cd3cf0a67f8c44d540}{
\index{Sinic::Device@{Sinic::Device}!RxStatus@{RxStatus}}
\index{RxStatus@{RxStatus}!Sinic::Device@{Sinic::Device}}
\subsubsection[{RxStatus}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf RxStatus}}}
\label{classSinic_1_1Device_a1d5b24603a5677cd3cf0a67f8c44d540}
\hypertarget{classSinic_1_1Device_a98e0c2747f2107c6f81f51e9ba3bdc8a}{
\index{Sinic::Device@{Sinic::Device}!rxUnique@{rxUnique}}
\index{rxUnique@{rxUnique}!Sinic::Device@{Sinic::Device}}
\subsubsection[{rxUnique}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Counter} {\bf rxUnique}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a98e0c2747f2107c6f81f51e9ba3bdc8a}
\hypertarget{classSinic_1_1Device_a49b873aef0e771896569f73b69ed5f6a}{
\index{Sinic::Device@{Sinic::Device}!RxWait@{RxWait}}
\index{RxWait@{RxWait}!Sinic::Device@{Sinic::Device}}
\subsubsection[{RxWait}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf RxWait}}}
\label{classSinic_1_1Device_a49b873aef0e771896569f73b69ed5f6a}
\hypertarget{classSinic_1_1Device_aceabe9d2fb5f87ee602c22e0d0141479}{
\index{Sinic::Device@{Sinic::Device}!totalVnicDistance@{totalVnicDistance}}
\index{totalVnicDistance@{totalVnicDistance}!Sinic::Device@{Sinic::Device}}
\subsubsection[{totalVnicDistance}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf totalVnicDistance}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSinic_1_1Device_aceabe9d2fb5f87ee602c22e0d0141479}
Statistics \hypertarget{classSinic_1_1Device_a6f031a974796558748f14b7ba7f64985}{
\index{Sinic::Device@{Sinic::Device}!TxData@{TxData}}
\index{TxData@{TxData}!Sinic::Device@{Sinic::Device}}
\subsubsection[{TxData}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf TxData}}}
\label{classSinic_1_1Device_a6f031a974796558748f14b7ba7f64985}
\hypertarget{classSinic_1_1Device_aef3a8dd866e8017fd7a675414596ec6b}{
\index{Sinic::Device@{Sinic::Device}!txDmaAddr@{txDmaAddr}}
\index{txDmaAddr@{txDmaAddr}!Sinic::Device@{Sinic::Device}}
\subsubsection[{txDmaAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf txDmaAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_aef3a8dd866e8017fd7a675414596ec6b}
\hypertarget{classSinic_1_1Device_af56464970a8957faf3a1d35026db6a12}{
\index{Sinic::Device@{Sinic::Device}!txDmaData@{txDmaData}}
\index{txDmaData@{txDmaData}!Sinic::Device@{Sinic::Device}}
\subsubsection[{txDmaData}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t$\ast$ {\bf txDmaData}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_af56464970a8957faf3a1d35026db6a12}
\hypertarget{classSinic_1_1Device_a3d31afcc8e7130b3e43e5dc1a0ef0e37}{
\index{Sinic::Device@{Sinic::Device}!txDmaEvent@{txDmaEvent}}
\index{txDmaEvent@{txDmaEvent}!Sinic::Device@{Sinic::Device}}
\subsubsection[{txDmaEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf Device}, \&Device::txDmaDone$>$ {\bf txDmaEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a3d31afcc8e7130b3e43e5dc1a0ef0e37}
\hypertarget{classSinic_1_1Device_a5782be4cae30f9377ab0c645a9f65892}{
\index{Sinic::Device@{Sinic::Device}!txDmaLen@{txDmaLen}}
\index{txDmaLen@{txDmaLen}!Sinic::Device@{Sinic::Device}}
\subsubsection[{txDmaLen}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf txDmaLen}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a5782be4cae30f9377ab0c645a9f65892}
\hypertarget{classSinic_1_1Device_ab0c6a1c886fdea04c1107ab914188fe7}{
\index{Sinic::Device@{Sinic::Device}!TxDone@{TxDone}}
\index{TxDone@{TxDone}!Sinic::Device@{Sinic::Device}}
\subsubsection[{TxDone}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf TxDone}}}
\label{classSinic_1_1Device_ab0c6a1c886fdea04c1107ab914188fe7}
\hypertarget{classSinic_1_1Device_a324fed072a29716c20a98a82927bd2a2}{
\index{Sinic::Device@{Sinic::Device}!txEvent@{txEvent}}
\index{txEvent@{txEvent}!Sinic::Device@{Sinic::Device}}
\subsubsection[{txEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TxEvent} {\bf txEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a324fed072a29716c20a98a82927bd2a2}
\hypertarget{classSinic_1_1Device_ae699c324753236e0a59aa2465920eb46}{
\index{Sinic::Device@{Sinic::Device}!txFifo@{txFifo}}
\index{txFifo@{txFifo}!Sinic::Device@{Sinic::Device}}
\subsubsection[{txFifo}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketFifo} {\bf txFifo}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_ae699c324753236e0a59aa2465920eb46}
\hypertarget{classSinic_1_1Device_ae282c8042fb1e67c966a0040eed2c37f}{
\index{Sinic::Device@{Sinic::Device}!TxFifoHigh@{TxFifoHigh}}
\index{TxFifoHigh@{TxFifoHigh}!Sinic::Device@{Sinic::Device}}
\subsubsection[{TxFifoHigh}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf TxFifoHigh}}}
\label{classSinic_1_1Device_ae282c8042fb1e67c966a0040eed2c37f}
\hypertarget{classSinic_1_1Device_a72783e023c789fe9ff7b3d526a202417}{
\index{Sinic::Device@{Sinic::Device}!TxFifoLow@{TxFifoLow}}
\index{TxFifoLow@{TxFifoLow}!Sinic::Device@{Sinic::Device}}
\subsubsection[{TxFifoLow}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf TxFifoLow}}}
\label{classSinic_1_1Device_a72783e023c789fe9ff7b3d526a202417}
\hypertarget{classSinic_1_1Device_a07afc60b5230368629f6b0eb9ab6c51a}{
\index{Sinic::Device@{Sinic::Device}!TxFifoSize@{TxFifoSize}}
\index{TxFifoSize@{TxFifoSize}!Sinic::Device@{Sinic::Device}}
\subsubsection[{TxFifoSize}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf TxFifoSize}}}
\label{classSinic_1_1Device_a07afc60b5230368629f6b0eb9ab6c51a}
\hypertarget{classSinic_1_1Device_aa09cc8a4752916111328b7353e64f3bb}{
\index{Sinic::Device@{Sinic::Device}!txFull@{txFull}}
\index{txFull@{txFull}!Sinic::Device@{Sinic::Device}}
\subsubsection[{txFull}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf txFull}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_aa09cc8a4752916111328b7353e64f3bb}
\hypertarget{classSinic_1_1Device_acfce4fae6fa03f94e3d91d71302fe349}{
\index{Sinic::Device@{Sinic::Device}!txKickTick@{txKickTick}}
\index{txKickTick@{txKickTick}!Sinic::Device@{Sinic::Device}}
\subsubsection[{txKickTick}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf txKickTick}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_acfce4fae6fa03f94e3d91d71302fe349}
\hypertarget{classSinic_1_1Device_a7010216dd085a0c2dac9d6b830a64f35}{
\index{Sinic::Device@{Sinic::Device}!txList@{txList}}
\index{txList@{txList}!Sinic::Device@{Sinic::Device}}
\subsubsection[{txList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf VirtualList} {\bf txList}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a7010216dd085a0c2dac9d6b830a64f35}
\hypertarget{classSinic_1_1Device_a8dfcab9c852a1e3e564b4ccceb9a594d}{
\index{Sinic::Device@{Sinic::Device}!TxMaxCopy@{TxMaxCopy}}
\index{TxMaxCopy@{TxMaxCopy}!Sinic::Device@{Sinic::Device}}
\subsubsection[{TxMaxCopy}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf TxMaxCopy}}}
\label{classSinic_1_1Device_a8dfcab9c852a1e3e564b4ccceb9a594d}
\hypertarget{classSinic_1_1Device_a8d22e1a154942ff0d4ab9048e7e844bb}{
\index{Sinic::Device@{Sinic::Device}!txPacket@{txPacket}}
\index{txPacket@{txPacket}!Sinic::Device@{Sinic::Device}}
\subsubsection[{txPacket}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EthPacketPtr} {\bf txPacket}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a8d22e1a154942ff0d4ab9048e7e844bb}
\hypertarget{classSinic_1_1Device_a1e82240f06ef6f0c8d8c0bb1a141a600}{
\index{Sinic::Device@{Sinic::Device}!txPacketBytes@{txPacketBytes}}
\index{txPacketBytes@{txPacketBytes}!Sinic::Device@{Sinic::Device}}
\subsubsection[{txPacketBytes}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf txPacketBytes}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a1e82240f06ef6f0c8d8c0bb1a141a600}
\hypertarget{classSinic_1_1Device_ac0d074adcc00053882737a0009c84adb}{
\index{Sinic::Device@{Sinic::Device}!txPacketOffset@{txPacketOffset}}
\index{txPacketOffset@{txPacketOffset}!Sinic::Device@{Sinic::Device}}
\subsubsection[{txPacketOffset}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf txPacketOffset}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_ac0d074adcc00053882737a0009c84adb}
\hypertarget{classSinic_1_1Device_a12e3a80bef638cd15c067541b96a4756}{
\index{Sinic::Device@{Sinic::Device}!txState@{txState}}
\index{txState@{txState}!Sinic::Device@{Sinic::Device}}
\subsubsection[{txState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TxState} {\bf txState}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_a12e3a80bef638cd15c067541b96a4756}
\hypertarget{classSinic_1_1Device_addcc8e87969e32011941cd144fe23c73}{
\index{Sinic::Device@{Sinic::Device}!txUnique@{txUnique}}
\index{txUnique@{txUnique}!Sinic::Device@{Sinic::Device}}
\subsubsection[{txUnique}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Counter} {\bf txUnique}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_addcc8e87969e32011941cd144fe23c73}
\hypertarget{classSinic_1_1Device_aee07d31d26bcedc3ec903158356f7d06}{
\index{Sinic::Device@{Sinic::Device}!TxWait@{TxWait}}
\index{TxWait@{TxWait}!Sinic::Device@{Sinic::Device}}
\subsubsection[{TxWait}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf TxWait}}}
\label{classSinic_1_1Device_aee07d31d26bcedc3ec903158356f7d06}
\hypertarget{classSinic_1_1Device_a8e55d9d438f57f1cf9bee803876daf7e}{
\index{Sinic::Device@{Sinic::Device}!VirtualCount@{VirtualCount}}
\index{VirtualCount@{VirtualCount}!Sinic::Device@{Sinic::Device}}
\subsubsection[{VirtualCount}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf VirtualCount}}}
\label{classSinic_1_1Device_a8e55d9d438f57f1cf9bee803876daf7e}
\hypertarget{classSinic_1_1Device_acb438fcaae56ab29f35376e8b0726c23}{
\index{Sinic::Device@{Sinic::Device}!virtualRegs@{virtualRegs}}
\index{virtualRegs@{virtualRegs}!Sinic::Device@{Sinic::Device}}
\subsubsection[{virtualRegs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf VirtualRegs} {\bf virtualRegs}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSinic_1_1Device_acb438fcaae56ab29f35376e8b0726c23}
\hypertarget{classSinic_1_1Device_a93d85f8e9d6efa8d85cce98ef514c54d}{
\index{Sinic::Device@{Sinic::Device}!ZeroCopyMark@{ZeroCopyMark}}
\index{ZeroCopyMark@{ZeroCopyMark}!Sinic::Device@{Sinic::Device}}
\subsubsection[{ZeroCopyMark}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf ZeroCopyMark}}}
\label{classSinic_1_1Device_a93d85f8e9d6efa8d85cce98ef514c54d}
\hypertarget{classSinic_1_1Device_a0a6cb3337e941db43aff26f90444592a}{
\index{Sinic::Device@{Sinic::Device}!ZeroCopySize@{ZeroCopySize}}
\index{ZeroCopySize@{ZeroCopySize}!Sinic::Device@{Sinic::Device}}
\subsubsection[{ZeroCopySize}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf ZeroCopySize}}}
\label{classSinic_1_1Device_a0a6cb3337e941db43aff26f90444592a}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/\hyperlink{sinic_8hh}{sinic.hh}\item 
dev/\hyperlink{sinic_8cc}{sinic.cc}\end{DoxyCompactItemize}
