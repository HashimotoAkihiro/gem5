\hypertarget{classLRU}{
\section{クラス LRU}
\label{classLRU}\index{LRU@{LRU}}
}


{\ttfamily \#include $<$lru.hh$>$}LRUに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=5cm]{classLRU}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classCacheBlk}{CacheBlk} \hyperlink{classLRU_a005ef3750319995a4a77bcfeee56e222}{BlkType}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classCacheBlk}{BlkType} $\ast$ $>$ \hyperlink{classLRU_a10e9d0cbb622eb6efe1dd332af622902}{BlkList}
\item 
typedef \hyperlink{classCacheSet}{CacheSet}$<$ \hyperlink{classCacheBlk}{CacheBlk} $>$ \hyperlink{classLRU_a3c0e5e439e276493def31913011594ff}{SetType}
\item 
typedef LRUParams \hyperlink{classLRU_a7817e729934956b9b3573d13924bf1eb}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classLRU_ad9acf3c29ee59e97dd4b0b73d560f382}{LRU} (const \hyperlink{classLRU_a7817e729934956b9b3573d13924bf1eb}{Params} $\ast$p)
\item 
virtual \hyperlink{classLRU_a611da3810a76e96c8b574845d82b6b8c}{$\sim$LRU} ()
\item 
unsigned \hyperlink{classLRU_a38301abe4b3689f8ac7de5c13a046234}{getBlockSize} () const 
\item 
unsigned \hyperlink{classLRU_aca3769c95ef908ce22475a69f8929a32}{getSubBlockSize} () const 
\item 
void \hyperlink{classLRU_a11ea27715371eaeb125996e0a9ce14ab}{invalidate} (\hyperlink{classCacheBlk}{BlkType} $\ast$blk)
\item 
\hyperlink{classCacheBlk}{BlkType} $\ast$ \hyperlink{classLRU_a969b41d68459011b652da68b4d5683a9}{accessBlock} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, bool is\_\-secure, \hyperlink{classCycles}{Cycles} \&lat, int context\_\-src)
\item 
\hyperlink{classCacheBlk}{BlkType} $\ast$ \hyperlink{classLRU_a0db6e9d80746c5480efcbba5d6be30da}{findBlock} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, bool is\_\-secure) const 
\item 
\hyperlink{classCacheBlk}{BlkType} $\ast$ \hyperlink{classLRU_ac69a78bca11156aff8773ad59125b55b}{findVictim} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr)
\item 
void \hyperlink{classLRU_a79eef32acfa26685ba4a2f8e89f3f949}{insertBlock} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{classCacheBlk}{BlkType} $\ast$blk)
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classLRU_a3a855eb5b0d8adbf737f25baa15a3d7b}{extractTag} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr) const 
\item 
int \hyperlink{classLRU_a8fdcc1372cb0a5d8e1933bdb0bf7d680}{extractSet} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr) const 
\item 
int \hyperlink{classLRU_aca82d98193a0685a9648acf6127abb1c}{extractBlkOffset} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr) const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classLRU_a73119e914b3b83f88be5bde312855cfe}{blkAlign} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr) const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classLRU_a33c16949fb3c73efb61bca4c90195b7d}{regenerateBlkAddr} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} tag, unsigned set) const 
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classLRU_a0239f3ef0ba6cf7c0460b12d289e6517}{getHitLatency} () const 
\item 
virtual void \hyperlink{classLRU_a522e7dda9c2f4eba2cc1c103887d9265}{clearLocks} ()
\item 
virtual void \hyperlink{classLRU_a1acd4c03e94e57919f1254cc4fa0b059}{cleanupRefs} ()
\item 
virtual std::string \hyperlink{classLRU_ae8a5b5e9e0e6be3b115ee77fa7b4d0c8}{print} () const 
\item 
virtual void \hyperlink{classLRU_a7dd045727ced6181c74934442e2ca33d}{computeStats} ()
\item 
{\footnotesize template$<$typename V $>$ }\\void \hyperlink{classLRU_a2f6fd1256bf2c210092c065ea65b83de}{forEachBlk} (V \&visitor)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
const unsigned \hyperlink{classLRU_accc9cc9a48a59881735c6aab4afc3ceb}{assoc}
\item 
const unsigned \hyperlink{classLRU_a5fd82580355559fd0c858de6292f3bb7}{numSets}
\item 
const bool \hyperlink{classLRU_abcad7d1df4609a3182779b57fc4120ac}{sequentialAccess}
\item 
\hyperlink{classCacheSet}{SetType} $\ast$ \hyperlink{classLRU_af644b16f4706597c8192621b8c58e2ed}{sets}
\item 
\hyperlink{classCacheBlk}{BlkType} $\ast$ \hyperlink{classLRU_adf78a0a96f176dd1b76d59906eda0c7d}{blks}
\item 
uint8\_\-t $\ast$ \hyperlink{classLRU_aec49d2d4de051250b86595f2ac472d42}{dataBlks}
\item 
int \hyperlink{classLRU_a836015c10ab05e1e7c4be79579a50730}{setShift}
\item 
int \hyperlink{classLRU_a782a405572109567b3a79ac934e91632}{tagShift}
\item 
unsigned \hyperlink{classLRU_aaac2f20338ad5e01ac8e2354606777ea}{setMask}
\item 
unsigned \hyperlink{classLRU_a7dcd7050ee7dfacdc9057287efbe3aa6}{blkMask}
\end{DoxyCompactItemize}


\subsection{説明}
A \hyperlink{classLRU}{LRU} cache tag store. \begin{DoxySeeAlso}{参照}
gem5 Memory System 
\end{DoxySeeAlso}


\subsection{型定義}
\hypertarget{classLRU_a10e9d0cbb622eb6efe1dd332af622902}{
\index{LRU@{LRU}!BlkList@{BlkList}}
\index{BlkList@{BlkList}!LRU@{LRU}}
\subsubsection[{BlkList}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf BlkType}$\ast$$>$ {\bf BlkList}}}
\label{classLRU_a10e9d0cbb622eb6efe1dd332af622902}
Typedef for a list of pointers to the local block class. \hypertarget{classLRU_a005ef3750319995a4a77bcfeee56e222}{
\index{LRU@{LRU}!BlkType@{BlkType}}
\index{BlkType@{BlkType}!LRU@{LRU}}
\subsubsection[{BlkType}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf CacheBlk} {\bf BlkType}}}
\label{classLRU_a005ef3750319995a4a77bcfeee56e222}
Typedef the block type used in this tag store. \hypertarget{classLRU_a7817e729934956b9b3573d13924bf1eb}{
\index{LRU@{LRU}!Params@{Params}}
\index{Params@{Params}!LRU@{LRU}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef LRUParams {\bf Params}}}
\label{classLRU_a7817e729934956b9b3573d13924bf1eb}
Convenience typedef. 

\hyperlink{classBaseTags_aab33a5313a7ca07c69f8a4e6e1490375}{BaseTags}を再定義しています。\hypertarget{classLRU_a3c0e5e439e276493def31913011594ff}{
\index{LRU@{LRU}!SetType@{SetType}}
\index{SetType@{SetType}!LRU@{LRU}}
\subsubsection[{SetType}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf CacheSet}$<${\bf CacheBlk}$>$ {\bf SetType}}}
\label{classLRU_a3c0e5e439e276493def31913011594ff}
Typedef the set type used in this tag store. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classLRU_ad9acf3c29ee59e97dd4b0b73d560f382}{
\index{LRU@{LRU}!LRU@{LRU}}
\index{LRU@{LRU}!LRU@{LRU}}
\subsubsection[{LRU}]{\setlength{\rightskip}{0pt plus 5cm}{\bf LRU} (const {\bf Params} $\ast$ {\em p})}}
\label{classLRU_ad9acf3c29ee59e97dd4b0b73d560f382}
Construct and initialize this tag store. 

\begin{Desc}
\item[\hyperlink{todo__todo000081}{TODO}]Make warmup percentage a parameter. \end{Desc}



\begin{DoxyCode}
60     :BaseTags(p), assoc(p->assoc),
61      numSets(p->size / (p->block_size * p->assoc)),
62      sequentialAccess(p->sequential_access)
63 {
64     // Check parameters
65     if (blkSize < 4 || !isPowerOf2(blkSize)) {
66         fatal("Block size must be at least 4 and a power of 2");
67     }
68     if (numSets <= 0 || !isPowerOf2(numSets)) {
69         fatal("# of sets must be non-zero and a power of 2");
70     }
71     if (assoc <= 0) {
72         fatal("associativity must be greater than zero");
73     }
74     if (hitLatency <= 0) {
75         fatal("access latency must be greater than zero");
76     }
77 
78     blkMask = blkSize - 1;
79     setShift = floorLog2(blkSize);
80     setMask = numSets - 1;
81     tagShift = setShift + floorLog2(numSets);
82     warmedUp = false;
84     warmupBound = numSets * assoc;
85 
86     sets = new SetType[numSets];
87     blks = new BlkType[numSets * assoc];
88     // allocate data storage in one big chunk
89     numBlocks = numSets * assoc;
90     dataBlks = new uint8_t[numBlocks * blkSize];
91 
92     unsigned blkIndex = 0;       // index into blks array
93     for (unsigned i = 0; i < numSets; ++i) {
94         sets[i].assoc = assoc;
95 
96         sets[i].blks = new BlkType*[assoc];
97 
98         // link in the data blocks
99         for (unsigned j = 0; j < assoc; ++j) {
100             // locate next cache block
101             BlkType *blk = &blks[blkIndex];
102             blk->data = &dataBlks[blkSize*blkIndex];
103             ++blkIndex;
104 
105             // invalidate new cache block
106             blk->invalidate();
107 
108             //EGH Fix Me : do we need to initialize blk?
109 
110             // Setting the tag to j is just to prevent long chains in the hash
111             // table; won't matter because the block is invalid
112             blk->tag = j;
113             blk->whenReady = 0;
114             blk->isTouched = false;
115             blk->size = blkSize;
116             sets[i].blks[j]=blk;
117             blk->set = i;
118         }
119     }
120 }
\end{DoxyCode}
\hypertarget{classLRU_a611da3810a76e96c8b574845d82b6b8c}{
\index{LRU@{LRU}!$\sim$LRU@{$\sim$LRU}}
\index{$\sim$LRU@{$\sim$LRU}!LRU@{LRU}}
\subsubsection[{$\sim$LRU}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf LRU} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classLRU_a611da3810a76e96c8b574845d82b6b8c}
Destructor 


\begin{DoxyCode}
123 {
124     delete [] dataBlks;
125     delete [] blks;
126     delete [] sets;
127 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classLRU_a969b41d68459011b652da68b4d5683a9}{
\index{LRU@{LRU}!accessBlock@{accessBlock}}
\index{accessBlock@{accessBlock}!LRU@{LRU}}
\subsubsection[{accessBlock}]{\setlength{\rightskip}{0pt plus 5cm}{\bf LRU::BlkType} $\ast$ accessBlock ({\bf Addr} {\em addr}, \/  bool {\em is\_\-secure}, \/  {\bf Cycles} \& {\em lat}, \/  int {\em context\_\-src})}}
\label{classLRU_a969b41d68459011b652da68b4d5683a9}
Access block and update replacement data. May not succeed, in which case NULL pointer is returned. This has all the implications of a cache access and should only be used as such. Returns the access latency as a side effect. 
\begin{DoxyParams}{引数}
\item[{\em addr}]The address to find. \item[{\em is\_\-secure}]True if the target memory space is secure. \item[{\em asid}]The address space ID. \item[{\em lat}]The access latency. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Pointer to the cache block if found. 
\end{DoxyReturn}



\begin{DoxyCode}
131 {
132     Addr tag = extractTag(addr);
133     unsigned set = extractSet(addr);
134     BlkType *blk = sets[set].findBlk(tag, is_secure);
135     lat = hitLatency;
136 
137     // Access all tags in parallel, hence one in each way.  The data side
138     // either accesses all blocks in parallel, or one block sequentially on
139     // a hit.  Sequential access with a miss doesn't access data.
140     tagAccesses += assoc;
141     if (sequentialAccess) {
142         if (blk != NULL) {
143             dataAccesses += 1;
144         }
145     } else {
146         dataAccesses += assoc;
147     }
148 
149     if (blk != NULL) {
150         // move this block to head of the MRU list
151         sets[set].moveToHead(blk);
152         DPRINTF(CacheRepl, "set %x: moving blk %x (%s) to MRU\n",
153                 set, regenerateBlkAddr(tag, set), is_secure ? "s" : "ns");
154         if (blk->whenReady > curTick()
155             && cache->ticksToCycles(blk->whenReady - curTick()) > hitLatency) {
156             lat = cache->ticksToCycles(blk->whenReady - curTick());
157         }
158         blk->refCount += 1;
159     }
160 
161     return blk;
162 }
\end{DoxyCode}
\hypertarget{classLRU_a73119e914b3b83f88be5bde312855cfe}{
\index{LRU@{LRU}!blkAlign@{blkAlign}}
\index{blkAlign@{blkAlign}!LRU@{LRU}}
\subsubsection[{blkAlign}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} blkAlign ({\bf Addr} {\em addr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLRU_a73119e914b3b83f88be5bde312855cfe}
Align an address to the block size. 
\begin{DoxyParams}{引数}
\item[{\em addr}]the address to align. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
The block address. 
\end{DoxyReturn}



\begin{DoxyCode}
220     {
221         return (addr & ~(Addr)blkMask);
222     }
\end{DoxyCode}
\hypertarget{classLRU_a1acd4c03e94e57919f1254cc4fa0b059}{
\index{LRU@{LRU}!cleanupRefs@{cleanupRefs}}
\index{cleanupRefs@{cleanupRefs}!LRU@{LRU}}
\subsubsection[{cleanupRefs}]{\setlength{\rightskip}{0pt plus 5cm}void cleanupRefs ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classLRU_a1acd4c03e94e57919f1254cc4fa0b059}
Called at end of simulation to complete average block reference stats. 

\hyperlink{classBaseTags_aab539ffaf653a007b5326b2042dc8e86}{BaseTags}を再定義しています。


\begin{DoxyCode}
291 {
292     for (unsigned i = 0; i < numSets*assoc; ++i) {
293         if (blks[i].isValid()) {
294             totalRefs += blks[i].refCount;
295             ++sampledRefs;
296         }
297     }
298 }
\end{DoxyCode}
\hypertarget{classLRU_a522e7dda9c2f4eba2cc1c103887d9265}{
\index{LRU@{LRU}!clearLocks@{clearLocks}}
\index{clearLocks@{clearLocks}!LRU@{LRU}}
\subsubsection[{clearLocks}]{\setlength{\rightskip}{0pt plus 5cm}void clearLocks ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classLRU_a522e7dda9c2f4eba2cc1c103887d9265}
iterated through all blocks and clear all locks Needed to clear all lock tracking at once 

\hyperlink{classBaseTags_a9f3e3b80f263780be72db8b9dc53680e}{BaseTags}を再定義しています。


\begin{DoxyCode}
261 {
262     for (int i = 0; i < numBlocks; i++){
263         blks[i].clearLoadLocks();
264     }
265 }
\end{DoxyCode}
\hypertarget{classLRU_a7dd045727ced6181c74934442e2ca33d}{
\index{LRU@{LRU}!computeStats@{computeStats}}
\index{computeStats@{computeStats}!LRU@{LRU}}
\subsubsection[{computeStats}]{\setlength{\rightskip}{0pt plus 5cm}void computeStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classLRU_a7dd045727ced6181c74934442e2ca33d}
Called prior to dumping stats to compute task occupancy 

\hyperlink{classBaseTags_a23fd48fae3a5efe5e8ffbefb54e51c1c}{BaseTags}を再定義しています。


\begin{DoxyCode}
302 {
303     for (unsigned i = 0; i < ContextSwitchTaskId::NumTaskId; ++i) {
304         occupanciesTaskId[i] = 0;
305         for (unsigned j = 0; j < 5; ++j) {
306             ageTaskId[i][j] = 0;
307         }
308     }
309 
310     for (unsigned i = 0; i < numSets * assoc; ++i) {
311         if (blks[i].isValid()) {
312             assert(blks[i].task_id < ContextSwitchTaskId::NumTaskId);
313             occupanciesTaskId[blks[i].task_id]++;
314             Tick age = curTick() - blks[i].tickInserted;
315             assert(age >= 0);
316 
317             int age_index;
318             if (age / SimClock::Int::us < 10) { // <10us
319                 age_index = 0;
320             } else if (age / SimClock::Int::us < 100) { // <100us
321                 age_index = 1;
322             } else if (age / SimClock::Int::ms < 1) { // <1ms
323                 age_index = 2;
324             } else if (age / SimClock::Int::ms < 10) { // <10ms
325                 age_index = 3;
326             } else
327                 age_index = 4; // >10ms
328 
329             ageTaskId[blks[i].task_id][age_index]++;
330         }
331     }
332 }
\end{DoxyCode}
\hypertarget{classLRU_aca82d98193a0685a9648acf6127abb1c}{
\index{LRU@{LRU}!extractBlkOffset@{extractBlkOffset}}
\index{extractBlkOffset@{extractBlkOffset}!LRU@{LRU}}
\subsubsection[{extractBlkOffset}]{\setlength{\rightskip}{0pt plus 5cm}int extractBlkOffset ({\bf Addr} {\em addr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLRU_aca82d98193a0685a9648acf6127abb1c}
Get the block offset from an address. 
\begin{DoxyParams}{引数}
\item[{\em addr}]The address to get the offset of. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
The block offset. 
\end{DoxyReturn}



\begin{DoxyCode}
210     {
211         return (addr & blkMask);
212     }
\end{DoxyCode}
\hypertarget{classLRU_a8fdcc1372cb0a5d8e1933bdb0bf7d680}{
\index{LRU@{LRU}!extractSet@{extractSet}}
\index{extractSet@{extractSet}!LRU@{LRU}}
\subsubsection[{extractSet}]{\setlength{\rightskip}{0pt plus 5cm}int extractSet ({\bf Addr} {\em addr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLRU_a8fdcc1372cb0a5d8e1933bdb0bf7d680}
Calculate the set index from the address. 
\begin{DoxyParams}{引数}
\item[{\em addr}]The address to get the set from. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
The set index of the address. 
\end{DoxyReturn}



\begin{DoxyCode}
200     {
201         return ((addr >> setShift) & setMask);
202     }
\end{DoxyCode}
\hypertarget{classLRU_a3a855eb5b0d8adbf737f25baa15a3d7b}{
\index{LRU@{LRU}!extractTag@{extractTag}}
\index{extractTag@{extractTag}!LRU@{LRU}}
\subsubsection[{extractTag}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} extractTag ({\bf Addr} {\em addr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLRU_a3a855eb5b0d8adbf737f25baa15a3d7b}
Generate the tag from the given address. 
\begin{DoxyParams}{引数}
\item[{\em addr}]The address to get the tag from. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
The tag of the address. 
\end{DoxyReturn}



\begin{DoxyCode}
190     {
191         return (addr >> tagShift);
192     }
\end{DoxyCode}
\hypertarget{classLRU_a0db6e9d80746c5480efcbba5d6be30da}{
\index{LRU@{LRU}!findBlock@{findBlock}}
\index{findBlock@{findBlock}!LRU@{LRU}}
\subsubsection[{findBlock}]{\setlength{\rightskip}{0pt plus 5cm}{\bf LRU::BlkType} $\ast$ findBlock ({\bf Addr} {\em addr}, \/  bool {\em is\_\-secure}) const}}
\label{classLRU_a0db6e9d80746c5480efcbba5d6be30da}
Finds the given address in the cache, do not update replacement data. i.e. This is a no-\/side-\/effect find of a block. 
\begin{DoxyParams}{引数}
\item[{\em addr}]The address to find. \item[{\em is\_\-secure}]True if the target memory space is secure. \item[{\em asid}]The address space ID. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Pointer to the cache block if found. 
\end{DoxyReturn}



\begin{DoxyCode}
167 {
168     Addr tag = extractTag(addr);
169     unsigned set = extractSet(addr);
170     BlkType *blk = sets[set].findBlk(tag, is_secure);
171     return blk;
172 }
\end{DoxyCode}
\hypertarget{classLRU_ac69a78bca11156aff8773ad59125b55b}{
\index{LRU@{LRU}!findVictim@{findVictim}}
\index{findVictim@{findVictim}!LRU@{LRU}}
\subsubsection[{findVictim}]{\setlength{\rightskip}{0pt plus 5cm}{\bf LRU::BlkType} $\ast$ findVictim ({\bf Addr} {\em addr})}}
\label{classLRU_ac69a78bca11156aff8773ad59125b55b}
Find a block to evict for the address provided. 
\begin{DoxyParams}{引数}
\item[{\em addr}]The addr to a find a replacement candidate for. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
The candidate block. 
\end{DoxyReturn}



\begin{DoxyCode}
176 {
177     unsigned set = extractSet(addr);
178     // grab a replacement candidate
179     BlkType *blk = sets[set].blks[assoc-1];
180 
181     if (blk->isValid()) {
182         DPRINTF(CacheRepl, "set %x: selecting blk %x for replacement\n",
183                 set, regenerateBlkAddr(blk->tag, set));
184     }
185     return blk;
186 }
\end{DoxyCode}
\hypertarget{classLRU_a2f6fd1256bf2c210092c065ea65b83de}{
\index{LRU@{LRU}!forEachBlk@{forEachBlk}}
\index{forEachBlk@{forEachBlk}!LRU@{LRU}}
\subsubsection[{forEachBlk}]{\setlength{\rightskip}{0pt plus 5cm}void forEachBlk (V \& {\em visitor})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLRU_a2f6fd1256bf2c210092c065ea65b83de}
Visit each block in the tag store and apply a visitor to the block.

The visitor should be a function (or object that behaves like a function) that takes a cache block reference as its parameter and returns a bool. A visitor can request the traversal to be stopped by returning false, returning true causes it to be called for the next block in the tag store.


\begin{DoxyParams}{引数}
\item[{\em visitor}]Visitor to call on each block. \end{DoxyParams}



\begin{DoxyCode}
277                                 {
278         for (unsigned i = 0; i < numSets * assoc; ++i) {
279             if (!visitor(blks[i]))
280                 return;
281         }
282     }
\end{DoxyCode}
\hypertarget{classLRU_a38301abe4b3689f8ac7de5c13a046234}{
\index{LRU@{LRU}!getBlockSize@{getBlockSize}}
\index{getBlockSize@{getBlockSize}!LRU@{LRU}}
\subsubsection[{getBlockSize}]{\setlength{\rightskip}{0pt plus 5cm}unsigned getBlockSize () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLRU_a38301abe4b3689f8ac7de5c13a046234}
Return the block size. \begin{DoxyReturn}{戻り値}
the block size. 
\end{DoxyReturn}



\begin{DoxyCode}
125     {
126         return blkSize;
127     }
\end{DoxyCode}
\hypertarget{classLRU_a0239f3ef0ba6cf7c0460b12d289e6517}{
\index{LRU@{LRU}!getHitLatency@{getHitLatency}}
\index{getHitLatency@{getHitLatency}!LRU@{LRU}}
\subsubsection[{getHitLatency}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} getHitLatency () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLRU_a0239f3ef0ba6cf7c0460b12d289e6517}
Return the hit latency. \begin{DoxyReturn}{戻り値}
the hit latency. 
\end{DoxyReturn}



\begin{DoxyCode}
240     {
241         return hitLatency;
242     }
\end{DoxyCode}
\hypertarget{classLRU_aca3769c95ef908ce22475a69f8929a32}{
\index{LRU@{LRU}!getSubBlockSize@{getSubBlockSize}}
\index{getSubBlockSize@{getSubBlockSize}!LRU@{LRU}}
\subsubsection[{getSubBlockSize}]{\setlength{\rightskip}{0pt plus 5cm}unsigned getSubBlockSize () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLRU_aca3769c95ef908ce22475a69f8929a32}
Return the subblock size. In the case of \hyperlink{classLRU}{LRU} it is always the block size. \begin{DoxyReturn}{戻り値}
The block size. 
\end{DoxyReturn}



\begin{DoxyCode}
136     {
137         return blkSize;
138     }
\end{DoxyCode}
\hypertarget{classLRU_a79eef32acfa26685ba4a2f8e89f3f949}{
\index{LRU@{LRU}!insertBlock@{insertBlock}}
\index{insertBlock@{insertBlock}!LRU@{LRU}}
\subsubsection[{insertBlock}]{\setlength{\rightskip}{0pt plus 5cm}void insertBlock ({\bf PacketPtr} {\em pkt}, \/  {\bf BlkType} $\ast$ {\em blk})}}
\label{classLRU_a79eef32acfa26685ba4a2f8e89f3f949}
Insert the new block into the cache. For \hyperlink{classLRU}{LRU} this means inserting into the MRU position of the set. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} holding the address to update \item[{\em blk}]The block to update. \end{DoxyParams}



\begin{DoxyCode}
190 {
191     Addr addr = pkt->getAddr();
192     MasterID master_id = pkt->req->masterId();
193     uint32_t task_id = pkt->req->taskId();
194     bool is_secure = pkt->isSecure();
195     if (!blk->isTouched) {
196         tagsInUse++;
197         blk->isTouched = true;
198         if (!warmedUp && tagsInUse.value() >= warmupBound) {
199             warmedUp = true;
200             warmupCycle = curTick();
201         }
202     }
203 
204     // If we're replacing a block that was previously valid update
205     // stats for it. This can't be done in findBlock() because a
206     // found block might not actually be replaced there if the
207     // coherence protocol says it can't be.
208     if (blk->isValid()) {
209         replacements[0]++;
210         totalRefs += blk->refCount;
211         ++sampledRefs;
212         blk->refCount = 0;
213 
214         // deal with evicted block
215         assert(blk->srcMasterId < cache->system->maxMasters());
216         occupancies[blk->srcMasterId]--;
217 
218         blk->invalidate();
219     }
220 
221     blk->isTouched = true;
222     // Set tag for new block.  Caller is responsible for setting status.
223     blk->tag = extractTag(addr);
224     if (is_secure)
225         blk->status |= BlkSecure;
226 
227     // deal with what we are bringing in
228     assert(master_id < cache->system->maxMasters());
229     occupancies[master_id]++;
230     blk->srcMasterId = master_id;
231     blk->task_id = task_id;
232     blk->tickInserted = curTick();
233 
234     unsigned set = extractSet(addr);
235     sets[set].moveToHead(blk);
236 
237     // We only need to write into one tag and one data block.
238     tagAccesses += 1;
239     dataAccesses += 1;
240 }
\end{DoxyCode}
\hypertarget{classLRU_a11ea27715371eaeb125996e0a9ce14ab}{
\index{LRU@{LRU}!invalidate@{invalidate}}
\index{invalidate@{invalidate}!LRU@{LRU}}
\subsubsection[{invalidate}]{\setlength{\rightskip}{0pt plus 5cm}void invalidate ({\bf BlkType} $\ast$ {\em blk})}}
\label{classLRU_a11ea27715371eaeb125996e0a9ce14ab}
Invalidate the given block. 
\begin{DoxyParams}{引数}
\item[{\em blk}]The block to invalidate. \end{DoxyParams}



\begin{DoxyCode}
244 {
245     assert(blk);
246     assert(blk->isValid());
247     tagsInUse--;
248     assert(blk->srcMasterId < cache->system->maxMasters());
249     occupancies[blk->srcMasterId]--;
250     blk->srcMasterId = Request::invldMasterId;
251     blk->task_id = ContextSwitchTaskId::Unknown;
252     blk->tickInserted = curTick();
253 
254     // should be evicted before valid blocks
255     unsigned set = blk->set;
256     sets[set].moveToTail(blk);
257 }
\end{DoxyCode}
\hypertarget{classLRU_ae8a5b5e9e0e6be3b115ee77fa7b4d0c8}{
\index{LRU@{LRU}!print@{print}}
\index{print@{print}!LRU@{LRU}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}std::string print () const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classLRU_ae8a5b5e9e0e6be3b115ee77fa7b4d0c8}
Print all tags used 

\hyperlink{classBaseTags_a56a7c10391fb704ea26efc16f4f4f87b}{BaseTags}を実装しています。


\begin{DoxyCode}
273                  {
274     std::string cache_state;
275     for (unsigned i = 0; i < numSets; ++i) {
276         // link in the data blocks
277         for (unsigned j = 0; j < assoc; ++j) {
278             BlkType *blk = sets[i].blks[j];
279             if (blk->isValid())
280                 cache_state += csprintf("\tset: %d block: %d %s\n", i, j,
281                         blk->print());
282         }
283     }
284     if (cache_state.empty())
285         cache_state = "no valid tags\n";
286     return cache_state;
287 }
\end{DoxyCode}
\hypertarget{classLRU_a33c16949fb3c73efb61bca4c90195b7d}{
\index{LRU@{LRU}!regenerateBlkAddr@{regenerateBlkAddr}}
\index{regenerateBlkAddr@{regenerateBlkAddr}!LRU@{LRU}}
\subsubsection[{regenerateBlkAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} regenerateBlkAddr ({\bf Addr} {\em tag}, \/  unsigned {\em set}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLRU_a33c16949fb3c73efb61bca4c90195b7d}
Regenerate the block address from the tag. 
\begin{DoxyParams}{引数}
\item[{\em tag}]The tag of the block. \item[{\em set}]The set of the block. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
The block address. 
\end{DoxyReturn}



\begin{DoxyCode}
231     {
232         return ((tag << tagShift) | ((Addr)set << setShift));
233     }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classLRU_accc9cc9a48a59881735c6aab4afc3ceb}{
\index{LRU@{LRU}!assoc@{assoc}}
\index{assoc@{assoc}!LRU@{LRU}}
\subsubsection[{assoc}]{\setlength{\rightskip}{0pt plus 5cm}const unsigned {\bf assoc}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLRU_accc9cc9a48a59881735c6aab4afc3ceb}
The associativity of the cache. \hypertarget{classLRU_a7dcd7050ee7dfacdc9057287efbe3aa6}{
\index{LRU@{LRU}!blkMask@{blkMask}}
\index{blkMask@{blkMask}!LRU@{LRU}}
\subsubsection[{blkMask}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf blkMask}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLRU_a7dcd7050ee7dfacdc9057287efbe3aa6}
Mask out all bits that aren't part of the block offset. \hypertarget{classLRU_adf78a0a96f176dd1b76d59906eda0c7d}{
\index{LRU@{LRU}!blks@{blks}}
\index{blks@{blks}!LRU@{LRU}}
\subsubsection[{blks}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BlkType}$\ast$ {\bf blks}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLRU_adf78a0a96f176dd1b76d59906eda0c7d}
The cache blocks. \hypertarget{classLRU_aec49d2d4de051250b86595f2ac472d42}{
\index{LRU@{LRU}!dataBlks@{dataBlks}}
\index{dataBlks@{dataBlks}!LRU@{LRU}}
\subsubsection[{dataBlks}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t$\ast$ {\bf dataBlks}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLRU_aec49d2d4de051250b86595f2ac472d42}
The data blocks, 1 per cache block. \hypertarget{classLRU_a5fd82580355559fd0c858de6292f3bb7}{
\index{LRU@{LRU}!numSets@{numSets}}
\index{numSets@{numSets}!LRU@{LRU}}
\subsubsection[{numSets}]{\setlength{\rightskip}{0pt plus 5cm}const unsigned {\bf numSets}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLRU_a5fd82580355559fd0c858de6292f3bb7}
The number of sets in the cache. \hypertarget{classLRU_abcad7d1df4609a3182779b57fc4120ac}{
\index{LRU@{LRU}!sequentialAccess@{sequentialAccess}}
\index{sequentialAccess@{sequentialAccess}!LRU@{LRU}}
\subsubsection[{sequentialAccess}]{\setlength{\rightskip}{0pt plus 5cm}const bool {\bf sequentialAccess}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLRU_abcad7d1df4609a3182779b57fc4120ac}
Whether tags and data are accessed sequentially. \hypertarget{classLRU_aaac2f20338ad5e01ac8e2354606777ea}{
\index{LRU@{LRU}!setMask@{setMask}}
\index{setMask@{setMask}!LRU@{LRU}}
\subsubsection[{setMask}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf setMask}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLRU_aaac2f20338ad5e01ac8e2354606777ea}
Mask out all bits that aren't part of the set index. \hypertarget{classLRU_af644b16f4706597c8192621b8c58e2ed}{
\index{LRU@{LRU}!sets@{sets}}
\index{sets@{sets}!LRU@{LRU}}
\subsubsection[{sets}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SetType}$\ast$ {\bf sets}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLRU_af644b16f4706597c8192621b8c58e2ed}
The cache sets. \hypertarget{classLRU_a836015c10ab05e1e7c4be79579a50730}{
\index{LRU@{LRU}!setShift@{setShift}}
\index{setShift@{setShift}!LRU@{LRU}}
\subsubsection[{setShift}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf setShift}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLRU_a836015c10ab05e1e7c4be79579a50730}
The amount to shift the address to get the set. \hypertarget{classLRU_a782a405572109567b3a79ac934e91632}{
\index{LRU@{LRU}!tagShift@{tagShift}}
\index{tagShift@{tagShift}!LRU@{LRU}}
\subsubsection[{tagShift}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf tagShift}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLRU_a782a405572109567b3a79ac934e91632}
The amount to shift the address to get the tag. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/cache/tags/\hyperlink{lru_8hh}{lru.hh}\item 
mem/cache/tags/\hyperlink{lru_8cc}{lru.cc}\end{DoxyCompactItemize}
