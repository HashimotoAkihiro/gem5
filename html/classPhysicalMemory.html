<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>File&nbsp;GEM5&nbsp;Wrapper: クラス PhysicalMemory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- 作成： Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>メインページ</span></a></li>
      <li><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>構成</span></a></li>
      <li><a href="classes.html"><span>構成索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>構成メンバ</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>クラス PhysicalMemory</h1><!-- doxytag: class="PhysicalMemory" --><!-- doxytag: inherits="Serializable" -->
<p><code>#include &lt;<a class="el" href="physical_8hh_source.html">physical.hh</a>&gt;</code></p>
<div class="dynheader">
PhysicalMemoryに対する継承グラフ</div>
<div class="dynsection">
 <div class="center">
  <img src="classPhysicalMemory.gif" usemap="#PhysicalMemory_map" alt=""/>
  <map id="PhysicalMemory_map" name="PhysicalMemory_map">
<area href="classSerializable.html" alt="Serializable" shape="rect" coords="0,0,106,24"/>
</map>
 </div>
</div>

<p><a href="classPhysicalMemory-members.html">すべてのメンバ一覧</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a987bb2d4a9b94b62fa15261e024019e5">PhysicalMemory</a> (const std::string &amp;<a class="el" href="classPhysicalMemory.html#aaf2ed934b37cbbd236fdd1b01a5f5005">_name</a>, const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAbstractMemory.html">AbstractMemory</a> * &gt; &amp;_memories)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#ad6a6b96cf5b3ed869b4a6f06429fd4eb">~PhysicalMemory</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a6490f765a824ced1cc94979609fe7e07">name</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a0faeadf06436f8123c7bda01087bb222">isMemAddr</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> addr) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1list.html">AddrRangeList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a564b079bb27347c8bd8430f009539623">getConfAddrRanges</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a990c48a7ad4a4821fe4f04a1e58845a6">totalSize</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classstd_1_1pair.html">std::pair</a><br class="typebreak"/>
&lt; <a class="el" href="classAddrRange.html">AddrRange</a>, uint8_t * &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a57d8785b312d1d1a53c4beb67a019d46">getBackingStore</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#aac5d96736802cb79fb2287135bcc1dff">access</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#ace845b5316308e12fd958fa5df09a8e8">functionalAccess</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a53e036786d17361be4c7320d39c99b84">serialize</a> (std::ostream &amp;os)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#adda88c8306de32c98ea608a0a85c3dcd">serializeStore</a> (std::ostream &amp;os, unsigned int store_id, <a class="el" href="classAddrRange.html">AddrRange</a> range, uint8_t *pmem)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#af22e5d6d660b97db37003ac61ac4ee49">unserialize</a> (<a class="el" href="classCheckpoint.html">Checkpoint</a> *cp, const std::string &amp;section)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#ad180e1b910a31a4f7e6ad1a701c8a286">unserializeStore</a> (<a class="el" href="classCheckpoint.html">Checkpoint</a> *cp, const std::string &amp;section)</td></tr>
<tr><td colspan="2"><h2>Private メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a5247a8a9ca8b14d01253a6861b8b3bf2">PhysicalMemory</a> (const <a class="el" href="classPhysicalMemory.html">PhysicalMemory</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPhysicalMemory.html">PhysicalMemory</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a3ce2a36a848a843e660964c9bc4237e8">operator=</a> (const <a class="el" href="classPhysicalMemory.html">PhysicalMemory</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a4a205bfc337649ce4e62fe5cb5c7579a">createBackingStore</a> (<a class="el" href="classAddrRange.html">AddrRange</a> range, const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAbstractMemory.html">AbstractMemory</a> * &gt; &amp;_memories)</td></tr>
<tr><td colspan="2"><h2>Private 変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#aaf2ed934b37cbbd236fdd1b01a5f5005">_name</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrRangeMap.html">AddrRangeMap</a>&lt; <a class="el" href="classAbstractMemory.html">AbstractMemory</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#ab5cfae3fb0ca282c337c30f0f36ea8d5">addrMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrRange.html">AddrRange</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a356adf3dbde22587d20fa428473a00d6">rangeCache</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAbstractMemory.html">AbstractMemory</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a4c874036afca619454444242943675f4">memories</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#af931a8871310b4dad23f0f0b0f623560">size</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classstd_1_1pair.html">std::pair</a><br class="typebreak"/>
&lt; <a class="el" href="classAddrRange.html">AddrRange</a>, uint8_t * &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a0c347314a9f0b468ed498abaf77bbe44">backingStore</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>説明</h2>
<p>The physical memory encapsulates all memories in the system and provides basic functionality for accessing those memories without going through the memory system and interconnect.</p>
<p>The physical memory is also responsible for providing the host system backingstore used by the memories in the simulated guest system. When the system is created, the physical memory allocates the backing store based on the address ranges that are populated in the system, and does so indepentent of how those map to actual memory controllers. Thus, the physical memory completely abstracts the mapping of the backing store of the host system and the address mapping in the guest system. This enables us to arbitrarily change the number of memory controllers, and their address mapping, as long as the ranges stay the same. </p>
<hr/><h2>コンストラクタとデストラクタ</h2>
<a class="anchor" id="a5247a8a9ca8b14d01253a6861b8b3bf2"></a><!-- doxytag: member="PhysicalMemory::PhysicalMemory" ref="a5247a8a9ca8b14d01253a6861b8b3bf2" args="(const PhysicalMemory &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPhysicalMemory.html">PhysicalMemory</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPhysicalMemory.html">PhysicalMemory</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a987bb2d4a9b94b62fa15261e024019e5"></a><!-- doxytag: member="PhysicalMemory::PhysicalMemory" ref="a987bb2d4a9b94b62fa15261e024019e5" args="(const std::string &amp;_name, const std::vector&lt; AbstractMemory * &gt; &amp;_memories)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPhysicalMemory.html">PhysicalMemory</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAbstractMemory.html">AbstractMemory</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_memories</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a physical memory object, wrapping a number of memories. </p>

</div>
</div>
<a class="anchor" id="ad6a6b96cf5b3ed869b4a6f06429fd4eb"></a><!-- doxytag: member="PhysicalMemory::~PhysicalMemory" ref="ad6a6b96cf5b3ed869b4a6f06429fd4eb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classPhysicalMemory.html">PhysicalMemory</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unmap all the backing store we have used. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00174"></a>00174 {
<a name="l00175"></a>00175     <span class="comment">// unmap the backing store</span>
<a name="l00176"></a>00176     <span class="keywordflow">for</span> (<a class="code" href="classstd_1_1vector.html">vector</a>&lt;<a class="code" href="classstd_1_1pair.html">pair&lt;AddrRange, uint8_t*&gt;</a> &gt;::iterator <a class="code" href="namespaceArmISA.html#afaeb18e17f862d8fcb76dfb68a18854f">s</a> = <a class="code" href="classPhysicalMemory.html#a0c347314a9f0b468ed498abaf77bbe44">backingStore</a>.begin();
<a name="l00177"></a>00177          <a class="code" href="namespaceArmISA.html#afaeb18e17f862d8fcb76dfb68a18854f">s</a> != <a class="code" href="classPhysicalMemory.html#a0c347314a9f0b468ed498abaf77bbe44">backingStore</a>.end(); ++<a class="code" href="namespaceArmISA.html#afaeb18e17f862d8fcb76dfb68a18854f">s</a>)
<a name="l00178"></a>00178         munmap((<span class="keywordtype">char</span>*)<a class="code" href="namespaceArmISA.html#afaeb18e17f862d8fcb76dfb68a18854f">s</a>-&gt;second, <a class="code" href="namespaceArmISA.html#afaeb18e17f862d8fcb76dfb68a18854f">s</a>-&gt;first.size());
<a name="l00179"></a>00179 }
</pre></div></p>

</div>
</div>
<hr/><h2>関数</h2>
<a class="anchor" id="aac5d96736802cb79fb2287135bcc1dff"></a><!-- doxytag: member="PhysicalMemory::access" ref="aac5d96736802cb79fb2287135bcc1dff" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform an untimed memory access and update all the state (e.g. locked addresses) and statistics accordingly. The packet is turned into a response if required.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td><a class="el" href="classPacket.html">Packet</a> performing the access </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00241"></a>00241 {
<a name="l00242"></a>00242     assert(pkt-&gt;<a class="code" href="classPacket.html#af21986d725d75fa8e1b6c83457cd4501">isRequest</a>());
<a name="l00243"></a>00243     <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a> = pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>();
<a name="l00244"></a>00244     <a class="code" href="classAddrRangeMap.html">AddrRangeMap&lt;AbstractMemory*&gt;::const_iterator</a> <a class="code" href="namespaceArmISA.html#afb747b54d0c5e3e4e1763be19ca9373b">m</a> = <a class="code" href="classPhysicalMemory.html#ab5cfae3fb0ca282c337c30f0f36ea8d5">addrMap</a>.<a class="code" href="classAddrRangeMap.html#aa89a64932a83b0166c2d0ef2c3427473">find</a>(addr);
<a name="l00245"></a>00245     assert(m != <a class="code" href="classPhysicalMemory.html#ab5cfae3fb0ca282c337c30f0f36ea8d5">addrMap</a>.<a class="code" href="classAddrRangeMap.html#a350132543d80a1c1e5be844e6d2878ea">end</a>());
<a name="l00246"></a>00246     m-&gt;second-&gt;access(pkt);
<a name="l00247"></a>00247 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4a205bfc337649ce4e62fe5cb5c7579a"></a><!-- doxytag: member="PhysicalMemory::createBackingStore" ref="a4a205bfc337649ce4e62fe5cb5c7579a" args="(AddrRange range, const std::vector&lt; AbstractMemory * &gt; &amp;_memories)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void createBackingStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrRange.html">AddrRange</a>&nbsp;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAbstractMemory.html">AbstractMemory</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_memories</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create the memory region providing the backing store for a given address range that corresponds to a set of memories in the simulated system.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>range</em>&nbsp;</td><td>The address range covered </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>memories</em>&nbsp;</td><td>The memories this range maps to </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00141"></a>00141 {
<a name="l00142"></a>00142     <span class="keywordflow">if</span> (range.<a class="code" href="classAddrRange.html#a5d52a3406dc6afea475c78ce06508afa">interleaved</a>())
<a name="l00143"></a>00143         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;Cannot create backing store for interleaved range %s\n&quot;</span>,
<a name="l00144"></a>00144               range.<a class="code" href="classAddrRange.html#aa48c39f92bc04eded742f5310c74aafe">to_string</a>());
<a name="l00145"></a>00145 
<a name="l00146"></a>00146     <span class="comment">// perform the actual mmap</span>
<a name="l00147"></a>00147     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(BusAddrRanges, <span class="stringliteral">&quot;Creating backing store for range %s with size %d\n&quot;</span>,
<a name="l00148"></a>00148             range.<a class="code" href="classAddrRange.html#aa48c39f92bc04eded742f5310c74aafe">to_string</a>(), range.<a class="code" href="classAddrRange.html#ade0faa4f478bf244b35fb208d640c648">size</a>());
<a name="l00149"></a>00149     <span class="keywordtype">int</span> map_flags = MAP_ANON | MAP_PRIVATE;
<a name="l00150"></a>00150     uint8_t* pmem = (uint8_t*) mmap(<a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>, range.<a class="code" href="classAddrRange.html#ade0faa4f478bf244b35fb208d640c648">size</a>(),
<a name="l00151"></a>00151                                     PROT_READ | PROT_WRITE,
<a name="l00152"></a>00152                                     map_flags, -1, 0);
<a name="l00153"></a>00153 
<a name="l00154"></a>00154     <span class="keywordflow">if</span> (pmem == (uint8_t*) MAP_FAILED) {
<a name="l00155"></a>00155         perror(<span class="stringliteral">&quot;mmap&quot;</span>);
<a name="l00156"></a>00156         <a class="code" href="base_2misc_8hh.html#acad519418dbfdd70c1208711e609c80e">fatal</a>(<span class="stringliteral">&quot;Could not mmap %d bytes for range %s!\n&quot;</span>, range.<a class="code" href="classAddrRange.html#ade0faa4f478bf244b35fb208d640c648">size</a>(),
<a name="l00157"></a>00157               range.<a class="code" href="classAddrRange.html#aa48c39f92bc04eded742f5310c74aafe">to_string</a>());
<a name="l00158"></a>00158     }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160     <span class="comment">// remember this backing store so we can checkpoint it and unmap</span>
<a name="l00161"></a>00161     <span class="comment">// it appropriately</span>
<a name="l00162"></a>00162     <a class="code" href="classPhysicalMemory.html#a0c347314a9f0b468ed498abaf77bbe44">backingStore</a>.push_back(make_pair(range, pmem));
<a name="l00163"></a>00163 
<a name="l00164"></a>00164     <span class="comment">// point the memories to their backing store</span>
<a name="l00165"></a>00165     <span class="keywordflow">for</span> (<a class="code" href="classstd_1_1vector.html">vector&lt;AbstractMemory*&gt;::const_iterator</a> <a class="code" href="namespaceArmISA.html#afb747b54d0c5e3e4e1763be19ca9373b">m</a> = _memories.begin();
<a name="l00166"></a>00166          <a class="code" href="namespaceArmISA.html#afb747b54d0c5e3e4e1763be19ca9373b">m</a> != _memories.end(); ++<a class="code" href="namespaceArmISA.html#afb747b54d0c5e3e4e1763be19ca9373b">m</a>) {
<a name="l00167"></a>00167         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(BusAddrRanges, <span class="stringliteral">&quot;Mapping memory %s to backing store\n&quot;</span>,
<a name="l00168"></a>00168                 (*m)-&gt;name());
<a name="l00169"></a>00169         (*m)-&gt;setBackingStore(pmem);
<a name="l00170"></a>00170     }
<a name="l00171"></a>00171 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ace845b5316308e12fd958fa5df09a8e8"></a><!-- doxytag: member="PhysicalMemory::functionalAccess" ref="ace845b5316308e12fd958fa5df09a8e8" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void functionalAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform an untimed memory read or write without changing anything but the memory itself. No stats are affected by this access. In addition to normal accesses this also facilitates print requests.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td><a class="el" href="classPacket.html">Packet</a> performing the access </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00251"></a>00251 {
<a name="l00252"></a>00252     assert(pkt-&gt;<a class="code" href="classPacket.html#af21986d725d75fa8e1b6c83457cd4501">isRequest</a>());
<a name="l00253"></a>00253     <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a> = pkt-&gt;<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>();
<a name="l00254"></a>00254     <a class="code" href="classAddrRangeMap.html">AddrRangeMap&lt;AbstractMemory*&gt;::const_iterator</a> <a class="code" href="namespaceArmISA.html#afb747b54d0c5e3e4e1763be19ca9373b">m</a> = <a class="code" href="classPhysicalMemory.html#ab5cfae3fb0ca282c337c30f0f36ea8d5">addrMap</a>.<a class="code" href="classAddrRangeMap.html#aa89a64932a83b0166c2d0ef2c3427473">find</a>(addr);
<a name="l00255"></a>00255     assert(m != <a class="code" href="classPhysicalMemory.html#ab5cfae3fb0ca282c337c30f0f36ea8d5">addrMap</a>.<a class="code" href="classAddrRangeMap.html#a350132543d80a1c1e5be844e6d2878ea">end</a>());
<a name="l00256"></a>00256     m-&gt;second-&gt;functionalAccess(pkt);
<a name="l00257"></a>00257 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a57d8785b312d1d1a53c4beb67a019d46"></a><!-- doxytag: member="PhysicalMemory::getBackingStore" ref="a57d8785b312d1d1a53c4beb67a019d46" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="classstd_1_1pair.html">std::pair</a>&lt;<a class="el" href="classAddrRange.html">AddrRange</a>, uint8_t*&gt; &gt; getBackingStore </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the pointers to the backing store for external host access. Note that memory in the guest should be accessed using <a class="el" href="classPhysicalMemory.html#aac5d96736802cb79fb2287135bcc1dff">access()</a> or <a class="el" href="classPhysicalMemory.html#ace845b5316308e12fd958fa5df09a8e8">functionalAccess()</a>. This interface is primarily intended for CPU models using hardware virtualization. Note that memories that are null are not present, and that the backing store may also contain memories that are not part of the OS-visible global address map and thus are allowed to overlap.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Pointers to the memory backing store </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00166"></a>00166     { <span class="keywordflow">return</span> <a class="code" href="classPhysicalMemory.html#a0c347314a9f0b468ed498abaf77bbe44">backingStore</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a564b079bb27347c8bd8430f009539623"></a><!-- doxytag: member="PhysicalMemory::getConfAddrRanges" ref="a564b079bb27347c8bd8430f009539623" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1list.html">AddrRangeList</a> getConfAddrRanges </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the memory ranges for all memories that are to be reported to the configuration table. The ranges are merged before they are returned such that any interleaved ranges appear as a single range.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>All configuration table memory ranges </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00204"></a>00204 {
<a name="l00205"></a>00205     <span class="comment">// this could be done once in the constructor, but since it is unlikely to</span>
<a name="l00206"></a>00206     <span class="comment">// be called more than once the iteration should not be a problem</span>
<a name="l00207"></a>00207     <a class="code" href="classstd_1_1list.html">AddrRangeList</a> ranges;
<a name="l00208"></a>00208     <a class="code" href="classstd_1_1vector.html">vector&lt;AddrRange&gt;</a> intlv_ranges;
<a name="l00209"></a>00209     <span class="keywordflow">for</span> (<a class="code" href="classAddrRangeMap.html">AddrRangeMap&lt;AbstractMemory*&gt;::const_iterator</a> <a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a> = <a class="code" href="classPhysicalMemory.html#ab5cfae3fb0ca282c337c30f0f36ea8d5">addrMap</a>.<a class="code" href="classAddrRangeMap.html#aa4b02d4f1a8500fb07a551069060709f">begin</a>();
<a name="l00210"></a>00210          <a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a> != <a class="code" href="classPhysicalMemory.html#ab5cfae3fb0ca282c337c30f0f36ea8d5">addrMap</a>.<a class="code" href="classAddrRangeMap.html#a350132543d80a1c1e5be844e6d2878ea">end</a>(); ++<a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a>) {
<a name="l00211"></a>00211         <span class="keywordflow">if</span> (<a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a>-&gt;second-&gt;isConfReported()) {
<a name="l00212"></a>00212             <span class="comment">// if the range is interleaved then save it for now</span>
<a name="l00213"></a>00213             <span class="keywordflow">if</span> (<a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a>-&gt;first.interleaved()) {
<a name="l00214"></a>00214                 <span class="comment">// if we already got interleaved ranges that are not</span>
<a name="l00215"></a>00215                 <span class="comment">// part of the same range, then first do a merge</span>
<a name="l00216"></a>00216                 <span class="comment">// before we add the new one</span>
<a name="l00217"></a>00217                 <span class="keywordflow">if</span> (!intlv_ranges.empty() &amp;&amp;
<a name="l00218"></a>00218                     !intlv_ranges.back().mergesWith(<a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a>-&gt;first)) {
<a name="l00219"></a>00219                     ranges.push_back(<a class="code" href="classAddrRange.html">AddrRange</a>(intlv_ranges));
<a name="l00220"></a>00220                     intlv_ranges.clear();
<a name="l00221"></a>00221                 }
<a name="l00222"></a>00222                 intlv_ranges.push_back(<a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a>-&gt;first);
<a name="l00223"></a>00223             } <span class="keywordflow">else</span> {
<a name="l00224"></a>00224                 <span class="comment">// keep the current range</span>
<a name="l00225"></a>00225                 ranges.push_back(<a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a>-&gt;first);
<a name="l00226"></a>00226             }
<a name="l00227"></a>00227         }
<a name="l00228"></a>00228     }
<a name="l00229"></a>00229 
<a name="l00230"></a>00230     <span class="comment">// if there is still interleaved ranges waiting to be merged,</span>
<a name="l00231"></a>00231     <span class="comment">// go ahead and do it</span>
<a name="l00232"></a>00232     <span class="keywordflow">if</span> (!intlv_ranges.empty()) {
<a name="l00233"></a>00233         ranges.push_back(<a class="code" href="classAddrRange.html">AddrRange</a>(intlv_ranges));
<a name="l00234"></a>00234     }
<a name="l00235"></a>00235 
<a name="l00236"></a>00236     <span class="keywordflow">return</span> ranges;
<a name="l00237"></a>00237 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0faeadf06436f8123c7bda01087bb222"></a><!-- doxytag: member="PhysicalMemory::isMemAddr" ref="a0faeadf06436f8123c7bda01087bb222" args="(Addr addr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isMemAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classCheck.html">Check</a> if a physical address is within a range of a memory that is part of the global address map.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>A physical address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Whether the address corresponds to a memory </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00183"></a>00183 {
<a name="l00184"></a>00184     <span class="comment">// see if the address is within the last matched range</span>
<a name="l00185"></a>00185     <span class="keywordflow">if</span> (!<a class="code" href="classPhysicalMemory.html#a356adf3dbde22587d20fa428473a00d6">rangeCache</a>.<a class="code" href="classAddrRange.html#aa839dbf0ffc0e871a3f08f1d23d78a18">contains</a>(<a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a>)) {
<a name="l00186"></a>00186         <span class="comment">// lookup in the interval tree</span>
<a name="l00187"></a>00187         <a class="code" href="classAddrRangeMap.html">AddrRangeMap&lt;AbstractMemory*&gt;::const_iterator</a> <a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a> = <a class="code" href="classPhysicalMemory.html#ab5cfae3fb0ca282c337c30f0f36ea8d5">addrMap</a>.<a class="code" href="classAddrRangeMap.html#aa89a64932a83b0166c2d0ef2c3427473">find</a>(<a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a>);
<a name="l00188"></a>00188         <span class="keywordflow">if</span> (r == <a class="code" href="classPhysicalMemory.html#ab5cfae3fb0ca282c337c30f0f36ea8d5">addrMap</a>.<a class="code" href="classAddrRangeMap.html#a350132543d80a1c1e5be844e6d2878ea">end</a>()) {
<a name="l00189"></a>00189             <span class="comment">// not in the cache, and not in the tree</span>
<a name="l00190"></a>00190             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00191"></a>00191         }
<a name="l00192"></a>00192         <span class="comment">// the range is in the tree, update the cache</span>
<a name="l00193"></a>00193         <a class="code" href="classPhysicalMemory.html#a356adf3dbde22587d20fa428473a00d6">rangeCache</a> = r-&gt;first;
<a name="l00194"></a>00194     }
<a name="l00195"></a>00195 
<a name="l00196"></a>00196     assert(<a class="code" href="classPhysicalMemory.html#ab5cfae3fb0ca282c337c30f0f36ea8d5">addrMap</a>.<a class="code" href="classAddrRangeMap.html#aa89a64932a83b0166c2d0ef2c3427473">find</a>(<a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a>) != <a class="code" href="classPhysicalMemory.html#ab5cfae3fb0ca282c337c30f0f36ea8d5">addrMap</a>.<a class="code" href="classAddrRangeMap.html#a350132543d80a1c1e5be844e6d2878ea">end</a>());
<a name="l00197"></a>00197 
<a name="l00198"></a>00198     <span class="comment">// either matched the cache or found in the tree</span>
<a name="l00199"></a>00199     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00200"></a>00200 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6490f765a824ced1cc94979609fe7e07"></a><!-- doxytag: member="PhysicalMemory::name" ref="a6490f765a824ced1cc94979609fe7e07" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string name </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the name for debugging and for creation of sections for checkpointing. </p>

<p><a class="el" href="classSerializable.html#a2d319721a65496069642871a52e47056">Serializable</a>を実装しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00125"></a>00125 { <span class="keywordflow">return</span> <a class="code" href="classPhysicalMemory.html#aaf2ed934b37cbbd236fdd1b01a5f5005">_name</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3ce2a36a848a843e660964c9bc4237e8"></a><!-- doxytag: member="PhysicalMemory::operator=" ref="a3ce2a36a848a843e660964c9bc4237e8" args="(const PhysicalMemory &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPhysicalMemory.html">PhysicalMemory</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPhysicalMemory.html">PhysicalMemory</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a53e036786d17361be4c7320d39c99b84"></a><!-- doxytag: member="PhysicalMemory::serialize" ref="a53e036786d17361be4c7320d39c99b84" args="(std::ostream &amp;os)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serialize </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Serialize all the memories in the system. This is independent of the logical memory layout, and the serialization only sees the contigous backing store, independent of how this maps to logical memories in the guest system.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>stream to serialize to </td></tr>
  </table>
  </dd>
</dl>

<p><a class="el" href="classSerializable.html#ad6272f80ae37e8331e3969b3f072a801">Serializable</a>を再定義しています。</p>

</div>
</div>
<a class="anchor" id="adda88c8306de32c98ea608a0a85c3dcd"></a><!-- doxytag: member="PhysicalMemory::serializeStore" ref="adda88c8306de32c98ea608a0a85c3dcd" args="(std::ostream &amp;os, unsigned int store_id, AddrRange range, uint8_t *pmem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serializeStore </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>store_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAddrRange.html">AddrRange</a>&nbsp;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>pmem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Serialize a specific store.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>store_id</em>&nbsp;</td><td>Unique identifier of this backing store </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>range</em>&nbsp;</td><td>The address range of this backing store </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pmem</em>&nbsp;</td><td>The host pointer to this backing store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a990c48a7ad4a4821fe4f04a1e58845a6"></a><!-- doxytag: member="PhysicalMemory::totalSize" ref="a990c48a7ad4a4821fe4f04a1e58845a6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t totalSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the total physical memory size.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>The sum of all memory sizes </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00151"></a>00151 { <span class="keywordflow">return</span> <a class="code" href="classPhysicalMemory.html#af931a8871310b4dad23f0f0b0f623560">size</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af22e5d6d660b97db37003ac61ac4ee49"></a><!-- doxytag: member="PhysicalMemory::unserialize" ref="af22e5d6d660b97db37003ac61ac4ee49" args="(Checkpoint *cp, const std::string &amp;section)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unserialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCheckpoint.html">Checkpoint</a> *&nbsp;</td>
          <td class="paramname"> <em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>section</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unserialize the memories in the system. As with the serialization, this action is independent of how the address ranges are mapped to logical memories in the guest system. </p>

<p><a class="el" href="classSerializable.html#af100c4e9feabf3cd918619c88c718387">Serializable</a>を再定義しています。</p>

</div>
</div>
<a class="anchor" id="ad180e1b910a31a4f7e6ad1a701c8a286"></a><!-- doxytag: member="PhysicalMemory::unserializeStore" ref="ad180e1b910a31a4f7e6ad1a701c8a286" args="(Checkpoint *cp, const std::string &amp;section)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unserializeStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCheckpoint.html">Checkpoint</a> *&nbsp;</td>
          <td class="paramname"> <em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>section</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unserialize a specific backing store, identified by a section. </p>

</div>
</div>
<hr/><h2>変数</h2>
<a class="anchor" id="aaf2ed934b37cbbd236fdd1b01a5f5005"></a><!-- doxytag: member="PhysicalMemory::_name" ref="aaf2ed934b37cbbd236fdd1b01a5f5005" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classPhysicalMemory.html#aaf2ed934b37cbbd236fdd1b01a5f5005">_name</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab5cfae3fb0ca282c337c30f0f36ea8d5"></a><!-- doxytag: member="PhysicalMemory::addrMap" ref="ab5cfae3fb0ca282c337c30f0f36ea8d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrRangeMap.html">AddrRangeMap</a>&lt;<a class="el" href="classAbstractMemory.html">AbstractMemory</a>*&gt; <a class="el" href="classPhysicalMemory.html#ab5cfae3fb0ca282c337c30f0f36ea8d5">addrMap</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0c347314a9f0b468ed498abaf77bbe44"></a><!-- doxytag: member="PhysicalMemory::backingStore" ref="a0c347314a9f0b468ed498abaf77bbe44" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="classstd_1_1pair.html">std::pair</a>&lt;<a class="el" href="classAddrRange.html">AddrRange</a>, uint8_t*&gt; &gt; <a class="el" href="classPhysicalMemory.html#a0c347314a9f0b468ed498abaf77bbe44">backingStore</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4c874036afca619454444242943675f4"></a><!-- doxytag: member="PhysicalMemory::memories" ref="a4c874036afca619454444242943675f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="classAbstractMemory.html">AbstractMemory</a>*&gt; <a class="el" href="classPhysicalMemory.html#a4c874036afca619454444242943675f4">memories</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a356adf3dbde22587d20fa428473a00d6"></a><!-- doxytag: member="PhysicalMemory::rangeCache" ref="a356adf3dbde22587d20fa428473a00d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrRange.html">AddrRange</a> <a class="el" href="classPhysicalMemory.html#a356adf3dbde22587d20fa428473a00d6">rangeCache</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af931a8871310b4dad23f0f0b0f623560"></a><!-- doxytag: member="PhysicalMemory::size" ref="af931a8871310b4dad23f0f0b0f623560" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classPhysicalMemory.html#af931a8871310b4dad23f0f0b0f623560">size</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>このクラスの説明は次のファイルから生成されました:<ul>
<li>mem/<a class="el" href="physical_8hh_source.html">physical.hh</a></li>
<li>mem/<a class="el" href="physical_8cc.html">physical.cc</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>File&nbsp;GEM5&nbsp;Wrapperに対して25 May 2015に生成されました。&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
