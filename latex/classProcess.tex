\hypertarget{classProcess}{
\section{クラス Process}
\label{classProcess}\index{Process@{Process}}
}


{\ttfamily \#include $<$process.hh$>$}Processに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.58235cm]{classProcess}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classProcess_1_1FdMap}{FdMap}
\item 
class \hyperlink{classProcess_1_1LiveProcess}{LiveProcess}
\item 
class \hyperlink{classProcess_1_1Process}{Process}
\item 
struct \hyperlink{structProcess_1_1WaitRec}{WaitRec}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
unsigned int \hyperlink{classProcess_ac5c70b967092e10582ce2f165e174890}{numCpus} ()
\item 
virtual void \hyperlink{classProcess_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classProcess_aec797e960b8c534f9105fbd4ee83f2c7}{assignThreadContext} (int context\_\-id)
\item 
\hyperlink{classThreadContext}{ThreadContext} $\ast$ \hyperlink{classProcess_ac26b4f23be05f684886e00f4f7526a0e}{findFreeContext} ()
\item 
virtual const char $\ast$ \hyperlink{classProcess_a580745d5543eb666c37e2a5f37fb32a0}{progName} () const 
\item 
void \hyperlink{classProcess_a292e48ab06f50224924454b6c74c90e4}{dup\_\-fd} (int sim\_\-fd, int tgt\_\-fd)
\item 
int \hyperlink{classProcess_aa98d99fb9a7db11be09b4e5b818d1795}{alloc\_\-fd} (int sim\_\-fd, std::string filename, int flags, int mode, bool pipe)
\item 
void \hyperlink{classProcess_a8c39614271eb6220f2db1bd774f43849}{free\_\-fd} (int tgt\_\-fd)
\item 
int \hyperlink{classProcess_ac7bb7ef35884d6fb4a2c02f167ab7679}{sim\_\-fd} (int tgt\_\-fd)
\item 
\hyperlink{classProcess_1_1FdMap}{FdMap} $\ast$ \hyperlink{classProcess_ac12196dd197c6731a021e211a95edb2d}{sim\_\-fd\_\-obj} (int tgt\_\-fd)
\item 
void \hyperlink{classProcess_a65bfd573cf5c576db37f79195adb9cbc}{fix\_\-file\_\-offsets} ()
\item 
void \hyperlink{classProcess_aec771386421777782ca6bec97dd93db3}{find\_\-file\_\-offsets} ()
\item 
void \hyperlink{classProcess_a06811a348d456174f7ad9f2b8f03a129}{setReadPipeSource} (int read\_\-pipe\_\-fd, int source\_\-fd)
\item 
virtual void \hyperlink{classProcess_a0abb4f4856f531e5b48484f5114a5bf9}{syscall} (int64\_\-t callnum, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)=0
\item 
void \hyperlink{classProcess_aaebf8af407502fcc035e598795f77089}{allocateMem} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vaddr, int64\_\-t size, bool clobber=false)
\item 
bool \hyperlink{classProcess_a5bfc8cca2ce6b8a330e0c209468e5f71}{fixupStackFault} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vaddr)
\item 
bool \hyperlink{classProcess_ac2bb68c3c87d0a046f848f537abb23fc}{map} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vaddr, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} paddr, int size)
\item 
void \hyperlink{classProcess_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
void \hyperlink{classProcess_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Static Public メソッド}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{classProcess_acea5ecbb223871b0d852b03b68837461}{openInputFile} (const std::string \&filename)
\item 
static int \hyperlink{classProcess_a230c9c6213b49eef2273fa99e3a511ba}{openOutputFile} (const std::string \&filename)
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSystem}{System} $\ast$ \hyperlink{classProcess_af27ccd765f13a4b7bd119dc7579e2746}{system}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ int $>$ \hyperlink{classProcess_a64a72121f39c3cbc68bb1b863c3f43ed}{contextIds}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{structProcess_1_1WaitRec}{WaitRec} $>$ \hyperlink{classProcess_a8af61364ae9c966602b3b5ec1c0f7f09}{waitList}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classProcess_aa0d3d9ff2a6fcb719d3b83226bb50638}{brk\_\-point}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classProcess_a9301d238f8ee69de69d9a608f23b0ee2}{stack\_\-base}
\item 
unsigned \hyperlink{classProcess_a846e164ff6493f2b7001b0adc9dfe535}{stack\_\-size}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classProcess_a03ca56edd14eafca9beec28c150e05a6}{stack\_\-min}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classProcess_a02d0240a7f8b3d791b54cd01f9370121}{max\_\-stack\_\-size}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classProcess_a55a3705006af6c58cba9f9a23ba89864}{next\_\-thread\_\-stack\_\-base}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classProcess_a39ba573f8e6f0a0f33a82245af695ffc}{mmap\_\-start}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classProcess_a41a18edd0dbae5a7bb12e20a30c2e3e1}{mmap\_\-end}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classProcess_a2e51a258c95c46a8e3b3b4c2c74795e6}{nxm\_\-start}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classProcess_aa47cd9dfc4d79b68bb78ee4b10b8298d}{nxm\_\-end}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classProcess_a71ce639346bf9b5caabdf218544e302a}{num\_\-syscalls}
\item 
uint64\_\-t \hyperlink{classProcess_a570045a30dc7f4c596f2fa18dfdfbed5}{M5\_\-pid}
\item 
\hyperlink{classPageTable}{PageTable} $\ast$ \hyperlink{classProcess_ad14ffa23ad731f6003755b643f999049}{pTable}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classProcess_a2c30075e49c804623c22b25934cfa02a}{Process} (ProcessParams $\ast$params)
\item 
virtual void \hyperlink{classProcess_a3c34ea9b29f410748d4435a667484924}{initState} ()
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSETranslatingPortProxy}{SETranslatingPortProxy} \hyperlink{classProcess_a280be1c93dee29cd2c6d5d1502c60a9b}{initVirtMem}
\begin{DoxyCompactList}\small\item\em Memory proxy for initialization (image loading). \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classProcess_1_1FdMap}{FdMap} \hyperlink{classProcess_ad817e277dc908ed0f32c4180c5ddb350}{fd\_\-map} \mbox{[}\hyperlink{classProcess_a2a18c1a4811677d6adabab2287226bb1}{MAX\_\-FD}+1\mbox{]}
\end{DoxyCompactItemize}
\subsection*{Static Private 変数}
\begin{DoxyCompactItemize}
\item 
static const int \hyperlink{classProcess_a2a18c1a4811677d6adabab2287226bb1}{MAX\_\-FD} = 256
\end{DoxyCompactItemize}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classProcess_a2c30075e49c804623c22b25934cfa02a}{
\index{Process@{Process}!Process@{Process}}
\index{Process@{Process}!Process@{Process}}
\subsubsection[{Process}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Process} (ProcessParams $\ast$ {\em params})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classProcess_a2c30075e49c804623c22b25934cfa02a}



\begin{DoxyCode}
104     : SimObject(params), system(params->system),
105       max_stack_size(params->max_stack_size),
106       M5_pid(system->allocatePID()),
107       pTable(new PageTable(name(), M5_pid)),
108       initVirtMem(system->getSystemPort(), this,
109                   SETranslatingPortProxy::Always)
110 {
111     string in = params->input;
112     string out = params->output;
113     string err = params->errout;
114 
115     // initialize file descriptors to default: same as simulator
116     int stdin_fd, stdout_fd, stderr_fd;
117 
118     if (in == "stdin" || in == "cin")
119         stdin_fd = STDIN_FILENO;
120     else if (in == "None")
121         stdin_fd = -1;
122     else
123         stdin_fd = Process::openInputFile(in);
124 
125     if (out == "stdout" || out == "cout")
126         stdout_fd = STDOUT_FILENO;
127     else if (out == "stderr" || out == "cerr")
128         stdout_fd = STDERR_FILENO;
129     else if (out == "None")
130         stdout_fd = -1;
131     else
132         stdout_fd = Process::openOutputFile(out);
133 
134     if (err == "stdout" || err == "cout")
135         stderr_fd = STDOUT_FILENO;
136     else if (err == "stderr" || err == "cerr")
137         stderr_fd = STDERR_FILENO;
138     else if (err == "None")
139         stderr_fd = -1;
140     else if (err == out)
141         stderr_fd = stdout_fd;
142     else
143         stderr_fd = Process::openOutputFile(err);
144 
145     // initialize first 3 fds (stdin, stdout, stderr)
146     Process::FdMap *fdo = &fd_map[STDIN_FILENO];
147     fdo->fd = stdin_fd;
148     fdo->filename = in;
149     fdo->flags = O_RDONLY;
150     fdo->mode = -1;
151     fdo->fileOffset = 0;
152 
153     fdo =  &fd_map[STDOUT_FILENO];
154     fdo->fd = stdout_fd;
155     fdo->filename = out;
156     fdo->flags =  O_WRONLY | O_CREAT | O_TRUNC;
157     fdo->mode = 0774;
158     fdo->fileOffset = 0;
159 
160     fdo = &fd_map[STDERR_FILENO];
161     fdo->fd = stderr_fd;
162     fdo->filename = err;
163     fdo->flags = O_WRONLY;
164     fdo->mode = -1;
165     fdo->fileOffset = 0;
166 
167 
168     // mark remaining fds as free
169     for (int i = 3; i <= MAX_FD; ++i) {
170         fdo = &fd_map[i];
171         fdo->fd = -1;
172     }
173 
174     mmap_start = mmap_end = 0;
175     nxm_start = nxm_end = 0;
176     // other parameters will be initialized when the program is loaded
177 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classProcess_aa98d99fb9a7db11be09b4e5b818d1795}{
\index{Process@{Process}!alloc\_\-fd@{alloc\_\-fd}}
\index{alloc\_\-fd@{alloc\_\-fd}!Process@{Process}}
\subsubsection[{alloc\_\-fd}]{\setlength{\rightskip}{0pt plus 5cm}int alloc\_\-fd (int {\em sim\_\-fd}, \/  std::string {\em filename}, \/  int {\em flags}, \/  int {\em mode}, \/  bool {\em pipe})}}
\label{classProcess_aa98d99fb9a7db11be09b4e5b818d1795}
\hypertarget{classProcess_aaebf8af407502fcc035e598795f77089}{
\index{Process@{Process}!allocateMem@{allocateMem}}
\index{allocateMem@{allocateMem}!Process@{Process}}
\subsubsection[{allocateMem}]{\setlength{\rightskip}{0pt plus 5cm}void allocateMem ({\bf Addr} {\em vaddr}, \/  int64\_\-t {\em size}, \/  bool {\em clobber} = {\ttfamily false})}}
\label{classProcess_aaebf8af407502fcc035e598795f77089}



\begin{DoxyCode}
329 {
330     int npages = divCeil(size, (int64_t)VMPageSize);
331     Addr paddr = system->allocPhysPages(npages);
332     pTable->map(vaddr, paddr, size, clobber);
333 }
\end{DoxyCode}
\hypertarget{classProcess_aec797e960b8c534f9105fbd4ee83f2c7}{
\index{Process@{Process}!assignThreadContext@{assignThreadContext}}
\index{assignThreadContext@{assignThreadContext}!Process@{Process}}
\subsubsection[{assignThreadContext}]{\setlength{\rightskip}{0pt plus 5cm}void assignThreadContext (int {\em context\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classProcess_aec797e960b8c534f9105fbd4ee83f2c7}



\begin{DoxyCode}
170     {
171         contextIds.push_back(context_id);
172     }
\end{DoxyCode}
\hypertarget{classProcess_a292e48ab06f50224924454b6c74c90e4}{
\index{Process@{Process}!dup\_\-fd@{dup\_\-fd}}
\index{dup\_\-fd@{dup\_\-fd}!Process@{Process}}
\subsubsection[{dup\_\-fd}]{\setlength{\rightskip}{0pt plus 5cm}void dup\_\-fd (int {\em sim\_\-fd}, \/  int {\em tgt\_\-fd})}}
\label{classProcess_a292e48ab06f50224924454b6c74c90e4}



\begin{DoxyCode}
254 {
255     if (tgt_fd < 0 || tgt_fd > MAX_FD)
256         panic("Process::dup_fd tried to dup past MAX_FD (%d)", tgt_fd);
257 
258     Process::FdMap *fdo = &fd_map[tgt_fd];
259     fdo->fd = sim_fd;
260 }
\end{DoxyCode}
\hypertarget{classProcess_aec771386421777782ca6bec97dd93db3}{
\index{Process@{Process}!find\_\-file\_\-offsets@{find\_\-file\_\-offsets}}
\index{find\_\-file\_\-offsets@{find\_\-file\_\-offsets}!Process@{Process}}
\subsubsection[{find\_\-file\_\-offsets}]{\setlength{\rightskip}{0pt plus 5cm}void find\_\-file\_\-offsets ()}}
\label{classProcess_aec771386421777782ca6bec97dd93db3}



\begin{DoxyCode}
458 {
459     for (int free_fd = 0; free_fd <= MAX_FD; ++free_fd) {
460         Process::FdMap *fdo = &fd_map[free_fd];
461         if (fdo->fd != -1) {
462             fdo->fileOffset = lseek(fdo->fd, 0, SEEK_CUR);
463         } else {
464                 fdo->filename = "NULL";
465                 fdo->fileOffset = 0;
466         }
467     }
468 }
\end{DoxyCode}
\hypertarget{classProcess_ac26b4f23be05f684886e00f4f7526a0e}{
\index{Process@{Process}!findFreeContext@{findFreeContext}}
\index{findFreeContext@{findFreeContext}!Process@{Process}}
\subsubsection[{findFreeContext}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadContext} $\ast$ findFreeContext ()}}
\label{classProcess_ac26b4f23be05f684886e00f4f7526a0e}



\begin{DoxyCode}
225 {
226     int size = contextIds.size();
227     ThreadContext *tc;
228     for (int i = 0; i < size; ++i) {
229         tc = system->getThreadContext(contextIds[i]);
230         if (tc->status() == ThreadContext::Halted) {
231             // inactive context, free to use
232             return tc;
233         }
234     }
235     return NULL;
236 }
\end{DoxyCode}
\hypertarget{classProcess_a65bfd573cf5c576db37f79195adb9cbc}{
\index{Process@{Process}!fix\_\-file\_\-offsets@{fix\_\-file\_\-offsets}}
\index{fix\_\-file\_\-offsets@{fix\_\-file\_\-offsets}!Process@{Process}}
\subsubsection[{fix\_\-file\_\-offsets}]{\setlength{\rightskip}{0pt plus 5cm}void fix\_\-file\_\-offsets ()}}
\label{classProcess_a65bfd573cf5c576db37f79195adb9cbc}



\begin{DoxyCode}
363 {
364     Process::FdMap *fdo_stdin = &fd_map[STDIN_FILENO];
365     Process::FdMap *fdo_stdout = &fd_map[STDOUT_FILENO];
366     Process::FdMap *fdo_stderr = &fd_map[STDERR_FILENO];
367     string in = fdo_stdin->filename;
368     string out = fdo_stdout->filename;
369     string err = fdo_stderr->filename;
370 
371     // initialize file descriptors to default: same as simulator
372     int stdin_fd, stdout_fd, stderr_fd;
373 
374     if (in == "stdin" || in == "cin")
375         stdin_fd = STDIN_FILENO;
376     else if (in == "None")
377         stdin_fd = -1;
378     else {
379         // open standard in and seek to the right location
380         stdin_fd = Process::openInputFile(in);
381         if (lseek(stdin_fd, fdo_stdin->fileOffset, SEEK_SET) < 0)
382             panic("Unable to seek to correct location in file: %s", in);
383     }
384 
385     if (out == "stdout" || out == "cout")
386         stdout_fd = STDOUT_FILENO;
387     else if (out == "stderr" || out == "cerr")
388         stdout_fd = STDERR_FILENO;
389     else if (out == "None")
390         stdout_fd = -1;
391     else {
392         stdout_fd = Process::openOutputFile(out);
393         if (lseek(stdout_fd, fdo_stdout->fileOffset, SEEK_SET) < 0)
394             panic("Unable to seek to correct location in file: %s", out);
395     }
396 
397     if (err == "stdout" || err == "cout")
398         stderr_fd = STDOUT_FILENO;
399     else if (err == "stderr" || err == "cerr")
400         stderr_fd = STDERR_FILENO;
401     else if (err == "None")
402         stderr_fd = -1;
403     else if (err == out)
404         stderr_fd = stdout_fd;
405     else {
406         stderr_fd = Process::openOutputFile(err);
407         if (lseek(stderr_fd, fdo_stderr->fileOffset, SEEK_SET) < 0)
408             panic("Unable to seek to correct location in file: %s", err);
409     }
410 
411     fdo_stdin->fd = stdin_fd;
412     fdo_stdout->fd = stdout_fd;
413     fdo_stderr->fd = stderr_fd;
414 
415 
416     for (int free_fd = 3; free_fd <= MAX_FD; ++free_fd) {
417         Process::FdMap *fdo = &fd_map[free_fd];
418         if (fdo->fd != -1) {
419             if (fdo->isPipe){
420                 if (fdo->filename == "PIPE-WRITE")
421                     continue;
422                 else {
423                     assert (fdo->filename == "PIPE-READ");
424                     //create a new pipe
425                     int fds[2];
426                     int pipe_retval = pipe(fds);
427 
428                     if (pipe_retval < 0) {
429                         // error
430                         panic("Unable to create new pipe.");
431                     }
432                     fdo->fd = fds[0]; //set read pipe
433                     Process::FdMap *fdo_write = &fd_map[fdo->readPipeSource];
434                     if (fdo_write->filename != "PIPE-WRITE")
435                         panic ("Couldn't find write end of the pipe");
436 
437                     fdo_write->fd = fds[1];//set write pipe
438                }
439             } else {
440                 //Open file
441                 int fd = open(fdo->filename.c_str(), fdo->flags, fdo->mode);
442 
443                 if (fd == -1)
444                     panic("Unable to open file: %s", fdo->filename);
445                 fdo->fd = fd;
446 
447                 //Seek to correct location before checkpoint
448                 if (lseek(fd,fdo->fileOffset, SEEK_SET) < 0)
449                     panic("Unable to seek to correct location in file: %s",
450                           fdo->filename);
451             }
452         }
453     }
454 }
\end{DoxyCode}
\hypertarget{classProcess_a5bfc8cca2ce6b8a330e0c209468e5f71}{
\index{Process@{Process}!fixupStackFault@{fixupStackFault}}
\index{fixupStackFault@{fixupStackFault}!Process@{Process}}
\subsubsection[{fixupStackFault}]{\setlength{\rightskip}{0pt plus 5cm}bool fixupStackFault ({\bf Addr} {\em vaddr})}}
\label{classProcess_a5bfc8cca2ce6b8a330e0c209468e5f71}
Attempt to fix up a fault at vaddr by allocating a page on the stack. \begin{DoxyReturn}{戻り値}
Whether the fault has been fixed. 
\end{DoxyReturn}



\begin{DoxyCode}
337 {
338     // Check if this is already on the stack and there's just no page there
339     // yet.
340     if (vaddr >= stack_min && vaddr < stack_base) {
341         allocateMem(roundDown(vaddr, VMPageSize), VMPageSize);
342         return true;
343     }
344 
345     // We've accessed the next page of the stack, so extend it to include
346     // this address.
347     if (vaddr < stack_min && vaddr >= stack_base - max_stack_size) {
348         while (vaddr < stack_min) {
349             stack_min -= TheISA::PageBytes;
350             if (stack_base - stack_min > max_stack_size)
351                 fatal("Maximum stack size exceeded\n");
352             allocateMem(stack_min, TheISA::PageBytes);
353             inform("Increasing stack size by one page.");
354         };
355         return true;
356     }
357     return false;
358 }
\end{DoxyCode}
\hypertarget{classProcess_a8c39614271eb6220f2db1bd774f43849}{
\index{Process@{Process}!free\_\-fd@{free\_\-fd}}
\index{free\_\-fd@{free\_\-fd}!Process@{Process}}
\subsubsection[{free\_\-fd}]{\setlength{\rightskip}{0pt plus 5cm}void free\_\-fd (int {\em tgt\_\-fd})}}
\label{classProcess_a8c39614271eb6220f2db1bd774f43849}



\begin{DoxyCode}
293 {
294     Process::FdMap *fdo = &fd_map[tgt_fd];
295     if (fdo->fd == -1)
296         warn("Process::free_fd: request to free unused fd %d", tgt_fd);
297 
298     fdo->fd = -1;
299     fdo->filename = "NULL";
300     fdo->mode = 0;
301     fdo->fileOffset = 0;
302     fdo->flags = 0;
303     fdo->isPipe = false;
304     fdo->readPipeSource = 0;
305 }
\end{DoxyCode}
\hypertarget{classProcess_a3c34ea9b29f410748d4435a667484924}{
\index{Process@{Process}!initState@{initState}}
\index{initState@{initState}!Process@{Process}}
\subsubsection[{initState}]{\setlength{\rightskip}{0pt plus 5cm}void initState ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classProcess_a3c34ea9b29f410748d4435a667484924}
\hyperlink{classProcess_a3c34ea9b29f410748d4435a667484924}{initState()} is called on each \hyperlink{classSimObject}{SimObject} when $\ast$not$\ast$ restoring from a checkpoint. This provides a hook for state initializations that are only required for a \char`\"{}cold start\char`\"{}. 

\hyperlink{classSimObject_a3c34ea9b29f410748d4435a667484924}{SimObject}を再定義しています。

\hyperlink{classAlphaLiveProcess_a3c34ea9b29f410748d4435a667484924}{AlphaLiveProcess}, \hyperlink{classArmLinuxProcess32_a3c34ea9b29f410748d4435a667484924}{ArmLinuxProcess32}, \hyperlink{classArmLinuxProcess64_a3c34ea9b29f410748d4435a667484924}{ArmLinuxProcess64}, \hyperlink{classArmLiveProcess32_a3c34ea9b29f410748d4435a667484924}{ArmLiveProcess32}, \hyperlink{classArmLiveProcess64_a3c34ea9b29f410748d4435a667484924}{ArmLiveProcess64}, \hyperlink{classMipsLiveProcess_a3c34ea9b29f410748d4435a667484924}{MipsLiveProcess}, \hyperlink{classMipsLiveProcess_a3c34ea9b29f410748d4435a667484924}{MipsLiveProcess}, \hyperlink{classPowerLinuxProcess_a3c34ea9b29f410748d4435a667484924}{PowerLinuxProcess}, \hyperlink{classPowerLiveProcess_a3c34ea9b29f410748d4435a667484924}{PowerLiveProcess}, \hyperlink{classSparcLiveProcess_a3c34ea9b29f410748d4435a667484924}{SparcLiveProcess}, \hyperlink{classSparc32LiveProcess_a3c34ea9b29f410748d4435a667484924}{Sparc32LiveProcess}, \hyperlink{classSparc64LiveProcess_a3c34ea9b29f410748d4435a667484924}{Sparc64LiveProcess}, \hyperlink{classX86ISA_1_1X86__64LiveProcess_a3c34ea9b29f410748d4435a667484924}{X86\_\-64LiveProcess}, と \hyperlink{classX86ISA_1_1I386LiveProcess_a3c34ea9b29f410748d4435a667484924}{I386LiveProcess}で再定義されています。


\begin{DoxyCode}
240 {
241     if (contextIds.empty())
242         fatal("Process %s is not associated with any HW contexts!\n", name());
243 
244     // first thread context for this process... initialize & enable
245     ThreadContext *tc = system->getThreadContext(contextIds[0]);
246 
247     // mark this context as active so it will start ticking.
248     tc->activate(Cycles(0));
249 }
\end{DoxyCode}
\hypertarget{classProcess_ac2bb68c3c87d0a046f848f537abb23fc}{
\index{Process@{Process}!map@{map}}
\index{map@{map}!Process@{Process}}
\subsubsection[{map}]{\setlength{\rightskip}{0pt plus 5cm}bool map ({\bf Addr} {\em vaddr}, \/  {\bf Addr} {\em paddr}, \/  int {\em size})}}
\label{classProcess_ac2bb68c3c87d0a046f848f537abb23fc}
Map a contiguous range of virtual addresses in this process's address space to a contiguous range of physical addresses. This function exists primarily to enable exposing the map operation to python, so that configuration scripts can set up mappings in SE mode.


\begin{DoxyParams}{引数}
\item[{\em vaddr}]The starting virtual address of the range. \item[{\em paddr}]The starting physical address of the range. \item[{\em size}]The length of the range in bytes. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
True if the map operation was successful. (At this point in time, the map operation always succeeds.) 
\end{DoxyReturn}



\begin{DoxyCode}
548 {
549     pTable->map(vaddr, paddr, size);
550     return true;
551 }
\end{DoxyCode}
\hypertarget{classProcess_ac5c70b967092e10582ce2f165e174890}{
\index{Process@{Process}!numCpus@{numCpus}}
\index{numCpus@{numCpus}!Process@{Process}}
\subsubsection[{numCpus}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int numCpus ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classProcess_ac5c70b967092e10582ce2f165e174890}



\begin{DoxyCode}
77 { return contextIds.size(); }
\end{DoxyCode}
\hypertarget{classProcess_acea5ecbb223871b0d852b03b68837461}{
\index{Process@{Process}!openInputFile@{openInputFile}}
\index{openInputFile@{openInputFile}!Process@{Process}}
\subsubsection[{openInputFile}]{\setlength{\rightskip}{0pt plus 5cm}static int openInputFile (const std::string \& {\em filename})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classProcess_acea5ecbb223871b0d852b03b68837461}
\hypertarget{classProcess_a230c9c6213b49eef2273fa99e3a511ba}{
\index{Process@{Process}!openOutputFile@{openOutputFile}}
\index{openOutputFile@{openOutputFile}!Process@{Process}}
\subsubsection[{openOutputFile}]{\setlength{\rightskip}{0pt plus 5cm}static int openOutputFile (const std::string \& {\em filename})\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classProcess_a230c9c6213b49eef2273fa99e3a511ba}
\hypertarget{classProcess_a580745d5543eb666c37e2a5f37fb32a0}{
\index{Process@{Process}!progName@{progName}}
\index{progName@{progName}!Process@{Process}}
\subsubsection[{progName}]{\setlength{\rightskip}{0pt plus 5cm}virtual const char$\ast$ progName () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classProcess_a580745d5543eb666c37e2a5f37fb32a0}


\hyperlink{classLiveProcess_a580745d5543eb666c37e2a5f37fb32a0}{LiveProcess}で再定義されています。


\begin{DoxyCode}
178 { return "<unknown>"; }
\end{DoxyCode}
\hypertarget{classProcess_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{Process@{Process}!regStats@{regStats}}
\index{regStats@{regStats}!Process@{Process}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classProcess_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} statistics for this object. 

\hyperlink{classSimObject_a4dc637449366fcdfc4e764cdf12d9b11}{SimObject}を再定義しています。


\begin{DoxyCode}
182 {
183     using namespace Stats;
184 
185     num_syscalls
186         .name(name() + ".num_syscalls")
187         .desc("Number of system calls")
188         ;
189 }
\end{DoxyCode}
\hypertarget{classProcess_a53e036786d17361be4c7320d39c99b84}{
\index{Process@{Process}!serialize@{serialize}}
\index{serialize@{serialize}!Process@{Process}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classProcess_a53e036786d17361be4c7320d39c99b84}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。


\begin{DoxyCode}
501 {
502     SERIALIZE_SCALAR(brk_point);
503     SERIALIZE_SCALAR(stack_base);
504     SERIALIZE_SCALAR(stack_size);
505     SERIALIZE_SCALAR(stack_min);
506     SERIALIZE_SCALAR(next_thread_stack_base);
507     SERIALIZE_SCALAR(mmap_start);
508     SERIALIZE_SCALAR(mmap_end);
509     SERIALIZE_SCALAR(nxm_start);
510     SERIALIZE_SCALAR(nxm_end);
511     find_file_offsets();
512     pTable->serialize(os);
513     for (int x = 0; x <= MAX_FD; x++) {
514         nameOut(os, csprintf("%s.FdMap%d", name(), x));
515         fd_map[x].serialize(os);
516     }
517     SERIALIZE_SCALAR(M5_pid);
518 
519 }
\end{DoxyCode}
\hypertarget{classProcess_a06811a348d456174f7ad9f2b8f03a129}{
\index{Process@{Process}!setReadPipeSource@{setReadPipeSource}}
\index{setReadPipeSource@{setReadPipeSource}!Process@{Process}}
\subsubsection[{setReadPipeSource}]{\setlength{\rightskip}{0pt plus 5cm}void setReadPipeSource (int {\em read\_\-pipe\_\-fd}, \/  int {\em source\_\-fd})}}
\label{classProcess_a06811a348d456174f7ad9f2b8f03a129}



\begin{DoxyCode}
472 {
473     Process::FdMap *fdo = &fd_map[read_pipe_fd];
474     fdo->readPipeSource = source_fd;
475 }
\end{DoxyCode}
\hypertarget{classProcess_ac7bb7ef35884d6fb4a2c02f167ab7679}{
\index{Process@{Process}!sim\_\-fd@{sim\_\-fd}}
\index{sim\_\-fd@{sim\_\-fd}!Process@{Process}}
\subsubsection[{sim\_\-fd}]{\setlength{\rightskip}{0pt plus 5cm}int sim\_\-fd (int {\em tgt\_\-fd})}}
\label{classProcess_ac7bb7ef35884d6fb4a2c02f167ab7679}



\begin{DoxyCode}
311 {
312     if (tgt_fd < 0 || tgt_fd > MAX_FD)
313         return -1;
314 
315     return fd_map[tgt_fd].fd;
316 }
\end{DoxyCode}
\hypertarget{classProcess_ac12196dd197c6731a021e211a95edb2d}{
\index{Process@{Process}!sim\_\-fd\_\-obj@{sim\_\-fd\_\-obj}}
\index{sim\_\-fd\_\-obj@{sim\_\-fd\_\-obj}!Process@{Process}}
\subsubsection[{sim\_\-fd\_\-obj}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Process::FdMap} $\ast$ sim\_\-fd\_\-obj (int {\em tgt\_\-fd})}}
\label{classProcess_ac12196dd197c6731a021e211a95edb2d}



\begin{DoxyCode}
320 {
321     if (tgt_fd < 0 || tgt_fd > MAX_FD)
322         return NULL;
323 
324     return &fd_map[tgt_fd];
325 }
\end{DoxyCode}
\hypertarget{classProcess_a0abb4f4856f531e5b48484f5114a5bf9}{
\index{Process@{Process}!syscall@{syscall}}
\index{syscall@{syscall}!Process@{Process}}
\subsubsection[{syscall}]{\setlength{\rightskip}{0pt plus 5cm}virtual void syscall (int64\_\-t {\em callnum}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classProcess_a0abb4f4856f531e5b48484f5114a5bf9}


\hyperlink{classX86ISA_1_1I386LiveProcess_a1ed38802271de4269c3adfa46c73e7e7}{I386LiveProcess}, と \hyperlink{classLiveProcess_a1ed38802271de4269c3adfa46c73e7e7}{LiveProcess}で実装されています。\hypertarget{classProcess_af22e5d6d660b97db37003ac61ac4ee49}{
\index{Process@{Process}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!Process@{Process}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classProcess_af22e5d6d660b97db37003ac61ac4ee49}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。


\begin{DoxyCode}
523 {
524     UNSERIALIZE_SCALAR(brk_point);
525     UNSERIALIZE_SCALAR(stack_base);
526     UNSERIALIZE_SCALAR(stack_size);
527     UNSERIALIZE_SCALAR(stack_min);
528     UNSERIALIZE_SCALAR(next_thread_stack_base);
529     UNSERIALIZE_SCALAR(mmap_start);
530     UNSERIALIZE_SCALAR(mmap_end);
531     UNSERIALIZE_SCALAR(nxm_start);
532     UNSERIALIZE_SCALAR(nxm_end);
533     pTable->unserialize(cp, section);
534     for (int x = 0; x <= MAX_FD; x++) {
535         fd_map[x].unserialize(cp, csprintf("%s.FdMap%d", section, x));
536     }
537     fix_file_offsets();
538     UNSERIALIZE_OPT_SCALAR(M5_pid);
539     // The above returns a bool so that you could do something if you don't
540     // find the param in the checkpoint if you wanted to, like set a default
541     // but in this case we'll just stick with the instantianted value if not
542     // found.   
543 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classProcess_aa0d3d9ff2a6fcb719d3b83226bb50638}{
\index{Process@{Process}!brk\_\-point@{brk\_\-point}}
\index{brk\_\-point@{brk\_\-point}!Process@{Process}}
\subsubsection[{brk\_\-point}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf brk\_\-point}}}
\label{classProcess_aa0d3d9ff2a6fcb719d3b83226bb50638}
\hypertarget{classProcess_a64a72121f39c3cbc68bb1b863c3f43ed}{
\index{Process@{Process}!contextIds@{contextIds}}
\index{contextIds@{contextIds}!Process@{Process}}
\subsubsection[{contextIds}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<$int$>$ {\bf contextIds}}}
\label{classProcess_a64a72121f39c3cbc68bb1b863c3f43ed}
\hypertarget{classProcess_ad817e277dc908ed0f32c4180c5ddb350}{
\index{Process@{Process}!fd\_\-map@{fd\_\-map}}
\index{fd\_\-map@{fd\_\-map}!Process@{Process}}
\subsubsection[{fd\_\-map}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FdMap} {\bf fd\_\-map}\mbox{[}{\bf MAX\_\-FD}+1\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classProcess_ad817e277dc908ed0f32c4180c5ddb350}
\hypertarget{classProcess_a280be1c93dee29cd2c6d5d1502c60a9b}{
\index{Process@{Process}!initVirtMem@{initVirtMem}}
\index{initVirtMem@{initVirtMem}!Process@{Process}}
\subsubsection[{initVirtMem}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SETranslatingPortProxy} {\bf initVirtMem}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classProcess_a280be1c93dee29cd2c6d5d1502c60a9b}


Memory proxy for initialization (image loading). \hypertarget{classProcess_a570045a30dc7f4c596f2fa18dfdfbed5}{
\index{Process@{Process}!M5\_\-pid@{M5\_\-pid}}
\index{M5\_\-pid@{M5\_\-pid}!Process@{Process}}
\subsubsection[{M5\_\-pid}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf M5\_\-pid}}}
\label{classProcess_a570045a30dc7f4c596f2fa18dfdfbed5}
\hypertarget{classProcess_a2a18c1a4811677d6adabab2287226bb1}{
\index{Process@{Process}!MAX\_\-FD@{MAX\_\-FD}}
\index{MAX\_\-FD@{MAX\_\-FD}!Process@{Process}}
\subsubsection[{MAX\_\-FD}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf MAX\_\-FD} = 256\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}
\label{classProcess_a2a18c1a4811677d6adabab2287226bb1}
\hypertarget{classProcess_a02d0240a7f8b3d791b54cd01f9370121}{
\index{Process@{Process}!max\_\-stack\_\-size@{max\_\-stack\_\-size}}
\index{max\_\-stack\_\-size@{max\_\-stack\_\-size}!Process@{Process}}
\subsubsection[{max\_\-stack\_\-size}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf max\_\-stack\_\-size}}}
\label{classProcess_a02d0240a7f8b3d791b54cd01f9370121}
\hypertarget{classProcess_a41a18edd0dbae5a7bb12e20a30c2e3e1}{
\index{Process@{Process}!mmap\_\-end@{mmap\_\-end}}
\index{mmap\_\-end@{mmap\_\-end}!Process@{Process}}
\subsubsection[{mmap\_\-end}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf mmap\_\-end}}}
\label{classProcess_a41a18edd0dbae5a7bb12e20a30c2e3e1}
\hypertarget{classProcess_a39ba573f8e6f0a0f33a82245af695ffc}{
\index{Process@{Process}!mmap\_\-start@{mmap\_\-start}}
\index{mmap\_\-start@{mmap\_\-start}!Process@{Process}}
\subsubsection[{mmap\_\-start}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf mmap\_\-start}}}
\label{classProcess_a39ba573f8e6f0a0f33a82245af695ffc}
\hypertarget{classProcess_a55a3705006af6c58cba9f9a23ba89864}{
\index{Process@{Process}!next\_\-thread\_\-stack\_\-base@{next\_\-thread\_\-stack\_\-base}}
\index{next\_\-thread\_\-stack\_\-base@{next\_\-thread\_\-stack\_\-base}!Process@{Process}}
\subsubsection[{next\_\-thread\_\-stack\_\-base}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf next\_\-thread\_\-stack\_\-base}}}
\label{classProcess_a55a3705006af6c58cba9f9a23ba89864}
\hypertarget{classProcess_a71ce639346bf9b5caabdf218544e302a}{
\index{Process@{Process}!num\_\-syscalls@{num\_\-syscalls}}
\index{num\_\-syscalls@{num\_\-syscalls}!Process@{Process}}
\subsubsection[{num\_\-syscalls}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf num\_\-syscalls}}}
\label{classProcess_a71ce639346bf9b5caabdf218544e302a}
\hypertarget{classProcess_aa47cd9dfc4d79b68bb78ee4b10b8298d}{
\index{Process@{Process}!nxm\_\-end@{nxm\_\-end}}
\index{nxm\_\-end@{nxm\_\-end}!Process@{Process}}
\subsubsection[{nxm\_\-end}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf nxm\_\-end}}}
\label{classProcess_aa47cd9dfc4d79b68bb78ee4b10b8298d}
\hypertarget{classProcess_a2e51a258c95c46a8e3b3b4c2c74795e6}{
\index{Process@{Process}!nxm\_\-start@{nxm\_\-start}}
\index{nxm\_\-start@{nxm\_\-start}!Process@{Process}}
\subsubsection[{nxm\_\-start}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf nxm\_\-start}}}
\label{classProcess_a2e51a258c95c46a8e3b3b4c2c74795e6}
\hypertarget{classProcess_ad14ffa23ad731f6003755b643f999049}{
\index{Process@{Process}!pTable@{pTable}}
\index{pTable@{pTable}!Process@{Process}}
\subsubsection[{pTable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PageTable}$\ast$ {\bf pTable}}}
\label{classProcess_ad14ffa23ad731f6003755b643f999049}
\hypertarget{classProcess_a9301d238f8ee69de69d9a608f23b0ee2}{
\index{Process@{Process}!stack\_\-base@{stack\_\-base}}
\index{stack\_\-base@{stack\_\-base}!Process@{Process}}
\subsubsection[{stack\_\-base}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf stack\_\-base}}}
\label{classProcess_a9301d238f8ee69de69d9a608f23b0ee2}
\hypertarget{classProcess_a03ca56edd14eafca9beec28c150e05a6}{
\index{Process@{Process}!stack\_\-min@{stack\_\-min}}
\index{stack\_\-min@{stack\_\-min}!Process@{Process}}
\subsubsection[{stack\_\-min}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf stack\_\-min}}}
\label{classProcess_a03ca56edd14eafca9beec28c150e05a6}
\hypertarget{classProcess_a846e164ff6493f2b7001b0adc9dfe535}{
\index{Process@{Process}!stack\_\-size@{stack\_\-size}}
\index{stack\_\-size@{stack\_\-size}!Process@{Process}}
\subsubsection[{stack\_\-size}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf stack\_\-size}}}
\label{classProcess_a846e164ff6493f2b7001b0adc9dfe535}
\hypertarget{classProcess_af27ccd765f13a4b7bd119dc7579e2746}{
\index{Process@{Process}!system@{system}}
\index{system@{system}!Process@{Process}}
\subsubsection[{system}]{\setlength{\rightskip}{0pt plus 5cm}{\bf System}$\ast$ {\bf system}}}
\label{classProcess_af27ccd765f13a4b7bd119dc7579e2746}
Pointer to object representing the system this process is running on. \hypertarget{classProcess_a8af61364ae9c966602b3b5ec1c0f7f09}{
\index{Process@{Process}!waitList@{waitList}}
\index{waitList@{waitList}!Process@{Process}}
\subsubsection[{waitList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf WaitRec}$>$ {\bf waitList}}}
\label{classProcess_a8af61364ae9c966602b3b5ec1c0f7f09}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
sim/\hyperlink{sim_2process_8hh}{process.hh}\item 
sim/\hyperlink{sim_2process_8cc}{process.cc}\end{DoxyCompactItemize}
