\hypertarget{classDefaultFetch}{
\section{クラス テンプレート DefaultFetch$<$ Impl $>$}
\label{classDefaultFetch}\index{DefaultFetch@{DefaultFetch}}
}


{\ttfamily \#include $<$fetch.hh$>$}\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classDefaultFetch_1_1FetchTranslation}{FetchTranslation}
\item 
class \hyperlink{classDefaultFetch_1_1FinishTranslationEvent}{FinishTranslationEvent}
\item 
struct \hyperlink{structDefaultFetch_1_1Stalls}{Stalls}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classDefaultFetch_a64605db3d589dcf77a170612ff89515e}{FetchStatus} \{ \hyperlink{classDefaultFetch_a64605db3d589dcf77a170612ff89515ea26bd8444261cc58df7a86753c79d2520}{Active}, 
\hyperlink{classDefaultFetch_a64605db3d589dcf77a170612ff89515ea969c924a722daf6334fca64346092ae6}{Inactive}
 \}
\item 
enum \hyperlink{classDefaultFetch_ae2739961013a00cede621d4d72f2173c}{ThreadStatus} \{ \par
\hyperlink{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca2f5f2c4a8c4f4f0519d503dcdfbf55cb}{Running}, 
\hyperlink{classDefaultFetch_ae2739961013a00cede621d4d72f2173cad3fa9ae9431d6cb1772f9d9df48cab19}{Idle}, 
\hyperlink{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca22a648855197e326dc88f548634c0ec7}{Squashing}, 
\hyperlink{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca9463ee9b8700258a1019b4b9d2d77a30}{Blocked}, 
\par
\hyperlink{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca718b7867aa13dd84937c83334380edee}{Fetching}, 
\hyperlink{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca8c49adf6da5f507150d403610c684877}{TrapPending}, 
\hyperlink{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca6dd2239b509a3ed085ad3bddda99cb16}{QuiescePending}, 
\hyperlink{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca2872442035b8be061f050fdf94761d33}{ItlbWait}, 
\par
\hyperlink{classDefaultFetch_ae2739961013a00cede621d4d72f2173caa694766f134e9cd81f5ad5b91dedf852}{IcacheWaitResponse}, 
\hyperlink{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca2a36c8d85e537909b8fa14af846e48a3}{IcacheWaitRetry}, 
\hyperlink{classDefaultFetch_ae2739961013a00cede621d4d72f2173caff0dbe49b2bc9aee96de6b007b5b826e}{IcacheAccessComplete}, 
\hyperlink{classDefaultFetch_ae2739961013a00cede621d4d72f2173caadf72b4e66cdfa8a56beab05bb411da6}{NoGoodAddr}
 \}
\item 
enum \hyperlink{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3}{FetchPriority} \{ \par
\hyperlink{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3ae01d52cbe97a50e79f4195cd27b3185b}{SingleThread}, 
\hyperlink{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3a5c08841de48c15133dd26a4d9d740a11}{RoundRobin}, 
\hyperlink{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3a070f4c50ffea5accaf5f88606fc088a8}{Branch}, 
\hyperlink{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3a7608065caa4249ff47a58c32d6f3c531}{IQ}, 
\par
\hyperlink{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3a4cc572b5087c4e67104941ee638a8512}{LSQ}
 \}
\item 
typedef Impl::CPUPol \hyperlink{classDefaultFetch_a87d662eaeb9eab249d671b63cb4ba11a}{CPUPol}
\item 
typedef Impl::DynInst \hyperlink{classDefaultFetch_ab741745c86a14c765b999c11167636d9}{DynInst}
\item 
typedef Impl::DynInstPtr \hyperlink{classDefaultFetch_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}
\item 
typedef Impl::O3CPU \hyperlink{classDefaultFetch_a44622cf06940413482836cb62931ac3f}{O3CPU}
\item 
typedef CPUPol::FetchStruct \hyperlink{classDefaultFetch_a3aac8607069f16898ef53cfaa2d97aeb}{FetchStruct}
\item 
typedef CPUPol::TimeStruct \hyperlink{classDefaultFetch_ab7dd3632ef639702a5c6e7c2c3a2f82a}{TimeStruct}
\item 
typedef TheISA::MachInst \hyperlink{classDefaultFetch_a4617f528417b8f55f809ae0988284c9b}{MachInst}
\item 
typedef TheISA::ExtMachInst \hyperlink{classDefaultFetch_a5605d4fc727eae9e595325c90c0ec108}{ExtMachInst}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDefaultFetch_a96cb569fd8ae5efebb8e7716f435d9d2}{DefaultFetch} (\hyperlink{classDefaultFetch_a44622cf06940413482836cb62931ac3f}{O3CPU} $\ast$\_\-cpu, DerivO3CPUParams $\ast$params)
\item 
std::string \hyperlink{classDefaultFetch_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classDefaultFetch_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classDefaultFetch_aa2dab17a363fd4307274d579796adcf7}{regProbePoints} ()
\item 
void \hyperlink{classDefaultFetch_aa9fe72c29dff746fa7023a15c1134ada}{setTimeBuffer} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$ $\ast$time\_\-buffer)
\item 
void \hyperlink{classDefaultFetch_aab96bdacf8bd420402cbb543f994e054}{setActiveThreads} (\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$at\_\-ptr)
\item 
void \hyperlink{classDefaultFetch_ad1be90519aa7737ddf8e41de079a5ea9}{setFetchQueue} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultFetch_a3aac8607069f16898ef53cfaa2d97aeb}{FetchStruct} $>$ $\ast$fq\_\-ptr)
\item 
void \hyperlink{classDefaultFetch_a31d4cbdab16d4ff8d6bc7f84ece727da}{startupStage} ()
\item 
void \hyperlink{classDefaultFetch_a29cb5a4f98063ce6e9210eacbdb35298}{recvRetry} ()
\item 
void \hyperlink{classDefaultFetch_a3dc029c2e87eb911352b82ff15c86236}{processCacheCompletion} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classDefaultFetch_a8f020d3237536fe007fc488c4125c5d8}{drainResume} ()
\item 
void \hyperlink{classDefaultFetch_a0240eb42fa57fe5d3788093f62b77347}{drainSanityCheck} () const 
\item 
bool \hyperlink{classDefaultFetch_adf5473c18a3d7c1e88c4a2072bce5526}{isDrained} () const 
\item 
void \hyperlink{classDefaultFetch_a8674059ce345e23aac5086b2c3e24a43}{takeOverFrom} ()
\item 
void \hyperlink{classDefaultFetch_ad1c01dde67aa909bd829896f6f587502}{drainStall} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultFetch_a040cbeac7187b0b8cdb1242d3f5aa179}{wakeFromQuiesce} ()
\item 
void \hyperlink{classDefaultFetch_ae16ceb7406a5afe4ea9a39fd12931d32}{squash} (const TheISA::PCState \&newPC, const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} seq\_\-num, \hyperlink{classDefaultFetch_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} squashInst, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultFetch_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\item 
bool \hyperlink{classDefaultFetch_af77f2bf38a75182c65e633b9fdf295d2}{checkSignalsAndUpdate} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultFetch_a77759cf15b084e00a9e4e8ca810a0be7}{fetch} (bool \&status\_\-change)
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classDefaultFetch_a0c451948a0050595e5d23f57866f2797}{fetchBufferAlignPC} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr)
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
TheISA::Decoder $\ast$ \hyperlink{classDefaultFetch_ad59085cbedffbd5bf8cd9eb714041505}{decoder} \mbox{[}Impl::MaxThreads\mbox{]}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classDefaultFetch_ada2a699094bc420f977abf2a17ed14c8}{resetStage} ()
\item 
void \hyperlink{classDefaultFetch_a03ce24cba34d3da5948f54e10f8710a9}{switchToActive} ()
\item 
void \hyperlink{classDefaultFetch_a8ef9d48876d3014250c97bfba41a42cd}{switchToInactive} ()
\item 
bool \hyperlink{classDefaultFetch_a033e8df655743382b3cb870600f70f82}{lookupAndUpdateNextPC} (\hyperlink{classDefaultFetch_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst, TheISA::PCState \&\hyperlink{classDefaultFetch_a6e6091c9272a281b8693c0f46279cad0}{pc})
\item 
bool \hyperlink{classDefaultFetch_a2ede53ea19a95876fd2418fcc329ef9a}{fetchCacheLine} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vaddr, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classDefaultFetch_a6e6091c9272a281b8693c0f46279cad0}{pc})
\item 
void \hyperlink{classDefaultFetch_ac7dca7de206b6388e989a53b56634ad4}{finishTranslation} (\hyperlink{classRefCountingPtr}{Fault} fault, \hyperlink{classRequest}{RequestPtr} mem\_\-req)
\item 
bool \hyperlink{classDefaultFetch_a0949b3c8e74ae282010e2a8698525c72}{checkInterrupt} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classDefaultFetch_a6e6091c9272a281b8693c0f46279cad0}{pc})
\item 
void \hyperlink{classDefaultFetch_a9c960f5de0fbb0511596cba5039660a3}{doSquash} (const TheISA::PCState \&newPC, const \hyperlink{classDefaultFetch_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} squashInst, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultFetch_acddf0ab1e13108e3626da3743de398b8}{squashFromDecode} (const TheISA::PCState \&newPC, const \hyperlink{classDefaultFetch_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} squashInst, const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} seq\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classDefaultFetch_a6ba4f2f95d991f5be818dabf7500feed}{checkStall} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid) const 
\item 
\hyperlink{classDefaultFetch_a64605db3d589dcf77a170612ff89515e}{FetchStatus} \hyperlink{classDefaultFetch_ac244c54ec94dd5e1d886dfd022752ec8}{updateFetchStatus} ()
\item 
\hyperlink{classDefaultFetch_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classDefaultFetch_a9c38c3c5f6bb4a7c1919ca7d3d4e12dc}{buildInst} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid, \hyperlink{classRefCountingPtr}{StaticInstPtr} staticInst, \hyperlink{classRefCountingPtr}{StaticInstPtr} curMacroop, TheISA::PCState thisPC, TheISA::PCState nextPC, bool trace)
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classDefaultFetch_a4a20466270bc79a695af63ea67a35576}{getFetchingThread} (\hyperlink{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3}{FetchPriority} \&fetch\_\-priority)
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classDefaultFetch_a8aab9cacbc483081596b13ecd5192eb5}{roundRobin} ()
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classDefaultFetch_a4aff2ae442aa43bcb382774f7c429030}{iqCount} ()
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classDefaultFetch_a2cce05272516009508e173f69d7d37df}{lsqCount} ()
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classDefaultFetch_adbe8a1ec70863059cb0e121edc864a14}{branchCount} ()
\item 
void \hyperlink{classDefaultFetch_a80cf75d186616b207a78a162498d1012}{pipelineIcacheAccesses} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultFetch_ab3fa3c541f25b65e1b61d7290712e507}{profileStall} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDefaultFetch_a64605db3d589dcf77a170612ff89515e}{FetchStatus} \hyperlink{classDefaultFetch_aa3fc43283eb7a93d6a41830bbd412681}{\_\-status}
\item 
\hyperlink{classDefaultFetch_ae2739961013a00cede621d4d72f2173c}{ThreadStatus} \hyperlink{classDefaultFetch_a852cb41bf6074487410b49ec9ff53c00}{fetchStatus} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3}{FetchPriority} \hyperlink{classDefaultFetch_aad8c2ca9262308cfdb74cd69cda508f6}{fetchPolicy}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ \hyperlink{classDefaultFetch_a0d967261cbbce522509d85936b8ce786}{priorityList}
\item 
\hyperlink{classProbePointArg}{ProbePointArg}$<$ \hyperlink{classDefaultFetch_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ $\ast$ \hyperlink{classDefaultFetch_a853ac5048dfdbba414f6f8186dd11afd}{ppFetch}
\item 
\hyperlink{classDefaultFetch_a44622cf06940413482836cb62931ac3f}{O3CPU} $\ast$ \hyperlink{classDefaultFetch_a1379cf882a12ac6fc9eba5da7c84b18b}{cpu}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$ $\ast$ \hyperlink{classDefaultFetch_a83f9ee976e732665aeb08dbc19acfd45}{timeBuffer}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classDefaultFetch_a1116d028078c70aa1579726747303a55}{fromDecode}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classDefaultFetch_ae99c54a9c8f1e218b86afcee348c54fc}{fromRename}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classDefaultFetch_a6c9093e88770a58dc8853f49a09bbac8}{fromIEW}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classDefaultFetch_a0055a92bd94eda21c2641d46ff013dac}{fromCommit}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultFetch_a3aac8607069f16898ef53cfaa2d97aeb}{FetchStruct} $>$ $\ast$ \hyperlink{classDefaultFetch_a9a2f350be647ebfb6567172812db491a}{fetchQueue}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultFetch_a3aac8607069f16898ef53cfaa2d97aeb}{FetchStruct} $>$::wire \hyperlink{classDefaultFetch_a5283adcc786817de9adc5a4601aa3a6f}{toDecode}
\item 
\hyperlink{classBPredUnit}{BPredUnit} $\ast$ \hyperlink{classDefaultFetch_adee29d0de843b42df1f1caf92d388413}{branchPred}
\item 
TheISA::PCState \hyperlink{classDefaultFetch_a6e6091c9272a281b8693c0f46279cad0}{pc} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classDefaultFetch_afc52fdca94918eaaf908094a80ab63ce}{fetchOffset} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classRefCountingPtr}{StaticInstPtr} \hyperlink{classDefaultFetch_a1f84ef3ef8e6b11f3bb9a3a0a6224345}{macroop} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
bool \hyperlink{classDefaultFetch_af247386188fbfaba3ea218eff3a771db}{delayedCommit} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classRequest}{RequestPtr} \hyperlink{classDefaultFetch_a7b85bc06912a7000a9b27cab60626a7a}{memReq} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
bool \hyperlink{classDefaultFetch_a2c7e870d4babdac0dc91fc7ffabd0f3d}{wroteToTimeBuffer}
\item 
int \hyperlink{classDefaultFetch_a07c4afd8e6b9ff4bdf20b573a39d1372}{numInst}
\item 
\hyperlink{structDefaultFetch_1_1Stalls}{Stalls} \hyperlink{classDefaultFetch_ade48cf321f5741ea8e54e071680cacdc}{stalls} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classDefaultFetch_a2ef45e1e2bd510cfb43c0a03a6ab3f1c}{decodeToFetchDelay}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classDefaultFetch_ae97f1fdea38bf1719a7d45a15f3dcd5c}{renameToFetchDelay}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classDefaultFetch_a986e734c1e66dc0be1723ade04d06d4b}{iewToFetchDelay}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classDefaultFetch_a4b0344f5703ba5770b42602c6df63340}{commitToFetchDelay}
\item 
unsigned \hyperlink{classDefaultFetch_a89b5ed63a2dba82556b909f343319416}{fetchWidth}
\item 
bool \hyperlink{classDefaultFetch_a12a8dc8b9e94659a01ff979d9d98be89}{cacheBlocked}
\item 
\hyperlink{classPacket}{PacketPtr} \hyperlink{classDefaultFetch_a314ae93c04b3ca96e79e1b1f39a8e478}{retryPkt}
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classDefaultFetch_a865aaad70625f17392c717930860d386}{retryTid}
\item 
unsigned int \hyperlink{classDefaultFetch_a37c69cb65c303fc6e66984fef13f18c6}{cacheBlkSize}
\item 
unsigned \hyperlink{classDefaultFetch_ac47806923c3481b83636c4aa03d184f8}{fetchBufferSize}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classDefaultFetch_a9fb9a70efc5e29795473f1f92c082063}{fetchBufferMask}
\item 
uint8\_\-t $\ast$ \hyperlink{classDefaultFetch_a924f2775385b2e5ac3008db4b8305c2b}{fetchBuffer} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classDefaultFetch_ab4b128217e67bdf9f6a98420b82cacb9}{fetchBufferPC} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
bool \hyperlink{classDefaultFetch_ab6845c7b94805ded9ea7d94b210be51b}{fetchBufferValid} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
int \hyperlink{classDefaultFetch_a494a9a986bc62c946604f9e9047ad237}{instSize}
\item 
\hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classDefaultFetch_a1848d938e5258a2a79298169e43efde5}{lastIcacheStall} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$ \hyperlink{classDefaultFetch_af6eaea53db532812052f71bf0380dab5}{activeThreads}
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classDefaultFetch_a88377f855dbf5adeeecb06b5bb821d35}{numThreads}
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classDefaultFetch_a6f81783998429ac4a3e8b75a5d5d12d4}{numFetchingThreads}
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classDefaultFetch_ac4dd16b14420d21b5704350fbbcefd04}{threadFetched}
\item 
bool \hyperlink{classDefaultFetch_a310de3efc6b60f47de5792d2b00d0840}{interruptPending}
\item 
bool \hyperlink{classDefaultFetch_a4004484fff11512f43124243e7eac71a}{issuePipelinedIfetch} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classDefaultFetch_1_1FinishTranslationEvent}{FinishTranslationEvent} \hyperlink{classDefaultFetch_a7bfa632a0dd4f5a541ceb627255286d3}{finishTranslationEvent}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultFetch_a2b9328bdb1a6898bfae824981cd64311}{icacheStallCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultFetch_af0e3fa228032036d2022ed9e2a3612b6}{fetchedInsts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultFetch_aaca0646636cde96795aed6beb2942975}{fetchedBranches}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultFetch_ae5c954036e76b5cc5a82cf7f17d4d5ed}{predictedBranches}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultFetch_a9699b5489dd499e832651b96f95b5d19}{fetchCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultFetch_ae1b92a3469ac6b00fddd788b71f64c9a}{fetchSquashCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultFetch_a9b08d665534d5e7d5b8134c4af16881d}{fetchTlbCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultFetch_a8af716ad2a53a409640347226078591c}{fetchIdleCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultFetch_a0501ffad4abed98618a6cf0ba9c3599b}{fetchBlockedCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultFetch_a0a77b8544fea92003669cdc78a46eea5}{fetchMiscStallCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultFetch_ad09f9a8597b6f2c627b5c116d85ea375}{fetchPendingDrainCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultFetch_aaa3b110a1f8e4fb7c88676a2ee836a06}{fetchNoActiveThreadStallCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultFetch_a5a80cd5375f1281e64f0dd318cc761d2}{fetchPendingTrapStallCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultFetch_a8be39e4ea9ed9168227dc6efced55f3f}{fetchPendingQuiesceStallCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultFetch_a85ea1666f596116bc53a277b388d39d7}{fetchIcacheWaitRetryStallCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultFetch_a0ead660daa133edcd64ac552d473ebba}{fetchedCacheLines}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultFetch_af5ce6113f31fddaab758b8fb025600bc}{fetchIcacheSquashes}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultFetch_afe07cb06e5135b2305320fa11fda71af}{fetchTlbSquashes}
\item 
\hyperlink{classStats_1_1Distribution}{Stats::Distribution} \hyperlink{classDefaultFetch_a4793a4a8857c13e7812b1c37c6df761b}{fetchNisnDist}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDefaultFetch_a4b942e4ec6b8c1d29a1c96e901ea71dd}{idleRate}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDefaultFetch_abceba4006d416e352df47f692b589bc3}{branchRate}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDefaultFetch_a7656c6cac3b62fa389148c650a5d127a}{fetchRate}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$class Impl$>$ class DefaultFetch$<$ Impl $>$}

\hyperlink{classDefaultFetch}{DefaultFetch} class handles both single threaded and SMT fetch. Its width is specified by the parameters; each cycle it tries to fetch that many instructions. It supports using a branch predictor to predict direction and targets. It supports the idling functionality of the CPU by indicating to the CPU when it is active and inactive. 

\subsection{型定義}
\hypertarget{classDefaultFetch_a87d662eaeb9eab249d671b63cb4ba11a}{
\index{DefaultFetch@{DefaultFetch}!CPUPol@{CPUPol}}
\index{CPUPol@{CPUPol}!DefaultFetch@{DefaultFetch}}
\subsubsection[{CPUPol}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::CPUPol {\bf CPUPol}}}
\label{classDefaultFetch_a87d662eaeb9eab249d671b63cb4ba11a}
Typedefs from Impl. \hypertarget{classDefaultFetch_ab741745c86a14c765b999c11167636d9}{
\index{DefaultFetch@{DefaultFetch}!DynInst@{DynInst}}
\index{DynInst@{DynInst}!DefaultFetch@{DefaultFetch}}
\subsubsection[{DynInst}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInst {\bf DynInst}}}
\label{classDefaultFetch_ab741745c86a14c765b999c11167636d9}
\hypertarget{classDefaultFetch_a028ce10889c5f6450239d9e9a7347976}{
\index{DefaultFetch@{DefaultFetch}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!DefaultFetch@{DefaultFetch}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInstPtr {\bf DynInstPtr}}}
\label{classDefaultFetch_a028ce10889c5f6450239d9e9a7347976}
\hypertarget{classDefaultFetch_a5605d4fc727eae9e595325c90c0ec108}{
\index{DefaultFetch@{DefaultFetch}!ExtMachInst@{ExtMachInst}}
\index{ExtMachInst@{ExtMachInst}!DefaultFetch@{DefaultFetch}}
\subsubsection[{ExtMachInst}]{\setlength{\rightskip}{0pt plus 5cm}typedef TheISA::ExtMachInst {\bf ExtMachInst}}}
\label{classDefaultFetch_a5605d4fc727eae9e595325c90c0ec108}
\hypertarget{classDefaultFetch_a3aac8607069f16898ef53cfaa2d97aeb}{
\index{DefaultFetch@{DefaultFetch}!FetchStruct@{FetchStruct}}
\index{FetchStruct@{FetchStruct}!DefaultFetch@{DefaultFetch}}
\subsubsection[{FetchStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::FetchStruct {\bf FetchStruct}}}
\label{classDefaultFetch_a3aac8607069f16898ef53cfaa2d97aeb}
Typedefs from the CPU policy. \hypertarget{classDefaultFetch_a4617f528417b8f55f809ae0988284c9b}{
\index{DefaultFetch@{DefaultFetch}!MachInst@{MachInst}}
\index{MachInst@{MachInst}!DefaultFetch@{DefaultFetch}}
\subsubsection[{MachInst}]{\setlength{\rightskip}{0pt plus 5cm}typedef TheISA::MachInst {\bf MachInst}}}
\label{classDefaultFetch_a4617f528417b8f55f809ae0988284c9b}
Typedefs from ISA. \hypertarget{classDefaultFetch_a44622cf06940413482836cb62931ac3f}{
\index{DefaultFetch@{DefaultFetch}!O3CPU@{O3CPU}}
\index{O3CPU@{O3CPU}!DefaultFetch@{DefaultFetch}}
\subsubsection[{O3CPU}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::O3CPU {\bf O3CPU}}}
\label{classDefaultFetch_a44622cf06940413482836cb62931ac3f}
\hypertarget{classDefaultFetch_ab7dd3632ef639702a5c6e7c2c3a2f82a}{
\index{DefaultFetch@{DefaultFetch}!TimeStruct@{TimeStruct}}
\index{TimeStruct@{TimeStruct}!DefaultFetch@{DefaultFetch}}
\subsubsection[{TimeStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::TimeStruct {\bf TimeStruct}}}
\label{classDefaultFetch_ab7dd3632ef639702a5c6e7c2c3a2f82a}


\subsection{列挙型}
\hypertarget{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3}{
\index{DefaultFetch@{DefaultFetch}!FetchPriority@{FetchPriority}}
\index{FetchPriority@{FetchPriority}!DefaultFetch@{DefaultFetch}}
\subsubsection[{FetchPriority}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf FetchPriority}}}
\label{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3}
Fetching Policy, Add new policies here. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{SingleThread@{SingleThread}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!SingleThread@{SingleThread}}\item[{\em 
\hypertarget{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3ae01d52cbe97a50e79f4195cd27b3185b}{
SingleThread}
\label{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3ae01d52cbe97a50e79f4195cd27b3185b}
}]\index{RoundRobin@{RoundRobin}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!RoundRobin@{RoundRobin}}\item[{\em 
\hypertarget{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3a5c08841de48c15133dd26a4d9d740a11}{
RoundRobin}
\label{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3a5c08841de48c15133dd26a4d9d740a11}
}]\index{Branch@{Branch}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!Branch@{Branch}}\item[{\em 
\hypertarget{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3a070f4c50ffea5accaf5f88606fc088a8}{
Branch}
\label{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3a070f4c50ffea5accaf5f88606fc088a8}
}]\index{IQ@{IQ}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!IQ@{IQ}}\item[{\em 
\hypertarget{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3a7608065caa4249ff47a58c32d6f3c531}{
IQ}
\label{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3a7608065caa4249ff47a58c32d6f3c531}
}]\index{LSQ@{LSQ}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!LSQ@{LSQ}}\item[{\em 
\hypertarget{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3a4cc572b5087c4e67104941ee638a8512}{
LSQ}
\label{classDefaultFetch_a818d5f50fdcec74a1a445b4fa8b760e3a4cc572b5087c4e67104941ee638a8512}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
177                        {
178         SingleThread,
179         RoundRobin,
180         Branch,
181         IQ,
182         LSQ
183     };
\end{DoxyCode}
\hypertarget{classDefaultFetch_a64605db3d589dcf77a170612ff89515e}{
\index{DefaultFetch@{DefaultFetch}!FetchStatus@{FetchStatus}}
\index{FetchStatus@{FetchStatus}!DefaultFetch@{DefaultFetch}}
\subsubsection[{FetchStatus}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf FetchStatus}}}
\label{classDefaultFetch_a64605db3d589dcf77a170612ff89515e}
Overall fetch status. Used to determine if the CPU can deschedule itsef due to a lack of activity. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Active@{Active}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!Active@{Active}}\item[{\em 
\hypertarget{classDefaultFetch_a64605db3d589dcf77a170612ff89515ea26bd8444261cc58df7a86753c79d2520}{
Active}
\label{classDefaultFetch_a64605db3d589dcf77a170612ff89515ea26bd8444261cc58df7a86753c79d2520}
}]\index{Inactive@{Inactive}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!Inactive@{Inactive}}\item[{\em 
\hypertarget{classDefaultFetch_a64605db3d589dcf77a170612ff89515ea969c924a722daf6334fca64346092ae6}{
Inactive}
\label{classDefaultFetch_a64605db3d589dcf77a170612ff89515ea969c924a722daf6334fca64346092ae6}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
155                      {
156         Active,
157         Inactive
158     };
\end{DoxyCode}
\hypertarget{classDefaultFetch_ae2739961013a00cede621d4d72f2173c}{
\index{DefaultFetch@{DefaultFetch}!ThreadStatus@{ThreadStatus}}
\index{ThreadStatus@{ThreadStatus}!DefaultFetch@{DefaultFetch}}
\subsubsection[{ThreadStatus}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ThreadStatus}}}
\label{classDefaultFetch_ae2739961013a00cede621d4d72f2173c}
Individual thread status. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Running@{Running}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!Running@{Running}}\item[{\em 
\hypertarget{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca2f5f2c4a8c4f4f0519d503dcdfbf55cb}{
Running}
\label{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca2f5f2c4a8c4f4f0519d503dcdfbf55cb}
}]\index{Idle@{Idle}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!Idle@{Idle}}\item[{\em 
\hypertarget{classDefaultFetch_ae2739961013a00cede621d4d72f2173cad3fa9ae9431d6cb1772f9d9df48cab19}{
Idle}
\label{classDefaultFetch_ae2739961013a00cede621d4d72f2173cad3fa9ae9431d6cb1772f9d9df48cab19}
}]\index{Squashing@{Squashing}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!Squashing@{Squashing}}\item[{\em 
\hypertarget{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca22a648855197e326dc88f548634c0ec7}{
Squashing}
\label{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca22a648855197e326dc88f548634c0ec7}
}]\index{Blocked@{Blocked}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!Blocked@{Blocked}}\item[{\em 
\hypertarget{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca9463ee9b8700258a1019b4b9d2d77a30}{
Blocked}
\label{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca9463ee9b8700258a1019b4b9d2d77a30}
}]\index{Fetching@{Fetching}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!Fetching@{Fetching}}\item[{\em 
\hypertarget{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca718b7867aa13dd84937c83334380edee}{
Fetching}
\label{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca718b7867aa13dd84937c83334380edee}
}]\index{TrapPending@{TrapPending}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!TrapPending@{TrapPending}}\item[{\em 
\hypertarget{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca8c49adf6da5f507150d403610c684877}{
TrapPending}
\label{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca8c49adf6da5f507150d403610c684877}
}]\index{QuiescePending@{QuiescePending}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!QuiescePending@{QuiescePending}}\item[{\em 
\hypertarget{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca6dd2239b509a3ed085ad3bddda99cb16}{
QuiescePending}
\label{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca6dd2239b509a3ed085ad3bddda99cb16}
}]\index{ItlbWait@{ItlbWait}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!ItlbWait@{ItlbWait}}\item[{\em 
\hypertarget{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca2872442035b8be061f050fdf94761d33}{
ItlbWait}
\label{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca2872442035b8be061f050fdf94761d33}
}]\index{IcacheWaitResponse@{IcacheWaitResponse}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!IcacheWaitResponse@{IcacheWaitResponse}}\item[{\em 
\hypertarget{classDefaultFetch_ae2739961013a00cede621d4d72f2173caa694766f134e9cd81f5ad5b91dedf852}{
IcacheWaitResponse}
\label{classDefaultFetch_ae2739961013a00cede621d4d72f2173caa694766f134e9cd81f5ad5b91dedf852}
}]\index{IcacheWaitRetry@{IcacheWaitRetry}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!IcacheWaitRetry@{IcacheWaitRetry}}\item[{\em 
\hypertarget{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca2a36c8d85e537909b8fa14af846e48a3}{
IcacheWaitRetry}
\label{classDefaultFetch_ae2739961013a00cede621d4d72f2173ca2a36c8d85e537909b8fa14af846e48a3}
}]\index{IcacheAccessComplete@{IcacheAccessComplete}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!IcacheAccessComplete@{IcacheAccessComplete}}\item[{\em 
\hypertarget{classDefaultFetch_ae2739961013a00cede621d4d72f2173caff0dbe49b2bc9aee96de6b007b5b826e}{
IcacheAccessComplete}
\label{classDefaultFetch_ae2739961013a00cede621d4d72f2173caff0dbe49b2bc9aee96de6b007b5b826e}
}]\index{NoGoodAddr@{NoGoodAddr}!DefaultFetch@{DefaultFetch}}\index{DefaultFetch@{DefaultFetch}!NoGoodAddr@{NoGoodAddr}}\item[{\em 
\hypertarget{classDefaultFetch_ae2739961013a00cede621d4d72f2173caadf72b4e66cdfa8a56beab05bb411da6}{
NoGoodAddr}
\label{classDefaultFetch_ae2739961013a00cede621d4d72f2173caadf72b4e66cdfa8a56beab05bb411da6}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
161                       {
162         Running,
163         Idle,
164         Squashing,
165         Blocked,
166         Fetching,
167         TrapPending,
168         QuiescePending,
169         ItlbWait,
170         IcacheWaitResponse,
171         IcacheWaitRetry,
172         IcacheAccessComplete,
173         NoGoodAddr
174     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classDefaultFetch_a96cb569fd8ae5efebb8e7716f435d9d2}{
\index{DefaultFetch@{DefaultFetch}!DefaultFetch@{DefaultFetch}}
\index{DefaultFetch@{DefaultFetch}!DefaultFetch@{DefaultFetch}}
\subsubsection[{DefaultFetch}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DefaultFetch} ({\bf O3CPU} $\ast$ {\em \_\-cpu}, \/  DerivO3CPUParams $\ast$ {\em params})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_a96cb569fd8ae5efebb8e7716f435d9d2}
\hyperlink{classDefaultFetch}{DefaultFetch} constructor. 


\begin{DoxyCode}
79     : cpu(_cpu),
80       decodeToFetchDelay(params->decodeToFetchDelay),
81       renameToFetchDelay(params->renameToFetchDelay),
82       iewToFetchDelay(params->iewToFetchDelay),
83       commitToFetchDelay(params->commitToFetchDelay),
84       fetchWidth(params->fetchWidth),
85       retryPkt(NULL),
86       retryTid(InvalidThreadID),
87       cacheBlkSize(cpu->cacheLineSize()),
88       fetchBufferSize(params->fetchBufferSize),
89       fetchBufferMask(fetchBufferSize - 1),
90       numThreads(params->numThreads),
91       numFetchingThreads(params->smtNumFetchingThreads),
92       finishTranslationEvent(this)
93 {
94     if (numThreads > Impl::MaxThreads)
95         fatal("numThreads (%d) is larger than compiled limit (%d),\n"
96               "\tincrease MaxThreads in src/cpu/o3/impl.hh\n",
97               numThreads, static_cast<int>(Impl::MaxThreads));
98     if (fetchWidth > Impl::MaxWidth)
99         fatal("fetchWidth (%d) is larger than compiled limit (%d),\n"
100              "\tincrease MaxWidth in src/cpu/o3/impl.hh\n",
101              fetchWidth, static_cast<int>(Impl::MaxWidth));
102     if (fetchBufferSize > cacheBlkSize)
103         fatal("fetch buffer size (%u bytes) is greater than the cache "
104               "block size (%u bytes)\n", fetchBufferSize, cacheBlkSize);
105     if (cacheBlkSize % fetchBufferSize)
106         fatal("cache block (%u bytes) is not a multiple of the "
107               "fetch buffer (%u bytes)\n", cacheBlkSize, fetchBufferSize);
108 
109     std::string policy = params->smtFetchPolicy;
110 
111     // Convert string to lowercase
112     std::transform(policy.begin(), policy.end(), policy.begin(),
113                    (int(*)(int)) tolower);
114 
115     // Figure out fetch policy
116     if (policy == "singlethread") {
117         fetchPolicy = SingleThread;
118         if (numThreads > 1)
119             panic("Invalid Fetch Policy for a SMT workload.");
120     } else if (policy == "roundrobin") {
121         fetchPolicy = RoundRobin;
122         DPRINTF(Fetch, "Fetch policy set to Round Robin\n");
123     } else if (policy == "branch") {
124         fetchPolicy = Branch;
125         DPRINTF(Fetch, "Fetch policy set to Branch Count\n");
126     } else if (policy == "iqcount") {
127         fetchPolicy = IQ;
128         DPRINTF(Fetch, "Fetch policy set to IQ count\n");
129     } else if (policy == "lsqcount") {
130         fetchPolicy = LSQ;
131         DPRINTF(Fetch, "Fetch policy set to LSQ count\n");
132     } else {
133         fatal("Invalid Fetch Policy. Options Are: {SingleThread,"
134               " RoundRobin,LSQcount,IQcount}\n");
135     }
136 
137     // Get the size of an instruction.
138     instSize = sizeof(TheISA::MachInst);
139 
140     for (int i = 0; i < Impl::MaxThreads; i++) {
141         decoder[i] = NULL;
142         fetchBuffer[i] = NULL;
143         fetchBufferPC[i] = 0;
144         fetchBufferValid[i] = false;
145     }
146 
147     branchPred = params->branchPred;
148 
149     for (ThreadID tid = 0; tid < numThreads; tid++) {
150         decoder[tid] = new TheISA::Decoder;
151         // Create space to buffer the cache line data,
152         // which may not hold the entire cache line.
153         fetchBuffer[tid] = new uint8_t[fetchBufferSize];
154     }
155 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classDefaultFetch_adbe8a1ec70863059cb0e121edc864a14}{
\index{DefaultFetch@{DefaultFetch}!branchCount@{branchCount}}
\index{branchCount@{branchCount}!DefaultFetch@{DefaultFetch}}
\subsubsection[{branchCount}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} branchCount ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_adbe8a1ec70863059cb0e121edc864a14}
Returns the appropriate thread to fetch using the branch count policy. 


\begin{DoxyCode}
1570 {
1571 #if 0
1572     list<ThreadID>::iterator thread = activeThreads->begin();
1573     assert(thread != activeThreads->end());
1574     ThreadID tid = *thread;
1575 #endif
1576 
1577     panic("Branch Count Fetch policy unimplemented\n");
1578     return InvalidThreadID;
1579 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a9c38c3c5f6bb4a7c1919ca7d3d4e12dc}{
\index{DefaultFetch@{DefaultFetch}!buildInst@{buildInst}}
\index{buildInst@{buildInst}!DefaultFetch@{DefaultFetch}}
\subsubsection[{buildInst}]{\setlength{\rightskip}{0pt plus 5cm}Impl::DynInstPtr buildInst ({\bf ThreadID} {\em tid}, \/  {\bf StaticInstPtr} {\em staticInst}, \/  {\bf StaticInstPtr} {\em curMacroop}, \/  TheISA::PCState {\em thisPC}, \/  TheISA::PCState {\em nextPC}, \/  bool {\em trace})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_a9c38c3c5f6bb4a7c1919ca7d3d4e12dc}



\begin{DoxyCode}
1090 {
1091     // Get a sequence number.
1092     InstSeqNum seq = cpu->getAndIncrementInstSeq();
1093 
1094     // Create a new DynInst from the instruction fetched.
1095     DynInstPtr instruction =
1096         new DynInst(staticInst, curMacroop, thisPC, nextPC, seq, cpu);
1097     instruction->setTid(tid);
1098 
1099     instruction->setASID(tid);
1100 
1101     instruction->setThreadState(cpu->thread[tid]);
1102 
1103     DPRINTF(Fetch, "[tid:%i]: Instruction PC %#x (%d) created "
1104             "[sn:%lli].\n", tid, thisPC.instAddr(),
1105             thisPC.microPC(), seq);
1106 
1107     DPRINTF(Fetch, "[tid:%i]: Instruction is: %s\n", tid,
1108             instruction->staticInst->
1109             disassemble(thisPC.instAddr()));
1110 
1111 #if TRACING_ON
1112     if (trace) {
1113         instruction->traceData =
1114             cpu->getTracer()->getInstRecord(curTick(), cpu->tcBase(tid),
1115                     instruction->staticInst, thisPC, curMacroop);
1116     }
1117 #else
1118     instruction->traceData = NULL;
1119 #endif
1120 
1121     // Add instruction to the CPU's list of instructions.
1122     instruction->setInstListIt(cpu->addInst(instruction));
1123 
1124     // Write the instruction to the first slot in the queue
1125     // that heads to decode.
1126     assert(numInst < fetchWidth);
1127     toDecode->insts[toDecode->size++] = instruction;
1128 
1129     // Keep track of if we can take an interrupt at this boundary
1130     delayedCommit[tid] = instruction->isDelayedCommit();
1131 
1132     return instruction;
1133 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a0949b3c8e74ae282010e2a8698525c72}{
\index{DefaultFetch@{DefaultFetch}!checkInterrupt@{checkInterrupt}}
\index{checkInterrupt@{checkInterrupt}!DefaultFetch@{DefaultFetch}}
\subsubsection[{checkInterrupt}]{\setlength{\rightskip}{0pt plus 5cm}bool checkInterrupt ({\bf Addr} {\em pc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_a0949b3c8e74ae282010e2a8698525c72}
\hyperlink{classCheck}{Check} if an interrupt is pending and that we need to handle 


\begin{DoxyCode}
302     {
303         return (interruptPending && (THE_ISA != ALPHA_ISA || !(pc & 0x3)));
304     }
\end{DoxyCode}
\hypertarget{classDefaultFetch_af77f2bf38a75182c65e633b9fdf295d2}{
\index{DefaultFetch@{DefaultFetch}!checkSignalsAndUpdate@{checkSignalsAndUpdate}}
\index{checkSignalsAndUpdate@{checkSignalsAndUpdate}!DefaultFetch@{DefaultFetch}}
\subsubsection[{checkSignalsAndUpdate}]{\setlength{\rightskip}{0pt plus 5cm}bool checkSignalsAndUpdate ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_af77f2bf38a75182c65e633b9fdf295d2}
Checks all input signals and updates the status as necessary. \begin{DoxyReturn}{戻り値}
: Returns if the status has changed due to input signals. 
\end{DoxyReturn}



\begin{DoxyCode}
943 {
944     // Update the per thread stall statuses.
945     if (fromDecode->decodeBlock[tid]) {
946         stalls[tid].decode = true;
947     }
948 
949     if (fromDecode->decodeUnblock[tid]) {
950         assert(stalls[tid].decode);
951         assert(!fromDecode->decodeBlock[tid]);
952         stalls[tid].decode = false;
953     }
954 
955     if (fromRename->renameBlock[tid]) {
956         stalls[tid].rename = true;
957     }
958 
959     if (fromRename->renameUnblock[tid]) {
960         assert(stalls[tid].rename);
961         assert(!fromRename->renameBlock[tid]);
962         stalls[tid].rename = false;
963     }
964 
965     if (fromIEW->iewBlock[tid]) {
966         stalls[tid].iew = true;
967     }
968 
969     if (fromIEW->iewUnblock[tid]) {
970         assert(stalls[tid].iew);
971         assert(!fromIEW->iewBlock[tid]);
972         stalls[tid].iew = false;
973     }
974 
975     if (fromCommit->commitBlock[tid]) {
976         stalls[tid].commit = true;
977     }
978 
979     if (fromCommit->commitUnblock[tid]) {
980         assert(stalls[tid].commit);
981         assert(!fromCommit->commitBlock[tid]);
982         stalls[tid].commit = false;
983     }
984 
985     // Check squash signals from commit.
986     if (fromCommit->commitInfo[tid].squash) {
987 
988         DPRINTF(Fetch, "[tid:%u]: Squashing instructions due to squash "
989                 "from commit.\n",tid);
990         // In any case, squash.
991         squash(fromCommit->commitInfo[tid].pc,
992                fromCommit->commitInfo[tid].doneSeqNum,
993                fromCommit->commitInfo[tid].squashInst, tid);
994 
995         // If it was a branch mispredict on a control instruction, update the
996         // branch predictor with that instruction, otherwise just kill the
997         // invalid state we generated in after sequence number
998         if (fromCommit->commitInfo[tid].mispredictInst &&
999             fromCommit->commitInfo[tid].mispredictInst->isControl()) {
1000             branchPred->squash(fromCommit->commitInfo[tid].doneSeqNum,
1001                               fromCommit->commitInfo[tid].pc,
1002                               fromCommit->commitInfo[tid].branchTaken,
1003                               tid);
1004         } else {
1005             branchPred->squash(fromCommit->commitInfo[tid].doneSeqNum,
1006                               tid);
1007         }
1008 
1009         return true;
1010     } else if (fromCommit->commitInfo[tid].doneSeqNum) {
1011         // Update the branch predictor if it wasn't a squashed instruction
1012         // that was broadcasted.
1013         branchPred->update(fromCommit->commitInfo[tid].doneSeqNum, tid);
1014     }
1015 
1016     // Check ROB squash signals from commit.
1017     if (fromCommit->commitInfo[tid].robSquashing) {
1018         DPRINTF(Fetch, "[tid:%u]: ROB is still squashing.\n", tid);
1019 
1020         // Continue to squash.
1021         fetchStatus[tid] = Squashing;
1022 
1023         return true;
1024     }
1025 
1026     // Check squash signals from decode.
1027     if (fromDecode->decodeInfo[tid].squash) {
1028         DPRINTF(Fetch, "[tid:%u]: Squashing instructions due to squash "
1029                 "from decode.\n",tid);
1030 
1031         // Update the branch predictor.
1032         if (fromDecode->decodeInfo[tid].branchMispredict) {
1033             branchPred->squash(fromDecode->decodeInfo[tid].doneSeqNum,
1034                               fromDecode->decodeInfo[tid].nextPC,
1035                               fromDecode->decodeInfo[tid].branchTaken,
1036                               tid);
1037         } else {
1038             branchPred->squash(fromDecode->decodeInfo[tid].doneSeqNum,
1039                               tid);
1040         }
1041 
1042         if (fetchStatus[tid] != Squashing) {
1043 
1044             DPRINTF(Fetch, "Squashing from decode with PC = %s\n",
1045                 fromDecode->decodeInfo[tid].nextPC);
1046             // Squash unless we're already squashing
1047             squashFromDecode(fromDecode->decodeInfo[tid].nextPC,
1048                              fromDecode->decodeInfo[tid].squashInst,
1049                              fromDecode->decodeInfo[tid].doneSeqNum,
1050                              tid);
1051 
1052             return true;
1053         }
1054     }
1055 
1056     if (checkStall(tid) &&
1057         fetchStatus[tid] != IcacheWaitResponse &&
1058         fetchStatus[tid] != IcacheWaitRetry &&
1059         fetchStatus[tid] != ItlbWait &&
1060         fetchStatus[tid] != QuiescePending) {
1061         DPRINTF(Fetch, "[tid:%i]: Setting to blocked\n",tid);
1062 
1063         fetchStatus[tid] = Blocked;
1064 
1065         return true;
1066     }
1067 
1068     if (fetchStatus[tid] == Blocked ||
1069         fetchStatus[tid] == Squashing) {
1070         // Switch status to running if fetch isn't being told to block or
1071         // squash this cycle.
1072         DPRINTF(Fetch, "[tid:%i]: Done squashing, switching to running.\n",
1073                 tid);
1074 
1075         fetchStatus[tid] = Running;
1076 
1077         return true;
1078     }
1079 
1080     // If we've reached this point, we have not gotten any signals that
1081     // cause fetch to change its status.  Fetch remains the same as before.
1082     return false;
1083 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a6ba4f2f95d991f5be818dabf7500feed}{
\index{DefaultFetch@{DefaultFetch}!checkStall@{checkStall}}
\index{checkStall@{checkStall}!DefaultFetch@{DefaultFetch}}
\subsubsection[{checkStall}]{\setlength{\rightskip}{0pt plus 5cm}bool checkStall ({\bf ThreadID} {\em tid}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_a6ba4f2f95d991f5be818dabf7500feed}
Checks if a thread is stalled. 


\begin{DoxyCode}
792 {
793     bool ret_val = false;
794 
795     if (cpu->contextSwitch) {
796         DPRINTF(Fetch,"[tid:%i]: Stalling for a context switch.\n",tid);
797         ret_val = true;
798     } else if (stalls[tid].drain) {
799         assert(cpu->isDraining());
800         DPRINTF(Fetch,"[tid:%i]: Drain stall detected.\n",tid);
801         ret_val = true;
802     } else if (stalls[tid].decode) {
803         DPRINTF(Fetch,"[tid:%i]: Stall from Decode stage detected.\n",tid);
804         ret_val = true;
805     } else if (stalls[tid].rename) {
806         DPRINTF(Fetch,"[tid:%i]: Stall from Rename stage detected.\n",tid);
807         ret_val = true;
808     } else if (stalls[tid].iew) {
809         DPRINTF(Fetch,"[tid:%i]: Stall from IEW stage detected.\n",tid);
810         ret_val = true;
811     } else if (stalls[tid].commit) {
812         DPRINTF(Fetch,"[tid:%i]: Stall from Commit stage detected.\n",tid);
813         ret_val = true;
814     }
815 
816     return ret_val;
817 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a9c960f5de0fbb0511596cba5039660a3}{
\index{DefaultFetch@{DefaultFetch}!doSquash@{doSquash}}
\index{doSquash@{doSquash}!DefaultFetch@{DefaultFetch}}
\subsubsection[{doSquash}]{\setlength{\rightskip}{0pt plus 5cm}void doSquash (const TheISA::PCState \& {\em newPC}, \/  const {\bf DynInstPtr} {\em squashInst}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_a9c960f5de0fbb0511596cba5039660a3}
Squashes a specific thread and resets the PC. 


\begin{DoxyCode}
728 {
729     DPRINTF(Fetch, "[tid:%i]: Squashing, setting PC to: %s.\n",
730             tid, newPC);
731 
732     pc[tid] = newPC;
733     fetchOffset[tid] = 0;
734     if (squashInst && squashInst->pcState().instAddr() == newPC.instAddr())
735         macroop[tid] = squashInst->macroop;
736     else
737         macroop[tid] = NULL;
738     decoder[tid]->reset();
739 
740     // Clear the icache miss if it's outstanding.
741     if (fetchStatus[tid] == IcacheWaitResponse) {
742         DPRINTF(Fetch, "[tid:%i]: Squashing outstanding Icache miss.\n",
743                 tid);
744         memReq[tid] = NULL;
745     } else if (fetchStatus[tid] == ItlbWait) {
746         DPRINTF(Fetch, "[tid:%i]: Squashing outstanding ITLB miss.\n",
747                 tid);
748         memReq[tid] = NULL;
749     }
750 
751     // Get rid of the retrying packet if it was from this thread.
752     if (retryTid == tid) {
753         assert(cacheBlocked);
754         if (retryPkt) {
755             delete retryPkt->req;
756             delete retryPkt;
757         }
758         retryPkt = NULL;
759         retryTid = InvalidThreadID;
760     }
761 
762     fetchStatus[tid] = Squashing;
763 
764     // microops are being squashed, it is not known wheather the
765     // youngest non-squashed microop was  marked delayed commit
766     // or not. Setting the flag to true ensures that the
767     // interrupts are not handled when they cannot be, though
768     // some opportunities to handle interrupts may be missed.
769     delayedCommit[tid] = true;
770 
771     ++fetchSquashCycles;
772 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a8f020d3237536fe007fc488c4125c5d8}{
\index{DefaultFetch@{DefaultFetch}!drainResume@{drainResume}}
\index{drainResume@{drainResume}!DefaultFetch@{DefaultFetch}}
\subsubsection[{drainResume}]{\setlength{\rightskip}{0pt plus 5cm}void drainResume ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_a8f020d3237536fe007fc488c4125c5d8}
Resume after a drain. 


\begin{DoxyCode}
421 {
422     for (ThreadID i = 0; i < Impl::MaxThreads; ++i)
423         stalls[i].drain = false;
424 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a0240eb42fa57fe5d3788093f62b77347}{
\index{DefaultFetch@{DefaultFetch}!drainSanityCheck@{drainSanityCheck}}
\index{drainSanityCheck@{drainSanityCheck}!DefaultFetch@{DefaultFetch}}
\subsubsection[{drainSanityCheck}]{\setlength{\rightskip}{0pt plus 5cm}void drainSanityCheck () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_a0240eb42fa57fe5d3788093f62b77347}
Perform sanity checks after a drain. 


\begin{DoxyCode}
429 {
430     assert(isDrained());
431     assert(retryPkt == NULL);
432     assert(retryTid == InvalidThreadID);
433     assert(!cacheBlocked);
434     assert(!interruptPending);
435 
436     for (ThreadID i = 0; i < numThreads; ++i) {
437         assert(!memReq[i]);
438         assert(!stalls[i].decode);
439         assert(!stalls[i].rename);
440         assert(!stalls[i].iew);
441         assert(!stalls[i].commit);
442         assert(fetchStatus[i] == Idle || stalls[i].drain);
443     }
444 
445     branchPred->drainSanityCheck();
446 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_ad1c01dde67aa909bd829896f6f587502}{
\index{DefaultFetch@{DefaultFetch}!drainStall@{drainStall}}
\index{drainStall@{drainStall}!DefaultFetch@{DefaultFetch}}
\subsubsection[{drainStall}]{\setlength{\rightskip}{0pt plus 5cm}void drainStall ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_ad1c01dde67aa909bd829896f6f587502}
Stall the fetch stage after reaching a safe drain point.

The CPU uses this method to stop fetching instructions from a thread that has been drained. The drain stall is different from all other stalls in that it is signaled instantly from the commit stage (without the normal communication delay) when it has reached a safe point to drain from. 


\begin{DoxyCode}
483 {
484     assert(cpu->isDraining());
485     assert(!stalls[tid].drain);
486     DPRINTF(Drain, "%i: Thread drained.\n", tid);
487     stalls[tid].drain = true;
488 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a77759cf15b084e00a9e4e8ca810a0be7}{
\index{DefaultFetch@{DefaultFetch}!fetch@{fetch}}
\index{fetch@{fetch}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetch}]{\setlength{\rightskip}{0pt plus 5cm}void fetch (bool \& {\em status\_\-change})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_a77759cf15b084e00a9e4e8ca810a0be7}
Does the actual fetching of instructions and passing them on to the next stage. 
\begin{DoxyParams}{引数}
\item[{\em status\_\-change}]\hyperlink{classDefaultFetch_a77759cf15b084e00a9e4e8ca810a0be7}{fetch()} sets this variable if there was a status change (ie switching to IcacheMissStall). \end{DoxyParams}



\begin{DoxyCode}
1138 {
1140     // Start actual fetch
1142     ThreadID tid = getFetchingThread(fetchPolicy);
1143 
1144     assert(!cpu->switchedOut());
1145 
1146     if (tid == InvalidThreadID) {
1147         // Breaks looping condition in tick()
1148         threadFetched = numFetchingThreads;
1149 
1150         if (numThreads == 1) {  // @todo Per-thread stats
1151             profileStall(0);
1152         }
1153 
1154         return;
1155     }
1156 
1157     DPRINTF(Fetch, "Attempting to fetch from [tid:%i]\n", tid);
1158 
1159     // The current PC.
1160     TheISA::PCState thisPC = pc[tid];
1161 
1162     Addr pcOffset = fetchOffset[tid];
1163     Addr fetchAddr = (thisPC.instAddr() + pcOffset) & BaseCPU::PCMask;
1164 
1165     bool inRom = isRomMicroPC(thisPC.microPC());
1166 
1167     // If returning from the delay of a cache miss, then update the status
1168     // to running, otherwise do the cache access.  Possibly move this up
1169     // to tick() function.
1170     if (fetchStatus[tid] == IcacheAccessComplete) {
1171         DPRINTF(Fetch, "[tid:%i]: Icache miss is complete.\n", tid);
1172 
1173         fetchStatus[tid] = Running;
1174         status_change = true;
1175     } else if (fetchStatus[tid] == Running) {
1176         // Align the fetch PC so its at the start of a fetch buffer segment.
1177         Addr fetchBufferBlockPC = fetchBufferAlignPC(fetchAddr);
1178 
1179         // If buffer is no longer valid or fetchAddr has moved to point
1180         // to the next cache block, AND we have no remaining ucode
1181         // from a macro-op, then start fetch from icache.
1182         if (!(fetchBufferValid[tid] && fetchBufferBlockPC == fetchBufferPC[tid])
1183             && !inRom && !macroop[tid]) {
1184             DPRINTF(Fetch, "[tid:%i]: Attempting to translate and read "
1185                     "instruction, starting at PC %s.\n", tid, thisPC);
1186 
1187             fetchCacheLine(fetchAddr, tid, thisPC.instAddr());
1188 
1189             if (fetchStatus[tid] == IcacheWaitResponse)
1190                 ++icacheStallCycles;
1191             else if (fetchStatus[tid] == ItlbWait)
1192                 ++fetchTlbCycles;
1193             else
1194                 ++fetchMiscStallCycles;
1195             return;
1196         } else if ((checkInterrupt(thisPC.instAddr()) && !delayedCommit[tid])) {
1197             // Stall CPU if an interrupt is posted and we're not issuing
1198             // an delayed commit micro-op currently (delayed commit instructions
1199             // are not interruptable by interrupts, only faults)
1200             ++fetchMiscStallCycles;
1201             DPRINTF(Fetch, "[tid:%i]: Fetch is stalled!\n", tid);
1202             return;
1203         }
1204     } else {
1205         if (fetchStatus[tid] == Idle) {
1206             ++fetchIdleCycles;
1207             DPRINTF(Fetch, "[tid:%i]: Fetch is idle!\n", tid);
1208         }
1209 
1210         // Status is Idle, so fetch should do nothing.
1211         return;
1212     }
1213 
1214     ++fetchCycles;
1215 
1216     TheISA::PCState nextPC = thisPC;
1217 
1218     StaticInstPtr staticInst = NULL;
1219     StaticInstPtr curMacroop = macroop[tid];
1220 
1221     // If the read of the first instruction was successful, then grab the
1222     // instructions from the rest of the cache line and put them into the
1223     // queue heading to decode.
1224 
1225     DPRINTF(Fetch, "[tid:%i]: Adding instructions to queue to "
1226             "decode.\n", tid);
1227 
1228     // Need to keep track of whether or not a predicted branch
1229     // ended this fetch block.
1230     bool predictedBranch = false;
1231 
1232     TheISA::MachInst *cacheInsts =
1233         reinterpret_cast<TheISA::MachInst *>(fetchBuffer[tid]);
1234 
1235     const unsigned numInsts = fetchBufferSize / instSize;
1236     unsigned blkOffset = (fetchAddr - fetchBufferPC[tid]) / instSize;
1237 
1238     // Loop through instruction memory from the cache.
1239     // Keep issuing while fetchWidth is available and branch is not
1240     // predicted taken
1241     while (numInst < fetchWidth && !predictedBranch) {
1242 
1243         // We need to process more memory if we aren't going to get a
1244         // StaticInst from the rom, the current macroop, or what's already
1245         // in the decoder.
1246         bool needMem = !inRom && !curMacroop &&
1247             !decoder[tid]->instReady();
1248         fetchAddr = (thisPC.instAddr() + pcOffset) & BaseCPU::PCMask;
1249         Addr fetchBufferBlockPC = fetchBufferAlignPC(fetchAddr);
1250 
1251         if (needMem) {
1252             // If buffer is no longer valid or fetchAddr has moved to point
1253             // to the next cache block then start fetch from icache.
1254             if (!fetchBufferValid[tid] ||
1255                 fetchBufferBlockPC != fetchBufferPC[tid])
1256                 break;
1257 
1258             if (blkOffset >= numInsts) {
1259                 // We need to process more memory, but we've run out of the
1260                 // current block.
1261                 break;
1262             }
1263 
1264             if (ISA_HAS_DELAY_SLOT && pcOffset == 0) {
1265                 // Walk past any annulled delay slot instructions.
1266                 Addr pcAddr = thisPC.instAddr() & BaseCPU::PCMask;
1267                 while (fetchAddr != pcAddr && blkOffset < numInsts) {
1268                     blkOffset++;
1269                     fetchAddr += instSize;
1270                 }
1271                 if (blkOffset >= numInsts)
1272                     break;
1273             }
1274 
1275             MachInst inst = TheISA::gtoh(cacheInsts[blkOffset]);
1276             decoder[tid]->moreBytes(thisPC, fetchAddr, inst);
1277 
1278             if (decoder[tid]->needMoreBytes()) {
1279                 blkOffset++;
1280                 fetchAddr += instSize;
1281                 pcOffset += instSize;
1282             }
1283         }
1284 
1285         // Extract as many instructions and/or microops as we can from
1286         // the memory we've processed so far.
1287         do {
1288             if (!(curMacroop || inRom)) {
1289                 if (decoder[tid]->instReady()) {
1290                     staticInst = decoder[tid]->decode(thisPC);
1291 
1292                     // Increment stat of fetched instructions.
1293                     ++fetchedInsts;
1294 
1295                     if (staticInst->isMacroop()) {
1296                         curMacroop = staticInst;
1297                     } else {
1298                         pcOffset = 0;
1299                     }
1300                 } else {
1301                     // We need more bytes for this instruction so blkOffset and
1302                     // pcOffset will be updated
1303                     break;
1304                 }
1305             }
1306             // Whether we're moving to a new macroop because we're at the
1307             // end of the current one, or the branch predictor incorrectly
1308             // thinks we are...
1309             bool newMacro = false;
1310             if (curMacroop || inRom) {
1311                 if (inRom) {
1312                     staticInst = cpu->microcodeRom.fetchMicroop(
1313                             thisPC.microPC(), curMacroop);
1314                 } else {
1315                     staticInst = curMacroop->fetchMicroop(thisPC.microPC());
1316                 }
1317                 newMacro |= staticInst->isLastMicroop();
1318             }
1319 
1320             DynInstPtr instruction =
1321                 buildInst(tid, staticInst, curMacroop,
1322                           thisPC, nextPC, true);
1323 
1324             ppFetch->notify(instruction);
1325             numInst++;
1326 
1327 #if TRACING_ON
1328             if (DTRACE(O3PipeView)) {
1329                 instruction->fetchTick = curTick();
1330             }
1331 #endif
1332 
1333             nextPC = thisPC;
1334 
1335             // If we're branching after this instruction, quite fetching
1336             // from the same block then.
1337             predictedBranch |= thisPC.branching();
1338             predictedBranch |=
1339                 lookupAndUpdateNextPC(instruction, nextPC);
1340             if (predictedBranch) {
1341                 DPRINTF(Fetch, "Branch detected with PC = %s\n", thisPC);
1342             }
1343 
1344             newMacro |= thisPC.instAddr() != nextPC.instAddr();
1345 
1346             // Move to the next instruction, unless we have a branch.
1347             thisPC = nextPC;
1348             inRom = isRomMicroPC(thisPC.microPC());
1349 
1350             if (newMacro) {
1351                 fetchAddr = thisPC.instAddr() & BaseCPU::PCMask;
1352                 blkOffset = (fetchAddr - fetchBufferPC[tid]) / instSize;
1353                 pcOffset = 0;
1354                 curMacroop = NULL;
1355             }
1356 
1357             if (instruction->isQuiesce()) {
1358                 DPRINTF(Fetch,
1359                         "Quiesce instruction encountered, halting fetch!");
1360                 fetchStatus[tid] = QuiescePending;
1361                 status_change = true;
1362                 break;
1363             }
1364         } while ((curMacroop || decoder[tid]->instReady()) &&
1365                  numInst < fetchWidth);
1366     }
1367 
1368     if (predictedBranch) {
1369         DPRINTF(Fetch, "[tid:%i]: Done fetching, predicted branch "
1370                 "instruction encountered.\n", tid);
1371     } else if (numInst >= fetchWidth) {
1372         DPRINTF(Fetch, "[tid:%i]: Done fetching, reached fetch bandwidth "
1373                 "for this cycle.\n", tid);
1374     } else if (blkOffset >= fetchBufferSize) {
1375         DPRINTF(Fetch, "[tid:%i]: Done fetching, reached the end of the"
1376                 "fetch buffer.\n", tid);
1377     }
1378 
1379     macroop[tid] = curMacroop;
1380     fetchOffset[tid] = pcOffset;
1381 
1382     if (numInst > 0) {
1383         wroteToTimeBuffer = true;
1384     }
1385 
1386     pc[tid] = thisPC;
1387 
1388     // pipeline a fetch if we're crossing a fetch buffer boundary and not in
1389     // a state that would preclude fetching
1390     fetchAddr = (thisPC.instAddr() + pcOffset) & BaseCPU::PCMask;
1391     Addr fetchBufferBlockPC = fetchBufferAlignPC(fetchAddr);
1392     issuePipelinedIfetch[tid] = fetchBufferBlockPC != fetchBufferPC[tid] &&
1393         fetchStatus[tid] != IcacheWaitResponse &&
1394         fetchStatus[tid] != ItlbWait &&
1395         fetchStatus[tid] != IcacheWaitRetry &&
1396         fetchStatus[tid] != QuiescePending &&
1397         !curMacroop;
1398 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a0c451948a0050595e5d23f57866f2797}{
\index{DefaultFetch@{DefaultFetch}!fetchBufferAlignPC@{fetchBufferAlignPC}}
\index{fetchBufferAlignPC@{fetchBufferAlignPC}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchBufferAlignPC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} fetchBufferAlignPC ({\bf Addr} {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_a0c451948a0050595e5d23f57866f2797}
Align a PC to the start of a fetch buffer block. 


\begin{DoxyCode}
351     {
352         return (addr & ~(fetchBufferMask));
353     }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a2ede53ea19a95876fd2418fcc329ef9a}{
\index{DefaultFetch@{DefaultFetch}!fetchCacheLine@{fetchCacheLine}}
\index{fetchCacheLine@{fetchCacheLine}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchCacheLine}]{\setlength{\rightskip}{0pt plus 5cm}bool fetchCacheLine ({\bf Addr} {\em vaddr}, \/  {\bf ThreadID} {\em tid}, \/  {\bf Addr} {\em pc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_a2ede53ea19a95876fd2418fcc329ef9a}
Fetches the cache line that contains the fetch PC. Returns any fault that happened. Puts the data into the class variable fetchBuffer, which may not hold the entire fetched cache line. 
\begin{DoxyParams}{引数}
\item[{\em vaddr}]The memory address that is being fetched from. \item[{\em ret\_\-fault}]The fault reference that will be set to the result of the icache access. \item[{\em tid}]Thread id. \item[{\em pc}]The actual PC of the current instruction. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Any fault that occured. 
\end{DoxyReturn}



\begin{DoxyCode}
572 {
573     Fault fault = NoFault;
574 
575     assert(!cpu->switchedOut());
576 
577     // @todo: not sure if these should block translation.
578     //AlphaDep
579     if (cacheBlocked) {
580         DPRINTF(Fetch, "[tid:%i] Can't fetch cache line, cache blocked\n",
581                 tid);
582         return false;
583     } else if (checkInterrupt(pc) && !delayedCommit[tid]) {
584         // Hold off fetch from getting new instructions when:
585         // Cache is blocked, or
586         // while an interrupt is pending and we're not in PAL mode, or
587         // fetch is switched out.
588         DPRINTF(Fetch, "[tid:%i] Can't fetch cache line, interrupt pending\n",
589                 tid);
590         return false;
591     }
592 
593     // Align the fetch address to the start of a fetch buffer segment.
594     Addr fetchBufferBlockPC = fetchBufferAlignPC(vaddr);
595 
596     DPRINTF(Fetch, "[tid:%i] Fetching cache line %#x for addr %#x\n",
597             tid, fetchBufferBlockPC, vaddr);
598 
599     // Setup the memReq to do a read of the first instruction's address.
600     // Set the appropriate read size and flags as well.
601     // Build request here.
602     RequestPtr mem_req =
603         new Request(tid, fetchBufferBlockPC, fetchBufferSize,
604                     Request::INST_FETCH, cpu->instMasterId(), pc,
605                     cpu->thread[tid]->contextId(), tid);
606 
607     mem_req->taskId(cpu->taskId());
608 
609     memReq[tid] = mem_req;
610 
611     // Initiate translation of the icache block
612     fetchStatus[tid] = ItlbWait;
613     FetchTranslation *trans = new FetchTranslation(this);
614     cpu->itb->translateTiming(mem_req, cpu->thread[tid]->getTC(),
615                               trans, BaseTLB::Execute);
616     return true;
617 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_ac7dca7de206b6388e989a53b56634ad4}{
\index{DefaultFetch@{DefaultFetch}!finishTranslation@{finishTranslation}}
\index{finishTranslation@{finishTranslation}!DefaultFetch@{DefaultFetch}}
\subsubsection[{finishTranslation}]{\setlength{\rightskip}{0pt plus 5cm}void finishTranslation ({\bf Fault} {\em fault}, \/  {\bf RequestPtr} {\em mem\_\-req})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_ac7dca7de206b6388e989a53b56634ad4}



\begin{DoxyCode}
622 {
623     ThreadID tid = mem_req->threadId();
624     Addr fetchBufferBlockPC = mem_req->getVaddr();
625 
626     assert(!cpu->switchedOut());
627 
628     // Wake up CPU if it was idle
629     cpu->wakeCPU();
630 
631     if (fetchStatus[tid] != ItlbWait || mem_req != memReq[tid] ||
632         mem_req->getVaddr() != memReq[tid]->getVaddr()) {
633         DPRINTF(Fetch, "[tid:%i] Ignoring itlb completed after squash\n",
634                 tid);
635         ++fetchTlbSquashes;
636         delete mem_req;
637         return;
638     }
639 
640 
641     // If translation was successful, attempt to read the icache block.
642     if (fault == NoFault) {
643         // Check that we're not going off into random memory
644         // If we have, just wait around for commit to squash something and put
645         // us on the right track
646         if (!cpu->system->isMemAddr(mem_req->getPaddr())) {
647             warn("Address %#x is outside of physical memory, stopping fetch\n",
648                     mem_req->getPaddr());
649             fetchStatus[tid] = NoGoodAddr;
650             delete mem_req;
651             memReq[tid] = NULL;
652             return;
653         }
654 
655         // Build packet here.
656         PacketPtr data_pkt = new Packet(mem_req, MemCmd::ReadReq);
657         data_pkt->dataDynamicArray(new uint8_t[fetchBufferSize]);
658 
659         fetchBufferPC[tid] = fetchBufferBlockPC;
660         fetchBufferValid[tid] = false;
661         DPRINTF(Fetch, "Fetch: Doing instruction read.\n");
662 
663         fetchedCacheLines++;
664 
665         // Access the cache.
666         if (!cpu->getInstPort().sendTimingReq(data_pkt)) {
667             assert(retryPkt == NULL);
668             assert(retryTid == InvalidThreadID);
669             DPRINTF(Fetch, "[tid:%i] Out of MSHRs!\n", tid);
670 
671             fetchStatus[tid] = IcacheWaitRetry;
672             retryPkt = data_pkt;
673             retryTid = tid;
674             cacheBlocked = true;
675         } else {
676             DPRINTF(Fetch, "[tid:%i]: Doing Icache access.\n", tid);
677             DPRINTF(Activity, "[tid:%i]: Activity: Waiting on I-cache "
678                     "response.\n", tid);
679             lastIcacheStall[tid] = curTick();
680             fetchStatus[tid] = IcacheWaitResponse;
681         }
682     } else {
683         if (!(numInst < fetchWidth)) {
684             assert(!finishTranslationEvent.scheduled());
685             finishTranslationEvent.setFault(fault);
686             finishTranslationEvent.setReq(mem_req);
687             cpu->schedule(finishTranslationEvent,
688                           cpu->clockEdge(Cycles(1)));
689             return;
690         }
691         DPRINTF(Fetch, "[tid:%i] Got back req with addr %#x but expected %#x\n",
692                 tid, mem_req->getVaddr(), memReq[tid]->getVaddr());
693         // Translation faulted, icache request won't be sent.
694         delete mem_req;
695         memReq[tid] = NULL;
696 
697         // Send the fault to commit.  This thread will not do anything
698         // until commit handles the fault.  The only other way it can
699         // wake up is if a squash comes along and changes the PC.
700         TheISA::PCState fetchPC = pc[tid];
701 
702         DPRINTF(Fetch, "[tid:%i]: Translation faulted, building noop.\n", tid);
703         // We will use a nop in ordier to carry the fault.
704         DynInstPtr instruction = buildInst(tid,
705                 decoder[tid]->decode(TheISA::NoopMachInst, fetchPC.instAddr()),
706                 NULL, fetchPC, fetchPC, false);
707 
708         instruction->setPredTarg(fetchPC);
709         instruction->fault = fault;
710         wroteToTimeBuffer = true;
711 
712         DPRINTF(Activity, "Activity this cycle.\n");
713         cpu->activityThisCycle();
714 
715         fetchStatus[tid] = TrapPending;
716 
717         DPRINTF(Fetch, "[tid:%i]: Blocked, need to handle the trap.\n", tid);
718         DPRINTF(Fetch, "[tid:%i]: fault (%s) detected @ PC %s.\n",
719                 tid, fault->name(), pc[tid]);
720     }
721     _status = updateFetchStatus();
722 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a4a20466270bc79a695af63ea67a35576}{
\index{DefaultFetch@{DefaultFetch}!getFetchingThread@{getFetchingThread}}
\index{getFetchingThread@{getFetchingThread}!DefaultFetch@{DefaultFetch}}
\subsubsection[{getFetchingThread}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} getFetchingThread ({\bf FetchPriority} \& {\em fetch\_\-priority})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_a4a20466270bc79a695af63ea67a35576}
Returns the appropriate thread to fetch, given the fetch policy. 


\begin{DoxyCode}
1431 {
1432     if (numThreads > 1) {
1433         switch (fetch_priority) {
1434 
1435           case SingleThread:
1436             return 0;
1437 
1438           case RoundRobin:
1439             return roundRobin();
1440 
1441           case IQ:
1442             return iqCount();
1443 
1444           case LSQ:
1445             return lsqCount();
1446 
1447           case Branch:
1448             return branchCount();
1449 
1450           default:
1451             return InvalidThreadID;
1452         }
1453     } else {
1454         list<ThreadID>::iterator thread = activeThreads->begin();
1455         if (thread == activeThreads->end()) {
1456             return InvalidThreadID;
1457         }
1458 
1459         ThreadID tid = *thread;
1460 
1461         if (fetchStatus[tid] == Running ||
1462             fetchStatus[tid] == IcacheAccessComplete ||
1463             fetchStatus[tid] == Idle) {
1464             return tid;
1465         } else {
1466             return InvalidThreadID;
1467         }
1468     }
1469 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a4aff2ae442aa43bcb382774f7c429030}{
\index{DefaultFetch@{DefaultFetch}!iqCount@{iqCount}}
\index{iqCount@{iqCount}!DefaultFetch@{DefaultFetch}}
\subsubsection[{iqCount}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} iqCount ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_a4aff2ae442aa43bcb382774f7c429030}
Returns the appropriate thread to fetch using the IQ count policy. 


\begin{DoxyCode}
1505 {
1506     std::priority_queue<unsigned> PQ;
1507     std::map<unsigned, ThreadID> threadMap;
1508 
1509     list<ThreadID>::iterator threads = activeThreads->begin();
1510     list<ThreadID>::iterator end = activeThreads->end();
1511 
1512     while (threads != end) {
1513         ThreadID tid = *threads++;
1514         unsigned iqCount = fromIEW->iewInfo[tid].iqCount;
1515 
1516         PQ.push(iqCount);
1517         threadMap[iqCount] = tid;
1518     }
1519 
1520     while (!PQ.empty()) {
1521         ThreadID high_pri = threadMap[PQ.top()];
1522 
1523         if (fetchStatus[high_pri] == Running ||
1524             fetchStatus[high_pri] == IcacheAccessComplete ||
1525             fetchStatus[high_pri] == Idle)
1526             return high_pri;
1527         else
1528             PQ.pop();
1529 
1530     }
1531 
1532     return InvalidThreadID;
1533 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_adf5473c18a3d7c1e88c4a2072bce5526}{
\index{DefaultFetch@{DefaultFetch}!isDrained@{isDrained}}
\index{isDrained@{isDrained}!DefaultFetch@{DefaultFetch}}
\subsubsection[{isDrained}]{\setlength{\rightskip}{0pt plus 5cm}bool isDrained () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_adf5473c18a3d7c1e88c4a2072bce5526}
Has the stage drained? 


\begin{DoxyCode}
451 {
452     /* Make sure that threads are either idle of that the commit stage
453      * has signaled that draining has completed by setting the drain
454      * stall flag. This effectively forces the pipeline to be disabled
455      * until the whole system is drained (simulation may continue to
456      * drain other components).
457      */
458     for (ThreadID i = 0; i < numThreads; ++i) {
459         if (!(fetchStatus[i] == Idle ||
460               (fetchStatus[i] == Blocked && stalls[i].drain)))
461             return false;
462     }
463 
464     /* The pipeline might start up again in the middle of the drain
465      * cycle if the finish translation event is scheduled, so make
466      * sure that's not the case.
467      */
468     return !finishTranslationEvent.scheduled();
469 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a033e8df655743382b3cb870600f70f82}{
\index{DefaultFetch@{DefaultFetch}!lookupAndUpdateNextPC@{lookupAndUpdateNextPC}}
\index{lookupAndUpdateNextPC@{lookupAndUpdateNextPC}!DefaultFetch@{DefaultFetch}}
\subsubsection[{lookupAndUpdateNextPC}]{\setlength{\rightskip}{0pt plus 5cm}bool lookupAndUpdateNextPC ({\bf DynInstPtr} \& {\em inst}, \/  TheISA::PCState \& {\em pc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_a033e8df655743382b3cb870600f70f82}
Looks up in the branch predictor to see if the next PC should be either next PC+=MachInst or a branch target. 
\begin{DoxyParams}{引数}
\item[{\em next\_\-PC}]Next PC variable passed in by reference. It is expected to be set to the current PC; it will be updated with what the next PC will be. \item[{\em next\_\-NPC}]Used for ISAs which use delay slots. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Whether or not a branch was predicted as taken. 
\end{DoxyReturn}



\begin{DoxyCode}
530 {
531     // Do branch prediction check here.
532     // A bit of a misnomer...next_PC is actually the current PC until
533     // this function updates it.
534     bool predict_taken;
535 
536     if (!inst->isControl()) {
537         TheISA::advancePC(nextPC, inst->staticInst);
538         inst->setPredTarg(nextPC);
539         inst->setPredTaken(false);
540         return false;
541     }
542 
543     ThreadID tid = inst->threadNumber;
544     predict_taken = branchPred->predict(inst->staticInst, inst->seqNum,
545                                         nextPC, tid);
546 
547     if (predict_taken) {
548         DPRINTF(Fetch, "[tid:%i]: [sn:%i]:  Branch predicted to be taken to %s.\n
      ",
549                 tid, inst->seqNum, nextPC);
550     } else {
551         DPRINTF(Fetch, "[tid:%i]: [sn:%i]:Branch predicted to be not taken.\n",
552                 tid, inst->seqNum);
553     }
554 
555     DPRINTF(Fetch, "[tid:%i]: [sn:%i] Branch predicted to go to %s.\n",
556             tid, inst->seqNum, nextPC);
557     inst->setPredTarg(nextPC);
558     inst->setPredTaken(predict_taken);
559 
560     ++fetchedBranches;
561 
562     if (predict_taken) {
563         ++predictedBranches;
564     }
565 
566     return predict_taken;
567 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a2cce05272516009508e173f69d7d37df}{
\index{DefaultFetch@{DefaultFetch}!lsqCount@{lsqCount}}
\index{lsqCount@{lsqCount}!DefaultFetch@{DefaultFetch}}
\subsubsection[{lsqCount}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} lsqCount ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_a2cce05272516009508e173f69d7d37df}
Returns the appropriate thread to fetch using the \hyperlink{classLSQ}{LSQ} count policy. 


\begin{DoxyCode}
1538 {
1539     std::priority_queue<unsigned> PQ;
1540     std::map<unsigned, ThreadID> threadMap;
1541 
1542     list<ThreadID>::iterator threads = activeThreads->begin();
1543     list<ThreadID>::iterator end = activeThreads->end();
1544 
1545     while (threads != end) {
1546         ThreadID tid = *threads++;
1547         unsigned ldstqCount = fromIEW->iewInfo[tid].ldstqCount;
1548 
1549         PQ.push(ldstqCount);
1550         threadMap[ldstqCount] = tid;
1551     }
1552 
1553     while (!PQ.empty()) {
1554         ThreadID high_pri = threadMap[PQ.top()];
1555 
1556         if (fetchStatus[high_pri] == Running ||
1557             fetchStatus[high_pri] == IcacheAccessComplete ||
1558             fetchStatus[high_pri] == Idle)
1559             return high_pri;
1560         else
1561             PQ.pop();
1562     }
1563 
1564     return InvalidThreadID;
1565 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{DefaultFetch@{DefaultFetch}!name@{name}}
\index{name@{name}!DefaultFetch@{DefaultFetch}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_a37627d5d5bba7f4a8690c71c2ab3cb07}
Returns the name of fetch. 


\begin{DoxyCode}
160 {
161     return cpu->name() + ".fetch";
162 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a80cf75d186616b207a78a162498d1012}{
\index{DefaultFetch@{DefaultFetch}!pipelineIcacheAccesses@{pipelineIcacheAccesses}}
\index{pipelineIcacheAccesses@{pipelineIcacheAccesses}!DefaultFetch@{DefaultFetch}}
\subsubsection[{pipelineIcacheAccesses}]{\setlength{\rightskip}{0pt plus 5cm}void pipelineIcacheAccesses ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_a80cf75d186616b207a78a162498d1012}
Pipeline the next I-\/cache access to the current one. 


\begin{DoxyCode}
1584 {
1585     if (!issuePipelinedIfetch[tid]) {
1586         return;
1587     }
1588 
1589     // The next PC to access.
1590     TheISA::PCState thisPC = pc[tid];
1591 
1592     if (isRomMicroPC(thisPC.microPC())) {
1593         return;
1594     }
1595 
1596     Addr pcOffset = fetchOffset[tid];
1597     Addr fetchAddr = (thisPC.instAddr() + pcOffset) & BaseCPU::PCMask;
1598 
1599     // Align the fetch PC so its at the start of a fetch buffer segment.
1600     Addr fetchBufferBlockPC = fetchBufferAlignPC(fetchAddr);
1601 
1602     // Unless buffer already got the block, fetch it from icache.
1603     if (!(fetchBufferValid[tid] && fetchBufferBlockPC == fetchBufferPC[tid])) {
1604         DPRINTF(Fetch, "[tid:%i]: Issuing a pipelined I-cache access, "
1605                 "starting at PC %s.\n", tid, thisPC);
1606 
1607         fetchCacheLine(fetchAddr, tid, thisPC.instAddr());
1608     }
1609 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a3dc029c2e87eb911352b82ff15c86236}{
\index{DefaultFetch@{DefaultFetch}!processCacheCompletion@{processCacheCompletion}}
\index{processCacheCompletion@{processCacheCompletion}!DefaultFetch@{DefaultFetch}}
\subsubsection[{processCacheCompletion}]{\setlength{\rightskip}{0pt plus 5cm}void processCacheCompletion ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_a3dc029c2e87eb911352b82ff15c86236}
Processes cache completion event. 


\begin{DoxyCode}
375 {
376     ThreadID tid = pkt->req->threadId();
377 
378     DPRINTF(Fetch, "[tid:%u] Waking up from cache miss.\n", tid);
379     assert(!cpu->switchedOut());
380 
381     // Only change the status if it's still waiting on the icache access
382     // to return.
383     if (fetchStatus[tid] != IcacheWaitResponse ||
384         pkt->req != memReq[tid]) {
385         ++fetchIcacheSquashes;
386         delete pkt->req;
387         delete pkt;
388         return;
389     }
390 
391     memcpy(fetchBuffer[tid], pkt->getPtr<uint8_t>(), fetchBufferSize);
392     fetchBufferValid[tid] = true;
393 
394     // Wake up the CPU (if it went to sleep and was waiting on
395     // this completion event).
396     cpu->wakeCPU();
397 
398     DPRINTF(Activity, "[tid:%u] Activating fetch due to cache completion\n",
399             tid);
400 
401     switchToActive();
402 
403     // Only switch to IcacheAccessComplete if we're not stalled as well.
404     if (checkStall(tid)) {
405         fetchStatus[tid] = Blocked;
406     } else {
407         fetchStatus[tid] = IcacheAccessComplete;
408     }
409 
410     pkt->req->setAccessLatency();
411     cpu->ppInstAccessComplete->notify(pkt);
412     // Reset the mem req to NULL.
413     delete pkt->req;
414     delete pkt;
415     memReq[tid] = NULL;
416 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_ab3fa3c541f25b65e1b61d7290712e507}{
\index{DefaultFetch@{DefaultFetch}!profileStall@{profileStall}}
\index{profileStall@{profileStall}!DefaultFetch@{DefaultFetch}}
\subsubsection[{profileStall}]{\setlength{\rightskip}{0pt plus 5cm}void profileStall ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_ab3fa3c541f25b65e1b61d7290712e507}
Profile the reasons of fetch stall. 


\begin{DoxyCode}
1613                                              {
1614     DPRINTF(Fetch,"There are no more threads available to fetch from.\n");
1615 
1616     // @todo Per-thread stats
1617 
1618     if (stalls[tid].drain) {
1619         ++fetchPendingDrainCycles;
1620         DPRINTF(Fetch, "Fetch is waiting for a drain!\n");
1621     } else if (activeThreads->empty()) {
1622         ++fetchNoActiveThreadStallCycles;
1623         DPRINTF(Fetch, "Fetch has no active thread!\n");
1624     } else if (fetchStatus[tid] == Blocked) {
1625         ++fetchBlockedCycles;
1626         DPRINTF(Fetch, "[tid:%i]: Fetch is blocked!\n", tid);
1627     } else if (fetchStatus[tid] == Squashing) {
1628         ++fetchSquashCycles;
1629         DPRINTF(Fetch, "[tid:%i]: Fetch is squashing!\n", tid);
1630     } else if (fetchStatus[tid] == IcacheWaitResponse) {
1631         ++icacheStallCycles;
1632         DPRINTF(Fetch, "[tid:%i]: Fetch is waiting cache response!\n",
1633                 tid);
1634     } else if (fetchStatus[tid] == ItlbWait) {
1635         ++fetchTlbCycles;
1636         DPRINTF(Fetch, "[tid:%i]: Fetch is waiting ITLB walk to "
1637                 "finish!\n", tid);
1638     } else if (fetchStatus[tid] == TrapPending) {
1639         ++fetchPendingTrapStallCycles;
1640         DPRINTF(Fetch, "[tid:%i]: Fetch is waiting for a pending trap!\n",
1641                 tid);
1642     } else if (fetchStatus[tid] == QuiescePending) {
1643         ++fetchPendingQuiesceStallCycles;
1644         DPRINTF(Fetch, "[tid:%i]: Fetch is waiting for a pending quiesce "
1645                 "instruction!\n", tid);
1646     } else if (fetchStatus[tid] == IcacheWaitRetry) {
1647         ++fetchIcacheWaitRetryStallCycles;
1648         DPRINTF(Fetch, "[tid:%i]: Fetch is waiting for an I-cache retry!\n",
1649                 tid);
1650     } else if (fetchStatus[tid] == NoGoodAddr) {
1651             DPRINTF(Fetch, "[tid:%i]: Fetch predicted non-executable address\n",
1652                     tid);
1653     } else {
1654         DPRINTF(Fetch, "[tid:%i]: Unexpected fetch stall reason (Status: %i).\n",
      
1655              tid, fetchStatus[tid]);
1656     }
1657 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a29cb5a4f98063ce6e9210eacbdb35298}{
\index{DefaultFetch@{DefaultFetch}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!DefaultFetch@{DefaultFetch}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetry ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_a29cb5a4f98063ce6e9210eacbdb35298}
Handles retrying the fetch access. 


\begin{DoxyCode}
1403 {
1404     if (retryPkt != NULL) {
1405         assert(cacheBlocked);
1406         assert(retryTid != InvalidThreadID);
1407         assert(fetchStatus[retryTid] == IcacheWaitRetry);
1408 
1409         if (cpu->getInstPort().sendTimingReq(retryPkt)) {
1410             fetchStatus[retryTid] = IcacheWaitResponse;
1411             retryPkt = NULL;
1412             retryTid = InvalidThreadID;
1413             cacheBlocked = false;
1414         }
1415     } else {
1416         assert(retryTid == InvalidThreadID);
1417         // Access has been squashed since it was sent out.  Just clear
1418         // the cache being blocked.
1419         cacheBlocked = false;
1420     }
1421 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_aa2dab17a363fd4307274d579796adcf7}{
\index{DefaultFetch@{DefaultFetch}!regProbePoints@{regProbePoints}}
\index{regProbePoints@{regProbePoints}!DefaultFetch@{DefaultFetch}}
\subsubsection[{regProbePoints}]{\setlength{\rightskip}{0pt plus 5cm}void regProbePoints ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_aa2dab17a363fd4307274d579796adcf7}
Registers probes. 


\begin{DoxyCode}
167 {
168     ppFetch = new ProbePointArg<DynInstPtr>(cpu->getProbeManager(), "Fetch");
169 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{DefaultFetch@{DefaultFetch}!regStats@{regStats}}
\index{regStats@{regStats}!DefaultFetch@{DefaultFetch}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_a4dc637449366fcdfc4e764cdf12d9b11}
Registers statistics. 


\begin{DoxyCode}
174 {
175     icacheStallCycles
176         .name(name() + ".icacheStallCycles")
177         .desc("Number of cycles fetch is stalled on an Icache miss")
178         .prereq(icacheStallCycles);
179 
180     fetchedInsts
181         .name(name() + ".Insts")
182         .desc("Number of instructions fetch has processed")
183         .prereq(fetchedInsts);
184 
185     fetchedBranches
186         .name(name() + ".Branches")
187         .desc("Number of branches that fetch encountered")
188         .prereq(fetchedBranches);
189 
190     predictedBranches
191         .name(name() + ".predictedBranches")
192         .desc("Number of branches that fetch has predicted taken")
193         .prereq(predictedBranches);
194 
195     fetchCycles
196         .name(name() + ".Cycles")
197         .desc("Number of cycles fetch has run and was not squashing or"
198               " blocked")
199         .prereq(fetchCycles);
200 
201     fetchSquashCycles
202         .name(name() + ".SquashCycles")
203         .desc("Number of cycles fetch has spent squashing")
204         .prereq(fetchSquashCycles);
205 
206     fetchTlbCycles
207         .name(name() + ".TlbCycles")
208         .desc("Number of cycles fetch has spent waiting for tlb")
209         .prereq(fetchTlbCycles);
210 
211     fetchIdleCycles
212         .name(name() + ".IdleCycles")
213         .desc("Number of cycles fetch was idle")
214         .prereq(fetchIdleCycles);
215 
216     fetchBlockedCycles
217         .name(name() + ".BlockedCycles")
218         .desc("Number of cycles fetch has spent blocked")
219         .prereq(fetchBlockedCycles);
220 
221     fetchedCacheLines
222         .name(name() + ".CacheLines")
223         .desc("Number of cache lines fetched")
224         .prereq(fetchedCacheLines);
225 
226     fetchMiscStallCycles
227         .name(name() + ".MiscStallCycles")
228         .desc("Number of cycles fetch has spent waiting on interrupts, or "
229               "bad addresses, or out of MSHRs")
230         .prereq(fetchMiscStallCycles);
231 
232     fetchPendingDrainCycles
233         .name(name() + ".PendingDrainCycles")
234         .desc("Number of cycles fetch has spent waiting on pipes to drain")
235         .prereq(fetchPendingDrainCycles);
236 
237     fetchNoActiveThreadStallCycles
238         .name(name() + ".NoActiveThreadStallCycles")
239         .desc("Number of stall cycles due to no active thread to fetch from")
240         .prereq(fetchNoActiveThreadStallCycles);
241 
242     fetchPendingTrapStallCycles
243         .name(name() + ".PendingTrapStallCycles")
244         .desc("Number of stall cycles due to pending traps")
245         .prereq(fetchPendingTrapStallCycles);
246 
247     fetchPendingQuiesceStallCycles
248         .name(name() + ".PendingQuiesceStallCycles")
249         .desc("Number of stall cycles due to pending quiesce instructions")
250         .prereq(fetchPendingQuiesceStallCycles);
251 
252     fetchIcacheWaitRetryStallCycles
253         .name(name() + ".IcacheWaitRetryStallCycles")
254         .desc("Number of stall cycles due to full MSHR")
255         .prereq(fetchIcacheWaitRetryStallCycles);
256 
257     fetchIcacheSquashes
258         .name(name() + ".IcacheSquashes")
259         .desc("Number of outstanding Icache misses that were squashed")
260         .prereq(fetchIcacheSquashes);
261 
262     fetchTlbSquashes
263         .name(name() + ".ItlbSquashes")
264         .desc("Number of outstanding ITLB misses that were squashed")
265         .prereq(fetchTlbSquashes);
266 
267     fetchNisnDist
268         .init(/* base value */ 0,
269               /* last value */ fetchWidth,
270               /* bucket size */ 1)
271         .name(name() + ".rateDist")
272         .desc("Number of instructions fetched each cycle (Total)")
273         .flags(Stats::pdf);
274 
275     idleRate
276         .name(name() + ".idleRate")
277         .desc("Percent of cycles fetch was idle")
278         .prereq(idleRate);
279     idleRate = fetchIdleCycles * 100 / cpu->numCycles;
280 
281     branchRate
282         .name(name() + ".branchRate")
283         .desc("Number of branch fetches per cycle")
284         .flags(Stats::total);
285     branchRate = fetchedBranches / cpu->numCycles;
286 
287     fetchRate
288         .name(name() + ".rate")
289         .desc("Number of inst fetches per cycle")
290         .flags(Stats::total);
291     fetchRate = fetchedInsts / cpu->numCycles;
292 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_ada2a699094bc420f977abf2a17ed14c8}{
\index{DefaultFetch@{DefaultFetch}!resetStage@{resetStage}}
\index{resetStage@{resetStage}!DefaultFetch@{DefaultFetch}}
\subsubsection[{resetStage}]{\setlength{\rightskip}{0pt plus 5cm}void resetStage ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_ada2a699094bc420f977abf2a17ed14c8}
Reset this pipeline stage 


\begin{DoxyCode}
339 {
340     numInst = 0;
341     interruptPending = false;
342     cacheBlocked = false;
343 
344     priorityList.clear();
345 
346     // Setup PC and nextPC with initial state.
347     for (ThreadID tid = 0; tid < numThreads; ++tid) {
348         fetchStatus[tid] = Running;
349         pc[tid] = cpu->pcState(tid);
350         fetchOffset[tid] = 0;
351         macroop[tid] = NULL;
352 
353         delayedCommit[tid] = false;
354         memReq[tid] = NULL;
355 
356         stalls[tid].decode = false;
357         stalls[tid].rename = false;
358         stalls[tid].iew = false;
359         stalls[tid].commit = false;
360         stalls[tid].drain = false;
361 
362         fetchBufferPC[tid] = 0;
363         fetchBufferValid[tid] = false;
364 
365         priorityList.push_back(tid);
366     }
367 
368     wroteToTimeBuffer = false;
369     _status = Inactive;
370 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a8aab9cacbc483081596b13ecd5192eb5}{
\index{DefaultFetch@{DefaultFetch}!roundRobin@{roundRobin}}
\index{roundRobin@{roundRobin}!DefaultFetch@{DefaultFetch}}
\subsubsection[{roundRobin}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} roundRobin ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_a8aab9cacbc483081596b13ecd5192eb5}
Returns the appropriate thread to fetch using a round robin policy. 


\begin{DoxyCode}
1475 {
1476     list<ThreadID>::iterator pri_iter = priorityList.begin();
1477     list<ThreadID>::iterator end      = priorityList.end();
1478 
1479     ThreadID high_pri;
1480 
1481     while (pri_iter != end) {
1482         high_pri = *pri_iter;
1483 
1484         assert(high_pri <= numThreads);
1485 
1486         if (fetchStatus[high_pri] == Running ||
1487             fetchStatus[high_pri] == IcacheAccessComplete ||
1488             fetchStatus[high_pri] == Idle) {
1489 
1490             priorityList.erase(pri_iter);
1491             priorityList.push_back(high_pri);
1492 
1493             return high_pri;
1494         }
1495 
1496         pri_iter++;
1497     }
1498 
1499     return InvalidThreadID;
1500 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_aab96bdacf8bd420402cbb543f994e054}{
\index{DefaultFetch@{DefaultFetch}!setActiveThreads@{setActiveThreads}}
\index{setActiveThreads@{setActiveThreads}!DefaultFetch@{DefaultFetch}}
\subsubsection[{setActiveThreads}]{\setlength{\rightskip}{0pt plus 5cm}void setActiveThreads ({\bf std::list}$<$ {\bf ThreadID} $>$ $\ast$ {\em at\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_aab96bdacf8bd420402cbb543f994e054}
Sets pointer to list of active threads. 


\begin{DoxyCode}
310 {
311     activeThreads = at_ptr;
312 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_ad1be90519aa7737ddf8e41de079a5ea9}{
\index{DefaultFetch@{DefaultFetch}!setFetchQueue@{setFetchQueue}}
\index{setFetchQueue@{setFetchQueue}!DefaultFetch@{DefaultFetch}}
\subsubsection[{setFetchQueue}]{\setlength{\rightskip}{0pt plus 5cm}void setFetchQueue ({\bf TimeBuffer}$<$ {\bf FetchStruct} $>$ $\ast$ {\em fq\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_ad1be90519aa7737ddf8e41de079a5ea9}
Sets pointer to time buffer used to communicate to the next stage. 


\begin{DoxyCode}
317 {
318     fetchQueue = fq_ptr;
319 
320     // Create wire to write information to proper place in fetch queue.
321     toDecode = fetchQueue->getWire(0);
322 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_aa9fe72c29dff746fa7023a15c1134ada}{
\index{DefaultFetch@{DefaultFetch}!setTimeBuffer@{setTimeBuffer}}
\index{setTimeBuffer@{setTimeBuffer}!DefaultFetch@{DefaultFetch}}
\subsubsection[{setTimeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}void setTimeBuffer ({\bf TimeBuffer}$<$ {\bf TimeStruct} $>$ $\ast$ {\em time\_\-buffer})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_aa9fe72c29dff746fa7023a15c1134ada}
Sets the main backwards communication time buffer pointer. 


\begin{DoxyCode}
297 {
298     timeBuffer = time_buffer;
299 
300     // Create wires to get information from proper places in time buffer.
301     fromDecode = timeBuffer->getWire(-decodeToFetchDelay);
302     fromRename = timeBuffer->getWire(-renameToFetchDelay);
303     fromIEW = timeBuffer->getWire(-iewToFetchDelay);
304     fromCommit = timeBuffer->getWire(-commitToFetchDelay);
305 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_ae16ceb7406a5afe4ea9a39fd12931d32}{
\index{DefaultFetch@{DefaultFetch}!squash@{squash}}
\index{squash@{squash}!DefaultFetch@{DefaultFetch}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash (const TheISA::PCState \& {\em newPC}, \/  const {\bf InstSeqNum} {\em seq\_\-num}, \/  {\bf DynInstPtr} {\em squashInst}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_ae16ceb7406a5afe4ea9a39fd12931d32}
Squashes a specific thread and resets the PC. Also tells the CPU to remove any instructions that are not in the \hyperlink{classROB}{ROB}. The source of this squash should be the commit stage. 


\begin{DoxyCode}
864 {
865     DPRINTF(Fetch, "[tid:%u]: Squash from commit.\n", tid);
866 
867     doSquash(newPC, squashInst, tid);
868 
869     // Tell the CPU to remove any instructions that are not in the ROB.
870     cpu->removeInstsNotInROB(tid);
871 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_acddf0ab1e13108e3626da3743de398b8}{
\index{DefaultFetch@{DefaultFetch}!squashFromDecode@{squashFromDecode}}
\index{squashFromDecode@{squashFromDecode}!DefaultFetch@{DefaultFetch}}
\subsubsection[{squashFromDecode}]{\setlength{\rightskip}{0pt plus 5cm}void squashFromDecode (const TheISA::PCState \& {\em newPC}, \/  const {\bf DynInstPtr} {\em squashInst}, \/  const {\bf InstSeqNum} {\em seq\_\-num}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_acddf0ab1e13108e3626da3743de398b8}
Squashes a specific thread and resets the PC. Also tells the CPU to remove any instructions between fetch and decode that should be sqaushed. 


\begin{DoxyCode}
779 {
780     DPRINTF(Fetch, "[tid:%i]: Squashing from decode.\n", tid);
781 
782     doSquash(newPC, squashInst, tid);
783 
784     // Tell the CPU to remove any instructions that are in flight between
785     // fetch and decode.
786     cpu->removeInstsUntil(seq_num, tid);
787 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a31d4cbdab16d4ff8d6bc7f84ece727da}{
\index{DefaultFetch@{DefaultFetch}!startupStage@{startupStage}}
\index{startupStage@{startupStage}!DefaultFetch@{DefaultFetch}}
\subsubsection[{startupStage}]{\setlength{\rightskip}{0pt plus 5cm}void startupStage ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_a31d4cbdab16d4ff8d6bc7f84ece727da}
Initialize stage. 


\begin{DoxyCode}
327 {
328     assert(priorityList.empty());
329     resetStage();
330 
331     // Fetch needs to start fetching instructions at the very beginning,
332     // so it must start up in active state.
333     switchToActive();
334 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a03ce24cba34d3da5948f54e10f8710a9}{
\index{DefaultFetch@{DefaultFetch}!switchToActive@{switchToActive}}
\index{switchToActive@{switchToActive}!DefaultFetch@{DefaultFetch}}
\subsubsection[{switchToActive}]{\setlength{\rightskip}{0pt plus 5cm}void switchToActive ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_a03ce24cba34d3da5948f54e10f8710a9}
Changes the status of this stage to active, and indicates this to the CPU. 


\begin{DoxyCode}
503 {
504     if (_status == Inactive) {
505         DPRINTF(Activity, "Activating stage.\n");
506 
507         cpu->activateStage(O3CPU::FetchIdx);
508 
509         _status = Active;
510     }
511 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a8ef9d48876d3014250c97bfba41a42cd}{
\index{DefaultFetch@{DefaultFetch}!switchToInactive@{switchToInactive}}
\index{switchToInactive@{switchToInactive}!DefaultFetch@{DefaultFetch}}
\subsubsection[{switchToInactive}]{\setlength{\rightskip}{0pt plus 5cm}void switchToInactive ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_a8ef9d48876d3014250c97bfba41a42cd}
Changes the status of this stage to inactive, and indicates this to the CPU. 


\begin{DoxyCode}
516 {
517     if (_status == Active) {
518         DPRINTF(Activity, "Deactivating stage.\n");
519 
520         cpu->deactivateStage(O3CPU::FetchIdx);
521 
522         _status = Inactive;
523     }
524 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a8674059ce345e23aac5086b2c3e24a43}{
\index{DefaultFetch@{DefaultFetch}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!DefaultFetch@{DefaultFetch}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_a8674059ce345e23aac5086b2c3e24a43}
Takes over from another CPU's thread. 


\begin{DoxyCode}
474 {
475     assert(cpu->getInstPort().isConnected());
476     resetStage();
477 
478 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a873dd91783f9efb4a590aded1f70d6b0}{
\index{DefaultFetch@{DefaultFetch}!tick@{tick}}
\index{tick@{tick}!DefaultFetch@{DefaultFetch}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_a873dd91783f9efb4a590aded1f70d6b0}
Ticks the fetch stage, processing all inputs signals and fetching as many instructions as possible. 


\begin{DoxyCode}
876 {
877     list<ThreadID>::iterator threads = activeThreads->begin();
878     list<ThreadID>::iterator end = activeThreads->end();
879     bool status_change = false;
880 
881     wroteToTimeBuffer = false;
882 
883     for (ThreadID i = 0; i < Impl::MaxThreads; ++i) {
884         issuePipelinedIfetch[i] = false;
885     }
886 
887     while (threads != end) {
888         ThreadID tid = *threads++;
889 
890         // Check the signals for each thread to determine the proper status
891         // for each thread.
892         bool updated_status = checkSignalsAndUpdate(tid);
893         status_change =  status_change || updated_status;
894     }
895 
896     DPRINTF(Fetch, "Running stage.\n");
897 
898     if (FullSystem) {
899         if (fromCommit->commitInfo[0].interruptPending) {
900             interruptPending = true;
901         }
902 
903         if (fromCommit->commitInfo[0].clearInterrupt) {
904             interruptPending = false;
905         }
906     }
907 
908     for (threadFetched = 0; threadFetched < numFetchingThreads;
909          threadFetched++) {
910         // Fetch each of the actively fetching threads.
911         fetch(status_change);
912     }
913 
914     // Record number of instructions fetched this cycle for distribution.
915     fetchNisnDist.sample(numInst);
916 
917     if (status_change) {
918         // Change the fetch stage status if there was a status change.
919         _status = updateFetchStatus();
920     }
921 
922     // If there was activity this cycle, inform the CPU of it.
923     if (wroteToTimeBuffer || cpu->contextSwitch) {
924         DPRINTF(Activity, "Activity this cycle.\n");
925 
926         cpu->activityThisCycle();
927     }
928 
929     // Issue the next I-cache request if possible.
930     for (ThreadID i = 0; i < Impl::MaxThreads; ++i) {
931         if (issuePipelinedIfetch[i]) {
932             pipelineIcacheAccesses(i);
933         }
934     }
935 
936     // Reset the number of the instruction we've fetched.
937     numInst = 0;
938 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_ac244c54ec94dd5e1d886dfd022752ec8}{
\index{DefaultFetch@{DefaultFetch}!updateFetchStatus@{updateFetchStatus}}
\index{updateFetchStatus@{updateFetchStatus}!DefaultFetch@{DefaultFetch}}
\subsubsection[{updateFetchStatus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DefaultFetch}$<$ Impl $>$::{\bf FetchStatus} updateFetchStatus ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultFetch_ac244c54ec94dd5e1d886dfd022752ec8}
Updates overall fetch stage status; to be called at the end of each cycle. 


\begin{DoxyCode}
822 {
823     //Check Running
824     list<ThreadID>::iterator threads = activeThreads->begin();
825     list<ThreadID>::iterator end = activeThreads->end();
826 
827     while (threads != end) {
828         ThreadID tid = *threads++;
829 
830         if (fetchStatus[tid] == Running ||
831             fetchStatus[tid] == Squashing ||
832             fetchStatus[tid] == IcacheAccessComplete) {
833 
834             if (_status == Inactive) {
835                 DPRINTF(Activity, "[tid:%i]: Activating stage.\n",tid);
836 
837                 if (fetchStatus[tid] == IcacheAccessComplete) {
838                     DPRINTF(Activity, "[tid:%i]: Activating fetch due to cache"
839                             "completion\n",tid);
840                 }
841 
842                 cpu->activateStage(O3CPU::FetchIdx);
843             }
844 
845             return Active;
846         }
847     }
848 
849     // Stage is switching from active to inactive, notify CPU of it.
850     if (_status == Active) {
851         DPRINTF(Activity, "Deactivating stage.\n");
852 
853         cpu->deactivateStage(O3CPU::FetchIdx);
854     }
855 
856     return Inactive;
857 }
\end{DoxyCode}
\hypertarget{classDefaultFetch_a040cbeac7187b0b8cdb1242d3f5aa179}{
\index{DefaultFetch@{DefaultFetch}!wakeFromQuiesce@{wakeFromQuiesce}}
\index{wakeFromQuiesce@{wakeFromQuiesce}!DefaultFetch@{DefaultFetch}}
\subsubsection[{wakeFromQuiesce}]{\setlength{\rightskip}{0pt plus 5cm}void wakeFromQuiesce ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultFetch_a040cbeac7187b0b8cdb1242d3f5aa179}
Tells fetch to wake up from a quiesce instruction. 


\begin{DoxyCode}
493 {
494     DPRINTF(Fetch, "Waking up from quiesce\n");
495     // Hopefully this is safe
496     // @todo: Allow other threads to wake from quiesce.
497     fetchStatus[0] = Running;
498 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classDefaultFetch_aa3fc43283eb7a93d6a41830bbd412681}{
\index{DefaultFetch@{DefaultFetch}!\_\-status@{\_\-status}}
\index{\_\-status@{\_\-status}!DefaultFetch@{DefaultFetch}}
\subsubsection[{\_\-status}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FetchStatus} {\bf \_\-status}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_aa3fc43283eb7a93d6a41830bbd412681}
Fetch status. \hypertarget{classDefaultFetch_af6eaea53db532812052f71bf0380dab5}{
\index{DefaultFetch@{DefaultFetch}!activeThreads@{activeThreads}}
\index{activeThreads@{activeThreads}!DefaultFetch@{DefaultFetch}}
\subsubsection[{activeThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf ThreadID}$>$$\ast$ {\bf activeThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_af6eaea53db532812052f71bf0380dab5}
List of Active Threads \hypertarget{classDefaultFetch_adee29d0de843b42df1f1caf92d388413}{
\index{DefaultFetch@{DefaultFetch}!branchPred@{branchPred}}
\index{branchPred@{branchPred}!DefaultFetch@{DefaultFetch}}
\subsubsection[{branchPred}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BPredUnit}$\ast$ {\bf branchPred}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_adee29d0de843b42df1f1caf92d388413}
\hyperlink{classBPredUnit}{BPredUnit}. \hypertarget{classDefaultFetch_abceba4006d416e352df47f692b589bc3}{
\index{DefaultFetch@{DefaultFetch}!branchRate@{branchRate}}
\index{branchRate@{branchRate}!DefaultFetch@{DefaultFetch}}
\subsubsection[{branchRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf branchRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_abceba4006d416e352df47f692b589bc3}
Number of branch fetches per cycle. \hypertarget{classDefaultFetch_a37c69cb65c303fc6e66984fef13f18c6}{
\index{DefaultFetch@{DefaultFetch}!cacheBlkSize@{cacheBlkSize}}
\index{cacheBlkSize@{cacheBlkSize}!DefaultFetch@{DefaultFetch}}
\subsubsection[{cacheBlkSize}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf cacheBlkSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a37c69cb65c303fc6e66984fef13f18c6}
\hyperlink{classCache}{Cache} block size. \hypertarget{classDefaultFetch_a12a8dc8b9e94659a01ff979d9d98be89}{
\index{DefaultFetch@{DefaultFetch}!cacheBlocked@{cacheBlocked}}
\index{cacheBlocked@{cacheBlocked}!DefaultFetch@{DefaultFetch}}
\subsubsection[{cacheBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf cacheBlocked}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a12a8dc8b9e94659a01ff979d9d98be89}
Is the cache blocked? If so no threads can access it. \hypertarget{classDefaultFetch_a4b0344f5703ba5770b42602c6df63340}{
\index{DefaultFetch@{DefaultFetch}!commitToFetchDelay@{commitToFetchDelay}}
\index{commitToFetchDelay@{commitToFetchDelay}!DefaultFetch@{DefaultFetch}}
\subsubsection[{commitToFetchDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf commitToFetchDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a4b0344f5703ba5770b42602c6df63340}
Commit to fetch delay. \hypertarget{classDefaultFetch_a1379cf882a12ac6fc9eba5da7c84b18b}{
\index{DefaultFetch@{DefaultFetch}!cpu@{cpu}}
\index{cpu@{cpu}!DefaultFetch@{DefaultFetch}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf O3CPU}$\ast$ {\bf cpu}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a1379cf882a12ac6fc9eba5da7c84b18b}
Pointer to the \hyperlink{namespaceO3CPU}{O3CPU}. \hypertarget{classDefaultFetch_ad59085cbedffbd5bf8cd9eb714041505}{
\index{DefaultFetch@{DefaultFetch}!decoder@{decoder}}
\index{decoder@{decoder}!DefaultFetch@{DefaultFetch}}
\subsubsection[{decoder}]{\setlength{\rightskip}{0pt plus 5cm}TheISA::Decoder$\ast$ {\bf decoder}\mbox{[}Impl::MaxThreads\mbox{]}}}
\label{classDefaultFetch_ad59085cbedffbd5bf8cd9eb714041505}
The decoder. \hypertarget{classDefaultFetch_a2ef45e1e2bd510cfb43c0a03a6ab3f1c}{
\index{DefaultFetch@{DefaultFetch}!decodeToFetchDelay@{decodeToFetchDelay}}
\index{decodeToFetchDelay@{decodeToFetchDelay}!DefaultFetch@{DefaultFetch}}
\subsubsection[{decodeToFetchDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf decodeToFetchDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a2ef45e1e2bd510cfb43c0a03a6ab3f1c}
Decode to fetch delay. \hypertarget{classDefaultFetch_af247386188fbfaba3ea218eff3a771db}{
\index{DefaultFetch@{DefaultFetch}!delayedCommit@{delayedCommit}}
\index{delayedCommit@{delayedCommit}!DefaultFetch@{DefaultFetch}}
\subsubsection[{delayedCommit}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf delayedCommit}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_af247386188fbfaba3ea218eff3a771db}
Can the fetch stage redirect from an interrupt on this instruction? \hypertarget{classDefaultFetch_a0501ffad4abed98618a6cf0ba9c3599b}{
\index{DefaultFetch@{DefaultFetch}!fetchBlockedCycles@{fetchBlockedCycles}}
\index{fetchBlockedCycles@{fetchBlockedCycles}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchBlockedCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchBlockedCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a0501ffad4abed98618a6cf0ba9c3599b}
Total number of cycles spent blocked. \hypertarget{classDefaultFetch_a924f2775385b2e5ac3008db4b8305c2b}{
\index{DefaultFetch@{DefaultFetch}!fetchBuffer@{fetchBuffer}}
\index{fetchBuffer@{fetchBuffer}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchBuffer}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t$\ast$ {\bf fetchBuffer}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a924f2775385b2e5ac3008db4b8305c2b}
The fetch data that is being fetched and buffered. \hypertarget{classDefaultFetch_a9fb9a70efc5e29795473f1f92c082063}{
\index{DefaultFetch@{DefaultFetch}!fetchBufferMask@{fetchBufferMask}}
\index{fetchBufferMask@{fetchBufferMask}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchBufferMask}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf fetchBufferMask}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a9fb9a70efc5e29795473f1f92c082063}
Mask to align a fetch address to a fetch buffer boundary. \hypertarget{classDefaultFetch_ab4b128217e67bdf9f6a98420b82cacb9}{
\index{DefaultFetch@{DefaultFetch}!fetchBufferPC@{fetchBufferPC}}
\index{fetchBufferPC@{fetchBufferPC}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchBufferPC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf fetchBufferPC}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_ab4b128217e67bdf9f6a98420b82cacb9}
The PC of the first instruction loaded into the fetch buffer. \hypertarget{classDefaultFetch_ac47806923c3481b83636c4aa03d184f8}{
\index{DefaultFetch@{DefaultFetch}!fetchBufferSize@{fetchBufferSize}}
\index{fetchBufferSize@{fetchBufferSize}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchBufferSize}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf fetchBufferSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_ac47806923c3481b83636c4aa03d184f8}
The size of the fetch buffer in bytes. The fetch buffer itself may be smaller than a cache line. \hypertarget{classDefaultFetch_ab6845c7b94805ded9ea7d94b210be51b}{
\index{DefaultFetch@{DefaultFetch}!fetchBufferValid@{fetchBufferValid}}
\index{fetchBufferValid@{fetchBufferValid}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchBufferValid}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf fetchBufferValid}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_ab6845c7b94805ded9ea7d94b210be51b}
Whether or not the fetch buffer data is valid. \hypertarget{classDefaultFetch_a9699b5489dd499e832651b96f95b5d19}{
\index{DefaultFetch@{DefaultFetch}!fetchCycles@{fetchCycles}}
\index{fetchCycles@{fetchCycles}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a9699b5489dd499e832651b96f95b5d19}
Stat for total number of cycles spent fetching. \hypertarget{classDefaultFetch_aaca0646636cde96795aed6beb2942975}{
\index{DefaultFetch@{DefaultFetch}!fetchedBranches@{fetchedBranches}}
\index{fetchedBranches@{fetchedBranches}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchedBranches}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchedBranches}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_aaca0646636cde96795aed6beb2942975}
Total number of fetched branches. \hypertarget{classDefaultFetch_a0ead660daa133edcd64ac552d473ebba}{
\index{DefaultFetch@{DefaultFetch}!fetchedCacheLines@{fetchedCacheLines}}
\index{fetchedCacheLines@{fetchedCacheLines}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchedCacheLines}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchedCacheLines}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a0ead660daa133edcd64ac552d473ebba}
Stat for total number of fetched cache lines. \hypertarget{classDefaultFetch_af0e3fa228032036d2022ed9e2a3612b6}{
\index{DefaultFetch@{DefaultFetch}!fetchedInsts@{fetchedInsts}}
\index{fetchedInsts@{fetchedInsts}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchedInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchedInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_af0e3fa228032036d2022ed9e2a3612b6}
Stat for total number of fetched instructions. \hypertarget{classDefaultFetch_af5ce6113f31fddaab758b8fb025600bc}{
\index{DefaultFetch@{DefaultFetch}!fetchIcacheSquashes@{fetchIcacheSquashes}}
\index{fetchIcacheSquashes@{fetchIcacheSquashes}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchIcacheSquashes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchIcacheSquashes}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_af5ce6113f31fddaab758b8fb025600bc}
Total number of outstanding icache accesses that were dropped due to a squash. \hypertarget{classDefaultFetch_a85ea1666f596116bc53a277b388d39d7}{
\index{DefaultFetch@{DefaultFetch}!fetchIcacheWaitRetryStallCycles@{fetchIcacheWaitRetryStallCycles}}
\index{fetchIcacheWaitRetryStallCycles@{fetchIcacheWaitRetryStallCycles}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchIcacheWaitRetryStallCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchIcacheWaitRetryStallCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a85ea1666f596116bc53a277b388d39d7}
Total number of stall cycles caused by I-\/cache wait retrys. \hypertarget{classDefaultFetch_a8af716ad2a53a409640347226078591c}{
\index{DefaultFetch@{DefaultFetch}!fetchIdleCycles@{fetchIdleCycles}}
\index{fetchIdleCycles@{fetchIdleCycles}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchIdleCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchIdleCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a8af716ad2a53a409640347226078591c}
Stat for total number of cycles spent blocked due to other stages in the pipeline. \hypertarget{classDefaultFetch_a0a77b8544fea92003669cdc78a46eea5}{
\index{DefaultFetch@{DefaultFetch}!fetchMiscStallCycles@{fetchMiscStallCycles}}
\index{fetchMiscStallCycles@{fetchMiscStallCycles}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchMiscStallCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchMiscStallCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a0a77b8544fea92003669cdc78a46eea5}
Total number of cycles spent in any other state. \hypertarget{classDefaultFetch_a4793a4a8857c13e7812b1c37c6df761b}{
\index{DefaultFetch@{DefaultFetch}!fetchNisnDist@{fetchNisnDist}}
\index{fetchNisnDist@{fetchNisnDist}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchNisnDist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Distribution} {\bf fetchNisnDist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a4793a4a8857c13e7812b1c37c6df761b}
Distribution of number of instructions fetched each cycle. \hypertarget{classDefaultFetch_aaa3b110a1f8e4fb7c88676a2ee836a06}{
\index{DefaultFetch@{DefaultFetch}!fetchNoActiveThreadStallCycles@{fetchNoActiveThreadStallCycles}}
\index{fetchNoActiveThreadStallCycles@{fetchNoActiveThreadStallCycles}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchNoActiveThreadStallCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchNoActiveThreadStallCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_aaa3b110a1f8e4fb7c88676a2ee836a06}
Total number of stall cycles caused by no active threads to run. \hypertarget{classDefaultFetch_afc52fdca94918eaaf908094a80ab63ce}{
\index{DefaultFetch@{DefaultFetch}!fetchOffset@{fetchOffset}}
\index{fetchOffset@{fetchOffset}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchOffset}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf fetchOffset}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_afc52fdca94918eaaf908094a80ab63ce}
\hypertarget{classDefaultFetch_ad09f9a8597b6f2c627b5c116d85ea375}{
\index{DefaultFetch@{DefaultFetch}!fetchPendingDrainCycles@{fetchPendingDrainCycles}}
\index{fetchPendingDrainCycles@{fetchPendingDrainCycles}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchPendingDrainCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchPendingDrainCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_ad09f9a8597b6f2c627b5c116d85ea375}
Total number of cycles spent in waiting for drains. \hypertarget{classDefaultFetch_a8be39e4ea9ed9168227dc6efced55f3f}{
\index{DefaultFetch@{DefaultFetch}!fetchPendingQuiesceStallCycles@{fetchPendingQuiesceStallCycles}}
\index{fetchPendingQuiesceStallCycles@{fetchPendingQuiesceStallCycles}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchPendingQuiesceStallCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchPendingQuiesceStallCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a8be39e4ea9ed9168227dc6efced55f3f}
Total number of stall cycles caused by pending quiesce instructions. \hypertarget{classDefaultFetch_a5a80cd5375f1281e64f0dd318cc761d2}{
\index{DefaultFetch@{DefaultFetch}!fetchPendingTrapStallCycles@{fetchPendingTrapStallCycles}}
\index{fetchPendingTrapStallCycles@{fetchPendingTrapStallCycles}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchPendingTrapStallCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchPendingTrapStallCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a5a80cd5375f1281e64f0dd318cc761d2}
Total number of stall cycles caused by pending traps. \hypertarget{classDefaultFetch_aad8c2ca9262308cfdb74cd69cda508f6}{
\index{DefaultFetch@{DefaultFetch}!fetchPolicy@{fetchPolicy}}
\index{fetchPolicy@{fetchPolicy}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchPolicy}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FetchPriority} {\bf fetchPolicy}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_aad8c2ca9262308cfdb74cd69cda508f6}
Fetch policy. \hypertarget{classDefaultFetch_a9a2f350be647ebfb6567172812db491a}{
\index{DefaultFetch@{DefaultFetch}!fetchQueue@{fetchQueue}}
\index{fetchQueue@{fetchQueue}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf FetchStruct}$>$$\ast$ {\bf fetchQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a9a2f350be647ebfb6567172812db491a}
Internal fetch instruction queue. \hypertarget{classDefaultFetch_a7656c6cac3b62fa389148c650a5d127a}{
\index{DefaultFetch@{DefaultFetch}!fetchRate@{fetchRate}}
\index{fetchRate@{fetchRate}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf fetchRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a7656c6cac3b62fa389148c650a5d127a}
Number of instruction fetched per cycle. \hypertarget{classDefaultFetch_ae1b92a3469ac6b00fddd788b71f64c9a}{
\index{DefaultFetch@{DefaultFetch}!fetchSquashCycles@{fetchSquashCycles}}
\index{fetchSquashCycles@{fetchSquashCycles}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchSquashCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchSquashCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_ae1b92a3469ac6b00fddd788b71f64c9a}
Stat for total number of cycles spent squashing. \hypertarget{classDefaultFetch_a852cb41bf6074487410b49ec9ff53c00}{
\index{DefaultFetch@{DefaultFetch}!fetchStatus@{fetchStatus}}
\index{fetchStatus@{fetchStatus}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchStatus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadStatus} {\bf fetchStatus}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a852cb41bf6074487410b49ec9ff53c00}
Per-\/thread status. \hypertarget{classDefaultFetch_a9b08d665534d5e7d5b8134c4af16881d}{
\index{DefaultFetch@{DefaultFetch}!fetchTlbCycles@{fetchTlbCycles}}
\index{fetchTlbCycles@{fetchTlbCycles}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchTlbCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchTlbCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a9b08d665534d5e7d5b8134c4af16881d}
Stat for total number of cycles spent waiting for translation \hypertarget{classDefaultFetch_afe07cb06e5135b2305320fa11fda71af}{
\index{DefaultFetch@{DefaultFetch}!fetchTlbSquashes@{fetchTlbSquashes}}
\index{fetchTlbSquashes@{fetchTlbSquashes}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchTlbSquashes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchTlbSquashes}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_afe07cb06e5135b2305320fa11fda71af}
Total number of outstanding tlb accesses that were dropped due to a squash. \hypertarget{classDefaultFetch_a89b5ed63a2dba82556b909f343319416}{
\index{DefaultFetch@{DefaultFetch}!fetchWidth@{fetchWidth}}
\index{fetchWidth@{fetchWidth}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fetchWidth}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf fetchWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a89b5ed63a2dba82556b909f343319416}
The width of fetch in instructions. \hypertarget{classDefaultFetch_a7bfa632a0dd4f5a541ceb627255286d3}{
\index{DefaultFetch@{DefaultFetch}!finishTranslationEvent@{finishTranslationEvent}}
\index{finishTranslationEvent@{finishTranslationEvent}!DefaultFetch@{DefaultFetch}}
\subsubsection[{finishTranslationEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FinishTranslationEvent} {\bf finishTranslationEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a7bfa632a0dd4f5a541ceb627255286d3}
\hyperlink{classEvent}{Event} used to delay fault generation of translation faults \hypertarget{classDefaultFetch_a0055a92bd94eda21c2641d46ff013dac}{
\index{DefaultFetch@{DefaultFetch}!fromCommit@{fromCommit}}
\index{fromCommit@{fromCommit}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fromCommit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf fromCommit}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a0055a92bd94eda21c2641d46ff013dac}
\hyperlink{classWire}{Wire} to get commit's information from backwards time buffer. \hypertarget{classDefaultFetch_a1116d028078c70aa1579726747303a55}{
\index{DefaultFetch@{DefaultFetch}!fromDecode@{fromDecode}}
\index{fromDecode@{fromDecode}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fromDecode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf fromDecode}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a1116d028078c70aa1579726747303a55}
\hyperlink{classWire}{Wire} to get decode's information from backwards time buffer. \hypertarget{classDefaultFetch_a6c9093e88770a58dc8853f49a09bbac8}{
\index{DefaultFetch@{DefaultFetch}!fromIEW@{fromIEW}}
\index{fromIEW@{fromIEW}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fromIEW}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf fromIEW}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a6c9093e88770a58dc8853f49a09bbac8}
\hyperlink{classWire}{Wire} to get iew's information from backwards time buffer. \hypertarget{classDefaultFetch_ae99c54a9c8f1e218b86afcee348c54fc}{
\index{DefaultFetch@{DefaultFetch}!fromRename@{fromRename}}
\index{fromRename@{fromRename}!DefaultFetch@{DefaultFetch}}
\subsubsection[{fromRename}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf fromRename}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_ae99c54a9c8f1e218b86afcee348c54fc}
\hyperlink{classWire}{Wire} to get rename's information from backwards time buffer. \hypertarget{classDefaultFetch_a2b9328bdb1a6898bfae824981cd64311}{
\index{DefaultFetch@{DefaultFetch}!icacheStallCycles@{icacheStallCycles}}
\index{icacheStallCycles@{icacheStallCycles}!DefaultFetch@{DefaultFetch}}
\subsubsection[{icacheStallCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf icacheStallCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a2b9328bdb1a6898bfae824981cd64311}
Stat for total number of cycles stalled due to an icache miss. \hypertarget{classDefaultFetch_a4b942e4ec6b8c1d29a1c96e901ea71dd}{
\index{DefaultFetch@{DefaultFetch}!idleRate@{idleRate}}
\index{idleRate@{idleRate}!DefaultFetch@{DefaultFetch}}
\subsubsection[{idleRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf idleRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a4b942e4ec6b8c1d29a1c96e901ea71dd}
Rate of how often fetch was idle. \hypertarget{classDefaultFetch_a986e734c1e66dc0be1723ade04d06d4b}{
\index{DefaultFetch@{DefaultFetch}!iewToFetchDelay@{iewToFetchDelay}}
\index{iewToFetchDelay@{iewToFetchDelay}!DefaultFetch@{DefaultFetch}}
\subsubsection[{iewToFetchDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf iewToFetchDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a986e734c1e66dc0be1723ade04d06d4b}
IEW to fetch delay. \hypertarget{classDefaultFetch_a494a9a986bc62c946604f9e9047ad237}{
\index{DefaultFetch@{DefaultFetch}!instSize@{instSize}}
\index{instSize@{instSize}!DefaultFetch@{DefaultFetch}}
\subsubsection[{instSize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf instSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a494a9a986bc62c946604f9e9047ad237}
Size of instructions. \hypertarget{classDefaultFetch_a310de3efc6b60f47de5792d2b00d0840}{
\index{DefaultFetch@{DefaultFetch}!interruptPending@{interruptPending}}
\index{interruptPending@{interruptPending}!DefaultFetch@{DefaultFetch}}
\subsubsection[{interruptPending}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf interruptPending}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a310de3efc6b60f47de5792d2b00d0840}
Checks if there is an interrupt pending. If there is, fetch must stop once it is not fetching \hyperlink{structPAL}{PAL} instructions. \hypertarget{classDefaultFetch_a4004484fff11512f43124243e7eac71a}{
\index{DefaultFetch@{DefaultFetch}!issuePipelinedIfetch@{issuePipelinedIfetch}}
\index{issuePipelinedIfetch@{issuePipelinedIfetch}!DefaultFetch@{DefaultFetch}}
\subsubsection[{issuePipelinedIfetch}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf issuePipelinedIfetch}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a4004484fff11512f43124243e7eac71a}
\hyperlink{classSet}{Set} to true if a pipelined I-\/cache request should be issued. \hypertarget{classDefaultFetch_a1848d938e5258a2a79298169e43efde5}{
\index{DefaultFetch@{DefaultFetch}!lastIcacheStall@{lastIcacheStall}}
\index{lastIcacheStall@{lastIcacheStall}!DefaultFetch@{DefaultFetch}}
\subsubsection[{lastIcacheStall}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Counter} {\bf lastIcacheStall}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a1848d938e5258a2a79298169e43efde5}
Icache stall statistics. \hypertarget{classDefaultFetch_a1f84ef3ef8e6b11f3bb9a3a0a6224345}{
\index{DefaultFetch@{DefaultFetch}!macroop@{macroop}}
\index{macroop@{macroop}!DefaultFetch@{DefaultFetch}}
\subsubsection[{macroop}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StaticInstPtr} {\bf macroop}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a1f84ef3ef8e6b11f3bb9a3a0a6224345}
\hypertarget{classDefaultFetch_a7b85bc06912a7000a9b27cab60626a7a}{
\index{DefaultFetch@{DefaultFetch}!memReq@{memReq}}
\index{memReq@{memReq}!DefaultFetch@{DefaultFetch}}
\subsubsection[{memReq}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RequestPtr} {\bf memReq}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a7b85bc06912a7000a9b27cab60626a7a}
Memory request used to access cache. \hypertarget{classDefaultFetch_a6f81783998429ac4a3e8b75a5d5d12d4}{
\index{DefaultFetch@{DefaultFetch}!numFetchingThreads@{numFetchingThreads}}
\index{numFetchingThreads@{numFetchingThreads}!DefaultFetch@{DefaultFetch}}
\subsubsection[{numFetchingThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} {\bf numFetchingThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a6f81783998429ac4a3e8b75a5d5d12d4}
Number of threads that are actively fetching. \hypertarget{classDefaultFetch_a07c4afd8e6b9ff4bdf20b573a39d1372}{
\index{DefaultFetch@{DefaultFetch}!numInst@{numInst}}
\index{numInst@{numInst}!DefaultFetch@{DefaultFetch}}
\subsubsection[{numInst}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf numInst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a07c4afd8e6b9ff4bdf20b573a39d1372}
Tracks how many instructions has been fetched this cycle. \hypertarget{classDefaultFetch_a88377f855dbf5adeeecb06b5bb821d35}{
\index{DefaultFetch@{DefaultFetch}!numThreads@{numThreads}}
\index{numThreads@{numThreads}!DefaultFetch@{DefaultFetch}}
\subsubsection[{numThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} {\bf numThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a88377f855dbf5adeeecb06b5bb821d35}
Number of threads. \hypertarget{classDefaultFetch_a6e6091c9272a281b8693c0f46279cad0}{
\index{DefaultFetch@{DefaultFetch}!pc@{pc}}
\index{pc@{pc}!DefaultFetch@{DefaultFetch}}
\subsubsection[{pc}]{\setlength{\rightskip}{0pt plus 5cm}TheISA::PCState {\bf pc}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a6e6091c9272a281b8693c0f46279cad0}
\hypertarget{classDefaultFetch_a853ac5048dfdbba414f6f8186dd11afd}{
\index{DefaultFetch@{DefaultFetch}!ppFetch@{ppFetch}}
\index{ppFetch@{ppFetch}!DefaultFetch@{DefaultFetch}}
\subsubsection[{ppFetch}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ProbePointArg}$<${\bf DynInstPtr}$>$$\ast$ {\bf ppFetch}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a853ac5048dfdbba414f6f8186dd11afd}
\hyperlink{namespaceProbe}{Probe} points. \hypertarget{classDefaultFetch_ae5c954036e76b5cc5a82cf7f17d4d5ed}{
\index{DefaultFetch@{DefaultFetch}!predictedBranches@{predictedBranches}}
\index{predictedBranches@{predictedBranches}!DefaultFetch@{DefaultFetch}}
\subsubsection[{predictedBranches}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf predictedBranches}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_ae5c954036e76b5cc5a82cf7f17d4d5ed}
Stat for total number of predicted branches. \hypertarget{classDefaultFetch_a0d967261cbbce522509d85936b8ce786}{
\index{DefaultFetch@{DefaultFetch}!priorityList@{priorityList}}
\index{priorityList@{priorityList}!DefaultFetch@{DefaultFetch}}
\subsubsection[{priorityList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf ThreadID}$>$ {\bf priorityList}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a0d967261cbbce522509d85936b8ce786}
List that has the threads organized by priority. \hypertarget{classDefaultFetch_ae97f1fdea38bf1719a7d45a15f3dcd5c}{
\index{DefaultFetch@{DefaultFetch}!renameToFetchDelay@{renameToFetchDelay}}
\index{renameToFetchDelay@{renameToFetchDelay}!DefaultFetch@{DefaultFetch}}
\subsubsection[{renameToFetchDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf renameToFetchDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_ae97f1fdea38bf1719a7d45a15f3dcd5c}
Rename to fetch delay. \hypertarget{classDefaultFetch_a314ae93c04b3ca96e79e1b1f39a8e478}{
\index{DefaultFetch@{DefaultFetch}!retryPkt@{retryPkt}}
\index{retryPkt@{retryPkt}!DefaultFetch@{DefaultFetch}}
\subsubsection[{retryPkt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketPtr} {\bf retryPkt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a314ae93c04b3ca96e79e1b1f39a8e478}
The packet that is waiting to be retried. \hypertarget{classDefaultFetch_a865aaad70625f17392c717930860d386}{
\index{DefaultFetch@{DefaultFetch}!retryTid@{retryTid}}
\index{retryTid@{retryTid}!DefaultFetch@{DefaultFetch}}
\subsubsection[{retryTid}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} {\bf retryTid}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a865aaad70625f17392c717930860d386}
The thread that is waiting on the cache to tell fetch to retry. \hypertarget{classDefaultFetch_ade48cf321f5741ea8e54e071680cacdc}{
\index{DefaultFetch@{DefaultFetch}!stalls@{stalls}}
\index{stalls@{stalls}!DefaultFetch@{DefaultFetch}}
\subsubsection[{stalls}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stalls} {\bf stalls}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_ade48cf321f5741ea8e54e071680cacdc}
Tracks which stages are telling fetch to stall. \hypertarget{classDefaultFetch_ac4dd16b14420d21b5704350fbbcefd04}{
\index{DefaultFetch@{DefaultFetch}!threadFetched@{threadFetched}}
\index{threadFetched@{threadFetched}!DefaultFetch@{DefaultFetch}}
\subsubsection[{threadFetched}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} {\bf threadFetched}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_ac4dd16b14420d21b5704350fbbcefd04}
Thread ID being fetched. \hypertarget{classDefaultFetch_a83f9ee976e732665aeb08dbc19acfd45}{
\index{DefaultFetch@{DefaultFetch}!timeBuffer@{timeBuffer}}
\index{timeBuffer@{timeBuffer}!DefaultFetch@{DefaultFetch}}
\subsubsection[{timeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$$\ast$ {\bf timeBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a83f9ee976e732665aeb08dbc19acfd45}
\hyperlink{classTime}{Time} buffer interface. \hypertarget{classDefaultFetch_a5283adcc786817de9adc5a4601aa3a6f}{
\index{DefaultFetch@{DefaultFetch}!toDecode@{toDecode}}
\index{toDecode@{toDecode}!DefaultFetch@{DefaultFetch}}
\subsubsection[{toDecode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf FetchStruct}$>$::wire {\bf toDecode}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a5283adcc786817de9adc5a4601aa3a6f}
\hyperlink{classWire}{Wire} used to write any information heading to decode. \hypertarget{classDefaultFetch_a2c7e870d4babdac0dc91fc7ffabd0f3d}{
\index{DefaultFetch@{DefaultFetch}!wroteToTimeBuffer@{wroteToTimeBuffer}}
\index{wroteToTimeBuffer@{wroteToTimeBuffer}!DefaultFetch@{DefaultFetch}}
\subsubsection[{wroteToTimeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf wroteToTimeBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultFetch_a2c7e870d4babdac0dc91fc7ffabd0f3d}
Variable that tracks if fetch has written to the time buffer this cycle. Used to tell CPU if there is activity this cycle. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/o3/\hyperlink{fetch_8hh}{fetch.hh}\item 
cpu/o3/\hyperlink{fetch__impl_8hh}{fetch\_\-impl.hh}\end{DoxyCompactItemize}
