\hypertarget{classCacheMemory}{
\section{クラス CacheMemory}
\label{classCacheMemory}\index{CacheMemory@{CacheMemory}}
}


{\ttfamily \#include $<$CacheMemory.hh$>$}CacheMemoryに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classCacheMemory}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef RubyCacheParams \hyperlink{classCacheMemory_ae5279e63669c110c0bd87dca490f126d}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classCacheMemory_a6d47aa204a76f4d2c72e64478e365f80}{CacheMemory} (const \hyperlink{classCacheMemory_ae5279e63669c110c0bd87dca490f126d}{Params} $\ast$p)
\item 
\hyperlink{classCacheMemory_a331251b11e8dca3018962c8209d79385}{$\sim$CacheMemory} ()
\item 
void \hyperlink{classCacheMemory_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
bool \hyperlink{classCacheMemory_acfc92479973bfd11ae0191fd798ba44c}{tryCacheAccess} (const \hyperlink{classAddress}{Address} \&address, RubyRequestType type, \hyperlink{classDataBlock}{DataBlock} $\ast$\&data\_\-ptr)
\item 
bool \hyperlink{classCacheMemory_aba82772b79ad7b17d20d195979043473}{testCacheAccess} (const \hyperlink{classAddress}{Address} \&address, RubyRequestType type, \hyperlink{classDataBlock}{DataBlock} $\ast$\&data\_\-ptr)
\item 
bool \hyperlink{classCacheMemory_a38231bf6d0b58d2b0319faa5af3135ca}{isTagPresent} (const \hyperlink{classAddress}{Address} \&address) const 
\item 
bool \hyperlink{classCacheMemory_add6ef1702fc19966e797bbebabf3cefa}{cacheAvail} (const \hyperlink{classAddress}{Address} \&address) const 
\item 
\hyperlink{classAbstractCacheEntry}{AbstractCacheEntry} $\ast$ \hyperlink{classCacheMemory_a3318e163b565401bb192c21040097d88}{allocate} (const \hyperlink{classAddress}{Address} \&address, \hyperlink{classAbstractCacheEntry}{AbstractCacheEntry} $\ast$new\_\-entry)
\item 
void \hyperlink{classCacheMemory_a97904b9885a944606b8d74fe48fa427a}{allocateVoid} (const \hyperlink{classAddress}{Address} \&address, \hyperlink{classAbstractCacheEntry}{AbstractCacheEntry} $\ast$new\_\-entry)
\item 
void \hyperlink{classCacheMemory_ad1a3e4943cc214363839148c7d94d6a4}{deallocate} (const \hyperlink{classAddress}{Address} \&address)
\item 
\hyperlink{classAddress}{Address} \hyperlink{classCacheMemory_ab7017a4e3b3db35ecd4f778ec0f61cdf}{cacheProbe} (const \hyperlink{classAddress}{Address} \&address) const 
\item 
\hyperlink{classAbstractCacheEntry}{AbstractCacheEntry} $\ast$ \hyperlink{classCacheMemory_a0c6ae9fa65dfd9c0786e2e5a39be4a1e}{lookup} (const \hyperlink{classAddress}{Address} \&address)
\item 
const \hyperlink{classAbstractCacheEntry}{AbstractCacheEntry} $\ast$ \hyperlink{classCacheMemory_a28b926de4d910367b746eb67d244f250}{lookup} (const \hyperlink{classAddress}{Address} \&address) const 
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classCacheMemory_ae69a59f28f0cfd099bf798cb6bb76356}{getLatency} () const 
\item 
void \hyperlink{classCacheMemory_aa6672e5328a3421c133ea5590f4b562d}{recordCacheContents} (int cntrl, \hyperlink{classCacheRecorder}{CacheRecorder} $\ast$tr) const 
\item 
void \hyperlink{classCacheMemory_a82f197cef10db015c46d8e9f71275f47}{setMRU} (const \hyperlink{classAddress}{Address} \&address)
\item 
void \hyperlink{classCacheMemory_a046beba265922d99b46eb407d30fa14a}{setLocked} (const \hyperlink{classAddress}{Address} \&addr, int context)
\item 
void \hyperlink{classCacheMemory_abd16aaa7623b6ed38e15bde2b210f88a}{clearLocked} (const \hyperlink{classAddress}{Address} \&addr)
\item 
bool \hyperlink{classCacheMemory_aeb3a7f627af8ca6e8c5f9a878a01ea6f}{isLocked} (const \hyperlink{classAddress}{Address} \&addr, int context)
\item 
void \hyperlink{classCacheMemory_ac55fe386a101fbae38c716067c9966a0}{print} (std::ostream \&out) const 
\item 
void \hyperlink{classCacheMemory_a82b5740a65950cb6ba001dc852567da7}{printData} (std::ostream \&out) const 
\item 
void \hyperlink{classCacheMemory_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
bool \hyperlink{classCacheMemory_a89094cea0857bcf3a16b429c0b3f8bfe}{checkResourceAvailable} (CacheResourceType res, \hyperlink{classAddress}{Address} addr)
\item 
void \hyperlink{classCacheMemory_a4798ec530ab14c83a290b9d372e31a9d}{recordRequestType} (CacheRequestType requestType)
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classCacheMemory_a47c68eff474df127a7e5e36b40965bdc}{m\_\-demand\_\-hits}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classCacheMemory_a3f24c5bd8e3da8dbb584cf70d3de4f09}{m\_\-demand\_\-misses}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classCacheMemory_a6d06da3f5d70180680054f20a4862051}{m\_\-demand\_\-accesses}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classCacheMemory_af2b41944a982febf9af12d438f137b87}{m\_\-sw\_\-prefetches}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classCacheMemory_a5ae5fe863837358e6e9a60e0b702fb94}{m\_\-hw\_\-prefetches}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classCacheMemory_a549248150d50bed3e4d815869edee7de}{m\_\-prefetches}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classCacheMemory_a83d90a771e3ee60100ef1730f1a118b1}{m\_\-accessModeType}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classCacheMemory_a0f63a1bbaf1dee7c23ab3ac06a80d775}{numDataArrayReads}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classCacheMemory_a97557f8d2f957731bdea9fd4537a140e}{numDataArrayWrites}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classCacheMemory_a3e723404e0119a13e13ca25460179249}{numTagArrayReads}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classCacheMemory_a3e43debd337a55436570324681b20000}{numTagArrayWrites}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classCacheMemory_aa8cfd5b3d3480062677e2229d8573483}{numTagArrayStalls}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classCacheMemory_a4034a29f6d2be3493f40aaa13ca6c77a}{numDataArrayStalls}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{TypeDefines_8hh_a39642de41f3574937f399f4fab25ba18}{Index} \hyperlink{classCacheMemory_ab8af076beefca7ea17d6ffbf639456db}{addressToCacheSet} (const \hyperlink{classAddress}{Address} \&address) const 
\item 
int \hyperlink{classCacheMemory_ac32dac48596332a7537a1e3c31cfd3c0}{findTagInSet} (\hyperlink{TypeDefines_8hh_a39642de41f3574937f399f4fab25ba18}{Index} line, const \hyperlink{classAddress}{Address} \&tag) const 
\item 
int \hyperlink{classCacheMemory_ad7d6ceb226fbf63dc2c91a61aa57d98a}{findTagInSetIgnorePermissions} (\hyperlink{TypeDefines_8hh_a39642de41f3574937f399f4fab25ba18}{Index} cacheSet, const \hyperlink{classAddress}{Address} \&tag) const 
\item 
\hyperlink{classCacheMemory_a15c87d4f0ba579b954e84d6eee946d46}{CacheMemory} (const \hyperlink{classCacheMemory}{CacheMemory} \&obj)
\item 
\hyperlink{classCacheMemory}{CacheMemory} \& \hyperlink{classCacheMemory_a3ba0e3a7cc49aede911aa79977fc4128}{operator=} (const \hyperlink{classCacheMemory}{CacheMemory} \&obj)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classCacheMemory_a7599697a6c831356525c7d97604edd31}{m\_\-latency}
\item 
bool \hyperlink{classCacheMemory_a0c3e90f32ef2e92b91ca006d44c12374}{m\_\-is\_\-instruction\_\-only\_\-cache}
\item 
m5::hash\_\-map$<$ \hyperlink{classAddress}{Address}, int $>$ \hyperlink{classCacheMemory_a546a29030c6970bfbc1197ae75826bc4}{m\_\-tag\_\-index}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classAbstractCacheEntry}{AbstractCacheEntry} $\ast$ $>$ $>$ \hyperlink{classCacheMemory_a07906f5e66f388186af8b84540922dcd}{m\_\-cache}
\item 
\hyperlink{classAbstractReplacementPolicy}{AbstractReplacementPolicy} $\ast$ \hyperlink{classCacheMemory_a37cdae2a2fe6c2b1a976cf8b3ae19f18}{m\_\-replacementPolicy\_\-ptr}
\item 
\hyperlink{classBankedArray}{BankedArray} \hyperlink{classCacheMemory_a3fe8de4d2516b188e76e11c5213d8eaf}{dataArray}
\item 
\hyperlink{classBankedArray}{BankedArray} \hyperlink{classCacheMemory_a68d742104ef77f83fee4d7832cc873fe}{tagArray}
\item 
int \hyperlink{classCacheMemory_a378c30d8d9ca0215ac61ea0974082ca0}{m\_\-cache\_\-size}
\item 
std::string \hyperlink{classCacheMemory_a89cf1f810dd6f5f9da8a2d588418ec49}{m\_\-policy}
\item 
int \hyperlink{classCacheMemory_a8773f9a442fa00b24f4c65c86dcd25d6}{m\_\-cache\_\-num\_\-sets}
\item 
int \hyperlink{classCacheMemory_a6b2e7aa0964d945df6b08fbbdd316f47}{m\_\-cache\_\-num\_\-set\_\-bits}
\item 
int \hyperlink{classCacheMemory_a0dcca2db5987fbc671fc1fef4169ebed}{m\_\-cache\_\-assoc}
\item 
int \hyperlink{classCacheMemory_ab350a6d3428acab3678b17bbd2d00c4b}{m\_\-start\_\-index\_\-bit}
\item 
bool \hyperlink{classCacheMemory_aa08c2cb7bf60a80e6be95267b1060509}{m\_\-resource\_\-stalls}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classCacheMemory_ae5279e63669c110c0bd87dca490f126d}{
\index{CacheMemory@{CacheMemory}!Params@{Params}}
\index{Params@{Params}!CacheMemory@{CacheMemory}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef RubyCacheParams {\bf Params}}}
\label{classCacheMemory_ae5279e63669c110c0bd87dca490f126d}


\hyperlink{classSimObject_a0f0761d2db586a23bb2a2880b8f387bb}{SimObject}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classCacheMemory_a6d47aa204a76f4d2c72e64478e365f80}{
\index{CacheMemory@{CacheMemory}!CacheMemory@{CacheMemory}}
\index{CacheMemory@{CacheMemory}!CacheMemory@{CacheMemory}}
\subsubsection[{CacheMemory}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CacheMemory} (const {\bf Params} $\ast$ {\em p})}}
\label{classCacheMemory_a6d47aa204a76f4d2c72e64478e365f80}



\begin{DoxyCode}
55     : SimObject(p),
56     dataArray(p->dataArrayBanks, p->dataAccessLatency, p->start_index_bit),
57     tagArray(p->tagArrayBanks, p->tagAccessLatency, p->start_index_bit)
58 {
59     m_cache_size = p->size;
60     m_latency = p->latency;
61     m_cache_assoc = p->assoc;
62     m_policy = p->replacement_policy;
63     m_start_index_bit = p->start_index_bit;
64     m_is_instruction_only_cache = p->is_icache;
65     m_resource_stalls = p->resourceStalls;
66 }
\end{DoxyCode}
\hypertarget{classCacheMemory_a331251b11e8dca3018962c8209d79385}{
\index{CacheMemory@{CacheMemory}!$\sim$CacheMemory@{$\sim$CacheMemory}}
\index{$\sim$CacheMemory@{$\sim$CacheMemory}!CacheMemory@{CacheMemory}}
\subsubsection[{$\sim$CacheMemory}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf CacheMemory} ()}}
\label{classCacheMemory_a331251b11e8dca3018962c8209d79385}



\begin{DoxyCode}
96 {
97     if (m_replacementPolicy_ptr != NULL)
98         delete m_replacementPolicy_ptr;
99     for (int i = 0; i < m_cache_num_sets; i++) {
100         for (int j = 0; j < m_cache_assoc; j++) {
101             delete m_cache[i][j];
102         }
103     }
104 }
\end{DoxyCode}
\hypertarget{classCacheMemory_a15c87d4f0ba579b954e84d6eee946d46}{
\index{CacheMemory@{CacheMemory}!CacheMemory@{CacheMemory}}
\index{CacheMemory@{CacheMemory}!CacheMemory@{CacheMemory}}
\subsubsection[{CacheMemory}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CacheMemory} (const {\bf CacheMemory} \& {\em obj})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_a15c87d4f0ba579b954e84d6eee946d46}


\subsection{関数}
\hypertarget{classCacheMemory_ab8af076beefca7ea17d6ffbf639456db}{
\index{CacheMemory@{CacheMemory}!addressToCacheSet@{addressToCacheSet}}
\index{addressToCacheSet@{addressToCacheSet}!CacheMemory@{CacheMemory}}
\subsubsection[{addressToCacheSet}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Index} addressToCacheSet (const {\bf Address} \& {\em address}) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_ab8af076beefca7ea17d6ffbf639456db}



\begin{DoxyCode}
109 {
110     assert(address == line_address(address));
111     return address.bitSelect(m_start_index_bit,
112                              m_start_index_bit + m_cache_num_set_bits - 1);
113 }
\end{DoxyCode}
\hypertarget{classCacheMemory_a3318e163b565401bb192c21040097d88}{
\index{CacheMemory@{CacheMemory}!allocate@{allocate}}
\index{allocate@{allocate}!CacheMemory@{CacheMemory}}
\subsubsection[{allocate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AbstractCacheEntry} $\ast$ allocate (const {\bf Address} \& {\em address}, \/  {\bf AbstractCacheEntry} $\ast$ {\em new\_\-entry})}}
\label{classCacheMemory_a3318e163b565401bb192c21040097d88}



\begin{DoxyCode}
238 {
239     assert(address == line_address(address));
240     assert(!isTagPresent(address));
241     assert(cacheAvail(address));
242     DPRINTF(RubyCache, "address: %s\n", address);
243 
244     // Find the first open slot
245     Index cacheSet = addressToCacheSet(address);
246     std::vector<AbstractCacheEntry*> &set = m_cache[cacheSet];
247     for (int i = 0; i < m_cache_assoc; i++) {
248         if (!set[i] || set[i]->m_Permission == AccessPermission_NotPresent) {
249             set[i] = entry;  // Init entry
250             set[i]->m_Address = address;
251             set[i]->m_Permission = AccessPermission_Invalid;
252             DPRINTF(RubyCache, "Allocate clearing lock for addr: %x\n",
253                     address);
254             set[i]->m_locked = -1;
255             m_tag_index[address] = i;
256 
257             m_replacementPolicy_ptr->touch(cacheSet, i, curTick());
258 
259             return entry;
260         }
261     }
262     panic("Allocate didn't find an available entry");
263 }
\end{DoxyCode}
\hypertarget{classCacheMemory_a97904b9885a944606b8d74fe48fa427a}{
\index{CacheMemory@{CacheMemory}!allocateVoid@{allocateVoid}}
\index{allocateVoid@{allocateVoid}!CacheMemory@{CacheMemory}}
\subsubsection[{allocateVoid}]{\setlength{\rightskip}{0pt plus 5cm}void allocateVoid (const {\bf Address} \& {\em address}, \/  {\bf AbstractCacheEntry} $\ast$ {\em new\_\-entry})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCacheMemory_a97904b9885a944606b8d74fe48fa427a}



\begin{DoxyCode}
79     {
80         allocate(address, new_entry);
81     }
\end{DoxyCode}
\hypertarget{classCacheMemory_add6ef1702fc19966e797bbebabf3cefa}{
\index{CacheMemory@{CacheMemory}!cacheAvail@{cacheAvail}}
\index{cacheAvail@{cacheAvail}!CacheMemory@{CacheMemory}}
\subsubsection[{cacheAvail}]{\setlength{\rightskip}{0pt plus 5cm}bool cacheAvail (const {\bf Address} \& {\em address}) const}}
\label{classCacheMemory_add6ef1702fc19966e797bbebabf3cefa}



\begin{DoxyCode}
216 {
217     assert(address == line_address(address));
218 
219     Index cacheSet = addressToCacheSet(address);
220 
221     for (int i = 0; i < m_cache_assoc; i++) {
222         AbstractCacheEntry* entry = m_cache[cacheSet][i];
223         if (entry != NULL) {
224             if (entry->m_Address == address ||
225                 entry->m_Permission == AccessPermission_NotPresent) {
226                 // Already in the cache or we found an empty entry
227                 return true;
228             }
229         } else {
230             return true;
231         }
232     }
233     return false;
234 }
\end{DoxyCode}
\hypertarget{classCacheMemory_ab7017a4e3b3db35ecd4f778ec0f61cdf}{
\index{CacheMemory@{CacheMemory}!cacheProbe@{cacheProbe}}
\index{cacheProbe@{cacheProbe}!CacheMemory@{CacheMemory}}
\subsubsection[{cacheProbe}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} cacheProbe (const {\bf Address} \& {\em address}) const}}
\label{classCacheMemory_ab7017a4e3b3db35ecd4f778ec0f61cdf}



\begin{DoxyCode}
283 {
284     assert(address == line_address(address));
285     assert(!cacheAvail(address));
286 
287     Index cacheSet = addressToCacheSet(address);
288     return m_cache[cacheSet][m_replacementPolicy_ptr->getVictim(cacheSet)]->
289         m_Address;
290 }
\end{DoxyCode}
\hypertarget{classCacheMemory_a89094cea0857bcf3a16b429c0b3f8bfe}{
\index{CacheMemory@{CacheMemory}!checkResourceAvailable@{checkResourceAvailable}}
\index{checkResourceAvailable@{checkResourceAvailable}!CacheMemory@{CacheMemory}}
\subsubsection[{checkResourceAvailable}]{\setlength{\rightskip}{0pt plus 5cm}bool checkResourceAvailable (CacheResourceType {\em res}, \/  {\bf Address} {\em addr})}}
\label{classCacheMemory_a89094cea0857bcf3a16b429c0b3f8bfe}



\begin{DoxyCode}
538 {
539     if (!m_resource_stalls) {
540         return true;
541     }
542 
543     if (res == CacheResourceType_TagArray) {
544         if (tagArray.tryAccess(addressToCacheSet(addr))) return true;
545         else {
546             DPRINTF(RubyResourceStalls,
547                     "Tag array stall on addr %s in set %d\n",
548                     addr, addressToCacheSet(addr));
549             numTagArrayStalls++;
550             return false;
551         }
552     } else if (res == CacheResourceType_DataArray) {
553         if (dataArray.tryAccess(addressToCacheSet(addr))) return true;
554         else {
555             DPRINTF(RubyResourceStalls,
556                     "Data array stall on addr %s in set %d\n",
557                     addr, addressToCacheSet(addr));
558             numDataArrayStalls++;
559             return false;
560         }
561     } else {
562         assert(false);
563         return true;
564     }
565 }
\end{DoxyCode}
\hypertarget{classCacheMemory_abd16aaa7623b6ed38e15bde2b210f88a}{
\index{CacheMemory@{CacheMemory}!clearLocked@{clearLocked}}
\index{clearLocked@{clearLocked}!CacheMemory@{CacheMemory}}
\subsubsection[{clearLocked}]{\setlength{\rightskip}{0pt plus 5cm}void clearLocked (const {\bf Address} \& {\em addr})}}
\label{classCacheMemory_abd16aaa7623b6ed38e15bde2b210f88a}



\begin{DoxyCode}
402 {
403     DPRINTF(RubyCache, "Clear Lock for addr: %x\n", address);
404     assert(address == line_address(address));
405     Index cacheSet = addressToCacheSet(address);
406     int loc = findTagInSet(cacheSet, address);
407     assert(loc != -1);
408     m_cache[cacheSet][loc]->m_locked = -1;
409 }
\end{DoxyCode}
\hypertarget{classCacheMemory_ad1a3e4943cc214363839148c7d94d6a4}{
\index{CacheMemory@{CacheMemory}!deallocate@{deallocate}}
\index{deallocate@{deallocate}!CacheMemory@{CacheMemory}}
\subsubsection[{deallocate}]{\setlength{\rightskip}{0pt plus 5cm}void deallocate (const {\bf Address} \& {\em address})}}
\label{classCacheMemory_ad1a3e4943cc214363839148c7d94d6a4}



\begin{DoxyCode}
267 {
268     assert(address == line_address(address));
269     assert(isTagPresent(address));
270     DPRINTF(RubyCache, "address: %s\n", address);
271     Index cacheSet = addressToCacheSet(address);
272     int loc = findTagInSet(cacheSet, address);
273     if (loc != -1) {
274         delete m_cache[cacheSet][loc];
275         m_cache[cacheSet][loc] = NULL;
276         m_tag_index.erase(address);
277     }
278 }
\end{DoxyCode}
\hypertarget{classCacheMemory_ac32dac48596332a7537a1e3c31cfd3c0}{
\index{CacheMemory@{CacheMemory}!findTagInSet@{findTagInSet}}
\index{findTagInSet@{findTagInSet}!CacheMemory@{CacheMemory}}
\subsubsection[{findTagInSet}]{\setlength{\rightskip}{0pt plus 5cm}int findTagInSet ({\bf Index} {\em line}, \/  const {\bf Address} \& {\em tag}) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_ac32dac48596332a7537a1e3c31cfd3c0}



\begin{DoxyCode}
119 {
120     assert(tag == line_address(tag));
121     // search the set for the tags
122     m5::hash_map<Address, int>::const_iterator it = m_tag_index.find(tag);
123     if (it != m_tag_index.end())
124         if (m_cache[cacheSet][it->second]->m_Permission !=
125             AccessPermission_NotPresent)
126             return it->second;
127     return -1; // Not found
128 }
\end{DoxyCode}
\hypertarget{classCacheMemory_ad7d6ceb226fbf63dc2c91a61aa57d98a}{
\index{CacheMemory@{CacheMemory}!findTagInSetIgnorePermissions@{findTagInSetIgnorePermissions}}
\index{findTagInSetIgnorePermissions@{findTagInSetIgnorePermissions}!CacheMemory@{CacheMemory}}
\subsubsection[{findTagInSetIgnorePermissions}]{\setlength{\rightskip}{0pt plus 5cm}int findTagInSetIgnorePermissions ({\bf Index} {\em cacheSet}, \/  const {\bf Address} \& {\em tag}) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_ad7d6ceb226fbf63dc2c91a61aa57d98a}



\begin{DoxyCode}
135 {
136     assert(tag == line_address(tag));
137     // search the set for the tags
138     m5::hash_map<Address, int>::const_iterator it = m_tag_index.find(tag);
139     if (it != m_tag_index.end())
140         return it->second;
141     return -1; // Not found
142 }
\end{DoxyCode}
\hypertarget{classCacheMemory_ae69a59f28f0cfd099bf798cb6bb76356}{
\index{CacheMemory@{CacheMemory}!getLatency@{getLatency}}
\index{getLatency@{getLatency}!CacheMemory@{CacheMemory}}
\subsubsection[{getLatency}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} getLatency () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCacheMemory_ae69a59f28f0cfd099bf798cb6bb76356}



\begin{DoxyCode}
93 { return m_latency; }
\end{DoxyCode}
\hypertarget{classCacheMemory_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{CacheMemory@{CacheMemory}!init@{init}}
\index{init@{init}!CacheMemory@{CacheMemory}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCacheMemory_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classCacheMemory_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{SimObject}を再定義しています。


\begin{DoxyCode}
70 {
71     m_cache_num_sets = (m_cache_size / m_cache_assoc) /
72         RubySystem::getBlockSizeBytes();
73     assert(m_cache_num_sets > 1);
74     m_cache_num_set_bits = floorLog2(m_cache_num_sets);
75     assert(m_cache_num_set_bits > 0);
76 
77     if (m_policy == "PSEUDO_LRU")
78         m_replacementPolicy_ptr =
79             new PseudoLRUPolicy(m_cache_num_sets, m_cache_assoc);
80     else if (m_policy == "LRU")
81         m_replacementPolicy_ptr =
82             new LRUPolicy(m_cache_num_sets, m_cache_assoc);
83     else
84         assert(false);
85 
86     m_cache.resize(m_cache_num_sets);
87     for (int i = 0; i < m_cache_num_sets; i++) {
88         m_cache[i].resize(m_cache_assoc);
89         for (int j = 0; j < m_cache_assoc; j++) {
90             m_cache[i][j] = NULL;
91         }
92     }
93 }
\end{DoxyCode}
\hypertarget{classCacheMemory_aeb3a7f627af8ca6e8c5f9a878a01ea6f}{
\index{CacheMemory@{CacheMemory}!isLocked@{isLocked}}
\index{isLocked@{isLocked}!CacheMemory@{CacheMemory}}
\subsubsection[{isLocked}]{\setlength{\rightskip}{0pt plus 5cm}bool isLocked (const {\bf Address} \& {\em addr}, \/  int {\em context})}}
\label{classCacheMemory_aeb3a7f627af8ca6e8c5f9a878a01ea6f}



\begin{DoxyCode}
413 {
414     assert(address == line_address(address));
415     Index cacheSet = addressToCacheSet(address);
416     int loc = findTagInSet(cacheSet, address);
417     assert(loc != -1);
418     DPRINTF(RubyCache, "Testing Lock for addr: %llx cur %d con %d\n",
419             address, m_cache[cacheSet][loc]->m_locked, context);
420     return m_cache[cacheSet][loc]->m_locked == context;
421 }
\end{DoxyCode}
\hypertarget{classCacheMemory_a38231bf6d0b58d2b0319faa5af3135ca}{
\index{CacheMemory@{CacheMemory}!isTagPresent@{isTagPresent}}
\index{isTagPresent@{isTagPresent}!CacheMemory@{CacheMemory}}
\subsubsection[{isTagPresent}]{\setlength{\rightskip}{0pt plus 5cm}bool isTagPresent (const {\bf Address} \& {\em address}) const}}
\label{classCacheMemory_a38231bf6d0b58d2b0319faa5af3135ca}



\begin{DoxyCode}
197 {
198     assert(address == line_address(address));
199     Index cacheSet = addressToCacheSet(address);
200     int loc = findTagInSet(cacheSet, address);
201 
202     if (loc == -1) {
203         // We didn't find the tag
204         DPRINTF(RubyCache, "No tag match for address: %s\n", address);
205         return false;
206     }
207     DPRINTF(RubyCache, "address: %s found\n", address);
208     return true;
209 }
\end{DoxyCode}
\hypertarget{classCacheMemory_a28b926de4d910367b746eb67d244f250}{
\index{CacheMemory@{CacheMemory}!lookup@{lookup}}
\index{lookup@{lookup}!CacheMemory@{CacheMemory}}
\subsubsection[{lookup}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf AbstractCacheEntry} $\ast$ lookup (const {\bf Address} \& {\em address}) const}}
\label{classCacheMemory_a28b926de4d910367b746eb67d244f250}



\begin{DoxyCode}
306 {
307     assert(address == line_address(address));
308     Index cacheSet = addressToCacheSet(address);
309     int loc = findTagInSet(cacheSet, address);
310     if(loc == -1) return NULL;
311     return m_cache[cacheSet][loc];
312 }
\end{DoxyCode}
\hypertarget{classCacheMemory_a0c6ae9fa65dfd9c0786e2e5a39be4a1e}{
\index{CacheMemory@{CacheMemory}!lookup@{lookup}}
\index{lookup@{lookup}!CacheMemory@{CacheMemory}}
\subsubsection[{lookup}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AbstractCacheEntry} $\ast$ lookup (const {\bf Address} \& {\em address})}}
\label{classCacheMemory_a0c6ae9fa65dfd9c0786e2e5a39be4a1e}



\begin{DoxyCode}
295 {
296     assert(address == line_address(address));
297     Index cacheSet = addressToCacheSet(address);
298     int loc = findTagInSet(cacheSet, address);
299     if(loc == -1) return NULL;
300     return m_cache[cacheSet][loc];
301 }
\end{DoxyCode}
\hypertarget{classCacheMemory_a3ba0e3a7cc49aede911aa79977fc4128}{
\index{CacheMemory@{CacheMemory}!operator=@{operator=}}
\index{operator=@{operator=}!CacheMemory@{CacheMemory}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CacheMemory}\& operator= (const {\bf CacheMemory} \& {\em obj})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_a3ba0e3a7cc49aede911aa79977fc4128}
\hypertarget{classCacheMemory_ac55fe386a101fbae38c716067c9966a0}{
\index{CacheMemory@{CacheMemory}!print@{print}}
\index{print@{print}!CacheMemory@{CacheMemory}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}void print (std::ostream \& {\em out}) const}}
\label{classCacheMemory_ac55fe386a101fbae38c716067c9966a0}
\hypertarget{classCacheMemory_a82b5740a65950cb6ba001dc852567da7}{
\index{CacheMemory@{CacheMemory}!printData@{printData}}
\index{printData@{printData}!CacheMemory@{CacheMemory}}
\subsubsection[{printData}]{\setlength{\rightskip}{0pt plus 5cm}void printData (std::ostream \& {\em out}) const}}
\label{classCacheMemory_a82b5740a65950cb6ba001dc852567da7}
\hypertarget{classCacheMemory_aa6672e5328a3421c133ea5590f4b562d}{
\index{CacheMemory@{CacheMemory}!recordCacheContents@{recordCacheContents}}
\index{recordCacheContents@{recordCacheContents}!CacheMemory@{CacheMemory}}
\subsubsection[{recordCacheContents}]{\setlength{\rightskip}{0pt plus 5cm}void recordCacheContents (int {\em cntrl}, \/  {\bf CacheRecorder} $\ast$ {\em tr}) const}}
\label{classCacheMemory_aa6672e5328a3421c133ea5590f4b562d}



\begin{DoxyCode}
327 {
328     uint64 warmedUpBlocks = 0;
329     uint64 totalBlocks M5_VAR_USED = (uint64)m_cache_num_sets
330                                                   * (uint64)m_cache_assoc;
331 
332     for (int i = 0; i < m_cache_num_sets; i++) {
333         for (int j = 0; j < m_cache_assoc; j++) {
334             if (m_cache[i][j] != NULL) {
335                 AccessPermission perm = m_cache[i][j]->m_Permission;
336                 RubyRequestType request_type = RubyRequestType_NULL;
337                 if (perm == AccessPermission_Read_Only) {
338                     if (m_is_instruction_only_cache) {
339                         request_type = RubyRequestType_IFETCH;
340                     } else {
341                         request_type = RubyRequestType_LD;
342                     }
343                 } else if (perm == AccessPermission_Read_Write) {
344                     request_type = RubyRequestType_ST;
345                 }
346 
347                 if (request_type != RubyRequestType_NULL) {
348                     tr->addRecord(cntrl, m_cache[i][j]->m_Address.getAddress(),
349                                   0, request_type,
350                                   m_replacementPolicy_ptr->getLastAccess(i, j),
351                                   m_cache[i][j]->getDataBlk());
352                     warmedUpBlocks++;
353                 }
354             }
355         }
356     }
357 
358     DPRINTF(RubyCacheTrace, "%s: %lli blocks of %lli total blocks"
359             "recorded %.2f%% \n", name().c_str(), warmedUpBlocks,
360             (uint64)m_cache_num_sets * (uint64)m_cache_assoc,
361             (float(warmedUpBlocks)/float(totalBlocks))*100.0);
362 }
\end{DoxyCode}
\hypertarget{classCacheMemory_a4798ec530ab14c83a290b9d372e31a9d}{
\index{CacheMemory@{CacheMemory}!recordRequestType@{recordRequestType}}
\index{recordRequestType@{recordRequestType}!CacheMemory@{CacheMemory}}
\subsubsection[{recordRequestType}]{\setlength{\rightskip}{0pt plus 5cm}void recordRequestType (CacheRequestType {\em requestType})}}
\label{classCacheMemory_a4798ec530ab14c83a290b9d372e31a9d}



\begin{DoxyCode}
514 {
515     DPRINTF(RubyStats, "Recorded statistic: %s\n",
516             CacheRequestType_to_string(requestType));
517     switch(requestType) {
518     case CacheRequestType_DataArrayRead:
519         numDataArrayReads++;
520         return;
521     case CacheRequestType_DataArrayWrite:
522         numDataArrayWrites++;
523         return;
524     case CacheRequestType_TagArrayRead:
525         numTagArrayReads++;
526         return;
527     case CacheRequestType_TagArrayWrite:
528         numTagArrayWrites++;
529         return;
530     default:
531         warn("CacheMemory access_type not found: %s",
532              CacheRequestType_to_string(requestType));
533     }
534 }
\end{DoxyCode}
\hypertarget{classCacheMemory_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{CacheMemory@{CacheMemory}!regStats@{regStats}}
\index{regStats@{regStats}!CacheMemory@{CacheMemory}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCacheMemory_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} statistics for this object. 

\hyperlink{classSimObject_a4dc637449366fcdfc4e764cdf12d9b11}{SimObject}を再定義しています。


\begin{DoxyCode}
425 {
426     m_demand_hits
427         .name(name() + ".demand_hits")
428         .desc("Number of cache demand hits")
429         ;
430 
431     m_demand_misses
432         .name(name() + ".demand_misses")
433         .desc("Number of cache demand misses")
434         ;
435 
436     m_demand_accesses
437         .name(name() + ".demand_accesses")
438         .desc("Number of cache demand accesses")
439         ;
440 
441     m_demand_accesses = m_demand_hits + m_demand_misses;
442 
443     m_sw_prefetches
444         .name(name() + ".total_sw_prefetches")
445         .desc("Number of software prefetches")
446         .flags(Stats::nozero)
447         ;
448 
449     m_hw_prefetches
450         .name(name() + ".total_hw_prefetches")
451         .desc("Number of hardware prefetches")
452         .flags(Stats::nozero)
453         ;
454 
455     m_prefetches
456         .name(name() + ".total_prefetches")
457         .desc("Number of prefetches")
458         .flags(Stats::nozero)
459         ;
460 
461     m_prefetches = m_sw_prefetches + m_hw_prefetches;
462 
463     m_accessModeType
464         .init(RubyRequestType_NUM)
465         .name(name() + ".access_mode")
466         .flags(Stats::pdf | Stats::total)
467         ;
468     for (int i = 0; i < RubyAccessMode_NUM; i++) {
469         m_accessModeType
470             .subname(i, RubyAccessMode_to_string(RubyAccessMode(i)))
471             .flags(Stats::nozero)
472             ;
473     }
474 
475     numDataArrayReads
476         .name(name() + ".num_data_array_reads")
477         .desc("number of data array reads")
478         .flags(Stats::nozero)
479         ;
480 
481     numDataArrayWrites
482         .name(name() + ".num_data_array_writes")
483         .desc("number of data array writes")
484         .flags(Stats::nozero)
485         ;
486 
487     numTagArrayReads
488         .name(name() + ".num_tag_array_reads")
489         .desc("number of tag array reads")
490         .flags(Stats::nozero)
491         ;
492 
493     numTagArrayWrites
494         .name(name() + ".num_tag_array_writes")
495         .desc("number of tag array writes")
496         .flags(Stats::nozero)
497         ;
498 
499     numTagArrayStalls
500         .name(name() + ".num_tag_array_stalls")
501         .desc("number of stalls caused by tag array")
502         .flags(Stats::nozero)
503         ;
504 
505     numDataArrayStalls
506         .name(name() + ".num_data_array_stalls")
507         .desc("number of stalls caused by data array")
508         .flags(Stats::nozero)
509         ;
510 }
\end{DoxyCode}
\hypertarget{classCacheMemory_a046beba265922d99b46eb407d30fa14a}{
\index{CacheMemory@{CacheMemory}!setLocked@{setLocked}}
\index{setLocked@{setLocked}!CacheMemory@{CacheMemory}}
\subsubsection[{setLocked}]{\setlength{\rightskip}{0pt plus 5cm}void setLocked (const {\bf Address} \& {\em addr}, \/  int {\em context})}}
\label{classCacheMemory_a046beba265922d99b46eb407d30fa14a}



\begin{DoxyCode}
391 {
392     DPRINTF(RubyCache, "Setting Lock for addr: %x to %d\n", address, context);
393     assert(address == line_address(address));
394     Index cacheSet = addressToCacheSet(address);
395     int loc = findTagInSet(cacheSet, address);
396     assert(loc != -1);
397     m_cache[cacheSet][loc]->m_locked = context;
398 }
\end{DoxyCode}
\hypertarget{classCacheMemory_a82f197cef10db015c46d8e9f71275f47}{
\index{CacheMemory@{CacheMemory}!setMRU@{setMRU}}
\index{setMRU@{setMRU}!CacheMemory@{CacheMemory}}
\subsubsection[{setMRU}]{\setlength{\rightskip}{0pt plus 5cm}void setMRU (const {\bf Address} \& {\em address})}}
\label{classCacheMemory_a82f197cef10db015c46d8e9f71275f47}



\begin{DoxyCode}
317 {
318     Index cacheSet = addressToCacheSet(address);
319     int loc = findTagInSet(cacheSet, address);
320 
321     if(loc != -1)
322         m_replacementPolicy_ptr->touch(cacheSet, loc, curTick());
323 }
\end{DoxyCode}
\hypertarget{classCacheMemory_aba82772b79ad7b17d20d195979043473}{
\index{CacheMemory@{CacheMemory}!testCacheAccess@{testCacheAccess}}
\index{testCacheAccess@{testCacheAccess}!CacheMemory@{CacheMemory}}
\subsubsection[{testCacheAccess}]{\setlength{\rightskip}{0pt plus 5cm}bool testCacheAccess (const {\bf Address} \& {\em address}, \/  RubyRequestType {\em type}, \/  {\bf DataBlock} $\ast$\& {\em data\_\-ptr})}}
\label{classCacheMemory_aba82772b79ad7b17d20d195979043473}



\begin{DoxyCode}
174 {
175     assert(address == line_address(address));
176     DPRINTF(RubyCache, "address: %s\n", address);
177     Index cacheSet = addressToCacheSet(address);
178     int loc = findTagInSet(cacheSet, address);
179 
180     if (loc != -1) {
181         // Do we even have a tag match?
182         AbstractCacheEntry* entry = m_cache[cacheSet][loc];
183         m_replacementPolicy_ptr->touch(cacheSet, loc, curTick());
184         data_ptr = &(entry->getDataBlk());
185 
186         return m_cache[cacheSet][loc]->m_Permission !=
187             AccessPermission_NotPresent;
188     }
189 
190     data_ptr = NULL;
191     return false;
192 }
\end{DoxyCode}
\hypertarget{classCacheMemory_acfc92479973bfd11ae0191fd798ba44c}{
\index{CacheMemory@{CacheMemory}!tryCacheAccess@{tryCacheAccess}}
\index{tryCacheAccess@{tryCacheAccess}!CacheMemory@{CacheMemory}}
\subsubsection[{tryCacheAccess}]{\setlength{\rightskip}{0pt plus 5cm}bool tryCacheAccess (const {\bf Address} \& {\em address}, \/  RubyRequestType {\em type}, \/  {\bf DataBlock} $\ast$\& {\em data\_\-ptr})}}
\label{classCacheMemory_acfc92479973bfd11ae0191fd798ba44c}



\begin{DoxyCode}
147 {
148     assert(address == line_address(address));
149     DPRINTF(RubyCache, "address: %s\n", address);
150     Index cacheSet = addressToCacheSet(address);
151     int loc = findTagInSet(cacheSet, address);
152     if (loc != -1) {
153         // Do we even have a tag match?
154         AbstractCacheEntry* entry = m_cache[cacheSet][loc];
155         m_replacementPolicy_ptr->touch(cacheSet, loc, curTick());
156         data_ptr = &(entry->getDataBlk());
157 
158         if (entry->m_Permission == AccessPermission_Read_Write) {
159             return true;
160         }
161         if ((entry->m_Permission == AccessPermission_Read_Only) &&
162             (type == RubyRequestType_LD || type == RubyRequestType_IFETCH)) {
163             return true;
164         }
165         // The line must not be accessible
166     }
167     data_ptr = NULL;
168     return false;
169 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classCacheMemory_a3fe8de4d2516b188e76e11c5213d8eaf}{
\index{CacheMemory@{CacheMemory}!dataArray@{dataArray}}
\index{dataArray@{dataArray}!CacheMemory@{CacheMemory}}
\subsubsection[{dataArray}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BankedArray} {\bf dataArray}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_a3fe8de4d2516b188e76e11c5213d8eaf}
\hypertarget{classCacheMemory_a83d90a771e3ee60100ef1730f1a118b1}{
\index{CacheMemory@{CacheMemory}!m\_\-accessModeType@{m\_\-accessModeType}}
\index{m\_\-accessModeType@{m\_\-accessModeType}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-accessModeType}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf m\_\-accessModeType}}}
\label{classCacheMemory_a83d90a771e3ee60100ef1730f1a118b1}
\hypertarget{classCacheMemory_a07906f5e66f388186af8b84540922dcd}{
\index{CacheMemory@{CacheMemory}!m\_\-cache@{m\_\-cache}}
\index{m\_\-cache@{m\_\-cache}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-cache}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf std::vector}$<${\bf AbstractCacheEntry}$\ast$$>$ $>$ {\bf m\_\-cache}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_a07906f5e66f388186af8b84540922dcd}
\hypertarget{classCacheMemory_a0dcca2db5987fbc671fc1fef4169ebed}{
\index{CacheMemory@{CacheMemory}!m\_\-cache\_\-assoc@{m\_\-cache\_\-assoc}}
\index{m\_\-cache\_\-assoc@{m\_\-cache\_\-assoc}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-cache\_\-assoc}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-cache\_\-assoc}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_a0dcca2db5987fbc671fc1fef4169ebed}
\hypertarget{classCacheMemory_a6b2e7aa0964d945df6b08fbbdd316f47}{
\index{CacheMemory@{CacheMemory}!m\_\-cache\_\-num\_\-set\_\-bits@{m\_\-cache\_\-num\_\-set\_\-bits}}
\index{m\_\-cache\_\-num\_\-set\_\-bits@{m\_\-cache\_\-num\_\-set\_\-bits}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-cache\_\-num\_\-set\_\-bits}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-cache\_\-num\_\-set\_\-bits}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_a6b2e7aa0964d945df6b08fbbdd316f47}
\hypertarget{classCacheMemory_a8773f9a442fa00b24f4c65c86dcd25d6}{
\index{CacheMemory@{CacheMemory}!m\_\-cache\_\-num\_\-sets@{m\_\-cache\_\-num\_\-sets}}
\index{m\_\-cache\_\-num\_\-sets@{m\_\-cache\_\-num\_\-sets}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-cache\_\-num\_\-sets}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-cache\_\-num\_\-sets}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_a8773f9a442fa00b24f4c65c86dcd25d6}
\hypertarget{classCacheMemory_a378c30d8d9ca0215ac61ea0974082ca0}{
\index{CacheMemory@{CacheMemory}!m\_\-cache\_\-size@{m\_\-cache\_\-size}}
\index{m\_\-cache\_\-size@{m\_\-cache\_\-size}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-cache\_\-size}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-cache\_\-size}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_a378c30d8d9ca0215ac61ea0974082ca0}
\hypertarget{classCacheMemory_a6d06da3f5d70180680054f20a4862051}{
\index{CacheMemory@{CacheMemory}!m\_\-demand\_\-accesses@{m\_\-demand\_\-accesses}}
\index{m\_\-demand\_\-accesses@{m\_\-demand\_\-accesses}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-demand\_\-accesses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf m\_\-demand\_\-accesses}}}
\label{classCacheMemory_a6d06da3f5d70180680054f20a4862051}
\hypertarget{classCacheMemory_a47c68eff474df127a7e5e36b40965bdc}{
\index{CacheMemory@{CacheMemory}!m\_\-demand\_\-hits@{m\_\-demand\_\-hits}}
\index{m\_\-demand\_\-hits@{m\_\-demand\_\-hits}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-demand\_\-hits}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf m\_\-demand\_\-hits}}}
\label{classCacheMemory_a47c68eff474df127a7e5e36b40965bdc}
\hypertarget{classCacheMemory_a3f24c5bd8e3da8dbb584cf70d3de4f09}{
\index{CacheMemory@{CacheMemory}!m\_\-demand\_\-misses@{m\_\-demand\_\-misses}}
\index{m\_\-demand\_\-misses@{m\_\-demand\_\-misses}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-demand\_\-misses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf m\_\-demand\_\-misses}}}
\label{classCacheMemory_a3f24c5bd8e3da8dbb584cf70d3de4f09}
\hypertarget{classCacheMemory_a5ae5fe863837358e6e9a60e0b702fb94}{
\index{CacheMemory@{CacheMemory}!m\_\-hw\_\-prefetches@{m\_\-hw\_\-prefetches}}
\index{m\_\-hw\_\-prefetches@{m\_\-hw\_\-prefetches}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-hw\_\-prefetches}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf m\_\-hw\_\-prefetches}}}
\label{classCacheMemory_a5ae5fe863837358e6e9a60e0b702fb94}
\hypertarget{classCacheMemory_a0c3e90f32ef2e92b91ca006d44c12374}{
\index{CacheMemory@{CacheMemory}!m\_\-is\_\-instruction\_\-only\_\-cache@{m\_\-is\_\-instruction\_\-only\_\-cache}}
\index{m\_\-is\_\-instruction\_\-only\_\-cache@{m\_\-is\_\-instruction\_\-only\_\-cache}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-is\_\-instruction\_\-only\_\-cache}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf m\_\-is\_\-instruction\_\-only\_\-cache}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_a0c3e90f32ef2e92b91ca006d44c12374}
\hypertarget{classCacheMemory_a7599697a6c831356525c7d97604edd31}{
\index{CacheMemory@{CacheMemory}!m\_\-latency@{m\_\-latency}}
\index{m\_\-latency@{m\_\-latency}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-latency}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf m\_\-latency}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_a7599697a6c831356525c7d97604edd31}
\hypertarget{classCacheMemory_a89cf1f810dd6f5f9da8a2d588418ec49}{
\index{CacheMemory@{CacheMemory}!m\_\-policy@{m\_\-policy}}
\index{m\_\-policy@{m\_\-policy}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-policy}]{\setlength{\rightskip}{0pt plus 5cm}std::string {\bf m\_\-policy}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_a89cf1f810dd6f5f9da8a2d588418ec49}
\hypertarget{classCacheMemory_a549248150d50bed3e4d815869edee7de}{
\index{CacheMemory@{CacheMemory}!m\_\-prefetches@{m\_\-prefetches}}
\index{m\_\-prefetches@{m\_\-prefetches}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-prefetches}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf m\_\-prefetches}}}
\label{classCacheMemory_a549248150d50bed3e4d815869edee7de}
\hypertarget{classCacheMemory_a37cdae2a2fe6c2b1a976cf8b3ae19f18}{
\index{CacheMemory@{CacheMemory}!m\_\-replacementPolicy\_\-ptr@{m\_\-replacementPolicy\_\-ptr}}
\index{m\_\-replacementPolicy\_\-ptr@{m\_\-replacementPolicy\_\-ptr}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-replacementPolicy\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AbstractReplacementPolicy}$\ast$ {\bf m\_\-replacementPolicy\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_a37cdae2a2fe6c2b1a976cf8b3ae19f18}
\hypertarget{classCacheMemory_aa08c2cb7bf60a80e6be95267b1060509}{
\index{CacheMemory@{CacheMemory}!m\_\-resource\_\-stalls@{m\_\-resource\_\-stalls}}
\index{m\_\-resource\_\-stalls@{m\_\-resource\_\-stalls}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-resource\_\-stalls}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf m\_\-resource\_\-stalls}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_aa08c2cb7bf60a80e6be95267b1060509}
\hypertarget{classCacheMemory_ab350a6d3428acab3678b17bbd2d00c4b}{
\index{CacheMemory@{CacheMemory}!m\_\-start\_\-index\_\-bit@{m\_\-start\_\-index\_\-bit}}
\index{m\_\-start\_\-index\_\-bit@{m\_\-start\_\-index\_\-bit}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-start\_\-index\_\-bit}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-start\_\-index\_\-bit}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_ab350a6d3428acab3678b17bbd2d00c4b}
\hypertarget{classCacheMemory_af2b41944a982febf9af12d438f137b87}{
\index{CacheMemory@{CacheMemory}!m\_\-sw\_\-prefetches@{m\_\-sw\_\-prefetches}}
\index{m\_\-sw\_\-prefetches@{m\_\-sw\_\-prefetches}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-sw\_\-prefetches}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf m\_\-sw\_\-prefetches}}}
\label{classCacheMemory_af2b41944a982febf9af12d438f137b87}
\hypertarget{classCacheMemory_a546a29030c6970bfbc1197ae75826bc4}{
\index{CacheMemory@{CacheMemory}!m\_\-tag\_\-index@{m\_\-tag\_\-index}}
\index{m\_\-tag\_\-index@{m\_\-tag\_\-index}!CacheMemory@{CacheMemory}}
\subsubsection[{m\_\-tag\_\-index}]{\setlength{\rightskip}{0pt plus 5cm}m5::hash\_\-map$<${\bf Address}, int$>$ {\bf m\_\-tag\_\-index}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_a546a29030c6970bfbc1197ae75826bc4}
\hypertarget{classCacheMemory_a0f63a1bbaf1dee7c23ab3ac06a80d775}{
\index{CacheMemory@{CacheMemory}!numDataArrayReads@{numDataArrayReads}}
\index{numDataArrayReads@{numDataArrayReads}!CacheMemory@{CacheMemory}}
\subsubsection[{numDataArrayReads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numDataArrayReads}}}
\label{classCacheMemory_a0f63a1bbaf1dee7c23ab3ac06a80d775}
\hypertarget{classCacheMemory_a4034a29f6d2be3493f40aaa13ca6c77a}{
\index{CacheMemory@{CacheMemory}!numDataArrayStalls@{numDataArrayStalls}}
\index{numDataArrayStalls@{numDataArrayStalls}!CacheMemory@{CacheMemory}}
\subsubsection[{numDataArrayStalls}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numDataArrayStalls}}}
\label{classCacheMemory_a4034a29f6d2be3493f40aaa13ca6c77a}
\hypertarget{classCacheMemory_a97557f8d2f957731bdea9fd4537a140e}{
\index{CacheMemory@{CacheMemory}!numDataArrayWrites@{numDataArrayWrites}}
\index{numDataArrayWrites@{numDataArrayWrites}!CacheMemory@{CacheMemory}}
\subsubsection[{numDataArrayWrites}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numDataArrayWrites}}}
\label{classCacheMemory_a97557f8d2f957731bdea9fd4537a140e}
\hypertarget{classCacheMemory_a3e723404e0119a13e13ca25460179249}{
\index{CacheMemory@{CacheMemory}!numTagArrayReads@{numTagArrayReads}}
\index{numTagArrayReads@{numTagArrayReads}!CacheMemory@{CacheMemory}}
\subsubsection[{numTagArrayReads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numTagArrayReads}}}
\label{classCacheMemory_a3e723404e0119a13e13ca25460179249}
\hypertarget{classCacheMemory_aa8cfd5b3d3480062677e2229d8573483}{
\index{CacheMemory@{CacheMemory}!numTagArrayStalls@{numTagArrayStalls}}
\index{numTagArrayStalls@{numTagArrayStalls}!CacheMemory@{CacheMemory}}
\subsubsection[{numTagArrayStalls}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numTagArrayStalls}}}
\label{classCacheMemory_aa8cfd5b3d3480062677e2229d8573483}
\hypertarget{classCacheMemory_a3e43debd337a55436570324681b20000}{
\index{CacheMemory@{CacheMemory}!numTagArrayWrites@{numTagArrayWrites}}
\index{numTagArrayWrites@{numTagArrayWrites}!CacheMemory@{CacheMemory}}
\subsubsection[{numTagArrayWrites}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf numTagArrayWrites}}}
\label{classCacheMemory_a3e43debd337a55436570324681b20000}
\hypertarget{classCacheMemory_a68d742104ef77f83fee4d7832cc873fe}{
\index{CacheMemory@{CacheMemory}!tagArray@{tagArray}}
\index{tagArray@{tagArray}!CacheMemory@{CacheMemory}}
\subsubsection[{tagArray}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BankedArray} {\bf tagArray}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCacheMemory_a68d742104ef77f83fee4d7832cc873fe}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/ruby/system/\hyperlink{CacheMemory_8hh}{CacheMemory.hh}\item 
mem/ruby/system/\hyperlink{CacheMemory_8cc}{CacheMemory.cc}\end{DoxyCompactItemize}
