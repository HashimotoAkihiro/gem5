\hypertarget{namespaceGenericISA}{
\section{ネームスペース GenericISA}
\label{namespaceGenericISA}\index{GenericISA@{GenericISA}}
}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classGenericISA_1_1M5DebugFault}{M5DebugFault}
\item 
class \hyperlink{classGenericISA_1_1M5VarArgsFault}{M5VarArgsFault}
\item 
class \hyperlink{classGenericISA_1_1BasicDecodeCache}{BasicDecodeCache}
\item 
class \hyperlink{classGenericISA_1_1PCStateBase}{PCStateBase}
\item 
class \hyperlink{classGenericISA_1_1SimplePCState}{SimplePCState}
\item 
class \hyperlink{classGenericISA_1_1UPCState}{UPCState}
\item 
class \hyperlink{classGenericISA_1_1DelaySlotPCState}{DelaySlotPCState}
\item 
class \hyperlink{classGenericISA_1_1DelaySlotUPCState}{DelaySlotUPCState}
\end{DoxyCompactItemize}
\subsection*{型定義}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classGenericISA_1_1M5VarArgsFault}{M5VarArgsFault}$<$ M5DebugFault::PanicFunc $>$ \hyperlink{namespaceGenericISA_a3427cc78f489a7ee730b871fcb4c1960}{M5PanicFault}
\item 
typedef \hyperlink{classGenericISA_1_1M5VarArgsFault}{M5VarArgsFault}$<$ M5DebugFault::FatalFunc $>$ \hyperlink{namespaceGenericISA_a7eadd3e78154f25c430d19d74ac7eb0c}{M5FatalFault}
\item 
typedef \hyperlink{classGenericISA_1_1M5VarArgsFault}{M5VarArgsFault}$<$ M5DebugFault::WarnFunc $>$ \hyperlink{namespaceGenericISA_ad2999c164328ac8e86d95c538d694132}{M5WarnFault}
\item 
typedef \hyperlink{classGenericISA_1_1M5VarArgsFault}{M5VarArgsFault}$<$ M5DebugFault::WarnOnceFunc $>$ \hyperlink{namespaceGenericISA_ae33236ed5f8a96d7a8c02ad15024384a}{M5WarnOnceFault}
\end{DoxyCompactItemize}
\subsection*{関数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{namespaceGenericISA_a79a8335aadefb64d22e7fc06ac063ad0}{iprAddressPseudoInst} (uint8\_\-t func, uint8\_\-t subfunc)
\item 
bool \hyperlink{namespaceGenericISA_a5570d3282731abc7bd1318962834300e}{isGenericIprAccess} (const \hyperlink{classPacket}{Packet} $\ast$pkt)
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{namespaceGenericISA_ac1de480955fd7b1b8b658e4faaece886}{handleGenericIprRead} (\hyperlink{classThreadContext}{ThreadContext} $\ast$xc, \hyperlink{classPacket}{Packet} $\ast$pkt)
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{namespaceGenericISA_a1412c2f2794674f9be65d92b5b0f0b18}{handleGenericIprWrite} (\hyperlink{classThreadContext}{ThreadContext} $\ast$xc, \hyperlink{classPacket}{Packet} $\ast$pkt)
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{namespaceGenericISA_a0b95fcdc1e1fe57dbb4fcad449a6efd8}{handleIprRead} (\hyperlink{classThreadContext}{ThreadContext} $\ast$xc, \hyperlink{classPacket}{Packet} $\ast$pkt)
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{namespaceGenericISA_a31c83a2af3232333d9a399a2878dc729}{handleIprWrite} (\hyperlink{classThreadContext}{ThreadContext} $\ast$xc, \hyperlink{classPacket}{Packet} $\ast$pkt)
\item 
{\footnotesize template$<$class MachInst $>$ }\\std::ostream \& \hyperlink{namespaceGenericISA_a960fce0270870fc775ac34cc401036ba}{operator$<$$<$} (std::ostream \&os, const \hyperlink{classGenericISA_1_1SimplePCState}{SimplePCState}$<$ MachInst $>$ \&pc)
\item 
{\footnotesize template$<$class MachInst $>$ }\\std::ostream \& \hyperlink{namespaceGenericISA_ad7647a2fd4c0b3a52c3039868605af36}{operator$<$$<$} (std::ostream \&os, const \hyperlink{classGenericISA_1_1UPCState}{UPCState}$<$ MachInst $>$ \&pc)
\item 
{\footnotesize template$<$class MachInst $>$ }\\std::ostream \& \hyperlink{namespaceGenericISA_a1ee53cba61e057cc025be65f71694001}{operator$<$$<$} (std::ostream \&os, const \hyperlink{classGenericISA_1_1DelaySlotPCState}{DelaySlotPCState}$<$ MachInst $>$ \&pc)
\item 
{\footnotesize template$<$class MachInst $>$ }\\std::ostream \& \hyperlink{namespaceGenericISA_a07062a2b0f755aa5b023fb796d2dceed}{operator$<$$<$} (std::ostream \&os, const \hyperlink{classGenericISA_1_1DelaySlotUPCState}{DelaySlotUPCState}$<$ MachInst $>$ \&pc)
\end{DoxyCompactItemize}
\subsection*{変数}
\begin{Indent}{\bf }\par
{\em \label{_amgrpd41d8cd98f00b204e9800998ecf8427e}
 }\begin{DoxyCompactItemize}
\item 
const int \hyperlink{namespaceGenericISA_aeb17d164394fbbccc6ef6992f36e9a74}{IPR\_\-CLASS\_\-SHIFT} = 48
\item 
const \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{namespaceGenericISA_ada17fbe3666ca6de3621618e5abf7791}{IPR\_\-IN\_\-CLASS\_\-MASK} = ULL(0x0000FFFFFFFFFFFF)
\item 
const \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{namespaceGenericISA_a7691200ba0d3fea3d1bfdc555efb9b76}{IPR\_\-CLASS\_\-PSEUDO\_\-INST} = 0x0
\end{DoxyCompactItemize}
\end{Indent}


\subsection{型定義}
\hypertarget{namespaceGenericISA_a7eadd3e78154f25c430d19d74ac7eb0c}{
\index{GenericISA@{GenericISA}!M5FatalFault@{M5FatalFault}}
\index{M5FatalFault@{M5FatalFault}!GenericISA@{GenericISA}}
\subsubsection[{M5FatalFault}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf M5VarArgsFault}$<$M5DebugFault::FatalFunc$>$ {\bf M5FatalFault}}}
\label{namespaceGenericISA_a7eadd3e78154f25c430d19d74ac7eb0c}
\hypertarget{namespaceGenericISA_a3427cc78f489a7ee730b871fcb4c1960}{
\index{GenericISA@{GenericISA}!M5PanicFault@{M5PanicFault}}
\index{M5PanicFault@{M5PanicFault}!GenericISA@{GenericISA}}
\subsubsection[{M5PanicFault}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf M5VarArgsFault}$<$M5DebugFault::PanicFunc$>$ {\bf M5PanicFault}}}
\label{namespaceGenericISA_a3427cc78f489a7ee730b871fcb4c1960}
\hypertarget{namespaceGenericISA_ad2999c164328ac8e86d95c538d694132}{
\index{GenericISA@{GenericISA}!M5WarnFault@{M5WarnFault}}
\index{M5WarnFault@{M5WarnFault}!GenericISA@{GenericISA}}
\subsubsection[{M5WarnFault}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf M5VarArgsFault}$<$M5DebugFault::WarnFunc$>$ {\bf M5WarnFault}}}
\label{namespaceGenericISA_ad2999c164328ac8e86d95c538d694132}
\hypertarget{namespaceGenericISA_ae33236ed5f8a96d7a8c02ad15024384a}{
\index{GenericISA@{GenericISA}!M5WarnOnceFault@{M5WarnOnceFault}}
\index{M5WarnOnceFault@{M5WarnOnceFault}!GenericISA@{GenericISA}}
\subsubsection[{M5WarnOnceFault}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf M5VarArgsFault}$<$M5DebugFault::WarnOnceFunc$>$ {\bf M5WarnOnceFault}}}
\label{namespaceGenericISA_ae33236ed5f8a96d7a8c02ad15024384a}


\subsection{関数}
\hypertarget{namespaceGenericISA_ac1de480955fd7b1b8b658e4faaece886}{
\index{GenericISA@{GenericISA}!handleGenericIprRead@{handleGenericIprRead}}
\index{handleGenericIprRead@{handleGenericIprRead}!GenericISA@{GenericISA}}
\subsubsection[{handleGenericIprRead}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} handleGenericIprRead ({\bf ThreadContext} $\ast$ {\em xc}, \/  {\bf Packet} $\ast$ {\em pkt})}}
\label{namespaceGenericISA_ac1de480955fd7b1b8b658e4faaece886}
Handle generic IPR reads


\begin{DoxyParams}{引数}
\item[{\em xc}]Thread context of the current thread. \item[{\em pkt}]\hyperlink{classPacket}{Packet} from the CPU \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Latency in CPU cycles 
\end{DoxyReturn}



\begin{DoxyCode}
54 {
55     Addr va(pkt->getAddr());
56     Addr cls(va >> IPR_CLASS_SHIFT);
57 
58     switch (cls) {
59     case IPR_CLASS_PSEUDO_INST:
60         handlePseudoInst(xc, pkt);
61         break;
62     default:
63         panic("Unhandled generic IPR read: 0x%x\n", va);
64     }
65 
66     return Cycles(1);
67 }
\end{DoxyCode}
\hypertarget{namespaceGenericISA_a1412c2f2794674f9be65d92b5b0f0b18}{
\index{GenericISA@{GenericISA}!handleGenericIprWrite@{handleGenericIprWrite}}
\index{handleGenericIprWrite@{handleGenericIprWrite}!GenericISA@{GenericISA}}
\subsubsection[{handleGenericIprWrite}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} handleGenericIprWrite ({\bf ThreadContext} $\ast$ {\em xc}, \/  {\bf Packet} $\ast$ {\em pkt})}}
\label{namespaceGenericISA_a1412c2f2794674f9be65d92b5b0f0b18}
Handle generic IPR writes


\begin{DoxyParams}{引数}
\item[{\em xc}]Thread context of the current thread. \item[{\em pkt}]\hyperlink{classPacket}{Packet} from the CPU \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Latency in CPU cycles 
\end{DoxyReturn}



\begin{DoxyCode}
71 {
72     Addr va(pkt->getAddr());
73     Addr cls(va >> IPR_CLASS_SHIFT);
74 
75     switch (cls) {
76     case IPR_CLASS_PSEUDO_INST:
77         handlePseudoInst(xc, pkt);
78         break;
79     default:
80         panic("Unhandled generic IPR write: 0x%x\n", va);
81     }
82 
83     return Cycles(1);
84 }
\end{DoxyCode}
\hypertarget{namespaceGenericISA_a0b95fcdc1e1fe57dbb4fcad449a6efd8}{
\index{GenericISA@{GenericISA}!handleIprRead@{handleIprRead}}
\index{handleIprRead@{handleIprRead}!GenericISA@{GenericISA}}
\subsubsection[{handleIprRead}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} GenericISA::handleIprRead ({\bf ThreadContext} $\ast$ {\em xc}, \/  {\bf Packet} $\ast$ {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespaceGenericISA_a0b95fcdc1e1fe57dbb4fcad449a6efd8}
Helper function to handle IPRs when the target architecture doesn't need its own IPR handling.

This function calls handleGenericIprRead if the accessing a generic IPR and panics otherwise.


\begin{DoxyParams}{引数}
\item[{\em xc}]Thread context of the current thread. \item[{\em pkt}]\hyperlink{classPacket}{Packet} from the CPU \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Latency in CPU cycles 
\end{DoxyReturn}



\begin{DoxyCode}
140     {
141         if (!isGenericIprAccess(pkt))
142             panic("Unhandled IPR access\n");
143 
144         return handleGenericIprRead(xc, pkt);
145     }
\end{DoxyCode}
\hypertarget{namespaceGenericISA_a31c83a2af3232333d9a399a2878dc729}{
\index{GenericISA@{GenericISA}!handleIprWrite@{handleIprWrite}}
\index{handleIprWrite@{handleIprWrite}!GenericISA@{GenericISA}}
\subsubsection[{handleIprWrite}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} GenericISA::handleIprWrite ({\bf ThreadContext} $\ast$ {\em xc}, \/  {\bf Packet} $\ast$ {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespaceGenericISA_a31c83a2af3232333d9a399a2878dc729}
Helper function to handle IPRs when the target architecture doesn't need its own IPR handling.

This function calls handleGenericIprWrite if the accessing a generic IPR and panics otherwise.


\begin{DoxyParams}{引数}
\item[{\em xc}]Thread context of the current thread. \item[{\em pkt}]\hyperlink{classPacket}{Packet} from the CPU \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Latency in CPU cycles 
\end{DoxyReturn}



\begin{DoxyCode}
161     {
162         if (!isGenericIprAccess(pkt))
163             panic("Unhandled IPR access\n");
164 
165         return handleGenericIprWrite(xc, pkt);
166     }
\end{DoxyCode}
\hypertarget{namespaceGenericISA_a79a8335aadefb64d22e7fc06ac063ad0}{
\index{GenericISA@{GenericISA}!iprAddressPseudoInst@{iprAddressPseudoInst}}
\index{iprAddressPseudoInst@{iprAddressPseudoInst}!GenericISA@{GenericISA}}
\subsubsection[{iprAddressPseudoInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} GenericISA::iprAddressPseudoInst (uint8\_\-t {\em func}, \/  uint8\_\-t {\em subfunc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespaceGenericISA_a79a8335aadefb64d22e7fc06ac063ad0}
Generate a generic IPR address that emulates a pseudo inst

\begin{DoxySeeAlso}{参照}
\hyperlink{namespacePseudoInst_a469ba8e314952a0076e086dee22ea6de}{PseudoInst::pseudoInst()}
\end{DoxySeeAlso}

\begin{DoxyParams}{引数}
\item[{\em func}]Function ID to call. \item[{\em subfunc}]Sub-\/function, usually 0. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
\hyperlink{classAddress}{Address} in the IPR space corresponding to the call. 
\end{DoxyReturn}



\begin{DoxyCode}
85     {
86         return (IPR_CLASS_PSEUDO_INST << IPR_CLASS_SHIFT)  |
87             (func << 8) | subfunc;
88     }
\end{DoxyCode}
\hypertarget{namespaceGenericISA_a5570d3282731abc7bd1318962834300e}{
\index{GenericISA@{GenericISA}!isGenericIprAccess@{isGenericIprAccess}}
\index{isGenericIprAccess@{isGenericIprAccess}!GenericISA@{GenericISA}}
\subsubsection[{isGenericIprAccess}]{\setlength{\rightskip}{0pt plus 5cm}bool GenericISA::isGenericIprAccess (const {\bf Packet} $\ast$ {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespaceGenericISA_a5570d3282731abc7bd1318962834300e}
\hyperlink{classCheck}{Check} if this is an platform independent IPR access

Accesses to internal platform independent gem5 registers are handled by \hyperlink{namespaceGenericISA_ac1de480955fd7b1b8b658e4faaece886}{handleGenericIprRead()} and \hyperlink{namespaceGenericISA_a1412c2f2794674f9be65d92b5b0f0b18}{handleGenericIprWrite()}. This method determines if a packet should be routed to those functions instead of the platform specific code.

\begin{DoxySeeAlso}{参照}
\hyperlink{namespaceGenericISA_ac1de480955fd7b1b8b658e4faaece886}{handleGenericIprRead} 

\hyperlink{namespaceGenericISA_a1412c2f2794674f9be65d92b5b0f0b18}{handleGenericIprWrite} 
\end{DoxySeeAlso}



\begin{DoxyCode}
104     {
105         Request::Flags flags(pkt->req->getFlags());
106         return (flags & Request::MMAPPED_IPR) &&
107             (flags & Request::GENERIC_IPR);
108     }
\end{DoxyCode}
\hypertarget{namespaceGenericISA_a07062a2b0f755aa5b023fb796d2dceed}{
\index{GenericISA@{GenericISA}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!GenericISA@{GenericISA}}
\subsubsection[{operator$<$$<$}]{\setlength{\rightskip}{0pt plus 5cm}std::ostream\& GenericISA::operator$<$$<$ (std::ostream \& {\em os}, \/  const DelaySlotUPCState$<$ MachInst $>$ \& {\em pc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespaceGenericISA_a07062a2b0f755aa5b023fb796d2dceed}



\begin{DoxyCode}
448 {
449     ccprintf(os, "(%#x=>%#x=>%#x).(%d=>%d)",
450             pc.pc(), pc.npc(), pc.nnpc(), pc.upc(), pc.nupc());
451     return os;
452 }
\end{DoxyCode}
\hypertarget{namespaceGenericISA_a1ee53cba61e057cc025be65f71694001}{
\index{GenericISA@{GenericISA}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!GenericISA@{GenericISA}}
\subsubsection[{operator$<$$<$}]{\setlength{\rightskip}{0pt plus 5cm}std::ostream\& GenericISA::operator$<$$<$ (std::ostream \& {\em os}, \/  const DelaySlotPCState$<$ MachInst $>$ \& {\em pc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespaceGenericISA_a1ee53cba61e057cc025be65f71694001}



\begin{DoxyCode}
349 {
350     ccprintf(os, "(%#x=>%#x=>%#x)",
351             pc.pc(), pc.npc(), pc.nnpc());
352     return os;
353 }
\end{DoxyCode}
\hypertarget{namespaceGenericISA_ad7647a2fd4c0b3a52c3039868605af36}{
\index{GenericISA@{GenericISA}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!GenericISA@{GenericISA}}
\subsubsection[{operator$<$$<$}]{\setlength{\rightskip}{0pt plus 5cm}std::ostream\& GenericISA::operator$<$$<$ (std::ostream \& {\em os}, \/  const UPCState$<$ MachInst $>$ \& {\em pc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespaceGenericISA_ad7647a2fd4c0b3a52c3039868605af36}



\begin{DoxyCode}
270 {
271     ccprintf(os, "(%#x=>%#x).(%d=>%d)",
272             pc.pc(), pc.npc(), pc.upc(), pc.nupc());
273     return os;
274 }
\end{DoxyCode}
\hypertarget{namespaceGenericISA_a960fce0270870fc775ac34cc401036ba}{
\index{GenericISA@{GenericISA}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!GenericISA@{GenericISA}}
\subsubsection[{operator$<$$<$}]{\setlength{\rightskip}{0pt plus 5cm}std::ostream\& GenericISA::operator$<$$<$ (std::ostream \& {\em os}, \/  const SimplePCState$<$ MachInst $>$ \& {\em pc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespaceGenericISA_a960fce0270870fc775ac34cc401036ba}



\begin{DoxyCode}
172 {
173     ccprintf(os, "(%#x=>%#x)", pc.pc(), pc.npc());
174     return os;
175 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{namespaceGenericISA_a7691200ba0d3fea3d1bfdc555efb9b76}{
\index{GenericISA@{GenericISA}!IPR\_\-CLASS\_\-PSEUDO\_\-INST@{IPR\_\-CLASS\_\-PSEUDO\_\-INST}}
\index{IPR\_\-CLASS\_\-PSEUDO\_\-INST@{IPR\_\-CLASS\_\-PSEUDO\_\-INST}!GenericISA@{GenericISA}}
\subsubsection[{IPR\_\-CLASS\_\-PSEUDO\_\-INST}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Addr} {\bf IPR\_\-CLASS\_\-PSEUDO\_\-INST} = 0x0}}
\label{namespaceGenericISA_a7691200ba0d3fea3d1bfdc555efb9b76}
gem5 pseudo-\/inst emulation.

Read and writes to this class execute gem5 pseudo-\/instructions. A write discards the return value of the instruction, while a read returns it.

\begin{DoxySeeAlso}{参照}
\hyperlink{namespacePseudoInst_a469ba8e314952a0076e086dee22ea6de}{pseudoInst()} 
\end{DoxySeeAlso}
\hypertarget{namespaceGenericISA_aeb17d164394fbbccc6ef6992f36e9a74}{
\index{GenericISA@{GenericISA}!IPR\_\-CLASS\_\-SHIFT@{IPR\_\-CLASS\_\-SHIFT}}
\index{IPR\_\-CLASS\_\-SHIFT@{IPR\_\-CLASS\_\-SHIFT}!GenericISA@{GenericISA}}
\subsubsection[{IPR\_\-CLASS\_\-SHIFT}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf IPR\_\-CLASS\_\-SHIFT} = 48}}
\label{namespaceGenericISA_aeb17d164394fbbccc6ef6992f36e9a74}
Memory requests with the MMAPPED\_\-IPR flag are generally mapped to registers. There is a class of these registers that are internal to gem5, for example gem5 pseudo-\/ops in virtualized mode. Such IPRs always have the flag GENERIC\_\-IPR set and are handled by this code. Shift amount when extracting the class of a generic IPR \hypertarget{namespaceGenericISA_ada17fbe3666ca6de3621618e5abf7791}{
\index{GenericISA@{GenericISA}!IPR\_\-IN\_\-CLASS\_\-MASK@{IPR\_\-IN\_\-CLASS\_\-MASK}}
\index{IPR\_\-IN\_\-CLASS\_\-MASK@{IPR\_\-IN\_\-CLASS\_\-MASK}!GenericISA@{GenericISA}}
\subsubsection[{IPR\_\-IN\_\-CLASS\_\-MASK}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Addr} {\bf IPR\_\-IN\_\-CLASS\_\-MASK} = ULL(0x0000FFFFFFFFFFFF)}}
\label{namespaceGenericISA_ada17fbe3666ca6de3621618e5abf7791}
Mask to extract the offset in within a generic IPR class 