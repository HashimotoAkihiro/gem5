\hypertarget{classRegDepMap}{
\section{クラス RegDepMap}
\label{classRegDepMap}\index{RegDepMap@{RegDepMap}}
}


{\ttfamily \#include $<$reg\_\-dep\_\-map.hh$>$}\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classRefCountingPtr}{ThePipeline::DynInstPtr} \hyperlink{classRegDepMap_af9d0c8a46736ba6aa2d8bb94da1a5e73}{DynInstPtr}
\item 
typedef TheISA::RegIndex \hyperlink{classRegDepMap_a36d25e03e43fa3bb4c5482cbefe5e0fb}{RegIndex}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classRegDepMap_a740eadbb74c2858768d7fa7e32e5cafb}{RegDepMap} (int size=TheISA::TotalNumRegs)
\item 
\hyperlink{classRegDepMap_abdbd8b917a4492cf43256c3962f97cb3}{$\sim$RegDepMap} ()
\item 
std::string \hyperlink{classRegDepMap_aa62b508d2c0e7d9cec12924965276eb5}{name} ()
\item 
void \hyperlink{classRegDepMap_ad9f94f552b2c6a5daf605771891e76e7}{setCPU} (\hyperlink{classInOrderCPU}{InOrderCPU} $\ast$\_\-cpu)
\item 
void \hyperlink{classRegDepMap_ac8bb3912a3ce86b15842e79d0b421204}{clear} ()
\item 
void \hyperlink{classRegDepMap_ae55039f80e321715cf410a62b39d069c}{insert} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
void \hyperlink{classRegDepMap_a21558187a079b60fba92c9c66725f051}{remove} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
void \hyperlink{classRegDepMap_a40cf3c335b8ecc0c33de75fe822f25f7}{removeFront} (uint8\_\-t reg\_\-type, \hyperlink{classRegDepMap_a36d25e03e43fa3bb4c5482cbefe5e0fb}{RegIndex} idx, \hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
bool \hyperlink{classRegDepMap_ae8b9c354b5aeebf986113ee06b6284bd}{canRead} (uint8\_\-t reg\_\-type, \hyperlink{classRegDepMap_a36d25e03e43fa3bb4c5482cbefe5e0fb}{RegIndex} idx, \hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
\hyperlink{classRefCountingPtr}{DynInstPtr} \hyperlink{classRegDepMap_a700524c6365911232dd3afe88da67f0a}{canForward} (uint8\_\-t reg\_\-type, unsigned reg\_\-idx, \hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
\hyperlink{classRefCountingPtr}{DynInstPtr} \hyperlink{classRegDepMap_a7f3dc7ca520ca37039329e5a63b2594a}{findBypassInst} (\hyperlink{classRegDepMap_a36d25e03e43fa3bb4c5482cbefe5e0fb}{RegIndex} idx)
\item 
bool \hyperlink{classRegDepMap_a461ac3944ef0b39fb9ef9eb94421ea84}{canWrite} (uint8\_\-t reg\_\-type, \hyperlink{classRegDepMap_a36d25e03e43fa3bb4c5482cbefe5e0fb}{RegIndex} idx, \hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
int \hyperlink{classRegDepMap_ab532dbca982a8cc2a418fdc6e36d3d87}{depSize} (\hyperlink{classRegDepMap_a36d25e03e43fa3bb4c5482cbefe5e0fb}{RegIndex} idx)
\item 
void \hyperlink{classRegDepMap_accd2600060dbaee3a3b41aed4034c63c}{dump} ()
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classRefCountingPtr}{DynInstPtr} $>$ $>$ \hyperlink{classRegDepMap_ac2db38d9150d8b1c9c69bc4f6482a415}{DepMap}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classRegDepMap_a0044f4c5dc6146067ba193f8fe6f8842}{insert} (uint8\_\-t reg\_\-type, \hyperlink{classRegDepMap_a36d25e03e43fa3bb4c5482cbefe5e0fb}{RegIndex} idx, \hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
void \hyperlink{classRegDepMap_a87e98fee344305ed226f0e12e43f482b}{remove} (uint8\_\-t reg\_\-type, \hyperlink{classRegDepMap_a36d25e03e43fa3bb4c5482cbefe5e0fb}{RegIndex} idx, \hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classstd_1_1vector}{DepMap} $>$ \hyperlink{classRegDepMap_aa6afa28f783151687606a9895fb15789}{regMap}
\item 
\hyperlink{classInOrderCPU}{InOrderCPU} $\ast$ \hyperlink{classRegDepMap_a41d682c28d0f49e04393c52815808782}{cpu}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classRegDepMap_ac2db38d9150d8b1c9c69bc4f6482a415}{
\index{RegDepMap@{RegDepMap}!DepMap@{DepMap}}
\index{DepMap@{DepMap}!RegDepMap@{RegDepMap}}
\subsubsection[{DepMap}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::vector}$<${\bf std::list}$<${\bf DynInstPtr}$>$ $>$ {\bf DepMap}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRegDepMap_ac2db38d9150d8b1c9c69bc4f6482a415}
\hypertarget{classRegDepMap_af9d0c8a46736ba6aa2d8bb94da1a5e73}{
\index{RegDepMap@{RegDepMap}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!RegDepMap@{RegDepMap}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf ThePipeline::DynInstPtr} {\bf DynInstPtr}}}
\label{classRegDepMap_af9d0c8a46736ba6aa2d8bb94da1a5e73}
\hypertarget{classRegDepMap_a36d25e03e43fa3bb4c5482cbefe5e0fb}{
\index{RegDepMap@{RegDepMap}!RegIndex@{RegIndex}}
\index{RegIndex@{RegIndex}!RegDepMap@{RegDepMap}}
\subsubsection[{RegIndex}]{\setlength{\rightskip}{0pt plus 5cm}typedef TheISA::RegIndex {\bf RegIndex}}}
\label{classRegDepMap_a36d25e03e43fa3bb4c5482cbefe5e0fb}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classRegDepMap_a740eadbb74c2858768d7fa7e32e5cafb}{
\index{RegDepMap@{RegDepMap}!RegDepMap@{RegDepMap}}
\index{RegDepMap@{RegDepMap}!RegDepMap@{RegDepMap}}
\subsubsection[{RegDepMap}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RegDepMap} (int {\em size} = {\ttfamily TheISA::TotalNumRegs})}}
\label{classRegDepMap_a740eadbb74c2858768d7fa7e32e5cafb}



\begin{DoxyCode}
46 {
47     regMap.resize(NumRegClasses);
48     regMap[IntRegClass].resize(NumIntRegs);
49     regMap[FloatRegClass].resize(NumFloatRegs);
50     regMap[MiscRegClass].resize(NumMiscRegs);
51 }
\end{DoxyCode}
\hypertarget{classRegDepMap_abdbd8b917a4492cf43256c3962f97cb3}{
\index{RegDepMap@{RegDepMap}!$\sim$RegDepMap@{$\sim$RegDepMap}}
\index{$\sim$RegDepMap@{$\sim$RegDepMap}!RegDepMap@{RegDepMap}}
\subsubsection[{$\sim$RegDepMap}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf RegDepMap} ()}}
\label{classRegDepMap_abdbd8b917a4492cf43256c3962f97cb3}



\begin{DoxyCode}
54 {
55     clear();
56 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classRegDepMap_a700524c6365911232dd3afe88da67f0a}{
\index{RegDepMap@{RegDepMap}!canForward@{canForward}}
\index{canForward@{canForward}!RegDepMap@{RegDepMap}}
\subsubsection[{canForward}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThePipeline::DynInstPtr} canForward (uint8\_\-t {\em reg\_\-type}, \/  unsigned {\em reg\_\-idx}, \/  {\bf DynInstPtr} {\em inst})}}
\label{classRegDepMap_a700524c6365911232dd3afe88da67f0a}
Is the current instruction able to get a forwarded value from another instruction for this destination register? 


\begin{DoxyCode}
218 {
219     std::list<DynInstPtr>::iterator list_it = regMap[reg_type][reg_idx].begin();
220     std::list<DynInstPtr>::iterator list_end = regMap[reg_type][reg_idx].end();
221 
222     DynInstPtr forward_inst = NULL;
223 
224     // Look for instruction immediately in front of requestor to supply
225     // data
226     while (list_it != list_end &&
227            (*list_it)->seqNum < inst->seqNum) {
228         forward_inst = (*list_it);
229         list_it++;
230     }
231 
232     if (forward_inst) {
233         int dest_reg_idx = forward_inst->getDestIdxNum(reg_idx);
234         assert(dest_reg_idx != -1);
235 
236         DPRINTF(RegDepMap, "[sn:%i] Found potential forwarding value for reg %i "
      
237                 " w/ [sn:%i] dest. reg. #%i\n",
238                 inst->seqNum, reg_idx, forward_inst->seqNum, dest_reg_idx);
239 
240         if (forward_inst->isExecuted() &&
241             forward_inst->readResultTime(dest_reg_idx) < curTick()) {
242             return forward_inst;
243         } else {
244             if (!forward_inst->isExecuted()) {
245                 DPRINTF(RegDepMap, "[sn:%i] Can't get value through "
246                         "forwarding, [sn:%i] %s has not been executed yet.\n",
247                         inst->seqNum, forward_inst->seqNum, forward_inst->instNam
      e());
248             } else if (forward_inst->readResultTime(dest_reg_idx) >= curTick()) {
      
249                 DPRINTF(RegDepMap, "[sn:%i] Can't get value through "
250                         "forwarding, [sn:%i] executed on tick:%i.\n",
251                         inst->seqNum, forward_inst->seqNum,
252                         forward_inst->readResultTime(dest_reg_idx));
253             }
254 
255             return NULL;
256         }
257     } else {
258         DPRINTF(RegDepMap, "[sn:%i] No instruction found to forward from.\n",
259                 inst->seqNum);
260         return NULL;
261     }
262 }
\end{DoxyCode}
\hypertarget{classRegDepMap_ae8b9c354b5aeebf986113ee06b6284bd}{
\index{RegDepMap@{RegDepMap}!canRead@{canRead}}
\index{canRead@{canRead}!RegDepMap@{RegDepMap}}
\subsubsection[{canRead}]{\setlength{\rightskip}{0pt plus 5cm}bool canRead (uint8\_\-t {\em reg\_\-type}, \/  {\bf RegIndex} {\em idx}, \/  {\bf DynInstPtr} {\em inst})}}
\label{classRegDepMap_ae8b9c354b5aeebf986113ee06b6284bd}
Is the current instruction able to read from this destination register? 


\begin{DoxyCode}
200 {
201     if (regMap[reg_type][idx].size() == 0)
202         return true;
203 
204     std::list<DynInstPtr>::iterator list_it = regMap[reg_type][idx].begin();
205 
206     if (inst->seqNum <= (*list_it)->seqNum) {
207         return true;
208     } else {
209         DPRINTF(RegDepMap, "[sn:%i] Can't read from RegFile, [sn:%i] has "
210                 "not written it's value back yet.\n",
211                 inst->seqNum, (*list_it)->seqNum);
212         return false;
213     }
214 }
\end{DoxyCode}
\hypertarget{classRegDepMap_a461ac3944ef0b39fb9ef9eb94421ea84}{
\index{RegDepMap@{RegDepMap}!canWrite@{canWrite}}
\index{canWrite@{canWrite}!RegDepMap@{RegDepMap}}
\subsubsection[{canWrite}]{\setlength{\rightskip}{0pt plus 5cm}bool canWrite (uint8\_\-t {\em reg\_\-type}, \/  {\bf RegIndex} {\em idx}, \/  {\bf DynInstPtr} {\em inst})}}
\label{classRegDepMap_a461ac3944ef0b39fb9ef9eb94421ea84}
Is the current instruction able to write to this destination register? 


\begin{DoxyCode}
266 {
267     if (regMap[reg_type][idx].size() == 0)
268         return true;
269 
270     std::list<DynInstPtr>::iterator list_it = regMap[reg_type][idx].begin();
271 
272     if (inst->seqNum <= (*list_it)->seqNum) {
273         return true;
274     } else {
275         DPRINTF(RegDepMap, "[sn:%i] Can't write from RegFile: [sn:%i] "
276                 "has not written it's value back yet.\n", inst->seqNum,
277                 (*list_it)->seqNum);
278     }
279 
280     return false;
281 }
\end{DoxyCode}
\hypertarget{classRegDepMap_ac8bb3912a3ce86b15842e79d0b421204}{
\index{RegDepMap@{RegDepMap}!clear@{clear}}
\index{clear@{clear}!RegDepMap@{RegDepMap}}
\subsubsection[{clear}]{\setlength{\rightskip}{0pt plus 5cm}void clear ()}}
\label{classRegDepMap_ac8bb3912a3ce86b15842e79d0b421204}
Clear the Entire Map 


\begin{DoxyCode}
73 {
74     for (int i = 0; i < regMap.size(); i++) {
75         for (int j = 0; j < regMap[j].size(); j++)
76             regMap[i][j].clear();
77         regMap[i].clear();
78     }
79     regMap.clear();
80 }
\end{DoxyCode}
\hypertarget{classRegDepMap_ab532dbca982a8cc2a418fdc6e36d3d87}{
\index{RegDepMap@{RegDepMap}!depSize@{depSize}}
\index{depSize@{depSize}!RegDepMap@{RegDepMap}}
\subsubsection[{depSize}]{\setlength{\rightskip}{0pt plus 5cm}int depSize ({\bf RegIndex} {\em idx})}}
\label{classRegDepMap_ab532dbca982a8cc2a418fdc6e36d3d87}
Size of Dependency of Map \hypertarget{classRegDepMap_accd2600060dbaee3a3b41aed4034c63c}{
\index{RegDepMap@{RegDepMap}!dump@{dump}}
\index{dump@{dump}!RegDepMap@{RegDepMap}}
\subsubsection[{dump}]{\setlength{\rightskip}{0pt plus 5cm}void dump ()}}
\label{classRegDepMap_accd2600060dbaee3a3b41aed4034c63c}



\begin{DoxyCode}
285 {
286     for (int reg_type = 0; reg_type < NumRegClasses; reg_type++) {
287         for (int idx=0; idx < regMap.size(); idx++) {
288             if (regMap[idx].size() > 0) {
289                 cprintf("Reg #%i (size:%i): ", idx, regMap[reg_type][idx].size())
      ;
290 
291                 std::list<DynInstPtr>::iterator list_it =
292                     regMap[reg_type][idx].begin();
293                 std::list<DynInstPtr>::iterator list_end =
294                     regMap[reg_type][idx].end();
295 
296                 while (list_it != list_end) {
297                     cprintf("[sn:%i] ", (*list_it)->seqNum);
298                     list_it++;
299                 }
300                 cprintf("\n");
301             }
302         }
303     }    
304 }
\end{DoxyCode}
\hypertarget{classRegDepMap_a7f3dc7ca520ca37039329e5a63b2594a}{
\index{RegDepMap@{RegDepMap}!findBypassInst@{findBypassInst}}
\index{findBypassInst@{findBypassInst}!RegDepMap@{RegDepMap}}
\subsubsection[{findBypassInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} findBypassInst ({\bf RegIndex} {\em idx})}}
\label{classRegDepMap_a7f3dc7ca520ca37039329e5a63b2594a}
find an instruction to forward/bypass a value from \hypertarget{classRegDepMap_a0044f4c5dc6146067ba193f8fe6f8842}{
\index{RegDepMap@{RegDepMap}!insert@{insert}}
\index{insert@{insert}!RegDepMap@{RegDepMap}}
\subsubsection[{insert}]{\setlength{\rightskip}{0pt plus 5cm}void insert (uint8\_\-t {\em reg\_\-type}, \/  {\bf RegIndex} {\em idx}, \/  {\bf DynInstPtr} {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRegDepMap_a0044f4c5dc6146067ba193f8fe6f8842}
Insert an instruction into a specific destination register index onto map. 


\begin{DoxyCode}
119 {
120     DPRINTF(RegDepMap, "Inserting [sn:%i] onto %s dep. list for "
121             "reg. idx %i.\n", inst->seqNum, RegClassStrings[reg_type],
122             idx);
123 
124     regMap[reg_type][idx].push_back(inst);
125 
126     inst->setRegDepEntry();
127 }
\end{DoxyCode}
\hypertarget{classRegDepMap_ae55039f80e321715cf410a62b39d069c}{
\index{RegDepMap@{RegDepMap}!insert@{insert}}
\index{insert@{insert}!RegDepMap@{RegDepMap}}
\subsubsection[{insert}]{\setlength{\rightskip}{0pt plus 5cm}void insert ({\bf DynInstPtr} {\em inst})}}
\label{classRegDepMap_ae55039f80e321715cf410a62b39d069c}
Insert all of a instruction's destination registers into map 


\begin{DoxyCode}
84 {
85     int dest_regs = inst->numDestRegs();
86 
87     DPRINTF(RegDepMap, "Setting Output Dependencies for [sn:%i] "
88             ", %s (dest. regs = %i).\n",
89             inst->seqNum,
90             inst->instName(),
91             dest_regs);
92 
93     for (int i = 0; i < dest_regs; i++) {
94         RegClass reg_type;
95         TheISA::RegIndex raw_idx = inst->destRegIdx(i);
96         TheISA::RegIndex flat_idx = cpu->flattenRegIdx(raw_idx,
97                                                        reg_type,
98                                                        inst->threadNumber);
99 
100         DPRINTF(RegDepMap, "[sn:%i] #%i flattened %i to %i.\n",
101                 inst->seqNum, i, raw_idx, flat_idx);
102 
103         inst->flattenDestReg(i, flat_idx);
104 
105         if (flat_idx == TheISA::ZeroReg && reg_type == IntRegClass) {
106             DPRINTF(RegDepMap, "[sn:%i]: Ignoring Insert-Dependency tracking for 
      "
107                     "ISA-ZeroReg (Int. Reg %i).\n", inst->seqNum,
108                     flat_idx);
109             continue;
110         }
111 
112         insert(reg_type, flat_idx, inst);
113     }
114 }
\end{DoxyCode}
\hypertarget{classRegDepMap_aa62b508d2c0e7d9cec12924965276eb5}{
\index{RegDepMap@{RegDepMap}!name@{name}}
\index{name@{name}!RegDepMap@{RegDepMap}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}string name ()}}
\label{classRegDepMap_aa62b508d2c0e7d9cec12924965276eb5}



\begin{DoxyCode}
60 {
61     return cpu->name() + ".RegDepMap";
62 }
\end{DoxyCode}
\hypertarget{classRegDepMap_a87e98fee344305ed226f0e12e43f482b}{
\index{RegDepMap@{RegDepMap}!remove@{remove}}
\index{remove@{remove}!RegDepMap@{RegDepMap}}
\subsubsection[{remove}]{\setlength{\rightskip}{0pt plus 5cm}void remove (uint8\_\-t {\em reg\_\-type}, \/  {\bf RegIndex} {\em idx}, \/  {\bf DynInstPtr} {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRegDepMap_a87e98fee344305ed226f0e12e43f482b}
Remove a specific instruction and dest. register index from map 


\begin{DoxyCode}
165 {
166     std::list<DynInstPtr>::iterator list_it = regMap[reg_type][idx].begin();
167     std::list<DynInstPtr>::iterator list_end = regMap[reg_type][idx].end();
168 
169 
170     while (list_it != list_end) {
171         if((*list_it) == inst) {
172             DPRINTF(RegDepMap, "Removing [sn:%i] from %s dep. list for "
173                     "reg. idx %i.\n", inst->seqNum, RegClassStrings[reg_type],
174                     idx);
175             regMap[reg_type][idx].erase(list_it);
176             return;
177         }
178         list_it++;
179     }
180     panic("[sn:%i] Did not find entry for %i, type:%i\n", inst->seqNum, idx, reg_
      type);
181 }
\end{DoxyCode}
\hypertarget{classRegDepMap_a21558187a079b60fba92c9c66725f051}{
\index{RegDepMap@{RegDepMap}!remove@{remove}}
\index{remove@{remove}!RegDepMap@{RegDepMap}}
\subsubsection[{remove}]{\setlength{\rightskip}{0pt plus 5cm}void remove ({\bf DynInstPtr} {\em inst})}}
\label{classRegDepMap_a21558187a079b60fba92c9c66725f051}
Remove all of a instruction's destination registers into map 


\begin{DoxyCode}
131 {
132     if (inst->isRegDepEntry()) {
133         int dest_regs = inst->numDestRegs();
134 
135         DPRINTF(RegDepMap, "Removing [sn:%i]'s entries from reg. dep. map. for "
136                 ", %s (dest. regs = %i).\n",
137                 inst->seqNum,
138                 inst->instName(),
139                 dest_regs);
140 
141 
142         for (int i = 0; i < dest_regs; i++) {
143             RegIndex flat_idx = inst->flattenedDestRegIdx(i);
144             RegClass reg_type = regIdxToClass(inst->destRegIdx(i));
145 
146             // Merge Dyn Inst & CPU Result Types
147             if (flat_idx == TheISA::ZeroReg &&
148                 reg_type == IntRegClass) {
149                 DPRINTF(RegDepMap, "[sn:%i]: Ignoring Remove-Dependency tracking 
      for "
150                         "ISA-ZeroReg (Int. Reg %i).\n", inst->seqNum,
151                         flat_idx);
152                 continue;
153             }
154 
155 
156             remove(reg_type, flat_idx, inst);
157         }
158 
159         inst->clearRegDepEntry();
160     }
161 }
\end{DoxyCode}
\hypertarget{classRegDepMap_a40cf3c335b8ecc0c33de75fe822f25f7}{
\index{RegDepMap@{RegDepMap}!removeFront@{removeFront}}
\index{removeFront@{removeFront}!RegDepMap@{RegDepMap}}
\subsubsection[{removeFront}]{\setlength{\rightskip}{0pt plus 5cm}void removeFront (uint8\_\-t {\em reg\_\-type}, \/  {\bf RegIndex} {\em idx}, \/  {\bf DynInstPtr} {\em inst})}}
\label{classRegDepMap_a40cf3c335b8ecc0c33de75fe822f25f7}
Remove Front instruction from a destination register 


\begin{DoxyCode}
185 {
186    std::list<DynInstPtr>::iterator list_it = regMap[reg_type][idx].begin();
187 
188    DPRINTF(RegDepMap, "[tid:%u]: Removing dependency entry on reg. idx "
189            "%i for [sn:%i].\n", inst->readTid(), idx, inst->seqNum);
190 
191    assert(list_it != regMap[reg_type][idx].end());
192 
193    assert(inst == (*list_it));
194 
195    regMap[reg_type][idx].erase(list_it);
196 }
\end{DoxyCode}
\hypertarget{classRegDepMap_ad9f94f552b2c6a5daf605771891e76e7}{
\index{RegDepMap@{RegDepMap}!setCPU@{setCPU}}
\index{setCPU@{setCPU}!RegDepMap@{RegDepMap}}
\subsubsection[{setCPU}]{\setlength{\rightskip}{0pt plus 5cm}void setCPU ({\bf InOrderCPU} $\ast$ {\em \_\-cpu})}}
\label{classRegDepMap_ad9f94f552b2c6a5daf605771891e76e7}



\begin{DoxyCode}
66 {
67     cpu = _cpu;
68 
69 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classRegDepMap_a41d682c28d0f49e04393c52815808782}{
\index{RegDepMap@{RegDepMap}!cpu@{cpu}}
\index{cpu@{cpu}!RegDepMap@{RegDepMap}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InOrderCPU}$\ast$ {\bf cpu}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRegDepMap_a41d682c28d0f49e04393c52815808782}
\hypertarget{classRegDepMap_aa6afa28f783151687606a9895fb15789}{
\index{RegDepMap@{RegDepMap}!regMap@{regMap}}
\index{regMap@{regMap}!RegDepMap@{RegDepMap}}
\subsubsection[{regMap}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf DepMap}$>$ {\bf regMap}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRegDepMap_aa6afa28f783151687606a9895fb15789}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/inorder/\hyperlink{reg__dep__map_8hh}{reg\_\-dep\_\-map.hh}\item 
cpu/inorder/\hyperlink{reg__dep__map_8cc}{reg\_\-dep\_\-map.cc}\end{DoxyCompactItemize}
