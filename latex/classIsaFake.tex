\hypertarget{classIsaFake}{
\section{クラス IsaFake}
\label{classIsaFake}\index{IsaFake@{IsaFake}}
}


{\ttfamily \#include $<$isa\_\-fake.hh$>$}IsaFakeに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=7cm]{classIsaFake}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef IsaFakeParams \hyperlink{classIsaFake_a9d89a786405f83fe384e7aadc17d5ce2}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
const \hyperlink{classIsaFake_a9d89a786405f83fe384e7aadc17d5ce2}{Params} $\ast$ \hyperlink{classIsaFake_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{classIsaFake_a156ba05e64791b9db37902f932519e30}{IsaFake} (\hyperlink{classIsaFake_a9d89a786405f83fe384e7aadc17d5ce2}{Params} $\ast$p)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIsaFake_a613ec7d5e1ec64f8d21fec78ae8e568e}{read} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIsaFake_a4cefab464e72b5dd42c003a0a4341802}{write} (\hyperlink{classPacket}{PacketPtr} pkt)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
uint8\_\-t \hyperlink{classIsaFake_ab214e69fe2d47c76466577f491122f50}{retData8}
\item 
uint16\_\-t \hyperlink{classIsaFake_a6a50681a9e818e6de256e0b428d031d4}{retData16}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classIsaFake_aff159069c738217f75e3bdf4048b7c20}{retData32}
\item 
uint64\_\-t \hyperlink{classIsaFake_a491508c3b16897f4ff96ef1ea2b2bebc}{retData64}
\end{DoxyCompactItemize}


\subsection{説明}
\hyperlink{classIsaFake}{IsaFake} is a device that returns, BadAddr, 1 or 0 on all reads and rites. It is meant to be placed at an address range so that an mcheck doesn't occur when an os probes a piece of hw that doesn't exist (e.g. UARTs1-\/3), or catch requests in the memory system that have no responders.. 

\subsection{型定義}
\hypertarget{classIsaFake_a9d89a786405f83fe384e7aadc17d5ce2}{
\index{IsaFake@{IsaFake}!Params@{Params}}
\index{Params@{Params}!IsaFake@{IsaFake}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef IsaFakeParams {\bf Params}}}
\label{classIsaFake_a9d89a786405f83fe384e7aadc17d5ce2}


\hyperlink{classBasicPioDevice_a2845515ac6467f10540747053c8a0449}{BasicPioDevice}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classIsaFake_a156ba05e64791b9db37902f932519e30}{
\index{IsaFake@{IsaFake}!IsaFake@{IsaFake}}
\index{IsaFake@{IsaFake}!IsaFake@{IsaFake}}
\subsubsection[{IsaFake}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IsaFake} ({\bf Params} $\ast$ {\em p})}}
\label{classIsaFake_a156ba05e64791b9db37902f932519e30}
The constructor for Isa Fake just registers itself with the MMU. 
\begin{DoxyParams}{引数}
\item[{\em p}]params structure \end{DoxyParams}



\begin{DoxyCode}
45     : BasicPioDevice(p, p->ret_bad_addr ? 0 : p->pio_size)
46 {
47     retData8 = p->ret_data8;
48     retData16 = p->ret_data16;
49     retData32 = p->ret_data32;
50     retData64 = p->ret_data64;
51 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classIsaFake_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{IsaFake@{IsaFake}!params@{params}}
\index{params@{params}!IsaFake@{IsaFake}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classIsaFake_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classBasicPioDevice_acd3c3feb78ae7a8f88fe0f110a718dff}{BasicPioDevice}を再定義しています。


\begin{DoxyCode}
64     {
65         return dynamic_cast<const Params *>(_params);
66     }
\end{DoxyCode}
\hypertarget{classIsaFake_a613ec7d5e1ec64f8d21fec78ae8e568e}{
\index{IsaFake@{IsaFake}!read@{read}}
\index{read@{read}!IsaFake@{IsaFake}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} read ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIsaFake_a613ec7d5e1ec64f8d21fec78ae8e568e}
This read always returns -\/1. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]The memory request. \item[{\em data}]Where to put the data. \end{DoxyParams}


\hyperlink{classPioDevice_a842312590432036092c422c87a442358}{PioDevice}を実装しています。


\begin{DoxyCode}
55 {
56     pkt->allocate();
57     pkt->makeAtomicResponse();
58 
59     if (params()->warn_access != "")
60         warn("Device %s accessed by read to address %#x size=%d\n",
61                 name(), pkt->getAddr(), pkt->getSize());
62     if (params()->ret_bad_addr) {
63         DPRINTF(IsaFake, "read to bad address va=%#x size=%d\n",
64                 pkt->getAddr(), pkt->getSize());
65         pkt->setBadAddress();
66     } else {
67         assert(pkt->getAddr() >= pioAddr && pkt->getAddr() < pioAddr + pioSize);
68         DPRINTF(IsaFake, "read  va=%#x size=%d\n",
69                 pkt->getAddr(), pkt->getSize());
70         switch (pkt->getSize()) {
71           case sizeof(uint64_t):
72              pkt->set(retData64);
73              break;
74           case sizeof(uint32_t):
75              pkt->set(retData32);
76              break;
77           case sizeof(uint16_t):
78              pkt->set(retData16);
79              break;
80           case sizeof(uint8_t):
81              pkt->set(retData8);
82              break;
83           default:
84              if (params()->fake_mem)
85                  std::memset(pkt->getPtr<uint8_t>(), 0, pkt->getSize());
86              else
87                  panic("invalid access size! Device being accessed by cache?\n");
      
88         }
89     }
90     return pioDelay;
91 }
\end{DoxyCode}
\hypertarget{classIsaFake_a4cefab464e72b5dd42c003a0a4341802}{
\index{IsaFake@{IsaFake}!write@{write}}
\index{write@{write}!IsaFake@{IsaFake}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} write ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIsaFake_a4cefab464e72b5dd42c003a0a4341802}
All writes are simply ignored. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]The memory request. \item[{\em data}]the data to not write. \end{DoxyParams}


\hyperlink{classPioDevice_afe8371668d023bb2516b286e5e399b6f}{PioDevice}を実装しています。


\begin{DoxyCode}
95 {
96     pkt->makeAtomicResponse();
97     if (params()->warn_access != "") {
98         uint64_t data;
99         switch (pkt->getSize()) {
100           case sizeof(uint64_t):
101             data = pkt->get<uint64_t>();
102             break;
103           case sizeof(uint32_t):
104             data = pkt->get<uint32_t>();
105             break;
106           case sizeof(uint16_t):
107             data = pkt->get<uint16_t>();
108             break;
109           case sizeof(uint8_t):
110             data = pkt->get<uint8_t>();
111             break;
112           default:
113             panic("invalid access size!\n");
114         }
115         warn("Device %s accessed by write to address %#x size=%d data=%#x\n",
116                 name(), pkt->getAddr(), pkt->getSize(), data);
117     }
118     if (params()->ret_bad_addr) {
119         DPRINTF(IsaFake, "write to bad address va=%#x size=%d \n",
120                 pkt->getAddr(), pkt->getSize());
121         pkt->setBadAddress();
122     } else {
123         DPRINTF(IsaFake, "write - va=%#x size=%d \n",
124                 pkt->getAddr(), pkt->getSize());
125 
126         if (params()->update_data) {
127             switch (pkt->getSize()) {
128               case sizeof(uint64_t):
129                 retData64 = pkt->get<uint64_t>();
130                 break;
131               case sizeof(uint32_t):
132                 retData32 = pkt->get<uint32_t>();
133                 break;
134               case sizeof(uint16_t):
135                 retData16 = pkt->get<uint16_t>();
136                 break;
137               case sizeof(uint8_t):
138                 retData8 = pkt->get<uint8_t>();
139                 break;
140               default:
141                 panic("invalid access size!\n");
142             }
143         }
144     }
145     return pioDelay;
146 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classIsaFake_a6a50681a9e818e6de256e0b428d031d4}{
\index{IsaFake@{IsaFake}!retData16@{retData16}}
\index{retData16@{retData16}!IsaFake@{IsaFake}}
\subsubsection[{retData16}]{\setlength{\rightskip}{0pt plus 5cm}uint16\_\-t {\bf retData16}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIsaFake_a6a50681a9e818e6de256e0b428d031d4}
\hypertarget{classIsaFake_aff159069c738217f75e3bdf4048b7c20}{
\index{IsaFake@{IsaFake}!retData32@{retData32}}
\index{retData32@{retData32}!IsaFake@{IsaFake}}
\subsubsection[{retData32}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf retData32}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIsaFake_aff159069c738217f75e3bdf4048b7c20}
\hypertarget{classIsaFake_a491508c3b16897f4ff96ef1ea2b2bebc}{
\index{IsaFake@{IsaFake}!retData64@{retData64}}
\index{retData64@{retData64}!IsaFake@{IsaFake}}
\subsubsection[{retData64}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf retData64}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIsaFake_a491508c3b16897f4ff96ef1ea2b2bebc}
\hypertarget{classIsaFake_ab214e69fe2d47c76466577f491122f50}{
\index{IsaFake@{IsaFake}!retData8@{retData8}}
\index{retData8@{retData8}!IsaFake@{IsaFake}}
\subsubsection[{retData8}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf retData8}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIsaFake_ab214e69fe2d47c76466577f491122f50}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/\hyperlink{isa__fake_8hh}{isa\_\-fake.hh}\item 
dev/\hyperlink{isa__fake_8cc}{isa\_\-fake.cc}\end{DoxyCompactItemize}
