\hypertarget{classIob}{
\section{クラス Iob}
\label{classIob}\index{Iob@{Iob}}
}


{\ttfamily \#include $<$iob.hh$>$}Iobに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=6cm]{classIob}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structIob_1_1IntBusy}{IntBusy}
\item 
struct \hyperlink{structIob_1_1IntCtl}{IntCtl}
\item 
struct \hyperlink{structIob_1_1IntMan}{IntMan}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef IobParams \hyperlink{classIob_a177ee3cfebf080ab43aa1b8310f520b1}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classIob_a6b17dd15918c015374327e292dca92f3}{Iob} (const \hyperlink{classIob_a177ee3cfebf080ab43aa1b8310f520b1}{Params} $\ast$p)
\item 
const \hyperlink{classIob_a177ee3cfebf080ab43aa1b8310f520b1}{Params} $\ast$ \hyperlink{classIob_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIob_a613ec7d5e1ec64f8d21fec78ae8e568e}{read} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIob_a4cefab464e72b5dd42c003a0a4341802}{write} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classIob_a3c0c6341079a8c15a7903e450c4dc1e5}{generateIpi} (\hyperlink{classIob_a1d1cfd8ffb84e947f82999c682b666a7}{Type} type, int cpu\_\-id, int vector)
\item 
void \hyperlink{classIob_a2f2af5343177e6cd711a25e3d34bbc85}{receiveDeviceInterrupt} (\hyperlink{classIob_a066ce0277195d2858dd73d3f2c5f48c4}{DeviceId} devid)
\item 
bool \hyperlink{classIob_abfe9b96f27c7834ff2c1302d6afea7c0}{receiveJBusInterrupt} (int cpu\_\-id, int source, uint64\_\-t d0, uint64\_\-t d1)
\item 
\hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classIob_a36cf113d5e5e091ebddb32306c098fae}{getAddrRanges} () const 
\item 
virtual void \hyperlink{classIob_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classIob_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classIob_a066ce0277195d2858dd73d3f2c5f48c4}{DeviceId} \{ \par
\hyperlink{classIob_a066ce0277195d2858dd73d3f2c5f48c4a303dacd808cdfd463b55fd4187054ae3}{Interal} =  0, 
\hyperlink{classIob_a066ce0277195d2858dd73d3f2c5f48c4a4dfd42ec49d09d8c6555c218301cc30f}{Error} =  1, 
\hyperlink{classIob_a066ce0277195d2858dd73d3f2c5f48c4a9519b5f56f6474a2f97052966f157b31}{SSI} =  2, 
\hyperlink{classIob_a066ce0277195d2858dd73d3f2c5f48c4a6136a0872216f91100b42ea04333af70}{Reserved} =  3, 
\par
\hyperlink{classIob_a066ce0277195d2858dd73d3f2c5f48c4ace7a692c78ae293ccaee297d424cd467}{NumDeviceIds}
 \}
\item 
enum \hyperlink{classIob_a1d1cfd8ffb84e947f82999c682b666a7}{Type} \{ \hyperlink{classIob_a1d1cfd8ffb84e947f82999c682b666a7ad165056706a57f6f8d2a171e9bbeebc6}{Interrupt}, 
\hyperlink{classIob_a1d1cfd8ffb84e947f82999c682b666a7a92793663441ced378f4676b8a6524385}{Reset}, 
\hyperlink{classIob_a1d1cfd8ffb84e947f82999c682b666a7ad3fa9ae9431d6cb1772f9d9df48cab19}{Idle}, 
\hyperlink{classIob_a1d1cfd8ffb84e947f82999c682b666a7a3e76e0644dbaf318b389719aab4e87da}{Resume}
 \}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classIob_a4683924656f7e6ca641aab7310aae530}{writeIob} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classIob_adfe6eb5eebb6cfad3bd50b969ef744c6}{writeJBus} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classIob_ab4cf9411b48d0baf8e0788b840c8256a}{readIob} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classIob_a04a9ec2ef24eaa5002c2c211e83e4067}{readJBus} (\hyperlink{classPacket}{PacketPtr} pkt)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classIntrControl}{IntrControl} $\ast$ \hyperlink{classIob_acd432c3316af2e694733cb3ca5b57bb4}{ic}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classIob_a5b9c2a6c7833c638ac7f48f8d40d8826}{iobManAddr}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classIob_a70272f6df3d88fc8934351dda059264a}{iobManSize}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classIob_aba44ac2ddf6078b6b3f990a68892272c}{iobJBusAddr}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classIob_afce8ffd48792d932bbadab4bc5a0a158}{iobJBusSize}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIob_ac8e969635a78ab9ab123904ccca434cc}{pioDelay}
\item 
\hyperlink{structIob_1_1IntMan}{IntMan} \hyperlink{classIob_a5ecb750ae20ab06b89d17e596ae2725b}{intMan} \mbox{[}NumDeviceIds\mbox{]}
\item 
\hyperlink{structIob_1_1IntCtl}{IntCtl} \hyperlink{classIob_af459816a17b687878d7d0f971c3af98e}{intCtl} \mbox{[}NumDeviceIds\mbox{]}
\item 
uint64\_\-t \hyperlink{classIob_a46f4284ddac54035615f6ae5dd274949}{jIntVec}
\item 
uint64\_\-t \hyperlink{classIob_a879d3a735fb02cc428ac1a00bd6ca1cd}{jBusData0} \mbox{[}\hyperlink{iob_8hh_ad25d74b9f417cfb77620cab3183e0aba}{MaxNiagaraProcs}\mbox{]}
\item 
uint64\_\-t \hyperlink{classIob_adb2d55598e0489de9fe265747a544686}{jBusData1} \mbox{[}\hyperlink{iob_8hh_ad25d74b9f417cfb77620cab3183e0aba}{MaxNiagaraProcs}\mbox{]}
\item 
\hyperlink{structIob_1_1IntBusy}{IntBusy} \hyperlink{classIob_a971401f936f065a7781d41a2cf198303}{jIntBusy} \mbox{[}\hyperlink{iob_8hh_ad25d74b9f417cfb77620cab3183e0aba}{MaxNiagaraProcs}\mbox{]}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classIob_a177ee3cfebf080ab43aa1b8310f520b1}{
\index{Iob@{Iob}!Params@{Params}}
\index{Params@{Params}!Iob@{Iob}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef IobParams {\bf Params}}}
\label{classIob_a177ee3cfebf080ab43aa1b8310f520b1}


\hyperlink{classPioDevice_a9cdbda5b5cc24147ce82b7d07bf03cd1}{PioDevice}を再定義しています。

\subsection{列挙型}
\hypertarget{classIob_a066ce0277195d2858dd73d3f2c5f48c4}{
\index{Iob@{Iob}!DeviceId@{DeviceId}}
\index{DeviceId@{DeviceId}!Iob@{Iob}}
\subsubsection[{DeviceId}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf DeviceId}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIob_a066ce0277195d2858dd73d3f2c5f48c4}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Interal@{Interal}!Iob@{Iob}}\index{Iob@{Iob}!Interal@{Interal}}\item[{\em 
\hypertarget{classIob_a066ce0277195d2858dd73d3f2c5f48c4a303dacd808cdfd463b55fd4187054ae3}{
Interal}
\label{classIob_a066ce0277195d2858dd73d3f2c5f48c4a303dacd808cdfd463b55fd4187054ae3}
}]\index{Error@{Error}!Iob@{Iob}}\index{Iob@{Iob}!Error@{Error}}\item[{\em 
\hypertarget{classIob_a066ce0277195d2858dd73d3f2c5f48c4a4dfd42ec49d09d8c6555c218301cc30f}{
Error}
\label{classIob_a066ce0277195d2858dd73d3f2c5f48c4a4dfd42ec49d09d8c6555c218301cc30f}
}]\index{SSI@{SSI}!Iob@{Iob}}\index{Iob@{Iob}!SSI@{SSI}}\item[{\em 
\hypertarget{classIob_a066ce0277195d2858dd73d3f2c5f48c4a9519b5f56f6474a2f97052966f157b31}{
SSI}
\label{classIob_a066ce0277195d2858dd73d3f2c5f48c4a9519b5f56f6474a2f97052966f157b31}
}]\index{Reserved@{Reserved}!Iob@{Iob}}\index{Iob@{Iob}!Reserved@{Reserved}}\item[{\em 
\hypertarget{classIob_a066ce0277195d2858dd73d3f2c5f48c4a6136a0872216f91100b42ea04333af70}{
Reserved}
\label{classIob_a066ce0277195d2858dd73d3f2c5f48c4a6136a0872216f91100b42ea04333af70}
}]\index{NumDeviceIds@{NumDeviceIds}!Iob@{Iob}}\index{Iob@{Iob}!NumDeviceIds@{NumDeviceIds}}\item[{\em 
\hypertarget{classIob_a066ce0277195d2858dd73d3f2c5f48c4ace7a692c78ae293ccaee297d424cd467}{
NumDeviceIds}
\label{classIob_a066ce0277195d2858dd73d3f2c5f48c4ace7a692c78ae293ccaee297d424cd467}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
84                   {
85         Interal = 0,
86         Error = 1,
87         SSI = 2,
88         Reserved = 3,
89         NumDeviceIds
90     };
\end{DoxyCode}
\hypertarget{classIob_a1d1cfd8ffb84e947f82999c682b666a7}{
\index{Iob@{Iob}!Type@{Type}}
\index{Type@{Type}!Iob@{Iob}}
\subsubsection[{Type}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Type}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIob_a1d1cfd8ffb84e947f82999c682b666a7}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Interrupt@{Interrupt}!Iob@{Iob}}\index{Iob@{Iob}!Interrupt@{Interrupt}}\item[{\em 
\hypertarget{classIob_a1d1cfd8ffb84e947f82999c682b666a7ad165056706a57f6f8d2a171e9bbeebc6}{
Interrupt}
\label{classIob_a1d1cfd8ffb84e947f82999c682b666a7ad165056706a57f6f8d2a171e9bbeebc6}
}]\index{Reset@{Reset}!Iob@{Iob}}\index{Iob@{Iob}!Reset@{Reset}}\item[{\em 
\hypertarget{classIob_a1d1cfd8ffb84e947f82999c682b666a7a92793663441ced378f4676b8a6524385}{
Reset}
\label{classIob_a1d1cfd8ffb84e947f82999c682b666a7a92793663441ced378f4676b8a6524385}
}]\index{Idle@{Idle}!Iob@{Iob}}\index{Iob@{Iob}!Idle@{Idle}}\item[{\em 
\hypertarget{classIob_a1d1cfd8ffb84e947f82999c682b666a7ad3fa9ae9431d6cb1772f9d9df48cab19}{
Idle}
\label{classIob_a1d1cfd8ffb84e947f82999c682b666a7ad3fa9ae9431d6cb1772f9d9df48cab19}
}]\index{Resume@{Resume}!Iob@{Iob}}\index{Iob@{Iob}!Resume@{Resume}}\item[{\em 
\hypertarget{classIob_a1d1cfd8ffb84e947f82999c682b666a7a3e76e0644dbaf318b389719aab4e87da}{
Resume}
\label{classIob_a1d1cfd8ffb84e947f82999c682b666a7a3e76e0644dbaf318b389719aab4e87da}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
107               {
108         Interrupt,
109         Reset,
110         Idle,
111         Resume
112     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classIob_a6b17dd15918c015374327e292dca92f3}{
\index{Iob@{Iob}!Iob@{Iob}}
\index{Iob@{Iob}!Iob@{Iob}}
\subsubsection[{Iob}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Iob} (const {\bf Params} $\ast$ {\em p})}}
\label{classIob_a6b17dd15918c015374327e292dca92f3}



\begin{DoxyCode}
55     : PioDevice(p), ic(p->platform->intrctrl)
56 {
57     iobManAddr = ULL(0x9800000000);
58     iobManSize = ULL(0x0100000000);
59     iobJBusAddr = ULL(0x9F00000000);
60     iobJBusSize = ULL(0x0100000000);
61     assert (params()->system->threadContexts.size() <= MaxNiagaraProcs);
62 
63     pioDelay = p->pio_latency;
64 
65     for (int x = 0; x < NumDeviceIds; ++x) {
66         intMan[x].cpu = 0;
67         intMan[x].vector = 0;
68         intCtl[x].mask = true;
69         intCtl[x].pend = false;
70     }
71 
72 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classIob_a3c0c6341079a8c15a7903e450c4dc1e5}{
\index{Iob@{Iob}!generateIpi@{generateIpi}}
\index{generateIpi@{generateIpi}!Iob@{Iob}}
\subsubsection[{generateIpi}]{\setlength{\rightskip}{0pt plus 5cm}void generateIpi ({\bf Type} {\em type}, \/  int {\em cpu\_\-id}, \/  int {\em vector})}}
\label{classIob_a3c0c6341079a8c15a7903e450c4dc1e5}



\begin{DoxyCode}
275 {
276     SparcISA::SparcFault<SparcISA::PowerOnReset> *por = new 
      SparcISA::PowerOnReset();
277     if (cpu_id >= sys->numContexts())
278         return;
279 
280     switch (type) {
281       case 0: // interrupt
282         DPRINTF(Iob, "Generating interrupt because of I/O write to cpu: %d vec %d
      \n",
283                 cpu_id, vector);
284         ic->post(cpu_id, SparcISA::IT_INT_VEC, vector);
285         break;
286       case 1: // reset
287         warn("Sending reset to CPU: %d\n", cpu_id);
288         if (vector != por->trapType())
289             panic("Don't know how to set non-POR reset to cpu\n");
290         por->invoke(sys->threadContexts[cpu_id]);
291         sys->threadContexts[cpu_id]->activate();
292         break;
293       case 2: // idle -- this means stop executing and don't wake on interrupts
294         DPRINTF(Iob, "Idling CPU because of I/O write cpu: %d\n", cpu_id);
295         sys->threadContexts[cpu_id]->halt();
296         break;
297       case 3: // resume
298         DPRINTF(Iob, "Resuming CPU because of I/O write cpu: %d\n", cpu_id);
299         sys->threadContexts[cpu_id]->activate();
300         break;
301       default:
302         panic("Invalid type to generate ipi\n");
303     }
304 }
\end{DoxyCode}
\hypertarget{classIob_a36cf113d5e5e091ebddb32306c098fae}{
\index{Iob@{Iob}!getAddrRanges@{getAddrRanges}}
\index{getAddrRanges@{getAddrRanges}!Iob@{Iob}}
\subsubsection[{getAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRangeList} getAddrRanges () const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIob_a36cf113d5e5e091ebddb32306c098fae}
Every PIO device is obliged to provide an implementation that returns the address ranges the device responds to.

\begin{DoxyReturn}{戻り値}
a list of non-\/overlapping address ranges 
\end{DoxyReturn}


\hyperlink{classPioDevice_a6e967f8921e80748eb2be35b6b481a7e}{PioDevice}を実装しています。


\begin{DoxyCode}
328 {
329     AddrRangeList ranges;
330     ranges.push_back(RangeSize(iobManAddr, iobManSize));
331     ranges.push_back(RangeSize(iobJBusAddr, iobJBusSize));
332     return ranges;
333 }
\end{DoxyCode}
\hypertarget{classIob_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{Iob@{Iob}!params@{params}}
\index{params@{params}!Iob@{Iob}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classIob_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classPioDevice_acd3c3feb78ae7a8f88fe0f110a718dff}{PioDevice}を再定義しています。


\begin{DoxyCode}
132     {
133         return dynamic_cast<const Params *>(_params);
134     }
\end{DoxyCode}
\hypertarget{classIob_a613ec7d5e1ec64f8d21fec78ae8e568e}{
\index{Iob@{Iob}!read@{read}}
\index{read@{read}!Iob@{Iob}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} read ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIob_a613ec7d5e1ec64f8d21fec78ae8e568e}
Pure virtual function that the device must implement. Called when a read command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_a842312590432036092c422c87a442358}{PioDevice}を実装しています。


\begin{DoxyCode}
76 {
77 
78     if (pkt->getAddr() >= iobManAddr && pkt->getAddr() < iobManAddr + iobManSize)
      
79         readIob(pkt);
80     else if (pkt->getAddr() >= iobJBusAddr && pkt->getAddr() < iobJBusAddr+
      iobJBusSize)
81         readJBus(pkt);
82     else
83         panic("Invalid address reached Iob\n");
84 
85     pkt->makeAtomicResponse();
86     return pioDelay;
87 }
\end{DoxyCode}
\hypertarget{classIob_ab4cf9411b48d0baf8e0788b840c8256a}{
\index{Iob@{Iob}!readIob@{readIob}}
\index{readIob@{readIob}!Iob@{Iob}}
\subsubsection[{readIob}]{\setlength{\rightskip}{0pt plus 5cm}void readIob ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIob_ab4cf9411b48d0baf8e0788b840c8256a}



\begin{DoxyCode}
91 {
92         Addr accessAddr = pkt->getAddr() - iobManAddr;
93 
94         if (accessAddr >= IntManAddr && accessAddr < IntManAddr + IntManSize) {
95             int index = (accessAddr - IntManAddr) >> 3;
96             uint64_t data = intMan[index].cpu << 8 | intMan[index].vector << 0;
97             pkt->set(data);
98             return;
99         }
100 
101         if (accessAddr >= IntCtlAddr && accessAddr < IntCtlAddr + IntCtlSize) {
102             int index = (accessAddr - IntCtlAddr) >> 3;
103             uint64_t data = intCtl[index].mask  ? 1 << 2 : 0 |
104                 intCtl[index].pend  ? 1 << 0 : 0;
105             pkt->set(data);
106             return;
107         }
108 
109         if (accessAddr == JIntVecAddr) {
110             pkt->set(jIntVec);
111             return;
112         }
113 
114         panic("Read to unknown IOB offset 0x%x\n", accessAddr);
115 }
\end{DoxyCode}
\hypertarget{classIob_a04a9ec2ef24eaa5002c2c211e83e4067}{
\index{Iob@{Iob}!readJBus@{readJBus}}
\index{readJBus@{readJBus}!Iob@{Iob}}
\subsubsection[{readJBus}]{\setlength{\rightskip}{0pt plus 5cm}void readJBus ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIob_a04a9ec2ef24eaa5002c2c211e83e4067}



\begin{DoxyCode}
119 {
120         Addr accessAddr = pkt->getAddr() - iobJBusAddr;
121         int cpuid = pkt->req->contextId();
122         int index;
123         uint64_t data;
124 
125 
126 
127 
128         if (accessAddr >= JIntData0Addr && accessAddr < JIntData1Addr) {
129             index = (accessAddr - JIntData0Addr) >> 3;
130             pkt->set(jBusData0[index]);
131             return;
132         }
133 
134         if (accessAddr >= JIntData1Addr && accessAddr < JIntDataA0Addr) {
135             index = (accessAddr - JIntData1Addr) >> 3;
136             pkt->set(jBusData1[index]);
137             return;
138         }
139 
140         if (accessAddr == JIntDataA0Addr) {
141             pkt->set(jBusData0[cpuid]);
142             return;
143         }
144 
145         if (accessAddr == JIntDataA1Addr) {
146             pkt->set(jBusData1[cpuid]);
147             return;
148         }
149 
150         if (accessAddr >= JIntBusyAddr && accessAddr < JIntBusyAddr + 
      JIntBusySize) {
151             index = (accessAddr - JIntBusyAddr) >> 3;
152             data = jIntBusy[index].busy ? 1 << 5 : 0 |
153                    jIntBusy[index].source;
154             pkt->set(data);
155             return;
156         }
157         if (accessAddr == JIntABusyAddr) {
158             data = jIntBusy[cpuid].busy ? 1 << 5 : 0 |
159                    jIntBusy[cpuid].source;
160             pkt->set(data);
161             return;
162         };
163 
164         panic("Read to unknown JBus offset 0x%x\n", accessAddr);
165 }
\end{DoxyCode}
\hypertarget{classIob_a2f2af5343177e6cd711a25e3d34bbc85}{
\index{Iob@{Iob}!receiveDeviceInterrupt@{receiveDeviceInterrupt}}
\index{receiveDeviceInterrupt@{receiveDeviceInterrupt}!Iob@{Iob}}
\subsubsection[{receiveDeviceInterrupt}]{\setlength{\rightskip}{0pt plus 5cm}void receiveDeviceInterrupt ({\bf DeviceId} {\em devid})}}
\label{classIob_a2f2af5343177e6cd711a25e3d34bbc85}



\begin{DoxyCode}
261 {
262     assert(devid < NumDeviceIds);
263     if (intCtl[devid].mask)
264         return;
265     intCtl[devid].mask = true;
266     intCtl[devid].pend = true;
267     DPRINTF(Iob, "Receiving Device interrupt: %d for cpu %d vec %d\n",
268             devid, intMan[devid].cpu, intMan[devid].vector);
269     ic->post(intMan[devid].cpu, SparcISA::IT_INT_VEC, intMan[devid].vector);
270 }
\end{DoxyCode}
\hypertarget{classIob_abfe9b96f27c7834ff2c1302d6afea7c0}{
\index{Iob@{Iob}!receiveJBusInterrupt@{receiveJBusInterrupt}}
\index{receiveJBusInterrupt@{receiveJBusInterrupt}!Iob@{Iob}}
\subsubsection[{receiveJBusInterrupt}]{\setlength{\rightskip}{0pt plus 5cm}bool receiveJBusInterrupt (int {\em cpu\_\-id}, \/  int {\em source}, \/  uint64\_\-t {\em d0}, \/  uint64\_\-t {\em d1})}}
\label{classIob_abfe9b96f27c7834ff2c1302d6afea7c0}



\begin{DoxyCode}
308 {
309     // If we are already dealing with an interrupt for that cpu we can't deal
310     // with another one right now... come back later
311     if (jIntBusy[cpu_id].busy)
312         return false;
313 
314     DPRINTF(Iob, "Receiving jBus interrupt: %d for cpu %d vec %d\n",
315             source, cpu_id, jIntVec);
316 
317     jIntBusy[cpu_id].busy = true;
318     jIntBusy[cpu_id].source = source;
319     jBusData0[cpu_id] = d0;
320     jBusData1[cpu_id] = d1;
321 
322     ic->post(cpu_id, SparcISA::IT_INT_VEC, jIntVec);
323     return true;
324 }
\end{DoxyCode}
\hypertarget{classIob_a53e036786d17361be4c7320d39c99b84}{
\index{Iob@{Iob}!serialize@{serialize}}
\index{serialize@{serialize}!Iob@{Iob}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIob_a53e036786d17361be4c7320d39c99b84}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。


\begin{DoxyCode}
338 {
339 
340     SERIALIZE_SCALAR(jIntVec);
341     SERIALIZE_ARRAY(jBusData0, MaxNiagaraProcs);
342     SERIALIZE_ARRAY(jBusData1, MaxNiagaraProcs);
343     for (int x = 0; x < NumDeviceIds; x++) {
344         nameOut(os, csprintf("%s.Int%d", name(), x));
345         paramOut(os, "cpu", intMan[x].cpu);
346         paramOut(os, "vector", intMan[x].vector);
347         paramOut(os, "mask", intCtl[x].mask);
348         paramOut(os, "pend", intCtl[x].pend);
349     };
350     for (int x = 0; x < MaxNiagaraProcs; x++) {
351         nameOut(os, csprintf("%s.jIntBusy%d", name(), x));
352         paramOut(os, "busy", jIntBusy[x].busy);
353         paramOut(os, "source", jIntBusy[x].source);
354     };
355 }
\end{DoxyCode}
\hypertarget{classIob_af22e5d6d660b97db37003ac61ac4ee49}{
\index{Iob@{Iob}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!Iob@{Iob}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIob_af22e5d6d660b97db37003ac61ac4ee49}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。


\begin{DoxyCode}
359 {
360     UNSERIALIZE_SCALAR(jIntVec);
361     UNSERIALIZE_ARRAY(jBusData0, MaxNiagaraProcs);
362     UNSERIALIZE_ARRAY(jBusData1, MaxNiagaraProcs);
363     for (int x = 0; x < NumDeviceIds; x++) {
364         paramIn(cp, csprintf("%s.Int%d", name(), x), "cpu", intMan[x].cpu);
365         paramIn(cp, csprintf("%s.Int%d", name(), x), "vector", intMan[x].vector);
      
366         paramIn(cp, csprintf("%s.Int%d", name(), x), "mask", intCtl[x].mask);
367         paramIn(cp, csprintf("%s.Int%d", name(), x), "pend", intCtl[x].pend);
368     };
369     for (int x = 0; x < MaxNiagaraProcs; x++) {
370         paramIn(cp, csprintf("%s.jIntBusy%d", name(), x), "busy", jIntBusy[x].bus
      y);
371         paramIn(cp, csprintf("%s.jIntBusy%d", name(), x), "source", jIntBusy[x].s
      ource);
372     };
373 }
\end{DoxyCode}
\hypertarget{classIob_a4cefab464e72b5dd42c003a0a4341802}{
\index{Iob@{Iob}!write@{write}}
\index{write@{write}!Iob@{Iob}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} write ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIob_a4cefab464e72b5dd42c003a0a4341802}
Pure virtual function that the device must implement. Called when a write command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_afe8371668d023bb2516b286e5e399b6f}{PioDevice}を実装しています。


\begin{DoxyCode}
169 {
170     if (pkt->getAddr() >= iobManAddr && pkt->getAddr() < iobManAddr + iobManSize)
      
171         writeIob(pkt);
172     else if (pkt->getAddr() >= iobJBusAddr && pkt->getAddr() < iobJBusAddr+
      iobJBusSize)
173         writeJBus(pkt);
174     else
175         panic("Invalid address reached Iob\n");
176 
177 
178     pkt->makeAtomicResponse();
179     return pioDelay;
180 }
\end{DoxyCode}
\hypertarget{classIob_a4683924656f7e6ca641aab7310aae530}{
\index{Iob@{Iob}!writeIob@{writeIob}}
\index{writeIob@{writeIob}!Iob@{Iob}}
\subsubsection[{writeIob}]{\setlength{\rightskip}{0pt plus 5cm}void writeIob ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIob_a4683924656f7e6ca641aab7310aae530}



\begin{DoxyCode}
184 {
185         Addr accessAddr = pkt->getAddr() - iobManAddr;
186         int index;
187         uint64_t data;
188 
189         if (accessAddr >= IntManAddr && accessAddr < IntManAddr + IntManSize) {
190             index = (accessAddr - IntManAddr) >> 3;
191             data = pkt->get<uint64_t>();
192             intMan[index].cpu = bits(data,12,8);
193             intMan[index].vector = bits(data,5,0);
194             DPRINTF(Iob, "Wrote IntMan %d cpu %d, vec %d\n", index,
195                     intMan[index].cpu, intMan[index].vector);
196             return;
197         }
198 
199         if (accessAddr >= IntCtlAddr && accessAddr < IntCtlAddr + IntCtlSize) {
200             index = (accessAddr - IntCtlAddr) >> 3;
201             data = pkt->get<uint64_t>();
202             intCtl[index].mask = bits(data,2,2);
203             if (bits(data,1,1))
204                 intCtl[index].pend = false;
205             DPRINTF(Iob, "Wrote IntCtl %d pend %d cleared %d\n", index,
206                     intCtl[index].pend, bits(data,2,2));
207             return;
208         }
209 
210         if (accessAddr == JIntVecAddr) {
211             jIntVec = bits(pkt->get<uint64_t>(), 5,0);
212             DPRINTF(Iob, "Wrote jIntVec %d\n", jIntVec);
213             return;
214         }
215 
216         if (accessAddr >= IntVecDisAddr && accessAddr < IntVecDisAddr + 
      IntVecDisSize) {
217             Type type;
218             int cpu_id;
219             int vector;
220             index = (accessAddr - IntManAddr) >> 3;
221             data = pkt->get<uint64_t>();
222             type = (Type)bits(data,17,16);
223             cpu_id = bits(data, 12,8);
224             vector = bits(data,5,0);
225             generateIpi(type,cpu_id, vector);
226             return;
227         }
228 
229         panic("Write to unknown IOB offset 0x%x\n", accessAddr);
230 }
\end{DoxyCode}
\hypertarget{classIob_adfe6eb5eebb6cfad3bd50b969ef744c6}{
\index{Iob@{Iob}!writeJBus@{writeJBus}}
\index{writeJBus@{writeJBus}!Iob@{Iob}}
\subsubsection[{writeJBus}]{\setlength{\rightskip}{0pt plus 5cm}void writeJBus ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIob_adfe6eb5eebb6cfad3bd50b969ef744c6}



\begin{DoxyCode}
234 {
235         Addr accessAddr = pkt->getAddr() - iobJBusAddr;
236         int cpuid = pkt->req->contextId();
237         int index;
238         uint64_t data;
239 
240         if (accessAddr >= JIntBusyAddr && accessAddr < JIntBusyAddr + 
      JIntBusySize) {
241             index = (accessAddr - JIntBusyAddr) >> 3;
242             data = pkt->get<uint64_t>();
243             jIntBusy[index].busy = bits(data,5,5);
244             DPRINTF(Iob, "Wrote jIntBusy index %d busy: %d\n", index,
245                     jIntBusy[index].busy);
246             return;
247         }
248         if (accessAddr == JIntABusyAddr) {
249             data = pkt->get<uint64_t>();
250             jIntBusy[cpuid].busy = bits(data,5,5);
251             DPRINTF(Iob, "Wrote jIntBusy index %d busy: %d\n", cpuid,
252                     jIntBusy[cpuid].busy);
253             return;
254         };
255 
256         panic("Write to unknown JBus offset 0x%x\n", accessAddr);
257 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classIob_acd432c3316af2e694733cb3ca5b57bb4}{
\index{Iob@{Iob}!ic@{ic}}
\index{ic@{ic}!Iob@{Iob}}
\subsubsection[{ic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IntrControl}$\ast$ {\bf ic}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIob_acd432c3316af2e694733cb3ca5b57bb4}
\hypertarget{classIob_af459816a17b687878d7d0f971c3af98e}{
\index{Iob@{Iob}!intCtl@{intCtl}}
\index{intCtl@{intCtl}!Iob@{Iob}}
\subsubsection[{intCtl}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IntCtl} {\bf intCtl}\mbox{[}NumDeviceIds\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIob_af459816a17b687878d7d0f971c3af98e}
\hypertarget{classIob_a5ecb750ae20ab06b89d17e596ae2725b}{
\index{Iob@{Iob}!intMan@{intMan}}
\index{intMan@{intMan}!Iob@{Iob}}
\subsubsection[{intMan}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IntMan} {\bf intMan}\mbox{[}NumDeviceIds\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIob_a5ecb750ae20ab06b89d17e596ae2725b}
\hypertarget{classIob_aba44ac2ddf6078b6b3f990a68892272c}{
\index{Iob@{Iob}!iobJBusAddr@{iobJBusAddr}}
\index{iobJBusAddr@{iobJBusAddr}!Iob@{Iob}}
\subsubsection[{iobJBusAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf iobJBusAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIob_aba44ac2ddf6078b6b3f990a68892272c}
\hypertarget{classIob_afce8ffd48792d932bbadab4bc5a0a158}{
\index{Iob@{Iob}!iobJBusSize@{iobJBusSize}}
\index{iobJBusSize@{iobJBusSize}!Iob@{Iob}}
\subsubsection[{iobJBusSize}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf iobJBusSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIob_afce8ffd48792d932bbadab4bc5a0a158}
\hypertarget{classIob_a5b9c2a6c7833c638ac7f48f8d40d8826}{
\index{Iob@{Iob}!iobManAddr@{iobManAddr}}
\index{iobManAddr@{iobManAddr}!Iob@{Iob}}
\subsubsection[{iobManAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf iobManAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIob_a5b9c2a6c7833c638ac7f48f8d40d8826}
\hypertarget{classIob_a70272f6df3d88fc8934351dda059264a}{
\index{Iob@{Iob}!iobManSize@{iobManSize}}
\index{iobManSize@{iobManSize}!Iob@{Iob}}
\subsubsection[{iobManSize}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf iobManSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIob_a70272f6df3d88fc8934351dda059264a}
\hypertarget{classIob_a879d3a735fb02cc428ac1a00bd6ca1cd}{
\index{Iob@{Iob}!jBusData0@{jBusData0}}
\index{jBusData0@{jBusData0}!Iob@{Iob}}
\subsubsection[{jBusData0}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf jBusData0}\mbox{[}{\bf MaxNiagaraProcs}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIob_a879d3a735fb02cc428ac1a00bd6ca1cd}
\hypertarget{classIob_adb2d55598e0489de9fe265747a544686}{
\index{Iob@{Iob}!jBusData1@{jBusData1}}
\index{jBusData1@{jBusData1}!Iob@{Iob}}
\subsubsection[{jBusData1}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf jBusData1}\mbox{[}{\bf MaxNiagaraProcs}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIob_adb2d55598e0489de9fe265747a544686}
\hypertarget{classIob_a971401f936f065a7781d41a2cf198303}{
\index{Iob@{Iob}!jIntBusy@{jIntBusy}}
\index{jIntBusy@{jIntBusy}!Iob@{Iob}}
\subsubsection[{jIntBusy}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IntBusy} {\bf jIntBusy}\mbox{[}{\bf MaxNiagaraProcs}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIob_a971401f936f065a7781d41a2cf198303}
\hypertarget{classIob_a46f4284ddac54035615f6ae5dd274949}{
\index{Iob@{Iob}!jIntVec@{jIntVec}}
\index{jIntVec@{jIntVec}!Iob@{Iob}}
\subsubsection[{jIntVec}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf jIntVec}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIob_a46f4284ddac54035615f6ae5dd274949}
\hypertarget{classIob_ac8e969635a78ab9ab123904ccca434cc}{
\index{Iob@{Iob}!pioDelay@{pioDelay}}
\index{pioDelay@{pioDelay}!Iob@{Iob}}
\subsubsection[{pioDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf pioDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIob_ac8e969635a78ab9ab123904ccca434cc}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/sparc/\hyperlink{iob_8hh}{iob.hh}\item 
dev/sparc/\hyperlink{iob_8cc}{iob.cc}\end{DoxyCompactItemize}
