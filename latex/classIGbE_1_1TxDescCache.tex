\hypertarget{classIGbE_1_1TxDescCache}{
\section{クラス TxDescCache}
\label{classIGbE_1_1TxDescCache}\index{IGbE::TxDescCache@{IGbE::TxDescCache}}
}
TxDescCacheに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classIGbE_1_1TxDescCache}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classIGbE_1_1TxDescCache_a5c53fad45a69d0f3c20bd08b980a2485}{TxDescCache} (\hyperlink{classIGbE}{IGbE} $\ast$i, std::string n, int s)
\item 
unsigned \hyperlink{classIGbE_1_1TxDescCache_a924187a1c689184efd8492916ca12e32}{getPacketSize} (\hyperlink{classRefCountingPtr}{EthPacketPtr} p)
\item 
void \hyperlink{classIGbE_1_1TxDescCache_af58491ad4f774a610584c404231b30ae}{getPacketData} (\hyperlink{classRefCountingPtr}{EthPacketPtr} p)
\item 
void \hyperlink{classIGbE_1_1TxDescCache_af7a2e6e84647ba93598a7a02730cba41}{processContextDesc} ()
\item 
unsigned \hyperlink{classIGbE_1_1TxDescCache_a6fb0bd6d34eae6de55fb211662f92180}{descInBlock} (unsigned num\_\-desc)
\item 
bool \hyperlink{classIGbE_1_1TxDescCache_a3fd3cdfc66306ff22b53325aeb4e2c64}{packetAvailable} ()
\item 
bool \hyperlink{classIGbE_1_1TxDescCache_ad8a4f7d1ef74ba318f35597c58bc757b}{packetWaiting} ()
\item 
bool \hyperlink{classIGbE_1_1TxDescCache_a126e4d9db081d9783bdcf86befdff3de}{packetMultiDesc} ()
\item 
void \hyperlink{classIGbE_1_1TxDescCache_a4f0881be8aa8698e16dcf52a89085100}{pktComplete} ()
\item 
void \hyperlink{classIGbE_1_1TxDescCache_ae7e4853724fee8019b3bdd04200b9d6b}{headerComplete} ()
\item 
void \hyperlink{classIGbE_1_1TxDescCache_a10c4245eaf8149b42c17bb6aa4a7c5eb}{completionWriteback} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} a, bool enabled)
\item 
virtual bool \hyperlink{classIGbE_1_1TxDescCache_a2587421ae644a9474416e5a5b63ccbca}{hasOutstandingEvents} ()
\item 
void \hyperlink{classIGbE_1_1TxDescCache_a34032325b571ff60682217adbf73ad37}{nullCallback} ()
\item 
virtual void \hyperlink{classIGbE_1_1TxDescCache_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classIGbE_1_1TxDescCache_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classIGbE_1_1TxDescCache}{TxDescCache},\&TxDescCache::pktComplete $>$ \hyperlink{classIGbE_1_1TxDescCache_a2a06f4aa962fc09e9e764d3e9006d11b}{pktEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classIGbE_1_1TxDescCache}{TxDescCache},\&TxDescCache::headerComplete $>$ \hyperlink{classIGbE_1_1TxDescCache_ae7a8388f5aa169f8c86c19f91c3b128d}{headerEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classIGbE_1_1TxDescCache}{TxDescCache},\&TxDescCache::nullCallback $>$ \hyperlink{classIGbE_1_1TxDescCache_adc0e7fe81737dc40daddf8391bffae79}{nullEvent}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classIGbE_1_1TxDescCache_ae5a77c90557026fdf4fd78883f92bef9}{descBase} () const 
\item 
virtual long \hyperlink{classIGbE_1_1TxDescCache_af3d1877b6f30bdf98b95351c38d400f3}{descHead} () const 
\item 
virtual long \hyperlink{classIGbE_1_1TxDescCache_a4b6b769be62592fc43518ba480bbd1f7}{descTail} () const 
\item 
virtual long \hyperlink{classIGbE_1_1TxDescCache_a465e4e31be3a89db3d7f9cd1ecc40064}{descLen} () const 
\item 
virtual void \hyperlink{classIGbE_1_1TxDescCache_a4f8dbb4f64167626cac110753708c55c}{updateHead} (long h)
\item 
virtual void \hyperlink{classIGbE_1_1TxDescCache_aec7fdcc540223076999e0f8f07f854bc}{enableSm} ()
\item 
virtual void \hyperlink{classIGbE_1_1TxDescCache_a32bbafeff677d291df2eb9247a33b292}{actionAfterWb} ()
\item 
virtual void \hyperlink{classIGbE_1_1TxDescCache_abb8070fbcfa38a9697d92bbc4a0b6505}{fetchAfterWb} ()
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classIGbE_1_1TxDescCache_a0807bda2e863c4492ab0165135bf396c}{pktDone}
\item 
bool \hyperlink{classIGbE_1_1TxDescCache_ad610366c4a18d924d4962433c0b8515e}{isTcp}
\item 
bool \hyperlink{classIGbE_1_1TxDescCache_a584d7923b741a0ed4ae9c59b8ab254ad}{pktWaiting}
\item 
bool \hyperlink{classIGbE_1_1TxDescCache_adb0830579bf508fe91ec42f51928ca5d}{pktMultiDesc}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classIGbE_1_1TxDescCache_a9bad25394212b8c9bf19b5b3fd692d7a}{completionAddress}
\item 
bool \hyperlink{classIGbE_1_1TxDescCache_ad3481e86d121444fdcc4b02650d38e47}{completionEnabled}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classIGbE_1_1TxDescCache_a487a3ccede49d6015e8e320bcd5b29e7}{descEnd}
\item 
bool \hyperlink{classIGbE_1_1TxDescCache_ae2379f1cb19d3eabcb86036c07fc7986}{useTso}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classIGbE_1_1TxDescCache_abdc8c249b4ac1dcba87bb5dd61aad6b4}{tsoHeaderLen}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classIGbE_1_1TxDescCache_a140f29bf479ea15261618bed60b9f777}{tsoMss}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classIGbE_1_1TxDescCache_a94166f6af145a255d6623ebd93b0c0f5}{tsoTotalLen}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classIGbE_1_1TxDescCache_afaeeb9d655b0c19961b86d83fc025ae5}{tsoUsedLen}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classIGbE_1_1TxDescCache_a2906204858e8f7b554a7b5a449bbb4cb}{tsoPrevSeq}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classIGbE_1_1TxDescCache_a6113e9447ae2e0f5fcea17ac8b4a2fd5}{tsoPktPayloadBytes}
\item 
bool \hyperlink{classIGbE_1_1TxDescCache_aea6ed56838e016f0ad81353c348b62cb}{tsoLoadedHeader}
\item 
bool \hyperlink{classIGbE_1_1TxDescCache_a3e767a1c20550a9a1f1c04e0900475d3}{tsoPktHasHeader}
\item 
uint8\_\-t \hyperlink{classIGbE_1_1TxDescCache_a3309d8f5e1d64bb4d1ce8a654d406094}{tsoHeader} \mbox{[}256\mbox{]}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classIGbE_1_1TxDescCache_a9db8e95f501ae2399c15308b5fd40905}{tsoDescBytesUsed}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classIGbE_1_1TxDescCache_a4e886802f97241586f0f9e59d4d3b27e}{tsoCopyBytes}
\item 
int \hyperlink{classIGbE_1_1TxDescCache_a50260682f8c2508080a0c2c51727b40c}{tsoPkts}
\end{DoxyCompactItemize}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classIGbE_1_1TxDescCache_a5c53fad45a69d0f3c20bd08b980a2485}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!TxDescCache@{TxDescCache}}
\index{TxDescCache@{TxDescCache}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{TxDescCache}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TxDescCache} ({\bf IGbE} $\ast$ {\em i}, \/  std::string {\em n}, \/  int {\em s})}}
\label{classIGbE_1_1TxDescCache_a5c53fad45a69d0f3c20bd08b980a2485}



\begin{DoxyCode}
1542     : DescCache<TxDesc>(i,n, s), pktDone(false), isTcp(false),
1543       pktWaiting(false), completionAddress(0), completionEnabled(false),
1544       useTso(false), tsoHeaderLen(0), tsoMss(0), tsoTotalLen(0), tsoUsedLen(0),
1545       tsoPrevSeq(0), tsoPktPayloadBytes(0), tsoLoadedHeader(false),
1546       tsoPktHasHeader(false), tsoDescBytesUsed(0), tsoCopyBytes(0), tsoPkts(0),
1547       pktEvent(this), headerEvent(this), nullEvent(this)
1548 {
1549     annSmFetch = "TX Desc Fetch";
1550     annSmWb = "TX Desc Writeback";
1551     annUnusedDescQ = "TX Unused Descriptors";
1552     annUnusedCacheQ = "TX Unused Descriptor Cache";
1553     annUsedCacheQ = "TX Used Descriptor Cache";
1554     annUsedDescQ = "TX Used Descriptors";
1555     annDescQ = "TX Descriptors";
1556 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classIGbE_1_1TxDescCache_a32bbafeff677d291df2eb9247a33b292}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!actionAfterWb@{actionAfterWb}}
\index{actionAfterWb@{actionAfterWb}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{actionAfterWb}]{\setlength{\rightskip}{0pt plus 5cm}void actionAfterWb ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a32bbafeff677d291df2eb9247a33b292}


\hyperlink{classIGbE_1_1DescCache_a22d736f39e553f2f93799dc2e0eea912}{DescCache$<$ iGbReg::TxDesc $>$}を再定義しています。


\begin{DoxyCode}
1948 {
1949     DPRINTF(EthernetDesc, "actionAfterWb() completionEnabled: %d\n",
1950             completionEnabled);
1951     igbe->postInterrupt(iGbReg::IT_TXDW);
1952     if (completionEnabled) { 
1953         descEnd = igbe->regs.tdh();
1954         DPRINTF(EthernetDesc,
1955                 "Completion writing back value: %d to addr: %#x\n", descEnd,
1956                 completionAddress);
1957         igbe->dmaWrite(pciToDma(mbits(completionAddress, 63, 2)),
1958                        sizeof(descEnd), &nullEvent, (uint8_t*)&descEnd, 0);
1959     }
1960 }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_a10c4245eaf8149b42c17bb6aa4a7c5eb}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!completionWriteback@{completionWriteback}}
\index{completionWriteback@{completionWriteback}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{completionWriteback}]{\setlength{\rightskip}{0pt plus 5cm}void completionWriteback ({\bf Addr} {\em a}, \/  bool {\em enabled})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a10c4245eaf8149b42c17bb6aa4a7c5eb}



\begin{DoxyCode}
487                                                        {
488             DPRINTF(EthernetDesc,
489                     "Completion writeback Addr: %#x enabled: %d\n", 
490                     a, enabled);
491             completionAddress = a;
492             completionEnabled = enabled;
493         }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_ae5a77c90557026fdf4fd78883f92bef9}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!descBase@{descBase}}
\index{descBase@{descBase}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{descBase}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Addr} descBase () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_ae5a77c90557026fdf4fd78883f92bef9}


\hyperlink{classIGbE_1_1DescCache_aa8bdc83aee2be5e0eaa7a1f7f1f284e2}{DescCache$<$ iGbReg::TxDesc $>$}を実装しています。


\begin{DoxyCode}
401 { return igbe->regs.tdba(); }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_af3d1877b6f30bdf98b95351c38d400f3}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!descHead@{descHead}}
\index{descHead@{descHead}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{descHead}]{\setlength{\rightskip}{0pt plus 5cm}virtual long descHead () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_af3d1877b6f30bdf98b95351c38d400f3}


\hyperlink{classIGbE_1_1DescCache_af413050780b6b8b2fe0793fff12037e3}{DescCache$<$ iGbReg::TxDesc $>$}を実装しています。


\begin{DoxyCode}
402 { return igbe->regs.tdh(); }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_a6fb0bd6d34eae6de55fb211662f92180}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!descInBlock@{descInBlock}}
\index{descInBlock@{descInBlock}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{descInBlock}]{\setlength{\rightskip}{0pt plus 5cm}unsigned descInBlock (unsigned {\em num\_\-desc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a6fb0bd6d34eae6de55fb211662f92180}
Return the number of dsecriptors in a cache block for threshold operations. 


\begin{DoxyCode}
455         {
456             return num_desc / igbe->cacheBlockSize() / sizeof(iGbReg::TxDesc);
457         }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_a465e4e31be3a89db3d7f9cd1ecc40064}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!descLen@{descLen}}
\index{descLen@{descLen}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{descLen}]{\setlength{\rightskip}{0pt plus 5cm}virtual long descLen () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a465e4e31be3a89db3d7f9cd1ecc40064}


\hyperlink{classIGbE_1_1DescCache_a8eb35163568b01fa17aa47b23a80f90c}{DescCache$<$ iGbReg::TxDesc $>$}を実装しています。


\begin{DoxyCode}
404 { return igbe->regs.tdlen() >> 4; }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_a4b6b769be62592fc43518ba480bbd1f7}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!descTail@{descTail}}
\index{descTail@{descTail}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{descTail}]{\setlength{\rightskip}{0pt plus 5cm}virtual long descTail () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a4b6b769be62592fc43518ba480bbd1f7}


\hyperlink{classIGbE_1_1DescCache_a88ebc5d9eb88ca9148465557e9a66c1c}{DescCache$<$ iGbReg::TxDesc $>$}を実装しています。


\begin{DoxyCode}
403 { return igbe->regs.tdt(); }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_aec7fdcc540223076999e0f8f07f854bc}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!enableSm@{enableSm}}
\index{enableSm@{enableSm}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{enableSm}]{\setlength{\rightskip}{0pt plus 5cm}void enableSm ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_aec7fdcc540223076999e0f8f07f854bc}


\hyperlink{classIGbE_1_1DescCache_a9b931707aadb26e13262c50e0dd87006}{DescCache$<$ iGbReg::TxDesc $>$}を実装しています。


\begin{DoxyCode}
2030 {
2031     if (!igbe->drainManager) {
2032         igbe->txTick = true;
2033         igbe->restartClock();
2034     }
2035 }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_abb8070fbcfa38a9697d92bbc4a0b6505}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!fetchAfterWb@{fetchAfterWb}}
\index{fetchAfterWb@{fetchAfterWb}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{fetchAfterWb}]{\setlength{\rightskip}{0pt plus 5cm}virtual void fetchAfterWb ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_abb8070fbcfa38a9697d92bbc4a0b6505}


\hyperlink{classIGbE_1_1DescCache_abe568c102619a35d2aa1a37c64dff086}{DescCache$<$ iGbReg::TxDesc $>$}を実装しています。


\begin{DoxyCode}
408                                     {
409             if (!igbe->txTick && igbe->getDrainState() == Drainable::Running)
410                 fetchDescriptors();
411         }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_af58491ad4f774a610584c404231b30ae}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!getPacketData@{getPacketData}}
\index{getPacketData@{getPacketData}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{getPacketData}]{\setlength{\rightskip}{0pt plus 5cm}void getPacketData ({\bf EthPacketPtr} {\em p})}}
\label{classIGbE_1_1TxDescCache_af58491ad4f774a610584c404231b30ae}



\begin{DoxyCode}
1702 {
1703     assert(unusedCache.size());
1704 
1705     TxDesc *desc;
1706     desc = unusedCache.front();
1707 
1708     DPRINTF(EthernetDesc, "getPacketData(): TxDescriptor data "
1709             "d1: %#llx d2: %#llx\n", desc->d1, desc->d2);
1710     assert((TxdOp::isLegacy(desc) || TxdOp::isData(desc)) &&
1711            TxdOp::getLen(desc));
1712 
1713     pktPtr = p;
1714 
1715     pktWaiting = true;
1716 
1717     DPRINTF(EthernetDesc, "Starting DMA of packet at offset %d\n", p->length);
1718     
1719     if (useTso) {
1720         assert(tsoLoadedHeader);
1721         if (!tsoPktHasHeader) {
1722             DPRINTF(EthernetDesc,
1723                     "Loading TSO header (%d bytes) into start of packet\n",
1724                     tsoHeaderLen);
1725             memcpy(p->data, &tsoHeader,tsoHeaderLen);
1726             p->length +=tsoHeaderLen;
1727             tsoPktHasHeader = true;
1728         }
1729     }
1730   
1731     if (useTso) {
1732         DPRINTF(EthernetDesc,
1733                 "Starting DMA of packet at offset %d length: %d\n",
1734                 p->length, tsoCopyBytes);
1735         igbe->dmaRead(pciToDma(TxdOp::getBuf(desc))
1736                       + tsoDescBytesUsed,
1737                       tsoCopyBytes, &pktEvent, p->data + p->length,
1738                       igbe->txReadDelay);
1739         tsoDescBytesUsed += tsoCopyBytes;
1740         assert(tsoDescBytesUsed <= TxdOp::getLen(desc));
1741     } else {
1742         igbe->dmaRead(pciToDma(TxdOp::getBuf(desc)),
1743                       TxdOp::getLen(desc), &pktEvent, p->data + p->length,
1744                       igbe->txReadDelay);
1745     }
1746 }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_a924187a1c689184efd8492916ca12e32}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!getPacketSize@{getPacketSize}}
\index{getPacketSize@{getPacketSize}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{getPacketSize}]{\setlength{\rightskip}{0pt plus 5cm}unsigned getPacketSize ({\bf EthPacketPtr} {\em p})}}
\label{classIGbE_1_1TxDescCache_a924187a1c689184efd8492916ca12e32}
Tell the cache to DMA a packet from main memory into its buffer and return the size the of the packet to reserve space in tx fifo. \begin{DoxyReturn}{戻り値}
size of the packet 
\end{DoxyReturn}



\begin{DoxyCode}
1662 {
1663     if (!unusedCache.size())
1664         return 0;
1665  
1666     DPRINTF(EthernetDesc, "Starting processing of descriptor\n");
1667 
1668     assert(!useTso || tsoLoadedHeader);
1669     TxDesc *desc = unusedCache.front();
1670 
1671     if (useTso) {
1672         DPRINTF(EthernetDesc, "getPacket(): TxDescriptor data "
1673                 "d1: %#llx d2: %#llx\n", desc->d1, desc->d2);
1674         DPRINTF(EthernetDesc, "TSO: use: %d hdrlen: %d mss: %d total: %d "
1675                 "used: %d loaded hdr: %d\n", useTso, tsoHeaderLen, tsoMss,
1676                 tsoTotalLen, tsoUsedLen, tsoLoadedHeader);
1677 
1678         if (tsoPktHasHeader) 
1679             tsoCopyBytes =  std::min((tsoMss + tsoHeaderLen) - p->length,
1680                                      TxdOp::getLen(desc) - tsoDescBytesUsed);
1681         else
1682             tsoCopyBytes =  std::min(tsoMss,
1683                                      TxdOp::getLen(desc) - tsoDescBytesUsed); 
1684         unsigned pkt_size =
1685             tsoCopyBytes + (tsoPktHasHeader ? 0 : tsoHeaderLen); 
1686 
1687         DPRINTF(EthernetDesc, "TSO: descBytesUsed: %d copyBytes: %d "
1688                 "this descLen: %d\n",
1689                 tsoDescBytesUsed, tsoCopyBytes, TxdOp::getLen(desc));
1690         DPRINTF(EthernetDesc, "TSO: pktHasHeader: %d\n", tsoPktHasHeader);
1691         DPRINTF(EthernetDesc, "TSO: Next packet is %d bytes\n", pkt_size);
1692         return pkt_size;
1693     }
1694 
1695     DPRINTF(EthernetDesc, "Next TX packet is %d bytes\n",
1696             TxdOp::getLen(unusedCache.front()));
1697     return TxdOp::getLen(desc);
1698 }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_a2587421ae644a9474416e5a5b63ccbca}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!hasOutstandingEvents@{hasOutstandingEvents}}
\index{hasOutstandingEvents@{hasOutstandingEvents}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{hasOutstandingEvents}]{\setlength{\rightskip}{0pt plus 5cm}bool hasOutstandingEvents ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a2587421ae644a9474416e5a5b63ccbca}


\hyperlink{classIGbE_1_1DescCache_a09989bc9720a200c8164dc1ef109d70b}{DescCache$<$ iGbReg::TxDesc $>$}を再定義しています。


\begin{DoxyCode}
2039 {
2040     return pktEvent.scheduled() || wbEvent.scheduled() ||
2041         fetchEvent.scheduled();
2042 }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_ae7e4853724fee8019b3bdd04200b9d6b}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!headerComplete@{headerComplete}}
\index{headerComplete@{headerComplete}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{headerComplete}]{\setlength{\rightskip}{0pt plus 5cm}void headerComplete ()}}
\label{classIGbE_1_1TxDescCache_ae7e4853724fee8019b3bdd04200b9d6b}



\begin{DoxyCode}
1637 {
1638     DPRINTF(EthernetDesc, "TSO: Fetching TSO header complete\n");
1639     pktWaiting = false;
1640 
1641     assert(unusedCache.size());
1642     TxDesc *desc = unusedCache.front();
1643     DPRINTF(EthernetDesc, "TSO: len: %d tsoHeaderLen: %d\n",
1644             TxdOp::getLen(desc), tsoHeaderLen);
1645 
1646     if (TxdOp::getLen(desc) == tsoHeaderLen) {
1647         tsoDescBytesUsed = 0;
1648         tsoLoadedHeader = true;
1649         unusedCache.pop_front();
1650         usedCache.push_back(desc);
1651     } else {
1652         DPRINTF(EthernetDesc, "TSO: header part of larger payload\n");
1653         tsoDescBytesUsed = tsoHeaderLen;
1654         tsoLoadedHeader = true;
1655     }
1656     enableSm();
1657     igbe->checkDrain();
1658 }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_a34032325b571ff60682217adbf73ad37}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!nullCallback@{nullCallback}}
\index{nullCallback@{nullCallback}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{nullCallback}]{\setlength{\rightskip}{0pt plus 5cm}void nullCallback ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a34032325b571ff60682217adbf73ad37}



\begin{DoxyCode}
497                             {
498             DPRINTF(EthernetDesc, "Completion writeback complete\n");
499         }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_a3fd3cdfc66306ff22b53325aeb4e2c64}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!packetAvailable@{packetAvailable}}
\index{packetAvailable@{packetAvailable}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{packetAvailable}]{\setlength{\rightskip}{0pt plus 5cm}bool packetAvailable ()}}
\label{classIGbE_1_1TxDescCache_a3fd3cdfc66306ff22b53325aeb4e2c64}
Ask if the packet has been transfered so the state machine can give it to the fifo. \begin{DoxyReturn}{戻り値}
packet available in descriptor cache 
\end{DoxyReturn}



\begin{DoxyCode}
2020 {
2021     if (pktDone) {
2022         pktDone = false;
2023         return true;
2024     }
2025     return false;
2026 }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_a126e4d9db081d9783bdcf86befdff3de}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!packetMultiDesc@{packetMultiDesc}}
\index{packetMultiDesc@{packetMultiDesc}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{packetMultiDesc}]{\setlength{\rightskip}{0pt plus 5cm}bool packetMultiDesc ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a126e4d9db081d9783bdcf86befdff3de}
Ask if this packet is composed of multiple descriptors so even if we've got data, we need to wait for more before we can send it out. \begin{DoxyReturn}{戻り値}
packet can't be sent out because it's a multi-\/descriptor packet 
\end{DoxyReturn}



\begin{DoxyCode}
476 { return pktMultiDesc;}
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_ad8a4f7d1ef74ba318f35597c58bc757b}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!packetWaiting@{packetWaiting}}
\index{packetWaiting@{packetWaiting}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{packetWaiting}]{\setlength{\rightskip}{0pt plus 5cm}bool packetWaiting ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_ad8a4f7d1ef74ba318f35597c58bc757b}
Ask if we are still waiting for the packet to be transfered. \begin{DoxyReturn}{戻り値}
packet still in transit. 
\end{DoxyReturn}



\begin{DoxyCode}
468 { return pktWaiting; }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_a4f0881be8aa8698e16dcf52a89085100}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!pktComplete@{pktComplete}}
\index{pktComplete@{pktComplete}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{pktComplete}]{\setlength{\rightskip}{0pt plus 5cm}void pktComplete ()}}
\label{classIGbE_1_1TxDescCache_a4f0881be8aa8698e16dcf52a89085100}
Called by event when dma to write packet is completed 


\begin{DoxyCode}
1750 {
1751 
1752     TxDesc *desc;
1753     assert(unusedCache.size());
1754     assert(pktPtr);
1755 
1756     igbe->anBegin("TXS", "Update Desc");
1757 
1758     DPRINTF(EthernetDesc, "DMA of packet complete\n");
1759 
1760 
1761     desc = unusedCache.front();
1762     assert((TxdOp::isLegacy(desc) || TxdOp::isData(desc)) &&
1763            TxdOp::getLen(desc));
1764 
1765     DPRINTF(EthernetDesc, "TxDescriptor data d1: %#llx d2: %#llx\n",
1766             desc->d1, desc->d2);
1767 
1768     // Set the length of the data in the EtherPacket
1769     if (useTso) {
1770         DPRINTF(EthernetDesc, "TSO: use: %d hdrlen: %d mss: %d total: %d "
1771             "used: %d loaded hdr: %d\n", useTso, tsoHeaderLen, tsoMss,
1772             tsoTotalLen, tsoUsedLen, tsoLoadedHeader);
1773         pktPtr->length += tsoCopyBytes;
1774         tsoUsedLen += tsoCopyBytes;
1775         DPRINTF(EthernetDesc, "TSO: descBytesUsed: %d copyBytes: %d\n",
1776             tsoDescBytesUsed, tsoCopyBytes);
1777     } else
1778         pktPtr->length += TxdOp::getLen(desc);
1779     
1780 
1781 
1782     if ((!TxdOp::eop(desc) && !useTso) || 
1783         (pktPtr->length < ( tsoMss + tsoHeaderLen) &&
1784          tsoTotalLen != tsoUsedLen && useTso)) {
1785         assert(!useTso || (tsoDescBytesUsed == TxdOp::getLen(desc)));
1786         igbe->anDq("TXS", annUnusedCacheQ);
1787         unusedCache.pop_front();
1788         igbe->anQ("TXS", annUsedCacheQ);
1789         usedCache.push_back(desc);
1790 
1791         tsoDescBytesUsed = 0;
1792         pktDone = true;
1793         pktWaiting = false;
1794         pktMultiDesc = true;
1795 
1796         DPRINTF(EthernetDesc, "Partial Packet Descriptor of %d bytes Done\n",
1797                 pktPtr->length);
1798         pktPtr = NULL;
1799 
1800         enableSm();
1801         igbe->checkDrain();
1802         return;
1803     }
1804 
1805 
1806     pktMultiDesc = false;
1807     // no support for vlans
1808     assert(!TxdOp::vle(desc));
1809 
1810     // we only support single packet descriptors at this point
1811     if (!useTso)
1812         assert(TxdOp::eop(desc));
1813 
1814     // set that this packet is done
1815     if (TxdOp::rs(desc))
1816         TxdOp::setDd(desc);
1817 
1818     DPRINTF(EthernetDesc, "TxDescriptor data d1: %#llx d2: %#llx\n",
1819             desc->d1, desc->d2);
1820 
1821     if (useTso) {
1822         IpPtr ip(pktPtr);
1823         if (ip) {
1824             DPRINTF(EthernetDesc, "TSO: Modifying IP header. Id + %d\n",
1825                     tsoPkts);
1826             ip->id(ip->id() + tsoPkts++);
1827             ip->len(pktPtr->length - EthPtr(pktPtr)->size()); 
1828         
1829             TcpPtr tcp(ip);
1830             if (tcp) {
1831                 DPRINTF(EthernetDesc,
1832                         "TSO: Modifying TCP header. old seq %d + %d\n",
1833                         tcp->seq(), tsoPrevSeq);
1834                 tcp->seq(tcp->seq() + tsoPrevSeq);
1835                 if (tsoUsedLen != tsoTotalLen)
1836                     tcp->flags(tcp->flags() & ~9); // clear fin & psh
1837             }
1838             UdpPtr udp(ip);
1839             if (udp) {
1840                 DPRINTF(EthernetDesc, "TSO: Modifying UDP header.\n");
1841                 udp->len(pktPtr->length - EthPtr(pktPtr)->size());
1842             }
1843         }
1844         tsoPrevSeq = tsoUsedLen;
1845     }
1846 
1847     if (DTRACE(EthernetDesc)) {
1848         IpPtr ip(pktPtr);
1849         if (ip)
1850             DPRINTF(EthernetDesc, "Proccesing Ip packet with Id=%d\n",
1851                     ip->id());
1852         else
1853             DPRINTF(EthernetSM, "Proccesing Non-Ip packet\n");
1854     }
1855 
1856     // Checksums are only ofloaded for new descriptor types
1857     if (TxdOp::isData(desc) && ( TxdOp::ixsm(desc) || TxdOp::txsm(desc)) ) {
1858         DPRINTF(EthernetDesc, "Calculating checksums for packet\n");
1859         IpPtr ip(pktPtr);
1860         assert(ip);
1861         if (TxdOp::ixsm(desc)) {
1862             ip->sum(0);
1863             ip->sum(cksum(ip));
1864             igbe->txIpChecksums++;
1865             DPRINTF(EthernetDesc, "Calculated IP checksum\n");
1866         }
1867         if (TxdOp::txsm(desc)) {
1868             TcpPtr tcp(ip);
1869             UdpPtr udp(ip);
1870             if (tcp) {
1871                 tcp->sum(0);
1872                 tcp->sum(cksum(tcp));
1873                 igbe->txTcpChecksums++;
1874                 DPRINTF(EthernetDesc, "Calculated TCP checksum\n");
1875             } else if (udp) {
1876                 assert(udp);
1877                 udp->sum(0);
1878                 udp->sum(cksum(udp));
1879                 igbe->txUdpChecksums++;
1880                 DPRINTF(EthernetDesc, "Calculated UDP checksum\n");
1881             } else {
1882                 panic("Told to checksum, but don't know how\n");
1883             }
1884         }
1885     }
1886 
1887     if (TxdOp::ide(desc)) {
1888         // Deal with the rx timer interrupts
1889         DPRINTF(EthernetDesc, "Descriptor had IDE set\n");
1890         if (igbe->regs.tidv.idv()) {
1891             Tick delay = igbe->regs.tidv.idv() * igbe->intClock();
1892             DPRINTF(EthernetDesc, "setting tidv\n");
1893             igbe->reschedule(igbe->tidvEvent, curTick() + delay, true);
1894         }
1895 
1896         if (igbe->regs.tadv.idv() && igbe->regs.tidv.idv()) {
1897             Tick delay = igbe->regs.tadv.idv() * igbe->intClock();
1898             DPRINTF(EthernetDesc, "setting tadv\n");
1899             if (!igbe->tadvEvent.scheduled()) {
1900                 igbe->schedule(igbe->tadvEvent, curTick() + delay);
1901             }
1902         }
1903     }
1904 
1905 
1906     if (!useTso ||  TxdOp::getLen(desc) == tsoDescBytesUsed) {
1907         DPRINTF(EthernetDesc, "Descriptor Done\n");
1908         igbe->anDq("TXS", annUnusedCacheQ);
1909         unusedCache.pop_front();
1910         igbe->anQ("TXS", annUsedCacheQ);
1911         usedCache.push_back(desc);
1912         tsoDescBytesUsed = 0;
1913     }
1914 
1915     if (useTso && tsoUsedLen == tsoTotalLen)
1916         useTso = false;
1917 
1918 
1919     DPRINTF(EthernetDesc,
1920             "------Packet of %d bytes ready for transmission-------\n",
1921             pktPtr->length);
1922     pktDone = true;
1923     pktWaiting = false;
1924     pktPtr = NULL;
1925     tsoPktHasHeader = false;
1926 
1927     if (igbe->regs.txdctl.wthresh() == 0) {
1928         igbe->anBegin("TXS", "Desc Writeback");
1929         DPRINTF(EthernetDesc, "WTHRESH == 0, writing back descriptor\n");
1930         writeback(0);
1931     } else if (!igbe->regs.txdctl.gran() && igbe->regs.txdctl.wthresh() <=
1932                descInBlock(usedCache.size())) {
1933         DPRINTF(EthernetDesc, "used > WTHRESH, writing back descriptor\n");
1934         igbe->anBegin("TXS", "Desc Writeback");
1935         writeback((igbe->cacheBlockSize()-1)>>4);
1936     } else if (igbe->regs.txdctl.wthresh() <= usedCache.size()) {
1937         DPRINTF(EthernetDesc, "used > WTHRESH, writing back descriptor\n");
1938         igbe->anBegin("TXS", "Desc Writeback");
1939         writeback((igbe->cacheBlockSize()-1)>>4);
1940     }
1941 
1942     enableSm();
1943     igbe->checkDrain();
1944 }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_af7a2e6e84647ba93598a7a02730cba41}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!processContextDesc@{processContextDesc}}
\index{processContextDesc@{processContextDesc}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{processContextDesc}]{\setlength{\rightskip}{0pt plus 5cm}void processContextDesc ()}}
\label{classIGbE_1_1TxDescCache_af7a2e6e84647ba93598a7a02730cba41}



\begin{DoxyCode}
1560 {
1561     assert(unusedCache.size());
1562     TxDesc *desc;
1563     
1564     DPRINTF(EthernetDesc, "Checking and  processing context descriptors\n");
1565 
1566     while (!useTso && unusedCache.size() &&
1567            TxdOp::isContext(unusedCache.front())) {
1568         DPRINTF(EthernetDesc, "Got context descriptor type...\n");
1569 
1570         desc = unusedCache.front();
1571         DPRINTF(EthernetDesc, "Descriptor upper: %#x lower: %#X\n", 
1572                 desc->d1, desc->d2);
1573 
1574         
1575         // is this going to be a tcp or udp packet?
1576         isTcp = TxdOp::tcp(desc) ? true : false;
1577 
1578         // setup all the TSO variables, they'll be ignored if we don't use 
1579         // tso for this connection
1580         tsoHeaderLen = TxdOp::hdrlen(desc);
1581         tsoMss  = TxdOp::mss(desc);
1582 
1583         if (TxdOp::isType(desc, TxdOp::TXD_CNXT) && TxdOp::tse(desc)) {
1584             DPRINTF(EthernetDesc, "TCP offload enabled for packet hdrlen: "
1585                     "%d mss: %d paylen %d\n", TxdOp::hdrlen(desc),
1586                     TxdOp::mss(desc), TxdOp::getLen(desc));
1587             useTso = true;
1588             tsoTotalLen = TxdOp::getLen(desc);
1589             tsoLoadedHeader = false;
1590             tsoDescBytesUsed = 0;
1591             tsoUsedLen = 0;
1592             tsoPrevSeq = 0;
1593             tsoPktHasHeader = false;
1594             tsoPkts = 0;
1595             tsoCopyBytes = 0;
1596         }
1597 
1598         TxdOp::setDd(desc);
1599         unusedCache.pop_front();
1600         igbe->anDq("TXS", annUnusedCacheQ);
1601         usedCache.push_back(desc);
1602         igbe->anQ("TXS", annUsedCacheQ);
1603     }
1604 
1605     if (!unusedCache.size())
1606         return;
1607 
1608     desc = unusedCache.front();
1609     if (!useTso && TxdOp::isType(desc, TxdOp::TXD_ADVDATA) && 
1610         TxdOp::tse(desc)) {
1611         DPRINTF(EthernetDesc, "TCP offload(adv) enabled for packet "
1612                 "hdrlen: %d mss: %d paylen %d\n", 
1613                 tsoHeaderLen, tsoMss, TxdOp::getTsoLen(desc));
1614         useTso = true;
1615         tsoTotalLen = TxdOp::getTsoLen(desc);
1616         tsoLoadedHeader = false;
1617         tsoDescBytesUsed = 0;
1618         tsoUsedLen = 0;
1619         tsoPrevSeq = 0;
1620         tsoPktHasHeader = false;
1621         tsoPkts = 0;
1622     }
1623 
1624     if (useTso && !tsoLoadedHeader) {
1625         // we need to fetch a header
1626         DPRINTF(EthernetDesc, "Starting DMA of TSO header\n");
1627         assert(TxdOp::isData(desc) && TxdOp::getLen(desc) >= tsoHeaderLen);
1628         pktWaiting = true;
1629         assert(tsoHeaderLen <= 256);
1630         igbe->dmaRead(pciToDma(TxdOp::getBuf(desc)),
1631                       tsoHeaderLen, &headerEvent, tsoHeader, 0);
1632     }
1633 }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_a53e036786d17361be4c7320d39c99b84}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!serialize@{serialize}}
\index{serialize@{serialize}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a53e036786d17361be4c7320d39c99b84}


\hyperlink{classIGbE_1_1DescCache_a53e036786d17361be4c7320d39c99b84}{DescCache$<$ iGbReg::TxDesc $>$}を再定義しています。


\begin{DoxyCode}
1964 {
1965     DescCache<TxDesc>::serialize(os);
1966     SERIALIZE_SCALAR(pktDone);
1967     SERIALIZE_SCALAR(isTcp);
1968     SERIALIZE_SCALAR(pktWaiting);
1969     SERIALIZE_SCALAR(pktMultiDesc);
1970 
1971     SERIALIZE_SCALAR(useTso);
1972     SERIALIZE_SCALAR(tsoHeaderLen);
1973     SERIALIZE_SCALAR(tsoMss);
1974     SERIALIZE_SCALAR(tsoTotalLen);
1975     SERIALIZE_SCALAR(tsoUsedLen);
1976     SERIALIZE_SCALAR(tsoPrevSeq);;
1977     SERIALIZE_SCALAR(tsoPktPayloadBytes);
1978     SERIALIZE_SCALAR(tsoLoadedHeader);
1979     SERIALIZE_SCALAR(tsoPktHasHeader);
1980     SERIALIZE_ARRAY(tsoHeader, 256);
1981     SERIALIZE_SCALAR(tsoDescBytesUsed);
1982     SERIALIZE_SCALAR(tsoCopyBytes);
1983     SERIALIZE_SCALAR(tsoPkts);
1984 
1985     SERIALIZE_SCALAR(completionAddress);
1986     SERIALIZE_SCALAR(completionEnabled);
1987     SERIALIZE_SCALAR(descEnd);
1988 }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_af22e5d6d660b97db37003ac61ac4ee49}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_af22e5d6d660b97db37003ac61ac4ee49}


\hyperlink{classIGbE_1_1DescCache_af22e5d6d660b97db37003ac61ac4ee49}{DescCache$<$ iGbReg::TxDesc $>$}を再定義しています。


\begin{DoxyCode}
1992 {
1993     DescCache<TxDesc>::unserialize(cp, section);
1994     UNSERIALIZE_SCALAR(pktDone);
1995     UNSERIALIZE_SCALAR(isTcp);
1996     UNSERIALIZE_SCALAR(pktWaiting);
1997     UNSERIALIZE_SCALAR(pktMultiDesc);
1998 
1999     UNSERIALIZE_SCALAR(useTso);
2000     UNSERIALIZE_SCALAR(tsoHeaderLen);
2001     UNSERIALIZE_SCALAR(tsoMss);
2002     UNSERIALIZE_SCALAR(tsoTotalLen);
2003     UNSERIALIZE_SCALAR(tsoUsedLen);
2004     UNSERIALIZE_SCALAR(tsoPrevSeq);;
2005     UNSERIALIZE_SCALAR(tsoPktPayloadBytes);
2006     UNSERIALIZE_SCALAR(tsoLoadedHeader);
2007     UNSERIALIZE_SCALAR(tsoPktHasHeader);
2008     UNSERIALIZE_ARRAY(tsoHeader, 256);
2009     UNSERIALIZE_SCALAR(tsoDescBytesUsed);
2010     UNSERIALIZE_SCALAR(tsoCopyBytes);
2011     UNSERIALIZE_SCALAR(tsoPkts);
2012 
2013     UNSERIALIZE_SCALAR(completionAddress);
2014     UNSERIALIZE_SCALAR(completionEnabled);
2015     UNSERIALIZE_SCALAR(descEnd);
2016 }
\end{DoxyCode}
\hypertarget{classIGbE_1_1TxDescCache_a4f8dbb4f64167626cac110753708c55c}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!updateHead@{updateHead}}
\index{updateHead@{updateHead}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{updateHead}]{\setlength{\rightskip}{0pt plus 5cm}virtual void updateHead (long {\em h})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a4f8dbb4f64167626cac110753708c55c}


\hyperlink{classIGbE_1_1DescCache_af48912789332a0283480cd85c7197f15}{DescCache$<$ iGbReg::TxDesc $>$}を実装しています。


\begin{DoxyCode}
405 { igbe->regs.tdh(h); }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classIGbE_1_1TxDescCache_a9bad25394212b8c9bf19b5b3fd692d7a}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!completionAddress@{completionAddress}}
\index{completionAddress@{completionAddress}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{completionAddress}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf completionAddress}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a9bad25394212b8c9bf19b5b3fd692d7a}
\hypertarget{classIGbE_1_1TxDescCache_ad3481e86d121444fdcc4b02650d38e47}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!completionEnabled@{completionEnabled}}
\index{completionEnabled@{completionEnabled}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{completionEnabled}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf completionEnabled}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_ad3481e86d121444fdcc4b02650d38e47}
\hypertarget{classIGbE_1_1TxDescCache_a487a3ccede49d6015e8e320bcd5b29e7}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!descEnd@{descEnd}}
\index{descEnd@{descEnd}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{descEnd}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf descEnd}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a487a3ccede49d6015e8e320bcd5b29e7}
\hypertarget{classIGbE_1_1TxDescCache_ae7a8388f5aa169f8c86c19f91c3b128d}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!headerEvent@{headerEvent}}
\index{headerEvent@{headerEvent}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{headerEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf TxDescCache}, \&TxDescCache::headerComplete$>$ {\bf headerEvent}}}
\label{classIGbE_1_1TxDescCache_ae7a8388f5aa169f8c86c19f91c3b128d}
\hypertarget{classIGbE_1_1TxDescCache_ad610366c4a18d924d4962433c0b8515e}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!isTcp@{isTcp}}
\index{isTcp@{isTcp}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{isTcp}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf isTcp}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_ad610366c4a18d924d4962433c0b8515e}
\hypertarget{classIGbE_1_1TxDescCache_adc0e7fe81737dc40daddf8391bffae79}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!nullEvent@{nullEvent}}
\index{nullEvent@{nullEvent}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{nullEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf TxDescCache}, \&TxDescCache::nullCallback$>$ {\bf nullEvent}}}
\label{classIGbE_1_1TxDescCache_adc0e7fe81737dc40daddf8391bffae79}
\hypertarget{classIGbE_1_1TxDescCache_a0807bda2e863c4492ab0165135bf396c}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!pktDone@{pktDone}}
\index{pktDone@{pktDone}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{pktDone}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf pktDone}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a0807bda2e863c4492ab0165135bf396c}
\hypertarget{classIGbE_1_1TxDescCache_a2a06f4aa962fc09e9e764d3e9006d11b}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!pktEvent@{pktEvent}}
\index{pktEvent@{pktEvent}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{pktEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf TxDescCache}, \&TxDescCache::pktComplete$>$ {\bf pktEvent}}}
\label{classIGbE_1_1TxDescCache_a2a06f4aa962fc09e9e764d3e9006d11b}
\hypertarget{classIGbE_1_1TxDescCache_adb0830579bf508fe91ec42f51928ca5d}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!pktMultiDesc@{pktMultiDesc}}
\index{pktMultiDesc@{pktMultiDesc}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{pktMultiDesc}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf pktMultiDesc}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_adb0830579bf508fe91ec42f51928ca5d}
\hypertarget{classIGbE_1_1TxDescCache_a584d7923b741a0ed4ae9c59b8ab254ad}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!pktWaiting@{pktWaiting}}
\index{pktWaiting@{pktWaiting}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{pktWaiting}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf pktWaiting}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a584d7923b741a0ed4ae9c59b8ab254ad}
\hypertarget{classIGbE_1_1TxDescCache_a4e886802f97241586f0f9e59d4d3b27e}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!tsoCopyBytes@{tsoCopyBytes}}
\index{tsoCopyBytes@{tsoCopyBytes}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{tsoCopyBytes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf tsoCopyBytes}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a4e886802f97241586f0f9e59d4d3b27e}
\hypertarget{classIGbE_1_1TxDescCache_a9db8e95f501ae2399c15308b5fd40905}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!tsoDescBytesUsed@{tsoDescBytesUsed}}
\index{tsoDescBytesUsed@{tsoDescBytesUsed}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{tsoDescBytesUsed}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf tsoDescBytesUsed}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a9db8e95f501ae2399c15308b5fd40905}
\hypertarget{classIGbE_1_1TxDescCache_a3309d8f5e1d64bb4d1ce8a654d406094}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!tsoHeader@{tsoHeader}}
\index{tsoHeader@{tsoHeader}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{tsoHeader}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf tsoHeader}\mbox{[}256\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a3309d8f5e1d64bb4d1ce8a654d406094}
\hypertarget{classIGbE_1_1TxDescCache_abdc8c249b4ac1dcba87bb5dd61aad6b4}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!tsoHeaderLen@{tsoHeaderLen}}
\index{tsoHeaderLen@{tsoHeaderLen}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{tsoHeaderLen}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf tsoHeaderLen}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_abdc8c249b4ac1dcba87bb5dd61aad6b4}
\hypertarget{classIGbE_1_1TxDescCache_aea6ed56838e016f0ad81353c348b62cb}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!tsoLoadedHeader@{tsoLoadedHeader}}
\index{tsoLoadedHeader@{tsoLoadedHeader}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{tsoLoadedHeader}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf tsoLoadedHeader}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_aea6ed56838e016f0ad81353c348b62cb}
\hypertarget{classIGbE_1_1TxDescCache_a140f29bf479ea15261618bed60b9f777}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!tsoMss@{tsoMss}}
\index{tsoMss@{tsoMss}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{tsoMss}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf tsoMss}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a140f29bf479ea15261618bed60b9f777}
\hypertarget{classIGbE_1_1TxDescCache_a3e767a1c20550a9a1f1c04e0900475d3}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!tsoPktHasHeader@{tsoPktHasHeader}}
\index{tsoPktHasHeader@{tsoPktHasHeader}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{tsoPktHasHeader}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf tsoPktHasHeader}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a3e767a1c20550a9a1f1c04e0900475d3}
\hypertarget{classIGbE_1_1TxDescCache_a6113e9447ae2e0f5fcea17ac8b4a2fd5}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!tsoPktPayloadBytes@{tsoPktPayloadBytes}}
\index{tsoPktPayloadBytes@{tsoPktPayloadBytes}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{tsoPktPayloadBytes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf tsoPktPayloadBytes}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a6113e9447ae2e0f5fcea17ac8b4a2fd5}
\hypertarget{classIGbE_1_1TxDescCache_a50260682f8c2508080a0c2c51727b40c}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!tsoPkts@{tsoPkts}}
\index{tsoPkts@{tsoPkts}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{tsoPkts}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf tsoPkts}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a50260682f8c2508080a0c2c51727b40c}
\hypertarget{classIGbE_1_1TxDescCache_a2906204858e8f7b554a7b5a449bbb4cb}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!tsoPrevSeq@{tsoPrevSeq}}
\index{tsoPrevSeq@{tsoPrevSeq}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{tsoPrevSeq}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf tsoPrevSeq}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a2906204858e8f7b554a7b5a449bbb4cb}
\hypertarget{classIGbE_1_1TxDescCache_a94166f6af145a255d6623ebd93b0c0f5}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!tsoTotalLen@{tsoTotalLen}}
\index{tsoTotalLen@{tsoTotalLen}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{tsoTotalLen}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf tsoTotalLen}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_a94166f6af145a255d6623ebd93b0c0f5}
\hypertarget{classIGbE_1_1TxDescCache_afaeeb9d655b0c19961b86d83fc025ae5}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!tsoUsedLen@{tsoUsedLen}}
\index{tsoUsedLen@{tsoUsedLen}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{tsoUsedLen}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf tsoUsedLen}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_afaeeb9d655b0c19961b86d83fc025ae5}
\hypertarget{classIGbE_1_1TxDescCache_ae2379f1cb19d3eabcb86036c07fc7986}{
\index{IGbE::TxDescCache@{IGbE::TxDescCache}!useTso@{useTso}}
\index{useTso@{useTso}!IGbE::TxDescCache@{IGbE::TxDescCache}}
\subsubsection[{useTso}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf useTso}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1TxDescCache_ae2379f1cb19d3eabcb86036c07fc7986}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/\hyperlink{i8254xGBe_8hh}{i8254xGBe.hh}\item 
dev/\hyperlink{i8254xGBe_8cc}{i8254xGBe.cc}\end{DoxyCompactItemize}
