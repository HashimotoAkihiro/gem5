\hypertarget{classBridge_1_1BridgeSlavePort}{
\section{クラス BridgeSlavePort}
\label{classBridge_1_1BridgeSlavePort}\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
}


{\ttfamily \#include $<$bridge.hh$>$}BridgeSlavePortに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4cm]{classBridge_1_1BridgeSlavePort}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classBridge_1_1BridgeSlavePort_a2b4ad4cec25b318ebfcf261db753a8fb}{BridgeSlavePort} (const std::string \&\_\-name, \hyperlink{classBridge_1_1Bridge}{Bridge} \&\_\-bridge, \hyperlink{classBridge_1_1BridgeMasterPort}{BridgeMasterPort} \&\hyperlink{classSlavePort_a5e0f39f8e39e5b4c3dcf0991c627489b}{\_\-masterPort}, \hyperlink{classCycles}{Cycles} \_\-delay, int \_\-resp\_\-limit, \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classAddrRange}{AddrRange} $>$ \_\-ranges)
\item 
void \hyperlink{classBridge_1_1BridgeSlavePort_a31c2fe79e7cbd7319eb327074e412675}{schedTimingResp} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} when)
\item 
void \hyperlink{classBridge_1_1BridgeSlavePort_a7b3f6456ef3aa1b8dcc6d1a20652453d}{retryStalledReq} ()
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classBridge_1_1BridgeSlavePort_a3344d9dd0f83257feab5424e761f31c6}{recvTimingReq} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classBridge_1_1BridgeSlavePort_a29cb5a4f98063ce6e9210eacbdb35298}{recvRetry} ()
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classBridge_1_1BridgeSlavePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{recvAtomic} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classBridge_1_1BridgeSlavePort_aeefa907fb6d6a787e6dab90e8138ea90}{recvFunctional} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classBridge_1_1BridgeSlavePort_a36cf113d5e5e091ebddb32306c098fae}{getAddrRanges} () const 
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classBridge_1_1BridgeSlavePort_a7ca559cfc6bcef8eba87fc5a0bd0bb42}{respQueueFull} () const 
\item 
void \hyperlink{classBridge_1_1BridgeSlavePort_a391c414b53eb45782e37bc539608e477}{trySendTiming} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classBridge_1_1Bridge}{Bridge} \& \hyperlink{classBridge_1_1BridgeSlavePort_a6d3b24e49ac986064571195ab9905136}{bridge}
\item 
\hyperlink{classBridge_1_1BridgeMasterPort}{BridgeMasterPort} \& \hyperlink{classBridge_1_1BridgeSlavePort_ab67087190dd99cae7527467d6b6e7bbb}{masterPort}
\item 
const \hyperlink{classCycles}{Cycles} \hyperlink{classBridge_1_1BridgeSlavePort_a153dd7cdfa9816427cbbe84dce923c8d}{delay}
\item 
const \hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classBridge_1_1BridgeSlavePort_aa51746d80e2118c6d1c670fcd6d6169e}{ranges}
\item 
\hyperlink{classstd_1_1deque}{std::deque}$<$ \hyperlink{classBridge_1_1DeferredPacket}{DeferredPacket} $>$ \hyperlink{classBridge_1_1BridgeSlavePort_a640fbfa2436c06d6f64608f76261e6e5}{transmitList}
\item 
unsigned int \hyperlink{classBridge_1_1BridgeSlavePort_a3d6ba4ec7b15c09dd3e5d3c23c1f174f}{outstandingResponses}
\item 
bool \hyperlink{classBridge_1_1BridgeSlavePort_aab3b947b2633a30b5973a39b7e9b018a}{retryReq}
\item 
unsigned int \hyperlink{classBridge_1_1BridgeSlavePort_a1da989012dff28370bdcf58a69d6769a}{respQueueLimit}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classBridge_1_1BridgeSlavePort}{BridgeSlavePort},\&BridgeSlavePort::trySendTiming $>$ \hyperlink{classBridge_1_1BridgeSlavePort_ae68804297f24d50ce6d825eccd46b6af}{sendEvent}
\end{DoxyCompactItemize}


\subsection{説明}
The port on the side that receives requests and sends responses. The slave port has a set of address ranges that it is responsible for. The slave port also has a buffer for the responses not yet sent. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classBridge_1_1BridgeSlavePort_a2b4ad4cec25b318ebfcf261db753a8fb}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!BridgeSlavePort@{BridgeSlavePort}}
\index{BridgeSlavePort@{BridgeSlavePort}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{BridgeSlavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BridgeSlavePort} (const std::string \& {\em \_\-name}, \/  {\bf Bridge} \& {\em \_\-bridge}, \/  {\bf BridgeMasterPort} \& {\em \_\-masterPort}, \/  {\bf Cycles} {\em \_\-delay}, \/  int {\em \_\-resp\_\-limit}, \/  {\bf std::vector}$<$ {\bf AddrRange} $>$ {\em \_\-ranges})}}
\label{classBridge_1_1BridgeSlavePort_a2b4ad4cec25b318ebfcf261db753a8fb}
Constructor for the \hyperlink{classBridge_1_1BridgeSlavePort}{BridgeSlavePort}.


\begin{DoxyParams}{引数}
\item[{\em \_\-name}]the port name including the owner \item[{\em \_\-bridge}]the structural owner \item[{\em \_\-masterPort}]the master port on the other side of the bridge \item[{\em \_\-delay}]the delay in cycles from receiving to sending \item[{\em \_\-resp\_\-limit}]the size of the response queue \item[{\em \_\-ranges}]a number of address ranges to forward \end{DoxyParams}



\begin{DoxyCode}
61     : SlavePort(_name, &_bridge), bridge(_bridge), masterPort(_masterPort),
62       delay(_delay), ranges(_ranges.begin(), _ranges.end()),
63       outstandingResponses(0), retryReq(false),
64       respQueueLimit(_resp_limit), sendEvent(*this)
65 {
66 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classBridge_1_1BridgeSlavePort_a36cf113d5e5e091ebddb32306c098fae}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!getAddrRanges@{getAddrRanges}}
\index{getAddrRanges@{getAddrRanges}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{getAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRangeList} getAddrRanges () const\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBridge_1_1BridgeSlavePort_a36cf113d5e5e091ebddb32306c098fae}
When receiving a address range request the peer port, pass it to the bridge. 

\hyperlink{classSlavePort_a6e967f8921e80748eb2be35b6b481a7e}{SlavePort}を実装しています。


\begin{DoxyCode}
404 {
405     return ranges;
406 }
\end{DoxyCode}
\hypertarget{classBridge_1_1BridgeSlavePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!recvAtomic@{recvAtomic}}
\index{recvAtomic@{recvAtomic}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{recvAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvAtomic ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBridge_1_1BridgeSlavePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}
When receiving a Atomic requestfrom the peer port, pass it to the bridge. 

\hyperlink{classSlavePort_a428ab07671bc9372dc44a2487b12a726}{SlavePort}を実装しています。


\begin{DoxyCode}
357 {
358     return delay * bridge.clockPeriod() + masterPort.sendAtomic(pkt);
359 }
\end{DoxyCode}
\hypertarget{classBridge_1_1BridgeSlavePort_aeefa907fb6d6a787e6dab90e8138ea90}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!recvFunctional@{recvFunctional}}
\index{recvFunctional@{recvFunctional}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{recvFunctional}]{\setlength{\rightskip}{0pt plus 5cm}void recvFunctional ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBridge_1_1BridgeSlavePort_aeefa907fb6d6a787e6dab90e8138ea90}
When receiving a Functional request from the peer port, pass it to the bridge. 

\hyperlink{classSlavePort_a6a3d6f2e5dab6bed16d53d9e7c17378d}{SlavePort}を実装しています。


\begin{DoxyCode}
363 {
364     pkt->pushLabel(name());
365 
366     // check the response queue
367     for (auto i = transmitList.begin();  i != transmitList.end(); ++i) {
368         if (pkt->checkFunctional((*i).pkt)) {
369             pkt->makeResponse();
370             return;
371         }
372     }
373 
374     // also check the master port's request queue
375     if (masterPort.checkFunctional(pkt)) {
376         return;
377     }
378 
379     pkt->popLabel();
380 
381     // fall through if pkt still not satisfied
382     masterPort.sendFunctional(pkt);
383 }
\end{DoxyCode}
\hypertarget{classBridge_1_1BridgeSlavePort_a29cb5a4f98063ce6e9210eacbdb35298}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetry ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBridge_1_1BridgeSlavePort_a29cb5a4f98063ce6e9210eacbdb35298}
When receiving a retry request from the peer port, pass it to the bridge. 

\hyperlink{classSlavePort_ac1ccc3bcf7ebabb20b57fab99b2be5b0}{SlavePort}を実装しています。


\begin{DoxyCode}
351 {
352     trySendTiming();
353 }
\end{DoxyCode}
\hypertarget{classBridge_1_1BridgeSlavePort_a3344d9dd0f83257feab5424e761f31c6}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!recvTimingReq@{recvTimingReq}}
\index{recvTimingReq@{recvTimingReq}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{recvTimingReq}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingReq ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBridge_1_1BridgeSlavePort_a3344d9dd0f83257feab5424e761f31c6}
When receiving a timing request from the peer port, pass it to the bridge. 

\hyperlink{classSlavePort_abcece77e42f88ee41af8d3d01bb48253}{SlavePort}を実装しています。


\begin{DoxyCode}
149 {
150     DPRINTF(Bridge, "recvTimingReq: %s addr 0x%x\n",
151             pkt->cmdString(), pkt->getAddr());
152 
153     // we should not see a timing request if we are already in a retry
154     assert(!retryReq);
155 
156     DPRINTF(Bridge, "Response queue size: %d outresp: %d\n",
157             transmitList.size(), outstandingResponses);
158 
159     // if the request queue is full then there is no hope
160     if (masterPort.reqQueueFull()) {
161         DPRINTF(Bridge, "Request queue full\n");
162         retryReq = true;
163     } else {
164         // look at the response queue if we expect to see a response
165         bool expects_response = pkt->needsResponse() &&
166             !pkt->memInhibitAsserted();
167         if (expects_response) {
168             if (respQueueFull()) {
169                 DPRINTF(Bridge, "Response queue full\n");
170                 retryReq = true;
171             } else {
172                 // ok to send the request with space for the response
173                 DPRINTF(Bridge, "Reserving space for response\n");
174                 assert(outstandingResponses != respQueueLimit);
175                 ++outstandingResponses;
176 
177                 // no need to set retryReq to false as this is already the
178                 // case
179             }
180         }
181 
182         if (!retryReq) {
183             // @todo: We need to pay for this and not just zero it out
184             pkt->busFirstWordDelay = pkt->busLastWordDelay = 0;
185 
186             masterPort.schedTimingReq(pkt, bridge.clockEdge(delay));
187         }
188     }
189 
190     // remember that we are now stalling a packet and that we have to
191     // tell the sending master to retry once space becomes available,
192     // we make no distinction whether the stalling is due to the
193     // request queue or response queue being full
194     return !retryReq;
195 }
\end{DoxyCode}
\hypertarget{classBridge_1_1BridgeSlavePort_a7ca559cfc6bcef8eba87fc5a0bd0bb42}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!respQueueFull@{respQueueFull}}
\index{respQueueFull@{respQueueFull}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{respQueueFull}]{\setlength{\rightskip}{0pt plus 5cm}bool respQueueFull () const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBridge_1_1BridgeSlavePort_a7ca559cfc6bcef8eba87fc5a0bd0bb42}
Is this side blocked from accepting new response packets.

\begin{DoxyReturn}{戻り値}
true if the reserved space has reached the set limit 
\end{DoxyReturn}



\begin{DoxyCode}
119 {
120     return outstandingResponses == respQueueLimit;
121 }
\end{DoxyCode}
\hypertarget{classBridge_1_1BridgeSlavePort_a7b3f6456ef3aa1b8dcc6d1a20652453d}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!retryStalledReq@{retryStalledReq}}
\index{retryStalledReq@{retryStalledReq}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{retryStalledReq}]{\setlength{\rightskip}{0pt plus 5cm}void retryStalledReq ()}}
\label{classBridge_1_1BridgeSlavePort_a7b3f6456ef3aa1b8dcc6d1a20652453d}
Retry any stalled request that we have failed to accept at an earlier point in time. This call will do nothing if no request is waiting. 


\begin{DoxyCode}
199 {
200     if (retryReq) {
201         DPRINTF(Bridge, "Request waiting for retry, now retrying\n");
202         retryReq = false;
203         sendRetry();
204     }
205 }
\end{DoxyCode}
\hypertarget{classBridge_1_1BridgeSlavePort_a31c2fe79e7cbd7319eb327074e412675}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!schedTimingResp@{schedTimingResp}}
\index{schedTimingResp@{schedTimingResp}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{schedTimingResp}]{\setlength{\rightskip}{0pt plus 5cm}void schedTimingResp ({\bf PacketPtr} {\em pkt}, \/  {\bf Tick} {\em when})}}
\label{classBridge_1_1BridgeSlavePort_a31c2fe79e7cbd7319eb327074e412675}
Queue a response packet to be sent out later and also schedule a send if necessary.


\begin{DoxyParams}{引数}
\item[{\em pkt}]a response to send out after a delay \item[{\em when}]tick when response packet should be sent \end{DoxyParams}



\begin{DoxyCode}
235 {
236     // This is a response for a request we forwarded earlier.  The
237     // corresponding request state should be stored in the packet's
238     // senderState field.
239     RequestState *req_state =
240         dynamic_cast<RequestState*>(pkt->popSenderState());
241     assert(req_state != NULL);
242     pkt->setDest(req_state->origSrc);
243     delete req_state;
244 
245     // the bridge assumes that at least one bus has set the
246     // destination field of the packet
247     assert(pkt->isDestValid());
248     DPRINTF(Bridge, "response, new dest %d\n", pkt->getDest());
249 
250     // If we're about to put this packet at the head of the queue, we
251     // need to schedule an event to do the transmit.  Otherwise there
252     // should already be an event scheduled for sending the head
253     // packet.
254     if (transmitList.empty()) {
255         bridge.schedule(sendEvent, when);
256     }
257 
258     transmitList.push_back(DeferredPacket(pkt, when));
259 }
\end{DoxyCode}
\hypertarget{classBridge_1_1BridgeSlavePort_a391c414b53eb45782e37bc539608e477}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!trySendTiming@{trySendTiming}}
\index{trySendTiming@{trySendTiming}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{trySendTiming}]{\setlength{\rightskip}{0pt plus 5cm}void trySendTiming ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBridge_1_1BridgeSlavePort_a391c414b53eb45782e37bc539608e477}
Handle send event, scheduled when the packet at the head of the response queue is ready to transmit (for timing accesses only). 


\begin{DoxyCode}
301 {
302     assert(!transmitList.empty());
303 
304     DeferredPacket resp = transmitList.front();
305 
306     assert(resp.tick <= curTick());
307 
308     PacketPtr pkt = resp.pkt;
309 
310     DPRINTF(Bridge, "trySend response addr 0x%x, outstanding %d\n",
311             pkt->getAddr(), outstandingResponses);
312 
313     if (sendTimingResp(pkt)) {
314         // send successful
315         transmitList.pop_front();
316         DPRINTF(Bridge, "trySend response successful\n");
317 
318         assert(outstandingResponses != 0);
319         --outstandingResponses;
320 
321         // If there are more packets to send, schedule event to try again.
322         if (!transmitList.empty()) {
323             DeferredPacket next_resp = transmitList.front();
324             DPRINTF(Bridge, "Scheduling next send\n");
325             bridge.schedule(sendEvent, std::max(next_resp.tick,
326                                                 bridge.clockEdge()));
327         }
328 
329         // if there is space in the request queue and we were stalling
330         // a request, it will definitely be possible to accept it now
331         // since there is guaranteed space in the response queue
332         if (!masterPort.reqQueueFull() && retryReq) {
333             DPRINTF(Bridge, "Request waiting for retry, now retrying\n");
334             retryReq = false;
335             sendRetry();
336         }
337     }
338 
339     // if the send failed, then we try again once we receive a retry,
340     // and therefore there is no need to take any action
341 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classBridge_1_1BridgeSlavePort_a6d3b24e49ac986064571195ab9905136}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!bridge@{bridge}}
\index{bridge@{bridge}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{bridge}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Bridge}\& {\bf bridge}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBridge_1_1BridgeSlavePort_a6d3b24e49ac986064571195ab9905136}
The bridge to which this port belongs. \hypertarget{classBridge_1_1BridgeSlavePort_a153dd7cdfa9816427cbbe84dce923c8d}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!delay@{delay}}
\index{delay@{delay}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{delay}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Cycles} {\bf delay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBridge_1_1BridgeSlavePort_a153dd7cdfa9816427cbbe84dce923c8d}
Minimum request delay though this bridge. \hypertarget{classBridge_1_1BridgeSlavePort_ab67087190dd99cae7527467d6b6e7bbb}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!masterPort@{masterPort}}
\index{masterPort@{masterPort}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{masterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BridgeMasterPort}\& {\bf masterPort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBridge_1_1BridgeSlavePort_ab67087190dd99cae7527467d6b6e7bbb}
Master port on the other side of the bridge (connected to the other bus). \hypertarget{classBridge_1_1BridgeSlavePort_a3d6ba4ec7b15c09dd3e5d3c23c1f174f}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!outstandingResponses@{outstandingResponses}}
\index{outstandingResponses@{outstandingResponses}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{outstandingResponses}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf outstandingResponses}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBridge_1_1BridgeSlavePort_a3d6ba4ec7b15c09dd3e5d3c23c1f174f}
Counter to track the outstanding responses. \hypertarget{classBridge_1_1BridgeSlavePort_aa51746d80e2118c6d1c670fcd6d6169e}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!ranges@{ranges}}
\index{ranges@{ranges}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{ranges}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf AddrRangeList} {\bf ranges}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBridge_1_1BridgeSlavePort_aa51746d80e2118c6d1c670fcd6d6169e}
\hyperlink{classAddress}{Address} ranges to pass through the bridge \hypertarget{classBridge_1_1BridgeSlavePort_a1da989012dff28370bdcf58a69d6769a}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!respQueueLimit@{respQueueLimit}}
\index{respQueueLimit@{respQueueLimit}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{respQueueLimit}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf respQueueLimit}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBridge_1_1BridgeSlavePort_a1da989012dff28370bdcf58a69d6769a}
Max queue size for reserved responses. \hypertarget{classBridge_1_1BridgeSlavePort_aab3b947b2633a30b5973a39b7e9b018a}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!retryReq@{retryReq}}
\index{retryReq@{retryReq}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{retryReq}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf retryReq}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBridge_1_1BridgeSlavePort_aab3b947b2633a30b5973a39b7e9b018a}
If we should send a retry when space becomes available. \hypertarget{classBridge_1_1BridgeSlavePort_ae68804297f24d50ce6d825eccd46b6af}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!sendEvent@{sendEvent}}
\index{sendEvent@{sendEvent}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{sendEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf BridgeSlavePort}, \&BridgeSlavePort::trySendTiming$>$ {\bf sendEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBridge_1_1BridgeSlavePort_ae68804297f24d50ce6d825eccd46b6af}
Send event for the response queue. \hypertarget{classBridge_1_1BridgeSlavePort_a640fbfa2436c06d6f64608f76261e6e5}{
\index{Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}!transmitList@{transmitList}}
\index{transmitList@{transmitList}!Bridge::BridgeSlavePort@{Bridge::BridgeSlavePort}}
\subsubsection[{transmitList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::deque}$<${\bf DeferredPacket}$>$ {\bf transmitList}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBridge_1_1BridgeSlavePort_a640fbfa2436c06d6f64608f76261e6e5}
Response packet queue. Response packets are held in this queue for a specified delay to model the processing delay of the bridge. We use a deque as we need to iterate over the items for functional accesses. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{bridge_8hh}{bridge.hh}\item 
mem/\hyperlink{bridge_8cc}{bridge.cc}\end{DoxyCompactItemize}
