\hypertarget{classX86ISA_1_1ISA}{
\section{クラス ISA}
\label{classX86ISA_1_1ISA}\index{X86ISA::ISA@{X86ISA::ISA}}
}


{\ttfamily \#include $<$isa.hh$>$}ISAに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classX86ISA_1_1ISA}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef X86ISAParams \hyperlink{classX86ISA_1_1ISA_a479c84ea8074d124d1ddd320ef027439}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classX86ISA_1_1ISA_ac8bb3912a3ce86b15842e79d0b421204}{clear} ()
\item 
\hyperlink{classX86ISA_1_1ISA_ae9132e021b3f3b20c917fc328a056bbd}{ISA} (\hyperlink{classX86ISA_1_1ISA_a479c84ea8074d124d1ddd320ef027439}{Params} $\ast$\hyperlink{namespaceX86ISA_af675c1d542a25b96e11164b80809a856}{p})
\item 
const \hyperlink{classX86ISA_1_1ISA_a479c84ea8074d124d1ddd320ef027439}{Params} $\ast$ \hyperlink{classX86ISA_1_1ISA_a7a20f1b985970cdbca22d0a4fbf09dd6}{params} () const 
\item 
\hyperlink{namespaceX86ISA_aa16539aa6584fd12f7d6fa868f75b4de}{MiscReg} \hyperlink{classX86ISA_1_1ISA_a8147f1448b78d0de3f86766175429e19}{readMiscRegNoEffect} (int miscReg)
\item 
\hyperlink{namespaceX86ISA_aa16539aa6584fd12f7d6fa868f75b4de}{MiscReg} \hyperlink{classX86ISA_1_1ISA_ac9a5ba47c1dd9552c65c3164fba45f20}{readMiscReg} (int miscReg, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\item 
void \hyperlink{classX86ISA_1_1ISA_a4b021ed77b93fc971a905c83bba97e38}{setMiscRegNoEffect} (int miscReg, \hyperlink{namespaceX86ISA_aa16539aa6584fd12f7d6fa868f75b4de}{MiscReg} \hyperlink{namespaceX86ISA_ae13bf1250853ff6b72aabe3c79b587cc}{val})
\item 
void \hyperlink{classX86ISA_1_1ISA_acb55d95b5d0cf15e23c7cdcfe03074f1}{setMiscReg} (int miscReg, \hyperlink{namespaceX86ISA_aa16539aa6584fd12f7d6fa868f75b4de}{MiscReg} \hyperlink{namespaceX86ISA_ae13bf1250853ff6b72aabe3c79b587cc}{val}, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\item 
int \hyperlink{classX86ISA_1_1ISA_aece4b88ffcab608652e8e9f0fbe643d4}{flattenIntIndex} (int \hyperlink{namespaceX86ISA_aeeb02ad833ab76f3430553ef93213a6b}{reg}) const 
\item 
int \hyperlink{classX86ISA_1_1ISA_a85addcd4f57c5a0ffa81805dcad1eeb7}{flattenFloatIndex} (int \hyperlink{namespaceX86ISA_aeeb02ad833ab76f3430553ef93213a6b}{reg}) const 
\item 
int \hyperlink{classX86ISA_1_1ISA_a7a5d7476bd10e5af09e6e753d1fca087}{flattenCCIndex} (int \hyperlink{namespaceX86ISA_aeeb02ad833ab76f3430553ef93213a6b}{reg}) const 
\item 
int \hyperlink{classX86ISA_1_1ISA_a8997760aa4425793911f57440a4dd8ae}{flattenMiscIndex} (int \hyperlink{namespaceX86ISA_aeeb02ad833ab76f3430553ef93213a6b}{reg}) const 
\item 
void \hyperlink{classX86ISA_1_1ISA_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&\hyperlink{namespaceX86ISA_a6b6e6ba763e7eaf46ac5b6372ca98d30}{os})
\item 
void \hyperlink{classX86ISA_1_1ISA_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\item 
void \hyperlink{classX86ISA_1_1ISA_a769e733729615c529fdb54f538f11dba}{startup} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classX86ISA_1_1ISA_a9ce2f376c572f07e3cc0851492e1ca25}{updateHandyM5Reg} (Efer efer, CR0 cr0, SegAttr csAttr, SegAttr ssAttr, RFLAGS rflags, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{namespaceX86ISA_aa16539aa6584fd12f7d6fa868f75b4de}{MiscReg} \hyperlink{classX86ISA_1_1ISA_a33fdce9a7f1c2a99683c4ef6fda1e32a}{regVal} \mbox{[}NUM\_\-MISCREGS\mbox{]}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classX86ISA_1_1ISA_a479c84ea8074d124d1ddd320ef027439}{
\index{X86ISA::ISA@{X86ISA::ISA}!Params@{Params}}
\index{Params@{Params}!X86ISA::ISA@{X86ISA::ISA}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef X86ISAParams {\bf Params}}}
\label{classX86ISA_1_1ISA_a479c84ea8074d124d1ddd320ef027439}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classX86ISA_1_1ISA_ae9132e021b3f3b20c917fc328a056bbd}{
\index{X86ISA::ISA@{X86ISA::ISA}!ISA@{ISA}}
\index{ISA@{ISA}!X86ISA::ISA@{X86ISA::ISA}}
\subsubsection[{ISA}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ISA} ({\bf Params} $\ast$ {\em p})}}
\label{classX86ISA_1_1ISA_ae9132e021b3f3b20c917fc328a056bbd}



\begin{DoxyCode}
115     : SimObject(p)
116 {
117     clear();
118 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classX86ISA_1_1ISA_ac8bb3912a3ce86b15842e79d0b421204}{
\index{X86ISA::ISA@{X86ISA::ISA}!clear@{clear}}
\index{clear@{clear}!X86ISA::ISA@{X86ISA::ISA}}
\subsubsection[{clear}]{\setlength{\rightskip}{0pt plus 5cm}void clear ()}}
\label{classX86ISA_1_1ISA_ac8bb3912a3ce86b15842e79d0b421204}



\begin{DoxyCode}
106 {
107     // Blank everything. 0 might not be an appropriate value for some things,
108     // but it is for most.
109     memset(regVal, 0, NumMiscRegs * sizeof(MiscReg));
110     regVal[MISCREG_DR6] = (mask(8) << 4) | (mask(16) << 16);
111     regVal[MISCREG_DR7] = 1 << 10;
112 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1ISA_a7a5d7476bd10e5af09e6e753d1fca087}{
\index{X86ISA::ISA@{X86ISA::ISA}!flattenCCIndex@{flattenCCIndex}}
\index{flattenCCIndex@{flattenCCIndex}!X86ISA::ISA@{X86ISA::ISA}}
\subsubsection[{flattenCCIndex}]{\setlength{\rightskip}{0pt plus 5cm}int flattenCCIndex (int {\em reg}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1ISA_a7a5d7476bd10e5af09e6e753d1fca087}



\begin{DoxyCode}
90         {
91             return reg;
92         }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1ISA_a85addcd4f57c5a0ffa81805dcad1eeb7}{
\index{X86ISA::ISA@{X86ISA::ISA}!flattenFloatIndex@{flattenFloatIndex}}
\index{flattenFloatIndex@{flattenFloatIndex}!X86ISA::ISA@{X86ISA::ISA}}
\subsubsection[{flattenFloatIndex}]{\setlength{\rightskip}{0pt plus 5cm}int flattenFloatIndex (int {\em reg}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1ISA_a85addcd4f57c5a0ffa81805dcad1eeb7}



\begin{DoxyCode}
80         {
81             if (reg >= NUM_FLOATREGS) {
82                 reg = FLOATREG_STACK(reg - NUM_FLOATREGS,
83                                      regVal[MISCREG_X87_TOP]);
84             }
85             return reg;
86         }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1ISA_aece4b88ffcab608652e8e9f0fbe643d4}{
\index{X86ISA::ISA@{X86ISA::ISA}!flattenIntIndex@{flattenIntIndex}}
\index{flattenIntIndex@{flattenIntIndex}!X86ISA::ISA@{X86ISA::ISA}}
\subsubsection[{flattenIntIndex}]{\setlength{\rightskip}{0pt plus 5cm}int flattenIntIndex (int {\em reg}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1ISA_aece4b88ffcab608652e8e9f0fbe643d4}



\begin{DoxyCode}
74         {
75             return reg & ~IntFoldBit;
76         }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1ISA_a8997760aa4425793911f57440a4dd8ae}{
\index{X86ISA::ISA@{X86ISA::ISA}!flattenMiscIndex@{flattenMiscIndex}}
\index{flattenMiscIndex@{flattenMiscIndex}!X86ISA::ISA@{X86ISA::ISA}}
\subsubsection[{flattenMiscIndex}]{\setlength{\rightskip}{0pt plus 5cm}int flattenMiscIndex (int {\em reg}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1ISA_a8997760aa4425793911f57440a4dd8ae}



\begin{DoxyCode}
96         {
97             return reg;
98         }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1ISA_a7a20f1b985970cdbca22d0a4fbf09dd6}{
\index{X86ISA::ISA@{X86ISA::ISA}!params@{params}}
\index{params@{params}!X86ISA::ISA@{X86ISA::ISA}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const X86ISAParams $\ast$ params () const}}
\label{classX86ISA_1_1ISA_a7a20f1b985970cdbca22d0a4fbf09dd6}



\begin{DoxyCode}
122 {
123     return dynamic_cast<const Params *>(_params);
124 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1ISA_ac9a5ba47c1dd9552c65c3164fba45f20}{
\index{X86ISA::ISA@{X86ISA::ISA}!readMiscReg@{readMiscReg}}
\index{readMiscReg@{readMiscReg}!X86ISA::ISA@{X86ISA::ISA}}
\subsubsection[{readMiscReg}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MiscReg} readMiscReg (int {\em miscReg}, \/  {\bf ThreadContext} $\ast$ {\em tc})}}
\label{classX86ISA_1_1ISA_ac9a5ba47c1dd9552c65c3164fba45f20}



\begin{DoxyCode}
143 {
144     if (miscReg == MISCREG_TSC) {
145         return regVal[MISCREG_TSC] + tc->getCpuPtr()->curCycle();
146     }
147 
148     if (miscReg == MISCREG_FSW) {
149         MiscReg fsw = regVal[MISCREG_FSW];
150         MiscReg top = regVal[MISCREG_X87_TOP];
151         return (fsw & (~(7ULL << 11))) + (top << 11);
152     }
153 
154     return readMiscRegNoEffect(miscReg);
155 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1ISA_a8147f1448b78d0de3f86766175429e19}{
\index{X86ISA::ISA@{X86ISA::ISA}!readMiscRegNoEffect@{readMiscRegNoEffect}}
\index{readMiscRegNoEffect@{readMiscRegNoEffect}!X86ISA::ISA@{X86ISA::ISA}}
\subsubsection[{readMiscRegNoEffect}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MiscReg} readMiscRegNoEffect (int {\em miscReg})}}
\label{classX86ISA_1_1ISA_a8147f1448b78d0de3f86766175429e19}



\begin{DoxyCode}
128 {
129     // Make sure we're not dealing with an illegal control register.
130     // Instructions should filter out these indexes, and nothing else should
131     // attempt to read them directly.
132     assert( miscReg != MISCREG_CR1 &&
133             !(miscReg > MISCREG_CR4 &&
134               miscReg < MISCREG_CR8) &&
135             !(miscReg > MISCREG_CR8 &&
136               miscReg <= MISCREG_CR15));
137 
138     return regVal[miscReg];
139 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1ISA_a53e036786d17361be4c7320d39c99b84}{
\index{X86ISA::ISA@{X86ISA::ISA}!serialize@{serialize}}
\index{serialize@{serialize}!X86ISA::ISA@{X86ISA::ISA}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})}}
\label{classX86ISA_1_1ISA_a53e036786d17361be4c7320d39c99b84}



\begin{DoxyCode}
374 {
375     SERIALIZE_ARRAY(regVal, NumMiscRegs);
376 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1ISA_acb55d95b5d0cf15e23c7cdcfe03074f1}{
\index{X86ISA::ISA@{X86ISA::ISA}!setMiscReg@{setMiscReg}}
\index{setMiscReg@{setMiscReg}!X86ISA::ISA@{X86ISA::ISA}}
\subsubsection[{setMiscReg}]{\setlength{\rightskip}{0pt plus 5cm}void setMiscReg (int {\em miscReg}, \/  {\bf MiscReg} {\em val}, \/  {\bf ThreadContext} $\ast$ {\em tc})}}
\label{classX86ISA_1_1ISA_acb55d95b5d0cf15e23c7cdcfe03074f1}



\begin{DoxyCode}
173 {
174     MiscReg newVal = val;
175     switch(miscReg)
176     {
177       case MISCREG_CR0:
178         {
179             CR0 toggled = regVal[miscReg] ^ val;
180             CR0 newCR0 = val;
181             Efer efer = regVal[MISCREG_EFER];
182             if (toggled.pg && efer.lme) {
183                 if (newCR0.pg) {
184                     //Turning on long mode
185                     efer.lma = 1;
186                     regVal[MISCREG_EFER] = efer;
187                 } else {
188                     //Turning off long mode
189                     efer.lma = 0;
190                     regVal[MISCREG_EFER] = efer;
191                 }
192             }
193             if (toggled.pg) {
194                 tc->getITBPtr()->flushAll();
195                 tc->getDTBPtr()->flushAll();
196             }
197             //This must always be 1.
198             newCR0.et = 1;
199             newVal = newCR0;
200             updateHandyM5Reg(regVal[MISCREG_EFER],
201                              newCR0,
202                              regVal[MISCREG_CS_ATTR],
203                              regVal[MISCREG_SS_ATTR],
204                              regVal[MISCREG_RFLAGS],
205                              tc);
206         }
207         break;
208       case MISCREG_CR2:
209         break;
210       case MISCREG_CR3:
211         tc->getITBPtr()->flushNonGlobal();
212         tc->getDTBPtr()->flushNonGlobal();
213         break;
214       case MISCREG_CR4:
215         {
216             CR4 toggled = regVal[miscReg] ^ val;
217             if (toggled.pae || toggled.pse || toggled.pge) {
218                 tc->getITBPtr()->flushAll();
219                 tc->getDTBPtr()->flushAll();
220             }
221         }
222         break;
223       case MISCREG_CR8:
224         break;
225       case MISCREG_CS_ATTR:
226         {
227             SegAttr toggled = regVal[miscReg] ^ val;
228             SegAttr newCSAttr = val;
229             if (toggled.longMode) {
230                 if (newCSAttr.longMode) {
231                     regVal[MISCREG_ES_EFF_BASE] = 0;
232                     regVal[MISCREG_CS_EFF_BASE] = 0;
233                     regVal[MISCREG_SS_EFF_BASE] = 0;
234                     regVal[MISCREG_DS_EFF_BASE] = 0;
235                 } else {
236                     regVal[MISCREG_ES_EFF_BASE] = regVal[MISCREG_ES_BASE];
237                     regVal[MISCREG_CS_EFF_BASE] = regVal[MISCREG_CS_BASE];
238                     regVal[MISCREG_SS_EFF_BASE] = regVal[MISCREG_SS_BASE];
239                     regVal[MISCREG_DS_EFF_BASE] = regVal[MISCREG_DS_BASE];
240                 }
241             }
242             updateHandyM5Reg(regVal[MISCREG_EFER],
243                              regVal[MISCREG_CR0],
244                              newCSAttr,
245                              regVal[MISCREG_SS_ATTR],
246                              regVal[MISCREG_RFLAGS],
247                              tc);
248         }
249         break;
250       case MISCREG_SS_ATTR:
251         updateHandyM5Reg(regVal[MISCREG_EFER],
252                          regVal[MISCREG_CR0],
253                          regVal[MISCREG_CS_ATTR],
254                          val,
255                          regVal[MISCREG_RFLAGS],
256                          tc);
257         break;
258       // These segments always actually use their bases, or in other words
259       // their effective bases must stay equal to their actual bases.
260       case MISCREG_FS_BASE:
261       case MISCREG_GS_BASE:
262       case MISCREG_HS_BASE:
263       case MISCREG_TSL_BASE:
264       case MISCREG_TSG_BASE:
265       case MISCREG_TR_BASE:
266       case MISCREG_IDTR_BASE:
267         regVal[MISCREG_SEG_EFF_BASE(miscReg - MISCREG_SEG_BASE_BASE)] = val;
268         break;
269       // These segments ignore their bases in 64 bit mode.
270       // their effective bases must stay equal to their actual bases.
271       case MISCREG_ES_BASE:
272       case MISCREG_CS_BASE:
273       case MISCREG_SS_BASE:
274       case MISCREG_DS_BASE:
275         {
276             Efer efer = regVal[MISCREG_EFER];
277             SegAttr csAttr = regVal[MISCREG_CS_ATTR];
278             if (!efer.lma || !csAttr.longMode) // Check for non 64 bit mode.
279                 regVal[MISCREG_SEG_EFF_BASE(miscReg -
280                         MISCREG_SEG_BASE_BASE)] = val;
281         }
282         break;
283       case MISCREG_TSC:
284         regVal[MISCREG_TSC] = val - tc->getCpuPtr()->curCycle();
285         return;
286       case MISCREG_DR0:
287       case MISCREG_DR1:
288       case MISCREG_DR2:
289       case MISCREG_DR3:
290         /* These should eventually set up breakpoints. */
291         break;
292       case MISCREG_DR4:
293         miscReg = MISCREG_DR6;
294         /* Fall through to have the same effects as DR6. */
295       case MISCREG_DR6:
296         {
297             DR6 dr6 = regVal[MISCREG_DR6];
298             DR6 newDR6 = val;
299             dr6.b0 = newDR6.b0;
300             dr6.b1 = newDR6.b1;
301             dr6.b2 = newDR6.b2;
302             dr6.b3 = newDR6.b3;
303             dr6.bd = newDR6.bd;
304             dr6.bs = newDR6.bs;
305             dr6.bt = newDR6.bt;
306             newVal = dr6;
307         }
308         break;
309       case MISCREG_DR5:
310         miscReg = MISCREG_DR7;
311         /* Fall through to have the same effects as DR7. */
312       case MISCREG_DR7:
313         {
314             DR7 dr7 = regVal[MISCREG_DR7];
315             DR7 newDR7 = val;
316             dr7.l0 = newDR7.l0;
317             dr7.g0 = newDR7.g0;
318             if (dr7.l0 || dr7.g0) {
319                 panic("Debug register breakpoints not implemented.\n");
320             } else {
321                 /* Disable breakpoint 0. */
322             }
323             dr7.l1 = newDR7.l1;
324             dr7.g1 = newDR7.g1;
325             if (dr7.l1 || dr7.g1) {
326                 panic("Debug register breakpoints not implemented.\n");
327             } else {
328                 /* Disable breakpoint 1. */
329             }
330             dr7.l2 = newDR7.l2;
331             dr7.g2 = newDR7.g2;
332             if (dr7.l2 || dr7.g2) {
333                 panic("Debug register breakpoints not implemented.\n");
334             } else {
335                 /* Disable breakpoint 2. */
336             }
337             dr7.l3 = newDR7.l3;
338             dr7.g3 = newDR7.g3;
339             if (dr7.l3 || dr7.g3) {
340                 panic("Debug register breakpoints not implemented.\n");
341             } else {
342                 /* Disable breakpoint 3. */
343             }
344             dr7.gd = newDR7.gd;
345             dr7.rw0 = newDR7.rw0;
346             dr7.len0 = newDR7.len0;
347             dr7.rw1 = newDR7.rw1;
348             dr7.len1 = newDR7.len1;
349             dr7.rw2 = newDR7.rw2;
350             dr7.len2 = newDR7.len2;
351             dr7.rw3 = newDR7.rw3;
352             dr7.len3 = newDR7.len3;
353         }
354         break;
355       case MISCREG_M5_REG:
356         // Writing anything to the m5reg with side effects makes it update
357         // based on the current values of the relevant registers. The actual
358         // value written is discarded.
359         updateHandyM5Reg(regVal[MISCREG_EFER],
360                          regVal[MISCREG_CR0],
361                          regVal[MISCREG_CS_ATTR],
362                          regVal[MISCREG_SS_ATTR],
363                          regVal[MISCREG_RFLAGS],
364                          tc);
365         return;
366       default:
367         break;
368     }
369     setMiscRegNoEffect(miscReg, newVal);
370 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1ISA_a4b021ed77b93fc971a905c83bba97e38}{
\index{X86ISA::ISA@{X86ISA::ISA}!setMiscRegNoEffect@{setMiscRegNoEffect}}
\index{setMiscRegNoEffect@{setMiscRegNoEffect}!X86ISA::ISA@{X86ISA::ISA}}
\subsubsection[{setMiscRegNoEffect}]{\setlength{\rightskip}{0pt plus 5cm}void setMiscRegNoEffect (int {\em miscReg}, \/  {\bf MiscReg} {\em val})}}
\label{classX86ISA_1_1ISA_a4b021ed77b93fc971a905c83bba97e38}



\begin{DoxyCode}
159 {
160     // Make sure we're not dealing with an illegal control register.
161     // Instructions should filter out these indexes, and nothing else should
162     // attempt to write to them directly.
163     assert( miscReg != MISCREG_CR1 &&
164             !(miscReg > MISCREG_CR4 &&
165               miscReg < MISCREG_CR8) &&
166             !(miscReg > MISCREG_CR8 &&
167               miscReg <= MISCREG_CR15));
168     regVal[miscReg] = val;
169 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1ISA_a769e733729615c529fdb54f538f11dba}{
\index{X86ISA::ISA@{X86ISA::ISA}!startup@{startup}}
\index{startup@{startup}!X86ISA::ISA@{X86ISA::ISA}}
\subsubsection[{startup}]{\setlength{\rightskip}{0pt plus 5cm}void startup ({\bf ThreadContext} $\ast$ {\em tc})}}
\label{classX86ISA_1_1ISA_a769e733729615c529fdb54f538f11dba}



\begin{DoxyCode}
392 {
393     tc->getDecoderPtr()->setM5Reg(regVal[MISCREG_M5_REG]);
394 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1ISA_af22e5d6d660b97db37003ac61ac4ee49}{
\index{X86ISA::ISA@{X86ISA::ISA}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!X86ISA::ISA@{X86ISA::ISA}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})}}
\label{classX86ISA_1_1ISA_af22e5d6d660b97db37003ac61ac4ee49}



\begin{DoxyCode}
380 {
381     UNSERIALIZE_ARRAY(regVal, NumMiscRegs);
382     updateHandyM5Reg(regVal[MISCREG_EFER],
383                      regVal[MISCREG_CR0],
384                      regVal[MISCREG_CS_ATTR],
385                      regVal[MISCREG_SS_ATTR],
386                      regVal[MISCREG_RFLAGS],
387                      NULL);
388 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1ISA_a9ce2f376c572f07e3cc0851492e1ca25}{
\index{X86ISA::ISA@{X86ISA::ISA}!updateHandyM5Reg@{updateHandyM5Reg}}
\index{updateHandyM5Reg@{updateHandyM5Reg}!X86ISA::ISA@{X86ISA::ISA}}
\subsubsection[{updateHandyM5Reg}]{\setlength{\rightskip}{0pt plus 5cm}void updateHandyM5Reg (Efer {\em efer}, \/  CR0 {\em cr0}, \/  SegAttr {\em csAttr}, \/  SegAttr {\em ssAttr}, \/  RFLAGS {\em rflags}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1ISA_a9ce2f376c572f07e3cc0851492e1ca25}



\begin{DoxyCode}
46 {
47     HandyM5Reg m5reg = 0;
48     if (efer.lma) {
49         m5reg.mode = LongMode;
50         if (csAttr.longMode)
51             m5reg.submode = SixtyFourBitMode;
52         else
53             m5reg.submode = CompatabilityMode;
54     } else {
55         m5reg.mode = LegacyMode;
56         if (cr0.pe) {
57             if (rflags.vm)
58                 m5reg.submode = Virtual8086Mode;
59             else
60                 m5reg.submode = ProtectedMode;
61         } else {
62             m5reg.submode = RealMode;
63         }
64     }
65     m5reg.cpl = csAttr.dpl;
66     m5reg.paging = cr0.pg;
67     m5reg.prot = cr0.pe;
68 
69     // Compute the default and alternate operand size.
70     if (m5reg.submode == SixtyFourBitMode || csAttr.defaultSize) {
71         m5reg.defOp = 2;
72         m5reg.altOp = 1;
73     } else {
74         m5reg.defOp = 1;
75         m5reg.altOp = 2;
76     }
77 
78     // Compute the default and alternate address size.
79     if (m5reg.submode == SixtyFourBitMode) {
80         m5reg.defAddr = 3;
81         m5reg.altAddr = 2;
82     } else if (csAttr.defaultSize) {
83         m5reg.defAddr = 2;
84         m5reg.altAddr = 1;
85     } else {
86         m5reg.defAddr = 1;
87         m5reg.altAddr = 2;
88     }
89 
90     // Compute the stack size
91     if (m5reg.submode == SixtyFourBitMode) {
92         m5reg.stack = 3;
93     } else if (ssAttr.defaultSize) {
94         m5reg.stack = 2;
95     } else {
96         m5reg.stack = 1;
97     }
98 
99     regVal[MISCREG_M5_REG] = m5reg;
100     if (tc)
101         tc->getDecoderPtr()->setM5Reg(m5reg);
102 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classX86ISA_1_1ISA_a33fdce9a7f1c2a99683c4ef6fda1e32a}{
\index{X86ISA::ISA@{X86ISA::ISA}!regVal@{regVal}}
\index{regVal@{regVal}!X86ISA::ISA@{X86ISA::ISA}}
\subsubsection[{regVal}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MiscReg} {\bf regVal}\mbox{[}NUM\_\-MISCREGS\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1ISA_a33fdce9a7f1c2a99683c4ef6fda1e32a}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/x86/\hyperlink{x86_2isa_8hh}{isa.hh}\item 
arch/x86/\hyperlink{x86_2isa_8cc}{isa.cc}\end{DoxyCompactItemize}
