\hypertarget{classRubyPort}{
\section{クラス RubyPort}
\label{classRubyPort}\index{RubyPort@{RubyPort}}
}


{\ttfamily \#include $<$RubyPort.hh$>$}RubyPortに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=6cm]{classRubyPort}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classRubyPort_1_1MemMasterPort}{MemMasterPort}
\item 
class \hyperlink{classRubyPort_1_1MemSlavePort}{MemSlavePort}
\item 
class \hyperlink{classRubyPort_1_1PioMasterPort}{PioMasterPort}
\item 
class \hyperlink{classRubyPort_1_1PioSlavePort}{PioSlavePort}
\item 
struct \hyperlink{structRubyPort_1_1SenderState}{SenderState}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef RubyPortParams \hyperlink{classRubyPort_a73ffda3b6b10849321fd359baf61eb3c}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classRubyPort_a48daea2300eda2ed192847716fe85997}{RubyPort} (const \hyperlink{classRubyPort_a73ffda3b6b10849321fd359baf61eb3c}{Params} $\ast$p)
\item 
virtual \hyperlink{classRubyPort_ab94ca27fbdf091331d2703af1e73d8dc}{$\sim$RubyPort} ()
\item 
void \hyperlink{classRubyPort_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
\hyperlink{classBaseMasterPort}{BaseMasterPort} \& \hyperlink{classRubyPort_adc4e675e51defbdd1e354dac729d0703}{getMasterPort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
\hyperlink{classBaseSlavePort}{BaseSlavePort} \& \hyperlink{classRubyPort_ac918a145092d7514ebc6dbd952dceafb}{getSlavePort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
virtual RequestStatus \hyperlink{classRubyPort_a596adbddbc1059f06e3989f743f2ed3e}{makeRequest} (\hyperlink{classPacket}{PacketPtr} pkt)=0
\item 
virtual int \hyperlink{classRubyPort_a366b0b3d8b8a08b7066f1b98c1b40b85}{outstandingCount} () const =0
\item 
virtual bool \hyperlink{classRubyPort_a24d37c70faaaf126b544c2d46ea70ce2}{isDeadlockEventScheduled} () const =0
\item 
virtual void \hyperlink{classRubyPort_ae635736b1bd64144a8f1fc5f42948b21}{descheduleDeadlockEvent} ()=0
\item 
void \hyperlink{classRubyPort_a0768dd0d813b0d71fd45a5deb1bd0294}{setController} (\hyperlink{classAbstractController}{AbstractController} $\ast$\_\-cntrl)
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classRubyPort_a0394d0753edf9da729ce700f110f650c}{getId} ()
\item 
unsigned int \hyperlink{classRubyPort_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classRubyPort_aa8ad1a5d600c338dcd76fcf434f3169e}{ruby\_\-hit\_\-callback} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classRubyPort_ada43967d9f25e87e20fa808ff7d88a89}{testDrainComplete} ()
\item 
void \hyperlink{classRubyPort_ac3858f72631784d3e09bba9070f96349}{ruby\_\-eviction\_\-callback} (const \hyperlink{classAddress}{Address} \&address)
\item 
bool \hyperlink{classRubyPort_a47ba09f9a3b3998cac9c14ab596a7515}{recvTimingResp} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} master\_\-port\_\-id)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classRubyPort_a0d6124b18fa39209bf51ec6407fa7c0f}{m\_\-version}
\item 
\hyperlink{classAbstractController}{AbstractController} $\ast$ \hyperlink{classRubyPort_a1e7049f2cd244dc3944af370eb3e979a}{m\_\-controller}
\item 
\hyperlink{classMessageBuffer}{MessageBuffer} $\ast$ \hyperlink{classRubyPort_a5bd71d4fde9408a3740efa5d95532c15}{m\_\-mandatory\_\-q\_\-ptr}
\item 
bool \hyperlink{classRubyPort_aad291d9ca2fd5321994e6553b21c530a}{m\_\-usingRubyTester}
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classRubyPort_1_1MemSlavePort}{MemSlavePort} $\ast$ $>$::iterator \hyperlink{classRubyPort_a0479a75b096e758f414b419c517de782}{CpuPortIter}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classRubyPort_ad473637152492944180673282ebe71a3}{addToRetryList} (\hyperlink{classRubyPort_1_1MemSlavePort}{MemSlavePort} $\ast$port)
\item 
unsigned int \hyperlink{classRubyPort_a6497fe5e5b0476effb15db9118962e93}{getChildDrainCount} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classRubyPort_1_1PioMasterPort}{PioMasterPort} \hyperlink{classRubyPort_ae1618ee13262dd22f26a87a3bcb2dca2}{pioMasterPort}
\item 
\hyperlink{classRubyPort_1_1PioSlavePort}{PioSlavePort} \hyperlink{classRubyPort_a294b27c7011440b7e24e12afddd75eab}{pioSlavePort}
\item 
\hyperlink{classRubyPort_1_1MemMasterPort}{MemMasterPort} \hyperlink{classRubyPort_ac2c1831a0923d1c83c01f7854d1d707e}{memMasterPort}
\item 
\hyperlink{classRubyPort_1_1MemSlavePort}{MemSlavePort} \hyperlink{classRubyPort_a5b8a0b35186f04ce4aeae758f4f0a698}{memSlavePort}
\item 
unsigned int \hyperlink{classRubyPort_a7194bb8c21c2c460cc31ecea9f08b1db}{gotAddrRanges}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classRubyPort_1_1MemSlavePort}{MemSlavePort} $\ast$ $>$ \hyperlink{classRubyPort_ac00171ae3169a04dcc3119647b11711f}{slave\_\-ports}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classRubyPort_1_1PioMasterPort}{PioMasterPort} $\ast$ $>$ \hyperlink{classRubyPort_ac95349e84e36b96125370f0ff8196196}{master\_\-ports}
\item 
\hyperlink{classDrainManager}{DrainManager} $\ast$ \hyperlink{classRubyPort_a329b71fb934a93312ca0aacbf5a3f982}{drainManager}
\item 
\hyperlink{classSystem}{System} $\ast$ \hyperlink{classRubyPort_af27ccd765f13a4b7bd119dc7579e2746}{system}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classRubyPort_1_1MemSlavePort}{MemSlavePort} $\ast$ $>$ \hyperlink{classRubyPort_a90d108bebdfeb2310e9a40b66b22f429}{retryList}
\item 
bool \hyperlink{classRubyPort_a5925f629d4ec58811bba7c4fa6b4d64d}{access\_\-phys\_\-mem}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classRubyPort_a0479a75b096e758f414b419c517de782}{
\index{RubyPort@{RubyPort}!CpuPortIter@{CpuPortIter}}
\index{CpuPortIter@{CpuPortIter}!RubyPort@{RubyPort}}
\subsubsection[{CpuPortIter}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::vector}$<${\bf MemSlavePort} $\ast$$>$::iterator {\bf CpuPortIter}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyPort_a0479a75b096e758f414b419c517de782}
Vector of M5 Ports attached to this Ruby port. \hypertarget{classRubyPort_a73ffda3b6b10849321fd359baf61eb3c}{
\index{RubyPort@{RubyPort}!Params@{Params}}
\index{Params@{Params}!RubyPort@{RubyPort}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef RubyPortParams {\bf Params}}}
\label{classRubyPort_a73ffda3b6b10849321fd359baf61eb3c}


\hyperlink{classMemObject_a905bbc621eeec0ed08859e21c8c95412}{MemObject}を再定義しています。

\hyperlink{classDMASequencer_a9827bc75ea7fc70f8a78d2545226f251}{DMASequencer}で再定義されています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classRubyPort_a48daea2300eda2ed192847716fe85997}{
\index{RubyPort@{RubyPort}!RubyPort@{RubyPort}}
\index{RubyPort@{RubyPort}!RubyPort@{RubyPort}}
\subsubsection[{RubyPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RubyPort} (const {\bf Params} $\ast$ {\em p})}}
\label{classRubyPort_a48daea2300eda2ed192847716fe85997}



\begin{DoxyCode}
53     : MemObject(p), m_version(p->version), m_controller(NULL),
54       m_mandatory_q_ptr(NULL), m_usingRubyTester(p->using_ruby_tester),
55       pioMasterPort(csprintf("%s.pio-master-port", name()), this),
56       pioSlavePort(csprintf("%s.pio-slave-port", name()), this),
57       memMasterPort(csprintf("%s.mem-master-port", name()), this),
58       memSlavePort(csprintf("%s-mem-slave-port", name()), this,
59           p->ruby_system, p->access_phys_mem, -1),
60       gotAddrRanges(p->port_master_connection_count), drainManager(NULL),
61       system(p->system), access_phys_mem(p->access_phys_mem)
62 {
63     assert(m_version != -1);
64 
65     // create the slave ports based on the number of connected ports
66     for (size_t i = 0; i < p->port_slave_connection_count; ++i) {
67         slave_ports.push_back(new MemSlavePort(csprintf("%s.slave%d", name(),
68             i), this, p->ruby_system, access_phys_mem, i));
69     }
70 
71     // create the master ports based on the number of connected ports
72     for (size_t i = 0; i < p->port_master_connection_count; ++i) {
73         master_ports.push_back(new PioMasterPort(csprintf("%s.master%d",
74             name(), i), this));
75     }
76 }
\end{DoxyCode}
\hypertarget{classRubyPort_ab94ca27fbdf091331d2703af1e73d8dc}{
\index{RubyPort@{RubyPort}!$\sim$RubyPort@{$\sim$RubyPort}}
\index{$\sim$RubyPort@{$\sim$RubyPort}!RubyPort@{RubyPort}}
\subsubsection[{$\sim$RubyPort}]{\setlength{\rightskip}{0pt plus 5cm}virtual $\sim${\bf RubyPort} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classRubyPort_ab94ca27fbdf091331d2703af1e73d8dc}



\begin{DoxyCode}
144 {}
\end{DoxyCode}


\subsection{関数}
\hypertarget{classRubyPort_ad473637152492944180673282ebe71a3}{
\index{RubyPort@{RubyPort}!addToRetryList@{addToRetryList}}
\index{addToRetryList@{addToRetryList}!RubyPort@{RubyPort}}
\subsubsection[{addToRetryList}]{\setlength{\rightskip}{0pt plus 5cm}void addToRetryList ({\bf MemSlavePort} $\ast$ {\em port})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classRubyPort_ad473637152492944180673282ebe71a3}



\begin{DoxyCode}
188     {
189         assert(std::find(retryList.begin(), retryList.end(), port) ==
190                retryList.end());
191         retryList.push_back(port);
192     }
\end{DoxyCode}
\hypertarget{classRubyPort_ae635736b1bd64144a8f1fc5f42948b21}{
\index{RubyPort@{RubyPort}!descheduleDeadlockEvent@{descheduleDeadlockEvent}}
\index{descheduleDeadlockEvent@{descheduleDeadlockEvent}!RubyPort@{RubyPort}}
\subsubsection[{descheduleDeadlockEvent}]{\setlength{\rightskip}{0pt plus 5cm}virtual void descheduleDeadlockEvent ()\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classRubyPort_ae635736b1bd64144a8f1fc5f42948b21}


\hyperlink{classDMASequencer_a7c9a8861621a62055761f47310814762}{DMASequencer}, と \hyperlink{classRubyPortProxy_a7c9a8861621a62055761f47310814762}{RubyPortProxy}で実装されています。\hypertarget{classRubyPort_aa8a18d230dba7a674ac8a0b4f35bc36a}{
\index{RubyPort@{RubyPort}!drain@{drain}}
\index{drain@{drain}!RubyPort@{RubyPort}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em drainManger})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyPort_aa8a18d230dba7a674ac8a0b4f35bc36a}
Provide a default implementation of the drain interface that simply returns 0 (draining completed) and sets the drain state to Drained. 

\hyperlink{classSimObject_a6bf479c521c7c3eb473822d953275b26}{SimObject}を再定義しています。


\begin{DoxyCode}
420 {
421     if (isDeadlockEventScheduled()) {
422         descheduleDeadlockEvent();
423     }
424 
425     //
426     // If the RubyPort is not empty, then it needs to clear all outstanding
427     // requests before it should call drainManager->signalDrainDone()
428     //
429     DPRINTF(Config, "outstanding count %d\n", outstandingCount());
430     bool need_drain = outstandingCount() > 0;
431 
432     //
433     // Also, get the number of child ports that will also need to clear
434     // their buffered requests before they call drainManager->signalDrainDone()
435     //
436     unsigned int child_drain_count = getChildDrainCount(dm);
437 
438     // Set status
439     if (need_drain) {
440         drainManager = dm;
441 
442         DPRINTF(Drain, "RubyPort not drained\n");
443         setDrainState(Drainable::Draining);
444         return child_drain_count + 1;
445     }
446 
447     drainManager = NULL;
448     setDrainState(Drainable::Drained);
449     return child_drain_count;
450 }
\end{DoxyCode}
\hypertarget{classRubyPort_a6497fe5e5b0476effb15db9118962e93}{
\index{RubyPort@{RubyPort}!getChildDrainCount@{getChildDrainCount}}
\index{getChildDrainCount@{getChildDrainCount}!RubyPort@{RubyPort}}
\subsubsection[{getChildDrainCount}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int getChildDrainCount ({\bf DrainManager} $\ast$ {\em dm})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyPort_a6497fe5e5b0476effb15db9118962e93}



\begin{DoxyCode}
395 {
396     int count = 0;
397 
398     if (memMasterPort.isConnected()) {
399         count += memMasterPort.drain(dm);
400         DPRINTF(Config, "count after pio check %d\n", count);
401     }
402 
403     for (CpuPortIter p = slave_ports.begin(); p != slave_ports.end(); ++p) {
404         count += (*p)->drain(dm);
405         DPRINTF(Config, "count after slave port check %d\n", count);
406     }
407 
408     for (std::vector<PioMasterPort *>::iterator p = master_ports.begin();
409          p != master_ports.end(); ++p) {
410         count += (*p)->drain(dm);
411         DPRINTF(Config, "count after master port check %d\n", count);
412     }
413 
414     DPRINTF(Config, "final count %d\n", count);
415     return count;
416 }
\end{DoxyCode}
\hypertarget{classRubyPort_a0394d0753edf9da729ce700f110f650c}{
\index{RubyPort@{RubyPort}!getId@{getId}}
\index{getId@{getId}!RubyPort@{RubyPort}}
\subsubsection[{getId}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} getId ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRubyPort_a0394d0753edf9da729ce700f110f650c}



\begin{DoxyCode}
163 { return m_version; }
\end{DoxyCode}
\hypertarget{classRubyPort_adc4e675e51defbdd1e354dac729d0703}{
\index{RubyPort@{RubyPort}!getMasterPort@{getMasterPort}}
\index{getMasterPort@{getMasterPort}!RubyPort@{RubyPort}}
\subsubsection[{getMasterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseMasterPort} \& getMasterPort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyPort_adc4e675e51defbdd1e354dac729d0703}
Get a master port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classMemObject_adc4e675e51defbdd1e354dac729d0703}{MemObject}を再定義しています。


\begin{DoxyCode}
88 {
89     if (if_name == "mem_master_port") {
90         return memMasterPort;
91     }
92 
93     if (if_name == "pio_master_port") {
94         return pioMasterPort;
95     }
96 
97     // used by the x86 CPUs to connect the interrupt PIO and interrupt slave
98     // port
99     if (if_name != "master") {
100         // pass it along to our super class
101         return MemObject::getMasterPort(if_name, idx);
102     } else {
103         if (idx >= static_cast<PortID>(master_ports.size())) {
104             panic("RubyPort::getMasterPort: unknown index %d\n", idx);
105         }
106 
107         return *master_ports[idx];
108     }
109 }
\end{DoxyCode}
\hypertarget{classRubyPort_ac918a145092d7514ebc6dbd952dceafb}{
\index{RubyPort@{RubyPort}!getSlavePort@{getSlavePort}}
\index{getSlavePort@{getSlavePort}!RubyPort@{RubyPort}}
\subsubsection[{getSlavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseSlavePort} \& getSlavePort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyPort_ac918a145092d7514ebc6dbd952dceafb}
Get a slave port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classMemObject_ac918a145092d7514ebc6dbd952dceafb}{MemObject}を再定義しています。


\begin{DoxyCode}
113 {
114     if (if_name == "mem_slave_port") {
115         return memSlavePort;
116     }
117 
118     if (if_name == "pio_slave_port")
119         return pioSlavePort;
120 
121     // used by the CPUs to connect the caches to the interconnect, and
122     // for the x86 case also the interrupt master
123     if (if_name != "slave") {
124         // pass it along to our super class
125         return MemObject::getSlavePort(if_name, idx);
126     } else {
127         if (idx >= static_cast<PortID>(slave_ports.size())) {
128             panic("RubyPort::getSlavePort: unknown index %d\n", idx);
129         }
130 
131         return *slave_ports[idx];
132     }
133 }
\end{DoxyCode}
\hypertarget{classRubyPort_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{RubyPort@{RubyPort}!init@{init}}
\index{init@{init}!RubyPort@{RubyPort}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classRubyPort_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classRubyPort_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{SimObject}を再定義しています。

\hyperlink{classDMASequencer_a02fd73d861ef2e4aabb38c0c9ff82947}{DMASequencer}, と \hyperlink{classRubyPortProxy_a02fd73d861ef2e4aabb38c0c9ff82947}{RubyPortProxy}で再定義されています。


\begin{DoxyCode}
80 {
81     assert(m_controller != NULL);
82     m_mandatory_q_ptr = m_controller->getMandatoryQueue();
83     m_mandatory_q_ptr->setSender(this);
84 }
\end{DoxyCode}
\hypertarget{classRubyPort_a24d37c70faaaf126b544c2d46ea70ce2}{
\index{RubyPort@{RubyPort}!isDeadlockEventScheduled@{isDeadlockEventScheduled}}
\index{isDeadlockEventScheduled@{isDeadlockEventScheduled}!RubyPort@{RubyPort}}
\subsubsection[{isDeadlockEventScheduled}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool isDeadlockEventScheduled () const\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classRubyPort_a24d37c70faaaf126b544c2d46ea70ce2}


\hyperlink{classDMASequencer_a11ce018fbd3aa89624b06dbdafbd4ef9}{DMASequencer}, と \hyperlink{classRubyPortProxy_a11ce018fbd3aa89624b06dbdafbd4ef9}{RubyPortProxy}で実装されています。\hypertarget{classRubyPort_a596adbddbc1059f06e3989f743f2ed3e}{
\index{RubyPort@{RubyPort}!makeRequest@{makeRequest}}
\index{makeRequest@{makeRequest}!RubyPort@{RubyPort}}
\subsubsection[{makeRequest}]{\setlength{\rightskip}{0pt plus 5cm}virtual RequestStatus makeRequest ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classRubyPort_a596adbddbc1059f06e3989f743f2ed3e}


\hyperlink{classDMASequencer_a23de6e3fbb2362f4410d435e3600d0f7}{DMASequencer}, と \hyperlink{classRubyPortProxy_a23de6e3fbb2362f4410d435e3600d0f7}{RubyPortProxy}で実装されています。\hypertarget{classRubyPort_a366b0b3d8b8a08b7066f1b98c1b40b85}{
\index{RubyPort@{RubyPort}!outstandingCount@{outstandingCount}}
\index{outstandingCount@{outstandingCount}!RubyPort@{RubyPort}}
\subsubsection[{outstandingCount}]{\setlength{\rightskip}{0pt plus 5cm}virtual int outstandingCount () const\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classRubyPort_a366b0b3d8b8a08b7066f1b98c1b40b85}


\hyperlink{classDMASequencer_ae47593dc86baa86bf047ad1fbcdcceed}{DMASequencer}, と \hyperlink{classRubyPortProxy_ae47593dc86baa86bf047ad1fbcdcceed}{RubyPortProxy}で実装されています。\hypertarget{classRubyPort_a47ba09f9a3b3998cac9c14ab596a7515}{
\index{RubyPort@{RubyPort}!recvTimingResp@{recvTimingResp}}
\index{recvTimingResp@{recvTimingResp}!RubyPort@{RubyPort}}
\subsubsection[{recvTimingResp}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingResp ({\bf PacketPtr} {\em pkt}, \/  {\bf PortID} {\em master\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classRubyPort_a47ba09f9a3b3998cac9c14ab596a7515}
Called by the PIO port when receiving a timing response.


\begin{DoxyParams}{引数}
\item[{\em pkt}]Response packet \item[{\em master\_\-port\_\-id}]\hyperlink{classPort}{Port} id of the PIO port\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Whether successfully sent 
\end{DoxyReturn}
\hypertarget{classRubyPort_ac3858f72631784d3e09bba9070f96349}{
\index{RubyPort@{RubyPort}!ruby\_\-eviction\_\-callback@{ruby\_\-eviction\_\-callback}}
\index{ruby\_\-eviction\_\-callback@{ruby\_\-eviction\_\-callback}!RubyPort@{RubyPort}}
\subsubsection[{ruby\_\-eviction\_\-callback}]{\setlength{\rightskip}{0pt plus 5cm}void ruby\_\-eviction\_\-callback (const {\bf Address} \& {\em address})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classRubyPort_ac3858f72631784d3e09bba9070f96349}



\begin{DoxyCode}
538 {
539     DPRINTF(RubyPort, "Sending invalidations.\n");
540     // This request is deleted in the stack-allocated packet destructor
541     // when this function exits
542     // TODO: should this really be using funcMasterId?
543     RequestPtr req =
544             new Request(address.getAddress(), 0, 0, Request::funcMasterId);
545     // Use a single packet to signal all snooping ports of the invalidation.
546     // This assumes that snooping ports do NOT modify the packet/request
547     Packet pkt(req, MemCmd::InvalidationReq);
548     for (CpuPortIter p = slave_ports.begin(); p != slave_ports.end(); ++p) {
549         // check if the connected master port is snooping
550         if ((*p)->isSnooping()) {
551             // send as a snoop request
552             (*p)->sendTimingSnoopReq(&pkt);
553         }
554     }
555 }
\end{DoxyCode}
\hypertarget{classRubyPort_aa8ad1a5d600c338dcd76fcf434f3169e}{
\index{RubyPort@{RubyPort}!ruby\_\-hit\_\-callback@{ruby\_\-hit\_\-callback}}
\index{ruby\_\-hit\_\-callback@{ruby\_\-hit\_\-callback}!RubyPort@{RubyPort}}
\subsubsection[{ruby\_\-hit\_\-callback}]{\setlength{\rightskip}{0pt plus 5cm}void ruby\_\-hit\_\-callback ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classRubyPort_aa8ad1a5d600c338dcd76fcf434f3169e}



\begin{DoxyCode}
335 {
336     DPRINTF(RubyPort, "Hit callback for %s 0x%x\n", pkt->cmdString(),
337             pkt->getAddr());
338 
339     // The packet was destined for memory and has not yet been turned
340     // into a response
341     assert(system->isMemAddr(pkt->getAddr()));
342     assert(pkt->isRequest());
343 
344     // As it has not yet been turned around, the source field tells us
345     // which port it came from.
346     assert(pkt->getSrc() < slave_ports.size());
347 
348     slave_ports[pkt->getSrc()]->hitCallback(pkt);
349 
350     //
351     // If we had to stall the MemSlavePorts, wake them up because the sequencer
352     // likely has free resources now.
353     //
354     if (!retryList.empty()) {
355         //
356         // Record the current list of ports to retry on a temporary list before
357         // calling sendRetry on those ports.  sendRetry will cause an 
358         // immediate retry, which may result in the ports being put back on the
359         // list. Therefore we want to clear the retryList before calling
360         // sendRetry.
361         //
362         std::vector<MemSlavePort *> curRetryList(retryList);
363 
364         retryList.clear();
365 
366         for (auto i = curRetryList.begin(); i != curRetryList.end(); ++i) {
367             DPRINTF(RubyPort,
368                     "Sequencer may now be free.  SendRetry to port %s\n",
369                     (*i)->name());
370             (*i)->sendRetry();
371         }
372     }
373 
374     testDrainComplete();
375 }
\end{DoxyCode}
\hypertarget{classRubyPort_a0768dd0d813b0d71fd45a5deb1bd0294}{
\index{RubyPort@{RubyPort}!setController@{setController}}
\index{setController@{setController}!RubyPort@{RubyPort}}
\subsubsection[{setController}]{\setlength{\rightskip}{0pt plus 5cm}void setController ({\bf AbstractController} $\ast$ {\em \_\-cntrl})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classRubyPort_a0768dd0d813b0d71fd45a5deb1bd0294}



\begin{DoxyCode}
162 { m_controller = _cntrl; }
\end{DoxyCode}
\hypertarget{classRubyPort_ada43967d9f25e87e20fa808ff7d88a89}{
\index{RubyPort@{RubyPort}!testDrainComplete@{testDrainComplete}}
\index{testDrainComplete@{testDrainComplete}!RubyPort@{RubyPort}}
\subsubsection[{testDrainComplete}]{\setlength{\rightskip}{0pt plus 5cm}void testDrainComplete ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classRubyPort_ada43967d9f25e87e20fa808ff7d88a89}



\begin{DoxyCode}
379 {
380     //If we weren't able to drain before, we might be able to now.
381     if (drainManager != NULL) {
382         unsigned int drainCount = outstandingCount();
383         DPRINTF(Drain, "Drain count: %u\n", drainCount);
384         if (drainCount == 0) {
385             DPRINTF(Drain, "RubyPort done draining, signaling drain done\n");
386             drainManager->signalDrainDone();
387             // Clear the drain manager once we're done with it.
388             drainManager = NULL;
389         }
390     }
391 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classRubyPort_a5925f629d4ec58811bba7c4fa6b4d64d}{
\index{RubyPort@{RubyPort}!access\_\-phys\_\-mem@{access\_\-phys\_\-mem}}
\index{access\_\-phys\_\-mem@{access\_\-phys\_\-mem}!RubyPort@{RubyPort}}
\subsubsection[{access\_\-phys\_\-mem}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf access\_\-phys\_\-mem}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyPort_a5925f629d4ec58811bba7c4fa6b4d64d}
\hypertarget{classRubyPort_a329b71fb934a93312ca0aacbf5a3f982}{
\index{RubyPort@{RubyPort}!drainManager@{drainManager}}
\index{drainManager@{drainManager}!RubyPort@{RubyPort}}
\subsubsection[{drainManager}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DrainManager}$\ast$ {\bf drainManager}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyPort_a329b71fb934a93312ca0aacbf5a3f982}
\hypertarget{classRubyPort_a7194bb8c21c2c460cc31ecea9f08b1db}{
\index{RubyPort@{RubyPort}!gotAddrRanges@{gotAddrRanges}}
\index{gotAddrRanges@{gotAddrRanges}!RubyPort@{RubyPort}}
\subsubsection[{gotAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf gotAddrRanges}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyPort_a7194bb8c21c2c460cc31ecea9f08b1db}
\hypertarget{classRubyPort_a1e7049f2cd244dc3944af370eb3e979a}{
\index{RubyPort@{RubyPort}!m\_\-controller@{m\_\-controller}}
\index{m\_\-controller@{m\_\-controller}!RubyPort@{RubyPort}}
\subsubsection[{m\_\-controller}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AbstractController}$\ast$ {\bf m\_\-controller}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classRubyPort_a1e7049f2cd244dc3944af370eb3e979a}
\hypertarget{classRubyPort_a5bd71d4fde9408a3740efa5d95532c15}{
\index{RubyPort@{RubyPort}!m\_\-mandatory\_\-q\_\-ptr@{m\_\-mandatory\_\-q\_\-ptr}}
\index{m\_\-mandatory\_\-q\_\-ptr@{m\_\-mandatory\_\-q\_\-ptr}!RubyPort@{RubyPort}}
\subsubsection[{m\_\-mandatory\_\-q\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MessageBuffer}$\ast$ {\bf m\_\-mandatory\_\-q\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classRubyPort_a5bd71d4fde9408a3740efa5d95532c15}
\hypertarget{classRubyPort_aad291d9ca2fd5321994e6553b21c530a}{
\index{RubyPort@{RubyPort}!m\_\-usingRubyTester@{m\_\-usingRubyTester}}
\index{m\_\-usingRubyTester@{m\_\-usingRubyTester}!RubyPort@{RubyPort}}
\subsubsection[{m\_\-usingRubyTester}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf m\_\-usingRubyTester}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classRubyPort_aad291d9ca2fd5321994e6553b21c530a}
\hypertarget{classRubyPort_a0d6124b18fa39209bf51ec6407fa7c0f}{
\index{RubyPort@{RubyPort}!m\_\-version@{m\_\-version}}
\index{m\_\-version@{m\_\-version}!RubyPort@{RubyPort}}
\subsubsection[{m\_\-version}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf m\_\-version}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classRubyPort_a0d6124b18fa39209bf51ec6407fa7c0f}
\hypertarget{classRubyPort_ac95349e84e36b96125370f0ff8196196}{
\index{RubyPort@{RubyPort}!master\_\-ports@{master\_\-ports}}
\index{master\_\-ports@{master\_\-ports}!RubyPort@{RubyPort}}
\subsubsection[{master\_\-ports}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf PioMasterPort} $\ast$$>$ {\bf master\_\-ports}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyPort_ac95349e84e36b96125370f0ff8196196}
\hypertarget{classRubyPort_ac2c1831a0923d1c83c01f7854d1d707e}{
\index{RubyPort@{RubyPort}!memMasterPort@{memMasterPort}}
\index{memMasterPort@{memMasterPort}!RubyPort@{RubyPort}}
\subsubsection[{memMasterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemMasterPort} {\bf memMasterPort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyPort_ac2c1831a0923d1c83c01f7854d1d707e}
\hypertarget{classRubyPort_a5b8a0b35186f04ce4aeae758f4f0a698}{
\index{RubyPort@{RubyPort}!memSlavePort@{memSlavePort}}
\index{memSlavePort@{memSlavePort}!RubyPort@{RubyPort}}
\subsubsection[{memSlavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemSlavePort} {\bf memSlavePort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyPort_a5b8a0b35186f04ce4aeae758f4f0a698}
\hypertarget{classRubyPort_ae1618ee13262dd22f26a87a3bcb2dca2}{
\index{RubyPort@{RubyPort}!pioMasterPort@{pioMasterPort}}
\index{pioMasterPort@{pioMasterPort}!RubyPort@{RubyPort}}
\subsubsection[{pioMasterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PioMasterPort} {\bf pioMasterPort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyPort_ae1618ee13262dd22f26a87a3bcb2dca2}
\hypertarget{classRubyPort_a294b27c7011440b7e24e12afddd75eab}{
\index{RubyPort@{RubyPort}!pioSlavePort@{pioSlavePort}}
\index{pioSlavePort@{pioSlavePort}!RubyPort@{RubyPort}}
\subsubsection[{pioSlavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PioSlavePort} {\bf pioSlavePort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyPort_a294b27c7011440b7e24e12afddd75eab}
\hypertarget{classRubyPort_a90d108bebdfeb2310e9a40b66b22f429}{
\index{RubyPort@{RubyPort}!retryList@{retryList}}
\index{retryList@{retryList}!RubyPort@{RubyPort}}
\subsubsection[{retryList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf MemSlavePort} $\ast$$>$ {\bf retryList}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyPort_a90d108bebdfeb2310e9a40b66b22f429}
\hypertarget{classRubyPort_ac00171ae3169a04dcc3119647b11711f}{
\index{RubyPort@{RubyPort}!slave\_\-ports@{slave\_\-ports}}
\index{slave\_\-ports@{slave\_\-ports}!RubyPort@{RubyPort}}
\subsubsection[{slave\_\-ports}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf MemSlavePort} $\ast$$>$ {\bf slave\_\-ports}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyPort_ac00171ae3169a04dcc3119647b11711f}
\hypertarget{classRubyPort_af27ccd765f13a4b7bd119dc7579e2746}{
\index{RubyPort@{RubyPort}!system@{system}}
\index{system@{system}!RubyPort@{RubyPort}}
\subsubsection[{system}]{\setlength{\rightskip}{0pt plus 5cm}{\bf System}$\ast$ {\bf system}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classRubyPort_af27ccd765f13a4b7bd119dc7579e2746}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/ruby/system/\hyperlink{RubyPort_8hh}{RubyPort.hh}\item 
mem/ruby/system/\hyperlink{RubyPort_8cc}{RubyPort.cc}\end{DoxyCompactItemize}
