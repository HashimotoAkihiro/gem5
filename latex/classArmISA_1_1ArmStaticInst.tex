\hypertarget{classArmISA_1_1ArmStaticInst}{
\section{クラス ArmStaticInst}
\label{classArmISA_1_1ArmStaticInst}\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
}


{\ttfamily \#include $<$static\_\-inst.hh$>$}ArmStaticInstに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=12cm]{classArmISA_1_1ArmStaticInst}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classArmISA_1_1ArmStaticInst_afdc526dcb5bdd123d904d20430a4e4eb}{annotateFault} (\hyperlink{classArmISA_1_1ArmFault}{ArmFault} $\ast$fault)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
int32\_\-t \hyperlink{classArmISA_1_1ArmStaticInst_a3bf2cda24ceeea2d93bb03f88ddeec19}{shift\_\-rm\_\-imm} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} base, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} shamt, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} type, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} cfval) const 
\item 
int32\_\-t \hyperlink{classArmISA_1_1ArmStaticInst_a9c90a343b88f159bcb263bd2457848a5}{shift\_\-rm\_\-rs} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} base, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} shamt, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} type, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} cfval) const 
\item 
bool \hyperlink{classArmISA_1_1ArmStaticInst_a0d5e73a81869e11788298814fcdbc6d5}{shift\_\-carry\_\-imm} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} base, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} shamt, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} type, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} cfval) const 
\item 
bool \hyperlink{classArmISA_1_1ArmStaticInst_a75fefade18d7fe86d23af0c7944eab6b}{shift\_\-carry\_\-rs} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} base, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} shamt, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} type, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} cfval) const 
\item 
int64\_\-t \hyperlink{classArmISA_1_1ArmStaticInst_ab15bd99705b24d9b8d647aba628ee562}{shiftReg64} (uint64\_\-t base, uint64\_\-t shiftAmt, \hyperlink{namespaceArmISA_a209d79feaaef0aa2f54ae62e53ee90de}{ArmShiftType} type, uint8\_\-t \hyperlink{namespaceArmISA_a0da89c280130b84ae26405a901396428}{width}) const 
\item 
int64\_\-t \hyperlink{classArmISA_1_1ArmStaticInst_a1a939bcc6d227f5720f0069eabf42516}{extendReg64} (uint64\_\-t base, \hyperlink{namespaceArmISA_a4420842b5673543552a3aba317c69dbb}{ArmExtendType} type, uint64\_\-t shiftAmt, uint8\_\-t \hyperlink{namespaceArmISA_a0da89c280130b84ae26405a901396428}{width}) const 
\item 
\hyperlink{classArmISA_1_1ArmStaticInst_a996483aaded98afb7f4306959a94f118}{ArmStaticInst} (const char $\ast$mnem, \hyperlink{classStaticInst_a5605d4fc727eae9e595325c90c0ec108}{ExtMachInst} \_\-machInst, OpClass \_\-\_\-opClass)
\item 
void \hyperlink{classArmISA_1_1ArmStaticInst_a48f52fc281b71e29aa8733caf36546fa}{printReg} (std::ostream \&os, int reg) const 
\item 
void \hyperlink{classArmISA_1_1ArmStaticInst_a88eea7239477478ffadf11474ea8454f}{printMnemonic} (std::ostream \&os, const std::string \&suffix=\char`\"{}\char`\"{}, bool withPred=true, bool withCond64=false, \hyperlink{namespaceArmISA_ab8f08e777c4753720cff841f81da8e06}{ConditionCode} cond64=COND\_\-UC) const 
\item 
void \hyperlink{classArmISA_1_1ArmStaticInst_ae7bcb973c05eaba610f0c9bcd5a613d7}{printTarget} (std::ostream \&os, \hyperlink{classm5_1_1params_1_1Addr}{Addr} target, const SymbolTable $\ast$symtab) const 
\item 
void \hyperlink{classArmISA_1_1ArmStaticInst_a5406949b89d21af62d6d0208837130f4}{printCondition} (std::ostream \&os, unsigned code, bool noImplicit=false) const 
\item 
void \hyperlink{classArmISA_1_1ArmStaticInst_a2e070f27c98b230d26db666f40256594}{printMemSymbol} (std::ostream \&os, const SymbolTable $\ast$symtab, const std::string \&prefix, const \hyperlink{classm5_1_1params_1_1Addr}{Addr} addr, const std::string \&suffix) const 
\item 
void \hyperlink{classArmISA_1_1ArmStaticInst_aadac34271bfa06cdbf005536896b4a63}{printShiftOperand} (std::ostream \&os, \hyperlink{namespaceArmISA_ae64680ba9fb526106829d6bf92fc791b}{IntRegIndex} \hyperlink{namespaceArmISA_ad546c2cf2168cf2d8ac21b2a9f485e82}{rm}, bool immShift, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} shiftAmt, \hyperlink{namespaceArmISA_ae64680ba9fb526106829d6bf92fc791b}{IntRegIndex} \hyperlink{namespaceArmISA_acf2b1073855b77fc0cddb61c70ec5391}{rs}, \hyperlink{namespaceArmISA_a209d79feaaef0aa2f54ae62e53ee90de}{ArmShiftType} type) const 
\item 
void \hyperlink{classArmISA_1_1ArmStaticInst_a911f1c2066f7df1b82ea71902f97e6d0}{printExtendOperand} (bool firstOperand, std::ostream \&os, \hyperlink{namespaceArmISA_ae64680ba9fb526106829d6bf92fc791b}{IntRegIndex} \hyperlink{namespaceArmISA_ad546c2cf2168cf2d8ac21b2a9f485e82}{rm}, \hyperlink{namespaceArmISA_a4420842b5673543552a3aba317c69dbb}{ArmExtendType} type, int64\_\-t shiftAmt) const 
\item 
void \hyperlink{classArmISA_1_1ArmStaticInst_a4acc01aec616addcddc2958cff18ec04}{printDataInst} (std::ostream \&os, bool withImm) const 
\item 
void \hyperlink{classArmISA_1_1ArmStaticInst_a8ffe4c63f924a39c3916afb0cb24aad0}{printDataInst} (std::ostream \&os, bool withImm, bool immShift, bool \hyperlink{namespaceArmISA_afaeb18e17f862d8fcb76dfb68a18854f}{s}, \hyperlink{namespaceArmISA_ae64680ba9fb526106829d6bf92fc791b}{IntRegIndex} \hyperlink{namespaceArmISA_a7108a0a03f819a683bb745ab6e02179d}{rd}, \hyperlink{namespaceArmISA_ae64680ba9fb526106829d6bf92fc791b}{IntRegIndex} \hyperlink{namespaceArmISA_adf8c6c579ad8729095a637a4f2181211}{rn}, \hyperlink{namespaceArmISA_ae64680ba9fb526106829d6bf92fc791b}{IntRegIndex} \hyperlink{namespaceArmISA_ad546c2cf2168cf2d8ac21b2a9f485e82}{rm}, \hyperlink{namespaceArmISA_ae64680ba9fb526106829d6bf92fc791b}{IntRegIndex} \hyperlink{namespaceArmISA_acf2b1073855b77fc0cddb61c70ec5391}{rs}, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} shiftAmt, \hyperlink{namespaceArmISA_a209d79feaaef0aa2f54ae62e53ee90de}{ArmShiftType} type, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{namespaceArmISA_a2308526fcc9af84548a72f9ba3102ec1}{imm}) const 
\item 
void \hyperlink{classArmISA_1_1ArmStaticInst_af04cd01429462d48e635f3e01ced6257}{advancePC} (PCState \&pcState) const 
\item 
std::string \hyperlink{classArmISA_1_1ArmStaticInst_a95d323a22a5f07e14d6b4c9385a91896}{generateDisassembly} (\hyperlink{classm5_1_1params_1_1Addr}{Addr} pc, const SymbolTable $\ast$symtab) const 
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classArmISA_1_1ArmStaticInst_a620f503b160038dbe4b15bada1adb0c9}{disabledFault} () const 
\end{DoxyCompactItemize}
\subsection*{Static Protected メソッド}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$int width$>$ }\\static bool \hyperlink{classArmISA_1_1ArmStaticInst_ac89dee160ae86de9876da96a1df9ca67}{saturateOp} (int32\_\-t \&res, int64\_\-t op1, int64\_\-t op2, bool sub=false)
\item 
static bool \hyperlink{classArmISA_1_1ArmStaticInst_acd2842ccffb92bb276c016c87155bc67}{satInt} (int32\_\-t \&res, int64\_\-t op, int \hyperlink{namespaceArmISA_a0da89c280130b84ae26405a901396428}{width})
\item 
{\footnotesize template$<$int width$>$ }\\static bool \hyperlink{classArmISA_1_1ArmStaticInst_a588c48bae73d27c932022c7738612e28}{uSaturateOp} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \&res, int64\_\-t op1, int64\_\-t op2, bool sub=false)
\item 
static bool \hyperlink{classArmISA_1_1ArmStaticInst_a1836673d51155a1d5792744da88eb51b}{uSatInt} (int32\_\-t \&res, int64\_\-t op, int \hyperlink{namespaceArmISA_a0da89c280130b84ae26405a901396428}{width})
\item 
static \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classArmISA_1_1ArmStaticInst_a26cbe697c83efb76534cf501020a9e8c}{cpsrWriteByInstr} (CPSR \hyperlink{namespaceArmISA_ad377bf9b9c48f8cf3e8e918e0847b1fe}{cpsr}, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} val, SCR \hyperlink{namespaceArmISA_ace0bf26677706ecff809bd4c76d33c8c}{scr}, NSACR nsacr, uint8\_\-t byteMask, bool affectState, bool \hyperlink{namespaceArmISA_a5c0063e75cc368c01fa3a96930b13593}{nmfi}, \hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{namespaceArmISA_a5aff829af55e65b802d83dfcef4e9dd0}{tc})
\item 
static \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classArmISA_1_1ArmStaticInst_a2fd5209011bb73f8cccbb7c3ff60a553}{spsrWriteByInstr} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} spsr, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} val, uint8\_\-t byteMask, bool affectState)
\item 
{\footnotesize template$<$class XC $>$ }\\static \hyperlink{classm5_1_1params_1_1Addr}{Addr} \hyperlink{classArmISA_1_1ArmStaticInst_a8895f5e6ea72acdc881a4a2811d8061d}{readPC} (XC $\ast$xc)
\item 
{\footnotesize template$<$class XC $>$ }\\static void \hyperlink{classArmISA_1_1ArmStaticInst_a8a008e37d143524d0c3aba6e7c835f44}{setNextPC} (XC $\ast$xc, \hyperlink{classm5_1_1params_1_1Addr}{Addr} val)
\item 
{\footnotesize template$<$class T $>$ }\\static T \hyperlink{classArmISA_1_1ArmStaticInst_acf3e010f3f922cce3330ad7e69133c5f}{cSwap} (T val, bool big)
\item 
{\footnotesize template$<$class T , class E $>$ }\\static T \hyperlink{classArmISA_1_1ArmStaticInst_acf3e010f3f922cce3330ad7e69133c5f}{cSwap} (T val, bool big)
\item 
{\footnotesize template$<$class XC $>$ }\\static void \hyperlink{classArmISA_1_1ArmStaticInst_a7ef87b5f37a06b7143d275af2ab6444a}{setIWNextPC} (XC $\ast$xc, \hyperlink{classm5_1_1params_1_1Addr}{Addr} val)
\item 
{\footnotesize template$<$class XC $>$ }\\static void \hyperlink{classArmISA_1_1ArmStaticInst_a9345b4f7094d39b12eed323ddc30a6bf}{setAIWNextPC} (XC $\ast$xc, \hyperlink{classm5_1_1params_1_1Addr}{Addr} val)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classArmISA_1_1ArmStaticInst_a52c06c8a54293998f3e1f71cdbd916f7}{aarch64}
\item 
uint8\_\-t \hyperlink{classArmISA_1_1ArmStaticInst_a2a06976c0a3797444170f251f34bd40a}{intWidth}
\end{DoxyCompactItemize}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classArmISA_1_1ArmStaticInst_a996483aaded98afb7f4306959a94f118}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!ArmStaticInst@{ArmStaticInst}}
\index{ArmStaticInst@{ArmStaticInst}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{ArmStaticInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ArmStaticInst} (const char $\ast$ {\em mnem}, \/  {\bf ExtMachInst} {\em \_\-machInst}, \/  OpClass {\em \_\-\_\-opClass})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a996483aaded98afb7f4306959a94f118}



\begin{DoxyCode}
145         : StaticInst(mnem, _machInst, __opClass)
146     {
147         aarch64 = machInst.aarch64;
148         if (bits(machInst, 28, 24) == 0x10)
149             intWidth = 64;  // Force 64-bit width for ADR/ADRP
150         else
151             intWidth = (aarch64 && bits(machInst, 31)) ? 64 : 32;
152     }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classArmISA_1_1ArmStaticInst_af04cd01429462d48e635f3e01ced6257}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!advancePC@{advancePC}}
\index{advancePC@{advancePC}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{advancePC}]{\setlength{\rightskip}{0pt plus 5cm}void advancePC (PCState \& {\em pcState}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_af04cd01429462d48e635f3e01ced6257}


\hyperlink{classArmISA_1_1MicroOp_af04cd01429462d48e635f3e01ced6257}{MicroOp}, \hyperlink{classArmISA_1_1MicroOpX_af04cd01429462d48e635f3e01ced6257}{MicroOpX}, \hyperlink{classArmISA_1_1MightBeMicro_af04cd01429462d48e635f3e01ced6257}{MightBeMicro}, \hyperlink{classArmISA_1_1MightBeMicro64_af04cd01429462d48e635f3e01ced6257}{MightBeMicro64}, \hyperlink{classArmISA_1_1PredMicroop_af04cd01429462d48e635f3e01ced6257}{PredMicroop}, と \hyperlink{classArmISA_1_1FpOp_af04cd01429462d48e635f3e01ced6257}{FpOp}で再定義されています。


\begin{DoxyCode}
185     {
186         pcState.advance();
187     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_afdc526dcb5bdd123d904d20430a4e4eb}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!annotateFault@{annotateFault}}
\index{annotateFault@{annotateFault}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{annotateFault}]{\setlength{\rightskip}{0pt plus 5cm}virtual void annotateFault ({\bf ArmFault} $\ast$ {\em fault})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_afdc526dcb5bdd123d904d20430a4e4eb}



\begin{DoxyCode}
365 {}
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a26cbe697c83efb76534cf501020a9e8c}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!cpsrWriteByInstr@{cpsrWriteByInstr}}
\index{cpsrWriteByInstr@{cpsrWriteByInstr}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{cpsrWriteByInstr}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf uint32\_\-t} cpsrWriteByInstr (CPSR {\em cpsr}, \/  {\bf uint32\_\-t} {\em val}, \/  SCR {\em scr}, \/  NSACR {\em nsacr}, \/  uint8\_\-t {\em byteMask}, \/  bool {\em affectState}, \/  bool {\em nmfi}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static, protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a26cbe697c83efb76534cf501020a9e8c}



\begin{DoxyCode}
194     {
195         bool privileged   = (cpsr.mode != MODE_USER);
196         bool haveVirt     = ArmSystem::haveVirtualization(tc);
197         bool haveSecurity = ArmSystem::haveSecurity(tc);
198         bool isSecure     = inSecureState(scr, cpsr) || !haveSecurity;
199 
200         uint32_t bitMask = 0;
201 
202         if (bits(byteMask, 3)) {
203             unsigned lowIdx = affectState ? 24 : 27;
204             bitMask = bitMask | mask(31, lowIdx);
205         }
206         if (bits(byteMask, 2)) {
207             bitMask = bitMask | mask(19, 16);
208         }
209         if (bits(byteMask, 1)) {
210             unsigned highIdx = affectState ? 15 : 9;
211             unsigned lowIdx = (privileged && (isSecure || scr.aw || haveVirt))
212                             ? 8 : 9;
213             bitMask = bitMask | mask(highIdx, lowIdx);
214         }
215         if (bits(byteMask, 0)) {
216             if (privileged) {
217                 bitMask |= 1 << 7;
218                 if ( (!nmfi || !((val >> 6) & 0x1)) &&
219                      (isSecure || scr.fw || haveVirt) ) {
220                     bitMask |= 1 << 6;
221                 }
222                 // Now check the new mode is allowed
223                 OperatingMode newMode = (OperatingMode) (val & mask(5));
224                 OperatingMode oldMode = (OperatingMode)(uint32_t)cpsr.mode;
225                 if (!badMode(newMode)) {
226                     bool validModeChange = true;
227                     // Check for attempts to enter modes only permitted in
228                     // Secure state from Non-secure state. These are Monitor
229                     // mode ('10110'), and FIQ mode ('10001') if the Security
230                     // Extensions have reserved it.
231                     if (!isSecure && newMode == MODE_MON)
232                         validModeChange = false;
233                     if (!isSecure && newMode == MODE_FIQ && nsacr.rfr == '1')
234                         validModeChange = false;
235                     // There is no Hyp mode ('11010') in Secure state, so that
236                     // is UNPREDICTABLE
237                     if (scr.ns == '0' && newMode == MODE_HYP)
238                         validModeChange = false;
239                     // Cannot move into Hyp mode directly from a Non-secure
240                     // PL1 mode
241                     if (!isSecure && oldMode != MODE_HYP && newMode == MODE_HYP)
242                         validModeChange = false;
243                     // Cannot move out of Hyp mode with this function except
244                     // on an exception return
245                     if (oldMode == MODE_HYP && newMode != MODE_HYP && !affectStat
      e)
246                         validModeChange = false;
247                     // Must not change to 64 bit when running in 32 bit mode
248                     if (!opModeIs64(oldMode) && opModeIs64(newMode))
249                         validModeChange = false;
250 
251                     // If we passed all of the above then set the bit mask to
252                     // copy the mode accross
253                     if (validModeChange) {
254                         bitMask = bitMask | mask(5);
255                     } else {
256                         warn_once("Illegal change to CPSR mode attempted\n");
257                     }
258                 } else {
259                     warn_once("Ignoring write of bad mode to CPSR.\n");
260                 }
261             }
262             if (affectState)
263                 bitMask = bitMask | (1 << 5);
264         }
265 
266         return ((uint32_t)cpsr & ~bitMask) | (val & bitMask);
267     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_acf3e010f3f922cce3330ad7e69133c5f}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!cSwap@{cSwap}}
\index{cSwap@{cSwap}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{cSwap}]{\setlength{\rightskip}{0pt plus 5cm}static T cSwap (T {\em val}, \/  bool {\em big})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static, protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_acf3e010f3f922cce3330ad7e69133c5f}



\begin{DoxyCode}
317     {
318         const unsigned count = sizeof(T) / sizeof(E);
319         union {
320             T tVal;
321             E eVals[count];
322         } conv;
323         conv.tVal = htog(val);
324         if (big) {
325             for (unsigned i = 0; i < count; i++) {
326                 conv.eVals[i] = gtobe(conv.eVals[i]);
327             }
328         } else {
329             for (unsigned i = 0; i < count; i++) {
330                 conv.eVals[i] = gtole(conv.eVals[i]);
331             }
332         }
333         return gtoh(conv.tVal);
334     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_acf3e010f3f922cce3330ad7e69133c5f}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!cSwap@{cSwap}}
\index{cSwap@{cSwap}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{cSwap}]{\setlength{\rightskip}{0pt plus 5cm}static T cSwap (T {\em val}, \/  bool {\em big})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static, protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_acf3e010f3f922cce3330ad7e69133c5f}



\begin{DoxyCode}
306     {
307         if (big) {
308             return gtobe(val);
309         } else {
310             return gtole(val);
311         }
312     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a620f503b160038dbe4b15bada1adb0c9}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!disabledFault@{disabledFault}}
\index{disabledFault@{disabledFault}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{disabledFault}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} disabledFault () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a620f503b160038dbe4b15bada1adb0c9}



\begin{DoxyCode}
359     {
360         return new UndefinedInstruction(machInst, false, mnemonic, true);
361     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a1a939bcc6d227f5720f0069eabf42516}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!extendReg64@{extendReg64}}
\index{extendReg64@{extendReg64}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{extendReg64}]{\setlength{\rightskip}{0pt plus 5cm}int64\_\-t extendReg64 (uint64\_\-t {\em base}, \/  {\bf ArmExtendType} {\em type}, \/  uint64\_\-t {\em shiftAmt}, \/  uint8\_\-t {\em width}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a1a939bcc6d227f5720f0069eabf42516}



\begin{DoxyCode}
131 {
132     bool sign_extend = false;
133     int len = 0;
134     switch (type) {
135       case UXTB:
136         len = 8;
137         break;
138       case UXTH:
139         len = 16;
140         break;
141       case UXTW:
142         len = 32;
143         break;
144       case UXTX:
145         len = 64;
146         break;
147       case SXTB:
148         len = 8;
149         sign_extend = true;
150         break;
151       case SXTH:
152         len = 16;
153         sign_extend = true;
154         break;
155       case SXTW:
156         len = 32;
157         sign_extend = true;
158         break;
159       case SXTX:
160         len = 64;
161         sign_extend = true;
162         break;
163     }
164     len = len <= width - shiftAmt ? len : width - shiftAmt;
165     uint64_t tmp = (uint64_t) bits(base, len - 1, 0) << shiftAmt;
166     if (sign_extend) {
167         int sign_bit = bits(tmp, len + shiftAmt - 1);
168         tmp = sign_bit ? (tmp | ~mask(len + shiftAmt)) : tmp;
169     }
170     return tmp & mask(width);
171 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a95d323a22a5f07e14d6b4c9385a91896}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!generateDisassembly@{generateDisassembly}}
\index{generateDisassembly@{generateDisassembly}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{generateDisassembly}]{\setlength{\rightskip}{0pt plus 5cm}std::string generateDisassembly ({\bf Addr} {\em pc}, \/  const SymbolTable $\ast$ {\em symtab}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a95d323a22a5f07e14d6b4c9385a91896}


\hyperlink{classArmISA_1_1BranchImm64_a95d323a22a5f07e14d6b4c9385a91896}{BranchImm64}, \hyperlink{classArmISA_1_1BranchImmCond64_a95d323a22a5f07e14d6b4c9385a91896}{BranchImmCond64}, \hyperlink{classArmISA_1_1BranchReg64_a95d323a22a5f07e14d6b4c9385a91896}{BranchReg64}, \hyperlink{classArmISA_1_1BranchRet64_a95d323a22a5f07e14d6b4c9385a91896}{BranchRet64}, \hyperlink{classArmISA_1_1BranchEret64_a95d323a22a5f07e14d6b4c9385a91896}{BranchEret64}, \hyperlink{classArmISA_1_1BranchImmReg64_a95d323a22a5f07e14d6b4c9385a91896}{BranchImmReg64}, \hyperlink{classArmISA_1_1BranchImmImmReg64_a95d323a22a5f07e14d6b4c9385a91896}{BranchImmImmReg64}, \hyperlink{classArmISA_1_1DataXImmOp_a95d323a22a5f07e14d6b4c9385a91896}{DataXImmOp}, \hyperlink{classArmISA_1_1DataXImmOnlyOp_a95d323a22a5f07e14d6b4c9385a91896}{DataXImmOnlyOp}, \hyperlink{classArmISA_1_1DataXSRegOp_a95d323a22a5f07e14d6b4c9385a91896}{DataXSRegOp}, \hyperlink{classArmISA_1_1DataXERegOp_a95d323a22a5f07e14d6b4c9385a91896}{DataXERegOp}, \hyperlink{classArmISA_1_1DataX1RegOp_a95d323a22a5f07e14d6b4c9385a91896}{DataX1RegOp}, \hyperlink{classArmISA_1_1DataX1RegImmOp_a95d323a22a5f07e14d6b4c9385a91896}{DataX1RegImmOp}, \hyperlink{classArmISA_1_1DataX1Reg2ImmOp_a95d323a22a5f07e14d6b4c9385a91896}{DataX1Reg2ImmOp}, \hyperlink{classArmISA_1_1DataX2RegOp_a95d323a22a5f07e14d6b4c9385a91896}{DataX2RegOp}, \hyperlink{classArmISA_1_1DataX2RegImmOp_a95d323a22a5f07e14d6b4c9385a91896}{DataX2RegImmOp}, \hyperlink{classArmISA_1_1DataX3RegOp_a95d323a22a5f07e14d6b4c9385a91896}{DataX3RegOp}, \hyperlink{classArmISA_1_1DataXCondCompImmOp_a95d323a22a5f07e14d6b4c9385a91896}{DataXCondCompImmOp}, \hyperlink{classArmISA_1_1DataXCondCompRegOp_a95d323a22a5f07e14d6b4c9385a91896}{DataXCondCompRegOp}, \hyperlink{classArmISA_1_1DataXCondSelOp_a95d323a22a5f07e14d6b4c9385a91896}{DataXCondSelOp}, \hyperlink{classArmISA_1_1MicroSetPCCPSR_a95d323a22a5f07e14d6b4c9385a91896}{MicroSetPCCPSR}, \hyperlink{classArmISA_1_1MicroIntMov_a95d323a22a5f07e14d6b4c9385a91896}{MicroIntMov}, \hyperlink{classArmISA_1_1MicroIntImmOp_a95d323a22a5f07e14d6b4c9385a91896}{MicroIntImmOp}, \hyperlink{classArmISA_1_1MicroIntImmXOp_a95d323a22a5f07e14d6b4c9385a91896}{MicroIntImmXOp}, \hyperlink{classArmISA_1_1MicroIntOp_a95d323a22a5f07e14d6b4c9385a91896}{MicroIntOp}, \hyperlink{classArmISA_1_1MicroIntRegXOp_a95d323a22a5f07e14d6b4c9385a91896}{MicroIntRegXOp}, \hyperlink{classArmISA_1_1MicroMemOp_a95d323a22a5f07e14d6b4c9385a91896}{MicroMemOp}, \hyperlink{classArmISA_1_1Swap_a3134956ec18bb095818e06eb988f6c55}{Swap}, \hyperlink{classArmISA_1_1RfeOp_a3134956ec18bb095818e06eb988f6c55}{RfeOp}, \hyperlink{classArmISA_1_1SrsOp_a3134956ec18bb095818e06eb988f6c55}{SrsOp}, \hyperlink{classArmISA_1_1SysDC64_a95d323a22a5f07e14d6b4c9385a91896}{SysDC64}, \hyperlink{classArmISA_1_1MemoryImm64_a95d323a22a5f07e14d6b4c9385a91896}{MemoryImm64}, \hyperlink{classArmISA_1_1MemoryDImm64_a95d323a22a5f07e14d6b4c9385a91896}{MemoryDImm64}, \hyperlink{classArmISA_1_1MemoryDImmEx64_a95d323a22a5f07e14d6b4c9385a91896}{MemoryDImmEx64}, \hyperlink{classArmISA_1_1MemoryPreIndex64_a95d323a22a5f07e14d6b4c9385a91896}{MemoryPreIndex64}, \hyperlink{classArmISA_1_1MemoryPostIndex64_a95d323a22a5f07e14d6b4c9385a91896}{MemoryPostIndex64}, \hyperlink{classArmISA_1_1MemoryReg64_a95d323a22a5f07e14d6b4c9385a91896}{MemoryReg64}, \hyperlink{classArmISA_1_1MemoryRaw64_a95d323a22a5f07e14d6b4c9385a91896}{MemoryRaw64}, \hyperlink{classArmISA_1_1MemoryEx64_a95d323a22a5f07e14d6b4c9385a91896}{MemoryEx64}, \hyperlink{classArmISA_1_1MemoryLiteral64_a95d323a22a5f07e14d6b4c9385a91896}{MemoryLiteral64}, \hyperlink{classArmISA_1_1PredImmOp_a95d323a22a5f07e14d6b4c9385a91896}{PredImmOp}, \hyperlink{classArmISA_1_1PredIntOp_a95d323a22a5f07e14d6b4c9385a91896}{PredIntOp}, \hyperlink{classArmISA_1_1DataImmOp_a95d323a22a5f07e14d6b4c9385a91896}{DataImmOp}, \hyperlink{classArmISA_1_1DataRegOp_a95d323a22a5f07e14d6b4c9385a91896}{DataRegOp}, \hyperlink{classArmISA_1_1DataRegRegOp_a95d323a22a5f07e14d6b4c9385a91896}{DataRegRegOp}, \hyperlink{classArmISA_1_1PredMacroOp_a95d323a22a5f07e14d6b4c9385a91896}{PredMacroOp}, \hyperlink{classArmISA_1_1FpCondCompRegOp_a95d323a22a5f07e14d6b4c9385a91896}{FpCondCompRegOp}, \hyperlink{classArmISA_1_1FpCondSelOp_a95d323a22a5f07e14d6b4c9385a91896}{FpCondSelOp}, \hyperlink{classArmISA_1_1FpRegRegOp_a95d323a22a5f07e14d6b4c9385a91896}{FpRegRegOp}, \hyperlink{classArmISA_1_1FpRegImmOp_a95d323a22a5f07e14d6b4c9385a91896}{FpRegImmOp}, \hyperlink{classArmISA_1_1FpRegRegImmOp_a95d323a22a5f07e14d6b4c9385a91896}{FpRegRegImmOp}, \hyperlink{classArmISA_1_1FpRegRegRegOp_a95d323a22a5f07e14d6b4c9385a91896}{FpRegRegRegOp}, \hyperlink{classArmISA_1_1FpRegRegRegRegOp_a95d323a22a5f07e14d6b4c9385a91896}{FpRegRegRegRegOp}, と \hyperlink{classArmISA_1_1FpRegRegRegImmOp_a95d323a22a5f07e14d6b4c9385a91896}{FpRegRegRegImmOp}で再定義されています。


\begin{DoxyCode}
592 {
593     std::stringstream ss;
594     printMnemonic(ss);
595     return ss.str();
596 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a5406949b89d21af62d6d0208837130f4}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!printCondition@{printCondition}}
\index{printCondition@{printCondition}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{printCondition}]{\setlength{\rightskip}{0pt plus 5cm}void printCondition (std::ostream \& {\em os}, \/  unsigned {\em code}, \/  bool {\em noImplicit} = {\ttfamily false}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a5406949b89d21af62d6d0208837130f4}



\begin{DoxyCode}
385 {
386     switch (code) {
387       case COND_EQ:
388         os << "eq";
389         break;
390       case COND_NE:
391         os << "ne";
392         break;
393       case COND_CS:
394         os << "cs";
395         break;
396       case COND_CC:
397         os << "cc";
398         break;
399       case COND_MI:
400         os << "mi";
401         break;
402       case COND_PL:
403         os << "pl";
404         break;
405       case COND_VS:
406         os << "vs";
407         break;
408       case COND_VC:
409         os << "vc";
410         break;
411       case COND_HI:
412         os << "hi";
413         break;
414       case COND_LS:
415         os << "ls";
416         break;
417       case COND_GE:
418         os << "ge";
419         break;
420       case COND_LT:
421         os << "lt";
422         break;
423       case COND_GT:
424         os << "gt";
425         break;
426       case COND_LE:
427         os << "le";
428         break;
429       case COND_AL:
430         // This one is implicit.
431         if (noImplicit)
432             os << "al";
433         break;
434       case COND_UC:
435         // Unconditional.
436         if (noImplicit)
437             os << "uc";
438         break;
439       default:
440         panic("Unrecognized condition code %d.\n", code);
441     }
442 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a8ffe4c63f924a39c3916afb0cb24aad0}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!printDataInst@{printDataInst}}
\index{printDataInst@{printDataInst}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{printDataInst}]{\setlength{\rightskip}{0pt plus 5cm}void printDataInst (std::ostream \& {\em os}, \/  bool {\em withImm}, \/  bool {\em immShift}, \/  bool {\em s}, \/  {\bf IntRegIndex} {\em rd}, \/  {\bf IntRegIndex} {\em rn}, \/  {\bf IntRegIndex} {\em rm}, \/  {\bf IntRegIndex} {\em rs}, \/  {\bf uint32\_\-t} {\em shiftAmt}, \/  {\bf ArmShiftType} {\em type}, \/  {\bf uint32\_\-t} {\em imm}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a8ffe4c63f924a39c3916afb0cb24aad0}



\begin{DoxyCode}
562 {
563     printMnemonic(os, s ? "s" : "");
564     bool firstOp = true;
565 
566     // Destination
567     if (rd != INTREG_ZERO) {
568         firstOp = false;
569         printReg(os, rd);
570     }
571 
572     // Source 1.
573     if (rn != INTREG_ZERO) {
574         if (!firstOp)
575             os << ", ";
576         firstOp = false;
577         printReg(os, rn);
578     }
579 
580     if (!firstOp)
581         os << ", ";
582     if (withImm) {
583         ccprintf(os, "#%d", imm);
584     } else {
585         printShiftOperand(os, rm, immShift, shiftAmt, rs, type);
586     }
587 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a4acc01aec616addcddc2958cff18ec04}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!printDataInst@{printDataInst}}
\index{printDataInst@{printDataInst}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{printDataInst}]{\setlength{\rightskip}{0pt plus 5cm}void printDataInst (std::ostream \& {\em os}, \/  bool {\em withImm}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a4acc01aec616addcddc2958cff18ec04}
\hypertarget{classArmISA_1_1ArmStaticInst_a911f1c2066f7df1b82ea71902f97e6d0}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!printExtendOperand@{printExtendOperand}}
\index{printExtendOperand@{printExtendOperand}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{printExtendOperand}]{\setlength{\rightskip}{0pt plus 5cm}void printExtendOperand (bool {\em firstOperand}, \/  std::ostream \& {\em os}, \/  {\bf IntRegIndex} {\em rm}, \/  {\bf ArmExtendType} {\em type}, \/  int64\_\-t {\em shiftAmt}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a911f1c2066f7df1b82ea71902f97e6d0}



\begin{DoxyCode}
529 {
530     if (!firstOperand)
531         ccprintf(os, ", ");
532     printReg(os, rm);
533     if (type == UXTX && shiftAmt == 0)
534         return;
535     switch (type) {
536       case UXTB: ccprintf(os, ", UXTB");
537         break;
538       case UXTH: ccprintf(os, ", UXTH");
539         break;
540       case UXTW: ccprintf(os, ", UXTW");
541         break;
542       case UXTX: ccprintf(os, ", LSL");
543         break;
544       case SXTB: ccprintf(os, ", SXTB");
545         break;
546       case SXTH: ccprintf(os, ", SXTH");
547         break;
548       case SXTW: ccprintf(os, ", SXTW");
549         break;
550       case SXTX: ccprintf(os, ", SXTW");
551         break;
552     }
553     if (type == UXTX || shiftAmt)
554         ccprintf(os, " #%d", shiftAmt);
555 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a2e070f27c98b230d26db666f40256594}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!printMemSymbol@{printMemSymbol}}
\index{printMemSymbol@{printMemSymbol}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{printMemSymbol}]{\setlength{\rightskip}{0pt plus 5cm}void printMemSymbol (std::ostream \& {\em os}, \/  const SymbolTable $\ast$ {\em symtab}, \/  const std::string \& {\em prefix}, \/  const {\bf Addr} {\em addr}, \/  const std::string \& {\em suffix}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a2e070f27c98b230d26db666f40256594}



\begin{DoxyCode}
450 {
451     Addr symbolAddr;
452     std::string symbol;
453     if (symtab && symtab->findNearestSymbol(addr, symbol, symbolAddr)) {
454         ccprintf(os, "%s%s", prefix, symbol);
455         if (symbolAddr != addr)
456             ccprintf(os, "+%d", addr - symbolAddr);
457         ccprintf(os, suffix);
458     }
459 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a88eea7239477478ffadf11474ea8454f}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!printMnemonic@{printMnemonic}}
\index{printMnemonic@{printMnemonic}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{printMnemonic}]{\setlength{\rightskip}{0pt plus 5cm}void printMnemonic (std::ostream \& {\em os}, \/  const std::string \& {\em suffix} = {\ttfamily \char`\"{}\char`\"{}}, \/  bool {\em withPred} = {\ttfamily true}, \/  bool {\em withCond64} = {\ttfamily false}, \/  {\bf ConditionCode} {\em cond64} = {\ttfamily COND\_\-UC}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a88eea7239477478ffadf11474ea8454f}



\begin{DoxyCode}
348 {
349     os << "  " << mnemonic;
350     if (withPred && !aarch64) {
351         printCondition(os, machInst.condCode);
352         os << suffix;
353     } else if (withCond64) {
354         os << ".";
355         printCondition(os, cond64);
356         os << suffix;
357     }
358     if (machInst.bigThumb)
359         os << ".w";
360     os << "   ";
361 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a48f52fc281b71e29aa8733caf36546fa}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!printReg@{printReg}}
\index{printReg@{printReg}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{printReg}]{\setlength{\rightskip}{0pt plus 5cm}void printReg (std::ostream \& {\em os}, \/  int {\em reg}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a48f52fc281b71e29aa8733caf36546fa}
Print a register name for disassembly given the unique dependence tag number (FP or int). 


\begin{DoxyCode}
296 {
297     RegIndex rel_reg;
298 
299     switch (regIdxToClass(reg, &rel_reg)) {
300       case IntRegClass:
301         if (aarch64) {
302             if (reg == INTREG_UREG0)
303                 ccprintf(os, "ureg0");
304             else if (reg == INTREG_SPX)
305                ccprintf(os, "%s%s", (intWidth == 32) ? "w" : "", "sp");
306             else if (reg == INTREG_X31)
307                 ccprintf(os, "%szr", (intWidth == 32) ? "w" : "x");
308             else
309                 ccprintf(os, "%s%d", (intWidth == 32) ? "w" : "x", reg);
310         } else {
311             switch (rel_reg) {
312               case PCReg:
313                 ccprintf(os, "pc");
314                 break;
315               case StackPointerReg:
316                 ccprintf(os, "sp");
317                 break;
318               case FramePointerReg:
319                 ccprintf(os, "fp");
320                 break;
321               case ReturnAddressReg:
322                 ccprintf(os, "lr");
323                 break;
324               default:
325                 ccprintf(os, "r%d", reg);
326                 break;
327             }
328         }
329         break;
330       case FloatRegClass:
331         ccprintf(os, "f%d", rel_reg);
332         break;
333       case MiscRegClass:
334         assert(rel_reg < NUM_MISCREGS);
335         ccprintf(os, "%s", ArmISA::miscRegName[rel_reg]);
336         break;
337       case CCRegClass:
338         panic("printReg: CCRegClass but ARM has no CC regs\n");
339     }
340 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_aadac34271bfa06cdbf005536896b4a63}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!printShiftOperand@{printShiftOperand}}
\index{printShiftOperand@{printShiftOperand}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{printShiftOperand}]{\setlength{\rightskip}{0pt plus 5cm}void printShiftOperand (std::ostream \& {\em os}, \/  {\bf IntRegIndex} {\em rm}, \/  bool {\em immShift}, \/  {\bf uint32\_\-t} {\em shiftAmt}, \/  {\bf IntRegIndex} {\em rs}, \/  {\bf ArmShiftType} {\em type}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_aadac34271bfa06cdbf005536896b4a63}



\begin{DoxyCode}
468 {
469     bool firstOp = false;
470 
471     if (rm != INTREG_ZERO) {
472         printReg(os, rm);
473     }
474 
475     bool done = false;
476 
477     if ((type == LSR || type == ASR) && immShift && shiftAmt == 0)
478         shiftAmt = 32;
479 
480     switch (type) {
481       case LSL:
482         if (immShift && shiftAmt == 0) {
483             done = true;
484             break;
485         }
486         if (!firstOp)
487             os << ", ";
488         os << "LSL";
489         break;
490       case LSR:
491         if (!firstOp)
492             os << ", ";
493         os << "LSR";
494         break;
495       case ASR:
496         if (!firstOp)
497             os << ", ";
498         os << "ASR";
499         break;
500       case ROR:
501         if (immShift && shiftAmt == 0) {
502             if (!firstOp)
503                 os << ", ";
504             os << "RRX";
505             done = true;
506             break;
507         }
508         if (!firstOp)
509             os << ", ";
510         os << "ROR";
511         break;
512       default:
513         panic("Tried to disassemble unrecognized shift type.\n");
514     }
515     if (!done) {
516         if (!firstOp)
517             os << " ";
518         if (immShift)
519             os << "#" << shiftAmt;
520         else
521             printReg(os, rs);
522     }
523 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_ae7bcb973c05eaba610f0c9bcd5a613d7}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!printTarget@{printTarget}}
\index{printTarget@{printTarget}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{printTarget}]{\setlength{\rightskip}{0pt plus 5cm}void printTarget (std::ostream \& {\em os}, \/  {\bf Addr} {\em target}, \/  const SymbolTable $\ast$ {\em symtab}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_ae7bcb973c05eaba610f0c9bcd5a613d7}



\begin{DoxyCode}
366 {
367     Addr symbolAddr;
368     std::string symbol;
369 
370     if (symtab && symtab->findNearestSymbol(target, symbol, symbolAddr)) {
371         ccprintf(os, "<%s", symbol);
372         if (symbolAddr != target)
373             ccprintf(os, "+%d>", target - symbolAddr);
374         else
375             ccprintf(os, ">");
376     } else {
377         ccprintf(os, "%#x", target);
378     }
379 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a8895f5e6ea72acdc881a4a2811d8061d}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!readPC@{readPC}}
\index{readPC@{readPC}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{readPC}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf Addr} readPC (XC $\ast$ {\em xc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static, protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a8895f5e6ea72acdc881a4a2811d8061d}



\begin{DoxyCode}
290     {
291         return xc->pcState().instPC();
292     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_acd2842ccffb92bb276c016c87155bc67}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!satInt@{satInt}}
\index{satInt@{satInt}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{satInt}]{\setlength{\rightskip}{0pt plus 5cm}static bool satInt (int32\_\-t \& {\em res}, \/  int64\_\-t {\em op}, \/  int {\em width})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static, protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_acd2842ccffb92bb276c016c87155bc67}



\begin{DoxyCode}
96     {
97         width--;
98         if (op >= (LL(1) << width)) {
99             res = (LL(1) << width) - 1;
100             return true;
101         } else if (op < -(LL(1) << width)) {
102             res = -(LL(1) << width);
103             return true;
104         } else {
105             res = op;
106             return false;
107         }
108     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_ac89dee160ae86de9876da96a1df9ca67}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!saturateOp@{saturateOp}}
\index{saturateOp@{saturateOp}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{saturateOp}]{\setlength{\rightskip}{0pt plus 5cm}static bool saturateOp (int32\_\-t \& {\em res}, \/  int64\_\-t {\em op1}, \/  int64\_\-t {\em op2}, \/  bool {\em sub} = {\ttfamily false})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static, protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_ac89dee160ae86de9876da96a1df9ca67}



\begin{DoxyCode}
80     {
81         int64_t midRes = sub ? (op1 - op2) : (op1 + op2);
82         if (bits(midRes, width) != bits(midRes, width - 1)) {
83             if (midRes > 0)
84                 res = (LL(1) << (width - 1)) - 1;
85             else
86                 res = -(LL(1) << (width - 1));
87             return true;
88         } else {
89             res = midRes;
90             return false;
91         }
92     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a9345b4f7094d39b12eed323ddc30a6bf}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!setAIWNextPC@{setAIWNextPC}}
\index{setAIWNextPC@{setAIWNextPC}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{setAIWNextPC}]{\setlength{\rightskip}{0pt plus 5cm}static void setAIWNextPC (XC $\ast$ {\em xc}, \/  {\bf Addr} {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static, protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a9345b4f7094d39b12eed323ddc30a6bf}



\begin{DoxyCode}
351     {
352         PCState pc = xc->pcState();
353         pc.instAIWNPC(val);
354         xc->pcState(pc);
355     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a7ef87b5f37a06b7143d275af2ab6444a}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!setIWNextPC@{setIWNextPC}}
\index{setIWNextPC@{setIWNextPC}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{setIWNextPC}]{\setlength{\rightskip}{0pt plus 5cm}static void setIWNextPC (XC $\ast$ {\em xc}, \/  {\bf Addr} {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static, protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a7ef87b5f37a06b7143d275af2ab6444a}



\begin{DoxyCode}
340     {
341         PCState pc = xc->pcState();
342         pc.instIWNPC(val);
343         xc->pcState(pc);
344     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a8a008e37d143524d0c3aba6e7c835f44}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!setNextPC@{setNextPC}}
\index{setNextPC@{setNextPC}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{setNextPC}]{\setlength{\rightskip}{0pt plus 5cm}static void setNextPC (XC $\ast$ {\em xc}, \/  {\bf Addr} {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static, protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a8a008e37d143524d0c3aba6e7c835f44}



\begin{DoxyCode}
297     {
298         PCState pc = xc->pcState();
299         pc.instNPC(val);
300         xc->pcState(pc);
301     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a0d5e73a81869e11788298814fcdbc6d5}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!shift\_\-carry\_\-imm@{shift\_\-carry\_\-imm}}
\index{shift\_\-carry\_\-imm@{shift\_\-carry\_\-imm}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{shift\_\-carry\_\-imm}]{\setlength{\rightskip}{0pt plus 5cm}bool shift\_\-carry\_\-imm ({\bf uint32\_\-t} {\em base}, \/  {\bf uint32\_\-t} {\em shamt}, \/  {\bf uint32\_\-t} {\em type}, \/  {\bf uint32\_\-t} {\em cfval}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a0d5e73a81869e11788298814fcdbc6d5}



\begin{DoxyCode}
217 {
218     enum ArmShiftType shiftType;
219     shiftType = (enum ArmShiftType) type;
220 
221     switch (shiftType)
222     {
223       case LSL:
224         if (shamt == 0)
225             return cfval;
226         else
227             return (base >> (32 - shamt)) & 1;
228       case LSR:
229         if (shamt == 0)
230             return (base >> 31);
231         else
232             return (base >> (shamt - 1)) & 1;
233       case ASR:
234         if (shamt == 0)
235             return (base >> 31);
236         else
237             return (base >> (shamt - 1)) & 1;
238       case ROR:
239         shamt = shamt & 0x1f;
240         if (shamt == 0)
241             return (base & 1); // RRX
242         else
243             return (base >> (shamt - 1)) & 1;
244       default:
245         ccprintf(std::cerr, "Unhandled shift type\n");
246         exit(1);
247         break;
248     }
249     return 0;
250 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a75fefade18d7fe86d23af0c7944eab6b}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!shift\_\-carry\_\-rs@{shift\_\-carry\_\-rs}}
\index{shift\_\-carry\_\-rs@{shift\_\-carry\_\-rs}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{shift\_\-carry\_\-rs}]{\setlength{\rightskip}{0pt plus 5cm}bool shift\_\-carry\_\-rs ({\bf uint32\_\-t} {\em base}, \/  {\bf uint32\_\-t} {\em shamt}, \/  {\bf uint32\_\-t} {\em type}, \/  {\bf uint32\_\-t} {\em cfval}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a75fefade18d7fe86d23af0c7944eab6b}



\begin{DoxyCode}
257 {
258     enum ArmShiftType shiftType;
259     shiftType = (enum ArmShiftType) type;
260 
261     if (shamt == 0)
262         return cfval;
263 
264     switch (shiftType)
265     {
266       case LSL:
267         if (shamt > 32)
268             return 0;
269         else
270             return (base >> (32 - shamt)) & 1;
271       case LSR:
272         if (shamt > 32)
273             return 0;
274         else
275             return (base >> (shamt - 1)) & 1;
276       case ASR:
277         if (shamt > 32)
278             shamt = 32;
279         return (base >> (shamt - 1)) & 1;
280       case ROR:
281         shamt = shamt & 0x1f;
282         if (shamt == 0)
283             shamt = 32;
284         return (base >> (shamt - 1)) & 1;
285       default:
286         ccprintf(std::cerr, "Unhandled shift type\n");
287         exit(1);
288         break;
289     }
290     return 0;
291 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a3bf2cda24ceeea2d93bb03f88ddeec19}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!shift\_\-rm\_\-imm@{shift\_\-rm\_\-imm}}
\index{shift\_\-rm\_\-imm@{shift\_\-rm\_\-imm}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{shift\_\-rm\_\-imm}]{\setlength{\rightskip}{0pt plus 5cm}int32\_\-t shift\_\-rm\_\-imm ({\bf uint32\_\-t} {\em base}, \/  {\bf uint32\_\-t} {\em shamt}, \/  {\bf uint32\_\-t} {\em type}, \/  {\bf uint32\_\-t} {\em cfval}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a3bf2cda24ceeea2d93bb03f88ddeec19}



\begin{DoxyCode}
57 {
58     assert(shamt < 32);
59     ArmShiftType shiftType;
60     shiftType = (ArmShiftType)type;
61 
62     switch (shiftType)
63     {
64       case LSL:
65         return base << shamt;
66       case LSR:
67         if (shamt == 0)
68             return 0;
69         else
70             return base >> shamt;
71       case ASR:
72         if (shamt == 0)
73             return (base >> 31) | -((base & (1 << 31)) >> 31);
74         else
75             return (base >> shamt) | -((base & (1 << 31)) >> shamt);
76       case ROR:
77         if (shamt == 0)
78             return (cfval << 31) | (base >> 1); // RRX
79         else
80             return (base << (32 - shamt)) | (base >> shamt);
81       default:
82         ccprintf(std::cerr, "Unhandled shift type\n");
83         exit(1);
84         break;
85     }
86     return 0;
87 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a9c90a343b88f159bcb263bd2457848a5}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!shift\_\-rm\_\-rs@{shift\_\-rm\_\-rs}}
\index{shift\_\-rm\_\-rs@{shift\_\-rm\_\-rs}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{shift\_\-rm\_\-rs}]{\setlength{\rightskip}{0pt plus 5cm}int32\_\-t shift\_\-rm\_\-rs ({\bf uint32\_\-t} {\em base}, \/  {\bf uint32\_\-t} {\em shamt}, \/  {\bf uint32\_\-t} {\em type}, \/  {\bf uint32\_\-t} {\em cfval}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a9c90a343b88f159bcb263bd2457848a5}



\begin{DoxyCode}
177 {
178     enum ArmShiftType shiftType;
179     shiftType = (enum ArmShiftType) type;
180 
181     switch (shiftType)
182     {
183       case LSL:
184         if (shamt >= 32)
185             return 0;
186         else
187             return base << shamt;
188       case LSR:
189         if (shamt >= 32)
190             return 0;
191         else
192             return base >> shamt;
193       case ASR:
194         if (shamt >= 32)
195             return (base >> 31) | -((base & (1 << 31)) >> 31);
196         else
197             return (base >> shamt) | -((base & (1 << 31)) >> shamt);
198       case ROR:
199         shamt = shamt & 0x1f;
200         if (shamt == 0)
201             return base;
202         else
203             return (base << (32 - shamt)) | (base >> shamt);
204       default:
205         ccprintf(std::cerr, "Unhandled shift type\n");
206         exit(1);
207         break;
208     }
209     return 0;
210 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_ab15bd99705b24d9b8d647aba628ee562}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!shiftReg64@{shiftReg64}}
\index{shiftReg64@{shiftReg64}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{shiftReg64}]{\setlength{\rightskip}{0pt plus 5cm}int64\_\-t shiftReg64 (uint64\_\-t {\em base}, \/  uint64\_\-t {\em shiftAmt}, \/  {\bf ArmShiftType} {\em type}, \/  uint8\_\-t {\em width}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_ab15bd99705b24d9b8d647aba628ee562}



\begin{DoxyCode}
92 {
93     shiftAmt = shiftAmt % width;
94     ArmShiftType shiftType;
95     shiftType = (ArmShiftType)type;
96 
97     switch (shiftType)
98     {
99       case LSL:
100         return base << shiftAmt;
101       case LSR:
102         if (shiftAmt == 0)
103             return base;
104         else
105             return (base & mask(width)) >> shiftAmt;
106       case ASR:
107         if (shiftAmt == 0) {
108             return base;
109         } else {
110             int sign_bit = bits(base, intWidth - 1);
111             base >>= shiftAmt;
112             base = sign_bit ? (base | ~mask(intWidth - shiftAmt)) : base;
113             return base & mask(intWidth);
114         }
115       case ROR:
116         if (shiftAmt == 0)
117             return base;
118         else
119             return (base << (width - shiftAmt)) | (base >> shiftAmt);
120       default:
121         ccprintf(std::cerr, "Unhandled shift type\n");
122         exit(1);
123         break;
124     }
125     return 0;
126 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a2fd5209011bb73f8cccbb7c3ff60a553}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!spsrWriteByInstr@{spsrWriteByInstr}}
\index{spsrWriteByInstr@{spsrWriteByInstr}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{spsrWriteByInstr}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf uint32\_\-t} spsrWriteByInstr ({\bf uint32\_\-t} {\em spsr}, \/  {\bf uint32\_\-t} {\em val}, \/  uint8\_\-t {\em byteMask}, \/  bool {\em affectState})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static, protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a2fd5209011bb73f8cccbb7c3ff60a553}



\begin{DoxyCode}
272     {
273         uint32_t bitMask = 0;
274 
275         if (bits(byteMask, 3))
276             bitMask = bitMask | mask(31, 24);
277         if (bits(byteMask, 2))
278             bitMask = bitMask | mask(19, 16);
279         if (bits(byteMask, 1))
280             bitMask = bitMask | mask(15, 8);
281         if (bits(byteMask, 0))
282             bitMask = bitMask | mask(7, 0);
283 
284         return ((spsr & ~bitMask) | (val & bitMask));
285     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a1836673d51155a1d5792744da88eb51b}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!uSatInt@{uSatInt}}
\index{uSatInt@{uSatInt}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{uSatInt}]{\setlength{\rightskip}{0pt plus 5cm}static bool uSatInt (int32\_\-t \& {\em res}, \/  int64\_\-t {\em op}, \/  int {\em width})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static, protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a1836673d51155a1d5792744da88eb51b}



\begin{DoxyCode}
129     {
130         if (op >= (LL(1) << width)) {
131             res = (LL(1) << width) - 1;
132             return true;
133         } else if (op < 0) {
134             res = 0;
135             return true;
136         } else {
137             res = op;
138             return false;
139         }
140     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1ArmStaticInst_a588c48bae73d27c932022c7738612e28}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!uSaturateOp@{uSaturateOp}}
\index{uSaturateOp@{uSaturateOp}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{uSaturateOp}]{\setlength{\rightskip}{0pt plus 5cm}static bool uSaturateOp ({\bf uint32\_\-t} \& {\em res}, \/  int64\_\-t {\em op1}, \/  int64\_\-t {\em op2}, \/  bool {\em sub} = {\ttfamily false})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, static, protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a588c48bae73d27c932022c7738612e28}



\begin{DoxyCode}
113     {
114         int64_t midRes = sub ? (op1 - op2) : (op1 + op2);
115         if (midRes >= (LL(1) << width)) {
116             res = (LL(1) << width) - 1;
117             return true;
118         } else if (midRes < 0) {
119             res = 0;
120             return true;
121         } else {
122             res = midRes;
123             return false;
124         }
125     }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classArmISA_1_1ArmStaticInst_a52c06c8a54293998f3e1f71cdbd916f7}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!aarch64@{aarch64}}
\index{aarch64@{aarch64}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{aarch64}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf aarch64}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a52c06c8a54293998f3e1f71cdbd916f7}
\hypertarget{classArmISA_1_1ArmStaticInst_a2a06976c0a3797444170f251f34bd40a}{
\index{ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}!intWidth@{intWidth}}
\index{intWidth@{intWidth}!ArmISA::ArmStaticInst@{ArmISA::ArmStaticInst}}
\subsubsection[{intWidth}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf intWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classArmISA_1_1ArmStaticInst_a2a06976c0a3797444170f251f34bd40a}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/arm/insts/\hyperlink{arch_2arm_2insts_2static__inst_8hh}{static\_\-inst.hh}\item 
arch/arm/insts/\hyperlink{arch_2arm_2insts_2static__inst_8cc}{static\_\-inst.cc}\end{DoxyCompactItemize}
