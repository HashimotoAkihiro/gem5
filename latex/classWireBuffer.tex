\hypertarget{classWireBuffer}{
\section{クラス WireBuffer}
\label{classWireBuffer}\index{WireBuffer@{WireBuffer}}
}


{\ttfamily \#include $<$WireBuffer.hh$>$}WireBufferに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classWireBuffer}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classWireBuffer_1_1RubyWireBuffer}{RubyWireBuffer}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef RubyWireBufferParams \hyperlink{classWireBuffer_a7ad77180949dea9bc226a0f7571391a0}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classWireBuffer_ae9a9cdc14adf2ac6984bab0b253d2cec}{WireBuffer} (const \hyperlink{classWireBuffer_a7ad77180949dea9bc226a0f7571391a0}{Params} $\ast$p)
\item 
void \hyperlink{classWireBuffer_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
\hyperlink{classWireBuffer_ab5bf2bdbeae187001e2184d5fdf106c8}{$\sim$WireBuffer} ()
\item 
void \hyperlink{classWireBuffer_ae674290a26ecbd622c5160e38e8a4fe9}{wakeup} ()
\item 
void \hyperlink{classWireBuffer_a8487c37680239f103e21ada9acf1726d}{setConsumer} (\hyperlink{classConsumer}{Consumer} $\ast$consumer\_\-ptr)
\item 
\hyperlink{classConsumer}{Consumer} $\ast$ \hyperlink{classWireBuffer_a2417fc7252a612b5c976ceaa2d1be4f7}{getConsumer} ()
\item 
void \hyperlink{classWireBuffer_a9cdbe64eebafb111a124edec55ed2340}{setDescription} (const std::string \&name)
\item 
std::string \hyperlink{classWireBuffer_a73da75c3e5ec30855a02eae2ba824e38}{getDescription} ()
\item 
void \hyperlink{classWireBuffer_aef2cd392bb1d0b136dc1d901d6e59f13}{enqueue} (\hyperlink{classRefCountingPtr}{MsgPtr} message, \hyperlink{classCycles}{Cycles} latency)
\item 
void \hyperlink{classWireBuffer_a851b6644e3e336c07f8e6fe77234b97f}{dequeue} ()
\item 
const \hyperlink{classMessage}{Message} $\ast$ \hyperlink{classWireBuffer_ab635dc32ebecf260c15d8fbbbb9b21e0}{peek} ()
\item 
\hyperlink{classMessageBufferNode}{MessageBufferNode} \hyperlink{classWireBuffer_a719ec7b793f4cb9336241e7c9a405323}{peekNode} ()
\item 
void \hyperlink{classWireBuffer_a98102238652df03cf871c9766de96af2}{recycle} ()
\item 
bool \hyperlink{classWireBuffer_acbed040576a7a18e2d9c46b2f15e0162}{isReady} ()
\item 
bool \hyperlink{classWireBuffer_a99a0d76f7266570912e6b0901cfaf9cf}{areNSlotsAvailable} (int n)
\item 
void \hyperlink{classWireBuffer_ac55fe386a101fbae38c716067c9966a0}{print} (std::ostream \&out) const 
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
uint64\_\-t \hyperlink{classWireBuffer_a3d60a9aaa917e449f52162fd0e6d3f25}{m\_\-msg\_\-counter}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classWireBuffer_af3ac0ff9352e0f326be850ddb42f95d5}{WireBuffer} (const \hyperlink{classWireBuffer}{WireBuffer} \&obj)
\item 
\hyperlink{classWireBuffer}{WireBuffer} \& \hyperlink{classWireBuffer_add880f9d0522944b0126f058cc4276b7}{operator=} (const \hyperlink{classWireBuffer}{WireBuffer} \&obj)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classConsumer}{Consumer} $\ast$ \hyperlink{classWireBuffer_a83dd1dc8eef330b0c0d184a4167b26b4}{m\_\-consumer\_\-ptr}
\item 
std::string \hyperlink{classWireBuffer_ad50eef5f7fcfa30f62e14f0fac2a4f6e}{m\_\-description}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMessageBufferNode}{MessageBufferNode} $>$ \hyperlink{classWireBuffer_a39fe545546f6c318a857521c207f2823}{m\_\-message\_\-queue}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classWireBuffer_a7ad77180949dea9bc226a0f7571391a0}{
\index{WireBuffer@{WireBuffer}!Params@{Params}}
\index{Params@{Params}!WireBuffer@{WireBuffer}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef RubyWireBufferParams {\bf Params}}}
\label{classWireBuffer_a7ad77180949dea9bc226a0f7571391a0}


\hyperlink{classSimObject_a0f0761d2db586a23bb2a2880b8f387bb}{SimObject}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classWireBuffer_ae9a9cdc14adf2ac6984bab0b253d2cec}{
\index{WireBuffer@{WireBuffer}!WireBuffer@{WireBuffer}}
\index{WireBuffer@{WireBuffer}!WireBuffer@{WireBuffer}}
\subsubsection[{WireBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf WireBuffer} (const {\bf Params} $\ast$ {\em p})}}
\label{classWireBuffer_ae9a9cdc14adf2ac6984bab0b253d2cec}



\begin{DoxyCode}
58     : SimObject(p)
59 {
60     m_msg_counter = 0;
61 }
\end{DoxyCode}
\hypertarget{classWireBuffer_ab5bf2bdbeae187001e2184d5fdf106c8}{
\index{WireBuffer@{WireBuffer}!$\sim$WireBuffer@{$\sim$WireBuffer}}
\index{$\sim$WireBuffer@{$\sim$WireBuffer}!WireBuffer@{WireBuffer}}
\subsubsection[{$\sim$WireBuffer}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf WireBuffer} ()}}
\label{classWireBuffer_ab5bf2bdbeae187001e2184d5fdf106c8}



\begin{DoxyCode}
69 {
70 }
\end{DoxyCode}
\hypertarget{classWireBuffer_af3ac0ff9352e0f326be850ddb42f95d5}{
\index{WireBuffer@{WireBuffer}!WireBuffer@{WireBuffer}}
\index{WireBuffer@{WireBuffer}!WireBuffer@{WireBuffer}}
\subsubsection[{WireBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf WireBuffer} (const {\bf WireBuffer} \& {\em obj})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classWireBuffer_af3ac0ff9352e0f326be850ddb42f95d5}


\subsection{関数}
\hypertarget{classWireBuffer_a99a0d76f7266570912e6b0901cfaf9cf}{
\index{WireBuffer@{WireBuffer}!areNSlotsAvailable@{areNSlotsAvailable}}
\index{areNSlotsAvailable@{areNSlotsAvailable}!WireBuffer@{WireBuffer}}
\subsubsection[{areNSlotsAvailable}]{\setlength{\rightskip}{0pt plus 5cm}bool areNSlotsAvailable (int {\em n})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classWireBuffer_a99a0d76f7266570912e6b0901cfaf9cf}



\begin{DoxyCode}
81 { return true; };  // infinite queue length
\end{DoxyCode}
\hypertarget{classWireBuffer_a851b6644e3e336c07f8e6fe77234b97f}{
\index{WireBuffer@{WireBuffer}!dequeue@{dequeue}}
\index{dequeue@{dequeue}!WireBuffer@{WireBuffer}}
\subsubsection[{dequeue}]{\setlength{\rightskip}{0pt plus 5cm}void dequeue ()}}
\label{classWireBuffer_a851b6644e3e336c07f8e6fe77234b97f}



\begin{DoxyCode}
92 {
93     assert(isReady());
94     pop_heap(m_message_queue.begin(), m_message_queue.end(),
95         greater<MessageBufferNode>());
96     m_message_queue.pop_back();
97 }
\end{DoxyCode}
\hypertarget{classWireBuffer_aef2cd392bb1d0b136dc1d901d6e59f13}{
\index{WireBuffer@{WireBuffer}!enqueue@{enqueue}}
\index{enqueue@{enqueue}!WireBuffer@{WireBuffer}}
\subsubsection[{enqueue}]{\setlength{\rightskip}{0pt plus 5cm}void enqueue ({\bf MsgPtr} {\em message}, \/  {\bf Cycles} {\em latency})}}
\label{classWireBuffer_aef2cd392bb1d0b136dc1d901d6e59f13}



\begin{DoxyCode}
74 {
75     m_msg_counter++;
76     Cycles current_time = g_system_ptr->curCycle();
77     Cycles arrival_time = current_time + latency;
78     assert(arrival_time > current_time);
79 
80     MessageBufferNode thisNode(arrival_time, m_msg_counter, message);
81     m_message_queue.push_back(thisNode);
82     if (m_consumer_ptr != NULL) {
83         m_consumer_ptr->
84             scheduleEventAbsolute(g_system_ptr->clockPeriod() * arrival_time);
85     } else {
86         panic("No Consumer for WireBuffer! %s\n", *this);
87     }
88 }
\end{DoxyCode}
\hypertarget{classWireBuffer_a2417fc7252a612b5c976ceaa2d1be4f7}{
\index{WireBuffer@{WireBuffer}!getConsumer@{getConsumer}}
\index{getConsumer@{getConsumer}!WireBuffer@{WireBuffer}}
\subsubsection[{getConsumer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Consumer}$\ast$ getConsumer ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classWireBuffer_a2417fc7252a612b5c976ceaa2d1be4f7}



\begin{DoxyCode}
71 { return m_consumer_ptr; };
\end{DoxyCode}
\hypertarget{classWireBuffer_a73da75c3e5ec30855a02eae2ba824e38}{
\index{WireBuffer@{WireBuffer}!getDescription@{getDescription}}
\index{getDescription@{getDescription}!WireBuffer@{WireBuffer}}
\subsubsection[{getDescription}]{\setlength{\rightskip}{0pt plus 5cm}std::string getDescription ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classWireBuffer_a73da75c3e5ec30855a02eae2ba824e38}



\begin{DoxyCode}
73 { return m_description; };
\end{DoxyCode}
\hypertarget{classWireBuffer_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{WireBuffer@{WireBuffer}!init@{init}}
\index{init@{init}!WireBuffer@{WireBuffer}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classWireBuffer_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classWireBuffer_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{SimObject}を再定義しています。


\begin{DoxyCode}
65 {
66 }
\end{DoxyCode}
\hypertarget{classWireBuffer_acbed040576a7a18e2d9c46b2f15e0162}{
\index{WireBuffer@{WireBuffer}!isReady@{isReady}}
\index{isReady@{isReady}!WireBuffer@{WireBuffer}}
\subsubsection[{isReady}]{\setlength{\rightskip}{0pt plus 5cm}bool isReady ()}}
\label{classWireBuffer_acbed040576a7a18e2d9c46b2f15e0162}



\begin{DoxyCode}
138 {
139     return ((!m_message_queue.empty()) &&
140             (m_message_queue.front().m_time <= g_system_ptr->curCycle()));
141 }
\end{DoxyCode}
\hypertarget{classWireBuffer_add880f9d0522944b0126f058cc4276b7}{
\index{WireBuffer@{WireBuffer}!operator=@{operator=}}
\index{operator=@{operator=}!WireBuffer@{WireBuffer}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf WireBuffer}\& operator= (const {\bf WireBuffer} \& {\em obj})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classWireBuffer_add880f9d0522944b0126f058cc4276b7}
\hypertarget{classWireBuffer_ab635dc32ebecf260c15d8fbbbb9b21e0}{
\index{WireBuffer@{WireBuffer}!peek@{peek}}
\index{peek@{peek}!WireBuffer@{WireBuffer}}
\subsubsection[{peek}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Message} $\ast$ peek ()}}
\label{classWireBuffer_ab635dc32ebecf260c15d8fbbbb9b21e0}



\begin{DoxyCode}
101 {
102     MessageBufferNode node = peekNode();
103     Message* msg_ptr = node.m_msgptr.get();
104     assert(msg_ptr != NULL);
105     return msg_ptr;
106 }
\end{DoxyCode}
\hypertarget{classWireBuffer_a719ec7b793f4cb9336241e7c9a405323}{
\index{WireBuffer@{WireBuffer}!peekNode@{peekNode}}
\index{peekNode@{peekNode}!WireBuffer@{WireBuffer}}
\subsubsection[{peekNode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MessageBufferNode} peekNode ()}}
\label{classWireBuffer_a719ec7b793f4cb9336241e7c9a405323}



\begin{DoxyCode}
110 {
111     assert(isReady());
112     MessageBufferNode req = m_message_queue.front();
113     return req;
114 }
\end{DoxyCode}
\hypertarget{classWireBuffer_ac55fe386a101fbae38c716067c9966a0}{
\index{WireBuffer@{WireBuffer}!print@{print}}
\index{print@{print}!WireBuffer@{WireBuffer}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}void print (std::ostream \& {\em out}) const}}
\label{classWireBuffer_ac55fe386a101fbae38c716067c9966a0}
\hypertarget{classWireBuffer_a98102238652df03cf871c9766de96af2}{
\index{WireBuffer@{WireBuffer}!recycle@{recycle}}
\index{recycle@{recycle}!WireBuffer@{WireBuffer}}
\subsubsection[{recycle}]{\setlength{\rightskip}{0pt plus 5cm}void recycle ()}}
\label{classWireBuffer_a98102238652df03cf871c9766de96af2}



\begin{DoxyCode}
118 {
119     // Because you don't want anything reordered, make sure the recycle latency
120     // is just 1 cycle. As a result, you really want to use this only in
121     // Wire-like situations because you don't want to deadlock as a result of
122     // being stuck behind something if you're not actually supposed to.
123     assert(isReady());
124     MessageBufferNode node = m_message_queue.front();
125     pop_heap(m_message_queue.begin(), m_message_queue.end(),
126         greater<MessageBufferNode>());
127 
128     node.m_time = g_system_ptr->curCycle() + Cycles(1);
129     m_message_queue.back() = node;
130     push_heap(m_message_queue.begin(), m_message_queue.end(),
131         greater<MessageBufferNode>());
132     m_consumer_ptr->
133         scheduleEventAbsolute(g_system_ptr->clockPeriod() * node.m_time);
134 }
\end{DoxyCode}
\hypertarget{classWireBuffer_a8487c37680239f103e21ada9acf1726d}{
\index{WireBuffer@{WireBuffer}!setConsumer@{setConsumer}}
\index{setConsumer@{setConsumer}!WireBuffer@{WireBuffer}}
\subsubsection[{setConsumer}]{\setlength{\rightskip}{0pt plus 5cm}void setConsumer ({\bf Consumer} $\ast$ {\em consumer\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classWireBuffer_a8487c37680239f103e21ada9acf1726d}



\begin{DoxyCode}
68     {
69         m_consumer_ptr = consumer_ptr;
70     }
\end{DoxyCode}
\hypertarget{classWireBuffer_a9cdbe64eebafb111a124edec55ed2340}{
\index{WireBuffer@{WireBuffer}!setDescription@{setDescription}}
\index{setDescription@{setDescription}!WireBuffer@{WireBuffer}}
\subsubsection[{setDescription}]{\setlength{\rightskip}{0pt plus 5cm}void setDescription (const std::string \& {\em name})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classWireBuffer_a9cdbe64eebafb111a124edec55ed2340}



\begin{DoxyCode}
72 { m_description = name; };
\end{DoxyCode}
\hypertarget{classWireBuffer_ae674290a26ecbd622c5160e38e8a4fe9}{
\index{WireBuffer@{WireBuffer}!wakeup@{wakeup}}
\index{wakeup@{wakeup}!WireBuffer@{WireBuffer}}
\subsubsection[{wakeup}]{\setlength{\rightskip}{0pt plus 5cm}void wakeup ()}}
\label{classWireBuffer_ae674290a26ecbd622c5160e38e8a4fe9}



\begin{DoxyCode}
150 {
151 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classWireBuffer_a83dd1dc8eef330b0c0d184a4167b26b4}{
\index{WireBuffer@{WireBuffer}!m\_\-consumer\_\-ptr@{m\_\-consumer\_\-ptr}}
\index{m\_\-consumer\_\-ptr@{m\_\-consumer\_\-ptr}!WireBuffer@{WireBuffer}}
\subsubsection[{m\_\-consumer\_\-ptr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Consumer}$\ast$ {\bf m\_\-consumer\_\-ptr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classWireBuffer_a83dd1dc8eef330b0c0d184a4167b26b4}
\hypertarget{classWireBuffer_ad50eef5f7fcfa30f62e14f0fac2a4f6e}{
\index{WireBuffer@{WireBuffer}!m\_\-description@{m\_\-description}}
\index{m\_\-description@{m\_\-description}!WireBuffer@{WireBuffer}}
\subsubsection[{m\_\-description}]{\setlength{\rightskip}{0pt plus 5cm}std::string {\bf m\_\-description}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classWireBuffer_ad50eef5f7fcfa30f62e14f0fac2a4f6e}
\hypertarget{classWireBuffer_a39fe545546f6c318a857521c207f2823}{
\index{WireBuffer@{WireBuffer}!m\_\-message\_\-queue@{m\_\-message\_\-queue}}
\index{m\_\-message\_\-queue@{m\_\-message\_\-queue}!WireBuffer@{WireBuffer}}
\subsubsection[{m\_\-message\_\-queue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf MessageBufferNode}$>$ {\bf m\_\-message\_\-queue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classWireBuffer_a39fe545546f6c318a857521c207f2823}
\hypertarget{classWireBuffer_a3d60a9aaa917e449f52162fd0e6d3f25}{
\index{WireBuffer@{WireBuffer}!m\_\-msg\_\-counter@{m\_\-msg\_\-counter}}
\index{m\_\-msg\_\-counter@{m\_\-msg\_\-counter}!WireBuffer@{WireBuffer}}
\subsubsection[{m\_\-msg\_\-counter}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf m\_\-msg\_\-counter}}}
\label{classWireBuffer_a3d60a9aaa917e449f52162fd0e6d3f25}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/ruby/system/\hyperlink{WireBuffer_8hh}{WireBuffer.hh}\item 
mem/ruby/system/\hyperlink{WireBuffer_8cc}{WireBuffer.cc}\end{DoxyCompactItemize}
