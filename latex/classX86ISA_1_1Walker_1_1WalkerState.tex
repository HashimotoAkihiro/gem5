\hypertarget{classX86ISA_1_1Walker_1_1WalkerState}{
\section{クラス WalkerState}
\label{classX86ISA_1_1Walker_1_1WalkerState}\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
}


{\ttfamily \#include $<$pagetable\_\-walker.hh$>$}\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classX86ISA_1_1Walker_1_1WalkerState_ac84e175444e79eb369ed3d6debdb601f}{WalkerState} (\hyperlink{classX86ISA_1_1Walker}{Walker} $\ast$\_\-walker, \hyperlink{classBaseTLB_1_1Translation}{BaseTLB::Translation} $\ast$\_\-translation, \hyperlink{classRequest}{RequestPtr} \_\-req, bool \_\-isFunctional=false)
\item 
void \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a92aeb88528be9893c2e8fe61629fc942}{initState} (\hyperlink{classThreadContext}{ThreadContext} $\ast$\_\-tc, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{BaseTLB::Mode} \_\-mode, bool \_\-isTiming=false)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_abe41f563c4251c8a075c343d770369ac}{startWalk} ()
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_ac1af47bc545fc273626009cb651d3b39}{startFunctional} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \&\hyperlink{namespaceX86ISA_ab705917f60c5566f9ce56a93f798b2e2}{addr}, unsigned \&logBytes)
\item 
bool \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_ac6c4ea75aa4bd19a760aca940fad8876}{recvPacket} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a46197e29b4fb481e9f1a932fbbf44586}{isRetrying} ()
\item 
bool \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a0335da57d5042e3a3dcfb9635cd3d1ca}{wasStarted} ()
\item 
bool \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a9dc00933e3ae5f8801363f2288084154}{isTiming} ()
\item 
void \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a549fc33ae3e5c345795b8384a91fb544}{retry} ()
\item 
std::string \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classX86ISA_1_1Walker}{Walker} $\ast$ \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a54537e5fcbe2d6f609ca4c90a48a06a8}{walker}
\item 
\hyperlink{classThreadContext}{ThreadContext} $\ast$ \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a4455a4759e69e5ebe68ae7298cbcc37d}{tc}
\item 
\hyperlink{classRequest}{RequestPtr} \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a956cd41d82347558b9c0a5b0474903f2}{req}
\item 
\hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8}{State} \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a876b486d3a5241a126bd5751c5f70f79}{state}
\item 
\hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8}{State} \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a02eca985bd74ea3c516fd47e6f1a7a0d}{nextState}
\item 
int \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a8c8e474bb8d2c6f7162455416b488e50}{dataSize}
\item 
bool \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a9a6fe7947a40e784ed47a05da0678825}{enableNX}
\item 
unsigned \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a9e6c5c16902269a9053480d064cacb9c}{inflight}
\item 
TlbEntry \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a67e11800589d9e3f891debb46889da99}{entry}
\item 
\hyperlink{classPacket}{PacketPtr} \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a80c062ee2cb2c5ef258a0bcf0d35ef19}{read}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classPacket}{PacketPtr} $>$ \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_ad878e24435696fc6f83c7b321d1cfb37}{writes}
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_ad64dd28e7be7f7f688e78a39d4c7d051}{timingFault}
\item 
\hyperlink{classBaseTLB_1_1Translation}{TLB::Translation} $\ast$ \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_af4dc79732f6962bb42c1d73da32ee926}{translation}
\item 
\hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{BaseTLB::Mode} \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_ae9b5adf8be89a72128708c7e621e7211}{mode}
\item 
bool \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a4f60754b74e2d1584c06199ae5b75f21}{functional}
\item 
bool \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a20f65ad56869382ed8681b9dd1aa85d6}{timing}
\item 
bool \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a69b34155de7bb405026219ea3725b695}{retrying}
\item 
bool \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a43c08d193d555a2b2a61c53d2a4e5a63}{started}
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8}{State} \{ \par
\hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a0e73e048b83849a411148a8dddc6dfcb}{Ready}, 
\hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a7ac9ab6c2e98f6df96b82b175d42747a}{Waiting}, 
\hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8ad66948e28eb00ddced813f3f0f6e5bc4}{LongPML4}, 
\hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a1b653b02c627354760be6c72a4e55d29}{LongPDP}, 
\par
\hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a829c2535d4b5c90636af37735c39052e}{LongPD}, 
\hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a58432ecaf212ab0040a78de1c8a4f841}{LongPTE}, 
\hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8ac7b0f8bb2fb252cf3ebaa9bc0b020157}{PAEPDP}, 
\hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a680c46f2b38a2799316fdb6fd399e9de}{PAEPD}, 
\par
\hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a65af6bc5b50578ce5e2e0ccfe7ff5ff6}{PAEPTE}, 
\hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a933f57294495f648d2d4d572f7123df7}{PSEPD}, 
\hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8aefbc069e0ac4cd293f3ba527bec2befe}{PD}, 
\hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a788b556d960eb5a1c7dc8cf2e058c010}{PTE}
 \}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a002ceab720d63ad3e2b3786c1d2285cc}{setupWalk} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vaddr)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a5c46b5cda98378cdb854f6810ee91f8a}{stepWalk} (\hyperlink{classPacket}{PacketPtr} \&write)
\item 
void \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_aa1322bdadbe5c9c04e2151a8317ab35d}{sendPackets} ()
\item 
void \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a040477c57c479fb61edb65bd58ca19d9}{endWalk} ()
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_aea73109ca1147453cb802d6102c1074a}{pageFault} (bool \hyperlink{namespaceX86ISA_a2c4bc7438a48bd4bbdd7ed9b629a6ec6}{present})
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classX86ISA_1_1Walker_1_1WalkerState_a561951adc2bae72717df4b975c66f02f}{Walker}
\end{DoxyCompactItemize}


\subsection{列挙型}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!State@{State}}
\index{State@{State}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{State}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf State}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Ready@{Ready}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!Ready@{Ready}}\item[{\em 
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a0e73e048b83849a411148a8dddc6dfcb}{
Ready}
\label{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a0e73e048b83849a411148a8dddc6dfcb}
}]\index{Waiting@{Waiting}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!Waiting@{Waiting}}\item[{\em 
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a7ac9ab6c2e98f6df96b82b175d42747a}{
Waiting}
\label{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a7ac9ab6c2e98f6df96b82b175d42747a}
}]\index{LongPML4@{LongPML4}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!LongPML4@{LongPML4}}\item[{\em 
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8ad66948e28eb00ddced813f3f0f6e5bc4}{
LongPML4}
\label{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8ad66948e28eb00ddced813f3f0f6e5bc4}
}]\index{LongPDP@{LongPDP}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!LongPDP@{LongPDP}}\item[{\em 
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a1b653b02c627354760be6c72a4e55d29}{
LongPDP}
\label{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a1b653b02c627354760be6c72a4e55d29}
}]\index{LongPD@{LongPD}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!LongPD@{LongPD}}\item[{\em 
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a829c2535d4b5c90636af37735c39052e}{
LongPD}
\label{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a829c2535d4b5c90636af37735c39052e}
}]\index{LongPTE@{LongPTE}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!LongPTE@{LongPTE}}\item[{\em 
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a58432ecaf212ab0040a78de1c8a4f841}{
LongPTE}
\label{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a58432ecaf212ab0040a78de1c8a4f841}
}]\index{PAEPDP@{PAEPDP}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!PAEPDP@{PAEPDP}}\item[{\em 
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8ac7b0f8bb2fb252cf3ebaa9bc0b020157}{
PAEPDP}
\label{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8ac7b0f8bb2fb252cf3ebaa9bc0b020157}
}]\index{PAEPD@{PAEPD}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!PAEPD@{PAEPD}}\item[{\em 
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a680c46f2b38a2799316fdb6fd399e9de}{
PAEPD}
\label{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a680c46f2b38a2799316fdb6fd399e9de}
}]\index{PAEPTE@{PAEPTE}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!PAEPTE@{PAEPTE}}\item[{\em 
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a65af6bc5b50578ce5e2e0ccfe7ff5ff6}{
PAEPTE}
\label{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a65af6bc5b50578ce5e2e0ccfe7ff5ff6}
}]\index{PSEPD@{PSEPD}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!PSEPD@{PSEPD}}\item[{\em 
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a933f57294495f648d2d4d572f7123df7}{
PSEPD}
\label{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a933f57294495f648d2d4d572f7123df7}
}]\index{PD@{PD}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!PD@{PD}}\item[{\em 
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8aefbc069e0ac4cd293f3ba527bec2befe}{
PD}
\label{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8aefbc069e0ac4cd293f3ba527bec2befe}
}]\index{PTE@{PTE}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!PTE@{PTE}}\item[{\em 
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a788b556d960eb5a1c7dc8cf2e058c010}{
PTE}
\label{classX86ISA_1_1Walker_1_1WalkerState_a5d74787dedbc4e11c1ab15bf487e61f8a788b556d960eb5a1c7dc8cf2e058c010}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
92                        {
93                 Ready,
94                 Waiting,
95                 // Long mode
96                 LongPML4, LongPDP, LongPD, LongPTE,
97                 // PAE legacy mode
98                 PAEPDP, PAEPD, PAEPTE,
99                 // Non PAE legacy mode with and without PSE
100                 PSEPD, PD, PTE
101             };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_ac84e175444e79eb369ed3d6debdb601f}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!WalkerState@{WalkerState}}
\index{WalkerState@{WalkerState}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{WalkerState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf WalkerState} ({\bf Walker} $\ast$ {\em \_\-walker}, \/  {\bf BaseTLB::Translation} $\ast$ {\em \_\-translation}, \/  {\bf RequestPtr} {\em \_\-req}, \/  bool {\em \_\-isFunctional} = {\ttfamily false})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_ac84e175444e79eb369ed3d6debdb601f}



\begin{DoxyCode}
124                                                                  :
125                         walker(_walker), req(_req), state(Ready),
126                         nextState(Ready), inflight(0),
127                         translation(_translation),
128                         functional(_isFunctional), timing(false),
129                         retrying(false), started(false)
130             {
131             }
            void initState(ThreadContext * _tc, BaseTLB::Mode _mode,
\end{DoxyCode}


\subsection{関数}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a040477c57c479fb61edb65bd58ca19d9}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!endWalk@{endWalk}}
\index{endWalk@{endWalk}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{endWalk}]{\setlength{\rightskip}{0pt plus 5cm}void endWalk ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a040477c57c479fb61edb65bd58ca19d9}



\begin{DoxyCode}
550 {
551     nextState = Ready;
552     delete read->req;
553     delete read;
554     read = NULL;
555 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a92aeb88528be9893c2e8fe61629fc942}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!initState@{initState}}
\index{initState@{initState}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{initState}]{\setlength{\rightskip}{0pt plus 5cm}void initState ({\bf ThreadContext} $\ast$ {\em \_\-tc}, \/  {\bf BaseTLB::Mode} {\em \_\-mode}, \/  bool {\em \_\-isTiming} = {\ttfamily false})}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a92aeb88528be9893c2e8fe61629fc942}



\begin{DoxyCode}
194 {
195     assert(state == Ready);
196     started = false;
197     tc = _tc;
198     mode = _mode;
199     timing = _isTiming;
200 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a46197e29b4fb481e9f1a932fbbf44586}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!isRetrying@{isRetrying}}
\index{isRetrying@{isRetrying}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{isRetrying}]{\setlength{\rightskip}{0pt plus 5cm}bool isRetrying ()}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a46197e29b4fb481e9f1a932fbbf44586}



\begin{DoxyCode}
693 {
694     return retrying;
695 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a9dc00933e3ae5f8801363f2288084154}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!isTiming@{isTiming}}
\index{isTiming@{isTiming}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{isTiming}]{\setlength{\rightskip}{0pt plus 5cm}bool isTiming ()}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a9dc00933e3ae5f8801363f2288084154}



\begin{DoxyCode}
699 {
700     return timing;
701 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!name@{name}}
\index{name@{name}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a37627d5d5bba7f4a8690c71c2ab3cb07}



\begin{DoxyCode}
141 {return walker->name();}
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_aea73109ca1147453cb802d6102c1074a}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!pageFault@{pageFault}}
\index{pageFault@{pageFault}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{pageFault}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} pageFault (bool {\em present})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_aea73109ca1147453cb802d6102c1074a}



\begin{DoxyCode}
718 {
719     DPRINTF(PageTableWalker, "Raising page fault.\n");
720     HandyM5Reg m5reg = tc->readMiscRegNoEffect(MISCREG_M5_REG);
721     if (mode == BaseTLB::Execute && !enableNX)
722         mode = BaseTLB::Read;
723     return new PageFault(entry.vaddr, present, mode, m5reg.cpl == 3, false);
724 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_ac6c4ea75aa4bd19a760aca940fad8876}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!recvPacket@{recvPacket}}
\index{recvPacket@{recvPacket}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{recvPacket}]{\setlength{\rightskip}{0pt plus 5cm}bool recvPacket ({\bf PacketPtr} {\em pkt})}}
\label{classX86ISA_1_1Walker_1_1WalkerState_ac6c4ea75aa4bd19a760aca940fad8876}



\begin{DoxyCode}
607 {
608     assert(pkt->isResponse());
609     assert(inflight);
610     assert(state == Waiting);
611     assert(!read);
612     inflight--;
613     if (pkt->isRead()) {
614         // @todo someone should pay for this
615         pkt->busFirstWordDelay = pkt->busLastWordDelay = 0;
616 
617         state = nextState;
618         nextState = Ready;
619         PacketPtr write = NULL;
620         read = pkt;
621         timingFault = stepWalk(write);
622         state = Waiting;
623         assert(timingFault == NoFault || read == NULL);
624         if (write) {
625             writes.push_back(write);
626         }
627         sendPackets();
628     } else {
629         sendPackets();
630     }
631     if (inflight == 0 && read == NULL && writes.size() == 0) {
632         state = Ready;
633         nextState = Waiting;
634         if (timingFault == NoFault) {
635             /*
636              * Finish the translation. Now that we now the right entry is
637              * in the TLB, this should work with no memory accesses.
638              * There could be new faults unrelated to the table walk like
639              * permissions violations, so we'll need the return value as
640              * well.
641              */
642             bool delayedResponse;
643             Fault fault = walker->tlb->translate(req, tc, NULL, mode,
644                                                  delayedResponse, true);
645             assert(!delayedResponse);
646             // Let the CPU continue.
647             translation->finish(fault, req, tc, mode);
648         } else {
649             // There was a fault during the walk. Let the CPU know.
650             translation->finish(timingFault, req, tc, mode);
651         }
652         return true;
653     }
654 
655     return false;
656 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a549fc33ae3e5c345795b8384a91fb544}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!retry@{retry}}
\index{retry@{retry}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{retry}]{\setlength{\rightskip}{0pt plus 5cm}void retry ()}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a549fc33ae3e5c345795b8384a91fb544}



\begin{DoxyCode}
711 {
712     retrying = false;
713     sendPackets();
714 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_aa1322bdadbe5c9c04e2151a8317ab35d}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!sendPackets@{sendPackets}}
\index{sendPackets@{sendPackets}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{sendPackets}]{\setlength{\rightskip}{0pt plus 5cm}void sendPackets ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_aa1322bdadbe5c9c04e2151a8317ab35d}



\begin{DoxyCode}
660 {
661     //If we're already waiting for the port to become available, just return.
662     if (retrying)
663         return;
664 
665     //Reads always have priority
666     if (read) {
667         PacketPtr pkt = read;
668         read = NULL;
669         inflight++;
670         if (!walker->sendTiming(this, pkt)) {
671             retrying = true;
672             read = pkt;
673             inflight--;
674             return;
675         }
676     }
677     //Send off as many of the writes as we can.
678     while (writes.size()) {
679         PacketPtr write = writes.back();
680         writes.pop_back();
681         inflight++;
682         if (!walker->sendTiming(this, write)) {
683             retrying = true;
684             writes.push_back(write);
685             inflight--;
686             return;
687         }
688     }
689 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a002ceab720d63ad3e2b3786c1d2285cc}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!setupWalk@{setupWalk}}
\index{setupWalk@{setupWalk}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{setupWalk}]{\setlength{\rightskip}{0pt plus 5cm}void setupWalk ({\bf Addr} {\em vaddr})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a002ceab720d63ad3e2b3786c1d2285cc}



\begin{DoxyCode}
559 {
560     VAddr addr = vaddr;
561     CR3 cr3 = tc->readMiscRegNoEffect(MISCREG_CR3);
562     // Check if we're in long mode or not
563     Efer efer = tc->readMiscRegNoEffect(MISCREG_EFER);
564     dataSize = 8;
565     Addr topAddr;
566     if (efer.lma) {
567         // Do long mode.
568         state = LongPML4;
569         topAddr = (cr3.longPdtb << 12) + addr.longl4 * dataSize;
570         enableNX = efer.nxe;
571     } else {
572         // We're in some flavor of legacy mode.
573         CR4 cr4 = tc->readMiscRegNoEffect(MISCREG_CR4);
574         if (cr4.pae) {
575             // Do legacy PAE.
576             state = PAEPDP;
577             topAddr = (cr3.paePdtb << 5) + addr.pael3 * dataSize;
578             enableNX = efer.nxe;
579         } else {
580             dataSize = 4;
581             topAddr = (cr3.pdtb << 12) + addr.norml2 * dataSize;
582             if (cr4.pse) {
583                 // Do legacy PSE.
584                 state = PSEPD;
585             } else {
586                 // Do legacy non PSE.
587                 state = PD;
588             }
589             enableNX = false;
590         }
591     }
592 
593     nextState = Ready;
594     entry.vaddr = vaddr;
595 
596     Request::Flags flags = Request::PHYSICAL;
597     if (cr3.pcd)
598         flags.set(Request::UNCACHEABLE);
599     RequestPtr request = new Request(topAddr, dataSize, flags,
600                                      walker->masterId);
601     read = new Packet(request, MemCmd::ReadReq);
602     read->allocate();
603 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_ac1af47bc545fc273626009cb651d3b39}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!startFunctional@{startFunctional}}
\index{startFunctional@{startFunctional}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{startFunctional}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} startFunctional ({\bf Addr} \& {\em addr}, \/  unsigned \& {\em logBytes})}}
\label{classX86ISA_1_1Walker_1_1WalkerState_ac1af47bc545fc273626009cb651d3b39}



\begin{DoxyCode}
263 {
264     Fault fault = NoFault;
265     assert(!started);
266     started = true;
267     setupWalk(addr);
268 
269     do {
270         walker->port.sendFunctional(read);
271         // On a functional access (page table lookup), writes should
272         // not happen so this pointer is ignored after stepWalk
273         PacketPtr write = NULL;
274         fault = stepWalk(write);
275         assert(fault == NoFault || read == NULL);
276         state = nextState;
277         nextState = Ready;
278     } while(read);
279     logBytes = entry.logBytes;
280     addr = entry.paddr;
281 
282     return fault;
283 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_abe41f563c4251c8a075c343d770369ac}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!startWalk@{startWalk}}
\index{startWalk@{startWalk}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{startWalk}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} startWalk ()}}
\label{classX86ISA_1_1Walker_1_1WalkerState_abe41f563c4251c8a075c343d770369ac}



\begin{DoxyCode}
234 {
235     Fault fault = NoFault;
236     assert(!started);
237     started = true;
238     setupWalk(req->getVaddr());
239     if (timing) {
240         nextState = state;
241         state = Waiting;
242         timingFault = NoFault;
243         sendPackets();
244     } else {
245         do {
246             walker->port.sendAtomic(read);
247             PacketPtr write = NULL;
248             fault = stepWalk(write);
249             assert(fault == NoFault || read == NULL);
250             state = nextState;
251             nextState = Ready;
252             if (write)
253                 walker->port.sendAtomic(write);
254         } while(read);
255         state = Ready;
256         nextState = Waiting;
257     }
258     return fault;
259 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a5c46b5cda98378cdb854f6810ee91f8a}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!stepWalk@{stepWalk}}
\index{stepWalk@{stepWalk}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{stepWalk}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} stepWalk ({\bf PacketPtr} \& {\em write})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a5c46b5cda98378cdb854f6810ee91f8a}



\begin{DoxyCode}
287 {
288     assert(state != Ready && state != Waiting);
289     Fault fault = NoFault;
290     write = NULL;
291     PageTableEntry pte;
292     if (dataSize == 8)
293         pte = read->get<uint64_t>();
294     else
295         pte = read->get<uint32_t>();
296     VAddr vaddr = entry.vaddr;
297     bool uncacheable = pte.pcd;
298     Addr nextRead = 0;
299     bool doWrite = false;
300     bool doTLBInsert = false;
301     bool doEndWalk = false;
302     bool badNX = pte.nx && mode == BaseTLB::Execute && enableNX;
303     switch(state) {
304       case LongPML4:
305         DPRINTF(PageTableWalker,
306                 "Got long mode PML4 entry %#016x.\n", (uint64_t)pte);
307         nextRead = ((uint64_t)pte & (mask(40) << 12)) + vaddr.longl3 * dataSize;
308         doWrite = !pte.a;
309         pte.a = 1;
310         entry.writable = pte.w;
311         entry.user = pte.u;
312         if (badNX || !pte.p) {
313             doEndWalk = true;
314             fault = pageFault(pte.p);
315             break;
316         }
317         entry.noExec = pte.nx;
318         nextState = LongPDP;
319         break;
320       case LongPDP:
321         DPRINTF(PageTableWalker,
322                 "Got long mode PDP entry %#016x.\n", (uint64_t)pte);
323         nextRead = ((uint64_t)pte & (mask(40) << 12)) + vaddr.longl2 * dataSize;
324         doWrite = !pte.a;
325         pte.a = 1;
326         entry.writable = entry.writable && pte.w;
327         entry.user = entry.user && pte.u;
328         if (badNX || !pte.p) {
329             doEndWalk = true;
330             fault = pageFault(pte.p);
331             break;
332         }
333         nextState = LongPD;
334         break;
335       case LongPD:
336         DPRINTF(PageTableWalker,
337                 "Got long mode PD entry %#016x.\n", (uint64_t)pte);
338         doWrite = !pte.a;
339         pte.a = 1;
340         entry.writable = entry.writable && pte.w;
341         entry.user = entry.user && pte.u;
342         if (badNX || !pte.p) {
343             doEndWalk = true;
344             fault = pageFault(pte.p);
345             break;
346         }
347         if (!pte.ps) {
348             // 4 KB page
349             entry.logBytes = 12;
350             nextRead =
351                 ((uint64_t)pte & (mask(40) << 12)) + vaddr.longl1 * dataSize;
352             nextState = LongPTE;
353             break;
354         } else {
355             // 2 MB page
356             entry.logBytes = 21;
357             entry.paddr = (uint64_t)pte & (mask(31) << 21);
358             entry.uncacheable = uncacheable;
359             entry.global = pte.g;
360             entry.patBit = bits(pte, 12);
361             entry.vaddr = entry.vaddr & ~((2 * (1 << 20)) - 1);
362             doTLBInsert = true;
363             doEndWalk = true;
364             break;
365         }
366       case LongPTE:
367         DPRINTF(PageTableWalker,
368                 "Got long mode PTE entry %#016x.\n", (uint64_t)pte);
369         doWrite = !pte.a;
370         pte.a = 1;
371         entry.writable = entry.writable && pte.w;
372         entry.user = entry.user && pte.u;
373         if (badNX || !pte.p) {
374             doEndWalk = true;
375             fault = pageFault(pte.p);
376             break;
377         }
378         entry.paddr = (uint64_t)pte & (mask(40) << 12);
379         entry.uncacheable = uncacheable;
380         entry.global = pte.g;
381         entry.patBit = bits(pte, 12);
382         entry.vaddr = entry.vaddr & ~((4 * (1 << 10)) - 1);
383         doTLBInsert = true;
384         doEndWalk = true;
385         break;
386       case PAEPDP:
387         DPRINTF(PageTableWalker,
388                 "Got legacy mode PAE PDP entry %#08x.\n", (uint32_t)pte);
389         nextRead = ((uint64_t)pte & (mask(40) << 12)) + vaddr.pael2 * dataSize;
390         if (!pte.p) {
391             doEndWalk = true;
392             fault = pageFault(pte.p);
393             break;
394         }
395         nextState = PAEPD;
396         break;
397       case PAEPD:
398         DPRINTF(PageTableWalker,
399                 "Got legacy mode PAE PD entry %#08x.\n", (uint32_t)pte);
400         doWrite = !pte.a;
401         pte.a = 1;
402         entry.writable = pte.w;
403         entry.user = pte.u;
404         if (badNX || !pte.p) {
405             doEndWalk = true;
406             fault = pageFault(pte.p);
407             break;
408         }
409         if (!pte.ps) {
410             // 4 KB page
411             entry.logBytes = 12;
412             nextRead = ((uint64_t)pte & (mask(40) << 12)) + vaddr.pael1 * 
      dataSize;
413             nextState = PAEPTE;
414             break;
415         } else {
416             // 2 MB page
417             entry.logBytes = 21;
418             entry.paddr = (uint64_t)pte & (mask(31) << 21);
419             entry.uncacheable = uncacheable;
420             entry.global = pte.g;
421             entry.patBit = bits(pte, 12);
422             entry.vaddr = entry.vaddr & ~((2 * (1 << 20)) - 1);
423             doTLBInsert = true;
424             doEndWalk = true;
425             break;
426         }
427       case PAEPTE:
428         DPRINTF(PageTableWalker,
429                 "Got legacy mode PAE PTE entry %#08x.\n", (uint32_t)pte);
430         doWrite = !pte.a;
431         pte.a = 1;
432         entry.writable = entry.writable && pte.w;
433         entry.user = entry.user && pte.u;
434         if (badNX || !pte.p) {
435             doEndWalk = true;
436             fault = pageFault(pte.p);
437             break;
438         }
439         entry.paddr = (uint64_t)pte & (mask(40) << 12);
440         entry.uncacheable = uncacheable;
441         entry.global = pte.g;
442         entry.patBit = bits(pte, 7);
443         entry.vaddr = entry.vaddr & ~((4 * (1 << 10)) - 1);
444         doTLBInsert = true;
445         doEndWalk = true;
446         break;
447       case PSEPD:
448         DPRINTF(PageTableWalker,
449                 "Got legacy mode PSE PD entry %#08x.\n", (uint32_t)pte);
450         doWrite = !pte.a;
451         pte.a = 1;
452         entry.writable = pte.w;
453         entry.user = pte.u;
454         if (!pte.p) {
455             doEndWalk = true;
456             fault = pageFault(pte.p);
457             break;
458         }
459         if (!pte.ps) {
460             // 4 KB page
461             entry.logBytes = 12;
462             nextRead =
463                 ((uint64_t)pte & (mask(20) << 12)) + vaddr.norml2 * dataSize;
464             nextState = PTE;
465             break;
466         } else {
467             // 4 MB page
468             entry.logBytes = 21;
469             entry.paddr = bits(pte, 20, 13) << 32 | bits(pte, 31, 22) << 22;
470             entry.uncacheable = uncacheable;
471             entry.global = pte.g;
472             entry.patBit = bits(pte, 12);
473             entry.vaddr = entry.vaddr & ~((4 * (1 << 20)) - 1);
474             doTLBInsert = true;
475             doEndWalk = true;
476             break;
477         }
478       case PD:
479         DPRINTF(PageTableWalker,
480                 "Got legacy mode PD entry %#08x.\n", (uint32_t)pte);
481         doWrite = !pte.a;
482         pte.a = 1;
483         entry.writable = pte.w;
484         entry.user = pte.u;
485         if (!pte.p) {
486             doEndWalk = true;
487             fault = pageFault(pte.p);
488             break;
489         }
490         // 4 KB page
491         entry.logBytes = 12;
492         nextRead = ((uint64_t)pte & (mask(20) << 12)) + vaddr.norml2 * dataSize;
493         nextState = PTE;
494         break;
495       case PTE:
496         DPRINTF(PageTableWalker,
497                 "Got legacy mode PTE entry %#08x.\n", (uint32_t)pte);
498         doWrite = !pte.a;
499         pte.a = 1;
500         entry.writable = pte.w;
501         entry.user = pte.u;
502         if (!pte.p) {
503             doEndWalk = true;
504             fault = pageFault(pte.p);
505             break;
506         }
507         entry.paddr = (uint64_t)pte & (mask(20) << 12);
508         entry.uncacheable = uncacheable;
509         entry.global = pte.g;
510         entry.patBit = bits(pte, 7);
511         entry.vaddr = entry.vaddr & ~((4 * (1 << 10)) - 1);
512         doTLBInsert = true;
513         doEndWalk = true;
514         break;
515       default:
516         panic("Unknown page table walker state %d!\n");
517     }
518     if (doEndWalk) {
519         if (doTLBInsert)
520             if (!functional)
521                 walker->tlb->insert(entry.vaddr, entry);
522         endWalk();
523     } else {
524         PacketPtr oldRead = read;
525         //If we didn't return, we're setting up another read.
526         Request::Flags flags = oldRead->req->getFlags();
527         flags.set(Request::UNCACHEABLE, uncacheable);
528         RequestPtr request =
529             new Request(nextRead, oldRead->getSize(), flags, walker->masterId);
530         read = new Packet(request, MemCmd::ReadReq);
531         read->allocate();
532         // If we need to write, adjust the read packet to write the modified
533         // value back to memory.
534         if (doWrite) {
535             write = oldRead;
536             write->set<uint64_t>(pte);
537             write->cmd = MemCmd::WriteReq;
538             write->clearDest();
539         } else {
540             write = NULL;
541             delete oldRead->req;
542             delete oldRead;
543         }
544     }
545     return fault;
546 }
\end{DoxyCode}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a0335da57d5042e3a3dcfb9635cd3d1ca}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!wasStarted@{wasStarted}}
\index{wasStarted@{wasStarted}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{wasStarted}]{\setlength{\rightskip}{0pt plus 5cm}bool wasStarted ()}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a0335da57d5042e3a3dcfb9635cd3d1ca}



\begin{DoxyCode}
705 {
706     return started;
707 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a561951adc2bae72717df4b975c66f02f}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!Walker@{Walker}}
\index{Walker@{Walker}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{Walker}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf Walker}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a561951adc2bae72717df4b975c66f02f}


\subsection{変数}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a8c8e474bb8d2c6f7162455416b488e50}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!dataSize@{dataSize}}
\index{dataSize@{dataSize}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{dataSize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf dataSize}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a8c8e474bb8d2c6f7162455416b488e50}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a9a6fe7947a40e784ed47a05da0678825}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!enableNX@{enableNX}}
\index{enableNX@{enableNX}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{enableNX}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf enableNX}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a9a6fe7947a40e784ed47a05da0678825}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a67e11800589d9e3f891debb46889da99}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!entry@{entry}}
\index{entry@{entry}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{entry}]{\setlength{\rightskip}{0pt plus 5cm}TlbEntry {\bf entry}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a67e11800589d9e3f891debb46889da99}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a4f60754b74e2d1584c06199ae5b75f21}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!functional@{functional}}
\index{functional@{functional}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{functional}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf functional}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a4f60754b74e2d1584c06199ae5b75f21}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a9e6c5c16902269a9053480d064cacb9c}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!inflight@{inflight}}
\index{inflight@{inflight}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{inflight}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf inflight}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a9e6c5c16902269a9053480d064cacb9c}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_ae9b5adf8be89a72128708c7e621e7211}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!mode@{mode}}
\index{mode@{mode}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{mode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseTLB::Mode} {\bf mode}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_ae9b5adf8be89a72128708c7e621e7211}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a02eca985bd74ea3c516fd47e6f1a7a0d}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!nextState@{nextState}}
\index{nextState@{nextState}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{nextState}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} {\bf nextState}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a02eca985bd74ea3c516fd47e6f1a7a0d}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a80c062ee2cb2c5ef258a0bcf0d35ef19}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!read@{read}}
\index{read@{read}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketPtr} {\bf read}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a80c062ee2cb2c5ef258a0bcf0d35ef19}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a956cd41d82347558b9c0a5b0474903f2}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!req@{req}}
\index{req@{req}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{req}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RequestPtr} {\bf req}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a956cd41d82347558b9c0a5b0474903f2}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a69b34155de7bb405026219ea3725b695}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!retrying@{retrying}}
\index{retrying@{retrying}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{retrying}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf retrying}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a69b34155de7bb405026219ea3725b695}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a43c08d193d555a2b2a61c53d2a4e5a63}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!started@{started}}
\index{started@{started}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{started}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf started}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a43c08d193d555a2b2a61c53d2a4e5a63}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a876b486d3a5241a126bd5751c5f70f79}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!state@{state}}
\index{state@{state}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{state}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} {\bf state}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a876b486d3a5241a126bd5751c5f70f79}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a4455a4759e69e5ebe68ae7298cbcc37d}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!tc@{tc}}
\index{tc@{tc}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{tc}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadContext}$\ast$ {\bf tc}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a4455a4759e69e5ebe68ae7298cbcc37d}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a20f65ad56869382ed8681b9dd1aa85d6}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!timing@{timing}}
\index{timing@{timing}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{timing}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf timing}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a20f65ad56869382ed8681b9dd1aa85d6}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_ad64dd28e7be7f7f688e78a39d4c7d051}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!timingFault@{timingFault}}
\index{timingFault@{timingFault}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{timingFault}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} {\bf timingFault}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_ad64dd28e7be7f7f688e78a39d4c7d051}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_af4dc79732f6962bb42c1d73da32ee926}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!translation@{translation}}
\index{translation@{translation}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{translation}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TLB::Translation}$\ast$ {\bf translation}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_af4dc79732f6962bb42c1d73da32ee926}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_a54537e5fcbe2d6f609ca4c90a48a06a8}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!walker@{walker}}
\index{walker@{walker}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{walker}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Walker}$\ast$ {\bf walker}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_a54537e5fcbe2d6f609ca4c90a48a06a8}
\hypertarget{classX86ISA_1_1Walker_1_1WalkerState_ad878e24435696fc6f83c7b321d1cfb37}{
\index{X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}!writes@{writes}}
\index{writes@{writes}!X86ISA::Walker::WalkerState@{X86ISA::Walker::WalkerState}}
\subsubsection[{writes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf PacketPtr}$>$ {\bf writes}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86ISA_1_1Walker_1_1WalkerState_ad878e24435696fc6f83c7b321d1cfb37}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/x86/\hyperlink{pagetable__walker_8hh}{pagetable\_\-walker.hh}\item 
arch/x86/\hyperlink{pagetable__walker_8cc}{pagetable\_\-walker.cc}\end{DoxyCompactItemize}
