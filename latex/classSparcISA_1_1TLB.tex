\hypertarget{classSparcISA_1_1TLB}{
\section{クラス TLB}
\label{classSparcISA_1_1TLB}\index{SparcISA::TLB@{SparcISA::TLB}}
}


{\ttfamily \#include $<$tlb.hh$>$}TLBに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4cm]{classSparcISA_1_1TLB}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef SparcTLBParams \hyperlink{classSparcISA_1_1TLB_a3073524452e67556982db4c27c5f18ea}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structSparcISA_1_1TlbEntry}{TlbEntry} $\ast$ \hyperlink{classSparcISA_1_1TLB_a74fbbb81cfaa89e81165a62736e4311a}{lookup} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} va, int partition\_\-id, bool real, int context\_\-id=0, bool update\_\-used=true)
\item 
void \hyperlink{classSparcISA_1_1TLB_aca1483a67aee5a91e442f7131d66bcbd}{flushAll} ()
\item 
\hyperlink{classSparcISA_1_1TLB_acb886bd3c59f00c21be9ceaaf25dab97}{TLB} (const \hyperlink{classSparcISA_1_1TLB_a3073524452e67556982db4c27c5f18ea}{Params} $\ast$p)
\item 
void \hyperlink{classSparcISA_1_1TLB_a15b6c15c1be2ca4de3e65772a02aa29f}{takeOverFrom} (\hyperlink{classBaseTLB}{BaseTLB} $\ast$otlb)
\item 
void \hyperlink{classSparcISA_1_1TLB_a2d698ff909513b48a1263f8a5440e067}{demapPage} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vaddr, uint64\_\-t asn)
\item 
void \hyperlink{classSparcISA_1_1TLB_a8cb66fc5f158a5d28cb9e5d73ecd26cc}{dumpAll} ()
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classSparcISA_1_1TLB_ad54e01e3c0a1613098a76b7f92e5be93}{translateAtomic} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} mode)
\item 
void \hyperlink{classSparcISA_1_1TLB_ae52f7e465748883695d2b4f432a13652}{translateTiming} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{classBaseTLB_1_1Translation}{Translation} $\ast$translation, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} mode)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classSparcISA_1_1TLB_a26658814c6c9034665aae19cf25545bb}{translateFunctional} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} mode)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classSparcISA_1_1TLB_ae199d95c42e036851a8a0543c6d6d2e3}{finalizePhysical} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{classBaseTLB_a46c8a310cf4c094f8c80e1cb8dc1f911}{Mode} mode) const 
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classSparcISA_1_1TLB_ac90a1eb3091d70b4d1465154d799db46}{doMmuRegRead} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{classPacket}{Packet} $\ast$pkt)
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classSparcISA_1_1TLB_acdfde16dc50b29fe74f4b7c3f9711d43}{doMmuRegWrite} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{classPacket}{Packet} $\ast$pkt)
\item 
void \hyperlink{classSparcISA_1_1TLB_ab52a39898286d036febd5dcb6d0b376a}{GetTsbPtr} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, int ctx, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} $\ast$ptrs)
\item 
virtual void \hyperlink{classSparcISA_1_1TLB_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classSparcISA_1_1TLB_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\item 
uint64\_\-t \hyperlink{classSparcISA_1_1TLB_a62b717ca770fe6713cdde68d76694f44}{TteRead} (int entry)
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822}{FaultTypes} \{ \par
\hyperlink{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822ad787a45173579300e6a023f2de7291af}{OtherFault} =  0, 
\hyperlink{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822afdc36f7178e8d04d90ec745400f5d5e7}{PrivViolation} =  0x1, 
\hyperlink{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822a24949c2da237f4437ec8254b313fa9e1}{SideEffect} =  0x2, 
\hyperlink{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822a385d55ed81ad94372aeb0ca764c50bb8}{AtomicToIo} =  0x4, 
\par
\hyperlink{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822a15e185ce6e96161d3b8cd69c4e404c14}{IllegalAsi} =  0x8, 
\hyperlink{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822a95f50e219a840e80a9a1915b7f8b959d}{LoadFromNfo} =  0x10, 
\hyperlink{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822a218b85059c614ecbbee4628b16ff49da}{VaOutOfRange} =  0x20, 
\hyperlink{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822a6b3372addb0e74f2071f8e2ae4402676}{VaOutOfRangeJmp} =  0x40
 \}
\item 
enum \hyperlink{classSparcISA_1_1TLB_a856bf0f48d7d9c89d1e4216a6f0394e5}{ContextType} \{ \hyperlink{classSparcISA_1_1TLB_a856bf0f48d7d9c89d1e4216a6f0394e5a35c33effed98e564ad1bd10ef61d302c}{Primary} =  0, 
\hyperlink{classSparcISA_1_1TLB_a856bf0f48d7d9c89d1e4216a6f0394e5acdd030c6485c7b0801d32116fd9d7103}{Secondary} =  1, 
\hyperlink{classSparcISA_1_1TLB_a856bf0f48d7d9c89d1e4216a6f0394e5af5d1689599ccf08b174b36cfd0c3b6c7}{Nucleus} =  2
 \}
\item 
enum \hyperlink{classSparcISA_1_1TLB_a639a136c8fa30e45275bd7354e95eadd}{TsbPageSize} \{ \hyperlink{classSparcISA_1_1TLB_a639a136c8fa30e45275bd7354e95eadda3a7edc18be042f9f093c3c4fd03b6048}{Ps0}, 
\hyperlink{classSparcISA_1_1TLB_a639a136c8fa30e45275bd7354e95eadda0955a6897849c661b0454ad02ad7f033}{Ps1}
 \}
\item 
typedef \hyperlink{classSparcISA_1_1TlbMap_ae61c5513b9ac04615ba7927f47c3ec69}{TlbMap::iterator} \hyperlink{classSparcISA_1_1TLB_a52ffc8e6c7bc8d7037f59391c2a93750}{MapIter}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classSparcISA_1_1TLB_a2b2db94fc3a8f3652866d0dc2aabcf87}{insert} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} vpn, int partition\_\-id, int context\_\-id, bool real, const \hyperlink{classSparcISA_1_1PageTableEntry}{PageTableEntry} \&PTE, int entry=-\/1)
\item 
uint64\_\-t \hyperlink{classSparcISA_1_1TLB_aaf85d399be0a94d95fa3282faff835ea}{TagRead} (int entry)
\item 
void \hyperlink{classSparcISA_1_1TLB_a787d07e454d0dddde90f226346065ade}{demapAll} (int partition\_\-id)
\item 
void \hyperlink{classSparcISA_1_1TLB_af7e91d9c8e43607b3064697810576e28}{demapContext} (int partition\_\-id, int context\_\-id)
\item 
void \hyperlink{classSparcISA_1_1TLB_a81a25ef373ef91ac81bb1717e4c9dcb0}{demapPage} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} va, int partition\_\-id, bool real, int context\_\-id)
\item 
bool \hyperlink{classSparcISA_1_1TLB_aa5cff14a14bcb47f10bb095035bd6290}{validVirtualAddress} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} va, bool \hyperlink{namespaceSparcISA_a221d874609a3a07e22447f60e33cffdb}{am})
\item 
void \hyperlink{classSparcISA_1_1TLB_afd0c300a55c5f8ae2a678bcac2179afb}{writeSfsr} (bool write, \hyperlink{classSparcISA_1_1TLB_a856bf0f48d7d9c89d1e4216a6f0394e5}{ContextType} ct, bool se, \hyperlink{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822}{FaultTypes} ft, int asi)
\item 
void \hyperlink{classSparcISA_1_1TLB_aa4eb1561faa47c66c28555cbf26f4d8f}{clearUsedBits} ()
\item 
void \hyperlink{classSparcISA_1_1TLB_a7f076e15ef97f1dd3f5e128b48cb4974}{writeTagAccess} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} va, int context)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classSparcISA_1_1TLB_a072afd8ed455dade4c25a85510e5a4da}{translateInst} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classSparcISA_1_1TLB_ad54aef66412f77e2a15a621a126dfb52}{translateData} (\hyperlink{classRequest}{RequestPtr} req, \hyperlink{classThreadContext}{ThreadContext} $\ast$tc, bool write)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
uint64\_\-t \hyperlink{classSparcISA_1_1TLB_a81cff85924ab4191c84c9818d90eb0a2}{sfar}
\item 
uint64\_\-t \hyperlink{classSparcISA_1_1TLB_ac1b9fd2f6c65e41f4f5b85b1b50d3a4e}{c0\_\-tsb\_\-ps0}
\item 
uint64\_\-t \hyperlink{classSparcISA_1_1TLB_a1ab61f1741b5a3c2f81fe87fe3908e7e}{c0\_\-tsb\_\-ps1}
\item 
uint64\_\-t \hyperlink{classSparcISA_1_1TLB_a9395cf2ea615ba767ab8a677ee13d29c}{c0\_\-config}
\item 
uint64\_\-t \hyperlink{classSparcISA_1_1TLB_a3a0b3ccfe08de626e122e8db329e6cde}{cx\_\-tsb\_\-ps0}
\item 
uint64\_\-t \hyperlink{classSparcISA_1_1TLB_a1551a0ec5dad394042a5f1384b582ff3}{cx\_\-tsb\_\-ps1}
\item 
uint64\_\-t \hyperlink{classSparcISA_1_1TLB_a7388d84b8f9e8e4f6c8b3b8723d12b4a}{cx\_\-config}
\item 
uint64\_\-t \hyperlink{classSparcISA_1_1TLB_aa93fbd043dbccd30bf6f78f83bb088eb}{sfsr}
\item 
uint64\_\-t \hyperlink{classSparcISA_1_1TLB_a5d2c5251a072e8aef04cf78fdd6432d7}{tag\_\-access}
\item 
\hyperlink{classSparcISA_1_1TlbMap}{TlbMap} \hyperlink{classSparcISA_1_1TLB_ac52ea914d25a72d4c33298b8d64603c1}{lookupTable}
\item 
\hyperlink{structSparcISA_1_1TlbEntry}{TlbEntry} $\ast$ \hyperlink{classSparcISA_1_1TLB_a4651b9a4f432960d77d8e3d30175aab3}{tlb}
\item 
int \hyperlink{classSparcISA_1_1TLB_a439227feff9d7f55384e8780cfc2eb82}{size}
\item 
int \hyperlink{classSparcISA_1_1TLB_ad85f3aef77516b13c75af59a1887f8b7}{usedEntries}
\item 
int \hyperlink{classSparcISA_1_1TLB_a943cc0b274cf0720dad94d3469de39c3}{lastReplaced}
\item 
uint64\_\-t \hyperlink{classSparcISA_1_1TLB_a426d36e3a37393acd76bb3f1b14c2be9}{cacheState}
\item 
bool \hyperlink{classSparcISA_1_1TLB_a7d50962c0e8dea3232b1929d48065a3d}{cacheValid}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{structSparcISA_1_1TlbEntry}{TlbEntry} $\ast$ $>$ \hyperlink{classSparcISA_1_1TLB_aa3dc4ef7249a728d9d8d717427985532}{freeList}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classSparcISA_1_1TLB_a3c55ffc205560c3c945248eda4e0a62d}{writeSfsr} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} a, bool write, \hyperlink{classSparcISA_1_1TLB_a856bf0f48d7d9c89d1e4216a6f0394e5}{ContextType} ct, bool se, \hyperlink{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822}{FaultTypes} ft, int asi)
\item 
uint64\_\-t \hyperlink{classSparcISA_1_1TLB_a69c520e9f2bec8ddb4eb5121cf10a94c}{MakeTsbPtr} (\hyperlink{classSparcISA_1_1TLB_a639a136c8fa30e45275bd7354e95eadd}{TsbPageSize} ps, uint64\_\-t \hyperlink{classSparcISA_1_1TLB_a5d2c5251a072e8aef04cf78fdd6432d7}{tag\_\-access}, uint64\_\-t c0\_\-tsb, uint64\_\-t \hyperlink{classSparcISA_1_1TLB_a9395cf2ea615ba767ab8a677ee13d29c}{c0\_\-config}, uint64\_\-t cX\_\-tsb, uint64\_\-t cX\_\-config)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structSparcISA_1_1TlbEntry}{TlbEntry} $\ast$ \hyperlink{classSparcISA_1_1TLB_a5c9e9ce37f7a50fb908752ece801110f}{cacheEntry} \mbox{[}2\mbox{]}
\item 
\hyperlink{namespaceSparcISA_a6dd43f1311515252b283f56d7095a1f3}{ASI} \hyperlink{classSparcISA_1_1TLB_ad1ec0943e2f511b3a252ca0b824eb3e6}{cacheAsi} \mbox{[}2\mbox{]}
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classSparcISA_1_1TLB_af8c3b0d2687d5c17d60fee3e4e77e20f}{FastInstructionAccessMMUMiss}
\item 
class \hyperlink{classSparcISA_1_1TLB_a3d497ded3c85659ec4b013e2cae38c71}{FastDataAccessMMUMiss}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classSparcISA_1_1TLB_a52ffc8e6c7bc8d7037f59391c2a93750}{
\index{SparcISA::TLB@{SparcISA::TLB}!MapIter@{MapIter}}
\index{MapIter@{MapIter}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{MapIter}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf TlbMap::iterator} {\bf MapIter}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a52ffc8e6c7bc8d7037f59391c2a93750}
\hypertarget{classSparcISA_1_1TLB_a3073524452e67556982db4c27c5f18ea}{
\index{SparcISA::TLB@{SparcISA::TLB}!Params@{Params}}
\index{Params@{Params}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef SparcTLBParams {\bf Params}}}
\label{classSparcISA_1_1TLB_a3073524452e67556982db4c27c5f18ea}


\hyperlink{classSimObject_a0f0761d2db586a23bb2a2880b8f387bb}{SimObject}を再定義しています。

\subsection{列挙型}
\hypertarget{classSparcISA_1_1TLB_a856bf0f48d7d9c89d1e4216a6f0394e5}{
\index{SparcISA::TLB@{SparcISA::TLB}!ContextType@{ContextType}}
\index{ContextType@{ContextType}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{ContextType}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ContextType}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a856bf0f48d7d9c89d1e4216a6f0394e5}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Primary@{Primary}!SparcISA::TLB@{SparcISA::TLB}}\index{SparcISA::TLB@{SparcISA::TLB}!Primary@{Primary}}\item[{\em 
\hypertarget{classSparcISA_1_1TLB_a856bf0f48d7d9c89d1e4216a6f0394e5a35c33effed98e564ad1bd10ef61d302c}{
Primary}
\label{classSparcISA_1_1TLB_a856bf0f48d7d9c89d1e4216a6f0394e5a35c33effed98e564ad1bd10ef61d302c}
}]\index{Secondary@{Secondary}!SparcISA::TLB@{SparcISA::TLB}}\index{SparcISA::TLB@{SparcISA::TLB}!Secondary@{Secondary}}\item[{\em 
\hypertarget{classSparcISA_1_1TLB_a856bf0f48d7d9c89d1e4216a6f0394e5acdd030c6485c7b0801d32116fd9d7103}{
Secondary}
\label{classSparcISA_1_1TLB_a856bf0f48d7d9c89d1e4216a6f0394e5acdd030c6485c7b0801d32116fd9d7103}
}]\index{Nucleus@{Nucleus}!SparcISA::TLB@{SparcISA::TLB}}\index{SparcISA::TLB@{SparcISA::TLB}!Nucleus@{Nucleus}}\item[{\em 
\hypertarget{classSparcISA_1_1TLB_a856bf0f48d7d9c89d1e4216a6f0394e5af5d1689599ccf08b174b36cfd0c3b6c7}{
Nucleus}
\label{classSparcISA_1_1TLB_a856bf0f48d7d9c89d1e4216a6f0394e5af5d1689599ccf08b174b36cfd0c3b6c7}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
93                      {
94         Primary = 0,
95         Secondary = 1,
96         Nucleus = 2
97     };
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822}{
\index{SparcISA::TLB@{SparcISA::TLB}!FaultTypes@{FaultTypes}}
\index{FaultTypes@{FaultTypes}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{FaultTypes}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf FaultTypes}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{OtherFault@{OtherFault}!SparcISA::TLB@{SparcISA::TLB}}\index{SparcISA::TLB@{SparcISA::TLB}!OtherFault@{OtherFault}}\item[{\em 
\hypertarget{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822ad787a45173579300e6a023f2de7291af}{
OtherFault}
\label{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822ad787a45173579300e6a023f2de7291af}
}]\index{PrivViolation@{PrivViolation}!SparcISA::TLB@{SparcISA::TLB}}\index{SparcISA::TLB@{SparcISA::TLB}!PrivViolation@{PrivViolation}}\item[{\em 
\hypertarget{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822afdc36f7178e8d04d90ec745400f5d5e7}{
PrivViolation}
\label{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822afdc36f7178e8d04d90ec745400f5d5e7}
}]\index{SideEffect@{SideEffect}!SparcISA::TLB@{SparcISA::TLB}}\index{SparcISA::TLB@{SparcISA::TLB}!SideEffect@{SideEffect}}\item[{\em 
\hypertarget{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822a24949c2da237f4437ec8254b313fa9e1}{
SideEffect}
\label{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822a24949c2da237f4437ec8254b313fa9e1}
}]\index{AtomicToIo@{AtomicToIo}!SparcISA::TLB@{SparcISA::TLB}}\index{SparcISA::TLB@{SparcISA::TLB}!AtomicToIo@{AtomicToIo}}\item[{\em 
\hypertarget{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822a385d55ed81ad94372aeb0ca764c50bb8}{
AtomicToIo}
\label{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822a385d55ed81ad94372aeb0ca764c50bb8}
}]\index{IllegalAsi@{IllegalAsi}!SparcISA::TLB@{SparcISA::TLB}}\index{SparcISA::TLB@{SparcISA::TLB}!IllegalAsi@{IllegalAsi}}\item[{\em 
\hypertarget{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822a15e185ce6e96161d3b8cd69c4e404c14}{
IllegalAsi}
\label{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822a15e185ce6e96161d3b8cd69c4e404c14}
}]\index{LoadFromNfo@{LoadFromNfo}!SparcISA::TLB@{SparcISA::TLB}}\index{SparcISA::TLB@{SparcISA::TLB}!LoadFromNfo@{LoadFromNfo}}\item[{\em 
\hypertarget{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822a95f50e219a840e80a9a1915b7f8b959d}{
LoadFromNfo}
\label{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822a95f50e219a840e80a9a1915b7f8b959d}
}]\index{VaOutOfRange@{VaOutOfRange}!SparcISA::TLB@{SparcISA::TLB}}\index{SparcISA::TLB@{SparcISA::TLB}!VaOutOfRange@{VaOutOfRange}}\item[{\em 
\hypertarget{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822a218b85059c614ecbbee4628b16ff49da}{
VaOutOfRange}
\label{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822a218b85059c614ecbbee4628b16ff49da}
}]\index{VaOutOfRangeJmp@{VaOutOfRangeJmp}!SparcISA::TLB@{SparcISA::TLB}}\index{SparcISA::TLB@{SparcISA::TLB}!VaOutOfRangeJmp@{VaOutOfRangeJmp}}\item[{\em 
\hypertarget{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822a6b3372addb0e74f2071f8e2ae4402676}{
VaOutOfRangeJmp}
\label{classSparcISA_1_1TLB_a8e661b580d73f1e008c8ea6fc5823822a6b3372addb0e74f2071f8e2ae4402676}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
82                     {
83         OtherFault = 0,
84         PrivViolation = 0x1,
85         SideEffect = 0x2,
86         AtomicToIo = 0x4,
87         IllegalAsi = 0x8,
88         LoadFromNfo = 0x10,
89         VaOutOfRange = 0x20,
90         VaOutOfRangeJmp = 0x40
91     };
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_a639a136c8fa30e45275bd7354e95eadd}{
\index{SparcISA::TLB@{SparcISA::TLB}!TsbPageSize@{TsbPageSize}}
\index{TsbPageSize@{TsbPageSize}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{TsbPageSize}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf TsbPageSize}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a639a136c8fa30e45275bd7354e95eadd}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Ps0@{Ps0}!SparcISA::TLB@{SparcISA::TLB}}\index{SparcISA::TLB@{SparcISA::TLB}!Ps0@{Ps0}}\item[{\em 
\hypertarget{classSparcISA_1_1TLB_a639a136c8fa30e45275bd7354e95eadda3a7edc18be042f9f093c3c4fd03b6048}{
Ps0}
\label{classSparcISA_1_1TLB_a639a136c8fa30e45275bd7354e95eadda3a7edc18be042f9f093c3c4fd03b6048}
}]\index{Ps1@{Ps1}!SparcISA::TLB@{SparcISA::TLB}}\index{SparcISA::TLB@{SparcISA::TLB}!Ps1@{Ps1}}\item[{\em 
\hypertarget{classSparcISA_1_1TLB_a639a136c8fa30e45275bd7354e95eadda0955a6897849c661b0454ad02ad7f033}{
Ps1}
\label{classSparcISA_1_1TLB_a639a136c8fa30e45275bd7354e95eadda0955a6897849c661b0454ad02ad7f033}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
99                      {
100         Ps0,
101         Ps1
102     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classSparcISA_1_1TLB_acb886bd3c59f00c21be9ceaaf25dab97}{
\index{SparcISA::TLB@{SparcISA::TLB}!TLB@{TLB}}
\index{TLB@{TLB}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{TLB}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TLB} (const {\bf Params} $\ast$ {\em p})}}
\label{classSparcISA_1_1TLB_acb886bd3c59f00c21be9ceaaf25dab97}



\begin{DoxyCode}
53     : BaseTLB(p), size(p->size), usedEntries(0), lastReplaced(0),
54       cacheState(0), cacheValid(false)
55 {
56     // To make this work you'll have to change the hypervisor and OS
57     if (size > 64)
58         fatal("SPARC T1 TLB registers don't support more than 64 TLB entries");
59 
60     tlb = new TlbEntry[size];
61     std::memset(tlb, 0, sizeof(TlbEntry) * size);
62 
63     for (int x = 0; x < size; x++)
64         freeList.push_back(&tlb[x]);
65 
66     c0_tsb_ps0 = 0;
67     c0_tsb_ps1 = 0;
68     c0_config = 0;
69     cx_tsb_ps0 = 0;
70     cx_tsb_ps1 = 0;
71     cx_config = 0;
72     sfsr = 0;
73     tag_access = 0;
74     sfar = 0;
75     cacheEntry[0] = NULL;
76     cacheEntry[1] = NULL;
77 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classSparcISA_1_1TLB_aa4eb1561faa47c66c28555cbf26f4d8f}{
\index{SparcISA::TLB@{SparcISA::TLB}!clearUsedBits@{clearUsedBits}}
\index{clearUsedBits@{clearUsedBits}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{clearUsedBits}]{\setlength{\rightskip}{0pt plus 5cm}void clearUsedBits ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_aa4eb1561faa47c66c28555cbf26f4d8f}



\begin{DoxyCode}
81 {
82     MapIter i;
83     for (i = lookupTable.begin(); i != lookupTable.end(); i++) {
84         TlbEntry *t = i->second;
85         if (!t->pte.locked()) {
86             t->used = false;
87             usedEntries--;
88         }
89     }
90 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_a787d07e454d0dddde90f226346065ade}{
\index{SparcISA::TLB@{SparcISA::TLB}!demapAll@{demapAll}}
\index{demapAll@{demapAll}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{demapAll}]{\setlength{\rightskip}{0pt plus 5cm}void demapAll (int {\em partition\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a787d07e454d0dddde90f226346065ade}
Remove all non-\/locked entries from the tlb that match partition id. 


\begin{DoxyCode}
308 {
309     DPRINTF(TLB, "TLB: Demapping All pid=%#d\n", partition_id);
310     cacheValid = false;
311     for (int x = 0; x < size; x++) {
312         if (tlb[x].valid && !tlb[x].pte.locked() &&
313                 tlb[x].range.partitionId == partition_id) {
314             freeList.push_front(&tlb[x]);
315             tlb[x].valid = false;
316             if (tlb[x].used) {
317                 tlb[x].used = false;
318                 usedEntries--;
319             }
320             lookupTable.erase(tlb[x].range);
321         }
322     }
323 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_af7e91d9c8e43607b3064697810576e28}{
\index{SparcISA::TLB@{SparcISA::TLB}!demapContext@{demapContext}}
\index{demapContext@{demapContext}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{demapContext}]{\setlength{\rightskip}{0pt plus 5cm}void demapContext (int {\em partition\_\-id}, \/  int {\em context\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_af7e91d9c8e43607b3064697810576e28}
Remove all entries that match a given context/partition id. 


\begin{DoxyCode}
286 {
287     DPRINTF(IPR, "TLB: Demapping Context pid=%#d cid=%d\n",
288             partition_id, context_id);
289     cacheValid = false;
290     for (int x = 0; x < size; x++) {
291         if (tlb[x].range.contextId == context_id &&
292             tlb[x].range.partitionId == partition_id) {
293             if (tlb[x].valid) {
294                 freeList.push_front(&tlb[x]);
295             }
296             tlb[x].valid = false;
297             if (tlb[x].used) {
298                 tlb[x].used = false;
299                 usedEntries--;
300             }
301             lookupTable.erase(tlb[x].range);
302         }
303     }
304 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_a2d698ff909513b48a1263f8a5440e067}{
\index{SparcISA::TLB@{SparcISA::TLB}!demapPage@{demapPage}}
\index{demapPage@{demapPage}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{demapPage}]{\setlength{\rightskip}{0pt plus 5cm}void demapPage ({\bf Addr} {\em vaddr}, \/  uint64\_\-t {\em asn})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classSparcISA_1_1TLB_a2d698ff909513b48a1263f8a5440e067}


\hyperlink{classBaseTLB_aff4b9d01b9a4712c699cfb2dd9b3b8cd}{BaseTLB}を実装しています。


\begin{DoxyCode}
161     {
162         panic("demapPage(Addr) is not implemented.\n");
163     }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_a81a25ef373ef91ac81bb1717e4c9dcb0}{
\index{SparcISA::TLB@{SparcISA::TLB}!demapPage@{demapPage}}
\index{demapPage@{demapPage}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{demapPage}]{\setlength{\rightskip}{0pt plus 5cm}void demapPage ({\bf Addr} {\em va}, \/  int {\em partition\_\-id}, \/  bool {\em real}, \/  int {\em context\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a81a25ef373ef91ac81bb1717e4c9dcb0}
Remve all entries that match a certain partition id, (contextid), and va). 


\begin{DoxyCode}
254 {
255     TlbRange tr;
256     MapIter i;
257 
258     DPRINTF(IPR, "TLB: Demapping Page va=%#x pid=%#d cid=%d r=%d\n",
259             va, partition_id, context_id, real);
260 
261     cacheValid = false;
262 
263     // Assemble full address structure
264     tr.va = va;
265     tr.size = 1;
266     tr.contextId = context_id;
267     tr.partitionId = partition_id;
268     tr.real = real;
269 
270     // Demap any entry that conflicts
271     i = lookupTable.find(tr);
272     if (i != lookupTable.end()) {
273         DPRINTF(IPR, "TLB: Demapped page\n");
274         i->second->valid = false;
275         if (i->second->used) {
276             i->second->used = false;
277             usedEntries--;
278         }
279         freeList.push_front(i->second);
280         lookupTable.erase(i);
281     }
282 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_ac90a1eb3091d70b4d1465154d799db46}{
\index{SparcISA::TLB@{SparcISA::TLB}!doMmuRegRead@{doMmuRegRead}}
\index{doMmuRegRead@{doMmuRegRead}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{doMmuRegRead}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} doMmuRegRead ({\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Packet} $\ast$ {\em pkt})}}
\label{classSparcISA_1_1TLB_ac90a1eb3091d70b4d1465154d799db46}



\begin{DoxyCode}
859 {
860     Addr va = pkt->getAddr();
861     ASI asi = (ASI)pkt->req->getArchFlags();
862     uint64_t temp;
863 
864     DPRINTF(IPR, "Memory Mapped IPR Read: asi=%#X a=%#x\n",
865          (uint32_t)pkt->req->getArchFlags(), pkt->getAddr());
866 
867     TLB *itb = tc->getITBPtr();
868 
869     switch (asi) {
870       case ASI_LSU_CONTROL_REG:
871         assert(va == 0);
872         pkt->set(tc->readMiscReg(MISCREG_MMU_LSU_CTRL));
873         break;
874       case ASI_MMU:
875         switch (va) {
876           case 0x8:
877             pkt->set(tc->readMiscReg(MISCREG_MMU_P_CONTEXT));
878             break;
879           case 0x10:
880             pkt->set(tc->readMiscReg(MISCREG_MMU_S_CONTEXT));
881             break;
882           default:
883             goto doMmuReadError;
884         }
885         break;
886       case ASI_QUEUE:
887         pkt->set(tc->readMiscReg(MISCREG_QUEUE_CPU_MONDO_HEAD +
888                     (va >> 4) - 0x3c));
889         break;
890       case ASI_DMMU_CTXT_ZERO_TSB_BASE_PS0:
891         assert(va == 0);
892         pkt->set(c0_tsb_ps0);
893         break;
894       case ASI_DMMU_CTXT_ZERO_TSB_BASE_PS1:
895         assert(va == 0);
896         pkt->set(c0_tsb_ps1);
897         break;
898       case ASI_DMMU_CTXT_ZERO_CONFIG:
899         assert(va == 0);
900         pkt->set(c0_config);
901         break;
902       case ASI_IMMU_CTXT_ZERO_TSB_BASE_PS0:
903         assert(va == 0);
904         pkt->set(itb->c0_tsb_ps0);
905         break;
906       case ASI_IMMU_CTXT_ZERO_TSB_BASE_PS1:
907         assert(va == 0);
908         pkt->set(itb->c0_tsb_ps1);
909         break;
910       case ASI_IMMU_CTXT_ZERO_CONFIG:
911         assert(va == 0);
912         pkt->set(itb->c0_config);
913         break;
914       case ASI_DMMU_CTXT_NONZERO_TSB_BASE_PS0:
915         assert(va == 0);
916         pkt->set(cx_tsb_ps0);
917         break;
918       case ASI_DMMU_CTXT_NONZERO_TSB_BASE_PS1:
919         assert(va == 0);
920         pkt->set(cx_tsb_ps1);
921         break;
922       case ASI_DMMU_CTXT_NONZERO_CONFIG:
923         assert(va == 0);
924         pkt->set(cx_config);
925         break;
926       case ASI_IMMU_CTXT_NONZERO_TSB_BASE_PS0:
927         assert(va == 0);
928         pkt->set(itb->cx_tsb_ps0);
929         break;
930       case ASI_IMMU_CTXT_NONZERO_TSB_BASE_PS1:
931         assert(va == 0);
932         pkt->set(itb->cx_tsb_ps1);
933         break;
934       case ASI_IMMU_CTXT_NONZERO_CONFIG:
935         assert(va == 0);
936         pkt->set(itb->cx_config);
937         break;
938       case ASI_SPARC_ERROR_STATUS_REG:
939         pkt->set((uint64_t)0);
940         break;
941       case ASI_HYP_SCRATCHPAD:
942       case ASI_SCRATCHPAD:
943         pkt->set(tc->readMiscReg(MISCREG_SCRATCHPAD_R0 + (va >> 3)));
944         break;
945       case ASI_IMMU:
946         switch (va) {
947           case 0x0:
948             temp = itb->tag_access;
949             pkt->set(bits(temp,63,22) | bits(temp,12,0) << 48);
950             break;
951           case 0x18:
952             pkt->set(itb->sfsr);
953             break;
954           case 0x30:
955             pkt->set(itb->tag_access);
956             break;
957           default:
958             goto doMmuReadError;
959         }
960         break;
961       case ASI_DMMU:
962         switch (va) {
963           case 0x0:
964             temp = tag_access;
965             pkt->set(bits(temp,63,22) | bits(temp,12,0) << 48);
966             break;
967           case 0x18:
968             pkt->set(sfsr);
969             break;
970           case 0x20:
971             pkt->set(sfar);
972             break;
973           case 0x30:
974             pkt->set(tag_access);
975             break;
976           case 0x80:
977             pkt->set(tc->readMiscReg(MISCREG_MMU_PART_ID));
978             break;
979           default:
980                 goto doMmuReadError;
981         }
982         break;
983       case ASI_DMMU_TSB_PS0_PTR_REG:
984         pkt->set(MakeTsbPtr(Ps0,
985             tag_access,
986             c0_tsb_ps0,
987             c0_config,
988             cx_tsb_ps0,
989             cx_config));
990         break;
991       case ASI_DMMU_TSB_PS1_PTR_REG:
992         pkt->set(MakeTsbPtr(Ps1,
993                 tag_access,
994                 c0_tsb_ps1,
995                 c0_config,
996                 cx_tsb_ps1,
997                 cx_config));
998         break;
999       case ASI_IMMU_TSB_PS0_PTR_REG:
1000           pkt->set(MakeTsbPtr(Ps0,
1001                 itb->tag_access,
1002                 itb->c0_tsb_ps0,
1003                 itb->c0_config,
1004                 itb->cx_tsb_ps0,
1005                 itb->cx_config));
1006         break;
1007       case ASI_IMMU_TSB_PS1_PTR_REG:
1008           pkt->set(MakeTsbPtr(Ps1,
1009                 itb->tag_access,
1010                 itb->c0_tsb_ps1,
1011                 itb->c0_config,
1012                 itb->cx_tsb_ps1,
1013                 itb->cx_config));
1014         break;
1015       case ASI_SWVR_INTR_RECEIVE:
1016         {
1017             SparcISA::Interrupts * interrupts =
1018                 dynamic_cast<SparcISA::Interrupts *>(
1019                         tc->getCpuPtr()->getInterruptController());
1020             pkt->set(interrupts->get_vec(IT_INT_VEC));
1021         }
1022         break;
1023       case ASI_SWVR_UDB_INTR_R:
1024         {
1025             SparcISA::Interrupts * interrupts =
1026                 dynamic_cast<SparcISA::Interrupts *>(
1027                         tc->getCpuPtr()->getInterruptController());
1028             temp = findMsbSet(interrupts->get_vec(IT_INT_VEC));
1029             tc->getCpuPtr()->clearInterrupt(IT_INT_VEC, temp);
1030             pkt->set(temp);
1031         }
1032         break;
1033       default:
1034 doMmuReadError:
1035         panic("need to impl DTB::doMmuRegRead() got asi=%#x, va=%#x\n",
1036             (uint32_t)asi, va);
1037     }
1038     pkt->makeAtomicResponse();
1039     return Cycles(1);
1040 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_acdfde16dc50b29fe74f4b7c3f9711d43}{
\index{SparcISA::TLB@{SparcISA::TLB}!doMmuRegWrite@{doMmuRegWrite}}
\index{doMmuRegWrite@{doMmuRegWrite}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{doMmuRegWrite}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} doMmuRegWrite ({\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Packet} $\ast$ {\em pkt})}}
\label{classSparcISA_1_1TLB_acdfde16dc50b29fe74f4b7c3f9711d43}



\begin{DoxyCode}
1044 {
1045     uint64_t data = pkt->get<uint64_t>();
1046     Addr va = pkt->getAddr();
1047     ASI asi = (ASI)pkt->req->getArchFlags();
1048 
1049     Addr ta_insert;
1050     Addr va_insert;
1051     Addr ct_insert;
1052     int part_insert;
1053     int entry_insert = -1;
1054     bool real_insert;
1055     bool ignore;
1056     int part_id;
1057     int ctx_id;
1058     PageTableEntry pte;
1059 
1060     DPRINTF(IPR, "Memory Mapped IPR Write: asi=%#X a=%#x d=%#X\n",
1061          (uint32_t)asi, va, data);
1062 
1063     TLB *itb = tc->getITBPtr();
1064 
1065     switch (asi) {
1066       case ASI_LSU_CONTROL_REG:
1067         assert(va == 0);
1068         tc->setMiscReg(MISCREG_MMU_LSU_CTRL, data);
1069         break;
1070       case ASI_MMU:
1071         switch (va) {
1072           case 0x8:
1073             tc->setMiscReg(MISCREG_MMU_P_CONTEXT, data);
1074             break;
1075           case 0x10:
1076             tc->setMiscReg(MISCREG_MMU_S_CONTEXT, data);
1077             break;
1078           default:
1079             goto doMmuWriteError;
1080         }
1081         break;
1082       case ASI_QUEUE:
1083         assert(mbits(data,13,6) == data);
1084         tc->setMiscReg(MISCREG_QUEUE_CPU_MONDO_HEAD +
1085                     (va >> 4) - 0x3c, data);
1086         break;
1087       case ASI_DMMU_CTXT_ZERO_TSB_BASE_PS0:
1088         assert(va == 0);
1089         c0_tsb_ps0 = data;
1090         break;
1091       case ASI_DMMU_CTXT_ZERO_TSB_BASE_PS1:
1092         assert(va == 0);
1093         c0_tsb_ps1 = data;
1094         break;
1095       case ASI_DMMU_CTXT_ZERO_CONFIG:
1096         assert(va == 0);
1097         c0_config = data;
1098         break;
1099       case ASI_IMMU_CTXT_ZERO_TSB_BASE_PS0:
1100         assert(va == 0);
1101         itb->c0_tsb_ps0 = data;
1102         break;
1103       case ASI_IMMU_CTXT_ZERO_TSB_BASE_PS1:
1104         assert(va == 0);
1105         itb->c0_tsb_ps1 = data;
1106         break;
1107       case ASI_IMMU_CTXT_ZERO_CONFIG:
1108         assert(va == 0);
1109         itb->c0_config = data;
1110         break;
1111       case ASI_DMMU_CTXT_NONZERO_TSB_BASE_PS0:
1112         assert(va == 0);
1113         cx_tsb_ps0 = data;
1114         break;
1115       case ASI_DMMU_CTXT_NONZERO_TSB_BASE_PS1:
1116         assert(va == 0);
1117         cx_tsb_ps1 = data;
1118         break;
1119       case ASI_DMMU_CTXT_NONZERO_CONFIG:
1120         assert(va == 0);
1121         cx_config = data;
1122         break;
1123       case ASI_IMMU_CTXT_NONZERO_TSB_BASE_PS0:
1124         assert(va == 0);
1125         itb->cx_tsb_ps0 = data;
1126         break;
1127       case ASI_IMMU_CTXT_NONZERO_TSB_BASE_PS1:
1128         assert(va == 0);
1129         itb->cx_tsb_ps1 = data;
1130         break;
1131       case ASI_IMMU_CTXT_NONZERO_CONFIG:
1132         assert(va == 0);
1133         itb->cx_config = data;
1134         break;
1135       case ASI_SPARC_ERROR_EN_REG:
1136       case ASI_SPARC_ERROR_STATUS_REG:
1137         inform("Ignoring write to SPARC ERROR regsiter\n");
1138         break;
1139       case ASI_HYP_SCRATCHPAD:
1140       case ASI_SCRATCHPAD:
1141         tc->setMiscReg(MISCREG_SCRATCHPAD_R0 + (va >> 3), data);
1142         break;
1143       case ASI_IMMU:
1144         switch (va) {
1145           case 0x18:
1146             itb->sfsr = data;
1147             break;
1148           case 0x30:
1149             sext<59>(bits(data, 59,0));
1150             itb->tag_access = data;
1151             break;
1152           default:
1153             goto doMmuWriteError;
1154         }
1155         break;
1156       case ASI_ITLB_DATA_ACCESS_REG:
1157         entry_insert = bits(va, 8,3);
1158       case ASI_ITLB_DATA_IN_REG:
1159         assert(entry_insert != -1 || mbits(va,10,9) == va);
1160         ta_insert = itb->tag_access;
1161         va_insert = mbits(ta_insert, 63,13);
1162         ct_insert = mbits(ta_insert, 12,0);
1163         part_insert = tc->readMiscReg(MISCREG_MMU_PART_ID);
1164         real_insert = bits(va, 9,9);
1165         pte.populate(data, bits(va,10,10) ? PageTableEntry::sun4v :
1166                 PageTableEntry::sun4u);
1167         tc->getITBPtr()->insert(va_insert, part_insert, ct_insert, real_insert,
1168                 pte, entry_insert);
1169         break;
1170       case ASI_DTLB_DATA_ACCESS_REG:
1171         entry_insert = bits(va, 8,3);
1172       case ASI_DTLB_DATA_IN_REG:
1173         assert(entry_insert != -1 || mbits(va,10,9) == va);
1174         ta_insert = tag_access;
1175         va_insert = mbits(ta_insert, 63,13);
1176         ct_insert = mbits(ta_insert, 12,0);
1177         part_insert = tc->readMiscReg(MISCREG_MMU_PART_ID);
1178         real_insert = bits(va, 9,9);
1179         pte.populate(data, bits(va,10,10) ? PageTableEntry::sun4v :
1180                 PageTableEntry::sun4u);
1181         insert(va_insert, part_insert, ct_insert, real_insert, pte,
1182                entry_insert);
1183         break;
1184       case ASI_IMMU_DEMAP:
1185         ignore = false;
1186         ctx_id = -1;
1187         part_id =  tc->readMiscReg(MISCREG_MMU_PART_ID);
1188         switch (bits(va,5,4)) {
1189           case 0:
1190             ctx_id = tc->readMiscReg(MISCREG_MMU_P_CONTEXT);
1191             break;
1192           case 1:
1193             ignore = true;
1194             break;
1195           case 3:
1196             ctx_id = 0;
1197             break;
1198           default:
1199             ignore = true;
1200         }
1201 
1202         switch (bits(va,7,6)) {
1203           case 0: // demap page
1204             if (!ignore)
1205                 tc->getITBPtr()->demapPage(mbits(va,63,13), part_id,
1206                         bits(va,9,9), ctx_id);
1207             break;
1208           case 1: // demap context
1209             if (!ignore)
1210                 tc->getITBPtr()->demapContext(part_id, ctx_id);
1211             break;
1212           case 2:
1213             tc->getITBPtr()->demapAll(part_id);
1214             break;
1215           default:
1216             panic("Invalid type for IMMU demap\n");
1217         }
1218         break;
1219       case ASI_DMMU:
1220         switch (va) {
1221           case 0x18:
1222             sfsr = data;
1223             break;
1224           case 0x30:
1225             sext<59>(bits(data, 59,0));
1226             tag_access = data;
1227             break;
1228           case 0x80:
1229             tc->setMiscReg(MISCREG_MMU_PART_ID, data);
1230             break;
1231           default:
1232             goto doMmuWriteError;
1233         }
1234         break;
1235       case ASI_DMMU_DEMAP:
1236         ignore = false;
1237         ctx_id = -1;
1238         part_id =  tc->readMiscReg(MISCREG_MMU_PART_ID);
1239         switch (bits(va,5,4)) {
1240           case 0:
1241             ctx_id = tc->readMiscReg(MISCREG_MMU_P_CONTEXT);
1242             break;
1243           case 1:
1244             ctx_id = tc->readMiscReg(MISCREG_MMU_S_CONTEXT);
1245             break;
1246           case 3:
1247             ctx_id = 0;
1248             break;
1249           default:
1250             ignore = true;
1251         }
1252 
1253         switch (bits(va,7,6)) {
1254           case 0: // demap page
1255             if (!ignore)
1256                 demapPage(mbits(va,63,13), part_id, bits(va,9,9), ctx_id);
1257             break;
1258           case 1: // demap context
1259             if (!ignore)
1260                 demapContext(part_id, ctx_id);
1261             break;
1262           case 2:
1263             demapAll(part_id);
1264             break;
1265           default:
1266             panic("Invalid type for IMMU demap\n");
1267         }
1268         break;
1269        case ASI_SWVR_INTR_RECEIVE:
1270         {
1271             int msb;
1272             // clear all the interrupts that aren't set in the write
1273             SparcISA::Interrupts * interrupts =
1274                 dynamic_cast<SparcISA::Interrupts *>(
1275                         tc->getCpuPtr()->getInterruptController());
1276             while (interrupts->get_vec(IT_INT_VEC) & data) {
1277                 msb = findMsbSet(interrupts->get_vec(IT_INT_VEC) & data);
1278                 tc->getCpuPtr()->clearInterrupt(IT_INT_VEC, msb);
1279             }
1280         }
1281         break;
1282       case ASI_SWVR_UDB_INTR_W:
1283             tc->getSystemPtr()->threadContexts[bits(data,12,8)]->getCpuPtr()->
1284             postInterrupt(bits(data, 5, 0), 0);
1285         break;
1286       default:
1287 doMmuWriteError:
1288         panic("need to impl DTB::doMmuRegWrite() got asi=%#x, va=%#x d=%#x\n",
1289             (uint32_t)pkt->req->getArchFlags(), pkt->getAddr(), data);
1290     }
1291     pkt->makeAtomicResponse();
1292     return Cycles(1);
1293 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_a8cb66fc5f158a5d28cb9e5d73ecd26cc}{
\index{SparcISA::TLB@{SparcISA::TLB}!dumpAll@{dumpAll}}
\index{dumpAll@{dumpAll}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{dumpAll}]{\setlength{\rightskip}{0pt plus 5cm}void dumpAll ()}}
\label{classSparcISA_1_1TLB_a8cb66fc5f158a5d28cb9e5d73ecd26cc}



\begin{DoxyCode}
240 {
241     MapIter i;
242     for (int x = 0; x < size; x++) {
243         if (tlb[x].valid) {
244            DPRINTFN("%4d:  %#2x:%#2x %c %#4x %#8x %#8x %#16x\n",
245                    x, tlb[x].range.partitionId, tlb[x].range.contextId,
246                    tlb[x].range.real ? 'R' : ' ', tlb[x].range.size,
247                    tlb[x].range.va, tlb[x].pte.paddr(), tlb[x].pte());
248         }
249     }
250 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_ae199d95c42e036851a8a0543c6d6d2e3}{
\index{SparcISA::TLB@{SparcISA::TLB}!finalizePhysical@{finalizePhysical}}
\index{finalizePhysical@{finalizePhysical}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{finalizePhysical}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} finalizePhysical ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Mode} {\em mode}) const}}
\label{classSparcISA_1_1TLB_ae199d95c42e036851a8a0543c6d6d2e3}



\begin{DoxyCode}
853 {
854     return NoFault;
855 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_aca1483a67aee5a91e442f7131d66bcbd}{
\index{SparcISA::TLB@{SparcISA::TLB}!flushAll@{flushAll}}
\index{flushAll@{flushAll}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{flushAll}]{\setlength{\rightskip}{0pt plus 5cm}void flushAll ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSparcISA_1_1TLB_aca1483a67aee5a91e442f7131d66bcbd}
Remove all entries from the \hyperlink{classSparcISA_1_1TLB}{TLB} 

\hyperlink{classBaseTLB_a5958bc92949a47d1be1088468abdc006}{BaseTLB}を実装しています。


\begin{DoxyCode}
327 {
328     cacheValid = false;
329     lookupTable.clear();
330 
331     for (int x = 0; x < size; x++) {
332         if (tlb[x].valid)
333             freeList.push_back(&tlb[x]);
334         tlb[x].valid = false;
335         tlb[x].used = false;
336     }
337     usedEntries = 0;
338 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_ab52a39898286d036febd5dcb6d0b376a}{
\index{SparcISA::TLB@{SparcISA::TLB}!GetTsbPtr@{GetTsbPtr}}
\index{GetTsbPtr@{GetTsbPtr}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{GetTsbPtr}]{\setlength{\rightskip}{0pt plus 5cm}void GetTsbPtr ({\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Addr} {\em addr}, \/  int {\em ctx}, \/  {\bf Addr} $\ast$ {\em ptrs})}}
\label{classSparcISA_1_1TLB_ab52a39898286d036febd5dcb6d0b376a}



\begin{DoxyCode}
1297 {
1298     uint64_t tag_access = mbits(addr,63,13) | mbits(ctx,12,0);
1299     TLB * itb = tc->getITBPtr();
1300     ptrs[0] = MakeTsbPtr(Ps0, tag_access,
1301                 c0_tsb_ps0,
1302                 c0_config,
1303                 cx_tsb_ps0,
1304                 cx_config);
1305     ptrs[1] = MakeTsbPtr(Ps1, tag_access,
1306                 c0_tsb_ps1,
1307                 c0_config,
1308                 cx_tsb_ps1,
1309                 cx_config);
1310     ptrs[2] = MakeTsbPtr(Ps0, tag_access,
1311                 itb->c0_tsb_ps0,
1312                 itb->c0_config,
1313                 itb->cx_tsb_ps0,
1314                 itb->cx_config);
1315     ptrs[3] = MakeTsbPtr(Ps1, tag_access,
1316                 itb->c0_tsb_ps1,
1317                 itb->c0_config,
1318                 itb->cx_tsb_ps1,
1319                 itb->cx_config);
1320 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_a2b2db94fc3a8f3652866d0dc2aabcf87}{
\index{SparcISA::TLB@{SparcISA::TLB}!insert@{insert}}
\index{insert@{insert}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{insert}]{\setlength{\rightskip}{0pt plus 5cm}void insert ({\bf Addr} {\em vpn}, \/  int {\em partition\_\-id}, \/  int {\em context\_\-id}, \/  bool {\em real}, \/  const {\bf PageTableEntry} \& {\em PTE}, \/  int {\em entry} = {\ttfamily -\/1})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a2b2db94fc3a8f3652866d0dc2aabcf87}
Insert a PTE into the \hyperlink{classSparcISA_1_1TLB}{TLB}. 


\begin{DoxyCode}
96 {
97     MapIter i;
98     TlbEntry *new_entry = NULL;
99 //    TlbRange tr;
100     int x;
101 
102     cacheValid = false;
103     va &= ~(PTE.size()-1);
104  /*   tr.va = va;
105     tr.size = PTE.size() - 1;
106     tr.contextId = context_id;
107     tr.partitionId = partition_id;
108     tr.real = real;
109 */
110 
111     DPRINTF(TLB,
112         "TLB: Inserting Entry; va=%#x pa=%#x pid=%d cid=%d r=%d entryid=%d\n",
113         va, PTE.paddr(), partition_id, context_id, (int)real, entry);
114 
115     // Demap any entry that conflicts
116     for (x = 0; x < size; x++) {
117         if (tlb[x].range.real == real &&
118             tlb[x].range.partitionId == partition_id &&
119             tlb[x].range.va < va + PTE.size() - 1 &&
120             tlb[x].range.va + tlb[x].range.size >= va &&
121             (real || tlb[x].range.contextId == context_id ))
122         {
123             if (tlb[x].valid) {
124                 freeList.push_front(&tlb[x]);
125                 DPRINTF(TLB, "TLB: Conflicting entry %#X , deleting it\n", x);
126 
127                 tlb[x].valid = false;
128                 if (tlb[x].used) {
129                     tlb[x].used = false;
130                     usedEntries--;
131                 }
132                 lookupTable.erase(tlb[x].range);
133             }
134         }
135     }
136 
137     if (entry != -1) {
138         assert(entry < size && entry >= 0);
139         new_entry = &tlb[entry];
140     } else {
141         if (!freeList.empty()) {
142             new_entry = freeList.front();
143         } else {
144             x = lastReplaced;
145             do {
146                 ++x;
147                 if (x == size)
148                     x = 0;
149                 if (x == lastReplaced)
150                     goto insertAllLocked;
151             } while (tlb[x].pte.locked());
152             lastReplaced = x;
153             new_entry = &tlb[x];
154         }
155     }
156 
157 insertAllLocked:
158     // Update the last ently if their all locked
159     if (!new_entry) {
160         new_entry = &tlb[size-1];
161     }
162 
163     freeList.remove(new_entry);
164     if (new_entry->valid && new_entry->used)
165         usedEntries--;
166     if (new_entry->valid)
167         lookupTable.erase(new_entry->range);
168 
169 
170     assert(PTE.valid());
171     new_entry->range.va = va;
172     new_entry->range.size = PTE.size() - 1;
173     new_entry->range.partitionId = partition_id;
174     new_entry->range.contextId = context_id;
175     new_entry->range.real = real;
176     new_entry->pte = PTE;
177     new_entry->used = true;;
178     new_entry->valid = true;
179     usedEntries++;
180 
181     i = lookupTable.insert(new_entry->range, new_entry);
182     assert(i != lookupTable.end());
183 
184     // If all entries have their used bit set, clear it on them all,
185     // but the one we just inserted
186     if (usedEntries == size) {
187         clearUsedBits();
188         new_entry->used = true;
189         usedEntries++;
190     }
191 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_a74fbbb81cfaa89e81165a62736e4311a}{
\index{SparcISA::TLB@{SparcISA::TLB}!lookup@{lookup}}
\index{lookup@{lookup}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{lookup}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TlbEntry} $\ast$ lookup ({\bf Addr} {\em va}, \/  int {\em partition\_\-id}, \/  bool {\em real}, \/  int {\em context\_\-id} = {\ttfamily 0}, \/  bool {\em update\_\-used} = {\ttfamily true})}}
\label{classSparcISA_1_1TLB_a74fbbb81cfaa89e81165a62736e4311a}
lookup an entry in the \hyperlink{classSparcISA_1_1TLB}{TLB} based on the partition id, and real bit if real is true or the partition id, and context id if real is false. 
\begin{DoxyParams}{引数}
\item[{\em va}]the virtual address not shifted (e.g. bottom 13 bits are 0) \item[{\em paritition\_\-id}]partition this entry is for \item[{\em real}]is this a real-\/$>$phys or virt-\/$>$phys translation \item[{\em context\_\-id}]if this is virt-\/$>$phys what context \item[{\em update\_\-used}]should ew update the used bits in the entries on not useful if we are trying to do a va-\/$>$pa without mucking with any state for a debug read for example. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A pointer to a tlb entry 
\end{DoxyReturn}



\begin{DoxyCode}
197 {
198     MapIter i;
199     TlbRange tr;
200     TlbEntry *t;
201 
202     DPRINTF(TLB, "TLB: Looking up entry va=%#x pid=%d cid=%d r=%d\n",
203             va, partition_id, context_id, real);
204     // Assemble full address structure
205     tr.va = va;
206     tr.size = 1;
207     tr.contextId = context_id;
208     tr.partitionId = partition_id;
209     tr.real = real;
210 
211     // Try to find the entry
212     i = lookupTable.find(tr);
213     if (i == lookupTable.end()) {
214         DPRINTF(TLB, "TLB: No valid entry found\n");
215         return NULL;
216     }
217 
218     // Mark the entries used bit and clear other used bits in needed
219     t = i->second;
220     DPRINTF(TLB, "TLB: Valid entry found pa: %#x size: %#x\n", t->pte.paddr(),
221             t->pte.size());
222 
223     // Update the used bits only if this is a real access (not a fake
224     // one from virttophys()
225     if (!t->used && update_used) {
226         t->used = true;
227         usedEntries++;
228         if (usedEntries == size) {
229             clearUsedBits();
230             t->used = true;
231             usedEntries++;
232         }
233     }
234 
235     return t;
236 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_a69c520e9f2bec8ddb4eb5121cf10a94c}{
\index{SparcISA::TLB@{SparcISA::TLB}!MakeTsbPtr@{MakeTsbPtr}}
\index{MakeTsbPtr@{MakeTsbPtr}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{MakeTsbPtr}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t MakeTsbPtr ({\bf TsbPageSize} {\em ps}, \/  uint64\_\-t {\em tag\_\-access}, \/  uint64\_\-t {\em c0\_\-tsb}, \/  uint64\_\-t {\em c0\_\-config}, \/  uint64\_\-t {\em cX\_\-tsb}, \/  uint64\_\-t {\em cX\_\-config})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSparcISA_1_1TLB_a69c520e9f2bec8ddb4eb5121cf10a94c}



\begin{DoxyCode}
1325 {
1326     uint64_t tsb;
1327     uint64_t config;
1328 
1329     if (bits(tag_access, 12,0) == 0) {
1330         tsb = c0_tsb;
1331         config = c0_config;
1332     } else {
1333         tsb = cX_tsb;
1334         config = cX_config;
1335     }
1336 
1337     uint64_t ptr = mbits(tsb,63,13);
1338     bool split = bits(tsb,12,12);
1339     int tsb_size = bits(tsb,3,0);
1340     int page_size = (ps == Ps0) ? bits(config, 2,0) : bits(config,10,8);
1341 
1342     if (ps == Ps1  && split)
1343         ptr |= ULL(1) << (13 + tsb_size);
1344     ptr |= (tag_access >> (9 + page_size * 3)) & mask(12+tsb_size, 4);
1345 
1346     return ptr;
1347 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_a53e036786d17361be4c7320d39c99b84}{
\index{SparcISA::TLB@{SparcISA::TLB}!serialize@{serialize}}
\index{serialize@{serialize}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSparcISA_1_1TLB_a53e036786d17361be4c7320d39c99b84}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。


\begin{DoxyCode}
1351 {
1352     SERIALIZE_SCALAR(size);
1353     SERIALIZE_SCALAR(usedEntries);
1354     SERIALIZE_SCALAR(lastReplaced);
1355 
1356     // convert the pointer based free list into an index based one
1357     int *free_list = (int*)malloc(sizeof(int) * size);
1358     int cntr = 0;
1359     std::list<TlbEntry*>::iterator i;
1360     i = freeList.begin();
1361     while (i != freeList.end()) {
1362         free_list[cntr++] = ((size_t)*i - (size_t)tlb)/ sizeof(TlbEntry);
1363         i++;
1364     }
1365     SERIALIZE_SCALAR(cntr);
1366     SERIALIZE_ARRAY(free_list,  cntr);
1367 
1368     SERIALIZE_SCALAR(c0_tsb_ps0);
1369     SERIALIZE_SCALAR(c0_tsb_ps1);
1370     SERIALIZE_SCALAR(c0_config);
1371     SERIALIZE_SCALAR(cx_tsb_ps0);
1372     SERIALIZE_SCALAR(cx_tsb_ps1);
1373     SERIALIZE_SCALAR(cx_config);
1374     SERIALIZE_SCALAR(sfsr);
1375     SERIALIZE_SCALAR(tag_access);
1376 
1377     for (int x = 0; x < size; x++) {
1378         nameOut(os, csprintf("%s.PTE%d", name(), x));
1379         tlb[x].serialize(os);
1380     }
1381     SERIALIZE_SCALAR(sfar);
1382 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_aaf85d399be0a94d95fa3282faff835ea}{
\index{SparcISA::TLB@{SparcISA::TLB}!TagRead@{TagRead}}
\index{TagRead@{TagRead}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{TagRead}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t TagRead (int {\em entry})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_aaf85d399be0a94d95fa3282faff835ea}
Given an entry id, read that tlb entries' tag. 


\begin{DoxyCode}
355 {
356     assert(entry < size);
357     uint64_t tag;
358     if (!tlb[entry].valid)
359         return (uint64_t)-1ll;
360 
361     tag = tlb[entry].range.contextId;
362     tag |= tlb[entry].range.va;
363     tag |= (uint64_t)tlb[entry].range.partitionId << 61;
364     tag |= tlb[entry].range.real ? ULL(1) << 60 : 0;
365     tag |= (uint64_t)~tlb[entry].pte._size() << 56;
366     return tag;
367 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_a15b6c15c1be2ca4de3e65772a02aa29f}{
\index{SparcISA::TLB@{SparcISA::TLB}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ({\bf BaseTLB} $\ast$ {\em otlb})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSparcISA_1_1TLB_a15b6c15c1be2ca4de3e65772a02aa29f}



\begin{DoxyCode}
157 {}
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_ad54e01e3c0a1613098a76b7f92e5be93}{
\index{SparcISA::TLB@{SparcISA::TLB}!translateAtomic@{translateAtomic}}
\index{translateAtomic@{translateAtomic}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{translateAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translateAtomic ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Mode} {\em mode})}}
\label{classSparcISA_1_1TLB_ad54e01e3c0a1613098a76b7f92e5be93}



\begin{DoxyCode}
829 {
830     if (mode == Execute)
831         return translateInst(req, tc);
832     else
833         return translateData(req, tc, mode == Write);
834 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_ad54aef66412f77e2a15a621a126dfb52}{
\index{SparcISA::TLB@{SparcISA::TLB}!translateData@{translateData}}
\index{translateData@{translateData}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{translateData}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translateData ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  bool {\em write})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_ad54aef66412f77e2a15a621a126dfb52}


Normal flow ends here. 


\begin{DoxyCode}
530 {
531     /*
532      * @todo this could really use some profiling and fixing to make
533      * it faster!
534      */
535     uint64_t tlbdata = tc->readMiscRegNoEffect(MISCREG_TLB_DATA);
536     Addr vaddr = req->getVaddr();
537     Addr size = req->getSize();
538     ASI asi;
539     asi = (ASI)req->getArchFlags();
540     bool implicit = false;
541     bool hpriv = bits(tlbdata,0,0);
542     bool unaligned = vaddr & (size - 1);
543 
544     DPRINTF(TLB, "TLB: DTB Request to translate va=%#x size=%d asi=%#x\n",
545             vaddr, size, asi);
546 
547     if (lookupTable.size() != 64 - freeList.size())
548        panic("Lookup table size: %d tlb size: %d\n", lookupTable.size(),
549                freeList.size());
550     if (asi == ASI_IMPLICIT)
551         implicit = true;
552 
553     // Only use the fast path here if there doesn't need to be an unaligned
554     // trap later
555     if (!unaligned) {
556         if (hpriv && implicit) {
557             req->setPaddr(vaddr & PAddrImplMask);
558             return NoFault;
559         }
560 
561         // Be fast if we can!
562         if (cacheValid &&  cacheState == tlbdata) {
563 
564 
565 
566             if (cacheEntry[0]) {
567                 TlbEntry *ce = cacheEntry[0];
568                 Addr ce_va = ce->range.va;
569                 if (cacheAsi[0] == asi &&
570                     ce_va < vaddr + size && ce_va + ce->range.size > vaddr &&
571                     (!write || ce->pte.writable())) {
572                     req->setPaddr(ce->pte.translate(vaddr));
573                     if (ce->pte.sideffect() || (ce->pte.paddr() >> 39) & 1)
574                         req->setFlags(Request::UNCACHEABLE);
575                     DPRINTF(TLB, "TLB: %#X -> %#X\n", vaddr, req->getPaddr());
576                     return NoFault;
577                 } // if matched
578             } // if cache entry valid
579             if (cacheEntry[1]) {
580                 TlbEntry *ce = cacheEntry[1];
581                 Addr ce_va = ce->range.va;
582                 if (cacheAsi[1] == asi &&
583                     ce_va < vaddr + size && ce_va + ce->range.size > vaddr &&
584                     (!write || ce->pte.writable())) {
585                     req->setPaddr(ce->pte.translate(vaddr));
586                     if (ce->pte.sideffect() || (ce->pte.paddr() >> 39) & 1)
587                         req->setFlags(Request::UNCACHEABLE);
588                     DPRINTF(TLB, "TLB: %#X -> %#X\n", vaddr, req->getPaddr());
589                     return NoFault;
590                 } // if matched
591             } // if cache entry valid
592         }
593     }
594 
595     bool red = bits(tlbdata,1,1);
596     bool priv = bits(tlbdata,2,2);
597     bool addr_mask = bits(tlbdata,3,3);
598     bool lsu_dm = bits(tlbdata,5,5);
599 
600     int part_id = bits(tlbdata,15,8);
601     int tl = bits(tlbdata,18,16);
602     int pri_context = bits(tlbdata,47,32);
603     int sec_context = bits(tlbdata,63,48);
604 
605     bool real = false;
606     ContextType ct = Primary;
607     int context = 0;
608 
609     TlbEntry *e;
610 
611     DPRINTF(TLB, "TLB: priv:%d hpriv:%d red:%d lsudm:%d part_id: %#X\n",
612             priv, hpriv, red, lsu_dm, part_id);
613 
614     if (implicit) {
615         if (tl > 0) {
616             asi = ASI_N;
617             ct = Nucleus;
618             context = 0;
619         } else {
620             asi = ASI_P;
621             ct = Primary;
622             context = pri_context;
623         }
624     } else {
625         // We need to check for priv level/asi priv
626         if (!priv && !hpriv && !asiIsUnPriv(asi)) {
627             // It appears that context should be Nucleus in these cases?
628             writeSfsr(vaddr, write, Nucleus, false, IllegalAsi, asi);
629             return new PrivilegedAction;
630         }
631 
632         if (!hpriv && asiIsHPriv(asi)) {
633             writeSfsr(vaddr, write, Nucleus, false, IllegalAsi, asi);
634             return new DataAccessException;
635         }
636 
637         if (asiIsPrimary(asi)) {
638             context = pri_context;
639             ct = Primary;
640         } else if (asiIsSecondary(asi)) {
641             context = sec_context;
642             ct = Secondary;
643         } else if (asiIsNucleus(asi)) {
644             ct = Nucleus;
645             context = 0;
646         } else {  // ????
647             ct = Primary;
648             context = pri_context;
649         }
650     }
651 
652     if (!implicit && asi != ASI_P && asi != ASI_S) {
653         if (asiIsLittle(asi))
654             panic("Little Endian ASIs not supported\n");
655 
656         //XXX It's unclear from looking at the documentation how a no fault
657         // load differs from a regular one, other than what happens concerning
658         // nfo and e bits in the TTE
659 //        if (asiIsNoFault(asi))
660 //            panic("No Fault ASIs not supported\n");
661 
662         if (asiIsPartialStore(asi))
663             panic("Partial Store ASIs not supported\n");
664 
665         if (asiIsCmt(asi))
666             panic("Cmt ASI registers not implmented\n");
667 
668         if (asiIsInterrupt(asi))
669             goto handleIntRegAccess;
670         if (asiIsMmu(asi))
671             goto handleMmuRegAccess;
672         if (asiIsScratchPad(asi))
673             goto handleScratchRegAccess;
674         if (asiIsQueue(asi))
675             goto handleQueueRegAccess;
676         if (asiIsSparcError(asi))
677             goto handleSparcErrorRegAccess;
678 
679         if (!asiIsReal(asi) && !asiIsNucleus(asi) && !asiIsAsIfUser(asi) &&
680                 !asiIsTwin(asi) && !asiIsBlock(asi) && !asiIsNoFault(asi))
681             panic("Accessing ASI %#X. Should we?\n", asi);
682     }
683 
684     // If the asi is unaligned trap
685     if (unaligned) {
686         writeSfsr(vaddr, false, ct, false, OtherFault, asi);
687         return new MemAddressNotAligned;
688     }
689 
690     if (addr_mask)
691         vaddr = vaddr & VAddrAMask;
692 
693     if (!validVirtualAddress(vaddr, addr_mask)) {
694         writeSfsr(vaddr, false, ct, true, VaOutOfRange, asi);
695         return new DataAccessException;
696     }
697 
698     if ((!lsu_dm && !hpriv && !red) || asiIsReal(asi)) {
699         real = true;
700         context = 0;
701     }
702 
703     if (hpriv && (implicit || (!asiIsAsIfUser(asi) && !asiIsReal(asi)))) {
704         req->setPaddr(vaddr & PAddrImplMask);
705         return NoFault;
706     }
707 
708     e = lookup(vaddr, part_id, real, context);
709 
710     if (e == NULL || !e->valid) {
711         writeTagAccess(vaddr, context);
712         DPRINTF(TLB, "TLB: DTB Failed to find matching TLB entry\n");
713         if (real) {
714             return new DataRealTranslationMiss;
715         } else {
716             if (FullSystem)
717                 return new FastDataAccessMMUMiss;
718             else
719                 return new FastDataAccessMMUMiss(req->getVaddr());
720         }
721 
722     }
723 
724     if (!priv && e->pte.priv()) {
725         writeTagAccess(vaddr, context);
726         writeSfsr(vaddr, write, ct, e->pte.sideffect(), PrivViolation, asi);
727         return new DataAccessException;
728     }
729 
730     if (write && !e->pte.writable()) {
731         writeTagAccess(vaddr, context);
732         writeSfsr(vaddr, write, ct, e->pte.sideffect(), OtherFault, asi);
733         return new FastDataAccessProtection;
734     }
735 
736     if (e->pte.nofault() && !asiIsNoFault(asi)) {
737         writeTagAccess(vaddr, context);
738         writeSfsr(vaddr, write, ct, e->pte.sideffect(), LoadFromNfo, asi);
739         return new DataAccessException;
740     }
741 
742     if (e->pte.sideffect() && asiIsNoFault(asi)) {
743         writeTagAccess(vaddr, context);
744         writeSfsr(vaddr, write, ct, e->pte.sideffect(), SideEffect, asi);
745         return new DataAccessException;
746     }
747 
748     if (e->pte.sideffect() || (e->pte.paddr() >> 39) & 1)
749         req->setFlags(Request::UNCACHEABLE);
750 
751     // cache translation date for next translation
752     cacheState = tlbdata;
753     if (!cacheValid) {
754         cacheEntry[1] = NULL;
755         cacheEntry[0] = NULL;
756     }
757 
758     if (cacheEntry[0] != e && cacheEntry[1] != e) {
759         cacheEntry[1] = cacheEntry[0];
760         cacheEntry[0] = e;
761         cacheAsi[1] = cacheAsi[0];
762         cacheAsi[0] = asi;
763         if (implicit)
764             cacheAsi[0] = (ASI)0;
765     }
766     cacheValid = true;
767     req->setPaddr(e->pte.translate(vaddr));
768     DPRINTF(TLB, "TLB: %#X -> %#X\n", vaddr, req->getPaddr());
769     return NoFault;
770 
772 handleIntRegAccess:
773     if (!hpriv) {
774         writeSfsr(vaddr, write, Primary, true, IllegalAsi, asi);
775         if (priv)
776             return new DataAccessException;
777          else
778             return new PrivilegedAction;
779     }
780 
781     if ((asi == ASI_SWVR_UDB_INTR_W && !write) ||
782         (asi == ASI_SWVR_UDB_INTR_R && write)) {
783         writeSfsr(vaddr, write, Primary, true, IllegalAsi, asi);
784         return new DataAccessException;
785     }
786 
787     goto regAccessOk;
788 
789 
790 handleScratchRegAccess:
791     if (vaddr > 0x38 || (vaddr >= 0x20 && vaddr < 0x30 && !hpriv)) {
792         writeSfsr(vaddr, write, Primary, true, IllegalAsi, asi);
793         return new DataAccessException;
794     }
795     goto regAccessOk;
796 
797 handleQueueRegAccess:
798     if (!priv  && !hpriv) {
799         writeSfsr(vaddr, write, Primary, true, IllegalAsi, asi);
800         return new PrivilegedAction;
801     }
802     if ((!hpriv && vaddr & 0xF) || vaddr > 0x3f8 || vaddr < 0x3c0) {
803         writeSfsr(vaddr, write, Primary, true, IllegalAsi, asi);
804         return new DataAccessException;
805     }
806     goto regAccessOk;
807 
808 handleSparcErrorRegAccess:
809     if (!hpriv) {
810         writeSfsr(vaddr, write, Primary, true, IllegalAsi, asi);
811         if (priv)
812             return new DataAccessException;
813          else
814             return new PrivilegedAction;
815     }
816     goto regAccessOk;
817 
818 
819 regAccessOk:
820 handleMmuRegAccess:
821     DPRINTF(TLB, "TLB: DTB Translating MM IPR access\n");
822     req->setFlags(Request::MMAPPED_IPR);
823     req->setPaddr(req->getVaddr());
824     return NoFault;
825 };
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_a26658814c6c9034665aae19cf25545bb}{
\index{SparcISA::TLB@{SparcISA::TLB}!translateFunctional@{translateFunctional}}
\index{translateFunctional@{translateFunctional}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{translateFunctional}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translateFunctional ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Mode} {\em mode})}}
\label{classSparcISA_1_1TLB_a26658814c6c9034665aae19cf25545bb}
Stub function for compilation support with \hyperlink{classCheckerCPU}{CheckerCPU}. SPARC \hyperlink{classSparcISA_1_1ISA}{ISA} does not support the \hyperlink{classChecker}{Checker} model at the moment 


\begin{DoxyCode}
846 {
847     panic("Not implemented\n");
848     return NoFault;
849 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_a072afd8ed455dade4c25a85510e5a4da}{
\index{SparcISA::TLB@{SparcISA::TLB}!translateInst@{translateInst}}
\index{translateInst@{translateInst}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{translateInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} translateInst ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a072afd8ed455dade4c25a85510e5a4da}



\begin{DoxyCode}
417 {
418     uint64_t tlbdata = tc->readMiscRegNoEffect(MISCREG_TLB_DATA);
419 
420     Addr vaddr = req->getVaddr();
421     TlbEntry *e;
422 
423     assert(req->getArchFlags() == ASI_IMPLICIT);
424 
425     DPRINTF(TLB, "TLB: ITB Request to translate va=%#x size=%d\n",
426             vaddr, req->getSize());
427 
428     // Be fast if we can!
429     if (cacheValid && cacheState == tlbdata) {
430         if (cacheEntry[0]) {
431             if (cacheEntry[0]->range.va < vaddr + sizeof(MachInst) &&
432                 cacheEntry[0]->range.va + cacheEntry[0]->range.size >= vaddr) {
433                 req->setPaddr(cacheEntry[0]->pte.translate(vaddr));
434                 return NoFault;
435             }
436         } else {
437             req->setPaddr(vaddr & PAddrImplMask);
438             return NoFault;
439         }
440     }
441 
442     bool hpriv = bits(tlbdata,0,0);
443     bool red = bits(tlbdata,1,1);
444     bool priv = bits(tlbdata,2,2);
445     bool addr_mask = bits(tlbdata,3,3);
446     bool lsu_im = bits(tlbdata,4,4);
447 
448     int part_id = bits(tlbdata,15,8);
449     int tl = bits(tlbdata,18,16);
450     int pri_context = bits(tlbdata,47,32);
451     int context;
452     ContextType ct;
453     int asi;
454     bool real = false;
455 
456     DPRINTF(TLB, "TLB: priv:%d hpriv:%d red:%d lsuim:%d part_id: %#X\n",
457            priv, hpriv, red, lsu_im, part_id);
458 
459     if (tl > 0) {
460         asi = ASI_N;
461         ct = Nucleus;
462         context = 0;
463     } else {
464         asi = ASI_P;
465         ct = Primary;
466         context = pri_context;
467     }
468 
469     if ( hpriv || red ) {
470         cacheValid = true;
471         cacheState = tlbdata;
472         cacheEntry[0] = NULL;
473         req->setPaddr(vaddr & PAddrImplMask);
474         return NoFault;
475     }
476 
477     // If the access is unaligned trap
478     if (vaddr & 0x3) {
479         writeSfsr(false, ct, false, OtherFault, asi);
480         return new MemAddressNotAligned;
481     }
482 
483     if (addr_mask)
484         vaddr = vaddr & VAddrAMask;
485 
486     if (!validVirtualAddress(vaddr, addr_mask)) {
487         writeSfsr(false, ct, false, VaOutOfRange, asi);
488         return new InstructionAccessException;
489     }
490 
491     if (!lsu_im) {
492         e = lookup(vaddr, part_id, true);
493         real = true;
494         context = 0;
495     } else {
496         e = lookup(vaddr, part_id, false, context);
497     }
498 
499     if (e == NULL || !e->valid) {
500         writeTagAccess(vaddr, context);
501         if (real) {
502             return new InstructionRealTranslationMiss;
503         } else {
504             if (FullSystem)
505                 return new FastInstructionAccessMMUMiss;
506             else
507                 return new FastInstructionAccessMMUMiss(req->getVaddr());
508         }
509     }
510 
511     // were not priviledged accesing priv page
512     if (!priv && e->pte.priv()) {
513         writeTagAccess(vaddr, context);
514         writeSfsr(false, ct, false, PrivViolation, asi);
515         return new InstructionAccessException;
516     }
517 
518     // cache translation date for next translation
519     cacheValid = true;
520     cacheState = tlbdata;
521     cacheEntry[0] = e;
522 
523     req->setPaddr(e->pte.translate(vaddr));
524     DPRINTF(TLB, "TLB: %#X -> %#X\n", vaddr, req->getPaddr());
525     return NoFault;
526 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_ae52f7e465748883695d2b4f432a13652}{
\index{SparcISA::TLB@{SparcISA::TLB}!translateTiming@{translateTiming}}
\index{translateTiming@{translateTiming}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{translateTiming}]{\setlength{\rightskip}{0pt plus 5cm}void translateTiming ({\bf RequestPtr} {\em req}, \/  {\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf Translation} $\ast$ {\em translation}, \/  {\bf Mode} {\em mode})}}
\label{classSparcISA_1_1TLB_ae52f7e465748883695d2b4f432a13652}



\begin{DoxyCode}
839 {
840     assert(translation);
841     translation->finish(translateAtomic(req, tc, mode), req, tc, mode);
842 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_a62b717ca770fe6713cdde68d76694f44}{
\index{SparcISA::TLB@{SparcISA::TLB}!TteRead@{TteRead}}
\index{TteRead@{TteRead}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{TteRead}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t TteRead (int {\em entry})}}
\label{classSparcISA_1_1TLB_a62b717ca770fe6713cdde68d76694f44}
Give an entry id, read that tlb entries' tte 


\begin{DoxyCode}
342 {
343     if (entry >= size)
344         panic("entry: %d\n", entry);
345 
346     assert(entry < size);
347     if (tlb[entry].valid)
348         return tlb[entry].pte();
349     else
350         return (uint64_t)-1ll;
351 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_af22e5d6d660b97db37003ac61ac4ee49}{
\index{SparcISA::TLB@{SparcISA::TLB}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSparcISA_1_1TLB_af22e5d6d660b97db37003ac61ac4ee49}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。


\begin{DoxyCode}
1386 {
1387     int oldSize;
1388 
1389     paramIn(cp, section, "size", oldSize);
1390     if (oldSize != size)
1391         panic("Don't support unserializing different sized TLBs\n");
1392     UNSERIALIZE_SCALAR(usedEntries);
1393     UNSERIALIZE_SCALAR(lastReplaced);
1394 
1395     int cntr;
1396     UNSERIALIZE_SCALAR(cntr);
1397 
1398     int *free_list = (int*)malloc(sizeof(int) * cntr);
1399     freeList.clear();
1400     UNSERIALIZE_ARRAY(free_list,  cntr);
1401     for (int x = 0; x < cntr; x++)
1402         freeList.push_back(&tlb[free_list[x]]);
1403 
1404     UNSERIALIZE_SCALAR(c0_tsb_ps0);
1405     UNSERIALIZE_SCALAR(c0_tsb_ps1);
1406     UNSERIALIZE_SCALAR(c0_config);
1407     UNSERIALIZE_SCALAR(cx_tsb_ps0);
1408     UNSERIALIZE_SCALAR(cx_tsb_ps1);
1409     UNSERIALIZE_SCALAR(cx_config);
1410     UNSERIALIZE_SCALAR(sfsr);
1411     UNSERIALIZE_SCALAR(tag_access);
1412 
1413     lookupTable.clear();
1414     for (int x = 0; x < size; x++) {
1415         tlb[x].unserialize(cp, csprintf("%s.PTE%d", section, x));
1416         if (tlb[x].valid)
1417             lookupTable.insert(tlb[x].range, &tlb[x]);
1418 
1419     }
1420     UNSERIALIZE_SCALAR(sfar);
1421 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_aa5cff14a14bcb47f10bb095035bd6290}{
\index{SparcISA::TLB@{SparcISA::TLB}!validVirtualAddress@{validVirtualAddress}}
\index{validVirtualAddress@{validVirtualAddress}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{validVirtualAddress}]{\setlength{\rightskip}{0pt plus 5cm}bool validVirtualAddress ({\bf Addr} {\em va}, \/  bool {\em am})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_aa5cff14a14bcb47f10bb095035bd6290}
Checks if the virtual address provided is a valid one. 


\begin{DoxyCode}
371 {
372     if (am)
373         return true;
374     if (va >= StartVAddrHole && va <= EndVAddrHole)
375         return false;
376     return true;
377 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_a3c55ffc205560c3c945248eda4e0a62d}{
\index{SparcISA::TLB@{SparcISA::TLB}!writeSfsr@{writeSfsr}}
\index{writeSfsr@{writeSfsr}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{writeSfsr}]{\setlength{\rightskip}{0pt plus 5cm}void writeSfsr ({\bf Addr} {\em a}, \/  bool {\em write}, \/  {\bf ContextType} {\em ct}, \/  bool {\em se}, \/  {\bf FaultTypes} {\em ft}, \/  int {\em asi})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSparcISA_1_1TLB_a3c55ffc205560c3c945248eda4e0a62d}



\begin{DoxyCode}
408 {
409     DPRINTF(TLB, "TLB: Fault: A=%#x w=%d ct=%d ft=%d asi=%d\n",
410             a, (int)write, ct, ft, asi);
411     TLB::writeSfsr(write, ct, se, ft, asi);
412     sfar = a;
413 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_afd0c300a55c5f8ae2a678bcac2179afb}{
\index{SparcISA::TLB@{SparcISA::TLB}!writeSfsr@{writeSfsr}}
\index{writeSfsr@{writeSfsr}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{writeSfsr}]{\setlength{\rightskip}{0pt plus 5cm}void writeSfsr (bool {\em write}, \/  {\bf ContextType} {\em ct}, \/  bool {\em se}, \/  {\bf FaultTypes} {\em ft}, \/  int {\em asi})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_afd0c300a55c5f8ae2a678bcac2179afb}



\begin{DoxyCode}
381 {
382     if (sfsr & 0x1)
383         sfsr = 0x3;
384     else
385         sfsr = 1;
386 
387     if (write)
388         sfsr |= 1 << 2;
389     sfsr |= ct << 4;
390     if (se)
391         sfsr |= 1 << 6;
392     sfsr |= ft << 7;
393     sfsr |= asi << 16;
394 }
\end{DoxyCode}
\hypertarget{classSparcISA_1_1TLB_a7f076e15ef97f1dd3f5e128b48cb4974}{
\index{SparcISA::TLB@{SparcISA::TLB}!writeTagAccess@{writeTagAccess}}
\index{writeTagAccess@{writeTagAccess}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{writeTagAccess}]{\setlength{\rightskip}{0pt plus 5cm}void writeTagAccess ({\bf Addr} {\em va}, \/  int {\em context})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a7f076e15ef97f1dd3f5e128b48cb4974}



\begin{DoxyCode}
398 {
399     DPRINTF(TLB, "TLB: Writing Tag Access: va: %#X ctx: %#X value: %#X\n",
400             va, context, mbits(va, 63,13) | mbits(context,12,0));
401 
402     tag_access = mbits(va, 63,13) | mbits(context,12,0);
403 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classSparcISA_1_1TLB_a3d497ded3c85659ec4b013e2cae38c71}{
\index{SparcISA::TLB@{SparcISA::TLB}!FastDataAccessMMUMiss@{FastDataAccessMMUMiss}}
\index{FastDataAccessMMUMiss@{FastDataAccessMMUMiss}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{FastDataAccessMMUMiss}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf FastDataAccessMMUMiss}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classSparcISA_1_1TLB_a3d497ded3c85659ec4b013e2cae38c71}
\hypertarget{classSparcISA_1_1TLB_af8c3b0d2687d5c17d60fee3e4e77e20f}{
\index{SparcISA::TLB@{SparcISA::TLB}!FastInstructionAccessMMUMiss@{FastInstructionAccessMMUMiss}}
\index{FastInstructionAccessMMUMiss@{FastInstructionAccessMMUMiss}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{FastInstructionAccessMMUMiss}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf FastInstructionAccessMMUMiss}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classSparcISA_1_1TLB_af8c3b0d2687d5c17d60fee3e4e77e20f}


\subsection{変数}
\hypertarget{classSparcISA_1_1TLB_a9395cf2ea615ba767ab8a677ee13d29c}{
\index{SparcISA::TLB@{SparcISA::TLB}!c0\_\-config@{c0\_\-config}}
\index{c0\_\-config@{c0\_\-config}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{c0\_\-config}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf c0\_\-config}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a9395cf2ea615ba767ab8a677ee13d29c}
\hypertarget{classSparcISA_1_1TLB_ac1b9fd2f6c65e41f4f5b85b1b50d3a4e}{
\index{SparcISA::TLB@{SparcISA::TLB}!c0\_\-tsb\_\-ps0@{c0\_\-tsb\_\-ps0}}
\index{c0\_\-tsb\_\-ps0@{c0\_\-tsb\_\-ps0}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{c0\_\-tsb\_\-ps0}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf c0\_\-tsb\_\-ps0}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_ac1b9fd2f6c65e41f4f5b85b1b50d3a4e}
\hypertarget{classSparcISA_1_1TLB_a1ab61f1741b5a3c2f81fe87fe3908e7e}{
\index{SparcISA::TLB@{SparcISA::TLB}!c0\_\-tsb\_\-ps1@{c0\_\-tsb\_\-ps1}}
\index{c0\_\-tsb\_\-ps1@{c0\_\-tsb\_\-ps1}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{c0\_\-tsb\_\-ps1}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf c0\_\-tsb\_\-ps1}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a1ab61f1741b5a3c2f81fe87fe3908e7e}
\hypertarget{classSparcISA_1_1TLB_ad1ec0943e2f511b3a252ca0b824eb3e6}{
\index{SparcISA::TLB@{SparcISA::TLB}!cacheAsi@{cacheAsi}}
\index{cacheAsi@{cacheAsi}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{cacheAsi}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ASI} {\bf cacheAsi}\mbox{[}2\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSparcISA_1_1TLB_ad1ec0943e2f511b3a252ca0b824eb3e6}
\hypertarget{classSparcISA_1_1TLB_a5c9e9ce37f7a50fb908752ece801110f}{
\index{SparcISA::TLB@{SparcISA::TLB}!cacheEntry@{cacheEntry}}
\index{cacheEntry@{cacheEntry}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{cacheEntry}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TlbEntry}$\ast$ {\bf cacheEntry}\mbox{[}2\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSparcISA_1_1TLB_a5c9e9ce37f7a50fb908752ece801110f}
\hypertarget{classSparcISA_1_1TLB_a426d36e3a37393acd76bb3f1b14c2be9}{
\index{SparcISA::TLB@{SparcISA::TLB}!cacheState@{cacheState}}
\index{cacheState@{cacheState}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{cacheState}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf cacheState}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a426d36e3a37393acd76bb3f1b14c2be9}
\hypertarget{classSparcISA_1_1TLB_a7d50962c0e8dea3232b1929d48065a3d}{
\index{SparcISA::TLB@{SparcISA::TLB}!cacheValid@{cacheValid}}
\index{cacheValid@{cacheValid}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{cacheValid}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf cacheValid}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a7d50962c0e8dea3232b1929d48065a3d}
\hypertarget{classSparcISA_1_1TLB_a7388d84b8f9e8e4f6c8b3b8723d12b4a}{
\index{SparcISA::TLB@{SparcISA::TLB}!cx\_\-config@{cx\_\-config}}
\index{cx\_\-config@{cx\_\-config}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{cx\_\-config}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf cx\_\-config}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a7388d84b8f9e8e4f6c8b3b8723d12b4a}
\hypertarget{classSparcISA_1_1TLB_a3a0b3ccfe08de626e122e8db329e6cde}{
\index{SparcISA::TLB@{SparcISA::TLB}!cx\_\-tsb\_\-ps0@{cx\_\-tsb\_\-ps0}}
\index{cx\_\-tsb\_\-ps0@{cx\_\-tsb\_\-ps0}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{cx\_\-tsb\_\-ps0}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf cx\_\-tsb\_\-ps0}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a3a0b3ccfe08de626e122e8db329e6cde}
\hypertarget{classSparcISA_1_1TLB_a1551a0ec5dad394042a5f1384b582ff3}{
\index{SparcISA::TLB@{SparcISA::TLB}!cx\_\-tsb\_\-ps1@{cx\_\-tsb\_\-ps1}}
\index{cx\_\-tsb\_\-ps1@{cx\_\-tsb\_\-ps1}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{cx\_\-tsb\_\-ps1}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf cx\_\-tsb\_\-ps1}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a1551a0ec5dad394042a5f1384b582ff3}
\hypertarget{classSparcISA_1_1TLB_aa3dc4ef7249a728d9d8d717427985532}{
\index{SparcISA::TLB@{SparcISA::TLB}!freeList@{freeList}}
\index{freeList@{freeList}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{freeList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf TlbEntry}$\ast$$>$ {\bf freeList}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_aa3dc4ef7249a728d9d8d717427985532}
\hypertarget{classSparcISA_1_1TLB_a943cc0b274cf0720dad94d3469de39c3}{
\index{SparcISA::TLB@{SparcISA::TLB}!lastReplaced@{lastReplaced}}
\index{lastReplaced@{lastReplaced}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{lastReplaced}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf lastReplaced}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a943cc0b274cf0720dad94d3469de39c3}
\hypertarget{classSparcISA_1_1TLB_ac52ea914d25a72d4c33298b8d64603c1}{
\index{SparcISA::TLB@{SparcISA::TLB}!lookupTable@{lookupTable}}
\index{lookupTable@{lookupTable}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{lookupTable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TlbMap} {\bf lookupTable}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_ac52ea914d25a72d4c33298b8d64603c1}
\hypertarget{classSparcISA_1_1TLB_a81cff85924ab4191c84c9818d90eb0a2}{
\index{SparcISA::TLB@{SparcISA::TLB}!sfar@{sfar}}
\index{sfar@{sfar}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{sfar}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf sfar}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a81cff85924ab4191c84c9818d90eb0a2}
\hypertarget{classSparcISA_1_1TLB_aa93fbd043dbccd30bf6f78f83bb088eb}{
\index{SparcISA::TLB@{SparcISA::TLB}!sfsr@{sfsr}}
\index{sfsr@{sfsr}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{sfsr}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf sfsr}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_aa93fbd043dbccd30bf6f78f83bb088eb}
\hypertarget{classSparcISA_1_1TLB_a439227feff9d7f55384e8780cfc2eb82}{
\index{SparcISA::TLB@{SparcISA::TLB}!size@{size}}
\index{size@{size}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{size}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf size}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a439227feff9d7f55384e8780cfc2eb82}
\hypertarget{classSparcISA_1_1TLB_a5d2c5251a072e8aef04cf78fdd6432d7}{
\index{SparcISA::TLB@{SparcISA::TLB}!tag\_\-access@{tag\_\-access}}
\index{tag\_\-access@{tag\_\-access}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{tag\_\-access}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf tag\_\-access}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a5d2c5251a072e8aef04cf78fdd6432d7}
\hypertarget{classSparcISA_1_1TLB_a4651b9a4f432960d77d8e3d30175aab3}{
\index{SparcISA::TLB@{SparcISA::TLB}!tlb@{tlb}}
\index{tlb@{tlb}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{tlb}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TlbEntry}$\ast$ {\bf tlb}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_a4651b9a4f432960d77d8e3d30175aab3}
\hypertarget{classSparcISA_1_1TLB_ad85f3aef77516b13c75af59a1887f8b7}{
\index{SparcISA::TLB@{SparcISA::TLB}!usedEntries@{usedEntries}}
\index{usedEntries@{usedEntries}!SparcISA::TLB@{SparcISA::TLB}}
\subsubsection[{usedEntries}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf usedEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSparcISA_1_1TLB_ad85f3aef77516b13c75af59a1887f8b7}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/sparc/\hyperlink{arch_2sparc_2tlb_8hh}{tlb.hh}\item 
arch/sparc/\hyperlink{arch_2sparc_2tlb_8cc}{tlb.cc}\end{DoxyCompactItemize}
