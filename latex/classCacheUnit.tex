\hypertarget{classCacheUnit}{
\section{クラス CacheUnit}
\label{classCacheUnit}\index{CacheUnit@{CacheUnit}}
}


{\ttfamily \#include $<$cache\_\-unit.hh$>$}CacheUnitに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classCacheUnit}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classCacheUnit_a2afce0a47a93eee73a314d53e4890153}{Command} \{ \par
\hyperlink{classCacheUnit_a2afce0a47a93eee73a314d53e4890153a073e15b510a5603d2befcbe896bd735e}{InitiateReadData}, 
\hyperlink{classCacheUnit_a2afce0a47a93eee73a314d53e4890153a4a1b5faa1ef065d02de5e8c06d8ea9c3}{CompleteReadData}, 
\hyperlink{classCacheUnit_a2afce0a47a93eee73a314d53e4890153aef4b28c5f1a2120dfb93f7613b5e12d7}{InitiateWriteData}, 
\hyperlink{classCacheUnit_a2afce0a47a93eee73a314d53e4890153a7a09943676cd675c7fc3ab19ad0c3d9a}{CompleteWriteData}, 
\par
\hyperlink{classCacheUnit_a2afce0a47a93eee73a314d53e4890153aaf47086f5466118f146d338e86976a99}{InitSecondSplitRead}, 
\hyperlink{classCacheUnit_a2afce0a47a93eee73a314d53e4890153a5a47a9fa564ced7a71887316685bc335}{InitSecondSplitWrite}, 
\hyperlink{classCacheUnit_a2afce0a47a93eee73a314d53e4890153ac69978bc7a301e20e323e43b35b3e9f1}{CompleteSecondSplitRead}, 
\hyperlink{classCacheUnit_a2afce0a47a93eee73a314d53e4890153a67738c183f321a947b53768e01b87a2c}{CompleteSecondSplitWrite}
 \}
\item 
typedef \hyperlink{classRefCountingPtr}{ThePipeline::DynInstPtr} \hyperlink{classCacheUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{DynInstPtr}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classCacheUnit_a24b18d6f820e0babe90abbfc838fc61c}{CacheUnit} (std::string res\_\-name, int res\_\-id, int res\_\-width, \hyperlink{classCycles}{Cycles} res\_\-latency, \hyperlink{classInOrderCPU}{InOrderCPU} $\ast$\_\-cpu, \hyperlink{namespaceThePipeline_ab62ca16eeca26566ad2422b5df4943ce}{ThePipeline::Params} $\ast$params)
\item 
void \hyperlink{classCacheUnit_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
\hyperlink{classResourceRequest}{ResourceRequest} $\ast$ \hyperlink{classCacheUnit_aae5ce84f94a1057d7f60172daf5d731d}{getRequest} (\hyperlink{classRefCountingPtr}{DynInstPtr} \_\-inst, int stage\_\-num, int res\_\-idx, int slot\_\-num, unsigned cmd)
\item 
\hyperlink{classResourceRequest}{ResReqPtr} \hyperlink{classCacheUnit_ae3afc1c63d17a49a6301bd18fca574a0}{findRequest} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
\hyperlink{classResourceRequest}{ResReqPtr} \hyperlink{classCacheUnit_abfbefbe2451158a25d064523dcb3d6bd}{findRequest} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, int idx)
\item 
void \hyperlink{classCacheUnit_a9063fd6f97e36e3565247339ffa3882c}{requestAgain} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, bool \&try\_\-request)
\item 
virtual int \hyperlink{classCacheUnit_ab3ba2ee95c723c8c056db0a1f2a6dfd3}{getSlot} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
virtual void \hyperlink{classCacheUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{execute} (int slot\_\-num)
\item 
virtual void \hyperlink{classCacheUnit_a52235c5e3d912452f254dc45f1496fd2}{squash} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, int stage\_\-num, \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} squash\_\-seq\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classCacheUnit_ae2d6fba25ece343caad6eb029a4a3b5b}{squashDueToMemStall} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, int stage\_\-num, \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} squash\_\-seq\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
virtual void \hyperlink{classCacheUnit_ac2831520eb121be08811b040992f416b}{squashCacheRequest} (\hyperlink{classCacheRequest}{CacheReqPtr} req\_\-ptr)
\item 
virtual void \hyperlink{classCacheUnit_a3dc029c2e87eb911352b82ff15c86236}{processCacheCompletion} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual void \hyperlink{classCacheUnit_aa942d730ea26d41b72db771cc951f51e}{setupMemRequest} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, \hyperlink{classCacheRequest}{CacheReqPtr} cache\_\-req, int acc\_\-size, int flags)
\item 
void \hyperlink{classCacheUnit_aea41ebe99227291877a80081e9b47822}{finishCacheUnitReq} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, \hyperlink{classCacheRequest}{CacheRequest} $\ast$cache\_\-req)
\item 
void \hyperlink{classCacheUnit_ad661f2bbc47ffa00d06636041132af20}{buildDataPacket} (\hyperlink{classCacheRequest}{CacheRequest} $\ast$cache\_\-req)
\item 
bool \hyperlink{classCacheUnit_a251d965e889d9bfeeb0f36bc4411d86f}{processSquash} (\hyperlink{classCacheReqPacket}{CacheReqPacket} $\ast$cache\_\-pkt)
\item 
void \hyperlink{classCacheUnit_abf76d6d245f7d3b17d26ea8dcc0cf36f}{trap} (\hyperlink{classRefCountingPtr}{Fault} fault, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid, \hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
void \hyperlink{classCacheUnit_a29cb5a4f98063ce6e9210eacbdb35298}{recvRetry} ()
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classCacheUnit_ac48fe45ef23fddfa02b5136cda4c060e}{read} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, uint8\_\-t $\ast$data, unsigned size, unsigned flags)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classCacheUnit_abd0bcff6bbdb03d0ad191f96774e8a8b}{write} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, uint8\_\-t $\ast$data, unsigned size, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr, unsigned flags, uint64\_\-t $\ast$res)
\item 
void \hyperlink{classCacheUnit_a88205381d7b3d93f930cac7bacc96022}{doTLBAccess} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, \hyperlink{classCacheRequest}{CacheReqPtr} cache\_\-req, int acc\_\-size, int flags, TheISA::TLB::Mode tlb\_\-mode)
\item 
void \hyperlink{classCacheUnit_afc4f09d8e36072c3a3c361f2edf108b4}{doCacheAccess} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, uint64\_\-t $\ast$write\_\-result=NULL, \hyperlink{classCacheRequest}{CacheReqPtr} split\_\-req=NULL)
\item 
uint64\_\-t \hyperlink{classCacheUnit_a1325b5bcdbbf4f0ba799cdda17265b72}{getMemData} (\hyperlink{classPacket}{Packet} $\ast$packet)
\item 
void \hyperlink{classCacheUnit_a4244e66bc15f13c2dbec20ca5fcea3d4}{setAddrDependency} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
virtual void \hyperlink{classCacheUnit_a8a894d91761439227fd27d91a318c31f}{removeAddrDependency} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classCacheUnit_a6a734ac8ee8c7fbe0df3fed5826a52ef}{cacheBlockAlign} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr)
\item 
TheISA::TLB $\ast$ \hyperlink{classCacheUnit_a3cf8b27760278d20d4aa9463f52a2d95}{tlb} ()
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classCacheUnit_a9d95d13b55fcaa47810d188d54903caf}{cacheBlkSize}
\item 
int \hyperlink{classCacheUnit_a4abab6f8643f5958a53eec1355be3ebd}{cacheBlkMask}
\item 
bool \hyperlink{classCacheUnit_a1e5ca2b940e91b19e93867cc549fe65d}{tlbBlocked} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classCacheUnit_a26ded431132c6ee52a8b8bdc8ddd837c}{tlbBlockSeqNum} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
TheISA::TLB $\ast$ \hyperlink{classCacheUnit_a5aa23855b427a009f3334c95a146084b}{\_\-tlb}
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMasterPort}{MasterPort} $\ast$ \hyperlink{classCacheUnit_a6acbf550d7553b77d4e6f42d91133da6}{cachePort}
\item 
bool \hyperlink{classCacheUnit_abe897aa45cc14999423020f95746328a}{cachePortBlocked}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} $>$ \hyperlink{classCacheUnit_a66e9796fd56a3a307b1095ff8da5a4c8}{addrList} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
m5::hash\_\-map$<$ \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr}, \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} $>$ \hyperlink{classCacheUnit_a9748daf7b829518c81be2287ecbc032d}{addrMap} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classCacheUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{
\index{CacheUnit@{CacheUnit}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!CacheUnit@{CacheUnit}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf ThePipeline::DynInstPtr} {\bf DynInstPtr}}}
\label{classCacheUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}


\hyperlink{classResource_af9d0c8a46736ba6aa2d8bb94da1a5e73}{Resource}を再定義しています。

\hyperlink{classFetchUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{FetchUnit}で再定義されています。

\subsection{列挙型}
\hypertarget{classCacheUnit_a2afce0a47a93eee73a314d53e4890153}{
\index{CacheUnit@{CacheUnit}!Command@{Command}}
\index{Command@{Command}!CacheUnit@{CacheUnit}}
\subsubsection[{Command}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Command}}}
\label{classCacheUnit_a2afce0a47a93eee73a314d53e4890153}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{InitiateReadData@{InitiateReadData}!CacheUnit@{CacheUnit}}\index{CacheUnit@{CacheUnit}!InitiateReadData@{InitiateReadData}}\item[{\em 
\hypertarget{classCacheUnit_a2afce0a47a93eee73a314d53e4890153a073e15b510a5603d2befcbe896bd735e}{
InitiateReadData}
\label{classCacheUnit_a2afce0a47a93eee73a314d53e4890153a073e15b510a5603d2befcbe896bd735e}
}]\index{CompleteReadData@{CompleteReadData}!CacheUnit@{CacheUnit}}\index{CacheUnit@{CacheUnit}!CompleteReadData@{CompleteReadData}}\item[{\em 
\hypertarget{classCacheUnit_a2afce0a47a93eee73a314d53e4890153a4a1b5faa1ef065d02de5e8c06d8ea9c3}{
CompleteReadData}
\label{classCacheUnit_a2afce0a47a93eee73a314d53e4890153a4a1b5faa1ef065d02de5e8c06d8ea9c3}
}]\index{InitiateWriteData@{InitiateWriteData}!CacheUnit@{CacheUnit}}\index{CacheUnit@{CacheUnit}!InitiateWriteData@{InitiateWriteData}}\item[{\em 
\hypertarget{classCacheUnit_a2afce0a47a93eee73a314d53e4890153aef4b28c5f1a2120dfb93f7613b5e12d7}{
InitiateWriteData}
\label{classCacheUnit_a2afce0a47a93eee73a314d53e4890153aef4b28c5f1a2120dfb93f7613b5e12d7}
}]\index{CompleteWriteData@{CompleteWriteData}!CacheUnit@{CacheUnit}}\index{CacheUnit@{CacheUnit}!CompleteWriteData@{CompleteWriteData}}\item[{\em 
\hypertarget{classCacheUnit_a2afce0a47a93eee73a314d53e4890153a7a09943676cd675c7fc3ab19ad0c3d9a}{
CompleteWriteData}
\label{classCacheUnit_a2afce0a47a93eee73a314d53e4890153a7a09943676cd675c7fc3ab19ad0c3d9a}
}]\index{InitSecondSplitRead@{InitSecondSplitRead}!CacheUnit@{CacheUnit}}\index{CacheUnit@{CacheUnit}!InitSecondSplitRead@{InitSecondSplitRead}}\item[{\em 
\hypertarget{classCacheUnit_a2afce0a47a93eee73a314d53e4890153aaf47086f5466118f146d338e86976a99}{
InitSecondSplitRead}
\label{classCacheUnit_a2afce0a47a93eee73a314d53e4890153aaf47086f5466118f146d338e86976a99}
}]\index{InitSecondSplitWrite@{InitSecondSplitWrite}!CacheUnit@{CacheUnit}}\index{CacheUnit@{CacheUnit}!InitSecondSplitWrite@{InitSecondSplitWrite}}\item[{\em 
\hypertarget{classCacheUnit_a2afce0a47a93eee73a314d53e4890153a5a47a9fa564ced7a71887316685bc335}{
InitSecondSplitWrite}
\label{classCacheUnit_a2afce0a47a93eee73a314d53e4890153a5a47a9fa564ced7a71887316685bc335}
}]\index{CompleteSecondSplitRead@{CompleteSecondSplitRead}!CacheUnit@{CacheUnit}}\index{CacheUnit@{CacheUnit}!CompleteSecondSplitRead@{CompleteSecondSplitRead}}\item[{\em 
\hypertarget{classCacheUnit_a2afce0a47a93eee73a314d53e4890153ac69978bc7a301e20e323e43b35b3e9f1}{
CompleteSecondSplitRead}
\label{classCacheUnit_a2afce0a47a93eee73a314d53e4890153ac69978bc7a301e20e323e43b35b3e9f1}
}]\index{CompleteSecondSplitWrite@{CompleteSecondSplitWrite}!CacheUnit@{CacheUnit}}\index{CacheUnit@{CacheUnit}!CompleteSecondSplitWrite@{CompleteSecondSplitWrite}}\item[{\em 
\hypertarget{classCacheUnit_a2afce0a47a93eee73a314d53e4890153a67738c183f321a947b53768e01b87a2c}{
CompleteSecondSplitWrite}
\label{classCacheUnit_a2afce0a47a93eee73a314d53e4890153a67738c183f321a947b53768e01b87a2c}
}]\end{description}
\end{Desc}



\hyperlink{classFetchUnit_a2afce0a47a93eee73a314d53e4890153}{FetchUnit}で再定義されています。


\begin{DoxyCode}
64                  {
65         InitiateReadData,
66         CompleteReadData,
67         InitiateWriteData,
68         CompleteWriteData,
69         InitSecondSplitRead,
70         InitSecondSplitWrite,
71         CompleteSecondSplitRead,
72         CompleteSecondSplitWrite
73     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classCacheUnit_a24b18d6f820e0babe90abbfc838fc61c}{
\index{CacheUnit@{CacheUnit}!CacheUnit@{CacheUnit}}
\index{CacheUnit@{CacheUnit}!CacheUnit@{CacheUnit}}
\subsubsection[{CacheUnit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CacheUnit} (std::string {\em res\_\-name}, \/  int {\em res\_\-id}, \/  int {\em res\_\-width}, \/  {\bf Cycles} {\em res\_\-latency}, \/  {\bf InOrderCPU} $\ast$ {\em \_\-cpu}, \/  {\bf ThePipeline::Params} $\ast$ {\em params})}}
\label{classCacheUnit_a24b18d6f820e0babe90abbfc838fc61c}


\subsection{関数}
\hypertarget{classCacheUnit_ad661f2bbc47ffa00d06636041132af20}{
\index{CacheUnit@{CacheUnit}!buildDataPacket@{buildDataPacket}}
\index{buildDataPacket@{buildDataPacket}!CacheUnit@{CacheUnit}}
\subsubsection[{buildDataPacket}]{\setlength{\rightskip}{0pt plus 5cm}void buildDataPacket ({\bf CacheRequest} $\ast$ {\em cache\_\-req})}}
\label{classCacheUnit_ad661f2bbc47ffa00d06636041132af20}



\begin{DoxyCode}
816 {
817     // Check for LL/SC and if so change command
818     if (cache_req->memReq->isLLSC() && cache_req->pktCmd == MemCmd::ReadReq) {
819         cache_req->pktCmd = MemCmd::LoadLockedReq;
820     }
821 
822     if (cache_req->pktCmd == MemCmd::WriteReq) {
823         cache_req->pktCmd =
824             cache_req->memReq->isSwap() ? MemCmd::SwapReq :
825             (cache_req->memReq->isLLSC() ? MemCmd::StoreCondReq 
826              : MemCmd::WriteReq);
827     }
828 
829     cache_req->dataPkt = new CacheReqPacket(cache_req,
830                                             cache_req->pktCmd,
831                                             cache_req->instIdx);
832     DPRINTF(InOrderCachePort, "[slot:%i]: Slot marked for %x\n",
833             cache_req->getSlot(),
834             cache_req->dataPkt->getAddr());
835 
836     cache_req->dataPkt->hasSlot = true;
837     cache_req->dataPkt->dataStatic(cache_req->reqData);
838 }
\end{DoxyCode}
\hypertarget{classCacheUnit_a6a734ac8ee8c7fbe0df3fed5826a52ef}{
\index{CacheUnit@{CacheUnit}!cacheBlockAlign@{cacheBlockAlign}}
\index{cacheBlockAlign@{cacheBlockAlign}!CacheUnit@{CacheUnit}}
\subsubsection[{cacheBlockAlign}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} cacheBlockAlign ({\bf Addr} {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCacheUnit_a6a734ac8ee8c7fbe0df3fed5826a52ef}
Align a PC to the start of the \hyperlink{classCache}{Cache} block. 


\begin{DoxyCode}
164     {
165         return (addr & ~(cacheBlkMask));
166     }
\end{DoxyCode}
\hypertarget{classCacheUnit_afc4f09d8e36072c3a3c361f2edf108b4}{
\index{CacheUnit@{CacheUnit}!doCacheAccess@{doCacheAccess}}
\index{doCacheAccess@{doCacheAccess}!CacheUnit@{CacheUnit}}
\subsubsection[{doCacheAccess}]{\setlength{\rightskip}{0pt plus 5cm}void doCacheAccess ({\bf DynInstPtr} {\em inst}, \/  uint64\_\-t $\ast$ {\em write\_\-result} = {\ttfamily NULL}, \/  {\bf CacheReqPtr} {\em split\_\-req} = {\ttfamily NULL})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCacheUnit_afc4f09d8e36072c3a3c361f2edf108b4}
Read/Write on behalf of an instruction. curResSlot needs to be a valid value in instruction. 

\hyperlink{classResource_aa874bbb279acf67627511df8f4c3dce5}{Resource}を再定義しています。


\begin{DoxyCode}
843 {
844     Fault fault = NoFault;
845 #if TRACING_ON
846     ThreadID tid = inst->readTid();
847 #endif
848     bool do_access = true;  // flag to suppress cache access
849 
850     // Special Handling if this is a split request
851     CacheReqPtr cache_req;
852     if (split_req == NULL)
853         cache_req = dynamic_cast<CacheReqPtr>(reqs[inst->getCurResSlot()]);
854     else {
855         cache_req = split_req;
856         assert(0);
857     }
858 
859     // Make a new packet inside the CacheRequest object
860     assert(cache_req);
861     buildDataPacket(cache_req);
862 
863     // Special Handling for LL/SC or Compare/Swap
864      bool is_write = cache_req->dataPkt->isWrite();
865      RequestPtr mem_req = cache_req->dataPkt->req;
866      if (is_write) {
867          DPRINTF(InOrderCachePort,
868                  "[tid:%u]: [sn:%i]: Storing data: %s\n",
869                  tid, inst->seqNum,
870                  printMemData(cache_req->dataPkt->getPtr<uint8_t>(),
871                               cache_req->dataPkt->getSize()));
872 
873         if (mem_req->isCondSwap()) {
874              assert(write_res);
875              cache_req->memReq->setExtraData(*write_res);
876          }
877         if (mem_req->isLLSC()) {
878             assert(cache_req->inst->isStoreConditional());
879             DPRINTF(InOrderCachePort, "Evaluating Store Conditional access\n");
880             do_access = TheISA::handleLockedWrite(inst.get(), mem_req, 
      cacheBlkSize);
881         }
882      }
883 
884     // Finally, go ahead and make the access if we can...
885     DPRINTF(InOrderCachePort,
886             "[tid:%i] [sn:%i] attempting to access cache for addr %08p\n",
887             tid, inst->seqNum, cache_req->dataPkt->getAddr());
888 
889     if (do_access) {
890         if (!cachePort->sendTimingReq(cache_req->dataPkt)) {
891             DPRINTF(InOrderCachePort,
892                     "[tid:%i] [sn:%i] cannot access cache, because port "
893                     "is blocked. now waiting to retry request\n", tid, 
894                     inst->seqNum);
895             delete cache_req->dataPkt;
896             cache_req->dataPkt = NULL;
897 
898             delete cache_req->memReq;
899             cache_req->memReq = NULL;
900 
901             cache_req->done(false);
902             cachePortBlocked = true;
903         } else {
904             DPRINTF(InOrderCachePort,
905                     "[tid:%i] [sn:%i] is now waiting for cache response\n",
906                     tid, inst->seqNum);
907             cache_req->setCompleted();
908             cache_req->setMemAccPending();
909             cachePortBlocked = false;
910         }
911     } else if (mem_req->isLLSC()){
912         // Store-Conditional instructions complete even if they "failed"
913         assert(cache_req->inst->isStoreConditional());
914         cache_req->setCompleted(true);
915 
916         DPRINTF(LLSC,
917                 "[tid:%i]: T%i Ignoring Failed Store Conditional Access\n",
918                 tid, tid);
919 
920         processCacheCompletion(cache_req->dataPkt);
921     } else {
922         delete cache_req->dataPkt;
923         cache_req->dataPkt = NULL;
924 
925         delete cache_req->memReq;
926         cache_req->memReq = NULL;
927 
928         // Make cache request again since access due to
929         // inability to access
930         DPRINTF(InOrderStall, "STALL: \n");
931         cache_req->done(false);
932     }
933 
934 }
\end{DoxyCode}
\hypertarget{classCacheUnit_a88205381d7b3d93f930cac7bacc96022}{
\index{CacheUnit@{CacheUnit}!doTLBAccess@{doTLBAccess}}
\index{doTLBAccess@{doTLBAccess}!CacheUnit@{CacheUnit}}
\subsubsection[{doTLBAccess}]{\setlength{\rightskip}{0pt plus 5cm}void doTLBAccess ({\bf DynInstPtr} {\em inst}, \/  {\bf CacheReqPtr} {\em cache\_\-req}, \/  int {\em acc\_\-size}, \/  int {\em flags}, \/  TheISA::TLB::Mode {\em tlb\_\-mode})}}
\label{classCacheUnit_a88205381d7b3d93f930cac7bacc96022}



\begin{DoxyCode}
369 {
370     ThreadID tid = inst->readTid();
371 
372     setupMemRequest(inst, cache_req, acc_size, flags);
373 
374     //@todo: HACK: the DTB expects the correct PC in the ThreadContext
375     //       but how if the memory accesses are speculative? Shouldn't
376     //       we send along the requestor's PC to the translate functions?
377     ThreadContext *tc = cpu->thread[tid]->getTC();
378     PCState old_pc = tc->pcState();
379     tc->pcState() = inst->pcState();
380 
381     inst->fault =
382         _tlb->translateAtomic(cache_req->memReq, tc, tlb_mode);
383     tc->pcState() = old_pc;
384 
385     if (inst->fault != NoFault) {
386         DPRINTF(InOrderTLB, "[tid:%i]: %s encountered while translating "
387                 "addr:%08p for [sn:%i].\n", tid, inst->fault->name(),
388                 cache_req->memReq->getVaddr(), inst->seqNum);
389 
390         tlbBlocked[tid] = true;
391         tlbBlockSeqNum[tid] = inst->seqNum;
392 
393         // Make sure nothing gets executed until after this faulting
394         // instruction gets handled.
395         inst->setSerializeAfter();
396 
397         // Mark it as complete so it can pass through next stage.
398         // Fault Handling will happen at commit/graduation
399         cache_req->setCompleted();
400     } else {
401         DPRINTF(InOrderTLB, "[tid:%i]: [sn:%i] virt. addr %08p translated "
402                 "to phys. addr:%08p.\n", tid, inst->seqNum,
403                 cache_req->memReq->getVaddr(),
404                 cache_req->memReq->getPaddr());
405     }
406 }
\end{DoxyCode}
\hypertarget{classCacheUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{
\index{CacheUnit@{CacheUnit}!execute@{execute}}
\index{execute@{execute}!CacheUnit@{CacheUnit}}
\subsubsection[{execute}]{\setlength{\rightskip}{0pt plus 5cm}void execute (int {\em slot\_\-num})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCacheUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}
Executes one of the commands from the \char`\"{}Command\char`\"{} enum 

\hyperlink{classResource_a39af49c5568d1db3f53c12d7d6914c32}{Resource}を再定義しています。

\hyperlink{classFetchUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{FetchUnit}で再定義されています。


\begin{DoxyCode}
624 {
625     CacheReqPtr cache_req = dynamic_cast<CacheReqPtr>(reqs[slot_num]);
626     assert(cache_req);
627 
628     if (cachePortBlocked &&
629         (cache_req->cmd == InitiateReadData ||
630          cache_req->cmd == InitiateWriteData ||
631          cache_req->cmd == InitSecondSplitRead ||
632          cache_req->cmd == InitSecondSplitWrite)) {
633         DPRINTF(InOrderCachePort, "Cache Port Blocked. Cannot Access\n");
634         cache_req->done(false);
635         return;
636     }
637 
638     DynInstPtr inst = cache_req->inst;
639     if (inst->fault != NoFault) {
640         DPRINTF(InOrderCachePort,
641                 "[tid:%i]: [sn:%i]: Detected %s fault @ %x. Forwarding to "
642                 "next stage.\n", inst->readTid(), inst->seqNum, inst->fault->name
      (),
643                 inst->getMemAddr());
644         finishCacheUnitReq(inst, cache_req);
645         return;
646     }
647 
648     if (inst->isSquashed()) {
649         DPRINTF(InOrderCachePort,
650                 "[tid:%i]: [sn:%i]: Detected squashed instruction "
651                 "next stage.\n", inst->readTid(), inst->seqNum);
652         finishCacheUnitReq(inst, cache_req);
653         return;
654     }
655 
656 #if TRACING_ON
657     ThreadID tid = inst->readTid();
658     std::string acc_type = "write";
659 #endif
660 
661     switch (cache_req->cmd)
662     {
663 
664       case InitiateReadData:
665 #if TRACING_ON
666         acc_type = "read";
667 #endif        
668       case InitiateWriteData:
669         if (cachePortBlocked) {
670             DPRINTF(InOrderCachePort, "Cache Port Blocked. Cannot Access\n");
671             cache_req->done(false);
672             return;
673         }
674 
675         DPRINTF(InOrderCachePort,
676                 "[tid:%u]: [sn:%i] Initiating data %s access to %s for "
677                 "addr. %08p\n", tid, inst->seqNum, acc_type, name(),
678                 cache_req->inst->getMemAddr());
679 
680         inst->setCurResSlot(slot_num);
681 
682         if (inst->isDataPrefetch() || inst->isInstPrefetch()) {
683             inst->execute();
684         } else {
685             inst->initiateAcc();
686         }
687         
688         break;
689 
690       case InitSecondSplitRead:
691         DPRINTF(InOrderCachePort,
692                 "[tid:%u]: [sn:%i] Initiating split data read access to %s "
693                 "for addr. %08p\n", tid, inst->seqNum, name(),
694                 cache_req->inst->split2ndAddr);
695         inst->split2ndAccess = true;
696         assert(inst->split2ndAddr != 0);
697         read(inst, inst->split2ndAddr, &inst->split2ndData,
698              inst->totalSize, inst->split2ndFlags);
699         break;
700 
701       case InitSecondSplitWrite:
702         DPRINTF(InOrderCachePort,
703                 "[tid:%u]: [sn:%i] Initiating split data write access to %s "
704                 "for addr. %08p\n", tid, inst->seqNum, name(),
705                 cache_req->inst->getMemAddr());
706 
707         inst->split2ndAccess = true;
708         assert(inst->split2ndAddr != 0);
709         write(inst, &inst->split2ndData, inst->totalSize,
710               inst->split2ndAddr, inst->split2ndFlags, NULL);
711         break;
712 
713       case CompleteReadData:
714         DPRINTF(InOrderCachePort,
715                 "[tid:%i]: [sn:%i]: Trying to Complete Data Read Access\n",
716                 tid, inst->seqNum);
717 
718 
719         //@todo: timing translations need to check here...
720         assert(!inst->isInstPrefetch() && "Can't Handle Inst. Prefecthes");
721         if (cache_req->isMemAccComplete() || inst->isDataPrefetch()) {
722             finishCacheUnitReq(inst, cache_req);
723         } else {
724             DPRINTF(InOrderStall, "STALL: [tid:%i]: Data miss from %08p\n",
725                     tid, cache_req->inst->getMemAddr());
726             cache_req->setCompleted(false);
727             cache_req->setMemStall(true);            
728         }
729         break;
730 
731       case CompleteWriteData:
732         {
733             DPRINTF(InOrderCachePort,
734                     "[tid:%i]: [sn:%i]: Trying to Complete Data Write Access\n",
735                     tid, inst->seqNum);
736 
737 
738             //@todo: check that timing translation is finished here
739             RequestPtr mem_req = cache_req->memReq;
740             if (mem_req->isCondSwap() || mem_req->isLLSC() || mem_req->isSwap()) 
      {
741                 DPRINTF(InOrderCachePort, "Detected Conditional Store Inst.\n");
742 
743                 if (!cache_req->isMemAccComplete()) {
744                     DPRINTF(InOrderStall, "STALL: [tid:%i]: Data miss from %08p\n
      ",
745                             tid, cache_req->inst->getMemAddr());
746                     cache_req->setCompleted(false);
747                     cache_req->setMemStall(true);
748                     return;
749                 } else {
750                     DPRINTF(InOrderStall, "Mem Acc Completed\n");
751                 }
752             }
753 
754             if (cache_req->isMemAccPending()) {
755                 DPRINTF(InOrderCachePort, "Store Instruction Pending Completion.\
      n");
756                 cache_req->dataPkt->reqData = cache_req->reqData;
757                 cache_req->dataPkt->memReq = cache_req->memReq;
758             } else
759                 DPRINTF(InOrderCachePort, "Store Instruction Finished Completion.
      \n");
760 
761             //@todo: if split inst save data
762             finishCacheUnitReq(inst, cache_req);
763         }
764         break;
765 
766       case CompleteSecondSplitRead:
767         DPRINTF(InOrderCachePort,
768                 "[tid:%i]: [sn:%i]: Trying to Complete Split Data Read "
769                 "Access\n", tid, inst->seqNum);
770 
771         //@todo: check that timing translation is finished here
772         assert(!inst->isInstPrefetch() && "Can't Handle Inst. Prefecthes");
773         if (cache_req->isMemAccComplete() || inst->isDataPrefetch()) {
774             finishCacheUnitReq(inst, cache_req);
775         } else {
776             DPRINTF(InOrderStall, "STALL: [tid:%i]: Data miss from %08p\n",
777                     tid, cache_req->inst->split2ndAddr);
778             cache_req->setCompleted(false);
779             cache_req->setMemStall(true);            
780         }
781         break;
782 
783       case CompleteSecondSplitWrite:
784         DPRINTF(InOrderCachePort,
785                 "[tid:%i]: [sn:%i]: Trying to Complete Split Data Write "
786                 "Access\n", tid, inst->seqNum);
787         //@todo: illegal to have a unaligned cond.swap or llsc?
788         assert(!cache_req->memReq->isSwap() && !cache_req->memReq->isCondSwap()
789                && !cache_req->memReq->isLLSC());
790 
791         if (cache_req->isMemAccPending()) {
792             cache_req->dataPkt->reqData = cache_req->reqData;
793             cache_req->dataPkt->memReq = cache_req->memReq;
794         }
795 
796         //@todo: check that timing translation is finished here
797         finishCacheUnitReq(inst, cache_req);
798         break;
799         
800       default:
801         fatal("Unrecognized command to %s", resName);
802     }
803 }
\end{DoxyCode}
\hypertarget{classCacheUnit_abfbefbe2451158a25d064523dcb3d6bd}{
\index{CacheUnit@{CacheUnit}!findRequest@{findRequest}}
\index{findRequest@{findRequest}!CacheUnit@{CacheUnit}}
\subsubsection[{findRequest}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ResReqPtr} findRequest ({\bf DynInstPtr} {\em inst}, \/  int {\em idx})}}
\label{classCacheUnit_abfbefbe2451158a25d064523dcb3d6bd}



\begin{DoxyCode}
227 {
228     for (int i = 0; i < width; i++) {
229         CacheRequest* cache_req =
230             dynamic_cast<CacheRequest*>(reqs[i]);
231         assert(cache_req);
232 
233         if (cache_req->valid &&
234             cache_req->getInst() == inst &&
235             cache_req->instIdx == idx) {
236             return cache_req;
237         }
238     }
239 
240     return NULL;
241 }
\end{DoxyCode}
\hypertarget{classCacheUnit_ae3afc1c63d17a49a6301bd18fca574a0}{
\index{CacheUnit@{CacheUnit}!findRequest@{findRequest}}
\index{findRequest@{findRequest}!CacheUnit@{CacheUnit}}
\subsubsection[{findRequest}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ResReqPtr} findRequest ({\bf DynInstPtr} {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCacheUnit_ae3afc1c63d17a49a6301bd18fca574a0}
Find the request that corresponds to this instruction 

\hyperlink{classResource_ae3afc1c63d17a49a6301bd18fca574a0}{Resource}を再定義しています。


\begin{DoxyCode}
209 {
210     for (int i = 0; i < width; i++) {
211         CacheRequest* cache_req =
212             dynamic_cast<CacheRequest*>(reqs[i]);
213         assert(cache_req);
214 
215         if (cache_req->valid &&
216             cache_req->getInst() == inst &&
217             cache_req->instIdx == inst->curSkedEntry->idx) {
218             return cache_req;
219         }
220     }
221 
222     return NULL;
223 }
\end{DoxyCode}
\hypertarget{classCacheUnit_aea41ebe99227291877a80081e9b47822}{
\index{CacheUnit@{CacheUnit}!finishCacheUnitReq@{finishCacheUnitReq}}
\index{finishCacheUnitReq@{finishCacheUnitReq}!CacheUnit@{CacheUnit}}
\subsubsection[{finishCacheUnitReq}]{\setlength{\rightskip}{0pt plus 5cm}void finishCacheUnitReq ({\bf DynInstPtr} {\em inst}, \/  {\bf CacheRequest} $\ast$ {\em cache\_\-req})}}
\label{classCacheUnit_aea41ebe99227291877a80081e9b47822}



\begin{DoxyCode}
807 {
808     //@note: add back in for speculative load/store capability
809     //removeAddrDependency(inst);
810     cache_req->setMemStall(false);
811     cache_req->done();
812 }
\end{DoxyCode}
\hypertarget{classCacheUnit_a1325b5bcdbbf4f0ba799cdda17265b72}{
\index{CacheUnit@{CacheUnit}!getMemData@{getMemData}}
\index{getMemData@{getMemData}!CacheUnit@{CacheUnit}}
\subsubsection[{getMemData}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t getMemData ({\bf Packet} $\ast$ {\em packet})}}
\label{classCacheUnit_a1325b5bcdbbf4f0ba799cdda17265b72}
\hypertarget{classCacheUnit_aae5ce84f94a1057d7f60172daf5d731d}{
\index{CacheUnit@{CacheUnit}!getRequest@{getRequest}}
\index{getRequest@{getRequest}!CacheUnit@{CacheUnit}}
\subsubsection[{getRequest}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ResReqPtr} getRequest ({\bf DynInstPtr} {\em \_\-inst}, \/  int {\em stage\_\-num}, \/  int {\em res\_\-idx}, \/  int {\em slot\_\-num}, \/  unsigned {\em cmd})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCacheUnit_aae5ce84f94a1057d7f60172daf5d731d}
\hyperlink{classRequest}{Request} usage of a resource for this instruction. If this instruction already has made this request to this resource, and that request is uncompleted this function will just return that request 

\hyperlink{classResource_aae5ce84f94a1057d7f60172daf5d731d}{Resource}を再定義しています。

\hyperlink{classFetchUnit_aae5ce84f94a1057d7f60172daf5d731d}{FetchUnit}で再定義されています。


\begin{DoxyCode}
247 {
248     ScheduleEntry* sched_entry = *inst->curSkedEntry;
249     CacheRequest* cache_req = dynamic_cast<CacheRequest*>(reqs[slot_num]);
250 
251     if (!inst->validMemAddr()) {
252         panic("Mem. Addr. must be set before requesting cache access\n");
253     }
254 
255     MemCmd::Command pkt_cmd;
256 
257     switch (sched_entry->cmd)
258     {
259       case InitSecondSplitRead:
260         pkt_cmd = MemCmd::ReadReq;
261 
262         DPRINTF(InOrderCachePort,
263                 "[tid:%i]: Read request from [sn:%i] for addr %08p\n",
264                 inst->readTid(), inst->seqNum, inst->split2ndAddr);
265         break;
266 
267       case InitiateReadData:
268         pkt_cmd = MemCmd::ReadReq;
269 
270         DPRINTF(InOrderCachePort,
271                 "[tid:%i]: Read request from [sn:%i] for addr %08p\n",
272                 inst->readTid(), inst->seqNum, inst->getMemAddr());
273         break;
274 
275       case InitSecondSplitWrite:
276         pkt_cmd = MemCmd::WriteReq;
277 
278         DPRINTF(InOrderCachePort,
279                 "[tid:%i]: Write request from [sn:%i] for addr %08p\n",
280                 inst->readTid(), inst->seqNum, inst->split2ndAddr);
281         break;
282 
283       case InitiateWriteData:
284         pkt_cmd = MemCmd::WriteReq;
285 
286         DPRINTF(InOrderCachePort,
287                 "[tid:%i]: Write request from [sn:%i] for addr %08p\n",
288                 inst->readTid(), inst->seqNum, inst->getMemAddr());
289         break;
290 
291       default:
292         panic("%i: Unexpected request type (%i) to %s", curTick(),
293               sched_entry->cmd, name());
294     }
295 
296     cache_req->setRequest(inst, stage_num, id, slot_num,
297                           sched_entry->cmd, pkt_cmd,
298                           inst->curSkedEntry->idx);
299     return cache_req;
300 }
\end{DoxyCode}
\hypertarget{classCacheUnit_ab3ba2ee95c723c8c056db0a1f2a6dfd3}{
\index{CacheUnit@{CacheUnit}!getSlot@{getSlot}}
\index{getSlot@{getSlot}!CacheUnit@{CacheUnit}}
\subsubsection[{getSlot}]{\setlength{\rightskip}{0pt plus 5cm}int getSlot ({\bf DynInstPtr} {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCacheUnit_ab3ba2ee95c723c8c056db0a1f2a6dfd3}
Get the next available slot in this resource. Instruction is passed so that resources can check the instruction before allocating a slot if necessary. 

\hyperlink{classResource_ab3ba2ee95c723c8c056db0a1f2a6dfd3}{Resource}を再定義しています。


\begin{DoxyCode}
135 {
136     ThreadID tid = inst->readTid();
137     if (tlbBlocked[tid]) {
138         return -1;
139     }
140 
141     // For a Split-Load, the instruction would have processed once already
142     // causing the address to be unset.
143     if (!inst->validMemAddr() && !inst->splitInst) {
144         panic("[tid:%i][sn:%i] Mem. Addr. must be set before requesting "
145               "cache access\n", inst->readTid(), inst->seqNum);
146     }
147 
148     int new_slot = Resource::getSlot(inst);
149     inst->memTime = curTick();
150     //@note: add back in if you want speculative loads/store capability
151     //setAddrDependency(inst);
152     return new_slot;
153 }
\end{DoxyCode}
\hypertarget{classCacheUnit_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{CacheUnit@{CacheUnit}!init@{init}}
\index{init@{init}!CacheUnit@{CacheUnit}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCacheUnit_a02fd73d861ef2e4aabb38c0c9ff82947}
Any extra initiliazation stuff can be set up using this function that should get called before the simulation starts (tick 0) 

\hyperlink{classResource_a02fd73d861ef2e4aabb38c0c9ff82947}{Resource}を再定義しています。


\begin{DoxyCode}
114 {
115     // Get the appropriate port from the CPU based on the resource name.
116     if (id == ICache) {
117         cachePort = &cpu->getInstPort();
118     } else if (id == DCache) {
119         cachePort = &cpu->getDataPort();
120     }
121     assert(cachePort != NULL);
122 
123     for (int i = 0; i < width; i++) {
124         reqs[i] = new CacheRequest(this);
125     }
126 
127     cacheBlkSize = cpu->cacheLineSize();
128     cacheBlkMask = cacheBlkSize  - 1;
129 
130     initSlots();
131 }
\end{DoxyCode}
\hypertarget{classCacheUnit_a3dc029c2e87eb911352b82ff15c86236}{
\index{CacheUnit@{CacheUnit}!processCacheCompletion@{processCacheCompletion}}
\index{processCacheCompletion@{processCacheCompletion}!CacheUnit@{CacheUnit}}
\subsubsection[{processCacheCompletion}]{\setlength{\rightskip}{0pt plus 5cm}void processCacheCompletion ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCacheUnit_a3dc029c2e87eb911352b82ff15c86236}
After memory request is completedd in the cache, then do final processing to complete the request in the CPU. 

\hyperlink{classFetchUnit_a3dc029c2e87eb911352b82ff15c86236}{FetchUnit}で再定義されています。


\begin{DoxyCode}
994 {
995     //@todo: use packet sender state instead of deriving from packet class to
996     //  get special state
997     CacheReqPacket* cache_pkt = dynamic_cast<CacheReqPacket*>(pkt);
998     assert(cache_pkt);
999 
1000     DPRINTF(InOrderCachePort, "Finished request for %x\n", pkt->getAddr());
1001 
1002     if (processSquash(cache_pkt))
1003         return;
1004 
1005     CacheRequest *cache_req = dynamic_cast<CacheReqPtr>(
1006         findRequest(cache_pkt->cacheReq->getInst(), cache_pkt->instIdx));
1007 
1008     if (!cache_req) {
1009         panic("[tid:%u]: [sn:%i]: Can't find slot for cache access to "
1010               "addr. %08p\n", cache_pkt->cacheReq->getInst()->readTid(),
1011               cache_pkt->cacheReq->getInst()->seqNum,
1012               cache_pkt->cacheReq->getInst()->getMemAddr());
1013     }
1014     
1015     assert(cache_req);
1016     assert(cache_req == cache_pkt->cacheReq);
1017 
1018     DPRINTF(InOrderCachePort,
1019             "[tid:%u]: [sn:%i]: [slot:%i] Waking from cache access (vaddr.%08p, p
      addr:%08p)\n",
1020             cache_pkt->cacheReq->getInst()->readTid(),
1021             cache_pkt->cacheReq->getInst()->seqNum,
1022             cache_req->getSlot(),
1023             cache_pkt->req->getVaddr(),
1024             cache_pkt->req->getPaddr());
1025 
1026     // Get resource request info
1027     unsigned stage_num = cache_req->getStageNum();
1028     DynInstPtr inst = cache_req->inst;
1029     ThreadID tid = cache_req->inst->readTid();
1030 
1031     assert(!cache_req->isSquashed());
1032     assert(inst->staticInst && inst->isMemRef());
1033 
1034 
1035     DPRINTF(InOrderCachePort,
1036             "[tid:%u]: [sn:%i]: Processing cache access\n",
1037             tid, inst->seqNum);
1038 
1039     PacketPtr split_pkt = NULL;
1040     if (inst->splitInst) {
1041         inst->splitFinishCnt++;
1042 
1043         if (inst->splitFinishCnt == 2) {
1044             cache_req->memReq->setVirt(0/*inst->tid*/,
1045                                        inst->getMemAddr(),
1046                                        inst->totalSize,
1047                                        0,
1048                                        cpu->dataMasterId(),
1049                                        0);
1050 
1051             split_pkt = new Packet(cache_req->memReq, cache_req->pktCmd);
1052             split_pkt->dataStatic(inst->splitMemData);
1053 
1054             DPRINTF(InOrderCachePort, "Completing Split Access.\n");
1055             inst->completeAcc(split_pkt);
1056         }
1057     } else {
1058         inst->completeAcc(cache_pkt);
1059     }
1060 
1061     inst->setExecuted();
1062 
1063     if (inst->isLoad()) {
1064         assert(cache_pkt->isRead());
1065 
1066         if (cache_pkt->req->isLLSC()) {
1067             DPRINTF(InOrderCachePort,
1068                     "[tid:%u]: Handling Load-Linked for [sn:%u]\n",
1069                     tid, inst->seqNum);
1070             TheISA::handleLockedRead(inst.get(), cache_pkt->req);
1071         }
1072 
1073         DPRINTF(InOrderCachePort,
1074                 "[tid:%u]: [sn:%i]: Bytes loaded were: %s\n",
1075                 tid, inst->seqNum,
1076                 (split_pkt) ? printMemData(split_pkt->getPtr<uint8_t>(),
1077                                            split_pkt->getSize()) :
1078                               printMemData(cache_pkt->getPtr<uint8_t>(),
1079                                            cache_pkt->getSize()));
1080     } else if(inst->isStore()) {
1081         assert(cache_pkt->isWrite());
1082 
1083         DPRINTF(InOrderCachePort,
1084                 "[tid:%u]: [sn:%i]: Bytes stored were: %s\n",
1085                 tid, inst->seqNum,
1086                 (split_pkt) ? printMemData(split_pkt->getPtr<uint8_t>(),
1087                                            split_pkt->getSize()) :
1088                               printMemData(cache_pkt->getPtr<uint8_t>(),
1089                                            cache_pkt->getSize()));
1090     }
1091 
1092 
1093     if (split_pkt) {
1094         delete split_pkt;
1095         split_pkt = NULL;
1096     }
1097 
1098     cache_req->setMemAccPending(false);
1099     cache_req->setMemAccCompleted();
1100 
1101     if (cache_req->isMemStall() &&
1102         cpu->threadModel == InOrderCPU::SwitchOnCacheMiss) {
1103         DPRINTF(InOrderCachePort, "[tid:%u] Waking up from Cache Miss.\n",
1104                 tid);
1105             
1106         cpu->activateContext(tid);
1107             
1108         DPRINTF(ThreadModel, "Activating [tid:%i] after return from cache"
1109                 "miss.\n", tid);
1110     }
1111         
1112     // Wake up the CPU (if it went to sleep and was waiting on this
1113     // completion event).
1114     cpu->wakeCPU();
1115 
1116     DPRINTF(Activity, "[tid:%u] Activating %s due to cache completion\n",
1117             tid, cpu->pipelineStage[stage_num]->name());
1118 
1119     cpu->switchToActive(stage_num);
1120 }
\end{DoxyCode}
\hypertarget{classCacheUnit_a251d965e889d9bfeeb0f36bc4411d86f}{
\index{CacheUnit@{CacheUnit}!processSquash@{processSquash}}
\index{processSquash@{processSquash}!CacheUnit@{CacheUnit}}
\subsubsection[{processSquash}]{\setlength{\rightskip}{0pt plus 5cm}bool processSquash ({\bf CacheReqPacket} $\ast$ {\em cache\_\-pkt})}}
\label{classCacheUnit_a251d965e889d9bfeeb0f36bc4411d86f}



\begin{DoxyCode}
938 {
939     // The resource may no longer be actively servicing this
940     // packet. Scenarios like a store that has been sent to the
941     // memory system or access that's been squashed. If that's
942     // the case, we can't access the request slot because it
943     // will be either invalid or servicing another request.
944     if (!cache_pkt->hasSlot) {
945         DPRINTF(InOrderCachePort,
946                 "%x does not have a slot in unit, ignoring.\n",
947                 cache_pkt->getAddr());
948 
949         if (cache_pkt->reqData) {
950             delete [] cache_pkt->reqData;
951             cache_pkt->reqData = NULL;
952         }
953 
954         if (cache_pkt->memReq) {
955             delete cache_pkt->memReq;
956             cache_pkt->memReq = NULL;
957         }
958 
959         delete cache_pkt;
960         cache_pkt = NULL;
961         cpu->wakeCPU();
962         return true;
963     } else {
964         DPRINTF(InOrderCachePort, "%x has slot %i\n",
965                 cache_pkt->getAddr(), cache_pkt->cacheReq->getSlot());
966     }
967 
968 
969     // It's possible that the request is squashed but the
970     // packet is still acknowledged by the resource. Squashes
971     // should happen at the end of the cycles and trigger the
972     // code above, but if not, this would handle any timing
973     // variations due to diff. user parameters.
974     if (cache_pkt->cacheReq->isSquashed()) {
975         DPRINTF(InOrderCachePort,
976                 "Ignoring completion of squashed access, [tid:%i] [sn:%i]\n",
977                 cache_pkt->cacheReq->getInst()->readTid(),
978                 cache_pkt->cacheReq->getInst()->seqNum);
979 
980         cache_pkt->cacheReq->setMemAccPending(false);
981         cache_pkt->cacheReq->freeSlot();
982         delete cache_pkt;
983         cache_pkt = NULL;
984         cpu->wakeCPU();
985         return true;
986     }
987 
988 
989     return false;
990 }
\end{DoxyCode}
\hypertarget{classCacheUnit_ac48fe45ef23fddfa02b5136cda4c060e}{
\index{CacheUnit@{CacheUnit}!read@{read}}
\index{read@{read}!CacheUnit@{CacheUnit}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} read ({\bf DynInstPtr} {\em inst}, \/  {\bf Addr} {\em addr}, \/  uint8\_\-t $\ast$ {\em data}, \/  unsigned {\em size}, \/  unsigned {\em flags})}}
\label{classCacheUnit_ac48fe45ef23fddfa02b5136cda4c060e}



\begin{DoxyCode}
417 {
418     CacheReqPtr cache_req = dynamic_cast<CacheReqPtr>(findRequest(inst));
419     assert(cache_req && "Can't Find Instruction for Read!");
420 
421     // The block size of our peer
422     unsigned blockSize = cacheBlkSize;
423 
424     //The size of the data we're trying to read.
425     int fullSize = size;
426     inst->totalSize = size;
427 
428     if (inst->traceData) {
429         inst->traceData->setAddr(addr);
430     }
431 
432     if (inst->split2ndAccess) {     
433         size = inst->split2ndSize;
434         cache_req->splitAccess = true;        
435         cache_req->split2ndAccess = true;
436         
437         DPRINTF(InOrderCachePort, "[sn:%i] Split Read Access (2 of 2) for "
438                 "(%#x, %#x).\n", inst->seqNum, inst->getMemAddr(),
439                 inst->split2ndAddr);
440     }  
441     
442 
443     //The address of the second part of this access if it needs to be split
444     //across a cache line boundary.
445     Addr secondAddr = roundDown(addr + size - 1, blockSize);
446 
447     
448     if (secondAddr > addr && !inst->split2ndAccess) {
449 
450         if (!inst->splitInst) {
451             DPRINTF(InOrderCachePort, "%i: sn[%i] Split Read Access (1 of 2) for 
      "
452                     "(%#x, %#x).\n", curTick(), inst->seqNum, addr, secondAddr);
453 
454             unsigned stage_num = cache_req->getStageNum();
455             unsigned cmd = inst->curSkedEntry->cmd;
456 
457             // 1. Make A New Inst. Schedule w/Split Read/Complete Entered on
458             // the schedule
459             // ==============================
460             // 2. Reassign curSkedPtr to current command (InitiateRead) on new
461             // schedule
462             // ==============================
463             inst->splitInst = true;
464             inst->setBackSked(cpu->createBackEndSked(inst));
465             inst->curSkedEntry = inst->backSked->find(stage_num, cmd);
466         } else {
467             DPRINTF(InOrderCachePort, "[tid:%i] [sn:%i] Retrying Split Read "
468                     "Access (1 of 2) for (%#x, %#x).\n", inst->readTid(),
469                     inst->seqNum, addr, secondAddr);
470         }
471 
472         // Save All "Total" Split Information
473         // ==============================
474         inst->splitMemData = new uint8_t[size];
475 
476         // Split Information for First Access
477         // ==============================
478         size = secondAddr - addr;
479         cache_req->splitAccess = true;
480 
481         // Split Information for Second Access
482         // ==============================
483         inst->split2ndSize = addr + fullSize - secondAddr;
484         inst->split2ndAddr = secondAddr;            
485         inst->split2ndDataPtr = inst->splitMemData + size;
486         inst->split2ndFlags = flags;        
487     }
488     
489     doTLBAccess(inst, cache_req, size, flags, TheISA::TLB::Read);
490 
491     if (inst->fault == NoFault) {
492         if (!cache_req->splitAccess) {            
493             cache_req->reqData = new uint8_t[size];
494             doCacheAccess(inst, NULL);
495         } else {
496             if (!inst->split2ndAccess) {                
497                 cache_req->reqData = inst->splitMemData;
498             } else {
499                 cache_req->reqData = inst->split2ndDataPtr;                
500             }
501             
502             doCacheAccess(inst, NULL, cache_req);            
503         }        
504     }
505 
506     return inst->fault;
507 }
\end{DoxyCode}
\hypertarget{classCacheUnit_a29cb5a4f98063ce6e9210eacbdb35298}{
\index{CacheUnit@{CacheUnit}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!CacheUnit@{CacheUnit}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetry ()}}
\label{classCacheUnit_a29cb5a4f98063ce6e9210eacbdb35298}



\begin{DoxyCode}
1124 {
1125     DPRINTF(InOrderCachePort, "Unblocking Cache Port. \n");
1126     
1127     assert(cachePortBlocked);
1128 
1129     // Clear the cache port for use again
1130     cachePortBlocked = false;
1131 
1132     cpu->wakeCPU();
1133 }
\end{DoxyCode}
\hypertarget{classCacheUnit_a8a894d91761439227fd27d91a318c31f}{
\index{CacheUnit@{CacheUnit}!removeAddrDependency@{removeAddrDependency}}
\index{removeAddrDependency@{removeAddrDependency}!CacheUnit@{CacheUnit}}
\subsubsection[{removeAddrDependency}]{\setlength{\rightskip}{0pt plus 5cm}void removeAddrDependency ({\bf DynInstPtr} {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCacheUnit_a8a894d91761439227fd27d91a318c31f}


\hyperlink{classFetchUnit_a8a894d91761439227fd27d91a318c31f}{FetchUnit}で再定義されています。


\begin{DoxyCode}
180 {
181     ThreadID tid = inst->readTid();
182 
183     Addr mem_addr = inst->getMemAddr();
184     
185     inst->unsetMemAddr();
186 
187     // Erase from Address List
188     std::list<Addr>::iterator list_it = find(addrList[tid].begin(),
189                                           addrList[tid].end(),
190                                           mem_addr);
191     assert(list_it != addrList[tid].end() || inst->splitInst);
192 
193     if (list_it != addrList[tid].end()) {
194         DPRINTF(AddrDep,
195                 "[tid:%i]: [sn:%i] Address %08p removed from dependency "
196                 "list\n", inst->readTid(), inst->seqNum, (*list_it));
197 
198         addrList[tid].erase(list_it);
199 
200         // Erase From Address Map (Used for Debugging)
201         addrMap[tid].erase(addrMap[tid].find(mem_addr));
202     }
203     
204 
205 }
\end{DoxyCode}
\hypertarget{classCacheUnit_a9063fd6f97e36e3565247339ffa3882c}{
\index{CacheUnit@{CacheUnit}!requestAgain@{requestAgain}}
\index{requestAgain@{requestAgain}!CacheUnit@{CacheUnit}}
\subsubsection[{requestAgain}]{\setlength{\rightskip}{0pt plus 5cm}void requestAgain ({\bf DynInstPtr} {\em inst}, \/  bool \& {\em try\_\-request})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCacheUnit_a9063fd6f97e36e3565247339ffa3882c}
\hyperlink{classRequest}{Request} a \hyperlink{classResource}{Resource} again. Some resources have to special process this in subsequent accesses. 

\hyperlink{classResource_a9063fd6f97e36e3565247339ffa3882c}{Resource}を再定義しています。


\begin{DoxyCode}
304 {
305     CacheReqPtr cache_req = dynamic_cast<CacheReqPtr>(findRequest(inst));
306     assert(cache_req);
307 
308     // Check to see if this instruction is requesting the same command
309     // or a different one
310     if (cache_req->cmd != inst->curSkedEntry->cmd &&
311         cache_req->instIdx == inst->curSkedEntry->idx) {
312         // If different, then update command in the request
313         cache_req->cmd = inst->curSkedEntry->cmd;
314         DPRINTF(InOrderCachePort,
315                 "[tid:%i]: [sn:%i]: Updating the command for this "
316                 "instruction\n", inst->readTid(), inst->seqNum);
317 
318         service_request = true;
319     } else if (inst->curSkedEntry->idx != CacheUnit::InitSecondSplitRead &&
320                inst->curSkedEntry->idx != CacheUnit::InitSecondSplitWrite) {
321         // If same command, just check to see if memory access was completed
322         // but dont try to re-execute
323         DPRINTF(InOrderCachePort,
324                 "[tid:%i]: [sn:%i]: requesting this resource again\n",
325                 inst->readTid(), inst->seqNum);
326 
327         service_request = true;
328     }
329 }
\end{DoxyCode}
\hypertarget{classCacheUnit_a4244e66bc15f13c2dbec20ca5fcea3d4}{
\index{CacheUnit@{CacheUnit}!setAddrDependency@{setAddrDependency}}
\index{setAddrDependency@{setAddrDependency}!CacheUnit@{CacheUnit}}
\subsubsection[{setAddrDependency}]{\setlength{\rightskip}{0pt plus 5cm}void setAddrDependency ({\bf DynInstPtr} {\em inst})}}
\label{classCacheUnit_a4244e66bc15f13c2dbec20ca5fcea3d4}



\begin{DoxyCode}
157 {
158     Addr req_addr = inst->getMemAddr();
159     ThreadID tid = inst->readTid();
160 
161     addrList[tid].push_back(req_addr);
162     addrMap[tid][req_addr] = inst->seqNum;
163 
164     DPRINTF(AddrDep,
165             "[tid:%i]: [sn:%i]: Address %08p added to dependency list (size=%i)\n
      ",
166             inst->readTid(), inst->seqNum, req_addr, addrList[tid].size());
167 
168     //@NOTE: 10 is an arbitrarily "high" number, but to be exact
169     //       we would need to know the # of outstanding accesses
170     //       a priori. Information like fetch width, stage width,
171     //       fetch buffer, and the branch resolution stage would be
172     //       useful for the icache_port. For the dcache port, the #
173     //       of outstanding cache accesses (mshrs) would be a good
174     //       sanity check here.
175     //assert(addrList[tid].size() < 10);
176 }
\end{DoxyCode}
\hypertarget{classCacheUnit_aa942d730ea26d41b72db771cc951f51e}{
\index{CacheUnit@{CacheUnit}!setupMemRequest@{setupMemRequest}}
\index{setupMemRequest@{setupMemRequest}!CacheUnit@{CacheUnit}}
\subsubsection[{setupMemRequest}]{\setlength{\rightskip}{0pt plus 5cm}void setupMemRequest ({\bf DynInstPtr} {\em inst}, \/  {\bf CacheReqPtr} {\em cache\_\-req}, \/  int {\em acc\_\-size}, \/  int {\em flags})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCacheUnit_aa942d730ea26d41b72db771cc951f51e}
Create request that will interface w/TLB and Memory objects 

\hyperlink{classFetchUnit_aa942d730ea26d41b72db771cc951f51e}{FetchUnit}で再定義されています。


\begin{DoxyCode}
334 {
335     ThreadID tid = inst->readTid();
336     Addr aligned_addr = inst->getMemAddr();
337 
338     if (!cache_req->is2ndSplit()) {
339         if (cache_req->memReq == NULL) {
340             cache_req->memReq =
341                 new Request(cpu->asid[tid], aligned_addr, acc_size, flags,
342                             cpu->dataMasterId(),
343                             inst->instAddr(),
344                             cpu->readCpuId(), //@todo: use context id
345                             tid);
346         }
347     } else {
348         assert(inst->splitInst);
349 
350         //
351         if (inst->splitMemReq == NULL) {
352             inst->splitMemReq = new Request(cpu->asid[tid], 
353                                             inst->split2ndAddr,
354                                             acc_size, 
355                                             flags, 
356                                             cpu->dataMasterId(),
357                                             inst->instAddr(),
358                                             cpu->readCpuId(), 
359                                             tid);
360         }
361 
362         cache_req->memReq = inst->splitMemReq;
363     }
364 }
\end{DoxyCode}
\hypertarget{classCacheUnit_a52235c5e3d912452f254dc45f1496fd2}{
\index{CacheUnit@{CacheUnit}!squash@{squash}}
\index{squash@{squash}!CacheUnit@{CacheUnit}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash ({\bf DynInstPtr} {\em inst}, \/  int {\em stage\_\-num}, \/  {\bf InstSeqNum} {\em squash\_\-seq\_\-num}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCacheUnit_a52235c5e3d912452f254dc45f1496fd2}
Squash All Requests After This Seq Num 

\hyperlink{classResource_a52235c5e3d912452f254dc45f1496fd2}{Resource}を再定義しています。


\begin{DoxyCode}
1218 {
1219     if (tlbBlocked[tid] &&
1220         tlbBlockSeqNum[tid] > squash_seq_num) {
1221         DPRINTF(InOrderCachePort, "Releasing TLB Block due to "
1222                 " squash after [sn:%i].\n", squash_seq_num);
1223         tlbBlocked[tid] = false;
1224     }
1225 
1226     for (int i = 0; i < width; i++) {
1227         ResReqPtr req_ptr = reqs[i];
1228 
1229         if (req_ptr->valid &&
1230             req_ptr->getInst()->readTid() == tid &&
1231             req_ptr->getInst()->seqNum > squash_seq_num) {
1232 
1233             DPRINTF(InOrderCachePort,
1234                     "[tid:%i] Squashing request from [sn:%i]\n",
1235                     req_ptr->getInst()->readTid(), req_ptr->getInst()->seqNum);
1236 
1237             if (req_ptr->isSquashed()) {
1238                 DPRINTF(AddrDep, "Request for [tid:%i] [sn:%i] already "
1239                         "squashed, ignoring squash process.\n",
1240                         req_ptr->getInst()->readTid(),
1241                         req_ptr->getInst()->seqNum);
1242                 continue;                
1243             }
1244 
1245             CacheReqPtr cache_req = dynamic_cast<CacheReqPtr>(req_ptr);
1246             assert(cache_req);
1247 
1248             squashCacheRequest(cache_req);
1249 
1250             int req_slot_num = req_ptr->getSlot();
1251 
1252             if (cache_req->tlbStall) {
1253                 tlbBlocked[tid] = false;
1254 
1255                 int stall_stage = reqs[req_slot_num]->getStageNum();
1256 
1257                 cpu->pipelineStage[stall_stage]->
1258                     unsetResStall(reqs[req_slot_num], tid);
1259             }
1260 
1261             if (cache_req->isMemAccPending()) {
1262                 cache_req->dataPkt->reqData = cache_req->reqData;
1263                 cache_req->dataPkt->memReq = cache_req->memReq;
1264             }
1265 
1266             if (!cache_req->tlbStall)
1267                 freeSlot(req_slot_num);
1268         }
1269     }
1270 
1271 }
\end{DoxyCode}
\hypertarget{classCacheUnit_ac2831520eb121be08811b040992f416b}{
\index{CacheUnit@{CacheUnit}!squashCacheRequest@{squashCacheRequest}}
\index{squashCacheRequest@{squashCacheRequest}!CacheUnit@{CacheUnit}}
\subsubsection[{squashCacheRequest}]{\setlength{\rightskip}{0pt plus 5cm}void squashCacheRequest ({\bf CacheReqPtr} {\em req\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCacheUnit_ac2831520eb121be08811b040992f416b}


\hyperlink{classFetchUnit_ac2831520eb121be08811b040992f416b}{FetchUnit}で再定義されています。


\begin{DoxyCode}
1197 {
1198     DynInstPtr inst =  req_ptr->getInst();
1199     req_ptr->setSquashed();
1200     inst->setSquashed();
1201 
1202     //@note: add back in for speculative load/store capability
1203     /*if (inst->validMemAddr()) {
1204         DPRINTF(AddrDep, "Squash of [tid:%i] [sn:%i], attempting to "
1205                 "remove addr. %08p dependencies.\n",
1206                 inst->readTid(),
1207                 inst->seqNum,
1208                 inst->getMemAddr());
1209 
1210         removeAddrDependency(inst);
1211     }*/
1212 }
\end{DoxyCode}
\hypertarget{classCacheUnit_ae2d6fba25ece343caad6eb029a4a3b5b}{
\index{CacheUnit@{CacheUnit}!squashDueToMemStall@{squashDueToMemStall}}
\index{squashDueToMemStall@{squashDueToMemStall}!CacheUnit@{CacheUnit}}
\subsubsection[{squashDueToMemStall}]{\setlength{\rightskip}{0pt plus 5cm}void squashDueToMemStall ({\bf DynInstPtr} {\em inst}, \/  int {\em stage\_\-num}, \/  {\bf InstSeqNum} {\em squash\_\-seq\_\-num}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCacheUnit_ae2d6fba25ece343caad6eb029a4a3b5b}
Squash Requests Due to a Memory Stall (By Default, same as \char`\"{}squash\char`\"{} 

\hyperlink{classResource_ae2d6fba25ece343caad6eb029a4a3b5b}{Resource}を再定義しています。


\begin{DoxyCode}
1179 {
1180     // If squashing due to memory stall, then we do NOT want to 
1181     // squash the instruction that caused the stall so we
1182     // increment the sequence number here to prevent that.
1183     //
1184     // NOTE: This is only for the SwitchOnCacheMiss Model
1185     // NOTE: If you have multiple outstanding misses from the same
1186     //       thread then you need to reevaluate this code
1187     // NOTE: squash should originate from 
1188     //       pipeline_stage.cc:processInstSchedule
1189     DPRINTF(InOrderCachePort, "Squashing above [sn:%u]\n", 
1190             squash_seq_num + 1);
1191     
1192     squash(inst, stage_num, squash_seq_num + 1, tid);    
1193 }
\end{DoxyCode}
\hypertarget{classCacheUnit_a3cf8b27760278d20d4aa9463f52a2d95}{
\index{CacheUnit@{CacheUnit}!tlb@{tlb}}
\index{tlb@{tlb}!CacheUnit@{CacheUnit}}
\subsubsection[{tlb}]{\setlength{\rightskip}{0pt plus 5cm}TheISA::TLB $\ast$ tlb ()}}
\label{classCacheUnit_a3cf8b27760278d20d4aa9463f52a2d95}



\begin{DoxyCode}
107 {
108     return _tlb;
109 
110 }
\end{DoxyCode}
\hypertarget{classCacheUnit_abf76d6d245f7d3b17d26ea8dcc0cf36f}{
\index{CacheUnit@{CacheUnit}!trap@{trap}}
\index{trap@{trap}!CacheUnit@{CacheUnit}}
\subsubsection[{trap}]{\setlength{\rightskip}{0pt plus 5cm}void trap ({\bf Fault} {\em fault}, \/  {\bf ThreadID} {\em tid}, \/  {\bf DynInstPtr} {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classCacheUnit_abf76d6d245f7d3b17d26ea8dcc0cf36f}
Post-\/processsing for Trap Generated from this instruction 

\hyperlink{classResource_a1eb2a0229740a87bde0282416035b864}{Resource}を再定義しています。

\hyperlink{classFetchUnit_abf76d6d245f7d3b17d26ea8dcc0cf36f}{FetchUnit}で再定義されています。


\begin{DoxyCode}
410 {
411     tlbBlocked[tid] = false;
412 }
\end{DoxyCode}
\hypertarget{classCacheUnit_abd0bcff6bbdb03d0ad191f96774e8a8b}{
\index{CacheUnit@{CacheUnit}!write@{write}}
\index{write@{write}!CacheUnit@{CacheUnit}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} write ({\bf DynInstPtr} {\em inst}, \/  uint8\_\-t $\ast$ {\em data}, \/  unsigned {\em size}, \/  {\bf Addr} {\em addr}, \/  unsigned {\em flags}, \/  uint64\_\-t $\ast$ {\em res})}}
\label{classCacheUnit_abd0bcff6bbdb03d0ad191f96774e8a8b}



\begin{DoxyCode}
512 {
513     CacheReqPtr cache_req = dynamic_cast<CacheReqPtr>(findRequest(inst));
514     assert(cache_req && "Can't Find Instruction for Write!");
515 
516     // The block size of our peer
517     unsigned blockSize = cacheBlkSize;
518 
519     //The size of the data we're trying to write.
520     int fullSize = size;
521     inst->totalSize = size;
522 
523     if (inst->traceData) {
524         inst->traceData->setAddr(addr);
525     }
526 
527     if (inst->split2ndAccess) {     
528         size = inst->split2ndSize;
529         cache_req->splitAccess = true;        
530         cache_req->split2ndAccess = true;
531         
532         DPRINTF(InOrderCachePort, "[sn:%i] Split Write Access (2 of 2) for "
533                 "(%#x, %#x).\n", inst->seqNum, inst->getMemAddr(),
534                 inst->split2ndAddr);
535     }  
536 
537     //The address of the second part of this access if it needs to be split
538     //across a cache line boundary.
539     Addr secondAddr = roundDown(addr + size - 1, blockSize);
540 
541     if (secondAddr > addr && !inst->split2ndAccess) {
542             
543         DPRINTF(InOrderCachePort, "[sn:%i] Split Write Access (1 of 2) for "
544                 "(%#x, %#x).\n", inst->seqNum, addr, secondAddr);
545 
546         // Save All "Total" Split Information
547         // ==============================
548         inst->splitInst = true;        
549 
550         if (!inst->splitInstSked) {
551             assert(0 && "Split Requests Not Supported for Now...");
552 
553             // Schedule Split Read/Complete for Instruction
554             // ==============================
555             int stage_num = cache_req->getStageNum();
556             RSkedPtr inst_sked = (stage_num >= ThePipeline::BackEndStartStage) ?
557                 inst->backSked : inst->frontSked;
558         
559             // this is just an arbitrarily high priority to ensure that this
560             // gets pushed to the back of the list
561             int stage_pri = 20;
562         
563             int isplit_cmd = CacheUnit::InitSecondSplitWrite;
564             inst_sked->push(new
565                             ScheduleEntry(stage_num,
566                                           stage_pri,
567                                           cpu->resPool->getResIdx(DCache),
568                                           isplit_cmd,
569                                           1));
570 
571             int csplit_cmd = CacheUnit::CompleteSecondSplitWrite;
572             inst_sked->push(new
573                             ScheduleEntry(stage_num + 1,
574                                           1/*stage_pri*/,
575                                           cpu->resPool->getResIdx(DCache),
576                                           csplit_cmd,
577                                           1));
578             inst->splitInstSked = true;
579         } else {
580             DPRINTF(InOrderCachePort, "[tid:%i] sn:%i] Retrying Split Read "
581                     "Access (1 of 2) for (%#x, %#x).\n",
582                     inst->readTid(), inst->seqNum, addr, secondAddr);            
             
583         }
584         
585         
586 
587         // Split Information for First Access
588         // ==============================
589         size = secondAddr - addr;
590         cache_req->splitAccess = true;
591 
592         // Split Information for Second Access
593         // ==============================
594         inst->split2ndSize = addr + fullSize - secondAddr;
595         inst->split2ndAddr = secondAddr;            
596         inst->split2ndFlags = flags;        
597         inst->splitInstSked = true;
598     }    
599         
600     doTLBAccess(inst, cache_req, size, flags, TheISA::TLB::Write);
601 
602     //@@@store
603     if (inst->fault == NoFault) {
604         if (!cache_req->splitAccess) {
605             cache_req->reqData = new uint8_t[size];
606             memcpy(cache_req->reqData, data, size);
607 
608             //inst->split2ndStoreDataPtr = cache_req->reqData;
609             //inst->split2ndStoreDataPtr += size;
610 
611             doCacheAccess(inst, write_res);
612         } else {            
613             doCacheAccess(inst, write_res, cache_req);            
614         }        
615         
616     }
617     
618     return inst->fault;
619 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classCacheUnit_a5aa23855b427a009f3334c95a146084b}{
\index{CacheUnit@{CacheUnit}!\_\-tlb@{\_\-tlb}}
\index{\_\-tlb@{\_\-tlb}!CacheUnit@{CacheUnit}}
\subsubsection[{\_\-tlb}]{\setlength{\rightskip}{0pt plus 5cm}TheISA::TLB$\ast$ {\bf \_\-tlb}}}
\label{classCacheUnit_a5aa23855b427a009f3334c95a146084b}
\hypertarget{classCacheUnit_a66e9796fd56a3a307b1095ff8da5a4c8}{
\index{CacheUnit@{CacheUnit}!addrList@{addrList}}
\index{addrList@{addrList}!CacheUnit@{CacheUnit}}
\subsubsection[{addrList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf Addr}$>$ {\bf addrList}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCacheUnit_a66e9796fd56a3a307b1095ff8da5a4c8}
\hypertarget{classCacheUnit_a9748daf7b829518c81be2287ecbc032d}{
\index{CacheUnit@{CacheUnit}!addrMap@{addrMap}}
\index{addrMap@{addrMap}!CacheUnit@{CacheUnit}}
\subsubsection[{addrMap}]{\setlength{\rightskip}{0pt plus 5cm}m5::hash\_\-map$<${\bf Addr}, {\bf InstSeqNum}$>$ {\bf addrMap}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCacheUnit_a9748daf7b829518c81be2287ecbc032d}
\hypertarget{classCacheUnit_a4abab6f8643f5958a53eec1355be3ebd}{
\index{CacheUnit@{CacheUnit}!cacheBlkMask@{cacheBlkMask}}
\index{cacheBlkMask@{cacheBlkMask}!CacheUnit@{CacheUnit}}
\subsubsection[{cacheBlkMask}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf cacheBlkMask}}}
\label{classCacheUnit_a4abab6f8643f5958a53eec1355be3ebd}
\hypertarget{classCacheUnit_a9d95d13b55fcaa47810d188d54903caf}{
\index{CacheUnit@{CacheUnit}!cacheBlkSize@{cacheBlkSize}}
\index{cacheBlkSize@{cacheBlkSize}!CacheUnit@{CacheUnit}}
\subsubsection[{cacheBlkSize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf cacheBlkSize}}}
\label{classCacheUnit_a9d95d13b55fcaa47810d188d54903caf}
\hypertarget{classCacheUnit_a6acbf550d7553b77d4e6f42d91133da6}{
\index{CacheUnit@{CacheUnit}!cachePort@{cachePort}}
\index{cachePort@{cachePort}!CacheUnit@{CacheUnit}}
\subsubsection[{cachePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterPort}$\ast$ {\bf cachePort}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCacheUnit_a6acbf550d7553b77d4e6f42d91133da6}
\hyperlink{classCache}{Cache} interface. \hypertarget{classCacheUnit_abe897aa45cc14999423020f95746328a}{
\index{CacheUnit@{CacheUnit}!cachePortBlocked@{cachePortBlocked}}
\index{cachePortBlocked@{cachePortBlocked}!CacheUnit@{CacheUnit}}
\subsubsection[{cachePortBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf cachePortBlocked}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classCacheUnit_abe897aa45cc14999423020f95746328a}
\hypertarget{classCacheUnit_a1e5ca2b940e91b19e93867cc549fe65d}{
\index{CacheUnit@{CacheUnit}!tlbBlocked@{tlbBlocked}}
\index{tlbBlocked@{tlbBlocked}!CacheUnit@{CacheUnit}}
\subsubsection[{tlbBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf tlbBlocked}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}}}
\label{classCacheUnit_a1e5ca2b940e91b19e93867cc549fe65d}
\hypertarget{classCacheUnit_a26ded431132c6ee52a8b8bdc8ddd837c}{
\index{CacheUnit@{CacheUnit}!tlbBlockSeqNum@{tlbBlockSeqNum}}
\index{tlbBlockSeqNum@{tlbBlockSeqNum}!CacheUnit@{CacheUnit}}
\subsubsection[{tlbBlockSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf tlbBlockSeqNum}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}}}
\label{classCacheUnit_a26ded431132c6ee52a8b8bdc8ddd837c}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/inorder/resources/\hyperlink{cache__unit_8hh}{cache\_\-unit.hh}\item 
cpu/inorder/resources/\hyperlink{cache__unit_8cc}{cache\_\-unit.cc}\end{DoxyCompactItemize}
