\hypertarget{classMemDepUnit}{
\section{クラス テンプレート MemDepUnit$<$ MemDepPred, Impl $>$}
\label{classMemDepUnit}\index{MemDepUnit@{MemDepUnit}}
}


{\ttfamily \#include $<$mem\_\-dep\_\-unit.hh$>$}MemDepUnit$<$ MemDepPred, Impl $>$に対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classMemDepUnit}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classMemDepUnit_1_1MemDepEntry}{MemDepEntry}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classRefCountingPtr}{ThePipeline::DynInstPtr} \hyperlink{classMemDepUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{DynInstPtr}
\item 
typedef Impl::DynInstPtr \hyperlink{classMemDepUnit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMemDepUnit_a954662036e667fd17db64ae83226ff3f}{MemDepUnit} (std::string res\_\-name, int res\_\-id, int res\_\-width, \hyperlink{classCycles}{Cycles} res\_\-latency, \hyperlink{classInOrderCPU}{InOrderCPU} $\ast$\_\-cpu)
\item 
virtual \hyperlink{classMemDepUnit_a45331beda5c09d8c776b6bd7c1814b59}{$\sim$MemDepUnit} ()
\item 
virtual void \hyperlink{classMemDepUnit_a74d7cd749b79186057ad86f5f7b79fd2}{execute} (int slot\_\-num)
\item 
\hyperlink{classMemDepUnit_a6a36e6c9f97f9e122c96398a39f53c7e}{MemDepUnit} ()
\item 
\hyperlink{classMemDepUnit_ad6878b8c69951d1680a6fcc62866a18f}{MemDepUnit} (DerivO3CPUParams $\ast$params)
\item 
\hyperlink{classMemDepUnit_a45331beda5c09d8c776b6bd7c1814b59}{$\sim$MemDepUnit} ()
\item 
std::string \hyperlink{classMemDepUnit_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classMemDepUnit_a0b3a45df958cbefd5455ff2aa1418bb4}{init} (DerivO3CPUParams $\ast$params, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classMemDepUnit_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classMemDepUnit_a0240eb42fa57fe5d3788093f62b77347}{drainSanityCheck} () const 
\item 
void \hyperlink{classMemDepUnit_a8674059ce345e23aac5086b2c3e24a43}{takeOverFrom} ()
\item 
void \hyperlink{classMemDepUnit_a9f2164f7d32d0906f0818ac724921840}{setIQ} (\hyperlink{classInstructionQueue}{InstructionQueue}$<$ Impl $>$ $\ast$iq\_\-ptr)
\item 
void \hyperlink{classMemDepUnit_a773e88db1aa010c3755e603493bf40ec}{insert} (\hyperlink{classRefCountingPtr}{DynInstPtr} \&inst)
\item 
void \hyperlink{classMemDepUnit_ad7036279ba36a8cfaf65554d1a5dbaac}{insertNonSpec} (\hyperlink{classRefCountingPtr}{DynInstPtr} \&inst)
\item 
void \hyperlink{classMemDepUnit_ae556f19566bae9c4f55350eab17abacd}{insertBarrier} (\hyperlink{classRefCountingPtr}{DynInstPtr} \&barr\_\-inst)
\item 
void \hyperlink{classMemDepUnit_a386af6dbeff30f5152fd5dc076143ff6}{regsReady} (\hyperlink{classRefCountingPtr}{DynInstPtr} \&inst)
\item 
void \hyperlink{classMemDepUnit_aa85e9b95e406478a19cb070b13b89c85}{nonSpecInstReady} (\hyperlink{classRefCountingPtr}{DynInstPtr} \&inst)
\item 
void \hyperlink{classMemDepUnit_a6a8d5eec636c2815cb1bc7ca3c467412}{reschedule} (\hyperlink{classRefCountingPtr}{DynInstPtr} \&inst)
\item 
void \hyperlink{classMemDepUnit_ace9b968c62d08a19c21a17b57bfb52fe}{replay} (\hyperlink{classRefCountingPtr}{DynInstPtr} \&inst)
\item 
void \hyperlink{classMemDepUnit_a4970c417e5fac50b9a28caea195717c3}{completed} (\hyperlink{classRefCountingPtr}{DynInstPtr} \&inst)
\item 
void \hyperlink{classMemDepUnit_a9debd021c4b533f5bbd174890037d2dd}{completeBarrier} (\hyperlink{classRefCountingPtr}{DynInstPtr} \&inst)
\item 
void \hyperlink{classMemDepUnit_a84834d31005dcede47e334bfee5b52d3}{wakeDependents} (\hyperlink{classRefCountingPtr}{DynInstPtr} \&inst)
\item 
void \hyperlink{classMemDepUnit_a74283dfde2ab06c84e10bd85000c168b}{squash} (const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&squashed\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classMemDepUnit_aac3ab1b2d6cc44bd1e7c42bf39538316}{violation} (\hyperlink{classRefCountingPtr}{DynInstPtr} \&store\_\-inst, \hyperlink{classRefCountingPtr}{DynInstPtr} \&violating\_\-load)
\item 
void \hyperlink{classMemDepUnit_a6abd0e2390123c2fe82ab377b76b5347}{issue} (\hyperlink{classRefCountingPtr}{DynInstPtr} \&inst)
\item 
void \hyperlink{classMemDepUnit_a3d1dae45e8e0b5cf7c1f4f8c796d070e}{dumpLists} ()
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classMemDepUnit_a5db9914f1c33ab7cef8fdc6037f98775}{lastCycleGrad}
\item 
int \hyperlink{classMemDepUnit_a9bd2235f4069b61f51af0d84d5115de5}{numCycleGrad}
\item 
bool $\ast$ \hyperlink{classMemDepUnit_aa27d1c9b589af0c77a81c490021c7dcb}{nonSpecInstActive} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} $\ast$ \hyperlink{classMemDepUnit_a899b1bc10d38a0f725495bf2108479a3}{nonSpecSeqNum} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\item 
std::string \hyperlink{classMemDepUnit_aaf2ed934b37cbbd236fdd1b01a5f5005}{\_\-name}
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classRefCountingPtr}{DynInstPtr} $>$::iterator \hyperlink{classMemDepUnit_a184cb829e22cc656acb41864f68f51ea}{ListIt}
\item 
typedef \hyperlink{classRefCountingPtr}{RefCountingPtr}$<$ \hyperlink{classMemDepUnit_1_1MemDepEntry}{MemDepEntry} $>$ \hyperlink{classMemDepUnit_a3ebb51dea989551d10194eb1b09cff41}{MemDepEntryPtr}
\item 
typedef m5::hash\_\-map$<$ \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum}, \hyperlink{classRefCountingPtr}{MemDepEntryPtr}, \hyperlink{structSNHash}{SNHash} $>$ \hyperlink{classMemDepUnit_a0552beec197948e07bf69cb6ea45407e}{MemDepHash}
\item 
typedef MemDepHash::iterator \hyperlink{classMemDepUnit_a4579af5e07d66f86f6e8aa193e0f926a}{MemDepHashIt}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classRefCountingPtr}{MemDepEntryPtr} \& \hyperlink{classMemDepUnit_a7c1fadef5550f6fd9382259565101bec}{findInHash} (const \hyperlink{classRefCountingPtr}{DynInstPtr} \&inst)
\item 
void \hyperlink{classMemDepUnit_ac1e743ad9d95132dd76847a784259e11}{moveToReady} (\hyperlink{classRefCountingPtr}{MemDepEntryPtr} \&ready\_\-inst\_\-entry)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMemDepUnit_a0552beec197948e07bf69cb6ea45407e}{MemDepHash} \hyperlink{classMemDepUnit_ac0b12f9eec0e0c6b639c7370177e5c36}{memDepHash}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classRefCountingPtr}{DynInstPtr} $>$ \hyperlink{classMemDepUnit_a7f2828a4f877a4a4d4b85a6788536b82}{instList} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classRefCountingPtr}{DynInstPtr} $>$ \hyperlink{classMemDepUnit_a4c7e8849e2a4606478c2e93f9dcb6c54}{instsToReplay}
\item 
MemDepPred \hyperlink{classMemDepUnit_a2b12193ddce173c34c8c54e0201925bc}{depPred}
\item 
bool \hyperlink{classMemDepUnit_a84cd010b1d5bb1d8a72a2603a9b58393}{loadBarrier}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classMemDepUnit_adbdb10ce572ac89847d1541d471f0be6}{loadBarrierSN}
\item 
bool \hyperlink{classMemDepUnit_ac066575fbaeda40cc6b2017292dfb0bf}{storeBarrier}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classMemDepUnit_ae3e16866c4d84194ff7f414f00d71e94}{storeBarrierSN}
\item 
\hyperlink{classInstructionQueue}{InstructionQueue}$<$ Impl $>$ $\ast$ \hyperlink{classMemDepUnit_ae1fd26993119273f381c42894e2672c6}{iqPtr}
\item 
int \hyperlink{classMemDepUnit_a7441ef0865bcb3db9b8064dd7375c1ea}{id}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classMemDepUnit_a7810bf3f4630c9898e404e7d46900ad5}{insertedLoads}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classMemDepUnit_a5f8daf9e076650e5b9f2f9a6876a3bf7}{insertedStores}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classMemDepUnit_ad5a10b8601553be6d0f3bfa3495dd5a5}{conflictingLoads}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classMemDepUnit_ab481d99d6034a2db5e14efd072448635}{conflictingStores}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$class MemDepPred, class Impl$>$ class MemDepUnit$<$ MemDepPred, Impl $>$}

Memory dependency unit class. This holds the memory dependence predictor. As memory operations are issued to the IQ, they are also issued to this unit, which then looks up the prediction as to what they are dependent upon. This unit must be checked prior to a memory operation being able to issue. Although this is templated, it's somewhat hard to make a generic memory dependence unit. This one is mostly for store sets; it will be quite limited in what other memory dependence predictions it can also utilize. Thus this class should be most likely be rewritten for other dependence prediction schemes. 

\subsection{型定義}
\hypertarget{classMemDepUnit_a028ce10889c5f6450239d9e9a7347976}{
\index{MemDepUnit@{MemDepUnit}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!MemDepUnit@{MemDepUnit}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInstPtr {\bf DynInstPtr}}}
\label{classMemDepUnit_a028ce10889c5f6450239d9e9a7347976}


\hyperlink{classResource_af9d0c8a46736ba6aa2d8bb94da1a5e73}{Resource}を再定義しています。\hypertarget{classMemDepUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{
\index{MemDepUnit@{MemDepUnit}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!MemDepUnit@{MemDepUnit}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf ThePipeline::DynInstPtr} {\bf DynInstPtr}}}
\label{classMemDepUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}


\hyperlink{classResource_af9d0c8a46736ba6aa2d8bb94da1a5e73}{Resource}を再定義しています。\hypertarget{classMemDepUnit_a184cb829e22cc656acb41864f68f51ea}{
\index{MemDepUnit@{MemDepUnit}!ListIt@{ListIt}}
\index{ListIt@{ListIt}!MemDepUnit@{MemDepUnit}}
\subsubsection[{ListIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf DynInstPtr}$>$::iterator {\bf ListIt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemDepUnit_a184cb829e22cc656acb41864f68f51ea}
\hypertarget{classMemDepUnit_a3ebb51dea989551d10194eb1b09cff41}{
\index{MemDepUnit@{MemDepUnit}!MemDepEntryPtr@{MemDepEntryPtr}}
\index{MemDepEntryPtr@{MemDepEntryPtr}!MemDepUnit@{MemDepUnit}}
\subsubsection[{MemDepEntryPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf RefCountingPtr}$<${\bf MemDepEntry}$>$ {\bf MemDepEntryPtr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemDepUnit_a3ebb51dea989551d10194eb1b09cff41}
\hypertarget{classMemDepUnit_a0552beec197948e07bf69cb6ea45407e}{
\index{MemDepUnit@{MemDepUnit}!MemDepHash@{MemDepHash}}
\index{MemDepHash@{MemDepHash}!MemDepUnit@{MemDepUnit}}
\subsubsection[{MemDepHash}]{\setlength{\rightskip}{0pt plus 5cm}typedef m5::hash\_\-map$<${\bf InstSeqNum}, {\bf MemDepEntryPtr}, {\bf SNHash}$>$ {\bf MemDepHash}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemDepUnit_a0552beec197948e07bf69cb6ea45407e}
\hypertarget{classMemDepUnit_a4579af5e07d66f86f6e8aa193e0f926a}{
\index{MemDepUnit@{MemDepUnit}!MemDepHashIt@{MemDepHashIt}}
\index{MemDepHashIt@{MemDepHashIt}!MemDepUnit@{MemDepUnit}}
\subsubsection[{MemDepHashIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef MemDepHash::iterator {\bf MemDepHashIt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemDepUnit_a4579af5e07d66f86f6e8aa193e0f926a}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classMemDepUnit_a954662036e667fd17db64ae83226ff3f}{
\index{MemDepUnit@{MemDepUnit}!MemDepUnit@{MemDepUnit}}
\index{MemDepUnit@{MemDepUnit}!MemDepUnit@{MemDepUnit}}
\subsubsection[{MemDepUnit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemDepUnit} (std::string {\em res\_\-name}, \/  int {\em res\_\-id}, \/  int {\em res\_\-width}, \/  {\bf Cycles} {\em res\_\-latency}, \/  {\bf InOrderCPU} $\ast$ {\em \_\-cpu})}}
\label{classMemDepUnit_a954662036e667fd17db64ae83226ff3f}
\hypertarget{classMemDepUnit_a45331beda5c09d8c776b6bd7c1814b59}{
\index{MemDepUnit@{MemDepUnit}!$\sim$MemDepUnit@{$\sim$MemDepUnit}}
\index{$\sim$MemDepUnit@{$\sim$MemDepUnit}!MemDepUnit@{MemDepUnit}}
\subsubsection[{$\sim$MemDepUnit}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf MemDepUnit} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classMemDepUnit_a45331beda5c09d8c776b6bd7c1814b59}



\begin{DoxyCode}
51 {}
\end{DoxyCode}
\hypertarget{classMemDepUnit_a6a36e6c9f97f9e122c96398a39f53c7e}{
\index{MemDepUnit@{MemDepUnit}!MemDepUnit@{MemDepUnit}}
\index{MemDepUnit@{MemDepUnit}!MemDepUnit@{MemDepUnit}}
\subsubsection[{MemDepUnit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemDepUnit} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_a6a36e6c9f97f9e122c96398a39f53c7e}
Empty constructor. Must call \hyperlink{classResource_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} prior to using in this case. 


\begin{DoxyCode}
55     : loadBarrier(false), loadBarrierSN(0), storeBarrier(false),
56       storeBarrierSN(0), iqPtr(NULL)
57 {
58 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_ad6878b8c69951d1680a6fcc62866a18f}{
\index{MemDepUnit@{MemDepUnit}!MemDepUnit@{MemDepUnit}}
\index{MemDepUnit@{MemDepUnit}!MemDepUnit@{MemDepUnit}}
\subsubsection[{MemDepUnit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemDepUnit} (DerivO3CPUParams $\ast$ {\em params})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_ad6878b8c69951d1680a6fcc62866a18f}
Constructs a \hyperlink{classMemDepUnit}{MemDepUnit} with given parameters. 


\begin{DoxyCode}
62     : _name(params->name + ".memdepunit"),
63       depPred(params->store_set_clear_period, params->SSITSize,
64               params->LFSTSize),
65       loadBarrier(false), loadBarrierSN(0), storeBarrier(false),
66       storeBarrierSN(0), iqPtr(NULL)
67 {
68     DPRINTF(MemDepUnit, "Creating MemDepUnit object.\n");
69 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_a45331beda5c09d8c776b6bd7c1814b59}{
\index{MemDepUnit@{MemDepUnit}!$\sim$MemDepUnit@{$\sim$MemDepUnit}}
\index{$\sim$MemDepUnit@{$\sim$MemDepUnit}!MemDepUnit@{MemDepUnit}}
\subsubsection[{$\sim$MemDepUnit}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf MemDepUnit} ()}}
\label{classMemDepUnit_a45331beda5c09d8c776b6bd7c1814b59}
Frees up any memory allocated. 

\subsection{関数}
\hypertarget{classMemDepUnit_a9debd021c4b533f5bbd174890037d2dd}{
\index{MemDepUnit@{MemDepUnit}!completeBarrier@{completeBarrier}}
\index{completeBarrier@{completeBarrier}!MemDepUnit@{MemDepUnit}}
\subsubsection[{completeBarrier}]{\setlength{\rightskip}{0pt plus 5cm}void completeBarrier ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_a9debd021c4b533f5bbd174890037d2dd}
Completes a barrier instruction. 


\begin{DoxyCode}
419 {
420     wakeDependents(inst);
421     completed(inst);
422 
423     InstSeqNum barr_sn = inst->seqNum;
424     DPRINTF(MemDepUnit, "barrier completed: %s SN:%lli\n", inst->pcState(),
425             inst->seqNum);
426     if (inst->isMemBarrier()) {
427         if (loadBarrierSN == barr_sn)
428             loadBarrier = false;
429         if (storeBarrierSN == barr_sn)
430             storeBarrier = false;
431     } else if (inst->isWriteBarrier()) {
432         if (storeBarrierSN == barr_sn)
433             storeBarrier = false;
434     }
435 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_a4970c417e5fac50b9a28caea195717c3}{
\index{MemDepUnit@{MemDepUnit}!completed@{completed}}
\index{completed@{completed}!MemDepUnit@{MemDepUnit}}
\subsubsection[{completed}]{\setlength{\rightskip}{0pt plus 5cm}void completed ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_a4970c417e5fac50b9a28caea195717c3}
Completes a memory instruction. 


\begin{DoxyCode}
395 {
396     DPRINTF(MemDepUnit, "Completed mem instruction PC %s [sn:%lli].\n",
397             inst->pcState(), inst->seqNum);
398 
399     ThreadID tid = inst->threadNumber;
400 
401     // Remove the instruction from the hash and the list.
402     MemDepHashIt hash_it = memDepHash.find(inst->seqNum);
403 
404     assert(hash_it != memDepHash.end());
405 
406     instList[tid].erase((*hash_it).second->listIt);
407 
408     (*hash_it).second = NULL;
409 
410     memDepHash.erase(hash_it);
411 #ifdef DEBUG
412     MemDepEntry::memdep_erase++;
413 #endif
414 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_a0240eb42fa57fe5d3788093f62b77347}{
\index{MemDepUnit@{MemDepUnit}!drainSanityCheck@{drainSanityCheck}}
\index{drainSanityCheck@{drainSanityCheck}!MemDepUnit@{MemDepUnit}}
\subsubsection[{drainSanityCheck}]{\setlength{\rightskip}{0pt plus 5cm}void drainSanityCheck () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_a0240eb42fa57fe5d3788093f62b77347}
Perform sanity checks after a drain. 


\begin{DoxyCode}
133 {
134     assert(instsToReplay.empty());
135     assert(memDepHash.empty());
136     for (int i = 0; i < Impl::MaxThreads; ++i)
137         assert(instList[i].empty());
138     assert(instsToReplay.empty());
139     assert(memDepHash.empty());
140 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_a3d1dae45e8e0b5cf7c1f4f8c796d070e}{
\index{MemDepUnit@{MemDepUnit}!dumpLists@{dumpLists}}
\index{dumpLists@{dumpLists}!MemDepUnit@{MemDepUnit}}
\subsubsection[{dumpLists}]{\setlength{\rightskip}{0pt plus 5cm}void dumpLists ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_a3d1dae45e8e0b5cf7c1f4f8c796d070e}
Debugging function to dump the lists of instructions. 


\begin{DoxyCode}
573 {
574     for (ThreadID tid = 0; tid < Impl::MaxThreads; tid++) {
575         cprintf("Instruction list %i size: %i\n",
576                 tid, instList[tid].size());
577 
578         ListIt inst_list_it = instList[tid].begin();
579         int num = 0;
580 
581         while (inst_list_it != instList[tid].end()) {
582             cprintf("Instruction:%i\nPC: %s\n[sn:%i]\n[tid:%i]\nIssued:%i\n"
583                     "Squashed:%i\n\n",
584                     num, (*inst_list_it)->pcState(),
585                     (*inst_list_it)->seqNum,
586                     (*inst_list_it)->threadNumber,
587                     (*inst_list_it)->isIssued(),
588                     (*inst_list_it)->isSquashed());
589             inst_list_it++;
590             ++num;
591         }
592     }
593 
594     cprintf("Memory dependence hash size: %i\n", memDepHash.size());
595 
596 #ifdef DEBUG
597     cprintf("Memory dependence entries: %i\n", MemDepEntry::memdep_count);
598 #endif
599 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_a74d7cd749b79186057ad86f5f7b79fd2}{
\index{MemDepUnit@{MemDepUnit}!execute@{execute}}
\index{execute@{execute}!MemDepUnit@{MemDepUnit}}
\subsubsection[{execute}]{\setlength{\rightskip}{0pt plus 5cm}virtual void execute (int {\em slot\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classMemDepUnit_a74d7cd749b79186057ad86f5f7b79fd2}
Execute the function of this resource. The Default is action is to do nothing. More specific models will derive from this class and define their own execute function. 

\hyperlink{classResource_a39af49c5568d1db3f53c12d7d6914c32}{Resource}を再定義しています。\hypertarget{classMemDepUnit_a7c1fadef5550f6fd9382259565101bec}{
\index{MemDepUnit@{MemDepUnit}!findInHash@{findInHash}}
\index{findInHash@{findInHash}!MemDepUnit@{MemDepUnit}}
\subsubsection[{findInHash}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemDepUnit}$<$ MemDepPred, Impl $>$::{\bf MemDepEntryPtr} \& findInHash (const {\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classMemDepUnit_a7c1fadef5550f6fd9382259565101bec}
Finds the memory dependence entry in the hash map. 


\begin{DoxyCode}
549 {
550     MemDepHashIt hash_it = memDepHash.find(inst->seqNum);
551 
552     assert(hash_it != memDepHash.end());
553 
554     return (*hash_it).second;
555 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_a0b3a45df958cbefd5455ff2aa1418bb4}{
\index{MemDepUnit@{MemDepUnit}!init@{init}}
\index{init@{init}!MemDepUnit@{MemDepUnit}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init (DerivO3CPUParams $\ast$ {\em params}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_a0b3a45df958cbefd5455ff2aa1418bb4}
Initializes the unit with parameters and a thread id. 


\begin{DoxyCode}
99 {
100     DPRINTF(MemDepUnit, "Creating MemDepUnit %i object.\n",tid);
101 
102     _name = csprintf("%s.memDep%d", params->name, tid);
103     id = tid;
104 
105     depPred.init(params->store_set_clear_period, params->SSITSize,
106             params->LFSTSize);
107 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_a773e88db1aa010c3755e603493bf40ec}{
\index{MemDepUnit@{MemDepUnit}!insert@{insert}}
\index{insert@{insert}!MemDepUnit@{MemDepUnit}}
\subsubsection[{insert}]{\setlength{\rightskip}{0pt plus 5cm}void insert ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_a773e88db1aa010c3755e603493bf40ec}
Inserts a memory instruction. 


\begin{DoxyCode}
162 {
163     ThreadID tid = inst->threadNumber;
164 
165     MemDepEntryPtr inst_entry = new MemDepEntry(inst);
166 
167     // Add the MemDepEntry to the hash.
168     memDepHash.insert(
169         std::pair<InstSeqNum, MemDepEntryPtr>(inst->seqNum, inst_entry));
170 #ifdef DEBUG
171     MemDepEntry::memdep_insert++;
172 #endif
173 
174     instList[tid].push_back(inst);
175 
176     inst_entry->listIt = --(instList[tid].end());
177 
178     // Check any barriers and the dependence predictor for any
179     // producing memrefs/stores.
180     InstSeqNum producing_store;
181     if (inst->isLoad() && loadBarrier) {
182         DPRINTF(MemDepUnit, "Load barrier [sn:%lli] in flight\n",
183                 loadBarrierSN);
184         producing_store = loadBarrierSN;
185     } else if (inst->isStore() && storeBarrier) {
186         DPRINTF(MemDepUnit, "Store barrier [sn:%lli] in flight\n",
187                 storeBarrierSN);
188         producing_store = storeBarrierSN;
189     } else {
190         producing_store = depPred.checkInst(inst->instAddr());
191     }
192 
193     MemDepEntryPtr store_entry = NULL;
194 
195     // If there is a producing store, try to find the entry.
196     if (producing_store != 0) {
197         DPRINTF(MemDepUnit, "Searching for producer\n");
198         MemDepHashIt hash_it = memDepHash.find(producing_store);
199 
200         if (hash_it != memDepHash.end()) {
201             store_entry = (*hash_it).second;
202             DPRINTF(MemDepUnit, "Proucer found\n");
203         }
204     }
205 
206     // If no store entry, then instruction can issue as soon as the registers
207     // are ready.
208     if (!store_entry) {
209         DPRINTF(MemDepUnit, "No dependency for inst PC "
210                 "%s [sn:%lli].\n", inst->pcState(), inst->seqNum);
211 
212         inst_entry->memDepReady = true;
213 
214         if (inst->readyToIssue()) {
215             inst_entry->regsReady = true;
216 
217             moveToReady(inst_entry);
218         }
219     } else {
220         // Otherwise make the instruction dependent on the store/barrier.
221         DPRINTF(MemDepUnit, "Adding to dependency list; "
222                 "inst PC %s is dependent on [sn:%lli].\n",
223                 inst->pcState(), producing_store);
224 
225         if (inst->readyToIssue()) {
226             inst_entry->regsReady = true;
227         }
228 
229         // Clear the bit saying this instruction can issue.
230         inst->clearCanIssue();
231 
232         // Add this instruction to the list of dependents.
233         store_entry->dependInsts.push_back(inst_entry);
234 
235         if (inst->isLoad()) {
236             ++conflictingLoads;
237         } else {
238             ++conflictingStores;
239         }
240     }
241 
242     if (inst->isStore()) {
243         DPRINTF(MemDepUnit, "Inserting store PC %s [sn:%lli].\n",
244                 inst->pcState(), inst->seqNum);
245 
246         depPred.insertStore(inst->instAddr(), inst->seqNum, inst->threadNumber);
247 
248         ++insertedStores;
249     } else if (inst->isLoad()) {
250         ++insertedLoads;
251     } else {
252         panic("Unknown type! (most likely a barrier).");
253     }
254 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_ae556f19566bae9c4f55350eab17abacd}{
\index{MemDepUnit@{MemDepUnit}!insertBarrier@{insertBarrier}}
\index{insertBarrier@{insertBarrier}!MemDepUnit@{MemDepUnit}}
\subsubsection[{insertBarrier}]{\setlength{\rightskip}{0pt plus 5cm}void insertBarrier ({\bf DynInstPtr} \& {\em barr\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_ae556f19566bae9c4f55350eab17abacd}
Inserts a barrier instruction. 


\begin{DoxyCode}
295 {
296     InstSeqNum barr_sn = barr_inst->seqNum;
297     // Memory barriers block loads and stores, write barriers only stores.
298     if (barr_inst->isMemBarrier()) {
299         loadBarrier = true;
300         loadBarrierSN = barr_sn;
301         storeBarrier = true;
302         storeBarrierSN = barr_sn;
303         DPRINTF(MemDepUnit, "Inserted a memory barrier %s SN:%lli\n",
304                 barr_inst->pcState(),barr_sn);
305     } else if (barr_inst->isWriteBarrier()) {
306         storeBarrier = true;
307         storeBarrierSN = barr_sn;
308         DPRINTF(MemDepUnit, "Inserted a write barrier\n");
309     }
310 
311     ThreadID tid = barr_inst->threadNumber;
312 
313     MemDepEntryPtr inst_entry = new MemDepEntry(barr_inst);
314 
315     // Add the MemDepEntry to the hash.
316     memDepHash.insert(
317         std::pair<InstSeqNum, MemDepEntryPtr>(barr_sn, inst_entry));
318 #ifdef DEBUG
319     MemDepEntry::memdep_insert++;
320 #endif
321 
322     // Add the instruction to the instruction list.
323     instList[tid].push_back(barr_inst);
324 
325     inst_entry->listIt = --(instList[tid].end());
326 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_ad7036279ba36a8cfaf65554d1a5dbaac}{
\index{MemDepUnit@{MemDepUnit}!insertNonSpec@{insertNonSpec}}
\index{insertNonSpec@{insertNonSpec}!MemDepUnit@{MemDepUnit}}
\subsubsection[{insertNonSpec}]{\setlength{\rightskip}{0pt plus 5cm}void insertNonSpec ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_ad7036279ba36a8cfaf65554d1a5dbaac}
Inserts a non-\/speculative memory instruction. 


\begin{DoxyCode}
259 {
260     ThreadID tid = inst->threadNumber;
261 
262     MemDepEntryPtr inst_entry = new MemDepEntry(inst);
263 
264     // Insert the MemDepEntry into the hash.
265     memDepHash.insert(
266         std::pair<InstSeqNum, MemDepEntryPtr>(inst->seqNum, inst_entry));
267 #ifdef DEBUG
268     MemDepEntry::memdep_insert++;
269 #endif
270 
271     // Add the instruction to the list.
272     instList[tid].push_back(inst);
273 
274     inst_entry->listIt = --(instList[tid].end());
275 
276     // Might want to turn this part into an inline function or something.
277     // It's shared between both insert functions.
278     if (inst->isStore()) {
279         DPRINTF(MemDepUnit, "Inserting store PC %s [sn:%lli].\n",
280                 inst->pcState(), inst->seqNum);
281 
282         depPred.insertStore(inst->instAddr(), inst->seqNum, inst->threadNumber);
283 
284         ++insertedStores;
285     } else if (inst->isLoad()) {
286         ++insertedLoads;
287     } else {
288         panic("Unknown type! (most likely a barrier).");
289     }
290 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_a6abd0e2390123c2fe82ab377b76b5347}{
\index{MemDepUnit@{MemDepUnit}!issue@{issue}}
\index{issue@{issue}!MemDepUnit@{MemDepUnit}}
\subsubsection[{issue}]{\setlength{\rightskip}{0pt plus 5cm}void issue ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_a6abd0e2390123c2fe82ab377b76b5347}
Issues the given instruction 


\begin{DoxyCode}
539 {
540     DPRINTF(MemDepUnit, "Issuing instruction PC %#x [sn:%lli].\n",
541             inst->instAddr(), inst->seqNum);
542 
543     depPred.issued(inst->instAddr(), inst->seqNum, inst->isStore());
544 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_ac1e743ad9d95132dd76847a784259e11}{
\index{MemDepUnit@{MemDepUnit}!moveToReady@{moveToReady}}
\index{moveToReady@{moveToReady}!MemDepUnit@{MemDepUnit}}
\subsubsection[{moveToReady}]{\setlength{\rightskip}{0pt plus 5cm}void moveToReady ({\bf MemDepEntryPtr} \& {\em ready\_\-inst\_\-entry})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classMemDepUnit_ac1e743ad9d95132dd76847a784259e11}
Moves an entry to the ready list. 


\begin{DoxyCode}
560 {
561     DPRINTF(MemDepUnit, "Adding instruction [sn:%lli] "
562             "to the ready list.\n", woken_inst_entry->inst->seqNum);
563 
564     assert(!woken_inst_entry->squashed);
565 
566     iqPtr->addReadyMemInst(woken_inst_entry->inst);
567 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{MemDepUnit@{MemDepUnit}!name@{name}}
\index{name@{name}!MemDepUnit@{MemDepUnit}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_a37627d5d5bba7f4a8690c71c2ab3cb07}
Returns the name of the memory dependence unit. 


\begin{DoxyCode}
99 { return _name; }
\end{DoxyCode}
\hypertarget{classMemDepUnit_aa85e9b95e406478a19cb070b13b89c85}{
\index{MemDepUnit@{MemDepUnit}!nonSpecInstReady@{nonSpecInstReady}}
\index{nonSpecInstReady@{nonSpecInstReady}!MemDepUnit@{MemDepUnit}}
\subsubsection[{nonSpecInstReady}]{\setlength{\rightskip}{0pt plus 5cm}void nonSpecInstReady ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_aa85e9b95e406478a19cb070b13b89c85}
Indicate that a non-\/speculative instruction is ready. 


\begin{DoxyCode}
354 {
355     DPRINTF(MemDepUnit, "Marking non speculative "
356             "instruction PC %s as ready [sn:%lli].\n",
357             inst->pcState(), inst->seqNum);
358 
359     MemDepEntryPtr inst_entry = findInHash(inst);
360 
361     moveToReady(inst_entry);
362 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_a386af6dbeff30f5152fd5dc076143ff6}{
\index{MemDepUnit@{MemDepUnit}!regsReady@{regsReady}}
\index{regsReady@{regsReady}!MemDepUnit@{MemDepUnit}}
\subsubsection[{regsReady}]{\setlength{\rightskip}{0pt plus 5cm}void regsReady ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_a386af6dbeff30f5152fd5dc076143ff6}
Indicate that an instruction has its registers ready. 


\begin{DoxyCode}
331 {
332     DPRINTF(MemDepUnit, "Marking registers as ready for "
333             "instruction PC %s [sn:%lli].\n",
334             inst->pcState(), inst->seqNum);
335 
336     MemDepEntryPtr inst_entry = findInHash(inst);
337 
338     inst_entry->regsReady = true;
339 
340     if (inst_entry->memDepReady) {
341         DPRINTF(MemDepUnit, "Instruction has its memory "
342                 "dependencies resolved, adding it to the ready list.\n");
343 
344         moveToReady(inst_entry);
345     } else {
346         DPRINTF(MemDepUnit, "Instruction still waiting on "
347                 "memory dependency.\n");
348     }
349 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{MemDepUnit@{MemDepUnit}!regStats@{regStats}}
\index{regStats@{regStats}!MemDepUnit@{MemDepUnit}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classMemDepUnit_a4dc637449366fcdfc4e764cdf12d9b11}
Registers statistics. 

\hyperlink{classResource_ac1739a9be0fbd5d96cf441cd3b2c1c78}{Resource}を再定義しています。


\begin{DoxyCode}
112 {
113     insertedLoads
114         .name(name() + ".insertedLoads")
115         .desc("Number of loads inserted to the mem dependence unit.");
116 
117     insertedStores
118         .name(name() + ".insertedStores")
119         .desc("Number of stores inserted to the mem dependence unit.");
120 
121     conflictingLoads
122         .name(name() + ".conflictingLoads")
123         .desc("Number of conflicting loads.");
124 
125     conflictingStores
126         .name(name() + ".conflictingStores")
127         .desc("Number of conflicting stores.");
128 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_ace9b968c62d08a19c21a17b57bfb52fe}{
\index{MemDepUnit@{MemDepUnit}!replay@{replay}}
\index{replay@{replay}!MemDepUnit@{MemDepUnit}}
\subsubsection[{replay}]{\setlength{\rightskip}{0pt plus 5cm}void replay ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_ace9b968c62d08a19c21a17b57bfb52fe}
Replays all instructions that have been rescheduled by moving them to the ready list. 


\begin{DoxyCode}
374 {
375     DynInstPtr temp_inst;
376 
377     // For now this replay function replays all waiting memory ops.
378     while (!instsToReplay.empty()) {
379         temp_inst = instsToReplay.front();
380 
381         MemDepEntryPtr inst_entry = findInHash(temp_inst);
382 
383         DPRINTF(MemDepUnit, "Replaying mem instruction PC %s [sn:%lli].\n",
384                 temp_inst->pcState(), temp_inst->seqNum);
385 
386         moveToReady(inst_entry);
387 
388         instsToReplay.pop_front();
389     }
390 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_a6a8d5eec636c2815cb1bc7ca3c467412}{
\index{MemDepUnit@{MemDepUnit}!reschedule@{reschedule}}
\index{reschedule@{reschedule}!MemDepUnit@{MemDepUnit}}
\subsubsection[{reschedule}]{\setlength{\rightskip}{0pt plus 5cm}void reschedule ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_a6a8d5eec636c2815cb1bc7ca3c467412}
Reschedules an instruction to be re-\/executed. 


\begin{DoxyCode}
367 {
368     instsToReplay.push_back(inst);
369 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_a9f2164f7d32d0906f0818ac724921840}{
\index{MemDepUnit@{MemDepUnit}!setIQ@{setIQ}}
\index{setIQ@{setIQ}!MemDepUnit@{MemDepUnit}}
\subsubsection[{setIQ}]{\setlength{\rightskip}{0pt plus 5cm}void setIQ ({\bf InstructionQueue}$<$ Impl $>$ $\ast$ {\em iq\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_a9f2164f7d32d0906f0818ac724921840}
Sets the pointer to the IQ. 


\begin{DoxyCode}
155 {
156     iqPtr = iq_ptr;
157 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_a74283dfde2ab06c84e10bd85000c168b}{
\index{MemDepUnit@{MemDepUnit}!squash@{squash}}
\index{squash@{squash}!MemDepUnit@{MemDepUnit}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash (const {\bf InstSeqNum} \& {\em squashed\_\-num}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_a74283dfde2ab06c84e10bd85000c168b}
Squashes all instructions up until a given sequence number for a specific thread. 


\begin{DoxyCode}
474 {
475     if (!instsToReplay.empty()) {
476         ListIt replay_it = instsToReplay.begin();
477         while (replay_it != instsToReplay.end()) {
478             if ((*replay_it)->threadNumber == tid &&
479                 (*replay_it)->seqNum > squashed_num) {
480                 instsToReplay.erase(replay_it++);
481             } else {
482                 ++replay_it;
483             }
484         }
485     }
486 
487     ListIt squash_it = instList[tid].end();
488     --squash_it;
489 
490     MemDepHashIt hash_it;
491 
492     while (!instList[tid].empty() &&
493            (*squash_it)->seqNum > squashed_num) {
494 
495         DPRINTF(MemDepUnit, "Squashing inst [sn:%lli]\n",
496                 (*squash_it)->seqNum);
497 
498         if ((*squash_it)->seqNum == loadBarrierSN)
499               loadBarrier = false;
500 
501         if ((*squash_it)->seqNum == storeBarrierSN)
502               storeBarrier = false;
503 
504         hash_it = memDepHash.find((*squash_it)->seqNum);
505 
506         assert(hash_it != memDepHash.end());
507 
508         (*hash_it).second->squashed = true;
509 
510         (*hash_it).second = NULL;
511 
512         memDepHash.erase(hash_it);
513 #ifdef DEBUG
514         MemDepEntry::memdep_erase++;
515 #endif
516 
517         instList[tid].erase(squash_it--);
518     }
519 
520     // Tell the dependency predictor to squash as well.
521     depPred.squash(squashed_num, tid);
522 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_a8674059ce345e23aac5086b2c3e24a43}{
\index{MemDepUnit@{MemDepUnit}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!MemDepUnit@{MemDepUnit}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_a8674059ce345e23aac5086b2c3e24a43}
Takes over from another CPU's thread. 


\begin{DoxyCode}
145 {
146     // Be sure to reset all state.
147     loadBarrier = storeBarrier = false;
148     loadBarrierSN = storeBarrierSN = 0;
149     depPred.clear();
150 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_aac3ab1b2d6cc44bd1e7c42bf39538316}{
\index{MemDepUnit@{MemDepUnit}!violation@{violation}}
\index{violation@{violation}!MemDepUnit@{MemDepUnit}}
\subsubsection[{violation}]{\setlength{\rightskip}{0pt plus 5cm}void violation ({\bf DynInstPtr} \& {\em store\_\-inst}, \/  {\bf DynInstPtr} \& {\em violating\_\-load})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_aac3ab1b2d6cc44bd1e7c42bf39538316}
Indicates an ordering violation between a store and a younger load. 


\begin{DoxyCode}
528 {
529     DPRINTF(MemDepUnit, "Passing violating PCs to store sets,"
530             " load: %#x, store: %#x\n", violating_load->instAddr(),
531             store_inst->instAddr());
532     // Tell the memory dependence unit of the violation.
533     depPred.violation(store_inst->instAddr(), violating_load->instAddr());
534 }
\end{DoxyCode}
\hypertarget{classMemDepUnit_a84834d31005dcede47e334bfee5b52d3}{
\index{MemDepUnit@{MemDepUnit}!wakeDependents@{wakeDependents}}
\index{wakeDependents@{wakeDependents}!MemDepUnit@{MemDepUnit}}
\subsubsection[{wakeDependents}]{\setlength{\rightskip}{0pt plus 5cm}void wakeDependents ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMemDepUnit_a84834d31005dcede47e334bfee5b52d3}
Wakes any dependents of a memory instruction. 


\begin{DoxyCode}
440 {
441     // Only stores and barriers have dependents.
442     if (!inst->isStore() && !inst->isMemBarrier() && !inst->isWriteBarrier()) {
443         return;
444     }
445 
446     MemDepEntryPtr inst_entry = findInHash(inst);
447 
448     for (int i = 0; i < inst_entry->dependInsts.size(); ++i ) {
449         MemDepEntryPtr woken_inst = inst_entry->dependInsts[i];
450 
451         if (!woken_inst->inst) {
452             // Potentially removed mem dep entries could be on this list
453             continue;
454         }
455 
456         DPRINTF(MemDepUnit, "Waking up a dependent inst, "
457                 "[sn:%lli].\n",
458                 woken_inst->inst->seqNum);
459 
460         if (woken_inst->regsReady && !woken_inst->squashed) {
461             moveToReady(woken_inst);
462         } else {
463             woken_inst->memDepReady = true;
464         }
465     }
466 
467     inst_entry->dependInsts.clear();
468 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classMemDepUnit_aaf2ed934b37cbbd236fdd1b01a5f5005}{
\index{MemDepUnit@{MemDepUnit}!\_\-name@{\_\-name}}
\index{\_\-name@{\_\-name}!MemDepUnit@{MemDepUnit}}
\subsubsection[{\_\-name}]{\setlength{\rightskip}{0pt plus 5cm}std::string {\bf \_\-name}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemDepUnit_aaf2ed934b37cbbd236fdd1b01a5f5005}
\hypertarget{classMemDepUnit_ad5a10b8601553be6d0f3bfa3495dd5a5}{
\index{MemDepUnit@{MemDepUnit}!conflictingLoads@{conflictingLoads}}
\index{conflictingLoads@{conflictingLoads}!MemDepUnit@{MemDepUnit}}
\subsubsection[{conflictingLoads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf conflictingLoads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemDepUnit_ad5a10b8601553be6d0f3bfa3495dd5a5}
Stat for number of conflicting loads that had to wait for a store. \hypertarget{classMemDepUnit_ab481d99d6034a2db5e14efd072448635}{
\index{MemDepUnit@{MemDepUnit}!conflictingStores@{conflictingStores}}
\index{conflictingStores@{conflictingStores}!MemDepUnit@{MemDepUnit}}
\subsubsection[{conflictingStores}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf conflictingStores}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemDepUnit_ab481d99d6034a2db5e14efd072448635}
Stat for number of conflicting stores that had to wait for a store. \hypertarget{classMemDepUnit_a2b12193ddce173c34c8c54e0201925bc}{
\index{MemDepUnit@{MemDepUnit}!depPred@{depPred}}
\index{depPred@{depPred}!MemDepUnit@{MemDepUnit}}
\subsubsection[{depPred}]{\setlength{\rightskip}{0pt plus 5cm}MemDepPred {\bf depPred}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemDepUnit_a2b12193ddce173c34c8c54e0201925bc}
The memory dependence predictor. It is accessed upon new instructions being added to the IQ, and responds by telling this unit what instruction the newly added instruction is dependent upon. \hypertarget{classMemDepUnit_a7441ef0865bcb3db9b8064dd7375c1ea}{
\index{MemDepUnit@{MemDepUnit}!id@{id}}
\index{id@{id}!MemDepUnit@{MemDepUnit}}
\subsubsection[{id}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf id}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemDepUnit_a7441ef0865bcb3db9b8064dd7375c1ea}
The thread id of this memory dependence unit. 

\hyperlink{classResource_a7441ef0865bcb3db9b8064dd7375c1ea}{Resource}を再定義しています。\hypertarget{classMemDepUnit_a7810bf3f4630c9898e404e7d46900ad5}{
\index{MemDepUnit@{MemDepUnit}!insertedLoads@{insertedLoads}}
\index{insertedLoads@{insertedLoads}!MemDepUnit@{MemDepUnit}}
\subsubsection[{insertedLoads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf insertedLoads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemDepUnit_a7810bf3f4630c9898e404e7d46900ad5}
Stat for number of inserted loads. \hypertarget{classMemDepUnit_a5f8daf9e076650e5b9f2f9a6876a3bf7}{
\index{MemDepUnit@{MemDepUnit}!insertedStores@{insertedStores}}
\index{insertedStores@{insertedStores}!MemDepUnit@{MemDepUnit}}
\subsubsection[{insertedStores}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf insertedStores}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemDepUnit_a5f8daf9e076650e5b9f2f9a6876a3bf7}
Stat for number of inserted stores. \hypertarget{classMemDepUnit_a7f2828a4f877a4a4d4b85a6788536b82}{
\index{MemDepUnit@{MemDepUnit}!instList@{instList}}
\index{instList@{instList}!MemDepUnit@{MemDepUnit}}
\subsubsection[{instList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf instList}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemDepUnit_a7f2828a4f877a4a4d4b85a6788536b82}
A list of all instructions in the memory dependence unit. \hypertarget{classMemDepUnit_a4c7e8849e2a4606478c2e93f9dcb6c54}{
\index{MemDepUnit@{MemDepUnit}!instsToReplay@{instsToReplay}}
\index{instsToReplay@{instsToReplay}!MemDepUnit@{MemDepUnit}}
\subsubsection[{instsToReplay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf instsToReplay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemDepUnit_a4c7e8849e2a4606478c2e93f9dcb6c54}
A list of all instructions that are going to be replayed. \hypertarget{classMemDepUnit_ae1fd26993119273f381c42894e2672c6}{
\index{MemDepUnit@{MemDepUnit}!iqPtr@{iqPtr}}
\index{iqPtr@{iqPtr}!MemDepUnit@{MemDepUnit}}
\subsubsection[{iqPtr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstructionQueue}$<$Impl$>$$\ast$ {\bf iqPtr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemDepUnit_ae1fd26993119273f381c42894e2672c6}
Pointer to the IQ. \hypertarget{classMemDepUnit_a5db9914f1c33ab7cef8fdc6037f98775}{
\index{MemDepUnit@{MemDepUnit}!lastCycleGrad@{lastCycleGrad}}
\index{lastCycleGrad@{lastCycleGrad}!MemDepUnit@{MemDepUnit}}
\subsubsection[{lastCycleGrad}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf lastCycleGrad}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemDepUnit_a5db9914f1c33ab7cef8fdc6037f98775}
\hypertarget{classMemDepUnit_a84cd010b1d5bb1d8a72a2603a9b58393}{
\index{MemDepUnit@{MemDepUnit}!loadBarrier@{loadBarrier}}
\index{loadBarrier@{loadBarrier}!MemDepUnit@{MemDepUnit}}
\subsubsection[{loadBarrier}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf loadBarrier}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemDepUnit_a84cd010b1d5bb1d8a72a2603a9b58393}
Is there an outstanding load barrier that loads must wait on. \hypertarget{classMemDepUnit_adbdb10ce572ac89847d1541d471f0be6}{
\index{MemDepUnit@{MemDepUnit}!loadBarrierSN@{loadBarrierSN}}
\index{loadBarrierSN@{loadBarrierSN}!MemDepUnit@{MemDepUnit}}
\subsubsection[{loadBarrierSN}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf loadBarrierSN}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemDepUnit_adbdb10ce572ac89847d1541d471f0be6}
The sequence number of the load barrier. \hypertarget{classMemDepUnit_ac0b12f9eec0e0c6b639c7370177e5c36}{
\index{MemDepUnit@{MemDepUnit}!memDepHash@{memDepHash}}
\index{memDepHash@{memDepHash}!MemDepUnit@{MemDepUnit}}
\subsubsection[{memDepHash}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemDepHash} {\bf memDepHash}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemDepUnit_ac0b12f9eec0e0c6b639c7370177e5c36}
A hash map of all memory dependence entries. \hypertarget{classMemDepUnit_aa27d1c9b589af0c77a81c490021c7dcb}{
\index{MemDepUnit@{MemDepUnit}!nonSpecInstActive@{nonSpecInstActive}}
\index{nonSpecInstActive@{nonSpecInstActive}!MemDepUnit@{MemDepUnit}}
\subsubsection[{nonSpecInstActive}]{\setlength{\rightskip}{0pt plus 5cm}bool$\ast$ {\bf nonSpecInstActive}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemDepUnit_aa27d1c9b589af0c77a81c490021c7dcb}
\hypertarget{classMemDepUnit_a899b1bc10d38a0f725495bf2108479a3}{
\index{MemDepUnit@{MemDepUnit}!nonSpecSeqNum@{nonSpecSeqNum}}
\index{nonSpecSeqNum@{nonSpecSeqNum}!MemDepUnit@{MemDepUnit}}
\subsubsection[{nonSpecSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum}$\ast$ {\bf nonSpecSeqNum}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemDepUnit_a899b1bc10d38a0f725495bf2108479a3}
\hypertarget{classMemDepUnit_a9bd2235f4069b61f51af0d84d5115de5}{
\index{MemDepUnit@{MemDepUnit}!numCycleGrad@{numCycleGrad}}
\index{numCycleGrad@{numCycleGrad}!MemDepUnit@{MemDepUnit}}
\subsubsection[{numCycleGrad}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf numCycleGrad}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classMemDepUnit_a9bd2235f4069b61f51af0d84d5115de5}
\hypertarget{classMemDepUnit_ac066575fbaeda40cc6b2017292dfb0bf}{
\index{MemDepUnit@{MemDepUnit}!storeBarrier@{storeBarrier}}
\index{storeBarrier@{storeBarrier}!MemDepUnit@{MemDepUnit}}
\subsubsection[{storeBarrier}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf storeBarrier}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemDepUnit_ac066575fbaeda40cc6b2017292dfb0bf}
Is there an outstanding store barrier that loads must wait on. \hypertarget{classMemDepUnit_ae3e16866c4d84194ff7f414f00d71e94}{
\index{MemDepUnit@{MemDepUnit}!storeBarrierSN@{storeBarrierSN}}
\index{storeBarrierSN@{storeBarrierSN}!MemDepUnit@{MemDepUnit}}
\subsubsection[{storeBarrierSN}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf storeBarrierSN}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMemDepUnit_ae3e16866c4d84194ff7f414f00d71e94}
The sequence number of the store barrier. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/inorder/resources/\hyperlink{inorder_2resources_2mem__dep__unit_8hh}{mem\_\-dep\_\-unit.hh}\item 
cpu/o3/\hyperlink{o3_2mem__dep__unit_8hh}{mem\_\-dep\_\-unit.hh}\item 
cpu/o3/\hyperlink{mem__dep__unit__impl_8hh}{mem\_\-dep\_\-unit\_\-impl.hh}\end{DoxyCompactItemize}
