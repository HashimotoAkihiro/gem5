\hypertarget{classPacketQueue}{
\section{クラス PacketQueue}
\label{classPacketQueue}\index{PacketQueue@{PacketQueue}}
}


{\ttfamily \#include $<$packet\_\-queue.hh$>$}PacketQueueに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4cm]{classPacketQueue}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classPacketQueue_1_1DeferredPacket}{DeferredPacket}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
virtual const std::string \hyperlink{classPacketQueue_a2d319721a65496069642871a52e47056}{name} () const =0
\item 
bool \hyperlink{classPacketQueue_a8eb60d4744b6212ad749f3a586759266}{checkFunctional} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classPacketQueue_af99adfc2df426c1ebd4e1fcb804c7e4d}{schedSendEvent} (\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} when)
\item 
void \hyperlink{classPacketQueue_a9b0fd72bebb706403e57dd17daff1f40}{schedSendTiming} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} when, bool send\_\-as\_\-snoop=false)
\item 
void \hyperlink{classPacketQueue_a549fc33ae3e5c345795b8384a91fb544}{retry} ()
\item 
unsigned int \hyperlink{classPacketQueue_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classPacketQueue_a052ea90ae061f6d3b53d6dee3b3076f3}{deferredPacketReady} ()
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classPacketQueue_a9a43740cba452beb76e08a890f59c70d}{deferredPacketReadyTime} ()
\item 
virtual void \hyperlink{classPacketQueue_a3ce3f4b79c2caf000124b3de8ba9157c}{sendDeferredPacket} ()
\item 
void \hyperlink{classPacketQueue_a391c414b53eb45782e37bc539608e477}{trySendTiming} ()
\item 
virtual bool \hyperlink{classPacketQueue_a3111a75f1ac04df57de8a34ded64a82d}{sendTiming} (\hyperlink{classPacket}{PacketPtr} pkt, bool send\_\-as\_\-snoop)=0
\item 
void \hyperlink{classPacketQueue_a34d5599fd6c275e889527628932a224e}{scheduleSend} (\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} time=\hyperlink{base_2types_8hh_abe940b1b328825e234da719447e15ca5}{MaxTick})
\item 
virtual void \hyperlink{classPacketQueue_af60d9c2c17fb4c9ebc5384a7e0c9f289}{recvRangeChange} ()
\item 
\hyperlink{classPacketQueue_aa30b1ba397193e7094a87b2a945f7237}{PacketQueue} (\hyperlink{classEventManager}{EventManager} \&\_\-em, const std::string \&\_\-label)
\item 
virtual \hyperlink{classPacketQueue_a3efbe442356f38106e0b67f41070245a}{$\sim$PacketQueue} ()
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
const std::string \hyperlink{classPacketQueue_ae471a4c4073716b769170188214fe93d}{label}
\item 
bool \hyperlink{classPacketQueue_ad4363dd8230c71676c4cad8dd5a0b8a7}{waitingOnRetry}
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classPacketQueue_1_1DeferredPacket}{DeferredPacket} $>$ \hyperlink{classPacketQueue_ae5fc25ae70b3044ebae593494f7f58c8}{DeferredPacketList}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classPacketQueue_1_1DeferredPacket}{DeferredPacket} $>$::iterator \hyperlink{classPacketQueue_ad01f0c4d4677a8aeea2433ba7ef9f6fd}{DeferredPacketIterator}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classPacketQueue_a09299dd6109496c23923f9e4f45b6f89}{processSendEvent} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classstd_1_1list}{DeferredPacketList} \hyperlink{classPacketQueue_a32a79d68b8d8f4f33bc27f59809eeae7}{transmitList}
\item 
\hyperlink{classEventManager}{EventManager} \& \hyperlink{classPacketQueue_a52e0dd5074be0e61097a0dadf9cda146}{em}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classPacketQueue}{PacketQueue},\&PacketQueue::processSendEvent $>$ \hyperlink{classPacketQueue_a2fc6007386af1667bd97ee56a71079fb}{sendEvent}
\item 
\hyperlink{classDrainManager}{DrainManager} $\ast$ \hyperlink{classPacketQueue_a329b71fb934a93312ca0aacbf5a3f982}{drainManager}
\end{DoxyCompactItemize}


\subsection{説明}
A packet queue is a class that holds deferred packets and later sends them using the associated slave port or master port. 

\subsection{型定義}
\hypertarget{classPacketQueue_ad01f0c4d4677a8aeea2433ba7ef9f6fd}{
\index{PacketQueue@{PacketQueue}!DeferredPacketIterator@{DeferredPacketIterator}}
\index{DeferredPacketIterator@{DeferredPacketIterator}!PacketQueue@{PacketQueue}}
\subsubsection[{DeferredPacketIterator}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf DeferredPacket}$>$::iterator {\bf DeferredPacketIterator}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPacketQueue_ad01f0c4d4677a8aeea2433ba7ef9f6fd}
\hypertarget{classPacketQueue_ae5fc25ae70b3044ebae593494f7f58c8}{
\index{PacketQueue@{PacketQueue}!DeferredPacketList@{DeferredPacketList}}
\index{DeferredPacketList@{DeferredPacketList}!PacketQueue@{PacketQueue}}
\subsubsection[{DeferredPacketList}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf DeferredPacket}$>$ {\bf DeferredPacketList}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPacketQueue_ae5fc25ae70b3044ebae593494f7f58c8}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classPacketQueue_aa30b1ba397193e7094a87b2a945f7237}{
\index{PacketQueue@{PacketQueue}!PacketQueue@{PacketQueue}}
\index{PacketQueue@{PacketQueue}!PacketQueue@{PacketQueue}}
\subsubsection[{PacketQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketQueue} ({\bf EventManager} \& {\em \_\-em}, \/  const std::string \& {\em \_\-label})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPacketQueue_aa30b1ba397193e7094a87b2a945f7237}
Create a packet queue, linked to an event manager, and a label that will be used for functional print request packets.


\begin{DoxyParams}{引数}
\item[{\em \_\-em}]\hyperlink{classEvent}{Event} manager used for scheduling this queue \item[{\em \_\-label}]Label to push on the label stack for print request packets \end{DoxyParams}



\begin{DoxyCode}
52     : em(_em), sendEvent(this), drainManager(NULL), label(_label),
53       waitingOnRetry(false)
54 {
55 }
\end{DoxyCode}
\hypertarget{classPacketQueue_a3efbe442356f38106e0b67f41070245a}{
\index{PacketQueue@{PacketQueue}!$\sim$PacketQueue@{$\sim$PacketQueue}}
\index{$\sim$PacketQueue@{$\sim$PacketQueue}!PacketQueue@{PacketQueue}}
\subsubsection[{$\sim$PacketQueue}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf PacketQueue} ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classPacketQueue_a3efbe442356f38106e0b67f41070245a}
Virtual desctructor since the class may be used as a base class. 


\begin{DoxyCode}
58 {
59 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classPacketQueue_a8eb60d4744b6212ad749f3a586759266}{
\index{PacketQueue@{PacketQueue}!checkFunctional@{checkFunctional}}
\index{checkFunctional@{checkFunctional}!PacketQueue@{PacketQueue}}
\subsubsection[{checkFunctional}]{\setlength{\rightskip}{0pt plus 5cm}bool checkFunctional ({\bf PacketPtr} {\em pkt})}}
\label{classPacketQueue_a8eb60d4744b6212ad749f3a586759266}
\hyperlink{classCheck}{Check} the list of buffered packets against the supplied functional request. 


\begin{DoxyCode}
71 {
72     pkt->pushLabel(label);
73 
74     DeferredPacketIterator i = transmitList.begin();
75     DeferredPacketIterator end = transmitList.end();
76     bool found = false;
77 
78     while (!found && i != end) {
79         // If the buffered packet contains data, and it overlaps the
80         // current packet, then update data
81         found = pkt->checkFunctional(i->pkt);
82         ++i;
83     }
84 
85     pkt->popLabel();
86 
87     return found;
88 }
\end{DoxyCode}
\hypertarget{classPacketQueue_a052ea90ae061f6d3b53d6dee3b3076f3}{
\index{PacketQueue@{PacketQueue}!deferredPacketReady@{deferredPacketReady}}
\index{deferredPacketReady@{deferredPacketReady}!PacketQueue@{PacketQueue}}
\subsubsection[{deferredPacketReady}]{\setlength{\rightskip}{0pt plus 5cm}bool deferredPacketReady ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classPacketQueue_a052ea90ae061f6d3b53d6dee3b3076f3}
\hyperlink{classCheck}{Check} whether we have a packet ready to go on the transmit list. 


\begin{DoxyCode}
113     { return !transmitList.empty() && transmitList.front().tick <= curTick(); }
\end{DoxyCode}
\hypertarget{classPacketQueue_a9a43740cba452beb76e08a890f59c70d}{
\index{PacketQueue@{PacketQueue}!deferredPacketReadyTime@{deferredPacketReadyTime}}
\index{deferredPacketReadyTime@{deferredPacketReadyTime}!PacketQueue@{PacketQueue}}
\subsubsection[{deferredPacketReadyTime}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} deferredPacketReadyTime ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classPacketQueue_a9a43740cba452beb76e08a890f59c70d}



\begin{DoxyCode}
116     { return transmitList.empty() ? MaxTick : transmitList.front().tick; }
\end{DoxyCode}
\hypertarget{classPacketQueue_aa8a18d230dba7a674ac8a0b4f35bc36a}{
\index{PacketQueue@{PacketQueue}!drain@{drain}}
\index{drain@{drain}!PacketQueue@{PacketQueue}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em drainManager})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classPacketQueue_aa8a18d230dba7a674ac8a0b4f35bc36a}
Determine if an object needs draining and register a \hyperlink{classDrainManager}{DrainManager}.

When draining the state of an object, the simulator calls drain with a pointer to a drain manager. If the object does not need further simulation to drain internal buffers, it switched to the Drained state and returns 0, otherwise it switches to the Draining state and returns the number of times that it will call \hyperlink{classEvent_a142b75b68a6291400e20fb0dd905b1c8}{Event::process()} on the drain event. Most objects are expected to return either 0 or 1.

\begin{DoxyNote}{覚え書き}
An object that has entered the Drained state can be disturbed by other objects in the system and consequently be forced to enter the Draining state again. The simulator therefore repeats the draining process until all objects return 0 on the first call to \hyperlink{classPacketQueue_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain()}.
\end{DoxyNote}

\begin{DoxyParams}{引数}
\item[{\em drainManager}]\hyperlink{classDrainManager}{DrainManager} to use to inform the simulator when draining has completed.\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
0 if the object is ready for serialization now, $>$0 if it needs further simulation. 
\end{DoxyReturn}


\hyperlink{classDrainable_a1ed42c14f2f622ea6b0df3865e89c8b4}{Drainable}を実装しています。


\begin{DoxyCode}
218 {
219     if (transmitList.empty() && !sendEvent.scheduled())
220         return 0;
221     DPRINTF(Drain, "PacketQueue not drained\n");
222     drainManager = dm;
223     return 1;
224 }
\end{DoxyCode}
\hypertarget{classPacketQueue_a2d319721a65496069642871a52e47056}{
\index{PacketQueue@{PacketQueue}!name@{name}}
\index{name@{name}!PacketQueue@{PacketQueue}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}virtual const std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classPacketQueue_a2d319721a65496069642871a52e47056}
Provide a name to simplify debugging.

\begin{DoxyReturn}{戻り値}
A complete name, appended to module and port 
\end{DoxyReturn}


\hyperlink{classMasterPacketQueue_a6490f765a824ced1cc94979609fe7e07}{MasterPacketQueue}, と \hyperlink{classSlavePacketQueue_a6490f765a824ced1cc94979609fe7e07}{SlavePacketQueue}で実装されています。\hypertarget{classPacketQueue_a09299dd6109496c23923f9e4f45b6f89}{
\index{PacketQueue@{PacketQueue}!processSendEvent@{processSendEvent}}
\index{processSendEvent@{processSendEvent}!PacketQueue@{PacketQueue}}
\subsubsection[{processSendEvent}]{\setlength{\rightskip}{0pt plus 5cm}void processSendEvent ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPacketQueue_a09299dd6109496c23923f9e4f45b6f89}
This function attempts to send deferred packets. Scheduled to be called in the future via SendEvent. 


\begin{DoxyCode}
211 {
212     assert(!waitingOnRetry);
213     sendDeferredPacket();
214 }
\end{DoxyCode}
\hypertarget{classPacketQueue_af60d9c2c17fb4c9ebc5384a7e0c9f289}{
\index{PacketQueue@{PacketQueue}!recvRangeChange@{recvRangeChange}}
\index{recvRangeChange@{recvRangeChange}!PacketQueue@{PacketQueue}}
\subsubsection[{recvRangeChange}]{\setlength{\rightskip}{0pt plus 5cm}virtual void recvRangeChange ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classPacketQueue_af60d9c2c17fb4c9ebc5384a7e0c9f289}
Simple ports are generally used as slave ports (i.e. the respond to requests) and thus do not expect to receive any range changes (as the neighbouring port has a master role and do not have any address ranges. A subclass can override the default behaviuor if needed. 


\begin{DoxyCode}
156 { }
\end{DoxyCode}
\hypertarget{classPacketQueue_a549fc33ae3e5c345795b8384a91fb544}{
\index{PacketQueue@{PacketQueue}!retry@{retry}}
\index{retry@{retry}!PacketQueue@{PacketQueue}}
\subsubsection[{retry}]{\setlength{\rightskip}{0pt plus 5cm}void retry ()}}
\label{classPacketQueue_a549fc33ae3e5c345795b8384a91fb544}
Used by a port to notify the queue that a retry was received and that the queue can proceed and retry sending the packet that caused the wait. 


\begin{DoxyCode}
63 {
64     DPRINTF(PacketQueue, "Queue %s received retry\n", name());
65     assert(waitingOnRetry);
66     sendDeferredPacket();
67 }
\end{DoxyCode}
\hypertarget{classPacketQueue_af99adfc2df426c1ebd4e1fcb804c7e4d}{
\index{PacketQueue@{PacketQueue}!schedSendEvent@{schedSendEvent}}
\index{schedSendEvent@{schedSendEvent}!PacketQueue@{PacketQueue}}
\subsubsection[{schedSendEvent}]{\setlength{\rightskip}{0pt plus 5cm}void schedSendEvent ({\bf Tick} {\em when})}}
\label{classPacketQueue_af99adfc2df426c1ebd4e1fcb804c7e4d}
Schedule a send even if not already waiting for a retry. If the requested time is before an already scheduled send event it will be rescheduled.


\begin{DoxyParams}{引数}
\item[{\em when}]\end{DoxyParams}



\begin{DoxyCode}
92 {
93     // if we are waiting on a retry, do not schedule a send event, and
94     // instead rely on retry being called
95     if (waitingOnRetry) {
96         assert(!sendEvent.scheduled());
97         return;
98     }
99 
100     if (!sendEvent.scheduled()) {
101         em.schedule(&sendEvent, when);
102     } else if (sendEvent.when() > when) {
103         em.reschedule(&sendEvent, when);
104     }
105 }
\end{DoxyCode}
\hypertarget{classPacketQueue_a9b0fd72bebb706403e57dd17daff1f40}{
\index{PacketQueue@{PacketQueue}!schedSendTiming@{schedSendTiming}}
\index{schedSendTiming@{schedSendTiming}!PacketQueue@{PacketQueue}}
\subsubsection[{schedSendTiming}]{\setlength{\rightskip}{0pt plus 5cm}void schedSendTiming ({\bf PacketPtr} {\em pkt}, \/  {\bf Tick} {\em when}, \/  bool {\em send\_\-as\_\-snoop} = {\ttfamily false})}}
\label{classPacketQueue_a9b0fd72bebb706403e57dd17daff1f40}
Add a packet to the transmit list, and ensure that a processSendEvent is called in the future.


\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} to send \item[{\em when}]Absolute time (in ticks) to send packet \item[{\em send\_\-as\_\-snoop}]Send the packet as a snoop or not \end{DoxyParams}



\begin{DoxyCode}
109 {
110     DPRINTF(PacketQueue, "%s for %s address %x size %d\n", __func__,
111             pkt->cmdString(), pkt->getAddr(), pkt->getSize());
112     // we can still send a packet before the end of this tick
113     assert(when >= curTick());
114 
115     // express snoops should never be queued
116     assert(!pkt->isExpressSnoop());
117 
118     // add a very basic sanity check on the port to ensure the
119     // invisible buffer is not growing beyond reasonable limits
120     if (transmitList.size() > 100) {
121         panic("Packet queue %s has grown beyond 100 packets\n",
122               name());
123     }
124 
125     // nothing on the list, or earlier than current front element,
126     // schedule an event
127     if (transmitList.empty() || when < transmitList.front().tick) {
128         // note that currently we ignore a potentially outstanding retry
129         // and could in theory put a new packet at the head of the
130         // transmit list before retrying the existing packet
131         transmitList.push_front(DeferredPacket(when, pkt, send_as_snoop));
132         schedSendEvent(when);
133         return;
134     }
135 
136     // list is non-empty and this belongs at the end
137     if (when >= transmitList.back().tick) {
138         transmitList.push_back(DeferredPacket(when, pkt, send_as_snoop));
139         return;
140     }
141 
142     // this belongs in the middle somewhere, insertion sort
143     DeferredPacketIterator i = transmitList.begin();
144     ++i; // already checked for insertion at front
145     while (i != transmitList.end() && when >= i->tick)
146         ++i;
147     transmitList.insert(i, DeferredPacket(when, pkt, send_as_snoop));
148 }
\end{DoxyCode}
\hypertarget{classPacketQueue_a34d5599fd6c275e889527628932a224e}{
\index{PacketQueue@{PacketQueue}!scheduleSend@{scheduleSend}}
\index{scheduleSend@{scheduleSend}!PacketQueue@{PacketQueue}}
\subsubsection[{scheduleSend}]{\setlength{\rightskip}{0pt plus 5cm}void scheduleSend ({\bf Tick} {\em time} = {\ttfamily {\bf MaxTick}})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPacketQueue_a34d5599fd6c275e889527628932a224e}
Based on the transmit list, or the provided time, schedule a send event if there are packets to send. If we are idle and asked to drain then do so.


\begin{DoxyParams}{引数}
\item[{\em time}]an alternative time for the next send event \end{DoxyParams}



\begin{DoxyCode}
174 {
175     // the next ready time is either determined by the next deferred packet,
176     // or in the cache through the MSHR ready time
177     Tick nextReady = std::min(deferredPacketReadyTime(), time);
178 
179     if (nextReady != MaxTick) {
180         // if the sendTiming caused someone else to call our
181         // recvTiming we could already have an event scheduled, check
182         if (!sendEvent.scheduled())
183             em.schedule(&sendEvent, std::max(nextReady, curTick() + 1));
184     } else {
185         // no more to send, so if we're draining, we may be done
186         if (drainManager && transmitList.empty() && !sendEvent.scheduled()) {
187             DPRINTF(Drain, "PacketQueue done draining,"
188                     "processing drain event\n");
189             drainManager->signalDrainDone();
190             drainManager = NULL;
191         }
192     }
193 }
\end{DoxyCode}
\hypertarget{classPacketQueue_a3ce3f4b79c2caf000124b3de8ba9157c}{
\index{PacketQueue@{PacketQueue}!sendDeferredPacket@{sendDeferredPacket}}
\index{sendDeferredPacket@{sendDeferredPacket}!PacketQueue@{PacketQueue}}
\subsubsection[{sendDeferredPacket}]{\setlength{\rightskip}{0pt plus 5cm}void sendDeferredPacket ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classPacketQueue_a3ce3f4b79c2caf000124b3de8ba9157c}
Attempt to send the packet at the head of the transmit list. Caller must guarantee that the list is non-\/empty and that the head packet is scheduled for \hyperlink{statistics_8hh_a7acdccbf0d35ce0c159c0cdd36371b22}{curTick()} (or earlier). Note that a subclass of the \hyperlink{classPacketQueue}{PacketQueue} can override this method and thus change the behaviour (as done by the cache). 

\hyperlink{classCache_1_1MemSidePacketQueue_a3ce3f4b79c2caf000124b3de8ba9157c}{MemSidePacketQueue$<$ TagStore $>$}で再定義されています。


\begin{DoxyCode}
197 {
198     // try to send what is on the list, this will set waitingOnRetry
199     // accordingly
200     trySendTiming();
201 
202     // if we succeeded and are not waiting for a retry, schedule the
203     // next send
204     if (!waitingOnRetry) {
205         scheduleSend();
206     }
207 }
\end{DoxyCode}
\hypertarget{classPacketQueue_a3111a75f1ac04df57de8a34ded64a82d}{
\index{PacketQueue@{PacketQueue}!sendTiming@{sendTiming}}
\index{sendTiming@{sendTiming}!PacketQueue@{PacketQueue}}
\subsubsection[{sendTiming}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool sendTiming ({\bf PacketPtr} {\em pkt}, \/  bool {\em send\_\-as\_\-snoop})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classPacketQueue_a3111a75f1ac04df57de8a34ded64a82d}


\hyperlink{classMasterPacketQueue_a49e787c20f2f8d3e4fc0b8213bebcfc4}{MasterPacketQueue}, と \hyperlink{classSlavePacketQueue_a49e787c20f2f8d3e4fc0b8213bebcfc4}{SlavePacketQueue}で実装されています。\hypertarget{classPacketQueue_a391c414b53eb45782e37bc539608e477}{
\index{PacketQueue@{PacketQueue}!trySendTiming@{trySendTiming}}
\index{trySendTiming@{trySendTiming}!PacketQueue@{PacketQueue}}
\subsubsection[{trySendTiming}]{\setlength{\rightskip}{0pt plus 5cm}void trySendTiming ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPacketQueue_a391c414b53eb45782e37bc539608e477}
Attempt to send the packet at the front of the transmit list, and set waitingOnRetry accordingly. The packet is temporarily taken off the list, but put back at the front if not successfully sent. 


\begin{DoxyCode}
151 {
152     assert(deferredPacketReady());
153 
154     // take the next packet off the list here, as we might return to
155     // ourselves through the sendTiming call below
156     DeferredPacket dp = transmitList.front();
157     transmitList.pop_front();
158 
159     // use the appropriate implementation of sendTiming based on the
160     // type of port associated with the queue, and whether the packet
161     // is to be sent as a snoop or not
162     waitingOnRetry = !sendTiming(dp.pkt, dp.sendAsSnoop);
163 
164     if (waitingOnRetry) {
165         // put the packet back at the front of the list (packet should
166         // not have changed since it wasn't accepted)
167         assert(!sendEvent.scheduled());
168         transmitList.push_front(dp);
169     }
170 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classPacketQueue_a329b71fb934a93312ca0aacbf5a3f982}{
\index{PacketQueue@{PacketQueue}!drainManager@{drainManager}}
\index{drainManager@{drainManager}!PacketQueue@{PacketQueue}}
\subsubsection[{drainManager}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DrainManager}$\ast$ {\bf drainManager}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPacketQueue_a329b71fb934a93312ca0aacbf5a3f982}
If we need to drain, keep the drain manager around until we're done here. \hypertarget{classPacketQueue_a52e0dd5074be0e61097a0dadf9cda146}{
\index{PacketQueue@{PacketQueue}!em@{em}}
\index{em@{em}!PacketQueue@{PacketQueue}}
\subsubsection[{em}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventManager}\& {\bf em}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPacketQueue_a52e0dd5074be0e61097a0dadf9cda146}
The manager which is used for the event queue \hypertarget{classPacketQueue_ae471a4c4073716b769170188214fe93d}{
\index{PacketQueue@{PacketQueue}!label@{label}}
\index{label@{label}!PacketQueue@{PacketQueue}}
\subsubsection[{label}]{\setlength{\rightskip}{0pt plus 5cm}const std::string {\bf label}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPacketQueue_ae471a4c4073716b769170188214fe93d}
Label to use for print request packets label stack. \hypertarget{classPacketQueue_a2fc6007386af1667bd97ee56a71079fb}{
\index{PacketQueue@{PacketQueue}!sendEvent@{sendEvent}}
\index{sendEvent@{sendEvent}!PacketQueue@{PacketQueue}}
\subsubsection[{sendEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf PacketQueue}, \&PacketQueue::processSendEvent$>$ {\bf sendEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPacketQueue_a2fc6007386af1667bd97ee56a71079fb}
\hyperlink{classEvent}{Event} used to call processSendEvent. \hypertarget{classPacketQueue_a32a79d68b8d8f4f33bc27f59809eeae7}{
\index{PacketQueue@{PacketQueue}!transmitList@{transmitList}}
\index{transmitList@{transmitList}!PacketQueue@{PacketQueue}}
\subsubsection[{transmitList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DeferredPacketList} {\bf transmitList}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPacketQueue_a32a79d68b8d8f4f33bc27f59809eeae7}
A list of outgoing timing response packets that haven't been serviced yet. \hypertarget{classPacketQueue_ad4363dd8230c71676c4cad8dd5a0b8a7}{
\index{PacketQueue@{PacketQueue}!waitingOnRetry@{waitingOnRetry}}
\index{waitingOnRetry@{waitingOnRetry}!PacketQueue@{PacketQueue}}
\subsubsection[{waitingOnRetry}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf waitingOnRetry}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classPacketQueue_ad4363dd8230c71676c4cad8dd5a0b8a7}
Remember whether we're awaiting a retry from the bus. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{packet__queue_8hh}{packet\_\-queue.hh}\item 
mem/\hyperlink{packet__queue_8cc}{packet\_\-queue.cc}\end{DoxyCompactItemize}
