\hypertarget{classDefaultIEW}{
\section{クラス テンプレート DefaultIEW$<$ Impl $>$}
\label{classDefaultIEW}\index{DefaultIEW@{DefaultIEW}}
}


{\ttfamily \#include $<$iew.hh$>$}\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structDefaultIEW_1_1Stalls}{Stalls}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classDefaultIEW_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \{ \hyperlink{classDefaultIEW_a67a0db04d321a74b7e7fcfd3f1a3f70ba26bd8444261cc58df7a86753c79d2520}{Active}, 
\hyperlink{classDefaultIEW_a67a0db04d321a74b7e7fcfd3f1a3f70ba969c924a722daf6334fca64346092ae6}{Inactive}
 \}
\item 
enum \hyperlink{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018}{StageStatus} \{ \par
\hyperlink{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018a2f5f2c4a8c4f4f0519d503dcdfbf55cb}{Running}, 
\hyperlink{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018a9463ee9b8700258a1019b4b9d2d77a30}{Blocked}, 
\hyperlink{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018ad3fa9ae9431d6cb1772f9d9df48cab19}{Idle}, 
\hyperlink{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018a19a48e232b72697e4bb7ea1b6075ed49}{StartSquash}, 
\par
\hyperlink{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018a22a648855197e326dc88f548634c0ec7}{Squashing}, 
\hyperlink{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018af2a3acf850890cb1651bc41dcbacb7e0}{Unblocking}
 \}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDefaultIEW_a2440a84872425a3bfdbd6dfd37760345}{DefaultIEW} (\hyperlink{classDefaultIEW_a44622cf06940413482836cb62931ac3f}{O3CPU} $\ast$\_\-cpu, DerivO3CPUParams $\ast$params)
\item 
std::string \hyperlink{classDefaultIEW_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classDefaultIEW_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classDefaultIEW_aa2dab17a363fd4307274d579796adcf7}{regProbePoints} ()
\item 
void \hyperlink{classDefaultIEW_a31d4cbdab16d4ff8d6bc7f84ece727da}{startupStage} ()
\item 
void \hyperlink{classDefaultIEW_a2b521ea5f191fff72265f60d4ed5187b}{setTimeBuffer} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$ $\ast$tb\_\-ptr)
\item 
void \hyperlink{classDefaultIEW_a701624f92a819fe4205faede6e614d9f}{setRenameQueue} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultIEW_a0c2a89ad2edad9ad605d0461f9b132a5}{RenameStruct} $>$ $\ast$rq\_\-ptr)
\item 
void \hyperlink{classDefaultIEW_a6b8bf7d75423c9bccd93d50470f7f935}{setIEWQueue} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultIEW_a7cf3f052f760b3a8a18623f792c10910}{IEWStruct} $>$ $\ast$iq\_\-ptr)
\item 
void \hyperlink{classDefaultIEW_aab96bdacf8bd420402cbb543f994e054}{setActiveThreads} (\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$at\_\-ptr)
\item 
void \hyperlink{classDefaultIEW_a6f43cb2e5396c650d07ea5e01e855c32}{setScoreboard} (\hyperlink{classScoreboard}{Scoreboard} $\ast$sb\_\-ptr)
\item 
void \hyperlink{classDefaultIEW_a0240eb42fa57fe5d3788093f62b77347}{drainSanityCheck} () const 
\item 
bool \hyperlink{classDefaultIEW_adf5473c18a3d7c1e88c4a2072bce5526}{isDrained} () const 
\item 
void \hyperlink{classDefaultIEW_a8674059ce345e23aac5086b2c3e24a43}{takeOverFrom} ()
\item 
void \hyperlink{classDefaultIEW_ad33d65c18c323d90695d7c2355b49af9}{squash} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultIEW_a84834d31005dcede47e334bfee5b52d3}{wakeDependents} (\hyperlink{classDefaultIEW_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classDefaultIEW_aa9c46f45f491ef90a936c7e2b95f20aa}{rescheduleMemInst} (\hyperlink{classDefaultIEW_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classDefaultIEW_ae165df775b4de9e9430228c7f04c2bc9}{replayMemInst} (\hyperlink{classDefaultIEW_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classDefaultIEW_a720e9865ffa6e84b756f5ec1d1a24d94}{instToCommit} (\hyperlink{classDefaultIEW_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classDefaultIEW_ac24515147270ef9b85991bbe13bd47af}{skidInsert} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
int \hyperlink{classDefaultIEW_af64dbc63d9980fb739ed89ddadb2b92e}{skidCount} ()
\item 
bool \hyperlink{classDefaultIEW_afe3e2673d17dd5c568862ef5ae68b4d8}{skidsEmpty} ()
\item 
void \hyperlink{classDefaultIEW_a4bb9486757ce225941aaaf759b357a57}{updateStatus} ()
\item 
void \hyperlink{classDefaultIEW_aaf9a05771a835f9f8d634cef36e24d40}{resetEntries} ()
\item 
void \hyperlink{classDefaultIEW_abce3a63b123f84972e4df7962f9b870e}{wakeCPU} ()
\item 
void \hyperlink{classDefaultIEW_ad7e5c2506873e8dc8c71740ac6dabb23}{activityThisCycle} ()
\item 
void \hyperlink{classDefaultIEW_adeab5540b89c1c9defd0d910d9b39e10}{activateStage} ()
\item 
void \hyperlink{classDefaultIEW_aeb7184c554fd889269371c654c7efdb6}{deactivateStage} ()
\item 
bool \hyperlink{classDefaultIEW_ad2e4b46255cfb53e85522adeed4e2089}{hasStoresToWB} ()
\item 
bool \hyperlink{classDefaultIEW_a7e6f40e5ef3dbfe9d3d8da2dbeaf2b91}{hasStoresToWB} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultIEW_a203d5348c070560c49290bcaf1c4496a}{incrWb} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&sn)
\item 
void \hyperlink{classDefaultIEW_a108570745f0a3cc383744de3180741fe}{decrWb} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&sn)
\item 
bool \hyperlink{classDefaultIEW_a93204549d4730243f4d1b4873ff0ffef}{canIssue} ()
\item 
void \hyperlink{classDefaultIEW_aa2a3a423cd0b79a85083da555c98f0f3}{checkMisprediction} (\hyperlink{classDefaultIEW_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classDefaultIEW_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classDefaultIEW_a7afe8710ac68efe63b0ae9fcca43853e}{ableToIssue}
\item 
\hyperlink{classDefaultIEW_aaecfbaa9bf5c22b455806f40f49ef627}{IQ} \hyperlink{classDefaultIEW_a190caab0d0faf2269b72f46da4bac40f}{instQueue}
\item 
\hyperlink{classLSQ}{LSQ} \hyperlink{classDefaultIEW_a9f2a7c471091519f7d05832eb48c2a9d}{ldstQueue}
\item 
\hyperlink{classFUPool}{FUPool} $\ast$ \hyperlink{classDefaultIEW_a480782fc1cfd21fd9748b26f2a08b97a}{fuPool}
\item 
bool \hyperlink{classDefaultIEW_a5cbd0281152001f7337f5d95155db5c0}{updateLSQNextCycle}
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef Impl::CPUPol \hyperlink{classDefaultIEW_a87d662eaeb9eab249d671b63cb4ba11a}{CPUPol}
\item 
typedef Impl::DynInstPtr \hyperlink{classDefaultIEW_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}
\item 
typedef Impl::O3CPU \hyperlink{classDefaultIEW_a44622cf06940413482836cb62931ac3f}{O3CPU}
\item 
typedef CPUPol::IQ \hyperlink{classDefaultIEW_aaecfbaa9bf5c22b455806f40f49ef627}{IQ}
\item 
typedef CPUPol::RenameMap \hyperlink{classDefaultIEW_a341963bcea1928476182a17e357f98e3}{RenameMap}
\item 
typedef CPUPol::LSQ \hyperlink{classDefaultIEW_a5a50654edfc0d8f12a301d17cf859e4c}{LSQ}
\item 
typedef CPUPol::TimeStruct \hyperlink{classDefaultIEW_ab7dd3632ef639702a5c6e7c2c3a2f82a}{TimeStruct}
\item 
typedef CPUPol::IEWStruct \hyperlink{classDefaultIEW_a7cf3f052f760b3a8a18623f792c10910}{IEWStruct}
\item 
typedef CPUPol::RenameStruct \hyperlink{classDefaultIEW_a0c2a89ad2edad9ad605d0461f9b132a5}{RenameStruct}
\item 
typedef CPUPol::IssueStruct \hyperlink{classDefaultIEW_aea279208ef417c3e47681ba0d183bd04}{IssueStruct}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classDefaultIEW_a7312a115c34dfbb21d18b6d85fc46fb9}{squashDueToBranch} (\hyperlink{classDefaultIEW_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultIEW_a581b3c0199d9fc6283bdc7dbcab26e45}{squashDueToMemOrder} (\hyperlink{classDefaultIEW_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultIEW_aa471ebd447a37d3bf56e80c6ce0373f5}{squashDueToMemBlocked} (\hyperlink{classDefaultIEW_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultIEW_a0c1ca72524d2661cee99b06f2ba54de7}{block} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultIEW_a2c95e7e16c04d20ba742b9e97a4f0809}{unblock} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultIEW_ae7e149739c0db3dcb5d49119bd675ee2}{dispatch} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultIEW_ada6ba514c48bb66235f0e4dba539b393}{dispatchInsts} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultIEW_a2d00e30d66a56e4667e28df302c98ac0}{executeInsts} ()
\item 
void \hyperlink{classDefaultIEW_a5e9a203f943b3a8a243ddc6d2a0a240d}{writebackInsts} ()
\item 
unsigned \hyperlink{classDefaultIEW_a5fc3225c48aefdbd7d923903a3aa5bc6}{validInstsFromRename} ()
\item 
void \hyperlink{classDefaultIEW_ad65c9f053a6038ac8c34c34bfe9a88c3}{readStallSignals} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classDefaultIEW_a2dd2400250619a315cb46f95f777db01}{checkStall} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultIEW_a4e0fecf6356ab23b6af3043c519b3f31}{checkSignalsAndUpdate} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultIEW_a1fe94223811c326eed5cc0664d85c5fd}{emptyRenameInsts} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classDefaultIEW_a9ff2aa32ab0f40674cb3518108d62f8e}{sortInsts} ()
\item 
void \hyperlink{classDefaultIEW_a132db67a5c42af856da64e347e8284d8}{updateExeInstStats} (\hyperlink{classDefaultIEW_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classDefaultIEW_a8336a7a280f893bc1225d7b1ce234106}{printAvailableInsts} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDefaultIEW_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \hyperlink{classDefaultIEW_a6cdf6e6db875a442f3ab6db542bd2bb5}{\_\-status}
\item 
\hyperlink{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018}{StageStatus} \hyperlink{classDefaultIEW_a2ab1f59ca15f38f95b082415285ee273}{dispatchStatus} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018}{StageStatus} \hyperlink{classDefaultIEW_ab8c04349b85b4d9bf03a601deee720b4}{exeStatus}
\item 
\hyperlink{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018}{StageStatus} \hyperlink{classDefaultIEW_abc3a4c25708a2663da1d26bf7fc045a0}{wbStatus}
\item 
\hyperlink{classProbePointArg}{ProbePointArg}$<$ \hyperlink{classDefaultIEW_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ $\ast$ \hyperlink{classDefaultIEW_a78ed80917b5ebd419bf614b2e3b8f2cb}{ppMispredict}
\item 
\hyperlink{classProbePointArg}{ProbePointArg}$<$ \hyperlink{classDefaultIEW_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ $\ast$ \hyperlink{classDefaultIEW_acf84d288c6bc7f3ffbb09eb080dcbb7b}{ppDispatch}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$ $\ast$ \hyperlink{classDefaultIEW_a83f9ee976e732665aeb08dbc19acfd45}{timeBuffer}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classDefaultIEW_acc94cfae2a67b5dbb0e74e81c24a3b6e}{toFetch}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classDefaultIEW_a0055a92bd94eda21c2641d46ff013dac}{fromCommit}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structTimeStruct}{TimeStruct} $>$::wire \hyperlink{classDefaultIEW_a0f41e335a1b036cd36ccec9716b2ee2b}{toRename}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultIEW_a0c2a89ad2edad9ad605d0461f9b132a5}{RenameStruct} $>$ $\ast$ \hyperlink{classDefaultIEW_ae9b536282159ba75153a223be77515ba}{renameQueue}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultIEW_a0c2a89ad2edad9ad605d0461f9b132a5}{RenameStruct} $>$::wire \hyperlink{classDefaultIEW_a2b6b1d4785b92bd378f8a7abc5b7e6b9}{fromRename}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structIssueStruct}{IssueStruct} $>$ \hyperlink{classDefaultIEW_ae11bca71ca0d33ab0c3b0fafd7bbb758}{issueToExecQueue}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structIssueStruct}{IssueStruct} $>$::wire \hyperlink{classDefaultIEW_af6f43373b6586aa8c486538fb076effb}{fromIssue}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultIEW_a7cf3f052f760b3a8a18623f792c10910}{IEWStruct} $>$ $\ast$ \hyperlink{classDefaultIEW_a034b0868914c304e81c13c4e645d2616}{iewQueue}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classDefaultIEW_a7cf3f052f760b3a8a18623f792c10910}{IEWStruct} $>$::wire \hyperlink{classDefaultIEW_aaebdc531a44267a7cc38b8bb6d3690d4}{toCommit}
\item 
std::queue$<$ \hyperlink{classDefaultIEW_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classDefaultIEW_a1b0ce60f9b6c662a2f3df87a3e8b50f8}{insts} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
std::queue$<$ \hyperlink{classDefaultIEW_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classDefaultIEW_a911bfd7c5c1efbd9f479d2b960078ec1}{skidBuffer} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classScoreboard}{Scoreboard} $\ast$ \hyperlink{classDefaultIEW_a265ad15229da2a6a05f908da093b3ed5}{scoreboard}
\item 
\hyperlink{classDefaultIEW_a44622cf06940413482836cb62931ac3f}{O3CPU} $\ast$ \hyperlink{classDefaultIEW_a1379cf882a12ac6fc9eba5da7c84b18b}{cpu}
\item 
bool \hyperlink{classDefaultIEW_a2c7e870d4babdac0dc91fc7ffabd0f3d}{wroteToTimeBuffer}
\item 
\hyperlink{structDefaultIEW_1_1Stalls}{Stalls} \hyperlink{classDefaultIEW_ade48cf321f5741ea8e54e071680cacdc}{stalls} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
bool \hyperlink{classDefaultIEW_aa40219506ff80e4e8c5a9a3b1205b282}{fetchRedirect} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
bool \hyperlink{classDefaultIEW_abdd12485100503d860c2aeda746cfd75}{updatedQueues}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classDefaultIEW_a6b6fe1148ed7c40758e45f351c375552}{commitToIEWDelay}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classDefaultIEW_a72426b859bd857b77c8402cc6bc1ac7a}{renameToIEWDelay}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classDefaultIEW_a40f102cb54be0bc75cfbd9a70b696091}{issueToExecuteDelay}
\item 
unsigned \hyperlink{classDefaultIEW_acd9a559a5f1d57c32c03c9a5b4299089}{dispatchWidth}
\item 
unsigned \hyperlink{classDefaultIEW_a574eb3fb1659bd364f4f613662fa2ead}{issueWidth}
\item 
unsigned \hyperlink{classDefaultIEW_a5fa0799bf5569437190dd1eda1d62b7b}{wbNumInst}
\item 
unsigned \hyperlink{classDefaultIEW_ad2c7b2687f864f2b7359eb393276996f}{wbCycle}
\item 
int \hyperlink{classDefaultIEW_a225199c05fd7bddaf95d0d79171b31dc}{wbOutstanding}
\item 
unsigned \hyperlink{classDefaultIEW_a97c827109db73fbbd67c50a90eccf7ac}{wbWidth}
\item 
unsigned \hyperlink{classDefaultIEW_a4feeca4f9ab71ed25ed257f08a09fe0e}{wbMax}
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classDefaultIEW_a88377f855dbf5adeeecb06b5bb821d35}{numThreads}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$ \hyperlink{classDefaultIEW_af6eaea53db532812052f71bf0380dab5}{activeThreads}
\item 
unsigned \hyperlink{classDefaultIEW_a268414a6444b620140f263013a739a17}{skidBufferMax}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultIEW_a9da3679b5e992aaed3de418432902a59}{iewIdleCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultIEW_acb215c0a56967a158558f7e8018cb68e}{iewSquashCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultIEW_a29d41a8f53acdfa4edcfa2c3238c8052}{iewBlockCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultIEW_aa77818f080dcd03ea5f5f593768b1740}{iewUnblockCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultIEW_a60a497827df5bf20377131218dbb5856}{iewDispatchedInsts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultIEW_a43a5c3a932fadd9d0cbcc8da45f6ec2e}{iewDispSquashedInsts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultIEW_a4912d8eb8445e3613e37bd099b4838a5}{iewDispLoadInsts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultIEW_a014a1fbd4e241bc9c3eb4d926aaf1156}{iewDispStoreInsts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultIEW_ad97a775edfe3139e00cf90d6ce85cd6e}{iewDispNonSpecInsts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultIEW_af14622d1e3f6f89130c87183c0fd31b1}{iewIQFullEvents}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultIEW_a98fa20b7c9538614aaba18ecf7b96cf6}{iewLSQFullEvents}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultIEW_a4cca8a82790f3c5dd13bd5c0b32ad774}{memOrderViolationEvents}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultIEW_aa848feac8bfb4947ca3acb410bfe75c6}{predictedTakenIncorrect}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultIEW_ae1cc96638781ca35cb92a5606bd508b7}{predictedNotTakenIncorrect}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDefaultIEW_a84b48267a042d76990dbfb6cec760fcb}{branchMispredicts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultIEW_a96ac594d4d0ac05306c6c3679ffbbfaa}{iewExecutedInsts}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultIEW_ad576ced7a991ca05c24bc21fc9d70cdc}{iewExecLoadInsts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classDefaultIEW_a822e0e5fd3e050a7b48437eab389be0a}{iewExecSquashedInsts}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultIEW_ab4a8c8cadda04122d21fc9596057b8ce}{iewExecutedSwp}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultIEW_a63390d8471177b1fbca3c4352cce1e8f}{iewExecutedNop}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultIEW_a7fdb9d8f885ec0c7d7db3015b254c073}{iewExecutedRefs}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultIEW_a69db59d35af8f8904b1e176cb611fc9b}{iewExecutedBranches}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDefaultIEW_a26e3fec9b7902bf996fbe1755c5bd063}{iewExecStoreInsts}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDefaultIEW_a455816a7fa7ff2a5fa41cc7e7486d91b}{iewExecRate}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultIEW_ad02ecf3ed9ed64d465941dc4e5f402f9}{iewInstsToCommit}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultIEW_a85f5041a2e3375a2dc81bc0ae534aa2e}{writebackCount}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultIEW_a79df9c76c4c8c7da92694a4a571d44f0}{producerInst}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultIEW_a69b21b8b0360b93b3088bbf183fe6abf}{consumerInst}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classDefaultIEW_a364daa8f3a358e41aa13fac115bb5e0f}{wbPenalized}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDefaultIEW_a5ab2bb9fa8eb98a735a204082a37c9db}{wbRate}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDefaultIEW_a667246d811337454bc9ceccf8bbf8f1c}{wbFanout}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classDefaultIEW_a58a4cd085d39435e69bc1ee729422d84}{wbPenalizedRate}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$class Impl$>$ class DefaultIEW$<$ Impl $>$}

\hyperlink{classDefaultIEW}{DefaultIEW} handles both single threaded and SMT IEW (issue/execute/writeback). It handles the dispatching of instructions to the LSQ/IQ as part of the issue stage, and has the IQ try to issue instructions each cycle. The execute latency is actually tied into the issue latency to allow the IQ to be able to do back-\/to-\/back scheduling without having to speculatively schedule instructions. This happens by having the IQ have access to the functional units, and the IQ gets the execution latencies from the FUs when it issues instructions. Instructions reach the execute stage on the last cycle of their execution, which is when the IQ knows to wake up any dependent instructions, allowing back to back scheduling. The execute portion of IEW separates memory instructions from non-\/memory instructions, either telling the \hyperlink{classLSQ}{LSQ} to execute the instruction, or executing the instruction directly. The writeback portion of IEW completes the instructions by waking up any dependents, and marking the register ready on the scoreboard. 

\subsection{型定義}
\hypertarget{classDefaultIEW_a87d662eaeb9eab249d671b63cb4ba11a}{
\index{DefaultIEW@{DefaultIEW}!CPUPol@{CPUPol}}
\index{CPUPol@{CPUPol}!DefaultIEW@{DefaultIEW}}
\subsubsection[{CPUPol}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::CPUPol {\bf CPUPol}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a87d662eaeb9eab249d671b63cb4ba11a}
\hypertarget{classDefaultIEW_a028ce10889c5f6450239d9e9a7347976}{
\index{DefaultIEW@{DefaultIEW}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!DefaultIEW@{DefaultIEW}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInstPtr {\bf DynInstPtr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a028ce10889c5f6450239d9e9a7347976}
\hypertarget{classDefaultIEW_a7cf3f052f760b3a8a18623f792c10910}{
\index{DefaultIEW@{DefaultIEW}!IEWStruct@{IEWStruct}}
\index{IEWStruct@{IEWStruct}!DefaultIEW@{DefaultIEW}}
\subsubsection[{IEWStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::IEWStruct {\bf IEWStruct}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a7cf3f052f760b3a8a18623f792c10910}
\hypertarget{classDefaultIEW_aaecfbaa9bf5c22b455806f40f49ef627}{
\index{DefaultIEW@{DefaultIEW}!IQ@{IQ}}
\index{IQ@{IQ}!DefaultIEW@{DefaultIEW}}
\subsubsection[{IQ}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::IQ {\bf IQ}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_aaecfbaa9bf5c22b455806f40f49ef627}
\hypertarget{classDefaultIEW_aea279208ef417c3e47681ba0d183bd04}{
\index{DefaultIEW@{DefaultIEW}!IssueStruct@{IssueStruct}}
\index{IssueStruct@{IssueStruct}!DefaultIEW@{DefaultIEW}}
\subsubsection[{IssueStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::IssueStruct {\bf IssueStruct}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_aea279208ef417c3e47681ba0d183bd04}
\hypertarget{classDefaultIEW_a5a50654edfc0d8f12a301d17cf859e4c}{
\index{DefaultIEW@{DefaultIEW}!LSQ@{LSQ}}
\index{LSQ@{LSQ}!DefaultIEW@{DefaultIEW}}
\subsubsection[{LSQ}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::LSQ {\bf LSQ}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a5a50654edfc0d8f12a301d17cf859e4c}
\hypertarget{classDefaultIEW_a44622cf06940413482836cb62931ac3f}{
\index{DefaultIEW@{DefaultIEW}!O3CPU@{O3CPU}}
\index{O3CPU@{O3CPU}!DefaultIEW@{DefaultIEW}}
\subsubsection[{O3CPU}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::O3CPU {\bf O3CPU}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a44622cf06940413482836cb62931ac3f}
\hypertarget{classDefaultIEW_a341963bcea1928476182a17e357f98e3}{
\index{DefaultIEW@{DefaultIEW}!RenameMap@{RenameMap}}
\index{RenameMap@{RenameMap}!DefaultIEW@{DefaultIEW}}
\subsubsection[{RenameMap}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::RenameMap {\bf RenameMap}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a341963bcea1928476182a17e357f98e3}
\hypertarget{classDefaultIEW_a0c2a89ad2edad9ad605d0461f9b132a5}{
\index{DefaultIEW@{DefaultIEW}!RenameStruct@{RenameStruct}}
\index{RenameStruct@{RenameStruct}!DefaultIEW@{DefaultIEW}}
\subsubsection[{RenameStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::RenameStruct {\bf RenameStruct}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a0c2a89ad2edad9ad605d0461f9b132a5}
\hypertarget{classDefaultIEW_ab7dd3632ef639702a5c6e7c2c3a2f82a}{
\index{DefaultIEW@{DefaultIEW}!TimeStruct@{TimeStruct}}
\index{TimeStruct@{TimeStruct}!DefaultIEW@{DefaultIEW}}
\subsubsection[{TimeStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef CPUPol::TimeStruct {\bf TimeStruct}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_ab7dd3632ef639702a5c6e7c2c3a2f82a}


\subsection{列挙型}
\hypertarget{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018}{
\index{DefaultIEW@{DefaultIEW}!StageStatus@{StageStatus}}
\index{StageStatus@{StageStatus}!DefaultIEW@{DefaultIEW}}
\subsubsection[{StageStatus}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf StageStatus}}}
\label{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018}
Status for Issue, Execute, and Writeback stages. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Running@{Running}!DefaultIEW@{DefaultIEW}}\index{DefaultIEW@{DefaultIEW}!Running@{Running}}\item[{\em 
\hypertarget{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018a2f5f2c4a8c4f4f0519d503dcdfbf55cb}{
Running}
\label{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018a2f5f2c4a8c4f4f0519d503dcdfbf55cb}
}]\index{Blocked@{Blocked}!DefaultIEW@{DefaultIEW}}\index{DefaultIEW@{DefaultIEW}!Blocked@{Blocked}}\item[{\em 
\hypertarget{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018a9463ee9b8700258a1019b4b9d2d77a30}{
Blocked}
\label{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018a9463ee9b8700258a1019b4b9d2d77a30}
}]\index{Idle@{Idle}!DefaultIEW@{DefaultIEW}}\index{DefaultIEW@{DefaultIEW}!Idle@{Idle}}\item[{\em 
\hypertarget{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018ad3fa9ae9431d6cb1772f9d9df48cab19}{
Idle}
\label{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018ad3fa9ae9431d6cb1772f9d9df48cab19}
}]\index{StartSquash@{StartSquash}!DefaultIEW@{DefaultIEW}}\index{DefaultIEW@{DefaultIEW}!StartSquash@{StartSquash}}\item[{\em 
\hypertarget{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018a19a48e232b72697e4bb7ea1b6075ed49}{
StartSquash}
\label{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018a19a48e232b72697e4bb7ea1b6075ed49}
}]\index{Squashing@{Squashing}!DefaultIEW@{DefaultIEW}}\index{DefaultIEW@{DefaultIEW}!Squashing@{Squashing}}\item[{\em 
\hypertarget{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018a22a648855197e326dc88f548634c0ec7}{
Squashing}
\label{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018a22a648855197e326dc88f548634c0ec7}
}]\index{Unblocking@{Unblocking}!DefaultIEW@{DefaultIEW}}\index{DefaultIEW@{DefaultIEW}!Unblocking@{Unblocking}}\item[{\em 
\hypertarget{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018af2a3acf850890cb1651bc41dcbacb7e0}{
Unblocking}
\label{classDefaultIEW_add44b42ba3608b213fc0986c4aee6018af2a3acf850890cb1651bc41dcbacb7e0}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
107                      {
108         Running,
109         Blocked,
110         Idle,
111         StartSquash,
112         Squashing,
113         Unblocking
114     };
\end{DoxyCode}
\hypertarget{classDefaultIEW_a67a0db04d321a74b7e7fcfd3f1a3f70b}{
\index{DefaultIEW@{DefaultIEW}!Status@{Status}}
\index{Status@{Status}!DefaultIEW@{DefaultIEW}}
\subsubsection[{Status}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Status}}}
\label{classDefaultIEW_a67a0db04d321a74b7e7fcfd3f1a3f70b}
Overall IEW stage status. Used to determine if the CPU can deschedule itself due to a lack of activity. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Active@{Active}!DefaultIEW@{DefaultIEW}}\index{DefaultIEW@{DefaultIEW}!Active@{Active}}\item[{\em 
\hypertarget{classDefaultIEW_a67a0db04d321a74b7e7fcfd3f1a3f70ba26bd8444261cc58df7a86753c79d2520}{
Active}
\label{classDefaultIEW_a67a0db04d321a74b7e7fcfd3f1a3f70ba26bd8444261cc58df7a86753c79d2520}
}]\index{Inactive@{Inactive}!DefaultIEW@{DefaultIEW}}\index{DefaultIEW@{DefaultIEW}!Inactive@{Inactive}}\item[{\em 
\hypertarget{classDefaultIEW_a67a0db04d321a74b7e7fcfd3f1a3f70ba969c924a722daf6334fca64346092ae6}{
Inactive}
\label{classDefaultIEW_a67a0db04d321a74b7e7fcfd3f1a3f70ba969c924a722daf6334fca64346092ae6}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
101                 {
102         Active,
103         Inactive
104     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classDefaultIEW_a2440a84872425a3bfdbd6dfd37760345}{
\index{DefaultIEW@{DefaultIEW}!DefaultIEW@{DefaultIEW}}
\index{DefaultIEW@{DefaultIEW}!DefaultIEW@{DefaultIEW}}
\subsubsection[{DefaultIEW}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DefaultIEW} ({\bf O3CPU} $\ast$ {\em \_\-cpu}, \/  DerivO3CPUParams $\ast$ {\em params})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_a2440a84872425a3bfdbd6dfd37760345}
Constructs a \hyperlink{classDefaultIEW}{DefaultIEW} with the given parameters. 


\begin{DoxyCode}
68     : issueToExecQueue(params->backComSize, params->forwardComSize),
69       cpu(_cpu),
70       instQueue(_cpu, this, params),
71       ldstQueue(_cpu, this, params),
72       fuPool(params->fuPool),
73       commitToIEWDelay(params->commitToIEWDelay),
74       renameToIEWDelay(params->renameToIEWDelay),
75       issueToExecuteDelay(params->issueToExecuteDelay),
76       dispatchWidth(params->dispatchWidth),
77       issueWidth(params->issueWidth),
78       wbOutstanding(0),
79       wbWidth(params->wbWidth),
80       numThreads(params->numThreads)
81 {
82     if (dispatchWidth > Impl::MaxWidth)
83         fatal("dispatchWidth (%d) is larger than compiled limit (%d),\n"
84              "\tincrease MaxWidth in src/cpu/o3/impl.hh\n",
85              dispatchWidth, static_cast<int>(Impl::MaxWidth));
86     if (issueWidth > Impl::MaxWidth)
87         fatal("issueWidth (%d) is larger than compiled limit (%d),\n"
88              "\tincrease MaxWidth in src/cpu/o3/impl.hh\n",
89              issueWidth, static_cast<int>(Impl::MaxWidth));
90     if (wbWidth > Impl::MaxWidth)
91         fatal("wbWidth (%d) is larger than compiled limit (%d),\n"
92              "\tincrease MaxWidth in src/cpu/o3/impl.hh\n",
93              wbWidth, static_cast<int>(Impl::MaxWidth));
94 
95     _status = Active;
96     exeStatus = Running;
97     wbStatus = Idle;
98 
99     // Setup wire to read instructions coming from issue.
100     fromIssue = issueToExecQueue.getWire(-issueToExecuteDelay);
101 
102     // Instruction queue needs the queue between issue and execute.
103     instQueue.setIssueToExecuteQueue(&issueToExecQueue);
104 
105     for (ThreadID tid = 0; tid < numThreads; tid++) {
106         dispatchStatus[tid] = Running;
107         stalls[tid].commit = false;
108         fetchRedirect[tid] = false;
109     }
110 
111     wbMax = wbWidth * params->wbDepth;
112 
113     updateLSQNextCycle = false;
114 
115     ableToIssue = true;
116 
117     skidBufferMax = (3 * (renameToIEWDelay * params->renameWidth)) + issueWidth;
118 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classDefaultIEW_adeab5540b89c1c9defd0d910d9b39e10}{
\index{DefaultIEW@{DefaultIEW}!activateStage@{activateStage}}
\index{activateStage@{activateStage}!DefaultIEW@{DefaultIEW}}
\subsubsection[{activateStage}]{\setlength{\rightskip}{0pt plus 5cm}void activateStage ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_adeab5540b89c1c9defd0d910d9b39e10}
Tells CPU that the IEW stage is active and running. 


\begin{DoxyCode}
935 {
936     DPRINTF(Activity, "Activating stage.\n");
937     cpu->activateStage(O3CPU::IEWIdx);
938 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_ad7e5c2506873e8dc8c71740ac6dabb23}{
\index{DefaultIEW@{DefaultIEW}!activityThisCycle@{activityThisCycle}}
\index{activityThisCycle@{activityThisCycle}!DefaultIEW@{DefaultIEW}}
\subsubsection[{activityThisCycle}]{\setlength{\rightskip}{0pt plus 5cm}void activityThisCycle ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_ad7e5c2506873e8dc8c71740ac6dabb23}
Reports to the CPU that there is activity this cycle. 


\begin{DoxyCode}
927 {
928     DPRINTF(Activity, "Activity this cycle.\n");
929     cpu->activityThisCycle();
930 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a0c1ca72524d2661cee99b06f2ba54de7}{
\index{DefaultIEW@{DefaultIEW}!block@{block}}
\index{block@{block}!DefaultIEW@{DefaultIEW}}
\subsubsection[{block}]{\setlength{\rightskip}{0pt plus 5cm}void block ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultIEW_a0c1ca72524d2661cee99b06f2ba54de7}
Sets Dispatch to blocked, and signals back to other stages to block. 


\begin{DoxyCode}
561 {
562     DPRINTF(IEW, "[tid:%u]: Blocking.\n", tid);
563 
564     if (dispatchStatus[tid] != Blocked &&
565         dispatchStatus[tid] != Unblocking) {
566         toRename->iewBlock[tid] = true;
567         wroteToTimeBuffer = true;
568     }
569 
570     // Add the current inputs to the skid buffer so they can be
571     // reprocessed when this stage unblocks.
572     skidInsert(tid);
573 
574     dispatchStatus[tid] = Blocked;
575 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a93204549d4730243f4d1b4873ff0ffef}{
\index{DefaultIEW@{DefaultIEW}!canIssue@{canIssue}}
\index{canIssue@{canIssue}!DefaultIEW@{DefaultIEW}}
\subsubsection[{canIssue}]{\setlength{\rightskip}{0pt plus 5cm}bool canIssue ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_a93204549d4730243f4d1b4873ff0ffef}



\begin{DoxyCode}
261 { return ableToIssue; }
\end{DoxyCode}
\hypertarget{classDefaultIEW_aa2a3a423cd0b79a85083da555c98f0f3}{
\index{DefaultIEW@{DefaultIEW}!checkMisprediction@{checkMisprediction}}
\index{checkMisprediction@{checkMisprediction}!DefaultIEW@{DefaultIEW}}
\subsubsection[{checkMisprediction}]{\setlength{\rightskip}{0pt plus 5cm}void checkMisprediction ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_aa2a3a423cd0b79a85083da555c98f0f3}
\hyperlink{classCheck}{Check} misprediction 


\begin{DoxyCode}
1674 {
1675     ThreadID tid = inst->threadNumber;
1676 
1677     if (!fetchRedirect[tid] ||
1678         !toCommit->squash[tid] ||
1679         toCommit->squashedSeqNum[tid] > inst->seqNum) {
1680 
1681         if (inst->mispredicted()) {
1682             fetchRedirect[tid] = true;
1683 
1684             DPRINTF(IEW, "Execute: Branch mispredict detected.\n");
1685             DPRINTF(IEW, "Predicted target was PC:%#x, NPC:%#x.\n",
1686                     inst->predInstAddr(), inst->predNextInstAddr());
1687             DPRINTF(IEW, "Execute: Redirecting fetch to PC: %#x,"
1688                     " NPC: %#x.\n", inst->nextInstAddr(),
1689                     inst->nextInstAddr());
1690             // If incorrect, then signal the ROB that it must be squashed.
1691             squashDueToBranch(inst, tid);
1692 
1693             if (inst->readPredTaken()) {
1694                 predictedTakenIncorrect++;
1695             } else {
1696                 predictedNotTakenIncorrect++;
1697             }
1698         }
1699     }
1700 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a4e0fecf6356ab23b6af3043c519b3f31}{
\index{DefaultIEW@{DefaultIEW}!checkSignalsAndUpdate@{checkSignalsAndUpdate}}
\index{checkSignalsAndUpdate@{checkSignalsAndUpdate}!DefaultIEW@{DefaultIEW}}
\subsubsection[{checkSignalsAndUpdate}]{\setlength{\rightskip}{0pt plus 5cm}void checkSignalsAndUpdate ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultIEW_a4e0fecf6356ab23b6af3043c519b3f31}
Processes inputs and changes state accordingly. 


\begin{DoxyCode}
820 {
821     // Check if there's a squash signal, squash if there is
822     // Check stall signals, block if there is.
823     // If status was Blocked
824     //     if so then go to unblocking
825     // If status was Squashing
826     //     check if squashing is not high.  Switch to running this cycle.
827 
828     readStallSignals(tid);
829 
830     if (fromCommit->commitInfo[tid].squash) {
831         squash(tid);
832 
833         if (dispatchStatus[tid] == Blocked ||
834             dispatchStatus[tid] == Unblocking) {
835             toRename->iewUnblock[tid] = true;
836             wroteToTimeBuffer = true;
837         }
838 
839         dispatchStatus[tid] = Squashing;
840         fetchRedirect[tid] = false;
841         return;
842     }
843 
844     if (fromCommit->commitInfo[tid].robSquashing) {
845         DPRINTF(IEW, "[tid:%i]: ROB is still squashing.\n", tid);
846 
847         dispatchStatus[tid] = Squashing;
848         emptyRenameInsts(tid);
849         wroteToTimeBuffer = true;
850         return;
851     }
852 
853     if (checkStall(tid)) {
854         block(tid);
855         dispatchStatus[tid] = Blocked;
856         return;
857     }
858 
859     if (dispatchStatus[tid] == Blocked) {
860         // Status from previous cycle was blocked, but there are no more stall
861         // conditions.  Switch over to unblocking.
862         DPRINTF(IEW, "[tid:%i]: Done blocking, switching to unblocking.\n",
863                 tid);
864 
865         dispatchStatus[tid] = Unblocking;
866 
867         unblock(tid);
868 
869         return;
870     }
871 
872     if (dispatchStatus[tid] == Squashing) {
873         // Switch status to running if rename isn't being told to block or
874         // squash this cycle.
875         DPRINTF(IEW, "[tid:%i]: Done squashing, switching to running.\n",
876                 tid);
877 
878         dispatchStatus[tid] = Running;
879 
880         return;
881     }
882 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a2dd2400250619a315cb46f95f777db01}{
\index{DefaultIEW@{DefaultIEW}!checkStall@{checkStall}}
\index{checkStall@{checkStall}!DefaultIEW@{DefaultIEW}}
\subsubsection[{checkStall}]{\setlength{\rightskip}{0pt plus 5cm}bool checkStall ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultIEW_a2dd2400250619a315cb46f95f777db01}
Checks if any of the stall conditions are currently true. 


\begin{DoxyCode}
784 {
785     bool ret_val(false);
786 
787     if (stalls[tid].commit) {
788         DPRINTF(IEW,"[tid:%i]: Stall from Commit stage detected.\n",tid);
789         ret_val = true;
790     } else if (instQueue.isFull(tid)) {
791         DPRINTF(IEW,"[tid:%i]: Stall: IQ  is full.\n",tid);
792         ret_val = true;
793     } else if (ldstQueue.isFull(tid)) {
794         DPRINTF(IEW,"[tid:%i]: Stall: LSQ is full\n",tid);
795 
796         if (ldstQueue.numLoads(tid) > 0 ) {
797 
798             DPRINTF(IEW,"[tid:%i]: LSQ oldest load: [sn:%i] \n",
799                     tid,ldstQueue.getLoadHeadSeqNum(tid));
800         }
801 
802         if (ldstQueue.numStores(tid) > 0) {
803 
804             DPRINTF(IEW,"[tid:%i]: LSQ oldest store: [sn:%i] \n",
805                     tid,ldstQueue.getStoreHeadSeqNum(tid));
806         }
807 
808         ret_val = true;
809     } else if (ldstQueue.isStalled(tid)) {
810         DPRINTF(IEW,"[tid:%i]: Stall: LSQ stall detected.\n",tid);
811         ret_val = true;
812     }
813 
814     return ret_val;
815 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_aeb7184c554fd889269371c654c7efdb6}{
\index{DefaultIEW@{DefaultIEW}!deactivateStage@{deactivateStage}}
\index{deactivateStage@{deactivateStage}!DefaultIEW@{DefaultIEW}}
\subsubsection[{deactivateStage}]{\setlength{\rightskip}{0pt plus 5cm}void deactivateStage ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_aeb7184c554fd889269371c654c7efdb6}
Tells CPU that the IEW stage is inactive and idle. 


\begin{DoxyCode}
943 {
944     DPRINTF(Activity, "Deactivating stage.\n");
945     cpu->deactivateStage(O3CPU::IEWIdx);
946 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a108570745f0a3cc383744de3180741fe}{
\index{DefaultIEW@{DefaultIEW}!decrWb@{decrWb}}
\index{decrWb@{decrWb}!DefaultIEW@{DefaultIEW}}
\subsubsection[{decrWb}]{\setlength{\rightskip}{0pt plus 5cm}void decrWb ({\bf InstSeqNum} \& {\em sn})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_a108570745f0a3cc383744de3180741fe}



\begin{DoxyCode}
235     {
236         if (wbOutstanding == wbMax)
237             ableToIssue = true;
238         wbOutstanding--;
239         DPRINTF(IEW, "wbOutstanding: %i [sn:%lli]\n", wbOutstanding, sn);
240         assert(wbOutstanding >= 0);
241 #ifdef DEBUG
242         assert(wbList.find(sn) != wbList.end());
243         wbList.erase(sn);
244 #endif
245     }
\end{DoxyCode}
\hypertarget{classDefaultIEW_ae7e149739c0db3dcb5d49119bd675ee2}{
\index{DefaultIEW@{DefaultIEW}!dispatch@{dispatch}}
\index{dispatch@{dispatch}!DefaultIEW@{DefaultIEW}}
\subsubsection[{dispatch}]{\setlength{\rightskip}{0pt plus 5cm}void dispatch ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultIEW_ae7e149739c0db3dcb5d49119bd675ee2}
Determines proper actions to take given Dispatch's status. 


\begin{DoxyCode}
951 {
952     // If status is Running or idle,
953     //     call dispatchInsts()
954     // If status is Unblocking,
955     //     buffer any instructions coming from rename
956     //     continue trying to empty skid buffer
957     //     check if stall conditions have passed
958 
959     if (dispatchStatus[tid] == Blocked) {
960         ++iewBlockCycles;
961 
962     } else if (dispatchStatus[tid] == Squashing) {
963         ++iewSquashCycles;
964     }
965 
966     // Dispatch should try to dispatch as many instructions as its bandwidth
967     // will allow, as long as it is not currently blocked.
968     if (dispatchStatus[tid] == Running ||
969         dispatchStatus[tid] == Idle) {
970         DPRINTF(IEW, "[tid:%i] Not blocked, so attempting to run "
971                 "dispatch.\n", tid);
972 
973         dispatchInsts(tid);
974     } else if (dispatchStatus[tid] == Unblocking) {
975         // Make sure that the skid buffer has something in it if the
976         // status is unblocking.
977         assert(!skidsEmpty());
978 
979         // If the status was unblocking, then instructions from the skid
980         // buffer were used.  Remove those instructions and handle
981         // the rest of unblocking.
982         dispatchInsts(tid);
983 
984         ++iewUnblockCycles;
985 
986         if (validInstsFromRename()) {
987             // Add the current inputs to the skid buffer so they can be
988             // reprocessed when this stage unblocks.
989             skidInsert(tid);
990         }
991 
992         unblock(tid);
993     }
994 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_ada6ba514c48bb66235f0e4dba539b393}{
\index{DefaultIEW@{DefaultIEW}!dispatchInsts@{dispatchInsts}}
\index{dispatchInsts@{dispatchInsts}!DefaultIEW@{DefaultIEW}}
\subsubsection[{dispatchInsts}]{\setlength{\rightskip}{0pt plus 5cm}void dispatchInsts ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultIEW_ada6ba514c48bb66235f0e4dba539b393}
Dispatches instructions to IQ and \hyperlink{classLSQ}{LSQ}. 


\begin{DoxyCode}
999 {
1000     // Obtain instructions from skid buffer if unblocking, or queue from rename
1001     // otherwise.
1002     std::queue<DynInstPtr> &insts_to_dispatch =
1003         dispatchStatus[tid] == Unblocking ?
1004         skidBuffer[tid] : insts[tid];
1005 
1006     int insts_to_add = insts_to_dispatch.size();
1007 
1008     DynInstPtr inst;
1009     bool add_to_iq = false;
1010     int dis_num_inst = 0;
1011 
1012     // Loop through the instructions, putting them in the instruction
1013     // queue.
1014     for ( ; dis_num_inst < insts_to_add &&
1015               dis_num_inst < dispatchWidth;
1016           ++dis_num_inst)
1017     {
1018         inst = insts_to_dispatch.front();
1019 
1020         if (dispatchStatus[tid] == Unblocking) {
1021             DPRINTF(IEW, "[tid:%i]: Issue: Examining instruction from skid "
1022                     "buffer\n", tid);
1023         }
1024 
1025         // Make sure there's a valid instruction there.
1026         assert(inst);
1027 
1028         DPRINTF(IEW, "[tid:%i]: Issue: Adding PC %s [sn:%lli] [tid:%i] to "
1029                 "IQ.\n",
1030                 tid, inst->pcState(), inst->seqNum, inst->threadNumber);
1031 
1032         // Be sure to mark these instructions as ready so that the
1033         // commit stage can go ahead and execute them, and mark
1034         // them as issued so the IQ doesn't reprocess them.
1035 
1036         // Check for squashed instructions.
1037         if (inst->isSquashed()) {
1038             DPRINTF(IEW, "[tid:%i]: Issue: Squashed instruction encountered, "
1039                     "not adding to IQ.\n", tid);
1040 
1041             ++iewDispSquashedInsts;
1042 
1043             insts_to_dispatch.pop();
1044 
1045             //Tell Rename That An Instruction has been processed
1046             if (inst->isLoad() || inst->isStore()) {
1047                 toRename->iewInfo[tid].dispatchedToLSQ++;
1048             }
1049             toRename->iewInfo[tid].dispatched++;
1050 
1051             continue;
1052         }
1053 
1054         // Check for full conditions.
1055         if (instQueue.isFull(tid)) {
1056             DPRINTF(IEW, "[tid:%i]: Issue: IQ has become full.\n", tid);
1057 
1058             // Call function to start blocking.
1059             block(tid);
1060 
1061             // Set unblock to false. Special case where we are using
1062             // skidbuffer (unblocking) instructions but then we still
1063             // get full in the IQ.
1064             toRename->iewUnblock[tid] = false;
1065 
1066             ++iewIQFullEvents;
1067             break;
1068         } else if (ldstQueue.isFull(tid)) {
1069             DPRINTF(IEW, "[tid:%i]: Issue: LSQ has become full.\n",tid);
1070 
1071             // Call function to start blocking.
1072             block(tid);
1073 
1074             // Set unblock to false. Special case where we are using
1075             // skidbuffer (unblocking) instructions but then we still
1076             // get full in the IQ.
1077             toRename->iewUnblock[tid] = false;
1078 
1079             ++iewLSQFullEvents;
1080             break;
1081         }
1082 
1083         // Otherwise issue the instruction just fine.
1084         if (inst->isLoad()) {
1085             DPRINTF(IEW, "[tid:%i]: Issue: Memory instruction "
1086                     "encountered, adding to LSQ.\n", tid);
1087 
1088             // Reserve a spot in the load store queue for this
1089             // memory access.
1090             ldstQueue.insertLoad(inst);
1091 
1092             ++iewDispLoadInsts;
1093 
1094             add_to_iq = true;
1095 
1096             toRename->iewInfo[tid].dispatchedToLSQ++;
1097         } else if (inst->isStore()) {
1098             DPRINTF(IEW, "[tid:%i]: Issue: Memory instruction "
1099                     "encountered, adding to LSQ.\n", tid);
1100 
1101             ldstQueue.insertStore(inst);
1102 
1103             ++iewDispStoreInsts;
1104 
1105             if (inst->isStoreConditional()) {
1106                 // Store conditionals need to be set as "canCommit()"
1107                 // so that commit can process them when they reach the
1108                 // head of commit.
1109                 // @todo: This is somewhat specific to Alpha.
1110                 inst->setCanCommit();
1111                 instQueue.insertNonSpec(inst);
1112                 add_to_iq = false;
1113 
1114                 ++iewDispNonSpecInsts;
1115             } else {
1116                 add_to_iq = true;
1117             }
1118 
1119             toRename->iewInfo[tid].dispatchedToLSQ++;
1120         } else if (inst->isMemBarrier() || inst->isWriteBarrier()) {
1121             // Same as non-speculative stores.
1122             inst->setCanCommit();
1123             instQueue.insertBarrier(inst);
1124             add_to_iq = false;
1125         } else if (inst->isNop()) {
1126             DPRINTF(IEW, "[tid:%i]: Issue: Nop instruction encountered, "
1127                     "skipping.\n", tid);
1128 
1129             inst->setIssued();
1130             inst->setExecuted();
1131             inst->setCanCommit();
1132 
1133             instQueue.recordProducer(inst);
1134 
1135             iewExecutedNop[tid]++;
1136 
1137             add_to_iq = false;
1138         } else if (inst->isExecuted()) {
1139             assert(0 && "Instruction shouldn't be executed.\n");
1140             DPRINTF(IEW, "Issue: Executed branch encountered, "
1141                     "skipping.\n");
1142 
1143             inst->setIssued();
1144             inst->setCanCommit();
1145 
1146             instQueue.recordProducer(inst);
1147 
1148             add_to_iq = false;
1149         } else {
1150             add_to_iq = true;
1151         }
1152         if (inst->isNonSpeculative()) {
1153             DPRINTF(IEW, "[tid:%i]: Issue: Nonspeculative instruction "
1154                     "encountered, skipping.\n", tid);
1155 
1156             // Same as non-speculative stores.
1157             inst->setCanCommit();
1158 
1159             // Specifically insert it as nonspeculative.
1160             instQueue.insertNonSpec(inst);
1161 
1162             ++iewDispNonSpecInsts;
1163 
1164             add_to_iq = false;
1165         }
1166 
1167         // If the instruction queue is not full, then add the
1168         // instruction.
1169         if (add_to_iq) {
1170             instQueue.insert(inst);
1171         }
1172 
1173         insts_to_dispatch.pop();
1174 
1175         toRename->iewInfo[tid].dispatched++;
1176 
1177         ++iewDispatchedInsts;
1178 
1179 #if TRACING_ON
1180         inst->dispatchTick = curTick() - inst->fetchTick;
1181 #endif
1182         ppDispatch->notify(inst);
1183     }
1184 
1185     if (!insts_to_dispatch.empty()) {
1186         DPRINTF(IEW,"[tid:%i]: Issue: Bandwidth Full. Blocking.\n", tid);
1187         block(tid);
1188         toRename->iewUnblock[tid] = false;
1189     }
1190 
1191     if (dispatchStatus[tid] == Idle && dis_num_inst) {
1192         dispatchStatus[tid] = Running;
1193 
1194         updatedQueues = true;
1195     }
1196 
1197     dis_num_inst = 0;
1198 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a0240eb42fa57fe5d3788093f62b77347}{
\index{DefaultIEW@{DefaultIEW}!drainSanityCheck@{drainSanityCheck}}
\index{drainSanityCheck@{drainSanityCheck}!DefaultIEW@{DefaultIEW}}
\subsubsection[{drainSanityCheck}]{\setlength{\rightskip}{0pt plus 5cm}void drainSanityCheck () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_a0240eb42fa57fe5d3788093f62b77347}
Perform sanity checks after a drain. 


\begin{DoxyCode}
416 {
417     assert(isDrained());
418 
419     instQueue.drainSanityCheck();
420     ldstQueue.drainSanityCheck();
421 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a1fe94223811c326eed5cc0664d85c5fd}{
\index{DefaultIEW@{DefaultIEW}!emptyRenameInsts@{emptyRenameInsts}}
\index{emptyRenameInsts@{emptyRenameInsts}!DefaultIEW@{DefaultIEW}}
\subsubsection[{emptyRenameInsts}]{\setlength{\rightskip}{0pt plus 5cm}void emptyRenameInsts ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultIEW_a1fe94223811c326eed5cc0664d85c5fd}
Removes instructions from rename from a thread's instruction list. 


\begin{DoxyCode}
901 {
902     DPRINTF(IEW, "[tid:%i]: Removing incoming rename instructions\n", tid);
903 
904     while (!insts[tid].empty()) {
905 
906         if (insts[tid].front()->isLoad() ||
907             insts[tid].front()->isStore() ) {
908             toRename->iewInfo[tid].dispatchedToLSQ++;
909         }
910 
911         toRename->iewInfo[tid].dispatched++;
912 
913         insts[tid].pop();
914     }
915 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a2d00e30d66a56e4667e28df302c98ac0}{
\index{DefaultIEW@{DefaultIEW}!executeInsts@{executeInsts}}
\index{executeInsts@{executeInsts}!DefaultIEW@{DefaultIEW}}
\subsubsection[{executeInsts}]{\setlength{\rightskip}{0pt plus 5cm}void executeInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultIEW_a2d00e30d66a56e4667e28df302c98ac0}
Executes instructions. In the case of memory operations, it informs the \hyperlink{classLSQ}{LSQ} to execute the instructions. Also handles any redirects that occur due to the executed instructions. 


\begin{DoxyCode}
1226 {
1227     wbNumInst = 0;
1228     wbCycle = 0;
1229 
1230     list<ThreadID>::iterator threads = activeThreads->begin();
1231     list<ThreadID>::iterator end = activeThreads->end();
1232 
1233     while (threads != end) {
1234         ThreadID tid = *threads++;
1235         fetchRedirect[tid] = false;
1236     }
1237 
1238     // Uncomment this if you want to see all available instructions.
1239     // @todo This doesn't actually work anymore, we should fix it.
1240 //    printAvailableInsts();
1241 
1242     // Execute/writeback any instructions that are available.
1243     int insts_to_execute = fromIssue->size;
1244     int inst_num = 0;
1245     for (; inst_num < insts_to_execute;
1246           ++inst_num) {
1247 
1248         DPRINTF(IEW, "Execute: Executing instructions from IQ.\n");
1249 
1250         DynInstPtr inst = instQueue.getInstToExecute();
1251 
1252         DPRINTF(IEW, "Execute: Processing PC %s, [tid:%i] [sn:%i].\n",
1253                 inst->pcState(), inst->threadNumber,inst->seqNum);
1254 
1255         // Check if the instruction is squashed; if so then skip it
1256         if (inst->isSquashed()) {
1257             DPRINTF(IEW, "Execute: Instruction was squashed. PC: %s, [tid:%i]"
1258                          " [sn:%i]\n", inst->pcState(), inst->threadNumber,
1259                          inst->seqNum);
1260 
1261             // Consider this instruction executed so that commit can go
1262             // ahead and retire the instruction.
1263             inst->setExecuted();
1264 
1265             // Not sure if I should set this here or just let commit try to
1266             // commit any squashed instructions.  I like the latter a bit more.
1267             inst->setCanCommit();
1268 
1269             ++iewExecSquashedInsts;
1270 
1271             decrWb(inst->seqNum);
1272             continue;
1273         }
1274 
1275         Fault fault = NoFault;
1276 
1277         // Execute instruction.
1278         // Note that if the instruction faults, it will be handled
1279         // at the commit stage.
1280         if (inst->isMemRef()) {
1281             DPRINTF(IEW, "Execute: Calculating address for memory "
1282                     "reference.\n");
1283 
1284             // Tell the LDSTQ to execute this instruction (if it is a load).
1285             if (inst->isLoad()) {
1286                 // Loads will mark themselves as executed, and their writeback
1287                 // event adds the instruction to the queue to commit
1288                 fault = ldstQueue.executeLoad(inst);
1289 
1290                 if (inst->isTranslationDelayed() &&
1291                     fault == NoFault) {
1292                     // A hw page table walk is currently going on; the
1293                     // instruction must be deferred.
1294                     DPRINTF(IEW, "Execute: Delayed translation, deferring "
1295                             "load.\n");
1296                     instQueue.deferMemInst(inst);
1297                     continue;
1298                 }
1299 
1300                 if (inst->isDataPrefetch() || inst->isInstPrefetch()) {
1301                     inst->fault = NoFault;
1302                 }
1303             } else if (inst->isStore()) {
1304                 fault = ldstQueue.executeStore(inst);
1305 
1306                 if (inst->isTranslationDelayed() &&
1307                     fault == NoFault) {
1308                     // A hw page table walk is currently going on; the
1309                     // instruction must be deferred.
1310                     DPRINTF(IEW, "Execute: Delayed translation, deferring "
1311                             "store.\n");
1312                     instQueue.deferMemInst(inst);
1313                     continue;
1314                 }
1315 
1316                 // If the store had a fault then it may not have a mem req
1317                 if (fault != NoFault || !inst->readPredicate() ||
1318                         !inst->isStoreConditional()) {
1319                     // If the instruction faulted, then we need to send it along
1320                     // to commit without the instruction completing.
1321                     // Send this instruction to commit, also make sure iew stage
1322                     // realizes there is activity.
1323                     inst->setExecuted();
1324                     instToCommit(inst);
1325                     activityThisCycle();
1326                 }
1327 
1328                 // Store conditionals will mark themselves as
1329                 // executed, and their writeback event will add the
1330                 // instruction to the queue to commit.
1331             } else {
1332                 panic("Unexpected memory type!\n");
1333             }
1334 
1335         } else {
1336             // If the instruction has already faulted, then skip executing it.
1337             // Such case can happen when it faulted during ITLB translation.
1338             // If we execute the instruction (even if it's a nop) the fault
1339             // will be replaced and we will lose it.
1340             if (inst->getFault() == NoFault) {
1341                 inst->execute();
1342                 if (!inst->readPredicate())
1343                     inst->forwardOldRegs();
1344             }
1345 
1346             inst->setExecuted();
1347 
1348             instToCommit(inst);
1349         }
1350 
1351         updateExeInstStats(inst);
1352 
1353         // Check if branch prediction was correct, if not then we need
1354         // to tell commit to squash in flight instructions.  Only
1355         // handle this if there hasn't already been something that
1356         // redirects fetch in this group of instructions.
1357 
1358         // This probably needs to prioritize the redirects if a different
1359         // scheduler is used.  Currently the scheduler schedules the oldest
1360         // instruction first, so the branch resolution order will be correct.
1361         ThreadID tid = inst->threadNumber;
1362 
1363         if (!fetchRedirect[tid] ||
1364             !toCommit->squash[tid] ||
1365             toCommit->squashedSeqNum[tid] > inst->seqNum) {
1366 
1367             // Prevent testing for misprediction on load instructions,
1368             // that have not been executed.
1369             bool loadNotExecuted = !inst->isExecuted() && inst->isLoad();
1370 
1371             if (inst->mispredicted() && !loadNotExecuted) {
1372                 fetchRedirect[tid] = true;
1373 
1374                 DPRINTF(IEW, "Execute: Branch mispredict detected.\n");
1375                 DPRINTF(IEW, "Predicted target was PC: %s.\n",
1376                         inst->readPredTarg());
1377                 DPRINTF(IEW, "Execute: Redirecting fetch to PC: %s.\n",
1378                         inst->pcState());
1379                 // If incorrect, then signal the ROB that it must be squashed.
1380                 squashDueToBranch(inst, tid);
1381 
1382                 ppMispredict->notify(inst);
1383 
1384                 if (inst->readPredTaken()) {
1385                     predictedTakenIncorrect++;
1386                 } else {
1387                     predictedNotTakenIncorrect++;
1388                 }
1389             } else if (ldstQueue.violation(tid)) {
1390                 assert(inst->isMemRef());
1391                 // If there was an ordering violation, then get the
1392                 // DynInst that caused the violation.  Note that this
1393                 // clears the violation signal.
1394                 DynInstPtr violator;
1395                 violator = ldstQueue.getMemDepViolator(tid);
1396 
1397                 DPRINTF(IEW, "LDSTQ detected a violation. Violator PC: %s "
1398                         "[sn:%lli], inst PC: %s [sn:%lli]. Addr is: %#x.\n",
1399                         violator->pcState(), violator->seqNum,
1400                         inst->pcState(), inst->seqNum, inst->physEffAddr);
1401 
1402                 fetchRedirect[tid] = true;
1403 
1404                 // Tell the instruction queue that a violation has occured.
1405                 instQueue.violation(inst, violator);
1406 
1407                 // Squash.
1408                 squashDueToMemOrder(violator, tid);
1409 
1410                 ++memOrderViolationEvents;
1411             } else if (ldstQueue.loadBlocked(tid) &&
1412                        !ldstQueue.isLoadBlockedHandled(tid)) {
1413                 fetchRedirect[tid] = true;
1414 
1415                 DPRINTF(IEW, "Load operation couldn't execute because the "
1416                         "memory system is blocked.  PC: %s [sn:%lli]\n",
1417                         inst->pcState(), inst->seqNum);
1418 
1419                 squashDueToMemBlocked(inst, tid);
1420             }
1421         } else {
1422             // Reset any state associated with redirects that will not
1423             // be used.
1424             if (ldstQueue.violation(tid)) {
1425                 assert(inst->isMemRef());
1426 
1427                 DynInstPtr violator = ldstQueue.getMemDepViolator(tid);
1428 
1429                 DPRINTF(IEW, "LDSTQ detected a violation.  Violator PC: "
1430                         "%s, inst PC: %s.  Addr is: %#x.\n",
1431                         violator->pcState(), inst->pcState(),
1432                         inst->physEffAddr);
1433                 DPRINTF(IEW, "Violation will not be handled because "
1434                         "already squashing\n");
1435 
1436                 ++memOrderViolationEvents;
1437             }
1438             if (ldstQueue.loadBlocked(tid) &&
1439                 !ldstQueue.isLoadBlockedHandled(tid)) {
1440                 DPRINTF(IEW, "Load operation couldn't execute because the "
1441                         "memory system is blocked.  PC: %s [sn:%lli]\n",
1442                         inst->pcState(), inst->seqNum);
1443                 DPRINTF(IEW, "Blocked load will not be handled because "
1444                         "already squashing\n");
1445 
1446                 ldstQueue.setLoadBlockedHandled(tid);
1447             }
1448 
1449         }
1450     }
1451 
1452     // Update and record activity if we processed any instructions.
1453     if (inst_num) {
1454         if (exeStatus == Idle) {
1455             exeStatus = Running;
1456         }
1457 
1458         updatedQueues = true;
1459 
1460         cpu->activityThisCycle();
1461     }
1462 
1463     // Need to reset this in case a writeback event needs to write into the
1464     // iew queue.  That way the writeback event will write into the correct
1465     // spot in the queue.
1466     wbNumInst = 0;
1467 
1468 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a7e6f40e5ef3dbfe9d3d8da2dbeaf2b91}{
\index{DefaultIEW@{DefaultIEW}!hasStoresToWB@{hasStoresToWB}}
\index{hasStoresToWB@{hasStoresToWB}!DefaultIEW@{DefaultIEW}}
\subsubsection[{hasStoresToWB}]{\setlength{\rightskip}{0pt plus 5cm}bool hasStoresToWB ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_a7e6f40e5ef3dbfe9d3d8da2dbeaf2b91}
Returns if the \hyperlink{classLSQ}{LSQ} has any stores to writeback. 


\begin{DoxyCode}
220 { return ldstQueue.hasStoresToWB(tid); }
\end{DoxyCode}
\hypertarget{classDefaultIEW_ad2e4b46255cfb53e85522adeed4e2089}{
\index{DefaultIEW@{DefaultIEW}!hasStoresToWB@{hasStoresToWB}}
\index{hasStoresToWB@{hasStoresToWB}!DefaultIEW@{DefaultIEW}}
\subsubsection[{hasStoresToWB}]{\setlength{\rightskip}{0pt plus 5cm}bool hasStoresToWB ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_ad2e4b46255cfb53e85522adeed4e2089}
Returns if the \hyperlink{classLSQ}{LSQ} has any stores to writeback. 


\begin{DoxyCode}
217 { return ldstQueue.hasStoresToWB(); }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a203d5348c070560c49290bcaf1c4496a}{
\index{DefaultIEW@{DefaultIEW}!incrWb@{incrWb}}
\index{incrWb@{incrWb}!DefaultIEW@{DefaultIEW}}
\subsubsection[{incrWb}]{\setlength{\rightskip}{0pt plus 5cm}void incrWb ({\bf InstSeqNum} \& {\em sn})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_a203d5348c070560c49290bcaf1c4496a}



\begin{DoxyCode}
223     {
224         ++wbOutstanding;
225         if (wbOutstanding == wbMax)
226             ableToIssue = false;
227         DPRINTF(IEW, "wbOutstanding: %i [sn:%lli]\n", wbOutstanding, sn);
228         assert(wbOutstanding <= wbMax);
229 #ifdef DEBUG
230         wbList.insert(sn);
231 #endif
232     }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a720e9865ffa6e84b756f5ec1d1a24d94}{
\index{DefaultIEW@{DefaultIEW}!instToCommit@{instToCommit}}
\index{instToCommit@{instToCommit}!DefaultIEW@{DefaultIEW}}
\subsubsection[{instToCommit}]{\setlength{\rightskip}{0pt plus 5cm}void instToCommit ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_a720e9865ffa6e84b756f5ec1d1a24d94}
Sends an instruction to commit through the time buffer. 


\begin{DoxyCode}
618 {
619     // This function should not be called after writebackInsts in a
620     // single cycle.  That will cause problems with an instruction
621     // being added to the queue to commit without being processed by
622     // writebackInsts prior to being sent to commit.
623 
624     // First check the time slot that this instruction will write
625     // to.  If there are free write ports at the time, then go ahead
626     // and write the instruction to that time.  If there are not,
627     // keep looking back to see where's the first time there's a
628     // free slot.
629     while ((*iewQueue)[wbCycle].insts[wbNumInst]) {
630         ++wbNumInst;
631         if (wbNumInst == wbWidth) {
632             ++wbCycle;
633             wbNumInst = 0;
634         }
635 
636         assert((wbCycle * wbWidth + wbNumInst) <= wbMax);
637     }
638 
639     DPRINTF(IEW, "Current wb cycle: %i, width: %i, numInst: %i\nwbActual:%i\n",
640             wbCycle, wbWidth, wbNumInst, wbCycle * wbWidth + wbNumInst);
641     // Add finished instruction to queue to commit.
642     (*iewQueue)[wbCycle].insts[wbNumInst] = inst;
643     (*iewQueue)[wbCycle].size++;
644 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_adf5473c18a3d7c1e88c4a2072bce5526}{
\index{DefaultIEW@{DefaultIEW}!isDrained@{isDrained}}
\index{isDrained@{isDrained}!DefaultIEW@{DefaultIEW}}
\subsubsection[{isDrained}]{\setlength{\rightskip}{0pt plus 5cm}bool isDrained () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_adf5473c18a3d7c1e88c4a2072bce5526}
Has the stage drained? 


\begin{DoxyCode}
388 {
389     bool drained(ldstQueue.isDrained());
390 
391     for (ThreadID tid = 0; tid < numThreads; tid++) {
392         if (!insts[tid].empty()) {
393             DPRINTF(Drain, "%i: Insts not empty.\n", tid);
394             drained = false;
395         }
396         if (!skidBuffer[tid].empty()) {
397             DPRINTF(Drain, "%i: Skid buffer not empty.\n", tid);
398             drained = false;
399         }
400     }
401 
402     // Also check the FU pool as instructions are "stored" in FU
403     // completion events until they are done and not accounted for
404     // above
405     if (drained && !fuPool->isDrained()) {
406         DPRINTF(Drain, "FU pool still busy.\n");
407         drained = false;
408     }
409 
410     return drained;
411 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{DefaultIEW@{DefaultIEW}!name@{name}}
\index{name@{name}!DefaultIEW@{DefaultIEW}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_a37627d5d5bba7f4a8690c71c2ab3cb07}
Returns the name of the \hyperlink{classDefaultIEW}{DefaultIEW} stage. 


\begin{DoxyCode}
123 {
124     return cpu->name() + ".iew";
125 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a8336a7a280f893bc1225d7b1ce234106}{
\index{DefaultIEW@{DefaultIEW}!printAvailableInsts@{printAvailableInsts}}
\index{printAvailableInsts@{printAvailableInsts}!DefaultIEW@{DefaultIEW}}
\subsubsection[{printAvailableInsts}]{\setlength{\rightskip}{0pt plus 5cm}void printAvailableInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultIEW_a8336a7a280f893bc1225d7b1ce234106}
\hyperlink{namespaceDebug}{Debug} function to print instructions that are issued this cycle. 


\begin{DoxyCode}
1203 {
1204     int inst = 0;
1205 
1206     std::cout << "Available Instructions: ";
1207 
1208     while (fromIssue->insts[inst]) {
1209 
1210         if (inst%3==0) std::cout << "\n\t";
1211 
1212         std::cout << "PC: " << fromIssue->insts[inst]->pcState()
1213              << " TN: " << fromIssue->insts[inst]->threadNumber
1214              << " SN: " << fromIssue->insts[inst]->seqNum << " | ";
1215 
1216         inst++;
1217 
1218     }
1219 
1220     std::cout << "\n";
1221 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_ad65c9f053a6038ac8c34c34bfe9a88c3}{
\index{DefaultIEW@{DefaultIEW}!readStallSignals@{readStallSignals}}
\index{readStallSignals@{readStallSignals}!DefaultIEW@{DefaultIEW}}
\subsubsection[{readStallSignals}]{\setlength{\rightskip}{0pt plus 5cm}void readStallSignals ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultIEW_ad65c9f053a6038ac8c34c34bfe9a88c3}
Reads the stall signals. 


\begin{DoxyCode}
770 {
771     if (fromCommit->commitBlock[tid]) {
772         stalls[tid].commit = true;
773     }
774 
775     if (fromCommit->commitUnblock[tid]) {
776         assert(stalls[tid].commit);
777         stalls[tid].commit = false;
778     }
779 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_aa2dab17a363fd4307274d579796adcf7}{
\index{DefaultIEW@{DefaultIEW}!regProbePoints@{regProbePoints}}
\index{regProbePoints@{regProbePoints}!DefaultIEW@{DefaultIEW}}
\subsubsection[{regProbePoints}]{\setlength{\rightskip}{0pt plus 5cm}void regProbePoints ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_aa2dab17a363fd4307274d579796adcf7}
Registers probes. 


\begin{DoxyCode}
130 {
131     ppDispatch = new ProbePointArg<DynInstPtr>(cpu->getProbeManager(), "Dispatch"
      );
132     ppMispredict = new ProbePointArg<DynInstPtr>(cpu->getProbeManager(), "Mispred
      ict");
133 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{DefaultIEW@{DefaultIEW}!regStats@{regStats}}
\index{regStats@{regStats}!DefaultIEW@{DefaultIEW}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_a4dc637449366fcdfc4e764cdf12d9b11}
Registers statistics. 


\begin{DoxyCode}
138 {
139     using namespace Stats;
140 
141     instQueue.regStats();
142     ldstQueue.regStats();
143 
144     iewIdleCycles
145         .name(name() + ".iewIdleCycles")
146         .desc("Number of cycles IEW is idle");
147 
148     iewSquashCycles
149         .name(name() + ".iewSquashCycles")
150         .desc("Number of cycles IEW is squashing");
151 
152     iewBlockCycles
153         .name(name() + ".iewBlockCycles")
154         .desc("Number of cycles IEW is blocking");
155 
156     iewUnblockCycles
157         .name(name() + ".iewUnblockCycles")
158         .desc("Number of cycles IEW is unblocking");
159 
160     iewDispatchedInsts
161         .name(name() + ".iewDispatchedInsts")
162         .desc("Number of instructions dispatched to IQ");
163 
164     iewDispSquashedInsts
165         .name(name() + ".iewDispSquashedInsts")
166         .desc("Number of squashed instructions skipped by dispatch");
167 
168     iewDispLoadInsts
169         .name(name() + ".iewDispLoadInsts")
170         .desc("Number of dispatched load instructions");
171 
172     iewDispStoreInsts
173         .name(name() + ".iewDispStoreInsts")
174         .desc("Number of dispatched store instructions");
175 
176     iewDispNonSpecInsts
177         .name(name() + ".iewDispNonSpecInsts")
178         .desc("Number of dispatched non-speculative instructions");
179 
180     iewIQFullEvents
181         .name(name() + ".iewIQFullEvents")
182         .desc("Number of times the IQ has become full, causing a stall");
183 
184     iewLSQFullEvents
185         .name(name() + ".iewLSQFullEvents")
186         .desc("Number of times the LSQ has become full, causing a stall");
187 
188     memOrderViolationEvents
189         .name(name() + ".memOrderViolationEvents")
190         .desc("Number of memory order violations");
191 
192     predictedTakenIncorrect
193         .name(name() + ".predictedTakenIncorrect")
194         .desc("Number of branches that were predicted taken incorrectly");
195 
196     predictedNotTakenIncorrect
197         .name(name() + ".predictedNotTakenIncorrect")
198         .desc("Number of branches that were predicted not taken incorrectly");
199 
200     branchMispredicts
201         .name(name() + ".branchMispredicts")
202         .desc("Number of branch mispredicts detected at execute");
203 
204     branchMispredicts = predictedTakenIncorrect + predictedNotTakenIncorrect;
205 
206     iewExecutedInsts
207         .name(name() + ".iewExecutedInsts")
208         .desc("Number of executed instructions");
209 
210     iewExecLoadInsts
211         .init(cpu->numThreads)
212         .name(name() + ".iewExecLoadInsts")
213         .desc("Number of load instructions executed")
214         .flags(total);
215 
216     iewExecSquashedInsts
217         .name(name() + ".iewExecSquashedInsts")
218         .desc("Number of squashed instructions skipped in execute");
219 
220     iewExecutedSwp
221         .init(cpu->numThreads)
222         .name(name() + ".exec_swp")
223         .desc("number of swp insts executed")
224         .flags(total);
225 
226     iewExecutedNop
227         .init(cpu->numThreads)
228         .name(name() + ".exec_nop")
229         .desc("number of nop insts executed")
230         .flags(total);
231 
232     iewExecutedRefs
233         .init(cpu->numThreads)
234         .name(name() + ".exec_refs")
235         .desc("number of memory reference insts executed")
236         .flags(total);
237 
238     iewExecutedBranches
239         .init(cpu->numThreads)
240         .name(name() + ".exec_branches")
241         .desc("Number of branches executed")
242         .flags(total);
243 
244     iewExecStoreInsts
245         .name(name() + ".exec_stores")
246         .desc("Number of stores executed")
247         .flags(total);
248     iewExecStoreInsts = iewExecutedRefs - iewExecLoadInsts;
249 
250     iewExecRate
251         .name(name() + ".exec_rate")
252         .desc("Inst execution rate")
253         .flags(total);
254 
255     iewExecRate = iewExecutedInsts / cpu->numCycles;
256 
257     iewInstsToCommit
258         .init(cpu->numThreads)
259         .name(name() + ".wb_sent")
260         .desc("cumulative count of insts sent to commit")
261         .flags(total);
262 
263     writebackCount
264         .init(cpu->numThreads)
265         .name(name() + ".wb_count")
266         .desc("cumulative count of insts written-back")
267         .flags(total);
268 
269     producerInst
270         .init(cpu->numThreads)
271         .name(name() + ".wb_producers")
272         .desc("num instructions producing a value")
273         .flags(total);
274 
275     consumerInst
276         .init(cpu->numThreads)
277         .name(name() + ".wb_consumers")
278         .desc("num instructions consuming a value")
279         .flags(total);
280 
281     wbPenalized
282         .init(cpu->numThreads)
283         .name(name() + ".wb_penalized")
284         .desc("number of instrctions required to write to 'other' IQ")
285         .flags(total);
286 
287     wbPenalizedRate
288         .name(name() + ".wb_penalized_rate")
289         .desc ("fraction of instructions written-back that wrote to 'other' IQ")
290         .flags(total);
291 
292     wbPenalizedRate = wbPenalized / writebackCount;
293 
294     wbFanout
295         .name(name() + ".wb_fanout")
296         .desc("average fanout of values written-back")
297         .flags(total);
298 
299     wbFanout = producerInst / consumerInst;
300 
301     wbRate
302         .name(name() + ".wb_rate")
303         .desc("insts written-back per cycle")
304         .flags(total);
305     wbRate = writebackCount / cpu->numCycles;
306 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_ae165df775b4de9e9430228c7f04c2bc9}{
\index{DefaultIEW@{DefaultIEW}!replayMemInst@{replayMemInst}}
\index{replayMemInst@{replayMemInst}!DefaultIEW@{DefaultIEW}}
\subsubsection[{replayMemInst}]{\setlength{\rightskip}{0pt plus 5cm}void replayMemInst ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_ae165df775b4de9e9430228c7f04c2bc9}
Re-\/executes all rescheduled memory instructions. 


\begin{DoxyCode}
611 {
612     instQueue.replayMemInst(inst);
613 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_aa9c46f45f491ef90a936c7e2b95f20aa}{
\index{DefaultIEW@{DefaultIEW}!rescheduleMemInst@{rescheduleMemInst}}
\index{rescheduleMemInst@{rescheduleMemInst}!DefaultIEW@{DefaultIEW}}
\subsubsection[{rescheduleMemInst}]{\setlength{\rightskip}{0pt plus 5cm}void rescheduleMemInst ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_aa9c46f45f491ef90a936c7e2b95f20aa}
Tells memory dependence unit that a memory instruction needs to be rescheduled. It will re-\/execute once \hyperlink{classDefaultIEW_ae165df775b4de9e9430228c7f04c2bc9}{replayMemInst()} is called. 


\begin{DoxyCode}
604 {
605     instQueue.rescheduleMemInst(inst);
606 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_aaf9a05771a835f9f8d634cef36e24d40}{
\index{DefaultIEW@{DefaultIEW}!resetEntries@{resetEntries}}
\index{resetEntries@{resetEntries}!DefaultIEW@{DefaultIEW}}
\subsubsection[{resetEntries}]{\setlength{\rightskip}{0pt plus 5cm}void resetEntries ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_aaf9a05771a835f9f8d634cef36e24d40}
Resets entries of the IQ and the \hyperlink{classLSQ}{LSQ}. 


\begin{DoxyCode}
762 {
763     instQueue.resetEntries();
764     ldstQueue.resetEntries();
765 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_aab96bdacf8bd420402cbb543f994e054}{
\index{DefaultIEW@{DefaultIEW}!setActiveThreads@{setActiveThreads}}
\index{setActiveThreads@{setActiveThreads}!DefaultIEW@{DefaultIEW}}
\subsubsection[{setActiveThreads}]{\setlength{\rightskip}{0pt plus 5cm}void setActiveThreads ({\bf std::list}$<$ {\bf ThreadID} $>$ $\ast$ {\em at\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_aab96bdacf8bd420402cbb543f994e054}
Sets pointer to list of active threads. 


\begin{DoxyCode}
371 {
372     activeThreads = at_ptr;
373 
374     ldstQueue.setActiveThreads(at_ptr);
375     instQueue.setActiveThreads(at_ptr);
376 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a6b8bf7d75423c9bccd93d50470f7f935}{
\index{DefaultIEW@{DefaultIEW}!setIEWQueue@{setIEWQueue}}
\index{setIEWQueue@{setIEWQueue}!DefaultIEW@{DefaultIEW}}
\subsubsection[{setIEWQueue}]{\setlength{\rightskip}{0pt plus 5cm}void setIEWQueue ({\bf TimeBuffer}$<$ {\bf IEWStruct} $>$ $\ast$ {\em iq\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_a6b8bf7d75423c9bccd93d50470f7f935}
Sets time buffer to pass on instructions to commit. 


\begin{DoxyCode}
361 {
362     iewQueue = iq_ptr;
363 
364     // Setup wire to write instructions to commit.
365     toCommit = iewQueue->getWire(0);
366 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a701624f92a819fe4205faede6e614d9f}{
\index{DefaultIEW@{DefaultIEW}!setRenameQueue@{setRenameQueue}}
\index{setRenameQueue@{setRenameQueue}!DefaultIEW@{DefaultIEW}}
\subsubsection[{setRenameQueue}]{\setlength{\rightskip}{0pt plus 5cm}void setRenameQueue ({\bf TimeBuffer}$<$ {\bf RenameStruct} $>$ $\ast$ {\em rq\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_a701624f92a819fe4205faede6e614d9f}
Sets time buffer for getting instructions coming from rename. 


\begin{DoxyCode}
351 {
352     renameQueue = rq_ptr;
353 
354     // Setup wire to read information from rename queue.
355     fromRename = renameQueue->getWire(-renameToIEWDelay);
356 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a6f43cb2e5396c650d07ea5e01e855c32}{
\index{DefaultIEW@{DefaultIEW}!setScoreboard@{setScoreboard}}
\index{setScoreboard@{setScoreboard}!DefaultIEW@{DefaultIEW}}
\subsubsection[{setScoreboard}]{\setlength{\rightskip}{0pt plus 5cm}void setScoreboard ({\bf Scoreboard} $\ast$ {\em sb\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_a6f43cb2e5396c650d07ea5e01e855c32}
Sets pointer to the scoreboard. 


\begin{DoxyCode}
381 {
382     scoreboard = sb_ptr;
383 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a2b521ea5f191fff72265f60d4ed5187b}{
\index{DefaultIEW@{DefaultIEW}!setTimeBuffer@{setTimeBuffer}}
\index{setTimeBuffer@{setTimeBuffer}!DefaultIEW@{DefaultIEW}}
\subsubsection[{setTimeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}void setTimeBuffer ({\bf TimeBuffer}$<$ {\bf TimeStruct} $>$ $\ast$ {\em tb\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_a2b521ea5f191fff72265f60d4ed5187b}
Sets main time buffer used for backwards communication. 


\begin{DoxyCode}
333 {
334     timeBuffer = tb_ptr;
335 
336     // Setup wire to read information from time buffer, from commit.
337     fromCommit = timeBuffer->getWire(-commitToIEWDelay);
338 
339     // Setup wire to write information back to previous stages.
340     toRename = timeBuffer->getWire(0);
341 
342     toFetch = timeBuffer->getWire(0);
343 
344     // Instruction queue also needs main time buffer.
345     instQueue.setTimeBuffer(tb_ptr);
346 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_af64dbc63d9980fb739ed89ddadb2b92e}{
\index{DefaultIEW@{DefaultIEW}!skidCount@{skidCount}}
\index{skidCount@{skidCount}!DefaultIEW@{DefaultIEW}}
\subsubsection[{skidCount}]{\setlength{\rightskip}{0pt plus 5cm}int skidCount ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_af64dbc63d9980fb739ed89ddadb2b92e}
Returns the max of the number of entries in all of the skid buffers. 


\begin{DoxyCode}
685 {
686     int max=0;
687 
688     list<ThreadID>::iterator threads = activeThreads->begin();
689     list<ThreadID>::iterator end = activeThreads->end();
690 
691     while (threads != end) {
692         ThreadID tid = *threads++;
693         unsigned thread_count = skidBuffer[tid].size();
694         if (max < thread_count)
695             max = thread_count;
696     }
697 
698     return max;
699 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_ac24515147270ef9b85991bbe13bd47af}{
\index{DefaultIEW@{DefaultIEW}!skidInsert@{skidInsert}}
\index{skidInsert@{skidInsert}!DefaultIEW@{DefaultIEW}}
\subsubsection[{skidInsert}]{\setlength{\rightskip}{0pt plus 5cm}void skidInsert ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_ac24515147270ef9b85991bbe13bd47af}
Inserts unused instructions of a thread into the skid buffer. 


\begin{DoxyCode}
663 {
664     DynInstPtr inst = NULL;
665 
666     while (!insts[tid].empty()) {
667         inst = insts[tid].front();
668 
669         insts[tid].pop();
670 
671         DPRINTF(IEW,"[tid:%i]: Inserting [sn:%lli] PC:%s into "
672                 "dispatch skidBuffer %i\n",tid, inst->seqNum,
673                 inst->pcState(),tid);
674 
675         skidBuffer[tid].push(inst);
676     }
677 
678     assert(skidBuffer[tid].size() <= skidBufferMax &&
679            "Skidbuffer Exceeded Max Size");
680 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_afe3e2673d17dd5c568862ef5ae68b4d8}{
\index{DefaultIEW@{DefaultIEW}!skidsEmpty@{skidsEmpty}}
\index{skidsEmpty@{skidsEmpty}!DefaultIEW@{DefaultIEW}}
\subsubsection[{skidsEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool skidsEmpty ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_afe3e2673d17dd5c568862ef5ae68b4d8}
Returns if all of the skid buffers are empty. 


\begin{DoxyCode}
704 {
705     list<ThreadID>::iterator threads = activeThreads->begin();
706     list<ThreadID>::iterator end = activeThreads->end();
707 
708     while (threads != end) {
709         ThreadID tid = *threads++;
710 
711         if (!skidBuffer[tid].empty())
712             return false;
713     }
714 
715     return true;
716 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a9ff2aa32ab0f40674cb3518108d62f8e}{
\index{DefaultIEW@{DefaultIEW}!sortInsts@{sortInsts}}
\index{sortInsts@{sortInsts}!DefaultIEW@{DefaultIEW}}
\subsubsection[{sortInsts}]{\setlength{\rightskip}{0pt plus 5cm}void sortInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultIEW_a9ff2aa32ab0f40674cb3518108d62f8e}
Sorts instructions coming from rename into lists separated by thread. 


\begin{DoxyCode}
887 {
888     int insts_from_rename = fromRename->size;
889 #ifdef DEBUG
890     for (ThreadID tid = 0; tid < numThreads; tid++)
891         assert(insts[tid].empty());
892 #endif
893     for (int i = 0; i < insts_from_rename; ++i) {
894         insts[fromRename->insts[i]->threadNumber].push(fromRename->insts[i]);
895     }
896 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_ad33d65c18c323d90695d7c2355b49af9}{
\index{DefaultIEW@{DefaultIEW}!squash@{squash}}
\index{squash@{squash}!DefaultIEW@{DefaultIEW}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_ad33d65c18c323d90695d7c2355b49af9}
Squashes instructions in IEW for a specific thread. 


\begin{DoxyCode}
455 {
456     DPRINTF(IEW, "[tid:%i]: Squashing all instructions.\n", tid);
457 
458     // Tell the IQ to start squashing.
459     instQueue.squash(tid);
460 
461     // Tell the LDSTQ to start squashing.
462     ldstQueue.squash(fromCommit->commitInfo[tid].doneSeqNum, tid);
463     updatedQueues = true;
464 
465     // Clear the skid buffer in case it has any data in it.
466     DPRINTF(IEW, "[tid:%i]: Removing skidbuffer instructions until [sn:%i].\n",
467             tid, fromCommit->commitInfo[tid].doneSeqNum);
468 
469     while (!skidBuffer[tid].empty()) {
470         if (skidBuffer[tid].front()->isLoad() ||
471             skidBuffer[tid].front()->isStore() ) {
472             toRename->iewInfo[tid].dispatchedToLSQ++;
473         }
474 
475         toRename->iewInfo[tid].dispatched++;
476 
477         skidBuffer[tid].pop();
478     }
479 
480     emptyRenameInsts(tid);
481 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a7312a115c34dfbb21d18b6d85fc46fb9}{
\index{DefaultIEW@{DefaultIEW}!squashDueToBranch@{squashDueToBranch}}
\index{squashDueToBranch@{squashDueToBranch}!DefaultIEW@{DefaultIEW}}
\subsubsection[{squashDueToBranch}]{\setlength{\rightskip}{0pt plus 5cm}void squashDueToBranch ({\bf DynInstPtr} \& {\em inst}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultIEW_a7312a115c34dfbb21d18b6d85fc46fb9}
Sends commit proper information for a squash due to a branch mispredict. 


\begin{DoxyCode}
486 {
487     DPRINTF(IEW, "[tid:%i]: Squashing from a specific instruction, PC: %s "
488             "[sn:%i].\n", tid, inst->pcState(), inst->seqNum);
489 
490     if (!toCommit->squash[tid] ||
491             inst->seqNum < toCommit->squashedSeqNum[tid]) {
492         toCommit->squash[tid] = true;
493         toCommit->squashedSeqNum[tid] = inst->seqNum;
494         toCommit->branchTaken[tid] = inst->pcState().branching();
495 
496         TheISA::PCState pc = inst->pcState();
497         TheISA::advancePC(pc, inst->staticInst);
498 
499         toCommit->pc[tid] = pc;
500         toCommit->mispredictInst[tid] = inst;
501         toCommit->includeSquashInst[tid] = false;
502 
503         wroteToTimeBuffer = true;
504     }
505 
506 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_aa471ebd447a37d3bf56e80c6ce0373f5}{
\index{DefaultIEW@{DefaultIEW}!squashDueToMemBlocked@{squashDueToMemBlocked}}
\index{squashDueToMemBlocked@{squashDueToMemBlocked}!DefaultIEW@{DefaultIEW}}
\subsubsection[{squashDueToMemBlocked}]{\setlength{\rightskip}{0pt plus 5cm}void squashDueToMemBlocked ({\bf DynInstPtr} \& {\em inst}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultIEW_aa471ebd447a37d3bf56e80c6ce0373f5}
Sends commit proper information for a squash due to memory becoming blocked (younger issued instructions must be retried). 


\begin{DoxyCode}
538 {
539     DPRINTF(IEW, "[tid:%i]: Memory blocked, squashing load and younger insts, "
540             "PC: %s [sn:%i].\n", tid, inst->pcState(), inst->seqNum);
541     if (!toCommit->squash[tid] ||
542             inst->seqNum < toCommit->squashedSeqNum[tid]) {
543         toCommit->squash[tid] = true;
544 
545         toCommit->squashedSeqNum[tid] = inst->seqNum;
546         toCommit->pc[tid] = inst->pcState();
547         toCommit->mispredictInst[tid] = NULL;
548 
549         // Must include the broadcasted SN in the squash.
550         toCommit->includeSquashInst[tid] = true;
551 
552         ldstQueue.setLoadBlockedHandled(tid);
553 
554         wroteToTimeBuffer = true;
555     }
556 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a581b3c0199d9fc6283bdc7dbcab26e45}{
\index{DefaultIEW@{DefaultIEW}!squashDueToMemOrder@{squashDueToMemOrder}}
\index{squashDueToMemOrder@{squashDueToMemOrder}!DefaultIEW@{DefaultIEW}}
\subsubsection[{squashDueToMemOrder}]{\setlength{\rightskip}{0pt plus 5cm}void squashDueToMemOrder ({\bf DynInstPtr} \& {\em inst}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultIEW_a581b3c0199d9fc6283bdc7dbcab26e45}
Sends commit proper information for a squash due to a memory order violation. 


\begin{DoxyCode}
511 {
512     DPRINTF(IEW, "[tid:%i]: Memory violation, squashing violator and younger "
513             "insts, PC: %s [sn:%i].\n", tid, inst->pcState(), inst->seqNum);
514     // Need to include inst->seqNum in the following comparison to cover the
515     // corner case when a branch misprediction and a memory violation for the
516     // same instruction (e.g. load PC) are detected in the same cycle.  In this
517     // case the memory violator should take precedence over the branch
518     // misprediction because it requires the violator itself to be included in
519     // the squash.
520     if (!toCommit->squash[tid] ||
521             inst->seqNum <= toCommit->squashedSeqNum[tid]) {
522         toCommit->squash[tid] = true;
523 
524         toCommit->squashedSeqNum[tid] = inst->seqNum;
525         toCommit->pc[tid] = inst->pcState();
526         toCommit->mispredictInst[tid] = NULL;
527 
528         // Must include the memory violator in the squash.
529         toCommit->includeSquashInst[tid] = true;
530 
531         wroteToTimeBuffer = true;
532     }
533 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a31d4cbdab16d4ff8d6bc7f84ece727da}{
\index{DefaultIEW@{DefaultIEW}!startupStage@{startupStage}}
\index{startupStage@{startupStage}!DefaultIEW@{DefaultIEW}}
\subsubsection[{startupStage}]{\setlength{\rightskip}{0pt plus 5cm}void startupStage ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_a31d4cbdab16d4ff8d6bc7f84ece727da}
Initializes stage; sends back the number of free IQ and \hyperlink{classLSQ}{LSQ} entries. 


\begin{DoxyCode}
311 {
312     for (ThreadID tid = 0; tid < numThreads; tid++) {
313         toRename->iewInfo[tid].usedIQ = true;
314         toRename->iewInfo[tid].freeIQEntries =
315             instQueue.numFreeEntries(tid);
316 
317         toRename->iewInfo[tid].usedLSQ = true;
318         toRename->iewInfo[tid].freeLSQEntries =
319             ldstQueue.numFreeEntries(tid);
320     }
321 
322     // Initialize the checker's dcache port here
323     if (cpu->checker) {
324         cpu->checker->setDcachePort(&cpu->getDataPort());
325     }
326 
327     cpu->activateStage(O3CPU::IEWIdx);
328 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a8674059ce345e23aac5086b2c3e24a43}{
\index{DefaultIEW@{DefaultIEW}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!DefaultIEW@{DefaultIEW}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_a8674059ce345e23aac5086b2c3e24a43}
Takes over from another CPU's thread. 


\begin{DoxyCode}
426 {
427     // Reset all state.
428     _status = Active;
429     exeStatus = Running;
430     wbStatus = Idle;
431 
432     instQueue.takeOverFrom();
433     ldstQueue.takeOverFrom();
434     fuPool->takeOverFrom();
435 
436     startupStage();
437     cpu->activityThisCycle();
438 
439     for (ThreadID tid = 0; tid < numThreads; tid++) {
440         dispatchStatus[tid] = Running;
441         stalls[tid].commit = false;
442         fetchRedirect[tid] = false;
443     }
444 
445     updateLSQNextCycle = false;
446 
447     for (int i = 0; i < issueToExecQueue.getSize(); ++i) {
448         issueToExecQueue.advance();
449     }
450 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a873dd91783f9efb4a590aded1f70d6b0}{
\index{DefaultIEW@{DefaultIEW}!tick@{tick}}
\index{tick@{tick}!DefaultIEW@{DefaultIEW}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_a873dd91783f9efb4a590aded1f70d6b0}
Ticks IEW stage, causing Dispatch, the IQ, the \hyperlink{classLSQ}{LSQ}, Execute, and Writeback to run for one cycle. 


\begin{DoxyCode}
1518 {
1519     wbNumInst = 0;
1520     wbCycle = 0;
1521 
1522     wroteToTimeBuffer = false;
1523     updatedQueues = false;
1524 
1525     sortInsts();
1526 
1527     // Free function units marked as being freed this cycle.
1528     fuPool->processFreeUnits();
1529 
1530     list<ThreadID>::iterator threads = activeThreads->begin();
1531     list<ThreadID>::iterator end = activeThreads->end();
1532 
1533     // Check stall and squash signals, dispatch any instructions.
1534     while (threads != end) {
1535         ThreadID tid = *threads++;
1536 
1537         DPRINTF(IEW,"Issue: Processing [tid:%i]\n",tid);
1538 
1539         checkSignalsAndUpdate(tid);
1540         dispatch(tid);
1541     }
1542 
1543     if (exeStatus != Squashing) {
1544         executeInsts();
1545 
1546         writebackInsts();
1547 
1548         // Have the instruction queue try to schedule any ready instructions.
1549         // (In actuality, this scheduling is for instructions that will
1550         // be executed next cycle.)
1551         instQueue.scheduleReadyInsts();
1552 
1553         // Also should advance its own time buffers if the stage ran.
1554         // Not the best place for it, but this works (hopefully).
1555         issueToExecQueue.advance();
1556     }
1557 
1558     bool broadcast_free_entries = false;
1559 
1560     if (updatedQueues || exeStatus == Running || updateLSQNextCycle) {
1561         exeStatus = Idle;
1562         updateLSQNextCycle = false;
1563 
1564         broadcast_free_entries = true;
1565     }
1566 
1567     // Writeback any stores using any leftover bandwidth.
1568     ldstQueue.writebackStores();
1569 
1570     // Check the committed load/store signals to see if there's a load
1571     // or store to commit.  Also check if it's being told to execute a
1572     // nonspeculative instruction.
1573     // This is pretty inefficient...
1574 
1575     threads = activeThreads->begin();
1576     while (threads != end) {
1577         ThreadID tid = (*threads++);
1578 
1579         DPRINTF(IEW,"Processing [tid:%i]\n",tid);
1580 
1581         // Update structures based on instructions committed.
1582         if (fromCommit->commitInfo[tid].doneSeqNum != 0 &&
1583             !fromCommit->commitInfo[tid].squash &&
1584             !fromCommit->commitInfo[tid].robSquashing) {
1585 
1586             ldstQueue.commitStores(fromCommit->commitInfo[tid].doneSeqNum,tid);
1587 
1588             ldstQueue.commitLoads(fromCommit->commitInfo[tid].doneSeqNum,tid);
1589 
1590             updateLSQNextCycle = true;
1591             instQueue.commit(fromCommit->commitInfo[tid].doneSeqNum,tid);
1592         }
1593 
1594         if (fromCommit->commitInfo[tid].nonSpecSeqNum != 0) {
1595 
1596             //DPRINTF(IEW,"NonspecInst from thread %i",tid);
1597             if (fromCommit->commitInfo[tid].uncached) {
1598                 instQueue.replayMemInst(fromCommit->commitInfo[tid].uncachedLoad)
      ;
1599                 fromCommit->commitInfo[tid].uncachedLoad->setAtCommit();
1600             } else {
1601                 instQueue.scheduleNonSpec(
1602                     fromCommit->commitInfo[tid].nonSpecSeqNum);
1603             }
1604         }
1605 
1606         if (broadcast_free_entries) {
1607             toFetch->iewInfo[tid].iqCount =
1608                 instQueue.getCount(tid);
1609             toFetch->iewInfo[tid].ldstqCount =
1610                 ldstQueue.getCount(tid);
1611 
1612             toRename->iewInfo[tid].usedIQ = true;
1613             toRename->iewInfo[tid].freeIQEntries =
1614                 instQueue.numFreeEntries(tid);
1615             toRename->iewInfo[tid].usedLSQ = true;
1616             toRename->iewInfo[tid].freeLSQEntries =
1617                 ldstQueue.numFreeEntries(tid);
1618 
1619             wroteToTimeBuffer = true;
1620         }
1621 
1622         DPRINTF(IEW, "[tid:%i], Dispatch dispatched %i instructions.\n",
1623                 tid, toRename->iewInfo[tid].dispatched);
1624     }
1625 
1626     DPRINTF(IEW, "IQ has %i free entries (Can schedule: %i).  "
1627             "LSQ has %i free entries.\n",
1628             instQueue.numFreeEntries(), instQueue.hasReadyInsts(),
1629             ldstQueue.numFreeEntries());
1630 
1631     updateStatus();
1632 
1633     if (wroteToTimeBuffer) {
1634         DPRINTF(Activity, "Activity this cycle.\n");
1635         cpu->activityThisCycle();
1636     }
1637 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a2c95e7e16c04d20ba742b9e97a4f0809}{
\index{DefaultIEW@{DefaultIEW}!unblock@{unblock}}
\index{unblock@{unblock}!DefaultIEW@{DefaultIEW}}
\subsubsection[{unblock}]{\setlength{\rightskip}{0pt plus 5cm}void unblock ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultIEW_a2c95e7e16c04d20ba742b9e97a4f0809}
Unblocks Dispatch if the skid buffer is empty, and signals back to other stages to unblock. 


\begin{DoxyCode}
580 {
581     DPRINTF(IEW, "[tid:%i]: Reading instructions out of the skid "
582             "buffer %u.\n",tid, tid);
583 
584     // If the skid bufffer is empty, signal back to previous stages to unblock.
585     // Also switch status to running.
586     if (skidBuffer[tid].empty()) {
587         toRename->iewUnblock[tid] = true;
588         wroteToTimeBuffer = true;
589         DPRINTF(IEW, "[tid:%i]: Done unblocking.\n",tid);
590         dispatchStatus[tid] = Running;
591     }
592 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a132db67a5c42af856da64e347e8284d8}{
\index{DefaultIEW@{DefaultIEW}!updateExeInstStats@{updateExeInstStats}}
\index{updateExeInstStats@{updateExeInstStats}!DefaultIEW@{DefaultIEW}}
\subsubsection[{updateExeInstStats}]{\setlength{\rightskip}{0pt plus 5cm}void updateExeInstStats ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultIEW_a132db67a5c42af856da64e347e8284d8}
Updates execution stats based on the instruction. 


\begin{DoxyCode}
1642 {
1643     ThreadID tid = inst->threadNumber;
1644 
1645     iewExecutedInsts++;
1646 
1647 #if TRACING_ON
1648     if (DTRACE(O3PipeView)) {
1649         inst->completeTick = curTick() - inst->fetchTick;
1650     }
1651 #endif
1652 
1653     //
1654     //  Control operations
1655     //
1656     if (inst->isControl())
1657         iewExecutedBranches[tid]++;
1658 
1659     //
1660     //  Memory operations
1661     //
1662     if (inst->isMemRef()) {
1663         iewExecutedRefs[tid]++;
1664 
1665         if (inst->isLoad()) {
1666             iewExecLoadInsts[tid]++;
1667         }
1668     }
1669 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a4bb9486757ce225941aaaf759b357a57}{
\index{DefaultIEW@{DefaultIEW}!updateStatus@{updateStatus}}
\index{updateStatus@{updateStatus}!DefaultIEW@{DefaultIEW}}
\subsubsection[{updateStatus}]{\setlength{\rightskip}{0pt plus 5cm}void updateStatus ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_a4bb9486757ce225941aaaf759b357a57}
Updates overall IEW status based on all of the stages' statuses. 


\begin{DoxyCode}
721 {
722     bool any_unblocking = false;
723 
724     list<ThreadID>::iterator threads = activeThreads->begin();
725     list<ThreadID>::iterator end = activeThreads->end();
726 
727     while (threads != end) {
728         ThreadID tid = *threads++;
729 
730         if (dispatchStatus[tid] == Unblocking) {
731             any_unblocking = true;
732             break;
733         }
734     }
735 
736     // If there are no ready instructions waiting to be scheduled by the IQ,
737     // and there's no stores waiting to write back, and dispatch is not
738     // unblocking, then there is no internal activity for the IEW stage.
739     instQueue.intInstQueueReads++;
740     if (_status == Active && !instQueue.hasReadyInsts() &&
741         !ldstQueue.willWB() && !any_unblocking) {
742         DPRINTF(IEW, "IEW switching to idle\n");
743 
744         deactivateStage();
745 
746         _status = Inactive;
747     } else if (_status == Inactive && (instQueue.hasReadyInsts() ||
748                                        ldstQueue.willWB() ||
749                                        any_unblocking)) {
750         // Otherwise there is internal activity.  Set to active.
751         DPRINTF(IEW, "IEW switching to active\n");
752 
753         activateStage();
754 
755         _status = Active;
756     }
757 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a5fc3225c48aefdbd7d923903a3aa5bc6}{
\index{DefaultIEW@{DefaultIEW}!validInstsFromRename@{validInstsFromRename}}
\index{validInstsFromRename@{validInstsFromRename}!DefaultIEW@{DefaultIEW}}
\subsubsection[{validInstsFromRename}]{\setlength{\rightskip}{0pt plus 5cm}unsigned validInstsFromRename ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultIEW_a5fc3225c48aefdbd7d923903a3aa5bc6}
Returns the number of valid, non-\/squashed instructions coming from rename to dispatch. 


\begin{DoxyCode}
649 {
650     unsigned inst_count = 0;
651 
652     for (int i=0; i<fromRename->size; i++) {
653         if (!fromRename->insts[i]->isSquashed())
654             inst_count++;
655     }
656 
657     return inst_count;
658 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_abce3a63b123f84972e4df7962f9b870e}{
\index{DefaultIEW@{DefaultIEW}!wakeCPU@{wakeCPU}}
\index{wakeCPU@{wakeCPU}!DefaultIEW@{DefaultIEW}}
\subsubsection[{wakeCPU}]{\setlength{\rightskip}{0pt plus 5cm}void wakeCPU ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_abce3a63b123f84972e4df7962f9b870e}
Tells the CPU to wakeup if it has descheduled itself due to no activity. Used mainly by the LdWritebackEvent. 


\begin{DoxyCode}
920 {
921     cpu->wakeCPU();
922 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a84834d31005dcede47e334bfee5b52d3}{
\index{DefaultIEW@{DefaultIEW}!wakeDependents@{wakeDependents}}
\index{wakeDependents@{wakeDependents}!DefaultIEW@{DefaultIEW}}
\subsubsection[{wakeDependents}]{\setlength{\rightskip}{0pt plus 5cm}void wakeDependents ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDefaultIEW_a84834d31005dcede47e334bfee5b52d3}
Wakes all dependents of a completed instruction. 


\begin{DoxyCode}
597 {
598     instQueue.wakeDependents(inst);
599 }
\end{DoxyCode}
\hypertarget{classDefaultIEW_a5e9a203f943b3a8a243ddc6d2a0a240d}{
\index{DefaultIEW@{DefaultIEW}!writebackInsts@{writebackInsts}}
\index{writebackInsts@{writebackInsts}!DefaultIEW@{DefaultIEW}}
\subsubsection[{writebackInsts}]{\setlength{\rightskip}{0pt plus 5cm}void writebackInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classDefaultIEW_a5e9a203f943b3a8a243ddc6d2a0a240d}
Writebacks instructions. In our model, the instruction's execute() function atomically reads registers, executes, and writes registers. Thus this writeback only wakes up dependent instructions, and informs the scoreboard of registers becoming ready. 


\begin{DoxyCode}
1473 {
1474     // Loop through the head of the time buffer and wake any
1475     // dependents.  These instructions are about to write back.  Also
1476     // mark scoreboard that this instruction is finally complete.
1477     // Either have IEW have direct access to scoreboard, or have this
1478     // as part of backwards communication.
1479     for (int inst_num = 0; inst_num < wbWidth &&
1480              toCommit->insts[inst_num]; inst_num++) {
1481         DynInstPtr inst = toCommit->insts[inst_num];
1482         ThreadID tid = inst->threadNumber;
1483 
1484         DPRINTF(IEW, "Sending instructions to commit, [sn:%lli] PC %s.\n",
1485                 inst->seqNum, inst->pcState());
1486 
1487         iewInstsToCommit[tid]++;
1488 
1489         // Some instructions will be sent to commit without having
1490         // executed because they need commit to handle them.
1491         // E.g. Uncached loads have not actually executed when they
1492         // are first sent to commit.  Instead commit must tell the LSQ
1493         // when it's ready to execute the uncached load.
1494         if (!inst->isSquashed() && inst->isExecuted() && inst->getFault() == 
      NoFault) {
1495             int dependents = instQueue.wakeDependents(inst);
1496 
1497             for (int i = 0; i < inst->numDestRegs(); i++) {
1498                 //mark as Ready
1499                 DPRINTF(IEW,"Setting Destination Register %i\n",
1500                         inst->renamedDestRegIdx(i));
1501                 scoreboard->setReg(inst->renamedDestRegIdx(i));
1502             }
1503 
1504             if (dependents) {
1505                 producerInst[tid]++;
1506                 consumerInst[tid]+= dependents;
1507             }
1508             writebackCount[tid]++;
1509         }
1510 
1511         decrWb(inst->seqNum);
1512     }
1513 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classDefaultIEW_a6cdf6e6db875a442f3ab6db542bd2bb5}{
\index{DefaultIEW@{DefaultIEW}!\_\-status@{\_\-status}}
\index{\_\-status@{\_\-status}!DefaultIEW@{DefaultIEW}}
\subsubsection[{\_\-status}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Status} {\bf \_\-status}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a6cdf6e6db875a442f3ab6db542bd2bb5}
Overall stage status. \hypertarget{classDefaultIEW_a7afe8710ac68efe63b0ae9fcca43853e}{
\index{DefaultIEW@{DefaultIEW}!ableToIssue@{ableToIssue}}
\index{ableToIssue@{ableToIssue}!DefaultIEW@{DefaultIEW}}
\subsubsection[{ableToIssue}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf ableToIssue}}}
\label{classDefaultIEW_a7afe8710ac68efe63b0ae9fcca43853e}
\hypertarget{classDefaultIEW_af6eaea53db532812052f71bf0380dab5}{
\index{DefaultIEW@{DefaultIEW}!activeThreads@{activeThreads}}
\index{activeThreads@{activeThreads}!DefaultIEW@{DefaultIEW}}
\subsubsection[{activeThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf ThreadID}$>$$\ast$ {\bf activeThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_af6eaea53db532812052f71bf0380dab5}
Pointer to list of active threads. \hypertarget{classDefaultIEW_a84b48267a042d76990dbfb6cec760fcb}{
\index{DefaultIEW@{DefaultIEW}!branchMispredicts@{branchMispredicts}}
\index{branchMispredicts@{branchMispredicts}!DefaultIEW@{DefaultIEW}}
\subsubsection[{branchMispredicts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf branchMispredicts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a84b48267a042d76990dbfb6cec760fcb}
Stat for total number of mispredicted branches detected at execute. \hypertarget{classDefaultIEW_a6b6fe1148ed7c40758e45f351c375552}{
\index{DefaultIEW@{DefaultIEW}!commitToIEWDelay@{commitToIEWDelay}}
\index{commitToIEWDelay@{commitToIEWDelay}!DefaultIEW@{DefaultIEW}}
\subsubsection[{commitToIEWDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf commitToIEWDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a6b6fe1148ed7c40758e45f351c375552}
Commit to IEW delay. \hypertarget{classDefaultIEW_a69b21b8b0360b93b3088bbf183fe6abf}{
\index{DefaultIEW@{DefaultIEW}!consumerInst@{consumerInst}}
\index{consumerInst@{consumerInst}!DefaultIEW@{DefaultIEW}}
\subsubsection[{consumerInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf consumerInst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a69b21b8b0360b93b3088bbf183fe6abf}
Number of instructions that wake up from producers. \hypertarget{classDefaultIEW_a1379cf882a12ac6fc9eba5da7c84b18b}{
\index{DefaultIEW@{DefaultIEW}!cpu@{cpu}}
\index{cpu@{cpu}!DefaultIEW@{DefaultIEW}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf O3CPU}$\ast$ {\bf cpu}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a1379cf882a12ac6fc9eba5da7c84b18b}
CPU pointer. \hypertarget{classDefaultIEW_a2ab1f59ca15f38f95b082415285ee273}{
\index{DefaultIEW@{DefaultIEW}!dispatchStatus@{dispatchStatus}}
\index{dispatchStatus@{dispatchStatus}!DefaultIEW@{DefaultIEW}}
\subsubsection[{dispatchStatus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StageStatus} {\bf dispatchStatus}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a2ab1f59ca15f38f95b082415285ee273}
Dispatch status. \hypertarget{classDefaultIEW_acd9a559a5f1d57c32c03c9a5b4299089}{
\index{DefaultIEW@{DefaultIEW}!dispatchWidth@{dispatchWidth}}
\index{dispatchWidth@{dispatchWidth}!DefaultIEW@{DefaultIEW}}
\subsubsection[{dispatchWidth}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf dispatchWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_acd9a559a5f1d57c32c03c9a5b4299089}
Width of dispatch, in instructions. \hypertarget{classDefaultIEW_ab8c04349b85b4d9bf03a601deee720b4}{
\index{DefaultIEW@{DefaultIEW}!exeStatus@{exeStatus}}
\index{exeStatus@{exeStatus}!DefaultIEW@{DefaultIEW}}
\subsubsection[{exeStatus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StageStatus} {\bf exeStatus}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_ab8c04349b85b4d9bf03a601deee720b4}
Execute status. \hypertarget{classDefaultIEW_aa40219506ff80e4e8c5a9a3b1205b282}{
\index{DefaultIEW@{DefaultIEW}!fetchRedirect@{fetchRedirect}}
\index{fetchRedirect@{fetchRedirect}!DefaultIEW@{DefaultIEW}}
\subsubsection[{fetchRedirect}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf fetchRedirect}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_aa40219506ff80e4e8c5a9a3b1205b282}
Records if there is a fetch redirect on this cycle for each thread. \hypertarget{classDefaultIEW_a0055a92bd94eda21c2641d46ff013dac}{
\index{DefaultIEW@{DefaultIEW}!fromCommit@{fromCommit}}
\index{fromCommit@{fromCommit}!DefaultIEW@{DefaultIEW}}
\subsubsection[{fromCommit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf fromCommit}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a0055a92bd94eda21c2641d46ff013dac}
\hyperlink{classWire}{Wire} to get commit's output from backwards time buffer. \hypertarget{classDefaultIEW_af6f43373b6586aa8c486538fb076effb}{
\index{DefaultIEW@{DefaultIEW}!fromIssue@{fromIssue}}
\index{fromIssue@{fromIssue}!DefaultIEW@{DefaultIEW}}
\subsubsection[{fromIssue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf IssueStruct}$>$::wire {\bf fromIssue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_af6f43373b6586aa8c486538fb076effb}
\hyperlink{classWire}{Wire} to read information from the issue stage time queue. \hypertarget{classDefaultIEW_a2b6b1d4785b92bd378f8a7abc5b7e6b9}{
\index{DefaultIEW@{DefaultIEW}!fromRename@{fromRename}}
\index{fromRename@{fromRename}!DefaultIEW@{DefaultIEW}}
\subsubsection[{fromRename}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf RenameStruct}$>$::wire {\bf fromRename}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a2b6b1d4785b92bd378f8a7abc5b7e6b9}
\hyperlink{classWire}{Wire} to get rename's output from rename queue. \hypertarget{classDefaultIEW_a480782fc1cfd21fd9748b26f2a08b97a}{
\index{DefaultIEW@{DefaultIEW}!fuPool@{fuPool}}
\index{fuPool@{fuPool}!DefaultIEW@{DefaultIEW}}
\subsubsection[{fuPool}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FUPool}$\ast$ {\bf fuPool}}}
\label{classDefaultIEW_a480782fc1cfd21fd9748b26f2a08b97a}
Pointer to the functional unit pool. \hypertarget{classDefaultIEW_a29d41a8f53acdfa4edcfa2c3238c8052}{
\index{DefaultIEW@{DefaultIEW}!iewBlockCycles@{iewBlockCycles}}
\index{iewBlockCycles@{iewBlockCycles}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewBlockCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iewBlockCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a29d41a8f53acdfa4edcfa2c3238c8052}
Stat for total number of blocking cycles. \hypertarget{classDefaultIEW_a60a497827df5bf20377131218dbb5856}{
\index{DefaultIEW@{DefaultIEW}!iewDispatchedInsts@{iewDispatchedInsts}}
\index{iewDispatchedInsts@{iewDispatchedInsts}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewDispatchedInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iewDispatchedInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a60a497827df5bf20377131218dbb5856}
Stat for total number of instructions dispatched. \hypertarget{classDefaultIEW_a4912d8eb8445e3613e37bd099b4838a5}{
\index{DefaultIEW@{DefaultIEW}!iewDispLoadInsts@{iewDispLoadInsts}}
\index{iewDispLoadInsts@{iewDispLoadInsts}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewDispLoadInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iewDispLoadInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a4912d8eb8445e3613e37bd099b4838a5}
Stat for total number of dispatched load instructions. \hypertarget{classDefaultIEW_ad97a775edfe3139e00cf90d6ce85cd6e}{
\index{DefaultIEW@{DefaultIEW}!iewDispNonSpecInsts@{iewDispNonSpecInsts}}
\index{iewDispNonSpecInsts@{iewDispNonSpecInsts}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewDispNonSpecInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iewDispNonSpecInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_ad97a775edfe3139e00cf90d6ce85cd6e}
Stat for total number of dispatched non speculative instructions. \hypertarget{classDefaultIEW_a43a5c3a932fadd9d0cbcc8da45f6ec2e}{
\index{DefaultIEW@{DefaultIEW}!iewDispSquashedInsts@{iewDispSquashedInsts}}
\index{iewDispSquashedInsts@{iewDispSquashedInsts}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewDispSquashedInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iewDispSquashedInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a43a5c3a932fadd9d0cbcc8da45f6ec2e}
Stat for total number of squashed instructions dispatch skips. \hypertarget{classDefaultIEW_a014a1fbd4e241bc9c3eb4d926aaf1156}{
\index{DefaultIEW@{DefaultIEW}!iewDispStoreInsts@{iewDispStoreInsts}}
\index{iewDispStoreInsts@{iewDispStoreInsts}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewDispStoreInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iewDispStoreInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a014a1fbd4e241bc9c3eb4d926aaf1156}
Stat for total number of dispatched store instructions. \hypertarget{classDefaultIEW_ad576ced7a991ca05c24bc21fc9d70cdc}{
\index{DefaultIEW@{DefaultIEW}!iewExecLoadInsts@{iewExecLoadInsts}}
\index{iewExecLoadInsts@{iewExecLoadInsts}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewExecLoadInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf iewExecLoadInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_ad576ced7a991ca05c24bc21fc9d70cdc}
Stat for total number of executed load instructions. \hypertarget{classDefaultIEW_a455816a7fa7ff2a5fa41cc7e7486d91b}{
\index{DefaultIEW@{DefaultIEW}!iewExecRate@{iewExecRate}}
\index{iewExecRate@{iewExecRate}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewExecRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf iewExecRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a455816a7fa7ff2a5fa41cc7e7486d91b}
Number of instructions executed per cycle. \hypertarget{classDefaultIEW_a822e0e5fd3e050a7b48437eab389be0a}{
\index{DefaultIEW@{DefaultIEW}!iewExecSquashedInsts@{iewExecSquashedInsts}}
\index{iewExecSquashedInsts@{iewExecSquashedInsts}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewExecSquashedInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iewExecSquashedInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a822e0e5fd3e050a7b48437eab389be0a}
Stat for total number of executed store instructions. Stat for total number of squashed instructions skipped at execute. \hypertarget{classDefaultIEW_a26e3fec9b7902bf996fbe1755c5bd063}{
\index{DefaultIEW@{DefaultIEW}!iewExecStoreInsts@{iewExecStoreInsts}}
\index{iewExecStoreInsts@{iewExecStoreInsts}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewExecStoreInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf iewExecStoreInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a26e3fec9b7902bf996fbe1755c5bd063}
Number of executed store instructions. \hypertarget{classDefaultIEW_a69db59d35af8f8904b1e176cb611fc9b}{
\index{DefaultIEW@{DefaultIEW}!iewExecutedBranches@{iewExecutedBranches}}
\index{iewExecutedBranches@{iewExecutedBranches}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewExecutedBranches}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf iewExecutedBranches}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a69db59d35af8f8904b1e176cb611fc9b}
Number of executed branches. \hypertarget{classDefaultIEW_a96ac594d4d0ac05306c6c3679ffbbfaa}{
\index{DefaultIEW@{DefaultIEW}!iewExecutedInsts@{iewExecutedInsts}}
\index{iewExecutedInsts@{iewExecutedInsts}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewExecutedInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iewExecutedInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a96ac594d4d0ac05306c6c3679ffbbfaa}
Stat for total number of executed instructions. \hypertarget{classDefaultIEW_a63390d8471177b1fbca3c4352cce1e8f}{
\index{DefaultIEW@{DefaultIEW}!iewExecutedNop@{iewExecutedNop}}
\index{iewExecutedNop@{iewExecutedNop}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewExecutedNop}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf iewExecutedNop}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a63390d8471177b1fbca3c4352cce1e8f}
Number of executed nops. \hypertarget{classDefaultIEW_a7fdb9d8f885ec0c7d7db3015b254c073}{
\index{DefaultIEW@{DefaultIEW}!iewExecutedRefs@{iewExecutedRefs}}
\index{iewExecutedRefs@{iewExecutedRefs}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewExecutedRefs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf iewExecutedRefs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a7fdb9d8f885ec0c7d7db3015b254c073}
Number of executed meomory references. \hypertarget{classDefaultIEW_ab4a8c8cadda04122d21fc9596057b8ce}{
\index{DefaultIEW@{DefaultIEW}!iewExecutedSwp@{iewExecutedSwp}}
\index{iewExecutedSwp@{iewExecutedSwp}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewExecutedSwp}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf iewExecutedSwp}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_ab4a8c8cadda04122d21fc9596057b8ce}
Number of executed software prefetches. \hypertarget{classDefaultIEW_a9da3679b5e992aaed3de418432902a59}{
\index{DefaultIEW@{DefaultIEW}!iewIdleCycles@{iewIdleCycles}}
\index{iewIdleCycles@{iewIdleCycles}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewIdleCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iewIdleCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a9da3679b5e992aaed3de418432902a59}
Stat for total number of idle cycles. \hypertarget{classDefaultIEW_ad02ecf3ed9ed64d465941dc4e5f402f9}{
\index{DefaultIEW@{DefaultIEW}!iewInstsToCommit@{iewInstsToCommit}}
\index{iewInstsToCommit@{iewInstsToCommit}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewInstsToCommit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf iewInstsToCommit}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_ad02ecf3ed9ed64d465941dc4e5f402f9}
Number of instructions sent to commit. \hypertarget{classDefaultIEW_af14622d1e3f6f89130c87183c0fd31b1}{
\index{DefaultIEW@{DefaultIEW}!iewIQFullEvents@{iewIQFullEvents}}
\index{iewIQFullEvents@{iewIQFullEvents}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewIQFullEvents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iewIQFullEvents}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_af14622d1e3f6f89130c87183c0fd31b1}
Stat for number of times the IQ becomes full. \hypertarget{classDefaultIEW_a98fa20b7c9538614aaba18ecf7b96cf6}{
\index{DefaultIEW@{DefaultIEW}!iewLSQFullEvents@{iewLSQFullEvents}}
\index{iewLSQFullEvents@{iewLSQFullEvents}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewLSQFullEvents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iewLSQFullEvents}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a98fa20b7c9538614aaba18ecf7b96cf6}
Stat for number of times the \hyperlink{classLSQ}{LSQ} becomes full. \hypertarget{classDefaultIEW_a034b0868914c304e81c13c4e645d2616}{
\index{DefaultIEW@{DefaultIEW}!iewQueue@{iewQueue}}
\index{iewQueue@{iewQueue}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf IEWStruct}$>$$\ast$ {\bf iewQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a034b0868914c304e81c13c4e645d2616}
IEW stage time buffer. Holds \hyperlink{classROB}{ROB} indices of instructions that can be marked as completed. \hypertarget{classDefaultIEW_acb215c0a56967a158558f7e8018cb68e}{
\index{DefaultIEW@{DefaultIEW}!iewSquashCycles@{iewSquashCycles}}
\index{iewSquashCycles@{iewSquashCycles}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewSquashCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iewSquashCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_acb215c0a56967a158558f7e8018cb68e}
Stat for total number of squashing cycles. \hypertarget{classDefaultIEW_aa77818f080dcd03ea5f5f593768b1740}{
\index{DefaultIEW@{DefaultIEW}!iewUnblockCycles@{iewUnblockCycles}}
\index{iewUnblockCycles@{iewUnblockCycles}!DefaultIEW@{DefaultIEW}}
\subsubsection[{iewUnblockCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf iewUnblockCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_aa77818f080dcd03ea5f5f593768b1740}
Stat for total number of unblocking cycles. \hypertarget{classDefaultIEW_a190caab0d0faf2269b72f46da4bac40f}{
\index{DefaultIEW@{DefaultIEW}!instQueue@{instQueue}}
\index{instQueue@{instQueue}!DefaultIEW@{DefaultIEW}}
\subsubsection[{instQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IQ} {\bf instQueue}}}
\label{classDefaultIEW_a190caab0d0faf2269b72f46da4bac40f}
Instruction queue. \hypertarget{classDefaultIEW_a1b0ce60f9b6c662a2f3df87a3e8b50f8}{
\index{DefaultIEW@{DefaultIEW}!insts@{insts}}
\index{insts@{insts}!DefaultIEW@{DefaultIEW}}
\subsubsection[{insts}]{\setlength{\rightskip}{0pt plus 5cm}std::queue$<${\bf DynInstPtr}$>$ {\bf insts}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a1b0ce60f9b6c662a2f3df87a3e8b50f8}
Queue of all instructions coming from rename this cycle. \hypertarget{classDefaultIEW_ae11bca71ca0d33ab0c3b0fafd7bbb758}{
\index{DefaultIEW@{DefaultIEW}!issueToExecQueue@{issueToExecQueue}}
\index{issueToExecQueue@{issueToExecQueue}!DefaultIEW@{DefaultIEW}}
\subsubsection[{issueToExecQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf IssueStruct}$>$ {\bf issueToExecQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_ae11bca71ca0d33ab0c3b0fafd7bbb758}
Issue stage queue. \hypertarget{classDefaultIEW_a40f102cb54be0bc75cfbd9a70b696091}{
\index{DefaultIEW@{DefaultIEW}!issueToExecuteDelay@{issueToExecuteDelay}}
\index{issueToExecuteDelay@{issueToExecuteDelay}!DefaultIEW@{DefaultIEW}}
\subsubsection[{issueToExecuteDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf issueToExecuteDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a40f102cb54be0bc75cfbd9a70b696091}
Issue to execute delay. What this actually represents is the amount of time it takes for an instruction to wake up, be scheduled, and sent to a FU for execution. \hypertarget{classDefaultIEW_a574eb3fb1659bd364f4f613662fa2ead}{
\index{DefaultIEW@{DefaultIEW}!issueWidth@{issueWidth}}
\index{issueWidth@{issueWidth}!DefaultIEW@{DefaultIEW}}
\subsubsection[{issueWidth}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf issueWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a574eb3fb1659bd364f4f613662fa2ead}
Width of issue, in instructions. \hypertarget{classDefaultIEW_a9f2a7c471091519f7d05832eb48c2a9d}{
\index{DefaultIEW@{DefaultIEW}!ldstQueue@{ldstQueue}}
\index{ldstQueue@{ldstQueue}!DefaultIEW@{DefaultIEW}}
\subsubsection[{ldstQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf LSQ} {\bf ldstQueue}}}
\label{classDefaultIEW_a9f2a7c471091519f7d05832eb48c2a9d}
Load / store queue. \hypertarget{classDefaultIEW_a4cca8a82790f3c5dd13bd5c0b32ad774}{
\index{DefaultIEW@{DefaultIEW}!memOrderViolationEvents@{memOrderViolationEvents}}
\index{memOrderViolationEvents@{memOrderViolationEvents}!DefaultIEW@{DefaultIEW}}
\subsubsection[{memOrderViolationEvents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf memOrderViolationEvents}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a4cca8a82790f3c5dd13bd5c0b32ad774}
Stat for total number of memory ordering violation events. \hypertarget{classDefaultIEW_a88377f855dbf5adeeecb06b5bb821d35}{
\index{DefaultIEW@{DefaultIEW}!numThreads@{numThreads}}
\index{numThreads@{numThreads}!DefaultIEW@{DefaultIEW}}
\subsubsection[{numThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} {\bf numThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a88377f855dbf5adeeecb06b5bb821d35}
Number of active threads. \hypertarget{classDefaultIEW_acf84d288c6bc7f3ffbb09eb080dcbb7b}{
\index{DefaultIEW@{DefaultIEW}!ppDispatch@{ppDispatch}}
\index{ppDispatch@{ppDispatch}!DefaultIEW@{DefaultIEW}}
\subsubsection[{ppDispatch}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ProbePointArg}$<${\bf DynInstPtr}$>$$\ast$ {\bf ppDispatch}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_acf84d288c6bc7f3ffbb09eb080dcbb7b}
\hypertarget{classDefaultIEW_a78ed80917b5ebd419bf614b2e3b8f2cb}{
\index{DefaultIEW@{DefaultIEW}!ppMispredict@{ppMispredict}}
\index{ppMispredict@{ppMispredict}!DefaultIEW@{DefaultIEW}}
\subsubsection[{ppMispredict}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ProbePointArg}$<${\bf DynInstPtr}$>$$\ast$ {\bf ppMispredict}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a78ed80917b5ebd419bf614b2e3b8f2cb}
\hyperlink{namespaceProbe}{Probe} points. \hypertarget{classDefaultIEW_ae1cc96638781ca35cb92a5606bd508b7}{
\index{DefaultIEW@{DefaultIEW}!predictedNotTakenIncorrect@{predictedNotTakenIncorrect}}
\index{predictedNotTakenIncorrect@{predictedNotTakenIncorrect}!DefaultIEW@{DefaultIEW}}
\subsubsection[{predictedNotTakenIncorrect}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf predictedNotTakenIncorrect}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_ae1cc96638781ca35cb92a5606bd508b7}
Stat for total number of incorrect predicted not taken branches. \hypertarget{classDefaultIEW_aa848feac8bfb4947ca3acb410bfe75c6}{
\index{DefaultIEW@{DefaultIEW}!predictedTakenIncorrect@{predictedTakenIncorrect}}
\index{predictedTakenIncorrect@{predictedTakenIncorrect}!DefaultIEW@{DefaultIEW}}
\subsubsection[{predictedTakenIncorrect}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf predictedTakenIncorrect}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_aa848feac8bfb4947ca3acb410bfe75c6}
Stat for total number of incorrect predicted taken branches. \hypertarget{classDefaultIEW_a79df9c76c4c8c7da92694a4a571d44f0}{
\index{DefaultIEW@{DefaultIEW}!producerInst@{producerInst}}
\index{producerInst@{producerInst}!DefaultIEW@{DefaultIEW}}
\subsubsection[{producerInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf producerInst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a79df9c76c4c8c7da92694a4a571d44f0}
Number of instructions that wake consumers. \hypertarget{classDefaultIEW_ae9b536282159ba75153a223be77515ba}{
\index{DefaultIEW@{DefaultIEW}!renameQueue@{renameQueue}}
\index{renameQueue@{renameQueue}!DefaultIEW@{DefaultIEW}}
\subsubsection[{renameQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf RenameStruct}$>$$\ast$ {\bf renameQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_ae9b536282159ba75153a223be77515ba}
Rename instruction queue interface. \hypertarget{classDefaultIEW_a72426b859bd857b77c8402cc6bc1ac7a}{
\index{DefaultIEW@{DefaultIEW}!renameToIEWDelay@{renameToIEWDelay}}
\index{renameToIEWDelay@{renameToIEWDelay}!DefaultIEW@{DefaultIEW}}
\subsubsection[{renameToIEWDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf renameToIEWDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a72426b859bd857b77c8402cc6bc1ac7a}
Rename to IEW delay. \hypertarget{classDefaultIEW_a265ad15229da2a6a05f908da093b3ed5}{
\index{DefaultIEW@{DefaultIEW}!scoreboard@{scoreboard}}
\index{scoreboard@{scoreboard}!DefaultIEW@{DefaultIEW}}
\subsubsection[{scoreboard}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Scoreboard}$\ast$ {\bf scoreboard}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a265ad15229da2a6a05f908da093b3ed5}
\hyperlink{classScoreboard}{Scoreboard} pointer. \hypertarget{classDefaultIEW_a911bfd7c5c1efbd9f479d2b960078ec1}{
\index{DefaultIEW@{DefaultIEW}!skidBuffer@{skidBuffer}}
\index{skidBuffer@{skidBuffer}!DefaultIEW@{DefaultIEW}}
\subsubsection[{skidBuffer}]{\setlength{\rightskip}{0pt plus 5cm}std::queue$<${\bf DynInstPtr}$>$ {\bf skidBuffer}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a911bfd7c5c1efbd9f479d2b960078ec1}
Skid buffer between rename and IEW. \hypertarget{classDefaultIEW_a268414a6444b620140f263013a739a17}{
\index{DefaultIEW@{DefaultIEW}!skidBufferMax@{skidBufferMax}}
\index{skidBufferMax@{skidBufferMax}!DefaultIEW@{DefaultIEW}}
\subsubsection[{skidBufferMax}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf skidBufferMax}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a268414a6444b620140f263013a739a17}
Maximum size of the skid buffer. \hypertarget{classDefaultIEW_ade48cf321f5741ea8e54e071680cacdc}{
\index{DefaultIEW@{DefaultIEW}!stalls@{stalls}}
\index{stalls@{stalls}!DefaultIEW@{DefaultIEW}}
\subsubsection[{stalls}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stalls} {\bf stalls}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_ade48cf321f5741ea8e54e071680cacdc}
Stages that are telling IEW to stall. \hypertarget{classDefaultIEW_a83f9ee976e732665aeb08dbc19acfd45}{
\index{DefaultIEW@{DefaultIEW}!timeBuffer@{timeBuffer}}
\index{timeBuffer@{timeBuffer}!DefaultIEW@{DefaultIEW}}
\subsubsection[{timeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$$\ast$ {\bf timeBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a83f9ee976e732665aeb08dbc19acfd45}
Pointer to main time buffer used for backwards communication. \hypertarget{classDefaultIEW_aaebdc531a44267a7cc38b8bb6d3690d4}{
\index{DefaultIEW@{DefaultIEW}!toCommit@{toCommit}}
\index{toCommit@{toCommit}!DefaultIEW@{DefaultIEW}}
\subsubsection[{toCommit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf IEWStruct}$>$::wire {\bf toCommit}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_aaebdc531a44267a7cc38b8bb6d3690d4}
\hyperlink{classWire}{Wire} to write infromation heading to commit. \hypertarget{classDefaultIEW_acc94cfae2a67b5dbb0e74e81c24a3b6e}{
\index{DefaultIEW@{DefaultIEW}!toFetch@{toFetch}}
\index{toFetch@{toFetch}!DefaultIEW@{DefaultIEW}}
\subsubsection[{toFetch}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf toFetch}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_acc94cfae2a67b5dbb0e74e81c24a3b6e}
\hyperlink{classWire}{Wire} to write information heading to previous stages. \hypertarget{classDefaultIEW_a0f41e335a1b036cd36ccec9716b2ee2b}{
\index{DefaultIEW@{DefaultIEW}!toRename@{toRename}}
\index{toRename@{toRename}!DefaultIEW@{DefaultIEW}}
\subsubsection[{toRename}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf TimeStruct}$>$::wire {\bf toRename}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a0f41e335a1b036cd36ccec9716b2ee2b}
\hyperlink{classWire}{Wire} to write information heading to previous stages. \hypertarget{classDefaultIEW_abdd12485100503d860c2aeda746cfd75}{
\index{DefaultIEW@{DefaultIEW}!updatedQueues@{updatedQueues}}
\index{updatedQueues@{updatedQueues}!DefaultIEW@{DefaultIEW}}
\subsubsection[{updatedQueues}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf updatedQueues}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_abdd12485100503d860c2aeda746cfd75}
Records if the queues have been changed (inserted or issued \hyperlink{namespaceinsts}{insts}), so that IEW knows to broadcast the updated amount of free entries. \hypertarget{classDefaultIEW_a5cbd0281152001f7337f5d95155db5c0}{
\index{DefaultIEW@{DefaultIEW}!updateLSQNextCycle@{updateLSQNextCycle}}
\index{updateLSQNextCycle@{updateLSQNextCycle}!DefaultIEW@{DefaultIEW}}
\subsubsection[{updateLSQNextCycle}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf updateLSQNextCycle}}}
\label{classDefaultIEW_a5cbd0281152001f7337f5d95155db5c0}
Records if the \hyperlink{classLSQ}{LSQ} needs to be updated on the next cycle, so that IEW knows if there will be activity on the next cycle. \hypertarget{classDefaultIEW_ad2c7b2687f864f2b7359eb393276996f}{
\index{DefaultIEW@{DefaultIEW}!wbCycle@{wbCycle}}
\index{wbCycle@{wbCycle}!DefaultIEW@{DefaultIEW}}
\subsubsection[{wbCycle}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf wbCycle}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_ad2c7b2687f864f2b7359eb393276996f}
Cycle number within the queue of instructions being written back. Used in case there are too many instructions writing back at the current cycle and writesbacks need to be scheduled for the future. See comments in \hyperlink{classDefaultIEW_a720e9865ffa6e84b756f5ec1d1a24d94}{instToCommit()}. \hypertarget{classDefaultIEW_a667246d811337454bc9ceccf8bbf8f1c}{
\index{DefaultIEW@{DefaultIEW}!wbFanout@{wbFanout}}
\index{wbFanout@{wbFanout}!DefaultIEW@{DefaultIEW}}
\subsubsection[{wbFanout}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf wbFanout}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a667246d811337454bc9ceccf8bbf8f1c}
Average number of woken instructions per writeback. \hypertarget{classDefaultIEW_a4feeca4f9ab71ed25ed257f08a09fe0e}{
\index{DefaultIEW@{DefaultIEW}!wbMax@{wbMax}}
\index{wbMax@{wbMax}!DefaultIEW@{DefaultIEW}}
\subsubsection[{wbMax}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf wbMax}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a4feeca4f9ab71ed25ed257f08a09fe0e}
Writeback width $\ast$ writeback depth, where writeback depth is the number of cycles of writing back instructions that can be buffered. \hypertarget{classDefaultIEW_a5fa0799bf5569437190dd1eda1d62b7b}{
\index{DefaultIEW@{DefaultIEW}!wbNumInst@{wbNumInst}}
\index{wbNumInst@{wbNumInst}!DefaultIEW@{DefaultIEW}}
\subsubsection[{wbNumInst}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf wbNumInst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a5fa0799bf5569437190dd1eda1d62b7b}
Index into queue of instructions being written back. \hypertarget{classDefaultIEW_a225199c05fd7bddaf95d0d79171b31dc}{
\index{DefaultIEW@{DefaultIEW}!wbOutstanding@{wbOutstanding}}
\index{wbOutstanding@{wbOutstanding}!DefaultIEW@{DefaultIEW}}
\subsubsection[{wbOutstanding}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf wbOutstanding}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a225199c05fd7bddaf95d0d79171b31dc}
Number of instructions in flight that will writeback. Number of instructions in flight that will writeback. \hypertarget{classDefaultIEW_a364daa8f3a358e41aa13fac115bb5e0f}{
\index{DefaultIEW@{DefaultIEW}!wbPenalized@{wbPenalized}}
\index{wbPenalized@{wbPenalized}!DefaultIEW@{DefaultIEW}}
\subsubsection[{wbPenalized}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf wbPenalized}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a364daa8f3a358e41aa13fac115bb5e0f}
Number of instructions that were delayed in writing back due to resource contention. \hypertarget{classDefaultIEW_a58a4cd085d39435e69bc1ee729422d84}{
\index{DefaultIEW@{DefaultIEW}!wbPenalizedRate@{wbPenalizedRate}}
\index{wbPenalizedRate@{wbPenalizedRate}!DefaultIEW@{DefaultIEW}}
\subsubsection[{wbPenalizedRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf wbPenalizedRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a58a4cd085d39435e69bc1ee729422d84}
Number of instructions per cycle delayed in writing back . \hypertarget{classDefaultIEW_a5ab2bb9fa8eb98a735a204082a37c9db}{
\index{DefaultIEW@{DefaultIEW}!wbRate@{wbRate}}
\index{wbRate@{wbRate}!DefaultIEW@{DefaultIEW}}
\subsubsection[{wbRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf wbRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a5ab2bb9fa8eb98a735a204082a37c9db}
Number of instructions per cycle written back. \hypertarget{classDefaultIEW_abc3a4c25708a2663da1d26bf7fc045a0}{
\index{DefaultIEW@{DefaultIEW}!wbStatus@{wbStatus}}
\index{wbStatus@{wbStatus}!DefaultIEW@{DefaultIEW}}
\subsubsection[{wbStatus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StageStatus} {\bf wbStatus}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_abc3a4c25708a2663da1d26bf7fc045a0}
Writeback status. \hypertarget{classDefaultIEW_a97c827109db73fbbd67c50a90eccf7ac}{
\index{DefaultIEW@{DefaultIEW}!wbWidth@{wbWidth}}
\index{wbWidth@{wbWidth}!DefaultIEW@{DefaultIEW}}
\subsubsection[{wbWidth}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf wbWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a97c827109db73fbbd67c50a90eccf7ac}
Writeback width. \hypertarget{classDefaultIEW_a85f5041a2e3375a2dc81bc0ae534aa2e}{
\index{DefaultIEW@{DefaultIEW}!writebackCount@{writebackCount}}
\index{writebackCount@{writebackCount}!DefaultIEW@{DefaultIEW}}
\subsubsection[{writebackCount}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf writebackCount}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a85f5041a2e3375a2dc81bc0ae534aa2e}
Number of instructions that writeback. \hypertarget{classDefaultIEW_a2c7e870d4babdac0dc91fc7ffabd0f3d}{
\index{DefaultIEW@{DefaultIEW}!wroteToTimeBuffer@{wroteToTimeBuffer}}
\index{wroteToTimeBuffer@{wroteToTimeBuffer}!DefaultIEW@{DefaultIEW}}
\subsubsection[{wroteToTimeBuffer}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf wroteToTimeBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDefaultIEW_a2c7e870d4babdac0dc91fc7ffabd0f3d}
Records if IEW has written to the time buffer this cycle, so that the CPU can deschedule itself if there is no activity. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/o3/\hyperlink{iew_8hh}{iew.hh}\item 
cpu/o3/\hyperlink{iew__impl_8hh}{iew\_\-impl.hh}\end{DoxyCompactItemize}
