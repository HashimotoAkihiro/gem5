\hypertarget{classMSHR}{
\section{クラス MSHR}
\label{classMSHR}\index{MSHR@{MSHR}}
}


{\ttfamily \#include $<$mshr.hh$>$}MSHRに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classMSHR}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classMSHR_1_1Target}{Target}
\item 
class \hyperlink{classMSHR_1_1TargetList}{TargetList}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classMSHR}{MSHR} $\ast$ $>$ \hyperlink{classMSHR_ad558dcd5b6beb35c76724ab05f90a077}{List}
\item 
typedef List::iterator \hyperlink{classMSHR_af944263ff3027ab76cf07354d3a3f0c6}{Iterator}
\item 
typedef List::const\_\-iterator \hyperlink{classMSHR_a91267e1b9ec14096dd01900290a0ba15}{ConstIterator}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classMSHR_aa8e449288b878ff3ff7f286eb4d28b6a}{needsExclusive} () const 
\item 
bool \hyperlink{classMSHR_a46636974002da45a91f2019ff47b5025}{isPendingDirty} () const 
\item 
bool \hyperlink{classMSHR_a492fb8bb0290ba36d8d05d9f86b8e754}{hasPostInvalidate} () const 
\item 
bool \hyperlink{classMSHR_a74c74cd6091f9e3e1523d3044ae9e9b4}{hasPostDowngrade} () const 
\item 
bool \hyperlink{classMSHR_a70c74b2809417ea8701dd6ba9e34312d}{isUncacheable} () const 
\item 
void \hyperlink{classMSHR_aea3dd4d447084fd85a6d737beefdc594}{allocate} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classMSHR_a0bb77b4ba61e408313e1118250f9278c}{addr}, int \hyperlink{classMSHR_a439227feff9d7f55384e8780cfc2eb82}{size}, \hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} when, \hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \_\-order)
\item 
bool \hyperlink{classMSHR_a89f5689827090dd1998bd3906e5454d1}{markInService} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classMSHR_aba459a1fb9c4f01c1911655c1db0e8e4}{clearDownstreamPending} ()
\item 
void \hyperlink{classMSHR_a2d68be4fd20ffdd7f7a9b51579eacc2f}{deallocate} ()
\item 
void \hyperlink{classMSHR_a84c132450efb0381229d03bba92d3d1d}{allocateTarget} (\hyperlink{classPacket}{PacketPtr} target, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} when, \hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classMSHR_a268baba59d9078c070be7059fd90d9bc}{order})
\item 
bool \hyperlink{classMSHR_a7501595166901f8ddffcad271441cdf4}{handleSnoop} (\hyperlink{classPacket}{PacketPtr} target, \hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classMSHR_a268baba59d9078c070be7059fd90d9bc}{order})
\item 
\hyperlink{classMSHR_ac9bcc3c4e7dc13e809c1ddc72d1df7b2}{MSHR} ()
\item 
int \hyperlink{classMSHR_ab22af10809b116b3a7ecba267c795c8a}{getNumTargets} () const 
\item 
bool \hyperlink{classMSHR_a9b007d67bfb5a6ff382a6d78ec08b3af}{hasTargets} () const 
\item 
\hyperlink{classMSHR_1_1Target}{Target} $\ast$ \hyperlink{classMSHR_ae068bab5bed8991efdfcd7829d9ca5e3}{getTarget} ()
\item 
void \hyperlink{classMSHR_a660e7beed1d7d25852a9bc63d1f314b3}{popTarget} ()
\item 
bool \hyperlink{classMSHR_aee2f7196808cfdd31122d93d11b633de}{isForwardNoResponse} () const 
\item 
bool \hyperlink{classMSHR_a6b0d016d76a2a7570d1d51eaa3086845}{promoteDeferredTargets} ()
\item 
void \hyperlink{classMSHR_aff2dbaf9542ae841979f44a7af2fab0b}{handleFill} (\hyperlink{classPacket}{Packet} $\ast$pkt, \hyperlink{classCacheBlk}{CacheBlk} $\ast$blk)
\item 
bool \hyperlink{classMSHR_a8eb60d4744b6212ad749f3a586759266}{checkFunctional} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classMSHR_ad5a464e147506af89ea2778d731fe46f}{print} (std::ostream \&os, int verbosity=0, const std::string \&prefix=\char`\"{}\char`\"{}) const 
\item 
std::string \hyperlink{classMSHR_ae8a5b5e9e0e6be3b115ee77fa7b4d0c8}{print} () const 
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMSHRQueue}{MSHRQueue} $\ast$ \hyperlink{classMSHR_a524ec1b0c7b11e23904171e42211679e}{queue}
\item 
\hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classMSHR_a268baba59d9078c070be7059fd90d9bc}{order}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classMSHR_a0bb77b4ba61e408313e1118250f9278c}{addr}
\item 
int \hyperlink{classMSHR_a439227feff9d7f55384e8780cfc2eb82}{size}
\item 
bool \hyperlink{classMSHR_a62bc84f4251f16cf0cfa0f8d96e00c37}{isSecure}
\item 
bool \hyperlink{classMSHR_a7f5c4fb6e9162689992ccd0cd7bce17b}{inService}
\item 
bool \hyperlink{classMSHR_a9b36b981f171b10bc35fbd5f79c3bae1}{isForward}
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classMSHR_a7ec985ceacc8f2c379dbccca0b2e0f44}{threadNum}
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classMSHR_a7cb362ebfb8750bd53baf5e8f96e00d0}{readyTime}
\item 
bool \hyperlink{classMSHR_a1f29f1c59828a6c0fecd2d33c992c8a4}{\_\-isUncacheable}
\item 
bool \hyperlink{classMSHR_a5ea3d1c4eadd163d5f9bd35927044ed5}{downstreamPending}
\item 
bool \hyperlink{classMSHR_a2c6e696fb220ec9db6d72d614998c800}{pendingDirty}
\item 
bool \hyperlink{classMSHR_af4c42f3027a6f426f32521a251fd724d}{postInvalidate}
\item 
bool \hyperlink{classMSHR_a361fccb7e46b8119bda165f80f2753ac}{postDowngrade}
\item 
uint8\_\-t $\ast$ \hyperlink{classMSHR_abe222f6d3581e7920dcad5306cc906a8}{data}
\item 
\hyperlink{classMSHR_af944263ff3027ab76cf07354d3a3f0c6}{Iterator} \hyperlink{classMSHR_a6ff6af8d20926ded4e18e8f676784ff6}{readyIter}
\item 
\hyperlink{classMSHR_af944263ff3027ab76cf07354d3a3f0c6}{Iterator} \hyperlink{classMSHR_afd1f01c04c4b2b391083188321ccd47e}{allocIter}
\item 
\hyperlink{classMSHR_1_1TargetList}{TargetList} \hyperlink{classMSHR_ac0771ddfd90fe1ffe0d2da35dad7dd36}{targets}
\item 
\hyperlink{classMSHR_1_1TargetList}{TargetList} \hyperlink{classMSHR_ab53d68e3f8e523ab7907b830d22bd35d}{deferredTargets}
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classMSHR_a3d057950abc60f70219bad94198fd407}{MSHRQueue}
\end{DoxyCompactItemize}


\subsection{説明}
Miss Status and handling \hyperlink{classRegister}{Register}. This class keeps all the information needed to handle a cache miss including a list of target requests. \begin{DoxySeeAlso}{参照}
gem5 Memory System 
\end{DoxySeeAlso}


\subsection{型定義}
\hypertarget{classMSHR_a91267e1b9ec14096dd01900290a0ba15}{
\index{MSHR@{MSHR}!ConstIterator@{ConstIterator}}
\index{ConstIterator@{ConstIterator}!MSHR@{MSHR}}
\subsubsection[{ConstIterator}]{\setlength{\rightskip}{0pt plus 5cm}typedef List::const\_\-iterator {\bf ConstIterator}}}
\label{classMSHR_a91267e1b9ec14096dd01900290a0ba15}
\hyperlink{classMSHR}{MSHR} list const\_\-iterator. \hypertarget{classMSHR_af944263ff3027ab76cf07354d3a3f0c6}{
\index{MSHR@{MSHR}!Iterator@{Iterator}}
\index{Iterator@{Iterator}!MSHR@{MSHR}}
\subsubsection[{Iterator}]{\setlength{\rightskip}{0pt plus 5cm}typedef List::iterator {\bf Iterator}}}
\label{classMSHR_af944263ff3027ab76cf07354d3a3f0c6}
\hyperlink{classMSHR}{MSHR} list iterator. \hypertarget{classMSHR_ad558dcd5b6beb35c76724ab05f90a077}{
\index{MSHR@{MSHR}!List@{List}}
\index{List@{List}!MSHR@{MSHR}}
\subsubsection[{List}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf MSHR} $\ast$$>$ {\bf List}}}
\label{classMSHR_ad558dcd5b6beb35c76724ab05f90a077}
A list of MSHRs. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classMSHR_ac9bcc3c4e7dc13e809c1ddc72d1df7b2}{
\index{MSHR@{MSHR}!MSHR@{MSHR}}
\index{MSHR@{MSHR}!MSHR@{MSHR}}
\subsubsection[{MSHR}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHR} ()}}
\label{classMSHR_ac9bcc3c4e7dc13e809c1ddc72d1df7b2}
A simple constructor. 


\begin{DoxyCode}
64            : readyTime(0), _isUncacheable(false), downstreamPending(false),
65                pendingDirty(false), postInvalidate(false),
66                postDowngrade(false), queue(NULL), order(0), addr(0), size(0),
67                isSecure(false), inService(false), isForward(false),
68                threadNum(InvalidThreadID), data(NULL)
69 {
70 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classMSHR_aea3dd4d447084fd85a6d737beefdc594}{
\index{MSHR@{MSHR}!allocate@{allocate}}
\index{allocate@{allocate}!MSHR@{MSHR}}
\subsubsection[{allocate}]{\setlength{\rightskip}{0pt plus 5cm}void allocate ({\bf Addr} {\em addr}, \/  int {\em size}, \/  {\bf PacketPtr} {\em pkt}, \/  {\bf Tick} {\em when}, \/  {\bf Counter} {\em \_\-order})}}
\label{classMSHR_aea3dd4d447084fd85a6d737beefdc594}
Allocate a miss to this \hyperlink{classMSHR}{MSHR}. 
\begin{DoxyParams}{引数}
\item[{\em cmd}]The requesting command. \item[{\em addr}]The address of the miss. \item[{\em asid}]The address space id of the miss. \item[{\em size}]The number of bytes to request. \item[{\em pkt}]The original miss. \end{DoxyParams}



\begin{DoxyCode}
206 {
207     addr = _addr;
208     size = _size;
209     isSecure = target->isSecure();
210     readyTime = whenReady;
211     order = _order;
212     assert(target);
213     isForward = false;
214     _isUncacheable = target->req->isUncacheable();
215     inService = false;
216     downstreamPending = false;
217     threadNum = 0;
218     assert(targets.isReset());
219     // Don't know of a case where we would allocate a new MSHR for a
220     // snoop (mem-side request), so set source according to request here
221     Target::Source source = (target->cmd == MemCmd::HardPFReq) ?
222         Target::FromPrefetcher : Target::FromCPU;
223     targets.add(target, whenReady, _order, source, true);
224     assert(deferredTargets.isReset());
225     data = NULL;
226 }
\end{DoxyCode}
\hypertarget{classMSHR_a84c132450efb0381229d03bba92d3d1d}{
\index{MSHR@{MSHR}!allocateTarget@{allocateTarget}}
\index{allocateTarget@{allocateTarget}!MSHR@{MSHR}}
\subsubsection[{allocateTarget}]{\setlength{\rightskip}{0pt plus 5cm}void allocateTarget ({\bf PacketPtr} {\em target}, \/  {\bf Tick} {\em when}, \/  {\bf Counter} {\em order})}}
\label{classMSHR_a84c132450efb0381229d03bba92d3d1d}
Add a request to the list of targets. 
\begin{DoxyParams}{引数}
\item[{\em target}]The target. \end{DoxyParams}



\begin{DoxyCode}
278 {
279     // if there's a request already in service for this MSHR, we will
280     // have to defer the new target until after the response if any of
281     // the following are true:
282     // - there are other targets already deferred
283     // - there's a pending invalidate to be applied after the response
284     //   comes back (but before this target is processed)
285     // - this target requires an exclusive block and either we're not
286     //   getting an exclusive block back or we have already snooped
287     //   another read request that will downgrade our exclusive block
288     //   to shared
289 
290     // assume we'd never issue a prefetch when we've got an
291     // outstanding miss
292     assert(pkt->cmd != MemCmd::HardPFReq);
293 
294     if (inService &&
295         (!deferredTargets.empty() || hasPostInvalidate() ||
296          (pkt->needsExclusive() &&
297           (!isPendingDirty() || hasPostDowngrade() || isForward)))) {
298         // need to put on deferred list
299         if (hasPostInvalidate())
300             replaceUpgrade(pkt);
301         deferredTargets.add(pkt, whenReady, _order, Target::FromCPU, true);
302     } else {
303         // No request outstanding, or still OK to append to
304         // outstanding request: append to regular target list.  Only
305         // mark pending if current request hasn't been issued yet
306         // (isn't in service).
307         targets.add(pkt, whenReady, _order, Target::FromCPU, !inService);
308     }
309 }
\end{DoxyCode}
\hypertarget{classMSHR_a8eb60d4744b6212ad749f3a586759266}{
\index{MSHR@{MSHR}!checkFunctional@{checkFunctional}}
\index{checkFunctional@{checkFunctional}!MSHR@{MSHR}}
\subsubsection[{checkFunctional}]{\setlength{\rightskip}{0pt plus 5cm}bool checkFunctional ({\bf PacketPtr} {\em pkt})}}
\label{classMSHR_a8eb60d4744b6212ad749f3a586759266}



\begin{DoxyCode}
439 {
440     // For printing, we treat the MSHR as a whole as single entity.
441     // For other requests, we iterate over the individual targets
442     // since that's where the actual data lies.
443     if (pkt->isPrint()) {
444         pkt->checkFunctional(this, addr, isSecure, size, NULL);
445         return false;
446     } else {
447         return (targets.checkFunctional(pkt) ||
448                 deferredTargets.checkFunctional(pkt));
449     }
450 }
\end{DoxyCode}
\hypertarget{classMSHR_aba459a1fb9c4f01c1911655c1db0e8e4}{
\index{MSHR@{MSHR}!clearDownstreamPending@{clearDownstreamPending}}
\index{clearDownstreamPending@{clearDownstreamPending}!MSHR@{MSHR}}
\subsubsection[{clearDownstreamPending}]{\setlength{\rightskip}{0pt plus 5cm}void clearDownstreamPending ()}}
\label{classMSHR_aba459a1fb9c4f01c1911655c1db0e8e4}



\begin{DoxyCode}
231 {
232     assert(downstreamPending);
233     downstreamPending = false;
234     // recursively clear flag on any MSHRs we will be forwarding
235     // responses to
236     targets.clearDownstreamPending();
237 }
\end{DoxyCode}
\hypertarget{classMSHR_a2d68be4fd20ffdd7f7a9b51579eacc2f}{
\index{MSHR@{MSHR}!deallocate@{deallocate}}
\index{deallocate@{deallocate}!MSHR@{MSHR}}
\subsubsection[{deallocate}]{\setlength{\rightskip}{0pt plus 5cm}void deallocate ()}}
\label{classMSHR_a2d68be4fd20ffdd7f7a9b51579eacc2f}
Mark this \hyperlink{classMSHR}{MSHR} as free. 


\begin{DoxyCode}
266 {
267     assert(targets.empty());
268     targets.resetFlags();
269     assert(deferredTargets.isReset());
270     inService = false;
271 }
\end{DoxyCode}
\hypertarget{classMSHR_ab22af10809b116b3a7ecba267c795c8a}{
\index{MSHR@{MSHR}!getNumTargets@{getNumTargets}}
\index{getNumTargets@{getNumTargets}!MSHR@{MSHR}}
\subsubsection[{getNumTargets}]{\setlength{\rightskip}{0pt plus 5cm}int getNumTargets () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMSHR_ab22af10809b116b3a7ecba267c795c8a}
Returns the current number of allocated targets. \begin{DoxyReturn}{戻り値}
The current number of allocated targets. 
\end{DoxyReturn}



\begin{DoxyCode}
252     { return targets.size() + deferredTargets.size(); }
\end{DoxyCode}
\hypertarget{classMSHR_ae068bab5bed8991efdfcd7829d9ca5e3}{
\index{MSHR@{MSHR}!getTarget@{getTarget}}
\index{getTarget@{getTarget}!MSHR@{MSHR}}
\subsubsection[{getTarget}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Target}$\ast$ getTarget ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMSHR_ae068bab5bed8991efdfcd7829d9ca5e3}
Returns a reference to the first target. \begin{DoxyReturn}{戻り値}
A pointer to the first target. 
\end{DoxyReturn}



\begin{DoxyCode}
265     {
266         assert(hasTargets());
267         return &targets.front();
268     }
\end{DoxyCode}
\hypertarget{classMSHR_aff2dbaf9542ae841979f44a7af2fab0b}{
\index{MSHR@{MSHR}!handleFill@{handleFill}}
\index{handleFill@{handleFill}!MSHR@{MSHR}}
\subsubsection[{handleFill}]{\setlength{\rightskip}{0pt plus 5cm}void handleFill ({\bf Packet} $\ast$ {\em pkt}, \/  {\bf CacheBlk} $\ast$ {\em blk})}}
\label{classMSHR_aff2dbaf9542ae841979f44a7af2fab0b}



\begin{DoxyCode}
412 {
413     if (!pkt->sharedAsserted()
414         && !(hasPostInvalidate() || hasPostDowngrade())
415         && deferredTargets.needsExclusive) {
416         // We got an exclusive response, but we have deferred targets
417         // which are waiting to request an exclusive copy (not because
418         // of a pending invalidate).  This can happen if the original
419         // request was for a read-only (non-exclusive) block, but we
420         // got an exclusive copy anyway because of the E part of the
421         // MOESI/MESI protocol.  Since we got the exclusive copy
422         // there's no need to defer the targets, so move them up to
423         // the regular target list.
424         assert(!targets.needsExclusive);
425         targets.needsExclusive = true;
426         // if any of the deferred targets were upper-level cache
427         // requests marked downstreamPending, need to clear that
428         assert(!downstreamPending);  // not pending here anymore
429         deferredTargets.clearDownstreamPending();
430         // this clears out deferredTargets too
431         targets.splice(targets.end(), deferredTargets);
432         deferredTargets.resetFlags();
433     }
434 }
\end{DoxyCode}
\hypertarget{classMSHR_a7501595166901f8ddffcad271441cdf4}{
\index{MSHR@{MSHR}!handleSnoop@{handleSnoop}}
\index{handleSnoop@{handleSnoop}!MSHR@{MSHR}}
\subsubsection[{handleSnoop}]{\setlength{\rightskip}{0pt plus 5cm}bool handleSnoop ({\bf PacketPtr} {\em target}, \/  {\bf Counter} {\em order})}}
\label{classMSHR_a7501595166901f8ddffcad271441cdf4}



\begin{DoxyCode}
313 {
314     DPRINTF(Cache, "%s for %s address %x size %d\n", __func__,
315             pkt->cmdString(), pkt->getAddr(), pkt->getSize());
316     if (!inService || (pkt->isExpressSnoop() && downstreamPending)) {
317         // Request has not been issued yet, or it's been issued
318         // locally but is buffered unissued at some downstream cache
319         // which is forwarding us this snoop.  Either way, the packet
320         // we're snooping logically precedes this MSHR's request, so
321         // the snoop has no impact on the MSHR, but must be processed
322         // in the standard way by the cache.  The only exception is
323         // that if we're an L2+ cache buffering an UpgradeReq from a
324         // higher-level cache, and the snoop is invalidating, then our
325         // buffered upgrades must be converted to read exclusives,
326         // since the upper-level cache no longer has a valid copy.
327         // That is, even though the upper-level cache got out on its
328         // local bus first, some other invalidating transaction
329         // reached the global bus before the upgrade did.
330         if (pkt->needsExclusive()) {
331             targets.replaceUpgrades();
332             deferredTargets.replaceUpgrades();
333         }
334 
335         return false;
336     }
337 
338     // From here on down, the request issued by this MSHR logically
339     // precedes the request we're snooping.
340     if (pkt->needsExclusive()) {
341         // snooped request still precedes the re-request we'll have to
342         // issue for deferred targets, if any...
343         deferredTargets.replaceUpgrades();
344     }
345 
346     if (hasPostInvalidate()) {
347         // a prior snoop has already appended an invalidation, so
348         // logically we don't have the block anymore; no need for
349         // further snooping.
350         return true;
351     }
352 
353     if (isPendingDirty() || pkt->isInvalidate()) {
354         // We need to save and replay the packet in two cases:
355         // 1. We're awaiting an exclusive copy, so ownership is pending,
356         //    and we need to respond after we receive data.
357         // 2. It's an invalidation (e.g., UpgradeReq), and we need
358         //    to forward the snoop up the hierarchy after the current
359         //    transaction completes.
360         
361         // Actual target device (typ. a memory) will delete the
362         // packet on reception, so we need to save a copy here.
363         PacketPtr cp_pkt = new Packet(pkt, true);
364         targets.add(cp_pkt, curTick(), _order, Target::FromSnoop,
365                      downstreamPending && targets.needsExclusive);
366 
367         if (isPendingDirty()) {
368             pkt->assertMemInhibit();
369             pkt->setSupplyExclusive();
370         }
371 
372         if (pkt->needsExclusive()) {
373             // This transaction will take away our pending copy
374             postInvalidate = true;
375         }
376     }
377 
378     if (!pkt->needsExclusive()) {
379         // This transaction will get a read-shared copy, downgrading
380         // our copy if we had an exclusive one
381         postDowngrade = true;
382         pkt->assertShared();
383     }
384 
385     return true;
386 }
\end{DoxyCode}
\hypertarget{classMSHR_a74c74cd6091f9e3e1523d3044ae9e9b4}{
\index{MSHR@{MSHR}!hasPostDowngrade@{hasPostDowngrade}}
\index{hasPostDowngrade@{hasPostDowngrade}!MSHR@{MSHR}}
\subsubsection[{hasPostDowngrade}]{\setlength{\rightskip}{0pt plus 5cm}bool hasPostDowngrade () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMSHR_a74c74cd6091f9e3e1523d3044ae9e9b4}



\begin{DoxyCode}
183                                   {
184         assert(inService); return postDowngrade;
185     }
\end{DoxyCode}
\hypertarget{classMSHR_a492fb8bb0290ba36d8d05d9f86b8e754}{
\index{MSHR@{MSHR}!hasPostInvalidate@{hasPostInvalidate}}
\index{hasPostInvalidate@{hasPostInvalidate}!MSHR@{MSHR}}
\subsubsection[{hasPostInvalidate}]{\setlength{\rightskip}{0pt plus 5cm}bool hasPostInvalidate () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMSHR_a492fb8bb0290ba36d8d05d9f86b8e754}



\begin{DoxyCode}
179                                    {
180         assert(inService); return postInvalidate;
181     }
\end{DoxyCode}
\hypertarget{classMSHR_a9b007d67bfb5a6ff382a6d78ec08b3af}{
\index{MSHR@{MSHR}!hasTargets@{hasTargets}}
\index{hasTargets@{hasTargets}!MSHR@{MSHR}}
\subsubsection[{hasTargets}]{\setlength{\rightskip}{0pt plus 5cm}bool hasTargets () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMSHR_a9b007d67bfb5a6ff382a6d78ec08b3af}
Returns true if there are targets left. \begin{DoxyReturn}{戻り値}
true if there are targets 
\end{DoxyReturn}



\begin{DoxyCode}
258 { return !targets.empty(); }
\end{DoxyCode}
\hypertarget{classMSHR_aee2f7196808cfdd31122d93d11b633de}{
\index{MSHR@{MSHR}!isForwardNoResponse@{isForwardNoResponse}}
\index{isForwardNoResponse@{isForwardNoResponse}!MSHR@{MSHR}}
\subsubsection[{isForwardNoResponse}]{\setlength{\rightskip}{0pt plus 5cm}bool isForwardNoResponse () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMSHR_aee2f7196808cfdd31122d93d11b633de}



\begin{DoxyCode}
279     {
280         if (getNumTargets() != 1)
281             return false;
282         const Target *tgt = &targets.front();
283         return tgt->source == Target::FromCPU && !tgt->pkt->needsResponse();
284     }
\end{DoxyCode}
\hypertarget{classMSHR_a46636974002da45a91f2019ff47b5025}{
\index{MSHR@{MSHR}!isPendingDirty@{isPendingDirty}}
\index{isPendingDirty@{isPendingDirty}!MSHR@{MSHR}}
\subsubsection[{isPendingDirty}]{\setlength{\rightskip}{0pt plus 5cm}bool isPendingDirty () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMSHR_a46636974002da45a91f2019ff47b5025}



\begin{DoxyCode}
175                                 {
176         assert(inService); return pendingDirty;
177     }
\end{DoxyCode}
\hypertarget{classMSHR_a70c74b2809417ea8701dd6ba9e34312d}{
\index{MSHR@{MSHR}!isUncacheable@{isUncacheable}}
\index{isUncacheable@{isUncacheable}!MSHR@{MSHR}}
\subsubsection[{isUncacheable}]{\setlength{\rightskip}{0pt plus 5cm}bool isUncacheable () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMSHR_a70c74b2809417ea8701dd6ba9e34312d}



\begin{DoxyCode}
215 { return _isUncacheable; }
\end{DoxyCode}
\hypertarget{classMSHR_a89f5689827090dd1998bd3906e5454d1}{
\index{MSHR@{MSHR}!markInService@{markInService}}
\index{markInService@{markInService}!MSHR@{MSHR}}
\subsubsection[{markInService}]{\setlength{\rightskip}{0pt plus 5cm}bool markInService ({\bf PacketPtr} {\em pkt})}}
\label{classMSHR_a89f5689827090dd1998bd3906e5454d1}



\begin{DoxyCode}
241 {
242     assert(!inService);
243     if (isForwardNoResponse()) {
244         // we just forwarded the request packet & don't expect a
245         // response, so get rid of it
246         assert(getNumTargets() == 1);
247         popTarget();
248         return true;
249     }
250     inService = true;
251     pendingDirty = (targets.needsExclusive ||
252                     (!pkt->sharedAsserted() && pkt->memInhibitAsserted()));
253     postInvalidate = postDowngrade = false;
254 
255     if (!downstreamPending) {
256         // let upstream caches know that the request has made it to a
257         // level where it's going to get a response
258         targets.clearDownstreamPending();
259     }
260     return false;
261 }
\end{DoxyCode}
\hypertarget{classMSHR_aa8e449288b878ff3ff7f286eb4d28b6a}{
\index{MSHR@{MSHR}!needsExclusive@{needsExclusive}}
\index{needsExclusive@{needsExclusive}!MSHR@{MSHR}}
\subsubsection[{needsExclusive}]{\setlength{\rightskip}{0pt plus 5cm}bool needsExclusive () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMSHR_aa8e449288b878ff3ff7f286eb4d28b6a}
The pending$\ast$ and post$\ast$ flags are only valid if inService is true. Using the accessor functions lets us detect if these flags are accessed improperly. True if we need to get an exclusive copy of the block. 


\begin{DoxyCode}
173 { return targets.needsExclusive; }
\end{DoxyCode}
\hypertarget{classMSHR_a660e7beed1d7d25852a9bc63d1f314b3}{
\index{MSHR@{MSHR}!popTarget@{popTarget}}
\index{popTarget@{popTarget}!MSHR@{MSHR}}
\subsubsection[{popTarget}]{\setlength{\rightskip}{0pt plus 5cm}void popTarget ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMSHR_a660e7beed1d7d25852a9bc63d1f314b3}
Pop first target. 


\begin{DoxyCode}
274     {
275         targets.pop_front();
276     }
\end{DoxyCode}
\hypertarget{classMSHR_ae8a5b5e9e0e6be3b115ee77fa7b4d0c8}{
\index{MSHR@{MSHR}!print@{print}}
\index{print@{print}!MSHR@{MSHR}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}std::string print () const}}
\label{classMSHR_ae8a5b5e9e0e6be3b115ee77fa7b4d0c8}
A no-\/args wrapper of print(std::ostream...) meant to be invoked from DPRINTFs avoiding string overheads in fast mode

\begin{DoxyReturn}{戻り値}
string with mshr fields + \mbox{[}deferred\mbox{]}targets 
\end{DoxyReturn}



\begin{DoxyCode}
478 {
479     ostringstream str;
480     print(str);
481     return str.str();
482 }
\end{DoxyCode}
\hypertarget{classMSHR_ad5a464e147506af89ea2778d731fe46f}{
\index{MSHR@{MSHR}!print@{print}}
\index{print@{print}!MSHR@{MSHR}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}void print (std::ostream \& {\em os}, \/  int {\em verbosity} = {\ttfamily 0}, \/  const std::string \& {\em prefix} = {\ttfamily \char`\"{}\char`\"{}}) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classMSHR_ad5a464e147506af89ea2778d731fe46f}
Prints the contents of this \hyperlink{classMSHR}{MSHR} for debugging. 

\hyperlink{classPrintable_a3be2c5a60e9670becc3259fc689833c5}{Printable}を実装しています。


\begin{DoxyCode}
455 {
456     ccprintf(os, "%s[%x:%x](%s) %s %s %s state: %s %s %s %s %s\n",
457              prefix, addr, addr+size-1,
458              isSecure ? "s" : "ns",
459              isForward ? "Forward" : "",
460              isForwardNoResponse() ? "ForwNoResp" : "",
461              needsExclusive() ? "Excl" : "",
462              _isUncacheable ? "Unc" : "",
463              inService ? "InSvc" : "",
464              downstreamPending ? "DwnPend" : "",
465              hasPostInvalidate() ? "PostInv" : "",
466              hasPostDowngrade() ? "PostDowngr" : "");
467 
468     ccprintf(os, "%s  Targets:\n", prefix);
469     targets.print(os, verbosity, prefix + "    ");
470     if (!deferredTargets.empty()) {
471         ccprintf(os, "%s  Deferred Targets:\n", prefix);
472         deferredTargets.print(os, verbosity, prefix + "      ");
473     }
474 }
\end{DoxyCode}
\hypertarget{classMSHR_a6b0d016d76a2a7570d1d51eaa3086845}{
\index{MSHR@{MSHR}!promoteDeferredTargets@{promoteDeferredTargets}}
\index{promoteDeferredTargets@{promoteDeferredTargets}!MSHR@{MSHR}}
\subsubsection[{promoteDeferredTargets}]{\setlength{\rightskip}{0pt plus 5cm}bool promoteDeferredTargets ()}}
\label{classMSHR_a6b0d016d76a2a7570d1d51eaa3086845}



\begin{DoxyCode}
391 {
392     assert(targets.empty());
393     if (deferredTargets.empty()) {
394         return false;
395     }
396 
397     // swap targets & deferredTargets lists
398     std::swap(targets, deferredTargets);
399 
400     // clear deferredTargets flags
401     deferredTargets.resetFlags();
402 
403     order = targets.front().order;
404     readyTime = std::max(curTick(), targets.front().readyTime);
405 
406     return true;
407 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classMSHR_a3d057950abc60f70219bad94198fd407}{
\index{MSHR@{MSHR}!MSHRQueue@{MSHRQueue}}
\index{MSHRQueue@{MSHRQueue}!MSHR@{MSHR}}
\subsubsection[{MSHRQueue}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf MSHRQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classMSHR_a3d057950abc60f70219bad94198fd407}
Consider the \hyperlink{classMSHRQueue}{MSHRQueue} a friend to avoid making everything public 

\subsection{変数}
\hypertarget{classMSHR_a1f29f1c59828a6c0fecd2d33c992c8a4}{
\index{MSHR@{MSHR}!\_\-isUncacheable@{\_\-isUncacheable}}
\index{\_\-isUncacheable@{\_\-isUncacheable}!MSHR@{MSHR}}
\subsubsection[{\_\-isUncacheable}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \_\-isUncacheable}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHR_a1f29f1c59828a6c0fecd2d33c992c8a4}
True if the request is uncacheable \hypertarget{classMSHR_a0bb77b4ba61e408313e1118250f9278c}{
\index{MSHR@{MSHR}!addr@{addr}}
\index{addr@{addr}!MSHR@{MSHR}}
\subsubsection[{addr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf addr}}}
\label{classMSHR_a0bb77b4ba61e408313e1118250f9278c}
\hyperlink{classAddress}{Address} of the request. \hypertarget{classMSHR_afd1f01c04c4b2b391083188321ccd47e}{
\index{MSHR@{MSHR}!allocIter@{allocIter}}
\index{allocIter@{allocIter}!MSHR@{MSHR}}
\subsubsection[{allocIter}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Iterator} {\bf allocIter}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHR_afd1f01c04c4b2b391083188321ccd47e}
Pointer to this \hyperlink{classMSHR}{MSHR} on the allocated list. \begin{DoxySeeAlso}{参照}
MissQueue, \hyperlink{classMSHRQueue_a4bac1d00b2059c983d4afaf4df82f4ac}{MSHRQueue::allocatedList} 
\end{DoxySeeAlso}
\hypertarget{classMSHR_abe222f6d3581e7920dcad5306cc906a8}{
\index{MSHR@{MSHR}!data@{data}}
\index{data@{data}!MSHR@{MSHR}}
\subsubsection[{data}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t$\ast$ {\bf data}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHR_abe222f6d3581e7920dcad5306cc906a8}
Data buffer (if needed). Currently used only for pending upgrade handling. \hypertarget{classMSHR_ab53d68e3f8e523ab7907b830d22bd35d}{
\index{MSHR@{MSHR}!deferredTargets@{deferredTargets}}
\index{deferredTargets@{deferredTargets}!MSHR@{MSHR}}
\subsubsection[{deferredTargets}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TargetList} {\bf deferredTargets}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHR_ab53d68e3f8e523ab7907b830d22bd35d}
\hypertarget{classMSHR_a5ea3d1c4eadd163d5f9bd35927044ed5}{
\index{MSHR@{MSHR}!downstreamPending@{downstreamPending}}
\index{downstreamPending@{downstreamPending}!MSHR@{MSHR}}
\subsubsection[{downstreamPending}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf downstreamPending}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHR_a5ea3d1c4eadd163d5f9bd35927044ed5}
Flag set by downstream caches \hypertarget{classMSHR_a7f5c4fb6e9162689992ccd0cd7bce17b}{
\index{MSHR@{MSHR}!inService@{inService}}
\index{inService@{inService}!MSHR@{MSHR}}
\subsubsection[{inService}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf inService}}}
\label{classMSHR_a7f5c4fb6e9162689992ccd0cd7bce17b}
True if the request has been sent to the bus. \hypertarget{classMSHR_a9b36b981f171b10bc35fbd5f79c3bae1}{
\index{MSHR@{MSHR}!isForward@{isForward}}
\index{isForward@{isForward}!MSHR@{MSHR}}
\subsubsection[{isForward}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf isForward}}}
\label{classMSHR_a9b36b981f171b10bc35fbd5f79c3bae1}
True if the request is just a simple forward from an upper level \hypertarget{classMSHR_a62bc84f4251f16cf0cfa0f8d96e00c37}{
\index{MSHR@{MSHR}!isSecure@{isSecure}}
\index{isSecure@{isSecure}!MSHR@{MSHR}}
\subsubsection[{isSecure}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf isSecure}}}
\label{classMSHR_a62bc84f4251f16cf0cfa0f8d96e00c37}
True if the request targets the secure memory space. \hypertarget{classMSHR_a268baba59d9078c070be7059fd90d9bc}{
\index{MSHR@{MSHR}!order@{order}}
\index{order@{order}!MSHR@{MSHR}}
\subsubsection[{order}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Counter} {\bf order}}}
\label{classMSHR_a268baba59d9078c070be7059fd90d9bc}
Order number assigned by the miss queue. \hypertarget{classMSHR_a2c6e696fb220ec9db6d72d614998c800}{
\index{MSHR@{MSHR}!pendingDirty@{pendingDirty}}
\index{pendingDirty@{pendingDirty}!MSHR@{MSHR}}
\subsubsection[{pendingDirty}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf pendingDirty}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHR_a2c6e696fb220ec9db6d72d614998c800}
Will we have a dirty copy after this request? \hypertarget{classMSHR_a361fccb7e46b8119bda165f80f2753ac}{
\index{MSHR@{MSHR}!postDowngrade@{postDowngrade}}
\index{postDowngrade@{postDowngrade}!MSHR@{MSHR}}
\subsubsection[{postDowngrade}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf postDowngrade}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHR_a361fccb7e46b8119bda165f80f2753ac}
Did we snoop a read while waiting for data? \hypertarget{classMSHR_af4c42f3027a6f426f32521a251fd724d}{
\index{MSHR@{MSHR}!postInvalidate@{postInvalidate}}
\index{postInvalidate@{postInvalidate}!MSHR@{MSHR}}
\subsubsection[{postInvalidate}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf postInvalidate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHR_af4c42f3027a6f426f32521a251fd724d}
Did we snoop an invalidate while waiting for data? \hypertarget{classMSHR_a524ec1b0c7b11e23904171e42211679e}{
\index{MSHR@{MSHR}!queue@{queue}}
\index{queue@{queue}!MSHR@{MSHR}}
\subsubsection[{queue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MSHRQueue}$\ast$ {\bf queue}}}
\label{classMSHR_a524ec1b0c7b11e23904171e42211679e}
Pointer to queue containing this \hyperlink{classMSHR}{MSHR}. \hypertarget{classMSHR_a6ff6af8d20926ded4e18e8f676784ff6}{
\index{MSHR@{MSHR}!readyIter@{readyIter}}
\index{readyIter@{readyIter}!MSHR@{MSHR}}
\subsubsection[{readyIter}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Iterator} {\bf readyIter}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHR_a6ff6af8d20926ded4e18e8f676784ff6}
Pointer to this \hyperlink{classMSHR}{MSHR} on the ready list. \begin{DoxySeeAlso}{参照}
MissQueue, \hyperlink{classMSHRQueue_ab090e7fb494c0f9af81d19d1959684a0}{MSHRQueue::readyList} 
\end{DoxySeeAlso}
\hypertarget{classMSHR_a7cb362ebfb8750bd53baf5e8f96e00d0}{
\index{MSHR@{MSHR}!readyTime@{readyTime}}
\index{readyTime@{readyTime}!MSHR@{MSHR}}
\subsubsection[{readyTime}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf readyTime}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHR_a7cb362ebfb8750bd53baf5e8f96e00d0}
Cycle when ready to issue \hypertarget{classMSHR_a439227feff9d7f55384e8780cfc2eb82}{
\index{MSHR@{MSHR}!size@{size}}
\index{size@{size}!MSHR@{MSHR}}
\subsubsection[{size}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf size}}}
\label{classMSHR_a439227feff9d7f55384e8780cfc2eb82}
Size of the request. \hypertarget{classMSHR_ac0771ddfd90fe1ffe0d2da35dad7dd36}{
\index{MSHR@{MSHR}!targets@{targets}}
\index{targets@{targets}!MSHR@{MSHR}}
\subsubsection[{targets}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TargetList} {\bf targets}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMSHR_ac0771ddfd90fe1ffe0d2da35dad7dd36}
List of all requests that match the address \hypertarget{classMSHR_a7ec985ceacc8f2c379dbccca0b2e0f44}{
\index{MSHR@{MSHR}!threadNum@{threadNum}}
\index{threadNum@{threadNum}!MSHR@{MSHR}}
\subsubsection[{threadNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} {\bf threadNum}}}
\label{classMSHR_a7ec985ceacc8f2c379dbccca0b2e0f44}
Thread number of the miss. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/cache/\hyperlink{mshr_8hh}{mshr.hh}\item 
mem/cache/\hyperlink{mshr_8cc}{mshr.cc}\end{DoxyCompactItemize}
