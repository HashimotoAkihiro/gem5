\hypertarget{classChecker}{
\section{クラス テンプレート Checker$<$ Impl $>$}
\label{classChecker}\index{Checker@{Checker}}
}


{\ttfamily \#include $<$cpu.hh$>$}Checker$<$ Impl $>$に対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classChecker}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classChecker_a5e269456f6adf2d73f7c41acd1b626e9}{Checker} (\hyperlink{classCheckerCPU_a56bf98a1e02b979e88cbf64420995961}{Params} $\ast$p)
\item 
void \hyperlink{classChecker_a05f299b443f8cc73a93d61572edc0218}{switchOut} ()
\item 
void \hyperlink{classChecker_ac82d2b8d331b2e8e6854a95d2917dfa2}{takeOverFrom} (\hyperlink{classBaseCPU_1_1BaseCPU}{BaseCPU} $\ast$oldCPU)
\item 
void \hyperlink{classChecker_a9ff8fd374877c2ff6c10178aaad00852}{advancePC} (\hyperlink{classRefCountingPtr}{Fault} fault)
\item 
void \hyperlink{classChecker_af7588193b0187186501d440f02645196}{verify} (\hyperlink{classChecker_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classChecker_afacc503db5e7b6c0dd9925071a6f2732}{validateInst} (\hyperlink{classChecker_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classChecker_ae48ab62afce87955bf9c238afb16e035}{validateExecution} (\hyperlink{classChecker_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classChecker_ab6bf9488b2aaa90f5c6ca2491c852d30}{validateState} ()
\item 
void \hyperlink{classChecker_afa9c0925515db4634c3902c386239f3c}{copyResult} (\hyperlink{classChecker_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst, uint64\_\-t mismatch\_\-val, int start\_\-idx)
\item 
void \hyperlink{classChecker_a7e1306bfefe8be093795acd567266c94}{handlePendingInt} ()
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef Impl::DynInstPtr \hyperlink{classChecker_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classChecker_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$::iterator \hyperlink{classChecker_a4da46d72d68fcd5bfe65dc701c358379}{InstListIt}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classChecker_a761ba7749af782d41357ddb6bffb7bd7}{handleError} (\hyperlink{classChecker_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classChecker_a03be99814b51ddc0835a81391dd174e7}{dumpAndExit} (\hyperlink{classChecker_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classChecker_a80587b4fe043bbe1995536cb3b361588}{dumpInsts} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classChecker_af852d5346faaffd68d81b10fee071300}{updateThisCycle}
\item 
\hyperlink{classChecker_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classChecker_a2d37ecd523121ea3770b0b2c4264dce4}{unverifiedInst}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classChecker_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classChecker_ae10a391d02ce1ef67ee13cd82b7d46e5}{instList}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$class Impl$>$ class Checker$<$ Impl $>$}

Templated \hyperlink{classChecker}{Checker} class. This \hyperlink{classChecker}{Checker} class is templated on the DynInstPtr of the instruction type that will be verified. Proper template instantiations of the \hyperlink{classChecker}{Checker} must be placed at the bottom of \hyperlink{checker_2cpu_8cc}{checker/cpu.cc}. 

\subsection{型定義}
\hypertarget{classChecker_a028ce10889c5f6450239d9e9a7347976}{
\index{Checker@{Checker}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!Checker@{Checker}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInstPtr {\bf DynInstPtr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classChecker_a028ce10889c5f6450239d9e9a7347976}
\hypertarget{classChecker_a4da46d72d68fcd5bfe65dc701c358379}{
\index{Checker@{Checker}!InstListIt@{InstListIt}}
\index{InstListIt@{InstListIt}!Checker@{Checker}}
\subsubsection[{InstListIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf DynInstPtr}$>$::iterator {\bf InstListIt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classChecker_a4da46d72d68fcd5bfe65dc701c358379}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classChecker_a5e269456f6adf2d73f7c41acd1b626e9}{
\index{Checker@{Checker}!Checker@{Checker}}
\index{Checker@{Checker}!Checker@{Checker}}
\subsubsection[{Checker}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Checker} ({\bf Params} $\ast$ {\em p})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classChecker_a5e269456f6adf2d73f7c41acd1b626e9}



\begin{DoxyCode}
418         : CheckerCPU(p), updateThisCycle(false), unverifiedInst(NULL)
419     { }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classChecker_a9ff8fd374877c2ff6c10178aaad00852}{
\index{Checker@{Checker}!advancePC@{advancePC}}
\index{advancePC@{advancePC}!Checker@{Checker}}
\subsubsection[{advancePC}]{\setlength{\rightskip}{0pt plus 5cm}void advancePC ({\bf Fault} {\em fault})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classChecker_a9ff8fd374877c2ff6c10178aaad00852}



\begin{DoxyCode}
73 {
74     if (fault != NoFault) {
75         curMacroStaticInst = StaticInst::nullStaticInstPtr;
76         fault->invoke(tc, curStaticInst);
77         thread->decoder.reset();
78     } else {
79         if (curStaticInst) {
80             if (curStaticInst->isLastMicroop())
81                 curMacroStaticInst = StaticInst::nullStaticInstPtr;
82             TheISA::PCState pcState = thread->pcState();
83             TheISA::advancePC(pcState, curStaticInst);
84             thread->pcState(pcState);
85             DPRINTF(Checker, "Advancing PC to %s.\n", thread->pcState());
86         }
87     }
88 }
\end{DoxyCode}
\hypertarget{classChecker_afa9c0925515db4634c3902c386239f3c}{
\index{Checker@{Checker}!copyResult@{copyResult}}
\index{copyResult@{copyResult}!Checker@{Checker}}
\subsubsection[{copyResult}]{\setlength{\rightskip}{0pt plus 5cm}void copyResult ({\bf DynInstPtr} \& {\em inst}, \/  uint64\_\-t {\em mismatch\_\-val}, \/  int {\em start\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classChecker_afa9c0925515db4634c3902c386239f3c}



\begin{DoxyCode}
595 {
596     // We've already popped one dest off the queue,
597     // so do the fix-up then start with the next dest reg;
598     if (start_idx >= 0) {
599         RegIndex idx = inst->destRegIdx(start_idx);
600         switch (regIdxToClass(idx)) {
601           case IntRegClass:
602             thread->setIntReg(idx, mismatch_val);
603             break;
604           case FloatRegClass:
605             thread->setFloatRegBits(idx - TheISA::FP_Reg_Base, mismatch_val);
606             break;
607           case CCRegClass:
608             thread->setCCReg(idx - TheISA::CC_Reg_Base, mismatch_val);
609             break;
610           case MiscRegClass:
611             thread->setMiscReg(idx - TheISA::Misc_Reg_Base,
612                                mismatch_val);
613             break;
614         }
615     }
616     start_idx++;
617     uint64_t res = 0;
618     for (int i = start_idx; i < inst->numDestRegs(); i++) {
619         RegIndex idx = inst->destRegIdx(i);
620         inst->template popResult<uint64_t>(res);
621         switch (regIdxToClass(idx)) {
622           case IntRegClass:
623             thread->setIntReg(idx, res);
624             break;
625           case FloatRegClass:
626             thread->setFloatRegBits(idx - TheISA::FP_Reg_Base, res);
627             break;
628           case CCRegClass:
629             thread->setCCReg(idx - TheISA::CC_Reg_Base, res);
630             break;
631           case MiscRegClass:
632             // Try to get the proper misc register index for ARM here...
633             thread->setMiscReg(idx - TheISA::Misc_Reg_Base, res);
634             break;
635             // else Register is out of range...
636         }
637     }
638 }
\end{DoxyCode}
\hypertarget{classChecker_a03be99814b51ddc0835a81391dd174e7}{
\index{Checker@{Checker}!dumpAndExit@{dumpAndExit}}
\index{dumpAndExit@{dumpAndExit}!Checker@{Checker}}
\subsubsection[{dumpAndExit}]{\setlength{\rightskip}{0pt plus 5cm}void dumpAndExit ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classChecker_a03be99814b51ddc0835a81391dd174e7}



\begin{DoxyCode}
643 {
644     cprintf("Error detected, instruction information:\n");
645     cprintf("PC:%s, nextPC:%#x\n[sn:%lli]\n[tid:%i]\n"
646             "Completed:%i\n",
647             inst->pcState(),
648             inst->nextInstAddr(),
649             inst->seqNum,
650             inst->threadNumber,
651             inst->isCompleted());
652     inst->dump();
653     CheckerCPU::dumpAndExit();
654 }
\end{DoxyCode}
\hypertarget{classChecker_a80587b4fe043bbe1995536cb3b361588}{
\index{Checker@{Checker}!dumpInsts@{dumpInsts}}
\index{dumpInsts@{dumpInsts}!Checker@{Checker}}
\subsubsection[{dumpInsts}]{\setlength{\rightskip}{0pt plus 5cm}void dumpInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classChecker_a80587b4fe043bbe1995536cb3b361588}



\begin{DoxyCode}
659 {
660     int num = 0;
661 
662     InstListIt inst_list_it = --(instList.end());
663 
664     cprintf("Inst list size: %i\n", instList.size());
665 
666     while (inst_list_it != instList.end())
667     {
668         cprintf("Instruction:%i\n",
669                 num);
670 
671         cprintf("PC:%s\n[sn:%lli]\n[tid:%i]\n"
672                 "Completed:%i\n",
673                 (*inst_list_it)->pcState(),
674                 (*inst_list_it)->seqNum,
675                 (*inst_list_it)->threadNumber,
676                 (*inst_list_it)->isCompleted());
677 
678         cprintf("\n");
679 
680         inst_list_it--;
681         ++num;
682     }
683 
684 }
\end{DoxyCode}
\hypertarget{classChecker_a761ba7749af782d41357ddb6bffb7bd7}{
\index{Checker@{Checker}!handleError@{handleError}}
\index{handleError@{handleError}!Checker@{Checker}}
\subsubsection[{handleError}]{\setlength{\rightskip}{0pt plus 5cm}void handleError ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classChecker_a761ba7749af782d41357ddb6bffb7bd7}



\begin{DoxyCode}
437     {
438         if (exitOnError) {
439             dumpAndExit(inst);
440         } else if (updateOnError) {
441             updateThisCycle = true;
442         }
443     }
\end{DoxyCode}
\hypertarget{classChecker_a7e1306bfefe8be093795acd567266c94}{
\index{Checker@{Checker}!handlePendingInt@{handlePendingInt}}
\index{handlePendingInt@{handlePendingInt}!Checker@{Checker}}
\subsubsection[{handlePendingInt}]{\setlength{\rightskip}{0pt plus 5cm}void handlePendingInt ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classChecker_a7e1306bfefe8be093795acd567266c94}



\begin{DoxyCode}
94 {
95     DPRINTF(Checker, "IRQ detected at PC: %s with %d insts in buffer\n",
96                      thread->pcState(), instList.size());
97     DynInstPtr boundaryInst = NULL;
98     if (!instList.empty()) {
99         // Set the instructions as completed and verify as much as possible.
100         DynInstPtr inst;
101         typename std::list<DynInstPtr>::iterator itr;
102 
103         for (itr = instList.begin(); itr != instList.end(); itr++) {
104             (*itr)->setCompleted();
105         }
106 
107         inst = instList.front();
108         boundaryInst = instList.back();
109         verify(inst); // verify the instructions
110         inst = NULL;
111     }
112     if ((!boundaryInst && curMacroStaticInst &&
113           curStaticInst->isDelayedCommit() &&
114           !curStaticInst->isLastMicroop()) ||
115         (boundaryInst && boundaryInst->isDelayedCommit() &&
116          !boundaryInst->isLastMicroop())) {
117         panic("%lli: Trying to take an interrupt in middle of "
118               "a non-interuptable instruction!", curTick());
119     }
120     boundaryInst = NULL;
121     thread->decoder.reset();
122     curMacroStaticInst = StaticInst::nullStaticInstPtr;
123 }
\end{DoxyCode}
\hypertarget{classChecker_a05f299b443f8cc73a93d61572edc0218}{
\index{Checker@{Checker}!switchOut@{switchOut}}
\index{switchOut@{switchOut}!Checker@{Checker}}
\subsubsection[{switchOut}]{\setlength{\rightskip}{0pt plus 5cm}void switchOut ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classChecker_a05f299b443f8cc73a93d61572edc0218}



\begin{DoxyCode}
450 {
451     instList.clear();
452 }
\end{DoxyCode}
\hypertarget{classChecker_ac82d2b8d331b2e8e6854a95d2917dfa2}{
\index{Checker@{Checker}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!Checker@{Checker}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ({\bf BaseCPU} $\ast$ {\em oldCPU})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classChecker_ac82d2b8d331b2e8e6854a95d2917dfa2}



\begin{DoxyCode}
457 {
458 }
\end{DoxyCode}
\hypertarget{classChecker_ae48ab62afce87955bf9c238afb16e035}{
\index{Checker@{Checker}!validateExecution@{validateExecution}}
\index{validateExecution@{validateExecution}!Checker@{Checker}}
\subsubsection[{validateExecution}]{\setlength{\rightskip}{0pt plus 5cm}void validateExecution ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classChecker_ae48ab62afce87955bf9c238afb16e035}



\begin{DoxyCode}
484 {
485     uint64_t checker_val;
486     uint64_t inst_val;
487     int idx = -1;
488     bool result_mismatch = false;
489 
490     if (inst->isUnverifiable()) {
491         // Unverifiable instructions assume they were executed
492         // properly by the CPU. Grab the result from the
493         // instruction and write it to the register.
494         copyResult(inst, 0, idx);
495     } else if (inst->numDestRegs() > 0 && !result.empty()) {
496         DPRINTF(Checker, "Dest regs %d, number of checker dest regs %d\n",
497                          inst->numDestRegs(), result.size());
498         for (int i = 0; i < inst->numDestRegs() && !result.empty(); i++) {
499             result.front().get(checker_val);
500             result.pop();
501             inst_val = 0;
502             inst->template popResult<uint64_t>(inst_val);
503             if (checker_val != inst_val) {
504                 result_mismatch = true;
505                 idx = i;
506                 break;
507             }
508         }
509     } // Checker CPU checks all the saved results in the dyninst passed by
510       // the cpu model being checked against the saved results present in
511       // the static inst executed in the Checker.  Sometimes the number
512       // of saved results differs between the dyninst and static inst, but
513       // this is ok and not a bug.  May be worthwhile to try and correct this.
514 
515     if (result_mismatch) {
516         warn("%lli: Instruction results do not match! (Values may not "
517              "actually be integers) Inst: %#x, checker: %#x",
518              curTick(), inst_val, checker_val);
519 
520         // It's useful to verify load values from memory, but in MP
521         // systems the value obtained at execute may be different than
522         // the value obtained at completion.  Similarly DMA can
523         // present the same problem on even UP systems.  Thus there is
524         // the option to only warn on loads having a result error.
525         // The load/store queue in Detailed CPU can also cause problems
526         // if load/store forwarding is allowed.
527         if (inst->isLoad() && warnOnlyOnLoadError) {
528             copyResult(inst, inst_val, idx);
529         } else {
530             handleError(inst);
531         }
532     }
533 
534     if (inst->nextInstAddr() != thread->nextInstAddr()) {
535         warn("%lli: Instruction next PCs do not match! Inst: %#x, "
536              "checker: %#x",
537              curTick(), inst->nextInstAddr(), thread->nextInstAddr());
538         handleError(inst);
539     }
540 
541     // Checking side effect registers can be difficult if they are not
542     // checked simultaneously with the execution of the instruction.
543     // This is because other valid instructions may have modified
544     // these registers in the meantime, and their values are not
545     // stored within the DynInst.
546     while (!miscRegIdxs.empty()) {
547         int misc_reg_idx = miscRegIdxs.front();
548         miscRegIdxs.pop();
549 
550         if (inst->tcBase()->readMiscRegNoEffect(misc_reg_idx) !=
551             thread->readMiscRegNoEffect(misc_reg_idx)) {
552             warn("%lli: Misc reg idx %i (side effect) does not match! "
553                  "Inst: %#x, checker: %#x",
554                  curTick(), misc_reg_idx,
555                  inst->tcBase()->readMiscRegNoEffect(misc_reg_idx),
556                  thread->readMiscRegNoEffect(misc_reg_idx));
557             handleError(inst);
558         }
559     }
560 }
\end{DoxyCode}
\hypertarget{classChecker_afacc503db5e7b6c0dd9925071a6f2732}{
\index{Checker@{Checker}!validateInst@{validateInst}}
\index{validateInst@{validateInst}!Checker@{Checker}}
\subsubsection[{validateInst}]{\setlength{\rightskip}{0pt plus 5cm}void validateInst ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classChecker_afacc503db5e7b6c0dd9925071a6f2732}



\begin{DoxyCode}
463 {
464     if (inst->instAddr() != thread->instAddr()) {
465         warn("%lli: PCs do not match! Inst: %s, checker: %s",
466              curTick(), inst->pcState(), thread->pcState());
467         if (changedPC) {
468             warn("%lli: Changed PCs recently, may not be an error",
469                  curTick());
470         } else {
471             handleError(inst);
472         }
473     }
474 
475     if (curStaticInst != inst->staticInst) {
476         warn("%lli: StaticInstPtrs don't match. (%s, %s).\n", curTick(),
477                 curStaticInst->getName(), inst->staticInst->getName());
478     }
479 }
\end{DoxyCode}
\hypertarget{classChecker_ab6bf9488b2aaa90f5c6ca2491c852d30}{
\index{Checker@{Checker}!validateState@{validateState}}
\index{validateState@{validateState}!Checker@{Checker}}
\subsubsection[{validateState}]{\setlength{\rightskip}{0pt plus 5cm}void validateState ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classChecker_ab6bf9488b2aaa90f5c6ca2491c852d30}



\begin{DoxyCode}
569 {
570     if (updateThisCycle) {
571         // Change this back to warn if divergences end up being false positives
572         panic("%lli: Instruction PC %#x results didn't match up, copying all "
573              "registers from main CPU", curTick(), unverifiedInst->instAddr());
574 
575         // Terribly convoluted way to make sure O3 model does not implode
576         bool no_squash_from_TC = unverifiedInst->thread->noSquashFromTC;
577         unverifiedInst->thread->noSquashFromTC = true;
578 
579         // Heavy-weight copying of all registers
580         thread->copyArchRegs(unverifiedInst->tcBase());
581         unverifiedInst->thread->noSquashFromTC = no_squash_from_TC;
582 
583         // Set curStaticInst to unverifiedInst->staticInst
584         curStaticInst = unverifiedInst->staticInst;
585         // Also advance the PC.  Hopefully no PC-based events happened.
586         advancePC(NoFault);
587         updateThisCycle = false;
588     }
589 }
\end{DoxyCode}
\hypertarget{classChecker_af7588193b0187186501d440f02645196}{
\index{Checker@{Checker}!verify@{verify}}
\index{verify@{verify}!Checker@{Checker}}
\subsubsection[{verify}]{\setlength{\rightskip}{0pt plus 5cm}void verify ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classChecker_af7588193b0187186501d440f02645196}



\begin{DoxyCode}
128 {
129     DynInstPtr inst;
130 
131     // Make sure serializing instructions are actually
132     // seen as serializing to commit. instList should be
133     // empty in these cases.
134     if ((completed_inst->isSerializing() ||
135         completed_inst->isSerializeBefore()) &&
136         (!instList.empty() ?
137          (instList.front()->seqNum != completed_inst->seqNum) : 0)) {
138         panic("%lli: Instruction sn:%lli at PC %s is serializing before but is"
139               " entering instList with other instructions\n", curTick(),
140               completed_inst->seqNum, completed_inst->pcState());
141     }
142 
143     // Either check this instruction, or add it to a list of
144     // instructions waiting to be checked.  Instructions must be
145     // checked in program order, so if a store has committed yet not
146     // completed, there may be some instructions that are waiting
147     // behind it that have completed and must be checked.
148     if (!instList.empty()) {
149         if (youngestSN < completed_inst->seqNum) {
150             DPRINTF(Checker, "Adding instruction [sn:%lli] PC:%s to list\n",
151                     completed_inst->seqNum, completed_inst->pcState());
152             instList.push_back(completed_inst);
153             youngestSN = completed_inst->seqNum;
154         }
155 
156         if (!instList.front()->isCompleted()) {
157             return;
158         } else {
159             inst = instList.front();
160             instList.pop_front();
161         }
162     } else {
163         if (!completed_inst->isCompleted()) {
164             if (youngestSN < completed_inst->seqNum) {
165                 DPRINTF(Checker, "Adding instruction [sn:%lli] PC:%s to list\n",
166                         completed_inst->seqNum, completed_inst->pcState());
167                 instList.push_back(completed_inst);
168                 youngestSN = completed_inst->seqNum;
169             }
170             return;
171         } else {
172             if (youngestSN < completed_inst->seqNum) {
173                 inst = completed_inst;
174                 youngestSN = completed_inst->seqNum;
175             } else {
176                 return;
177             }
178         }
179     }
180 
181     // Make sure a serializing instruction is actually seen as
182     // serializing. instList should be empty here
183     if (inst->isSerializeAfter() && !instList.empty()) {
184         panic("%lli: Instruction sn:%lli at PC %s is serializing after but is"
185              " exiting instList with other instructions\n", curTick(),
186              completed_inst->seqNum, completed_inst->pcState());
187     }
188     unverifiedInst = inst;
189     inst = NULL;
190 
191     // Try to check all instructions that are completed, ending if we
192     // run out of instructions to check or if an instruction is not
193     // yet completed.
194     while (1) {
195         DPRINTF(Checker, "Processing instruction [sn:%lli] PC:%s.\n",
196                 unverifiedInst->seqNum, unverifiedInst->pcState());
197         unverifiedReq = NULL;
198         unverifiedReq = unverifiedInst->reqToVerify;
199         unverifiedMemData = unverifiedInst->memData;
200         // Make sure results queue is empty
201         while (!result.empty()) {
202             result.pop();
203         }
204         numCycles++;
205 
206         Fault fault = NoFault;
207 
208         // maintain $r0 semantics
209         thread->setIntReg(ZeroReg, 0);
210 #if THE_ISA == ALPHA_ISA
211         thread->setFloatReg(ZeroReg, 0.0);
212 #endif
213 
214         // Check if any recent PC changes match up with anything we
215         // expect to happen.  This is mostly to check if traps or
216         // PC-based events have occurred in both the checker and CPU.
217         if (changedPC) {
218             DPRINTF(Checker, "Changed PC recently to %s\n",
219                     thread->pcState());
220             if (willChangePC) {
221                 if (newPCState == thread->pcState()) {
222                     DPRINTF(Checker, "Changed PC matches expected PC\n");
223                 } else {
224                     warn("%lli: Changed PC does not match expected PC, "
225                          "changed: %s, expected: %s",
226                          curTick(), thread->pcState(), newPCState);
227                     CheckerCPU::handleError();
228                 }
229                 willChangePC = false;
230             }
231             changedPC = false;
232         }
233 
234         // Try to fetch the instruction
235         uint64_t fetchOffset = 0;
236         bool fetchDone = false;
237 
238         while (!fetchDone) {
239             Addr fetch_PC = thread->instAddr();
240             fetch_PC = (fetch_PC & PCMask) + fetchOffset;
241 
242             MachInst machInst;
243 
244             // If not in the middle of a macro instruction
245             if (!curMacroStaticInst) {
246                 // set up memory request for instruction fetch
247                 memReq = new Request(unverifiedInst->threadNumber, fetch_PC,
248                                      sizeof(MachInst),
249                                      0,
250                                      masterId,
251                                      fetch_PC, thread->contextId(),
252                                      unverifiedInst->threadNumber);
253                 memReq->setVirt(0, fetch_PC, sizeof(MachInst),
254                                 Request::INST_FETCH, masterId, thread->instAddr()
      );
255 
256 
257                 fault = itb->translateFunctional(memReq, tc, BaseTLB::Execute);
258 
259                 if (fault != NoFault) {
260                     if (unverifiedInst->getFault() == NoFault) {
261                         // In this case the instruction was not a dummy
262                         // instruction carrying an ITB fault.  In the single
263                         // threaded case the ITB should still be able to
264                         // translate this instruction; in the SMT case it's
265                         // possible that its ITB entry was kicked out.
266                         warn("%lli: Instruction PC %s was not found in the "
267                              "ITB!", curTick(), thread->pcState());
268                         handleError(unverifiedInst);
269 
270                         // go to the next instruction
271                         advancePC(NoFault);
272 
273                         // Give up on an ITB fault..
274                         delete memReq;
275                         unverifiedInst = NULL;
276                         return;
277                     } else {
278                         // The instruction is carrying an ITB fault.  Handle
279                         // the fault and see if our results match the CPU on
280                         // the next tick().
281                         fault = unverifiedInst->getFault();
282                         delete memReq;
283                         break;
284                     }
285                 } else {
286                     PacketPtr pkt = new Packet(memReq, MemCmd::ReadReq);
287 
288                     pkt->dataStatic(&machInst);
289                     icachePort->sendFunctional(pkt);
290                     machInst = gtoh(machInst);
291 
292                     delete memReq;
293                     delete pkt;
294                 }
295             }
296 
297             if (fault == NoFault) {
298                 TheISA::PCState pcState = thread->pcState();
299 
300                 if (isRomMicroPC(pcState.microPC())) {
301                     fetchDone = true;
302                     curStaticInst =
303                         microcodeRom.fetchMicroop(pcState.microPC(), NULL);
304                 } else if (!curMacroStaticInst) {
305                     //We're not in the middle of a macro instruction
306                     StaticInstPtr instPtr = NULL;
307 
308                     //Predecode, ie bundle up an ExtMachInst
309                     //If more fetch data is needed, pass it in.
310                     Addr fetchPC = (pcState.instAddr() & PCMask) + fetchOffset;
311                     thread->decoder.moreBytes(pcState, fetchPC, machInst);
312 
313                     //If an instruction is ready, decode it.
314                     //Otherwise, we'll have to fetch beyond the
315                     //MachInst at the current pc.
316                     if (thread->decoder.instReady()) {
317                         fetchDone = true;
318                         instPtr = thread->decoder.decode(pcState);
319                         thread->pcState(pcState);
320                     } else {
321                         fetchDone = false;
322                         fetchOffset += sizeof(TheISA::MachInst);
323                     }
324 
325                     //If we decoded an instruction and it's microcoded,
326                     //start pulling out micro ops
327                     if (instPtr && instPtr->isMacroop()) {
328                         curMacroStaticInst = instPtr;
329                         curStaticInst =
330                             instPtr->fetchMicroop(pcState.microPC());
331                     } else {
332                         curStaticInst = instPtr;
333                     }
334                 } else {
335                     // Read the next micro op from the macro-op
336                     curStaticInst =
337                         curMacroStaticInst->fetchMicroop(pcState.microPC());
338                     fetchDone = true;
339                 }
340             }
341         }
342         // reset decoder on Checker
343         thread->decoder.reset();
344 
345         // Check Checker and CPU get same instruction, and record
346         // any faults the CPU may have had.
347         Fault unverifiedFault;
348         if (fault == NoFault) {
349             unverifiedFault = unverifiedInst->getFault();
350 
351             // Checks that the instruction matches what we expected it to be.
352             // Checks both the machine instruction and the PC.
353             validateInst(unverifiedInst);
354         }
355 
356         // keep an instruction count
357         numInst++;
358 
359 
360         // Either the instruction was a fault and we should process the fault,
361         // or we should just go ahead execute the instruction.  This assumes
362         // that the instruction is properly marked as a fault.
363         if (fault == NoFault) {
364             // Execute Checker instruction and trace
365             if (!unverifiedInst->isUnverifiable()) {
366                 Trace::InstRecord *traceData = tracer->getInstRecord(curTick(),
367                                                            tc,
368                                                            curStaticInst,
369                                                            pcState(),
370                                                            curMacroStaticInst);
371                 fault = curStaticInst->execute(this, traceData);
372                 if (traceData) {
373                     traceData->dump();
374                     delete traceData;
375                 }
376             }
377 
378             if (fault == NoFault && unverifiedFault == NoFault) {
379                 thread->funcExeInst++;
380                 // Checks to make sure instrution results are correct.
381                 validateExecution(unverifiedInst);
382 
383                 if (curStaticInst->isLoad()) {
384                     ++numLoad;
385                 }
386             } else if (fault != NoFault && unverifiedFault == NoFault) {
387                 panic("%lli: sn: %lli at PC: %s took a fault in checker "
388                       "but not in driver CPU\n", curTick(),
389                       unverifiedInst->seqNum, unverifiedInst->pcState());
390             } else if (fault == NoFault && unverifiedFault != NoFault) {
391                 panic("%lli: sn: %lli at PC: %s took a fault in driver "
392                       "CPU but not in checker\n", curTick(),
393                       unverifiedInst->seqNum, unverifiedInst->pcState());
394             }
395         }
396 
397         // Take any faults here
398         if (fault != NoFault) {
399             if (FullSystem) {
400                 fault->invoke(tc, curStaticInst);
401                 willChangePC = true;
402                 newPCState = thread->pcState();
403                 DPRINTF(Checker, "Fault, PC is now %s\n", newPCState);
404                 curMacroStaticInst = StaticInst::nullStaticInstPtr;
405             }
406         } else {
407            advancePC(fault);
408         }
409 
410         if (FullSystem) {
411             // @todo: Determine if these should happen only if the
412             // instruction hasn't faulted.  In the SimpleCPU case this may
413             // not be true, but in the O3 or Ozone case this may be true.
414             Addr oldpc;
415             int count = 0;
416             do {
417                 oldpc = thread->instAddr();
418                 system->pcEventQueue.service(tc);
419                 count++;
420             } while (oldpc != thread->instAddr());
421             if (count > 1) {
422                 willChangePC = true;
423                 newPCState = thread->pcState();
424                 DPRINTF(Checker, "PC Event, PC is now %s\n", newPCState);
425             }
426         }
427 
428         // @todo:  Optionally can check all registers. (Or just those
429         // that have been modified).
430         validateState();
431 
432         // Continue verifying instructions if there's another completed
433         // instruction waiting to be verified.
434         if (instList.empty()) {
435             break;
436         } else if (instList.front()->isCompleted()) {
437             unverifiedInst = NULL;
438             unverifiedInst = instList.front();
439             instList.pop_front();
440         } else {
441             break;
442         }
443     }
444     unverifiedInst = NULL;
445 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classChecker_ae10a391d02ce1ef67ee13cd82b7d46e5}{
\index{Checker@{Checker}!instList@{instList}}
\index{instList@{instList}!Checker@{Checker}}
\subsubsection[{instList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf instList}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classChecker_ae10a391d02ce1ef67ee13cd82b7d46e5}
\hypertarget{classChecker_a2d37ecd523121ea3770b0b2c4264dce4}{
\index{Checker@{Checker}!unverifiedInst@{unverifiedInst}}
\index{unverifiedInst@{unverifiedInst}!Checker@{Checker}}
\subsubsection[{unverifiedInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf unverifiedInst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classChecker_a2d37ecd523121ea3770b0b2c4264dce4}
\hypertarget{classChecker_af852d5346faaffd68d81b10fee071300}{
\index{Checker@{Checker}!updateThisCycle@{updateThisCycle}}
\index{updateThisCycle@{updateThisCycle}!Checker@{Checker}}
\subsubsection[{updateThisCycle}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf updateThisCycle}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classChecker_af852d5346faaffd68d81b10fee071300}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/checker/\hyperlink{checker_2cpu_8hh}{cpu.hh}\item 
cpu/checker/\hyperlink{checker_2cpu__impl_8hh}{cpu\_\-impl.hh}\end{DoxyCompactItemize}
