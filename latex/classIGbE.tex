\hypertarget{classIGbE}{
\section{クラス IGbE}
\label{classIGbE}\index{IGbE@{IGbE}}
}


{\ttfamily \#include $<$i8254xGBe.hh$>$}IGbEに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=9cm]{classIGbE}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classIGbE_1_1DescCache}{DescCache}
\item 
class \hyperlink{classIGbE_1_1RxDescCache}{RxDescCache}
\item 
class \hyperlink{classIGbE_1_1TxDescCache}{TxDescCache}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef IGbEParams \hyperlink{classIGbE_ad27b5cfed87f35a483863a73336d8258}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
const \hyperlink{classIGbE_ad27b5cfed87f35a483863a73336d8258}{Params} $\ast$ \hyperlink{classIGbE_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{classIGbE_a3e3eef81d3caf789558505740ce0ed07}{IGbE} (const \hyperlink{classIGbE_ad27b5cfed87f35a483863a73336d8258}{Params} $\ast$params)
\item 
\hyperlink{classIGbE_a8ff05c4d178fcac0d8a3ae83db67d89b}{$\sim$IGbE} ()
\item 
virtual void \hyperlink{classIGbE_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
virtual \hyperlink{classEtherInt}{EtherInt} $\ast$ \hyperlink{classIGbE_a10260c5a583c0894dcdcd1ced50a53ae}{getEthPort} (const std::string \&if\_\-name, int idx)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIGbE_a613ec7d5e1ec64f8d21fec78ae8e568e}{read} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIGbE_a4cefab464e72b5dd42c003a0a4341802}{write} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIGbE_aac7b61a78530109bfa20923a53064bbf}{writeConfig} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classIGbE_aaae8ccdf0f0b15e4d1b93e71a0c8b303}{ethRxPkt} (\hyperlink{classRefCountingPtr}{EthPacketPtr} packet)
\item 
void \hyperlink{classIGbE_a4b170caf60b0a01672ab8e8e3e4dff10}{ethTxDone} ()
\item 
virtual void \hyperlink{classIGbE_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classIGbE_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\item 
unsigned int \hyperlink{classIGbE_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)
\item 
void \hyperlink{classIGbE_a8f020d3237536fe007fc488c4125c5d8}{drainResume} ()
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIGbE_adad52012a21d414368149556f2cc909b}{lastInterrupt}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classIGbE_a047d922eba10484b3a0127faa8e1be0a}{rdtrProcess} ()
\item 
void \hyperlink{classIGbE_a1d54e26efe0f0a1fbd354ccffa34459f}{radvProcess} ()
\item 
void \hyperlink{classIGbE_a7e3216d8f11c9d6c3fa244be21648778}{tadvProcess} ()
\item 
void \hyperlink{classIGbE_aedc70a3ef5f173813e3060f77fa53bc8}{tidvProcess} ()
\item 
void \hyperlink{classIGbE_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\item 
void \hyperlink{classIGbE_aa22f1272cbc1c6b44dd50faaa71a0d87}{rxStateMachine} ()
\item 
void \hyperlink{classIGbE_a86f1c8a72188e638c991535ba96f5f0e}{txStateMachine} ()
\item 
void \hyperlink{classIGbE_af67ff1365c83adc97fef8753e38f3d9e}{txWire} ()
\item 
void \hyperlink{classIGbE_a5421bafb8503ffca04cac20d616ae4cc}{postInterrupt} (\hyperlink{namespaceiGbReg_ab881f740bd3545d8eb42b05253752e9c}{iGbReg::IntTypes} t, bool now=false)
\item 
void \hyperlink{classIGbE_a29bfbbe58f3015bfb026c019295a8836}{chkInterrupt} ()
\item 
void \hyperlink{classIGbE_a671c460437037741ca81581773939a28}{delayIntEvent} ()
\item 
void \hyperlink{classIGbE_a6cc0f5948b3dc7c1f2e489bce23ef907}{cpuPostInt} ()
\item 
void \hyperlink{classIGbE_a5bb6e41ae1497d53a611db0a6b455115}{cpuClearInt} ()
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIGbE_ad4b9fb8ece2ddee6cda2b12e4f77b3d1}{intClock} ()
\item 
void \hyperlink{classIGbE_a9506deecc41eb6290f9b9b8662cc33c2}{restartClock} ()
\item 
void \hyperlink{classIGbE_a97cbf86aeda5390deb20b1d39396d111}{checkDrain} ()
\item 
void \hyperlink{classIGbE_ac20fadb883428d12627ffa95751acf17}{anBegin} (std::string sm, std::string st, int flags=CPA::FL\_\-NONE)
\item 
void \hyperlink{classIGbE_ad5560d7f7671ea0c96250beacf187ac8}{anQ} (std::string sm, std::string q)
\item 
void \hyperlink{classIGbE_a4d59c58fec3355c64488974a9110bb70}{anDq} (std::string sm, std::string q)
\item 
void \hyperlink{classIGbE_a9398b9f9270a0cfcc96ab2f8ad4b2c87}{anPq} (std::string sm, std::string q, int num=1)
\item 
void \hyperlink{classIGbE_a48fd12dd7cf4b842162b7a0b89875559}{anRq} (std::string sm, std::string q, int num=1)
\item 
void \hyperlink{classIGbE_ace79fee3c0fd652014ae35a7b1497ca1}{anWe} (std::string sm, std::string q)
\item 
void \hyperlink{classIGbE_a09c6a12f9551bd90d913dfe8ed396a67}{anWf} (std::string sm, std::string q)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classIGbEInt}{IGbEInt} $\ast$ \hyperlink{classIGbE_a4c7684471cc2bc72bc660ea06ca78c91}{etherInt}
\item 
\hyperlink{classCPA}{CPA} $\ast$ \hyperlink{classIGbE_ad3738d2e08f4ea21f1c3721f2492c9c2}{cpa}
\item 
\hyperlink{structiGbReg_1_1Regs}{iGbReg::Regs} \hyperlink{classIGbE_aca82e9e23b43d692ee2d79799761533f}{regs}
\item 
int \hyperlink{classIGbE_a8988636da8c2e4f74e8c62d7ad585a61}{eeOpBits}
\item 
int \hyperlink{classIGbE_a976342e4e142f8f031f86a8e7ce7a55f}{eeAddrBits}
\item 
int \hyperlink{classIGbE_ad2c36d4fa51a4befaa7518f6fa3590be}{eeDataBits}
\item 
uint8\_\-t \hyperlink{classIGbE_aa6c5c24d6b03e9f01ddacc4448214383}{eeOpcode}
\item 
uint8\_\-t \hyperlink{classIGbE_a00d8c4d0c00b1a7fc2a5885222511eee}{eeAddr}
\item 
uint16\_\-t \hyperlink{classIGbE_a7a8d29882b2cc202e8f3d9f4e758937c}{flash} \mbox{[}\hyperlink{namespaceiGbReg_adb0e1024d46141c966014951f5b1e5c8}{iGbReg::EEPROM\_\-SIZE}\mbox{]}
\item 
\hyperlink{classDrainManager}{DrainManager} $\ast$ \hyperlink{classIGbE_a329b71fb934a93312ca0aacbf5a3f982}{drainManager}
\item 
\hyperlink{classPacketFifo}{PacketFifo} \hyperlink{classIGbE_a45c9c6a3665bcd91e57ff35aa9089fa7}{rxFifo}
\item 
\hyperlink{classPacketFifo}{PacketFifo} \hyperlink{classIGbE_ae699c324753236e0a59aa2465920eb46}{txFifo}
\item 
\hyperlink{classRefCountingPtr}{EthPacketPtr} \hyperlink{classIGbE_a8d22e1a154942ff0d4ab9048e7e844bb}{txPacket}
\item 
bool \hyperlink{classIGbE_a3dd1ff20ea750ba74f718ba7e7c210fe}{rxTick}
\item 
bool \hyperlink{classIGbE_a0f33aec9eb84199e089e1917f7df501d}{txTick}
\item 
bool \hyperlink{classIGbE_a99be71cc5dbbb45b77d1d66d1bedf454}{txFifoTick}
\item 
bool \hyperlink{classIGbE_aa8031223419e9d8480a99fae1f2de778}{rxDmaPacket}
\item 
unsigned \hyperlink{classIGbE_a41fd0002dbd12f7ab760e7f0a6620953}{pktOffset}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIGbE_aa17c871ae2de13303ab07a8e8b571965}{fetchDelay}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIGbE_a899afa4a59ed0cf8334061645dc16c53}{wbDelay}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIGbE_ae404928093bd61ac24cd54406a98046e}{fetchCompDelay}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIGbE_ab0f05d6ecbedd2a670abfe34bc8112e1}{wbCompDelay}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIGbE_a94231b5b6ec824655f1e33a2481009fb}{rxWriteDelay}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classIGbE_a2e204efac3d8a0a09aef20570520baac}{txReadDelay}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classIGbE}{IGbE},\&IGbE::rdtrProcess $>$ \hyperlink{classIGbE_a72b4c60f46bdb4b88427dec167aaca80}{rdtrEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classIGbE}{IGbE},\&IGbE::radvProcess $>$ \hyperlink{classIGbE_a30a3a2a8194ad851683c915beca8a172}{radvEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classIGbE}{IGbE},\&IGbE::tadvProcess $>$ \hyperlink{classIGbE_a52af2948f0bdbd05624c9f1e90872556}{tadvEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classIGbE}{IGbE},\&IGbE::tidvProcess $>$ \hyperlink{classIGbE_a91fce863693eb4c56a924639620d77cf}{tidvEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classIGbE}{IGbE},\&IGbE::tick $>$ \hyperlink{classIGbE_a13b02e56360d63f349a514edb321bd9c}{tickEvent}
\item 
uint64\_\-t \hyperlink{classIGbE_ab70964077d0446a01beedcfb7b9f64da}{macAddr}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classIGbE}{IGbE},\&IGbE::delayIntEvent $>$ \hyperlink{classIGbE_a3de27cfe33d0ae9f9451c767ee40a57d}{interEvent}
\item 
\hyperlink{classIGbE_1_1RxDescCache}{RxDescCache} \hyperlink{classIGbE_a0e260069d3ff6994b7ab0d843388c5d5}{rxDescCache}
\item 
\hyperlink{classIGbE_1_1TxDescCache}{TxDescCache} \hyperlink{classIGbE_a8ab7bc15342abe2e4fe9d9bde951441b}{txDescCache}
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classIGbE_a5117ecf4d368d174c17a9304676a45a5}{RxDescCache}
\item 
class \hyperlink{classIGbE_ab83c1d837daa8ccbbd651c133208ced0}{TxDescCache}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classIGbE_ad27b5cfed87f35a483863a73336d8258}{
\index{IGbE@{IGbE}!Params@{Params}}
\index{Params@{Params}!IGbE@{IGbE}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef IGbEParams {\bf Params}}}
\label{classIGbE_ad27b5cfed87f35a483863a73336d8258}


\hyperlink{classEtherDevice_afcf43c7944288000e850f783bdd66b9d}{EtherDevice}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classIGbE_a3e3eef81d3caf789558505740ce0ed07}{
\index{IGbE@{IGbE}!IGbE@{IGbE}}
\index{IGbE@{IGbE}!IGbE@{IGbE}}
\subsubsection[{IGbE}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IGbE} (const {\bf Params} $\ast$ {\em params})}}
\label{classIGbE_a3e3eef81d3caf789558505740ce0ed07}



\begin{DoxyCode}
60     : EtherDevice(p), etherInt(NULL),  drainManager(NULL),
61       rxFifo(p->rx_fifo_size), txFifo(p->tx_fifo_size), rxTick(false),
62       txTick(false), txFifoTick(false), rxDmaPacket(false), pktOffset(0),
63       fetchDelay(p->fetch_delay), wbDelay(p->wb_delay), 
64       fetchCompDelay(p->fetch_comp_delay), wbCompDelay(p->wb_comp_delay), 
65       rxWriteDelay(p->rx_write_delay), txReadDelay(p->tx_read_delay),  
66       rdtrEvent(this), radvEvent(this),
67       tadvEvent(this), tidvEvent(this), tickEvent(this), interEvent(this),
68       rxDescCache(this, name()+".RxDesc", p->rx_desc_cache_size),
69       txDescCache(this, name()+".TxDesc", p->tx_desc_cache_size),
70       lastInterrupt(0)
71 {
72     etherInt = new IGbEInt(name() + ".int", this);
73 
74     // Initialized internal registers per Intel documentation
75     // All registers intialized to 0 by per register constructor
76     regs.ctrl.fd(1);
77     regs.ctrl.lrst(1);
78     regs.ctrl.speed(2);
79     regs.ctrl.frcspd(1);
80     regs.sts.speed(3); // Say we're 1000Mbps
81     regs.sts.fd(1); // full duplex
82     regs.sts.lu(1); // link up
83     regs.eecd.fwe(1);
84     regs.eecd.ee_type(1);
85     regs.imr = 0;
86     regs.iam = 0;
87     regs.rxdctl.gran(1);
88     regs.rxdctl.wthresh(1);
89     regs.fcrth(1);
90     regs.tdwba = 0;
91     regs.rlpml = 0;
92     regs.sw_fw_sync = 0;
93 
94     regs.pba.rxa(0x30);
95     regs.pba.txa(0x10);
96 
97     eeOpBits            = 0;
98     eeAddrBits          = 0;
99     eeDataBits          = 0;
100     eeOpcode            = 0;
101 
102     // clear all 64 16 bit words of the eeprom
103     memset(&flash, 0, EEPROM_SIZE*2);
104 
105     // Set the MAC address
106     memcpy(flash, p->hardware_address.bytes(), ETH_ADDR_LEN);
107     for (int x = 0; x < ETH_ADDR_LEN/2; x++)
108         flash[x] = htobe(flash[x]);
109 
110     uint16_t csum = 0;
111     for (int x = 0; x < EEPROM_SIZE; x++)
112         csum += htobe(flash[x]);
113 
114 
115     // Magic happy checksum value
116     flash[EEPROM_SIZE-1] = htobe((uint16_t)(EEPROM_CSUM - csum));
117 
118     // Store the MAC address as queue ID
119     macAddr = p->hardware_address;
120 
121     rxFifo.clear();
122     txFifo.clear();
123 }
\end{DoxyCode}
\hypertarget{classIGbE_a8ff05c4d178fcac0d8a3ae83db67d89b}{
\index{IGbE@{IGbE}!$\sim$IGbE@{$\sim$IGbE}}
\index{$\sim$IGbE@{$\sim$IGbE}!IGbE@{IGbE}}
\subsubsection[{$\sim$IGbE}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf IGbE} ()}}
\label{classIGbE_a8ff05c4d178fcac0d8a3ae83db67d89b}



\begin{DoxyCode}
126 {
127     delete etherInt;
128 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classIGbE_ac20fadb883428d12627ffa95751acf17}{
\index{IGbE@{IGbE}!anBegin@{anBegin}}
\index{anBegin@{anBegin}!IGbE@{IGbE}}
\subsubsection[{anBegin}]{\setlength{\rightskip}{0pt plus 5cm}void anBegin (std::string {\em sm}, \/  std::string {\em st}, \/  int {\em flags} = {\ttfamily CPA::FL\_\-NONE})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classIGbE_ac20fadb883428d12627ffa95751acf17}



\begin{DoxyCode}
184                                                                      {
185         cpa->hwBegin((CPA::flags)flags, sys, macAddr, sm, st);
186     }
\end{DoxyCode}
\hypertarget{classIGbE_a4d59c58fec3355c64488974a9110bb70}{
\index{IGbE@{IGbE}!anDq@{anDq}}
\index{anDq@{anDq}!IGbE@{IGbE}}
\subsubsection[{anDq}]{\setlength{\rightskip}{0pt plus 5cm}void anDq (std::string {\em sm}, \/  std::string {\em q})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classIGbE_a4d59c58fec3355c64488974a9110bb70}



\begin{DoxyCode}
192                                          {
193         cpa->hwDq(CPA::FL_NONE, sys, macAddr, sm, q, macAddr);
194     }
\end{DoxyCode}
\hypertarget{classIGbE_a9398b9f9270a0cfcc96ab2f8ad4b2c87}{
\index{IGbE@{IGbE}!anPq@{anPq}}
\index{anPq@{anPq}!IGbE@{IGbE}}
\subsubsection[{anPq}]{\setlength{\rightskip}{0pt plus 5cm}void anPq (std::string {\em sm}, \/  std::string {\em q}, \/  int {\em num} = {\ttfamily 1})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classIGbE_a9398b9f9270a0cfcc96ab2f8ad4b2c87}



\begin{DoxyCode}
196                                                       {
197         cpa->hwPq(CPA::FL_NONE, sys, macAddr, sm, q, macAddr, NULL, num);
198     }
\end{DoxyCode}
\hypertarget{classIGbE_ad5560d7f7671ea0c96250beacf187ac8}{
\index{IGbE@{IGbE}!anQ@{anQ}}
\index{anQ@{anQ}!IGbE@{IGbE}}
\subsubsection[{anQ}]{\setlength{\rightskip}{0pt plus 5cm}void anQ (std::string {\em sm}, \/  std::string {\em q})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classIGbE_ad5560d7f7671ea0c96250beacf187ac8}



\begin{DoxyCode}
188                                         { 
189         cpa->hwQ(CPA::FL_NONE, sys, macAddr, sm, q, macAddr);
190     }
\end{DoxyCode}
\hypertarget{classIGbE_a48fd12dd7cf4b842162b7a0b89875559}{
\index{IGbE@{IGbE}!anRq@{anRq}}
\index{anRq@{anRq}!IGbE@{IGbE}}
\subsubsection[{anRq}]{\setlength{\rightskip}{0pt plus 5cm}void anRq (std::string {\em sm}, \/  std::string {\em q}, \/  int {\em num} = {\ttfamily 1})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classIGbE_a48fd12dd7cf4b842162b7a0b89875559}



\begin{DoxyCode}
200                                                       {
201         cpa->hwRq(CPA::FL_NONE, sys, macAddr, sm, q, macAddr, NULL, num);
202     }
\end{DoxyCode}
\hypertarget{classIGbE_ace79fee3c0fd652014ae35a7b1497ca1}{
\index{IGbE@{IGbE}!anWe@{anWe}}
\index{anWe@{anWe}!IGbE@{IGbE}}
\subsubsection[{anWe}]{\setlength{\rightskip}{0pt plus 5cm}void anWe (std::string {\em sm}, \/  std::string {\em q})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classIGbE_ace79fee3c0fd652014ae35a7b1497ca1}



\begin{DoxyCode}
204                                          {
205         cpa->hwWe(CPA::FL_NONE, sys, macAddr, sm, q, macAddr);
206     }
\end{DoxyCode}
\hypertarget{classIGbE_a09c6a12f9551bd90d913dfe8ed396a67}{
\index{IGbE@{IGbE}!anWf@{anWf}}
\index{anWf@{anWf}!IGbE@{IGbE}}
\subsubsection[{anWf}]{\setlength{\rightskip}{0pt plus 5cm}void anWf (std::string {\em sm}, \/  std::string {\em q})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classIGbE_a09c6a12f9551bd90d913dfe8ed396a67}



\begin{DoxyCode}
208                                          {
209         cpa->hwWf(CPA::FL_NONE, sys, macAddr, sm, q, macAddr);
210     }
\end{DoxyCode}
\hypertarget{classIGbE_a97cbf86aeda5390deb20b1d39396d111}{
\index{IGbE@{IGbE}!checkDrain@{checkDrain}}
\index{checkDrain@{checkDrain}!IGbE@{IGbE}}
\subsubsection[{checkDrain}]{\setlength{\rightskip}{0pt plus 5cm}void checkDrain ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a97cbf86aeda5390deb20b1d39396d111}
\hyperlink{classCheck}{Check} if all the draining things that need to occur have occured and handle the drain event if so. 


\begin{DoxyCode}
2097 {
2098     if (!drainManager)
2099         return;
2100 
2101     txFifoTick = false;
2102     txTick = false;
2103     rxTick = false;
2104     if (!rxDescCache.hasOutstandingEvents() &&
2105         !txDescCache.hasOutstandingEvents()) {
2106         DPRINTF(Drain, "IGbE done draining, processing drain event\n");
2107         drainManager->signalDrainDone();
2108         drainManager = NULL;
2109     }
2110 }
\end{DoxyCode}
\hypertarget{classIGbE_a29bfbbe58f3015bfb026c019295a8836}{
\index{IGbE@{IGbE}!chkInterrupt@{chkInterrupt}}
\index{chkInterrupt@{chkInterrupt}!IGbE@{IGbE}}
\subsubsection[{chkInterrupt}]{\setlength{\rightskip}{0pt plus 5cm}void chkInterrupt ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a29bfbbe58f3015bfb026c019295a8836}
\hyperlink{classCheck}{Check} and see if changes to the mask register have caused an interrupt to need to be sent or perhaps removed an interrupt cause. 


\begin{DoxyCode}
789 {
790     DPRINTF(Ethernet, "Checking interrupts icr: %#x imr: %#x\n", regs.icr(),
791             regs.imr);
792     // Check if we need to clear the cpu interrupt
793     if (!(regs.icr() & regs.imr)) {
794         DPRINTF(Ethernet, "Mask cleaned all interrupts\n");
795         if (interEvent.scheduled())
796             deschedule(interEvent);
797         if (regs.icr.int_assert())
798             cpuClearInt();
799     }
800     DPRINTF(Ethernet, "ITR = %#X itr.interval = %#X\n",
801             regs.itr(), regs.itr.interval());
802 
803     if (regs.icr() & regs.imr) {
804         if (regs.itr.interval() == 0)  {
805             cpuPostInt();
806         } else {
807             DPRINTF(Ethernet,
808                     "Possibly scheduling interrupt because of imr write\n");
809             if (!interEvent.scheduled()) {
810                 Tick t = curTick() + SimClock::Int::ns * 256 * regs.itr.interval(
      );
811                 DPRINTF(Ethernet, "Scheduling for %d\n", t);
812                 schedule(interEvent, t);
813             }
814         }
815     }
816 }
\end{DoxyCode}
\hypertarget{classIGbE_a5bb6e41ae1497d53a611db0a6b455115}{
\index{IGbE@{IGbE}!cpuClearInt@{cpuClearInt}}
\index{cpuClearInt@{cpuClearInt}!IGbE@{IGbE}}
\subsubsection[{cpuClearInt}]{\setlength{\rightskip}{0pt plus 5cm}void cpuClearInt ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a5bb6e41ae1497d53a611db0a6b455115}
Clear the interupt line to the cpu 


\begin{DoxyCode}
777 {
778     if (regs.icr.int_assert()) {
779         regs.icr.int_assert(0);
780         DPRINTF(EthernetIntr,
781                 "EINT: Clearing interrupt to CPU now. Vector %#x\n",
782                 regs.icr());
783         intrClear();
784     }
785 }
\end{DoxyCode}
\hypertarget{classIGbE_a6cc0f5948b3dc7c1f2e489bce23ef907}{
\index{IGbE@{IGbE}!cpuPostInt@{cpuPostInt}}
\index{cpuPostInt@{cpuPostInt}!IGbE@{IGbE}}
\subsubsection[{cpuPostInt}]{\setlength{\rightskip}{0pt plus 5cm}void cpuPostInt ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a6cc0f5948b3dc7c1f2e489bce23ef907}



\begin{DoxyCode}
733 {
734 
735     postedInterrupts++;
736 
737     if (!(regs.icr() & regs.imr)) {
738         DPRINTF(Ethernet, "Interrupt Masked. Not Posting\n");
739         return;
740     }
741 
742     DPRINTF(Ethernet, "Posting Interrupt\n");
743 
744 
745     if (interEvent.scheduled()) {
746         deschedule(interEvent);
747     }
748 
749     if (rdtrEvent.scheduled()) {
750         regs.icr.rxt0(1);
751         deschedule(rdtrEvent);
752     }
753     if (radvEvent.scheduled()) {
754         regs.icr.rxt0(1);
755         deschedule(radvEvent);
756     }
757     if (tadvEvent.scheduled()) {
758         regs.icr.txdw(1);
759         deschedule(tadvEvent);
760     }
761     if (tidvEvent.scheduled()) {
762         regs.icr.txdw(1);
763         deschedule(tidvEvent);
764     }
765 
766     regs.icr.int_assert(1);
767     DPRINTF(EthernetIntr, "EINT: Posting interrupt to CPU now. Vector %#x\n",
768             regs.icr());
769 
770     intrPost();
771 
772     lastInterrupt = curTick();
773 }
\end{DoxyCode}
\hypertarget{classIGbE_a671c460437037741ca81581773939a28}{
\index{IGbE@{IGbE}!delayIntEvent@{delayIntEvent}}
\index{delayIntEvent@{delayIntEvent}!IGbE@{IGbE}}
\subsubsection[{delayIntEvent}]{\setlength{\rightskip}{0pt plus 5cm}void delayIntEvent ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a671c460437037741ca81581773939a28}
Send an interrupt to the cpu 


\begin{DoxyCode}
726 {
727     cpuPostInt();
728 }
\end{DoxyCode}
\hypertarget{classIGbE_aa8a18d230dba7a674ac8a0b4f35bc36a}{
\index{IGbE@{IGbE}!drain@{drain}}
\index{drain@{drain}!IGbE@{IGbE}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em drainManger})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIGbE_aa8a18d230dba7a674ac8a0b4f35bc36a}
Provide a default implementation of the drain interface that simply returns 0 (draining completed) and sets the drain state to Drained. 

\hyperlink{classPciDevice_aa8a18d230dba7a674ac8a0b4f35bc36a}{PciDevice}を再定義しています。


\begin{DoxyCode}
2057 {
2058     unsigned int count;
2059     count = pioPort.drain(dm) + dmaPort.drain(dm);
2060     if (rxDescCache.hasOutstandingEvents() ||
2061         txDescCache.hasOutstandingEvents()) {
2062         count++;
2063         drainManager = dm;
2064     }
2065 
2066     txFifoTick = false;
2067     txTick = false;
2068     rxTick = false;
2069 
2070     if (tickEvent.scheduled())
2071         deschedule(tickEvent);
2072 
2073     if (count) {
2074         DPRINTF(Drain, "IGbE not drained\n");
2075         setDrainState(Drainable::Draining);
2076     } else
2077         setDrainState(Drainable::Drained);
2078 
2079     return count;
2080 }
\end{DoxyCode}
\hypertarget{classIGbE_a8f020d3237536fe007fc488c4125c5d8}{
\index{IGbE@{IGbE}!drainResume@{drainResume}}
\index{drainResume@{drainResume}!IGbE@{IGbE}}
\subsubsection[{drainResume}]{\setlength{\rightskip}{0pt plus 5cm}void drainResume ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIGbE_a8f020d3237536fe007fc488c4125c5d8}
Resume execution after a successful drain.

\begin{DoxyNote}{覚え書き}
This method is normally only called from the simulation scripts. 
\end{DoxyNote}


\hyperlink{classDrainable_a8f020d3237536fe007fc488c4125c5d8}{Drainable}を再定義しています。


\begin{DoxyCode}
2084 {
2085     Drainable::drainResume();
2086 
2087     txFifoTick = true;
2088     txTick = true;
2089     rxTick = true;
2090 
2091     restartClock();
2092     DPRINTF(EthernetSM, "resuming from drain");
2093 }
\end{DoxyCode}
\hypertarget{classIGbE_aaae8ccdf0f0b15e4d1b93e71a0c8b303}{
\index{IGbE@{IGbE}!ethRxPkt@{ethRxPkt}}
\index{ethRxPkt@{ethRxPkt}!IGbE@{IGbE}}
\subsubsection[{ethRxPkt}]{\setlength{\rightskip}{0pt plus 5cm}bool ethRxPkt ({\bf EthPacketPtr} {\em packet})}}
\label{classIGbE_aaae8ccdf0f0b15e4d1b93e71a0c8b303}



\begin{DoxyCode}
2216 {
2217     rxBytes += pkt->length;
2218     rxPackets++;
2219 
2220     DPRINTF(Ethernet, "RxFIFO: Receiving pcakte from wire\n");
2221     anBegin("RXQ", "Wire Recv");
2222 
2223 
2224     if (!regs.rctl.en()) {
2225         DPRINTF(Ethernet, "RxFIFO: RX not enabled, dropping\n");
2226         anBegin("RXQ", "FIFO Drop", CPA::FL_BAD);
2227         return true;
2228     }
2229 
2230     // restart the state machines if they are stopped
2231     rxTick = true && !drainManager;
2232     if ((rxTick || txTick) && !tickEvent.scheduled()) {
2233         DPRINTF(EthernetSM,
2234                 "RXS: received packet into fifo, starting ticking\n");
2235         restartClock();
2236     }
2237 
2238     if (!rxFifo.push(pkt)) {
2239         DPRINTF(Ethernet, "RxFIFO: Packet won't fit in fifo... dropped\n");
2240         postInterrupt(IT_RXO, true);
2241         anBegin("RXQ", "FIFO Drop", CPA::FL_BAD);
2242         return false;
2243     }
2244 
2245     if (CPA::available() && cpa->enabled()) {
2246         assert(sys->numSystemsRunning <= 2);
2247         System *other_sys;
2248         if (sys->systemList[0] == sys)
2249             other_sys = sys->systemList[1];
2250         else
2251             other_sys = sys->systemList[0];
2252 
2253         cpa->hwDq(CPA::FL_NONE, sys, macAddr, "RXQ", "WireQ", 0, other_sys);
2254         anQ("RXQ", "RX FIFO Q");
2255         cpa->hwWe(CPA::FL_NONE, sys, macAddr, "RXQ", "WireQ", 0, other_sys);
2256     }
2257 
2258     return true;
2259 }
\end{DoxyCode}
\hypertarget{classIGbE_a4b170caf60b0a01672ab8e8e3e4dff10}{
\index{IGbE@{IGbE}!ethTxDone@{ethTxDone}}
\index{ethTxDone@{ethTxDone}!IGbE@{IGbE}}
\subsubsection[{ethTxDone}]{\setlength{\rightskip}{0pt plus 5cm}void ethTxDone ()}}
\label{classIGbE_a4b170caf60b0a01672ab8e8e3e4dff10}



\begin{DoxyCode}
2439 {
2440     anBegin("TXQ", "Send Done");
2441     // restart the tx state machines if they are stopped
2442     // fifo to send another packet
2443     // tx sm to put more data into the fifo
2444     txFifoTick = true && !drainManager;
2445     if (txDescCache.descLeft() != 0 && !drainManager)
2446         txTick = true;
2447 
2448     restartClock();
2449     txWire();
2450     DPRINTF(EthernetSM, "TxFIFO: Transmission complete\n");
2451 }
\end{DoxyCode}
\hypertarget{classIGbE_a10260c5a583c0894dcdcd1ced50a53ae}{
\index{IGbE@{IGbE}!getEthPort@{getEthPort}}
\index{getEthPort@{getEthPort}!IGbE@{IGbE}}
\subsubsection[{getEthPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EtherInt} $\ast$ getEthPort (const std::string \& {\em if\_\-name}, \/  int {\em idx})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIGbE_a10260c5a583c0894dcdcd1ced50a53ae}
Additional function to return the \hyperlink{classPort}{Port} of a memory object. 

\hyperlink{classEtherDevice_ac1aa24c1f8c0f1ee8bdc3f3d3799f67c}{EtherDevice}を実装しています。


\begin{DoxyCode}
139 {
140 
141     if (if_name == "interface") {
142         if (etherInt->getPeer())
143             panic("Port already connected to\n");
144         return etherInt;
145     }
146     return NULL;
147 }
\end{DoxyCode}
\hypertarget{classIGbE_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{IGbE@{IGbE}!init@{init}}
\index{init@{init}!IGbE@{IGbE}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIGbE_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classIGbE_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classPciDevice_a02fd73d861ef2e4aabb38c0c9ff82947}{PciDevice}を再定義しています。


\begin{DoxyCode}
132 {
133     cpa = CPA::cpa();
134     PciDevice::init();
135 }
\end{DoxyCode}
\hypertarget{classIGbE_ad4b9fb8ece2ddee6cda2b12e4f77b3d1}{
\index{IGbE@{IGbE}!intClock@{intClock}}
\index{intClock@{intClock}!IGbE@{IGbE}}
\subsubsection[{intClock}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} intClock ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classIGbE_ad4b9fb8ece2ddee6cda2b12e4f77b3d1}



\begin{DoxyCode}
173 { return SimClock::Int::ns * 1024; }
\end{DoxyCode}
\hypertarget{classIGbE_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{IGbE@{IGbE}!params@{params}}
\index{params@{params}!IGbE@{IGbE}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classIGbE_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classEtherDevice_acd3c3feb78ae7a8f88fe0f110a718dff}{EtherDevice}を再定義しています。


\begin{DoxyCode}
513                    {
514         return dynamic_cast<const Params *>(_params);
515     }
\end{DoxyCode}
\hypertarget{classIGbE_a5421bafb8503ffca04cac20d616ae4cc}{
\index{IGbE@{IGbE}!postInterrupt@{postInterrupt}}
\index{postInterrupt@{postInterrupt}!IGbE@{IGbE}}
\subsubsection[{postInterrupt}]{\setlength{\rightskip}{0pt plus 5cm}void postInterrupt ({\bf iGbReg::IntTypes} {\em t}, \/  bool {\em now} = {\ttfamily false})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a5421bafb8503ffca04cac20d616ae4cc}
Write an interrupt into the interrupt pending register and check mask and interrupt limit timer before sending interrupt to CPU 
\begin{DoxyParams}{引数}
\item[{\em t}]the type of interrupt we are posting \item[{\em now}]should we ignore the interrupt limiting timer \end{DoxyParams}



\begin{DoxyCode}
693 {
694     assert(t);
695 
696     // Interrupt is already pending
697     if (t & regs.icr() && !now)
698         return;
699 
700     regs.icr = regs.icr() | t;
701 
702     Tick itr_interval = SimClock::Int::ns * 256 * regs.itr.interval();
703     DPRINTF(EthernetIntr,
704             "EINT: postInterrupt() curTick(): %d itr: %d interval: %d\n",
705             curTick(), regs.itr.interval(), itr_interval);
706 
707     if (regs.itr.interval() == 0 || now ||
708         lastInterrupt + itr_interval <= curTick()) {
709         if (interEvent.scheduled()) {
710             deschedule(interEvent);
711         }
712         cpuPostInt();
713     } else {
714         Tick int_time = lastInterrupt + itr_interval;
715         assert(int_time > 0);
716         DPRINTF(EthernetIntr, "EINT: Scheduling timer interrupt for tick %d\n",
717                 int_time);
718         if (!interEvent.scheduled()) {
719             schedule(interEvent, int_time);
720         }
721     }
722 }
\end{DoxyCode}
\hypertarget{classIGbE_a1d54e26efe0f0a1fbd354ccffa34459f}{
\index{IGbE@{IGbE}!radvProcess@{radvProcess}}
\index{radvProcess@{radvProcess}!IGbE@{IGbE}}
\subsubsection[{radvProcess}]{\setlength{\rightskip}{0pt plus 5cm}void radvProcess ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classIGbE_a1d54e26efe0f0a1fbd354ccffa34459f}



\begin{DoxyCode}
107                        {
108         rxDescCache.writeback(0);
109         DPRINTF(EthernetIntr,
110                 "Posting RXT interrupt because RADV timer expired\n");
111         postInterrupt(iGbReg::IT_RXT);
112     }
\end{DoxyCode}
\hypertarget{classIGbE_a047d922eba10484b3a0127faa8e1be0a}{
\index{IGbE@{IGbE}!rdtrProcess@{rdtrProcess}}
\index{rdtrProcess@{rdtrProcess}!IGbE@{IGbE}}
\subsubsection[{rdtrProcess}]{\setlength{\rightskip}{0pt plus 5cm}void rdtrProcess ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classIGbE_a047d922eba10484b3a0127faa8e1be0a}



\begin{DoxyCode}
96                        {
97         rxDescCache.writeback(0);
98         DPRINTF(EthernetIntr,
99                 "Posting RXT interrupt because RDTR timer expired\n");
100         postInterrupt(iGbReg::IT_RXT);
101     }
\end{DoxyCode}
\hypertarget{classIGbE_a613ec7d5e1ec64f8d21fec78ae8e568e}{
\index{IGbE@{IGbE}!read@{read}}
\index{read@{read}!IGbE@{IGbE}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} read ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIGbE_a613ec7d5e1ec64f8d21fec78ae8e568e}
Pure virtual function that the device must implement. Called when a read command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_a842312590432036092c422c87a442358}{PioDevice}を実装しています。


\begin{DoxyCode}
170 {
171     int bar;
172     Addr daddr;
173 
174     if (!getBAR(pkt->getAddr(), bar, daddr))
175         panic("Invalid PCI memory access to unmapped memory.\n");
176 
177     // Only Memory register BAR is allowed
178     assert(bar == 0);
179 
180     // Only 32bit accesses allowed
181     assert(pkt->getSize() == 4);
182 
183     DPRINTF(Ethernet, "Read device register %#X\n", daddr);
184 
185     pkt->allocate();
186 
187     //
188     // Handle read of register here
189     //
190 
191 
192     switch (daddr) {
193       case REG_CTRL:
194         pkt->set<uint32_t>(regs.ctrl());
195         break;
196       case REG_STATUS:
197         pkt->set<uint32_t>(regs.sts());
198         break;
199       case REG_EECD:
200         pkt->set<uint32_t>(regs.eecd());
201         break;
202       case REG_EERD:
203         pkt->set<uint32_t>(regs.eerd());
204         break;
205       case REG_CTRL_EXT:
206         pkt->set<uint32_t>(regs.ctrl_ext());
207         break;
208       case REG_MDIC:
209         pkt->set<uint32_t>(regs.mdic());
210         break;
211       case REG_ICR:
212         DPRINTF(Ethernet, "Reading ICR. ICR=%#x IMR=%#x IAM=%#x IAME=%d\n",
213                 regs.icr(), regs.imr, regs.iam, regs.ctrl_ext.iame());
214         pkt->set<uint32_t>(regs.icr());
215         if (regs.icr.int_assert() || regs.imr == 0) {
216             regs.icr = regs.icr() & ~mask(30);
217             DPRINTF(Ethernet, "Cleared ICR. ICR=%#x\n", regs.icr());
218         }
219         if (regs.ctrl_ext.iame() && regs.icr.int_assert())
220             regs.imr &= ~regs.iam;
221         chkInterrupt();
222         break;
223       case REG_EICR:
224         // This is only useful for MSI, but the driver reads it every time
225         // Just don't do anything
226         pkt->set<uint32_t>(0);
227         break;
228       case REG_ITR:
229         pkt->set<uint32_t>(regs.itr());
230         break;
231       case REG_RCTL:
232         pkt->set<uint32_t>(regs.rctl());
233         break;
234       case REG_FCTTV:
235         pkt->set<uint32_t>(regs.fcttv());
236         break;
237       case REG_TCTL:
238         pkt->set<uint32_t>(regs.tctl());
239         break;
240       case REG_PBA:
241         pkt->set<uint32_t>(regs.pba());
242         break;
243       case REG_WUC:
244       case REG_LEDCTL:
245         pkt->set<uint32_t>(0); // We don't care, so just return 0
246         break;
247       case REG_FCRTL:
248         pkt->set<uint32_t>(regs.fcrtl());
249         break;
250       case REG_FCRTH:
251         pkt->set<uint32_t>(regs.fcrth());
252         break;
253       case REG_RDBAL:
254         pkt->set<uint32_t>(regs.rdba.rdbal());
255         break;
256       case REG_RDBAH:
257         pkt->set<uint32_t>(regs.rdba.rdbah());
258         break;
259       case REG_RDLEN:
260         pkt->set<uint32_t>(regs.rdlen());
261         break;
262       case REG_SRRCTL:
263         pkt->set<uint32_t>(regs.srrctl());
264         break;
265       case REG_RDH:
266         pkt->set<uint32_t>(regs.rdh());
267         break;
268       case REG_RDT:
269         pkt->set<uint32_t>(regs.rdt());
270         break;
271       case REG_RDTR:
272         pkt->set<uint32_t>(regs.rdtr());
273         if (regs.rdtr.fpd()) {
274             rxDescCache.writeback(0);
275             DPRINTF(EthernetIntr,
276                     "Posting interrupt because of RDTR.FPD write\n");
277             postInterrupt(IT_RXT);
278             regs.rdtr.fpd(0);
279         }
280         break;
281       case REG_RXDCTL:
282         pkt->set<uint32_t>(regs.rxdctl());
283         break;
284       case REG_RADV:
285         pkt->set<uint32_t>(regs.radv());
286         break;
287       case REG_TDBAL:
288         pkt->set<uint32_t>(regs.tdba.tdbal());
289         break;
290       case REG_TDBAH:
291         pkt->set<uint32_t>(regs.tdba.tdbah());
292         break;
293       case REG_TDLEN:
294         pkt->set<uint32_t>(regs.tdlen());
295         break;
296       case REG_TDH:
297         pkt->set<uint32_t>(regs.tdh());
298         break;
299       case REG_TXDCA_CTL:
300         pkt->set<uint32_t>(regs.txdca_ctl());
301         break;
302       case REG_TDT:
303         pkt->set<uint32_t>(regs.tdt());
304         break;
305       case REG_TIDV:
306         pkt->set<uint32_t>(regs.tidv());
307         break;
308       case REG_TXDCTL:
309         pkt->set<uint32_t>(regs.txdctl());
310         break;
311       case REG_TADV:
312         pkt->set<uint32_t>(regs.tadv());
313         break;
314       case REG_TDWBAL:
315         pkt->set<uint32_t>(regs.tdwba & mask(32));
316         break;
317       case REG_TDWBAH:
318         pkt->set<uint32_t>(regs.tdwba >> 32);
319         break;
320       case REG_RXCSUM:
321         pkt->set<uint32_t>(regs.rxcsum());
322         break;
323       case REG_RLPML:
324         pkt->set<uint32_t>(regs.rlpml);
325         break;
326       case REG_RFCTL:
327         pkt->set<uint32_t>(regs.rfctl());
328         break;
329       case REG_MANC:
330         pkt->set<uint32_t>(regs.manc());
331         break;
332       case REG_SWSM:
333         pkt->set<uint32_t>(regs.swsm());
334         regs.swsm.smbi(1);
335         break;
336       case REG_FWSM:
337         pkt->set<uint32_t>(regs.fwsm());
338         break;
339       case REG_SWFWSYNC:
340         pkt->set<uint32_t>(regs.sw_fw_sync);
341         break;
342       default:
343         if (!IN_RANGE(daddr, REG_VFTA, VLAN_FILTER_TABLE_SIZE*4) &&
344             !IN_RANGE(daddr, REG_RAL, RCV_ADDRESS_TABLE_SIZE*8) &&
345             !IN_RANGE(daddr, REG_MTA, MULTICAST_TABLE_SIZE*4) &&
346             !IN_RANGE(daddr, REG_CRCERRS, STATS_REGS_SIZE))
347             panic("Read request to unknown register number: %#x\n", daddr);
348         else
349             pkt->set<uint32_t>(0);
350     };
351 
352     pkt->makeAtomicResponse();
353     return pioDelay;
354 }
\end{DoxyCode}
\hypertarget{classIGbE_a9506deecc41eb6290f9b9b8662cc33c2}{
\index{IGbE@{IGbE}!restartClock@{restartClock}}
\index{restartClock@{restartClock}!IGbE@{IGbE}}
\subsubsection[{restartClock}]{\setlength{\rightskip}{0pt plus 5cm}void restartClock ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a9506deecc41eb6290f9b9b8662cc33c2}
This function is used to restart the clock so it can handle things like draining and resume in one place. 


\begin{DoxyCode}
2049 {
2050     if (!tickEvent.scheduled() && (rxTick || txTick || txFifoTick) &&
2051         getDrainState() == Drainable::Running)
2052         schedule(tickEvent, clockEdge(Cycles(1)));
2053 }
\end{DoxyCode}
\hypertarget{classIGbE_aa22f1272cbc1c6b44dd50faaa71a0d87}{
\index{IGbE@{IGbE}!rxStateMachine@{rxStateMachine}}
\index{rxStateMachine@{rxStateMachine}!IGbE@{IGbE}}
\subsubsection[{rxStateMachine}]{\setlength{\rightskip}{0pt plus 5cm}void rxStateMachine ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_aa22f1272cbc1c6b44dd50faaa71a0d87}



\begin{DoxyCode}
2264 {
2265     if (!regs.rctl.en()) {
2266         rxTick = false;
2267         DPRINTF(EthernetSM, "RXS: RX disabled, stopping ticking\n");
2268         return;
2269     }
2270 
2271     // If the packet is done check for interrupts/descriptors/etc
2272     if (rxDescCache.packetDone()) {
2273         rxDmaPacket = false;
2274         DPRINTF(EthernetSM, "RXS: Packet completed DMA to memory\n");
2275         int descLeft = rxDescCache.descLeft();
2276         DPRINTF(EthernetSM, "RXS: descLeft: %d rdmts: %d rdlen: %d\n",
2277                 descLeft, regs.rctl.rdmts(), regs.rdlen());
2278         switch (regs.rctl.rdmts()) {
2279           case 2: if (descLeft > .125 * regs.rdlen()) break;
2280           case 1: if (descLeft > .250 * regs.rdlen()) break;
2281           case 0: if (descLeft > .500 * regs.rdlen())  break;
2282             DPRINTF(Ethernet, "RXS: Interrupting (RXDMT) "
2283                     "because of descriptors left\n");
2284             postInterrupt(IT_RXDMT);
2285             break;
2286         }
2287 
2288         if (rxFifo.empty())
2289             rxDescCache.writeback(0);
2290 
2291         if (descLeft == 0) {
2292             anBegin("RXS", "Writeback Descriptors");
2293             rxDescCache.writeback(0);
2294             DPRINTF(EthernetSM, "RXS: No descriptors left in ring, forcing"
2295                     " writeback and stopping ticking\n");
2296             rxTick = false;
2297         }
2298 
2299         // only support descriptor granulaties
2300         assert(regs.rxdctl.gran());
2301 
2302         if (regs.rxdctl.wthresh() >= rxDescCache.descUsed()) {
2303             DPRINTF(EthernetSM,
2304                     "RXS: Writing back because WTHRESH >= descUsed\n");
2305             anBegin("RXS", "Writeback Descriptors");
2306             if (regs.rxdctl.wthresh() < (cacheBlockSize()>>4))
2307                 rxDescCache.writeback(regs.rxdctl.wthresh()-1);
2308             else
2309                 rxDescCache.writeback((cacheBlockSize()-1)>>4);
2310         }
2311 
2312         if ((rxDescCache.descUnused() < regs.rxdctl.pthresh()) &&
2313             ((rxDescCache.descLeft() - rxDescCache.descUnused()) >
2314              regs.rxdctl.hthresh())) {
2315             DPRINTF(EthernetSM, "RXS: Fetching descriptors because "
2316                     "descUnused < PTHRESH\n");
2317             anBegin("RXS", "Fetch Descriptors");
2318             rxDescCache.fetchDescriptors();
2319         }
2320 
2321         if (rxDescCache.descUnused() == 0) {
2322             anBegin("RXS", "Fetch Descriptors");
2323             rxDescCache.fetchDescriptors();
2324             anWe("RXS", rxDescCache.annUnusedCacheQ);
2325             DPRINTF(EthernetSM, "RXS: No descriptors available in cache, "
2326                     "fetching descriptors and stopping ticking\n");
2327             rxTick = false;
2328         }
2329         return;
2330     }
2331 
2332     if (rxDmaPacket) {
2333         DPRINTF(EthernetSM,
2334                 "RXS: stopping ticking until packet DMA completes\n");
2335         rxTick = false;
2336         return;
2337     }
2338 
2339     if (!rxDescCache.descUnused()) {
2340         anBegin("RXS", "Fetch Descriptors");
2341         rxDescCache.fetchDescriptors();
2342         anWe("RXS", rxDescCache.annUnusedCacheQ);
2343         DPRINTF(EthernetSM, "RXS: No descriptors available in cache, "
2344                 "stopping ticking\n");
2345         rxTick = false;
2346         DPRINTF(EthernetSM, "RXS: No descriptors available, fetching\n");
2347         return;
2348     }
2349     anPq("RXS", rxDescCache.annUnusedCacheQ);
2350 
2351     if (rxFifo.empty()) {
2352         anWe("RXS", "RX FIFO Q");
2353         DPRINTF(EthernetSM, "RXS: RxFIFO empty, stopping ticking\n");
2354         rxTick = false;
2355         return;
2356     }
2357     anPq("RXS", "RX FIFO Q");
2358     anBegin("RXS", "Get Desc");
2359 
2360     EthPacketPtr pkt;
2361     pkt = rxFifo.front();
2362 
2363 
2364     pktOffset = rxDescCache.writePacket(pkt, pktOffset);
2365     DPRINTF(EthernetSM, "RXS: Writing packet into memory\n");
2366     if (pktOffset == pkt->length) {
2367         anBegin( "RXS", "FIFO Dequeue");
2368         DPRINTF(EthernetSM, "RXS: Removing packet from FIFO\n");
2369         pktOffset = 0;
2370         anDq("RXS", "RX FIFO Q");
2371         rxFifo.pop();
2372     }
2373 
2374     DPRINTF(EthernetSM, "RXS: stopping ticking until packet DMA completes\n");
2375     rxTick = false;
2376     rxDmaPacket = true;
2377     anBegin("RXS", "DMA Packet");
2378 }
\end{DoxyCode}
\hypertarget{classIGbE_a53e036786d17361be4c7320d39c99b84}{
\index{IGbE@{IGbE}!serialize@{serialize}}
\index{serialize@{serialize}!IGbE@{IGbE}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIGbE_a53e036786d17361be4c7320d39c99b84}
Serialize this object to the given output stream. 
\begin{DoxyParams}{引数}
\item[{\em os}]The stream to serialize to. \end{DoxyParams}


\hyperlink{classPciDevice_a53e036786d17361be4c7320d39c99b84}{PciDevice}を再定義しています。


\begin{DoxyCode}
2455 {
2456     PciDevice::serialize(os);
2457 
2458     regs.serialize(os);
2459     SERIALIZE_SCALAR(eeOpBits);
2460     SERIALIZE_SCALAR(eeAddrBits);
2461     SERIALIZE_SCALAR(eeDataBits);
2462     SERIALIZE_SCALAR(eeOpcode);
2463     SERIALIZE_SCALAR(eeAddr);
2464     SERIALIZE_SCALAR(lastInterrupt);
2465     SERIALIZE_ARRAY(flash,iGbReg::EEPROM_SIZE);
2466 
2467     rxFifo.serialize("rxfifo", os);
2468     txFifo.serialize("txfifo", os);
2469 
2470     bool txPktExists = txPacket;
2471     SERIALIZE_SCALAR(txPktExists);
2472     if (txPktExists)
2473         txPacket->serialize("txpacket", os);
2474 
2475     Tick rdtr_time = 0, radv_time = 0, tidv_time = 0, tadv_time = 0,
2476         inter_time = 0;
2477 
2478     if (rdtrEvent.scheduled())
2479         rdtr_time = rdtrEvent.when();
2480     SERIALIZE_SCALAR(rdtr_time);
2481 
2482     if (radvEvent.scheduled())
2483         radv_time = radvEvent.when();
2484     SERIALIZE_SCALAR(radv_time);
2485 
2486     if (tidvEvent.scheduled())
2487         tidv_time = tidvEvent.when();
2488     SERIALIZE_SCALAR(tidv_time);
2489 
2490     if (tadvEvent.scheduled())
2491         tadv_time = tadvEvent.when();
2492     SERIALIZE_SCALAR(tadv_time);
2493 
2494     if (interEvent.scheduled())
2495         inter_time = interEvent.when();
2496     SERIALIZE_SCALAR(inter_time);
2497 
2498     SERIALIZE_SCALAR(pktOffset);
2499 
2500     nameOut(os, csprintf("%s.TxDescCache", name()));
2501     txDescCache.serialize(os);
2502 
2503     nameOut(os, csprintf("%s.RxDescCache", name()));
2504     rxDescCache.serialize(os);
2505 }
\end{DoxyCode}
\hypertarget{classIGbE_a7e3216d8f11c9d6c3fa244be21648778}{
\index{IGbE@{IGbE}!tadvProcess@{tadvProcess}}
\index{tadvProcess@{tadvProcess}!IGbE@{IGbE}}
\subsubsection[{tadvProcess}]{\setlength{\rightskip}{0pt plus 5cm}void tadvProcess ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classIGbE_a7e3216d8f11c9d6c3fa244be21648778}



\begin{DoxyCode}
118                        {
119         txDescCache.writeback(0);
120         DPRINTF(EthernetIntr,
121                 "Posting TXDW interrupt because TADV timer expired\n");
122         postInterrupt(iGbReg::IT_TXDW);
123     }
\end{DoxyCode}
\hypertarget{classIGbE_a873dd91783f9efb4a590aded1f70d6b0}{
\index{IGbE@{IGbE}!tick@{tick}}
\index{tick@{tick}!IGbE@{IGbE}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a873dd91783f9efb4a590aded1f70d6b0}



\begin{DoxyCode}
2420 {
2421     DPRINTF(EthernetSM, "IGbE: -------------- Cycle --------------\n");
2422 
2423     if (rxTick)
2424         rxStateMachine();
2425 
2426     if (txTick)
2427         txStateMachine();
2428 
2429     if (txFifoTick)
2430         txWire();
2431 
2432 
2433     if (rxTick || txTick || txFifoTick)
2434         schedule(tickEvent, curTick() + clockPeriod());
2435 }
\end{DoxyCode}
\hypertarget{classIGbE_aedc70a3ef5f173813e3060f77fa53bc8}{
\index{IGbE@{IGbE}!tidvProcess@{tidvProcess}}
\index{tidvProcess@{tidvProcess}!IGbE@{IGbE}}
\subsubsection[{tidvProcess}]{\setlength{\rightskip}{0pt plus 5cm}void tidvProcess ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classIGbE_aedc70a3ef5f173813e3060f77fa53bc8}



\begin{DoxyCode}
129                        {
130         txDescCache.writeback(0);
131         DPRINTF(EthernetIntr,
132                 "Posting TXDW interrupt because TIDV timer expired\n");
133         postInterrupt(iGbReg::IT_TXDW);
134     }
\end{DoxyCode}
\hypertarget{classIGbE_a86f1c8a72188e638c991535ba96f5f0e}{
\index{IGbE@{IGbE}!txStateMachine@{txStateMachine}}
\index{txStateMachine@{txStateMachine}!IGbE@{IGbE}}
\subsubsection[{txStateMachine}]{\setlength{\rightskip}{0pt plus 5cm}void txStateMachine ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a86f1c8a72188e638c991535ba96f5f0e}



\begin{DoxyCode}
2114 {
2115     if (!regs.tctl.en()) {
2116         txTick = false;
2117         DPRINTF(EthernetSM, "TXS: TX disabled, stopping ticking\n");
2118         return;
2119     }
2120 
2121     // If we have a packet available and it's length is not 0 (meaning it's not
2122     // a multidescriptor packet) put it in the fifo, otherwise an the next
2123     // iteration we'll get the rest of the data
2124     if (txPacket && txDescCache.packetAvailable()
2125         && !txDescCache.packetMultiDesc() && txPacket->length) {
2126         anQ("TXS", "TX FIFO Q");
2127         DPRINTF(EthernetSM, "TXS: packet placed in TX FIFO\n");
2128 #ifndef NDEBUG
2129         bool success =
2130 #endif
2131             txFifo.push(txPacket);
2132         txFifoTick = true && !drainManager;
2133         assert(success);
2134         txPacket = NULL;
2135         anBegin("TXS", "Desc Writeback");
2136         txDescCache.writeback((cacheBlockSize()-1)>>4);
2137         return;
2138     }
2139 
2140     // Only support descriptor granularity
2141     if (regs.txdctl.lwthresh() &&
2142         txDescCache.descLeft() < (regs.txdctl.lwthresh() * 8)) {
2143         DPRINTF(EthernetSM, "TXS: LWTHRESH caused posting of TXDLOW\n");
2144         postInterrupt(IT_TXDLOW);
2145     }
2146 
2147     if (!txPacket) {
2148         txPacket = new EthPacketData(16384);
2149     }
2150 
2151     if (!txDescCache.packetWaiting()) {
2152         if (txDescCache.descLeft() == 0) {
2153             postInterrupt(IT_TXQE);
2154             anBegin("TXS", "Desc Writeback");
2155             txDescCache.writeback(0);
2156             anBegin("TXS", "Desc Fetch");
2157             anWe("TXS", txDescCache.annUnusedCacheQ);
2158             txDescCache.fetchDescriptors();
2159             DPRINTF(EthernetSM, "TXS: No descriptors left in ring, forcing "
2160                     "writeback stopping ticking and posting TXQE\n");
2161             txTick = false;
2162             return;
2163         }
2164 
2165 
2166         if (!(txDescCache.descUnused())) {
2167             anBegin("TXS", "Desc Fetch");
2168             txDescCache.fetchDescriptors();
2169             anWe("TXS", txDescCache.annUnusedCacheQ);
2170             DPRINTF(EthernetSM, "TXS: No descriptors available in cache, "
2171                     "fetching and stopping ticking\n");
2172             txTick = false;
2173             return;
2174         }
2175         anPq("TXS", txDescCache.annUnusedCacheQ);
2176 
2177 
2178         txDescCache.processContextDesc();
2179         if (txDescCache.packetWaiting()) {
2180             DPRINTF(EthernetSM,
2181                     "TXS: Fetching TSO header, stopping ticking\n");
2182             txTick = false;
2183             return;
2184         }
2185 
2186         unsigned size = txDescCache.getPacketSize(txPacket);
2187         if (size > 0 && txFifo.avail() > size) {
2188             anRq("TXS", "TX FIFO Q");
2189             anBegin("TXS", "DMA Packet");
2190             DPRINTF(EthernetSM, "TXS: Reserving %d bytes in FIFO and "
2191                     "beginning DMA of next packet\n", size);
2192             txFifo.reserve(size);
2193             txDescCache.getPacketData(txPacket);
2194         } else if (size == 0) {
2195             DPRINTF(EthernetSM, "TXS: getPacketSize returned: %d\n", size);
2196             DPRINTF(EthernetSM,
2197                     "TXS: No packets to get, writing back used descriptors\n");
2198             anBegin("TXS", "Desc Writeback");
2199             txDescCache.writeback(0);
2200         } else {
2201             anWf("TXS", "TX FIFO Q");
2202             DPRINTF(EthernetSM, "TXS: FIFO full, stopping ticking until space "
2203                     "available in FIFO\n");
2204             txTick = false;
2205         }
2206 
2207 
2208         return;
2209     }
2210     DPRINTF(EthernetSM, "TXS: Nothing to do, stopping ticking\n");
2211     txTick = false;
2212 }
\end{DoxyCode}
\hypertarget{classIGbE_af67ff1365c83adc97fef8753e38f3d9e}{
\index{IGbE@{IGbE}!txWire@{txWire}}
\index{txWire@{txWire}!IGbE@{IGbE}}
\subsubsection[{txWire}]{\setlength{\rightskip}{0pt plus 5cm}void txWire ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_af67ff1365c83adc97fef8753e38f3d9e}



\begin{DoxyCode}
2382 {
2383     if (txFifo.empty()) {
2384         anWe("TXQ", "TX FIFO Q");
2385         txFifoTick = false;
2386         return;
2387     }
2388 
2389 
2390     anPq("TXQ", "TX FIFO Q");
2391     if (etherInt->sendPacket(txFifo.front())) {
2392         cpa->hwQ(CPA::FL_NONE, sys, macAddr, "TXQ", "WireQ", 0);
2393         if (DTRACE(EthernetSM)) {
2394             IpPtr ip(txFifo.front());
2395             if (ip)
2396                 DPRINTF(EthernetSM, "Transmitting Ip packet with Id=%d\n",
2397                         ip->id());
2398             else
2399                 DPRINTF(EthernetSM, "Transmitting Non-Ip packet\n");
2400         }
2401         anDq("TXQ", "TX FIFO Q");
2402         anBegin("TXQ", "Wire Send");
2403         DPRINTF(EthernetSM,
2404                 "TxFIFO: Successful transmit, bytes available in fifo: %d\n",
2405                 txFifo.avail());
2406 
2407         txBytes += txFifo.front()->length;
2408         txPackets++;
2409         txFifoTick = false;
2410 
2411         txFifo.pop();
2412     } else {
2413         // We'll get woken up when the packet ethTxDone() gets called
2414         txFifoTick = false;
2415     }
2416 }
\end{DoxyCode}
\hypertarget{classIGbE_af22e5d6d660b97db37003ac61ac4ee49}{
\index{IGbE@{IGbE}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!IGbE@{IGbE}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIGbE_af22e5d6d660b97db37003ac61ac4ee49}
Reconstruct the state of this object from a checkpoint. 
\begin{DoxyParams}{引数}
\item[{\em \hyperlink{namespacecp}{cp}}]The checkpoint use. \item[{\em section}]The section name of this object \end{DoxyParams}


\hyperlink{classPciDevice_af22e5d6d660b97db37003ac61ac4ee49}{PciDevice}を再定義しています。


\begin{DoxyCode}
2509 {
2510     PciDevice::unserialize(cp, section);
2511 
2512     regs.unserialize(cp, section);
2513     UNSERIALIZE_SCALAR(eeOpBits);
2514     UNSERIALIZE_SCALAR(eeAddrBits);
2515     UNSERIALIZE_SCALAR(eeDataBits);
2516     UNSERIALIZE_SCALAR(eeOpcode);
2517     UNSERIALIZE_SCALAR(eeAddr);
2518     UNSERIALIZE_SCALAR(lastInterrupt);
2519     UNSERIALIZE_ARRAY(flash,iGbReg::EEPROM_SIZE);
2520 
2521     rxFifo.unserialize("rxfifo", cp, section);
2522     txFifo.unserialize("txfifo", cp, section);
2523 
2524     bool txPktExists;
2525     UNSERIALIZE_SCALAR(txPktExists);
2526     if (txPktExists) {
2527         txPacket = new EthPacketData(16384);
2528         txPacket->unserialize("txpacket", cp, section);
2529     }
2530 
2531     rxTick = true;
2532     txTick = true;
2533     txFifoTick = true;
2534 
2535     Tick rdtr_time, radv_time, tidv_time, tadv_time, inter_time;
2536     UNSERIALIZE_SCALAR(rdtr_time);
2537     UNSERIALIZE_SCALAR(radv_time);
2538     UNSERIALIZE_SCALAR(tidv_time);
2539     UNSERIALIZE_SCALAR(tadv_time);
2540     UNSERIALIZE_SCALAR(inter_time);
2541 
2542     if (rdtr_time)
2543         schedule(rdtrEvent, rdtr_time);
2544 
2545     if (radv_time)
2546         schedule(radvEvent, radv_time);
2547 
2548     if (tidv_time)
2549         schedule(tidvEvent, tidv_time);
2550 
2551     if (tadv_time)
2552         schedule(tadvEvent, tadv_time);
2553 
2554     if (inter_time)
2555         schedule(interEvent, inter_time);
2556 
2557     UNSERIALIZE_SCALAR(pktOffset);
2558 
2559     txDescCache.unserialize(cp, csprintf("%s.TxDescCache", section));
2560 
2561     rxDescCache.unserialize(cp, csprintf("%s.RxDescCache", section));
2562 }
\end{DoxyCode}
\hypertarget{classIGbE_a4cefab464e72b5dd42c003a0a4341802}{
\index{IGbE@{IGbE}!write@{write}}
\index{write@{write}!IGbE@{IGbE}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} write ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIGbE_a4cefab464e72b5dd42c003a0a4341802}
Pure virtual function that the device must implement. Called when a write command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_afe8371668d023bb2516b286e5e399b6f}{PioDevice}を実装しています。


\begin{DoxyCode}
358 {
359     int bar;
360     Addr daddr;
361 
362 
363     if (!getBAR(pkt->getAddr(), bar, daddr))
364         panic("Invalid PCI memory access to unmapped memory.\n");
365 
366     // Only Memory register BAR is allowed
367     assert(bar == 0);
368 
369     // Only 32bit accesses allowed
370     assert(pkt->getSize() == sizeof(uint32_t));
371 
372     DPRINTF(Ethernet, "Wrote device register %#X value %#X\n",
373             daddr, pkt->get<uint32_t>());
374 
375     //
376     // Handle write of register here
377     //
378     uint32_t val = pkt->get<uint32_t>();
379 
380     Regs::RCTL oldrctl;
381     Regs::TCTL oldtctl;
382 
383     switch (daddr) {
384       case REG_CTRL:
385         regs.ctrl = val;
386         if (regs.ctrl.tfce())
387             warn("TX Flow control enabled, should implement\n");
388         if (regs.ctrl.rfce())
389             warn("RX Flow control enabled, should implement\n");
390         break;
391       case REG_CTRL_EXT:
392         regs.ctrl_ext = val;
393         break;
394       case REG_STATUS:
395         regs.sts = val;
396         break;
397       case REG_EECD:
398         int oldClk;
399         oldClk = regs.eecd.sk();
400         regs.eecd = val;
401         // See if this is a eeprom access and emulate accordingly
402         if (!oldClk && regs.eecd.sk()) {
403             if (eeOpBits < 8) {
404                 eeOpcode = eeOpcode << 1 | regs.eecd.din();
405                 eeOpBits++;
406             } else if (eeAddrBits < 8 && eeOpcode == EEPROM_READ_OPCODE_SPI) {
407                 eeAddr = eeAddr << 1 | regs.eecd.din();
408                 eeAddrBits++;
409             } else if (eeDataBits < 16 && eeOpcode == EEPROM_READ_OPCODE_SPI) {
410                 assert(eeAddr>>1 < EEPROM_SIZE);
411                 DPRINTF(EthernetEEPROM, "EEPROM bit read: %d word: %#X\n",
412                         flash[eeAddr>>1] >> eeDataBits & 0x1,
413                         flash[eeAddr>>1]);
414                 regs.eecd.dout((flash[eeAddr>>1] >> (15-eeDataBits)) & 0x1);
415                 eeDataBits++;
416             } else if (eeDataBits < 8 && eeOpcode == EEPROM_RDSR_OPCODE_SPI) {
417                 regs.eecd.dout(0);
418                 eeDataBits++;
419             } else
420                 panic("What's going on with eeprom interface? opcode:"
421                       " %#x:%d addr: %#x:%d, data: %d\n", (uint32_t)eeOpcode,
422                       (uint32_t)eeOpBits, (uint32_t)eeAddr,
423                       (uint32_t)eeAddrBits, (uint32_t)eeDataBits);
424 
425             // Reset everything for the next command
426             if ((eeDataBits == 16 && eeOpcode == EEPROM_READ_OPCODE_SPI) ||
427                 (eeDataBits == 8 && eeOpcode == EEPROM_RDSR_OPCODE_SPI)) {
428                 eeOpBits = 0;
429                 eeAddrBits = 0;
430                 eeDataBits = 0;
431                 eeOpcode = 0;
432                 eeAddr = 0;
433             }
434 
435             DPRINTF(EthernetEEPROM, "EEPROM: opcode: %#X:%d addr: %#X:%d\n",
436                     (uint32_t)eeOpcode, (uint32_t) eeOpBits,
437                     (uint32_t)eeAddr>>1, (uint32_t)eeAddrBits);
438             if (eeOpBits == 8 && !(eeOpcode == EEPROM_READ_OPCODE_SPI ||
439                                    eeOpcode == EEPROM_RDSR_OPCODE_SPI ))
440                 panic("Unknown eeprom opcode: %#X:%d\n", (uint32_t)eeOpcode,
441                       (uint32_t)eeOpBits);
442 
443 
444         }
445         // If driver requests eeprom access, immediately give it to it
446         regs.eecd.ee_gnt(regs.eecd.ee_req());
447         break;
448       case REG_EERD:
449         regs.eerd = val;
450         if (regs.eerd.start()) {
451             regs.eerd.done(1);
452             assert(regs.eerd.addr() < EEPROM_SIZE);
453             regs.eerd.data(flash[regs.eerd.addr()]);
454             regs.eerd.start(0);
455             DPRINTF(EthernetEEPROM, "EEPROM: read addr: %#X data %#x\n",
456                     regs.eerd.addr(), regs.eerd.data());
457         }
458         break;
459       case REG_MDIC:
460         regs.mdic = val;
461         if (regs.mdic.i())
462             panic("No support for interrupt on mdic complete\n");
463         if (regs.mdic.phyadd() != 1)
464             panic("No support for reading anything but phy\n");
465         DPRINTF(Ethernet, "%s phy address %x\n",
466                 regs.mdic.op() == 1 ? "Writing" : "Reading",
467                 regs.mdic.regadd());
468         switch (regs.mdic.regadd()) {
469           case PHY_PSTATUS:
470             regs.mdic.data(0x796D); // link up
471             break;
472           case PHY_PID:
473             regs.mdic.data(params()->phy_pid);
474             break;
475           case PHY_EPID:
476             regs.mdic.data(params()->phy_epid);
477             break;
478           case PHY_GSTATUS:
479             regs.mdic.data(0x7C00);
480             break;
481           case PHY_EPSTATUS:
482             regs.mdic.data(0x3000);
483             break;
484           case PHY_AGC:
485             regs.mdic.data(0x180); // some random length
486             break;
487           default:
488             regs.mdic.data(0);
489         }
490         regs.mdic.r(1);
491         break;
492       case REG_ICR:
493         DPRINTF(Ethernet, "Writing ICR. ICR=%#x IMR=%#x IAM=%#x IAME=%d\n",
494                 regs.icr(), regs.imr, regs.iam, regs.ctrl_ext.iame());
495         if (regs.ctrl_ext.iame())
496             regs.imr &= ~regs.iam;
497         regs.icr = ~bits(val,30,0) & regs.icr();
498         chkInterrupt();
499         break;
500       case REG_ITR:
501         regs.itr = val;
502         break;
503       case REG_ICS:
504         DPRINTF(EthernetIntr, "Posting interrupt because of ICS write\n");
505         postInterrupt((IntTypes)val);
506         break;
507       case REG_IMS:
508         regs.imr |= val;
509         chkInterrupt();
510         break;
511       case REG_IMC:
512         regs.imr &= ~val;
513         chkInterrupt();
514         break;
515       case REG_IAM:
516         regs.iam = val;
517         break;
518       case REG_RCTL:
519         oldrctl = regs.rctl;
520         regs.rctl = val;
521         if (regs.rctl.rst()) {
522             rxDescCache.reset();
523             DPRINTF(EthernetSM, "RXS: Got RESET!\n");
524             rxFifo.clear();
525             regs.rctl.rst(0);
526         }
527         if (regs.rctl.en())
528             rxTick = true;
529         restartClock();
530         break;
531       case REG_FCTTV:
532         regs.fcttv = val;
533         break;
534       case REG_TCTL:
535         regs.tctl = val;
536         oldtctl = regs.tctl;
537         regs.tctl = val;
538         if (regs.tctl.en())
539             txTick = true;
540         restartClock();
541         if (regs.tctl.en() && !oldtctl.en()) {
542             txDescCache.reset();
543         }
544         break;
545       case REG_PBA:
546         regs.pba.rxa(val);
547         regs.pba.txa(64 - regs.pba.rxa());
548         break;
549       case REG_WUC:
550       case REG_LEDCTL:
551       case REG_FCAL:
552       case REG_FCAH:
553       case REG_FCT:
554       case REG_VET:
555       case REG_AIFS:
556       case REG_TIPG:
557         ; // We don't care, so don't store anything
558         break;
559       case REG_IVAR0:
560         warn("Writing to IVAR0, ignoring...\n");
561         break;
562       case REG_FCRTL:
563         regs.fcrtl = val;
564         break;
565       case REG_FCRTH:
566         regs.fcrth = val;
567         break;
568       case REG_RDBAL:
569         regs.rdba.rdbal( val & ~mask(4));
570         rxDescCache.areaChanged();
571         break;
572       case REG_RDBAH:
573         regs.rdba.rdbah(val);
574         rxDescCache.areaChanged();
575         break;
576       case REG_RDLEN:
577         regs.rdlen = val & ~mask(7);
578         rxDescCache.areaChanged();
579         break;
580       case REG_SRRCTL:
581         regs.srrctl = val;
582         break;
583       case REG_RDH:
584         regs.rdh = val;
585         rxDescCache.areaChanged();
586         break;
587       case REG_RDT:
588         regs.rdt = val;
589         DPRINTF(EthernetSM, "RXS: RDT Updated.\n");
590         if (getDrainState() == Drainable::Running) {
591             DPRINTF(EthernetSM, "RXS: RDT Fetching Descriptors!\n");
592             rxDescCache.fetchDescriptors();
593         } else {
594             DPRINTF(EthernetSM, "RXS: RDT NOT Fetching Desc b/c draining!\n");
595         }
596         break;
597       case REG_RDTR:
598         regs.rdtr = val;
599         break;
600       case REG_RADV:
601         regs.radv = val;
602         break;
603       case REG_RXDCTL:
604         regs.rxdctl = val;
605         break;
606       case REG_TDBAL:
607         regs.tdba.tdbal( val & ~mask(4));
608         txDescCache.areaChanged();
609         break;
610       case REG_TDBAH:
611         regs.tdba.tdbah(val);
612         txDescCache.areaChanged();
613         break;
614       case REG_TDLEN:
615         regs.tdlen = val & ~mask(7);
616         txDescCache.areaChanged();
617         break;
618       case REG_TDH:
619         regs.tdh = val;
620         txDescCache.areaChanged();
621         break;
622       case REG_TXDCA_CTL:
623         regs.txdca_ctl = val;
624         if (regs.txdca_ctl.enabled())
625             panic("No support for DCA\n");
626         break;
627       case REG_TDT:
628         regs.tdt = val;
629         DPRINTF(EthernetSM, "TXS: TX Tail pointer updated\n");
630         if (getDrainState() == Drainable::Running) {
631             DPRINTF(EthernetSM, "TXS: TDT Fetching Descriptors!\n");
632             txDescCache.fetchDescriptors();
633         } else {
634             DPRINTF(EthernetSM, "TXS: TDT NOT Fetching Desc b/c draining!\n");
635         }
636         break;
637       case REG_TIDV:
638         regs.tidv = val;
639         break;
640       case REG_TXDCTL:
641         regs.txdctl = val;
642         break;
643       case REG_TADV:
644         regs.tadv = val;
645         break;
646       case REG_TDWBAL:
647         regs.tdwba &= ~mask(32);
648         regs.tdwba |= val;
649         txDescCache.completionWriteback(regs.tdwba & ~mask(1),
650                                         regs.tdwba & mask(1));
651         break;
652       case REG_TDWBAH:
653         regs.tdwba &= mask(32);
654         regs.tdwba |= (uint64_t)val << 32;
655         txDescCache.completionWriteback(regs.tdwba & ~mask(1),
656                                         regs.tdwba & mask(1));
657         break;
658       case REG_RXCSUM:
659         regs.rxcsum = val;
660         break;
661       case REG_RLPML:
662         regs.rlpml = val;
663         break;
664       case REG_RFCTL:
665         regs.rfctl = val;
666         if (regs.rfctl.exsten())
667             panic("Extended RX descriptors not implemented\n");
668         break;
669       case REG_MANC:
670         regs.manc = val;
671         break;
672       case REG_SWSM:
673         regs.swsm = val;
674         if (regs.fwsm.eep_fw_semaphore())
675             regs.swsm.swesmbi(0);
676         break;
677       case REG_SWFWSYNC:
678         regs.sw_fw_sync = val;
679         break;
680       default:
681         if (!IN_RANGE(daddr, REG_VFTA, VLAN_FILTER_TABLE_SIZE*4) &&
682             !IN_RANGE(daddr, REG_RAL, RCV_ADDRESS_TABLE_SIZE*8) &&
683             !IN_RANGE(daddr, REG_MTA, MULTICAST_TABLE_SIZE*4))
684             panic("Write request to unknown register number: %#x\n", daddr);
685     };
686 
687     pkt->makeAtomicResponse();
688     return pioDelay;
689 }
\end{DoxyCode}
\hypertarget{classIGbE_aac7b61a78530109bfa20923a53064bbf}{
\index{IGbE@{IGbE}!writeConfig@{writeConfig}}
\index{writeConfig@{writeConfig}!IGbE@{IGbE}}
\subsubsection[{writeConfig}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} writeConfig ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIGbE_aac7b61a78530109bfa20923a53064bbf}
Write to the PCI config space data that is stored locally. This may be overridden by the device but at some point it will eventually call this for normal operations that it does not need to override. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]packet containing the write the offset into config space \end{DoxyParams}


\hyperlink{classPciDevice_aac7b61a78530109bfa20923a53064bbf}{PciDevice}を再定義しています。


\begin{DoxyCode}
151 {
152     int offset = pkt->getAddr() & PCI_CONFIG_SIZE;
153     if (offset < PCI_DEVICE_SPECIFIC)
154         PciDevice::writeConfig(pkt);
155     else
156         panic("Device specific PCI config space not implemented.\n");
157 
158     //
159     // Some work may need to be done here based for the pci COMMAND bits.
160     //
161 
162     return configDelay;
163 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classIGbE_a5117ecf4d368d174c17a9304676a45a5}{
\index{IGbE@{IGbE}!RxDescCache@{RxDescCache}}
\index{RxDescCache@{RxDescCache}!IGbE@{IGbE}}
\subsubsection[{RxDescCache}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf RxDescCache}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classIGbE_a5117ecf4d368d174c17a9304676a45a5}
\hypertarget{classIGbE_ab83c1d837daa8ccbbd651c133208ced0}{
\index{IGbE@{IGbE}!TxDescCache@{TxDescCache}}
\index{TxDescCache@{TxDescCache}!IGbE@{IGbE}}
\subsubsection[{TxDescCache}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf TxDescCache}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classIGbE_ab83c1d837daa8ccbbd651c133208ced0}


\subsection{変数}
\hypertarget{classIGbE_ad3738d2e08f4ea21f1c3721f2492c9c2}{
\index{IGbE@{IGbE}!cpa@{cpa}}
\index{cpa@{cpa}!IGbE@{IGbE}}
\subsubsection[{cpa}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CPA}$\ast$ {\bf cpa}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_ad3738d2e08f4ea21f1c3721f2492c9c2}
\hypertarget{classIGbE_a329b71fb934a93312ca0aacbf5a3f982}{
\index{IGbE@{IGbE}!drainManager@{drainManager}}
\index{drainManager@{drainManager}!IGbE@{IGbE}}
\subsubsection[{drainManager}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DrainManager}$\ast$ {\bf drainManager}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a329b71fb934a93312ca0aacbf5a3f982}
\hypertarget{classIGbE_a00d8c4d0c00b1a7fc2a5885222511eee}{
\index{IGbE@{IGbE}!eeAddr@{eeAddr}}
\index{eeAddr@{eeAddr}!IGbE@{IGbE}}
\subsubsection[{eeAddr}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf eeAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a00d8c4d0c00b1a7fc2a5885222511eee}
\hypertarget{classIGbE_a976342e4e142f8f031f86a8e7ce7a55f}{
\index{IGbE@{IGbE}!eeAddrBits@{eeAddrBits}}
\index{eeAddrBits@{eeAddrBits}!IGbE@{IGbE}}
\subsubsection[{eeAddrBits}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf eeAddrBits}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a976342e4e142f8f031f86a8e7ce7a55f}
\hypertarget{classIGbE_ad2c36d4fa51a4befaa7518f6fa3590be}{
\index{IGbE@{IGbE}!eeDataBits@{eeDataBits}}
\index{eeDataBits@{eeDataBits}!IGbE@{IGbE}}
\subsubsection[{eeDataBits}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf eeDataBits}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_ad2c36d4fa51a4befaa7518f6fa3590be}
\hypertarget{classIGbE_a8988636da8c2e4f74e8c62d7ad585a61}{
\index{IGbE@{IGbE}!eeOpBits@{eeOpBits}}
\index{eeOpBits@{eeOpBits}!IGbE@{IGbE}}
\subsubsection[{eeOpBits}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf eeOpBits}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a8988636da8c2e4f74e8c62d7ad585a61}
\hypertarget{classIGbE_aa6c5c24d6b03e9f01ddacc4448214383}{
\index{IGbE@{IGbE}!eeOpcode@{eeOpcode}}
\index{eeOpcode@{eeOpcode}!IGbE@{IGbE}}
\subsubsection[{eeOpcode}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t {\bf eeOpcode}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_aa6c5c24d6b03e9f01ddacc4448214383}
\hypertarget{classIGbE_a4c7684471cc2bc72bc660ea06ca78c91}{
\index{IGbE@{IGbE}!etherInt@{etherInt}}
\index{etherInt@{etherInt}!IGbE@{IGbE}}
\subsubsection[{etherInt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IGbEInt}$\ast$ {\bf etherInt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a4c7684471cc2bc72bc660ea06ca78c91}
\hypertarget{classIGbE_ae404928093bd61ac24cd54406a98046e}{
\index{IGbE@{IGbE}!fetchCompDelay@{fetchCompDelay}}
\index{fetchCompDelay@{fetchCompDelay}!IGbE@{IGbE}}
\subsubsection[{fetchCompDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf fetchCompDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_ae404928093bd61ac24cd54406a98046e}
\hypertarget{classIGbE_aa17c871ae2de13303ab07a8e8b571965}{
\index{IGbE@{IGbE}!fetchDelay@{fetchDelay}}
\index{fetchDelay@{fetchDelay}!IGbE@{IGbE}}
\subsubsection[{fetchDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf fetchDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_aa17c871ae2de13303ab07a8e8b571965}
\hypertarget{classIGbE_a7a8d29882b2cc202e8f3d9f4e758937c}{
\index{IGbE@{IGbE}!flash@{flash}}
\index{flash@{flash}!IGbE@{IGbE}}
\subsubsection[{flash}]{\setlength{\rightskip}{0pt plus 5cm}uint16\_\-t {\bf flash}\mbox{[}{\bf iGbReg::EEPROM\_\-SIZE}\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a7a8d29882b2cc202e8f3d9f4e758937c}
\hypertarget{classIGbE_a3de27cfe33d0ae9f9451c767ee40a57d}{
\index{IGbE@{IGbE}!interEvent@{interEvent}}
\index{interEvent@{interEvent}!IGbE@{IGbE}}
\subsubsection[{interEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf IGbE}, \&IGbE::delayIntEvent$>$ {\bf interEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a3de27cfe33d0ae9f9451c767ee40a57d}
\hypertarget{classIGbE_adad52012a21d414368149556f2cc909b}{
\index{IGbE@{IGbE}!lastInterrupt@{lastInterrupt}}
\index{lastInterrupt@{lastInterrupt}!IGbE@{IGbE}}
\subsubsection[{lastInterrupt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf lastInterrupt}}}
\label{classIGbE_adad52012a21d414368149556f2cc909b}
\hypertarget{classIGbE_ab70964077d0446a01beedcfb7b9f64da}{
\index{IGbE@{IGbE}!macAddr@{macAddr}}
\index{macAddr@{macAddr}!IGbE@{IGbE}}
\subsubsection[{macAddr}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf macAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_ab70964077d0446a01beedcfb7b9f64da}
\hypertarget{classIGbE_a41fd0002dbd12f7ab760e7f0a6620953}{
\index{IGbE@{IGbE}!pktOffset@{pktOffset}}
\index{pktOffset@{pktOffset}!IGbE@{IGbE}}
\subsubsection[{pktOffset}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf pktOffset}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a41fd0002dbd12f7ab760e7f0a6620953}
\hypertarget{classIGbE_a30a3a2a8194ad851683c915beca8a172}{
\index{IGbE@{IGbE}!radvEvent@{radvEvent}}
\index{radvEvent@{radvEvent}!IGbE@{IGbE}}
\subsubsection[{radvEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf IGbE}, \&IGbE::radvProcess$>$ {\bf radvEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a30a3a2a8194ad851683c915beca8a172}
\hypertarget{classIGbE_a72b4c60f46bdb4b88427dec167aaca80}{
\index{IGbE@{IGbE}!rdtrEvent@{rdtrEvent}}
\index{rdtrEvent@{rdtrEvent}!IGbE@{IGbE}}
\subsubsection[{rdtrEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf IGbE}, \&IGbE::rdtrProcess$>$ {\bf rdtrEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a72b4c60f46bdb4b88427dec167aaca80}
\hypertarget{classIGbE_aca82e9e23b43d692ee2d79799761533f}{
\index{IGbE@{IGbE}!regs@{regs}}
\index{regs@{regs}!IGbE@{IGbE}}
\subsubsection[{regs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf iGbReg::Regs} {\bf regs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_aca82e9e23b43d692ee2d79799761533f}
\hypertarget{classIGbE_a0e260069d3ff6994b7ab0d843388c5d5}{
\index{IGbE@{IGbE}!rxDescCache@{rxDescCache}}
\index{rxDescCache@{rxDescCache}!IGbE@{IGbE}}
\subsubsection[{rxDescCache}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RxDescCache} {\bf rxDescCache}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a0e260069d3ff6994b7ab0d843388c5d5}
\hypertarget{classIGbE_aa8031223419e9d8480a99fae1f2de778}{
\index{IGbE@{IGbE}!rxDmaPacket@{rxDmaPacket}}
\index{rxDmaPacket@{rxDmaPacket}!IGbE@{IGbE}}
\subsubsection[{rxDmaPacket}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf rxDmaPacket}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_aa8031223419e9d8480a99fae1f2de778}
\hypertarget{classIGbE_a45c9c6a3665bcd91e57ff35aa9089fa7}{
\index{IGbE@{IGbE}!rxFifo@{rxFifo}}
\index{rxFifo@{rxFifo}!IGbE@{IGbE}}
\subsubsection[{rxFifo}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketFifo} {\bf rxFifo}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a45c9c6a3665bcd91e57ff35aa9089fa7}
\hypertarget{classIGbE_a3dd1ff20ea750ba74f718ba7e7c210fe}{
\index{IGbE@{IGbE}!rxTick@{rxTick}}
\index{rxTick@{rxTick}!IGbE@{IGbE}}
\subsubsection[{rxTick}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf rxTick}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a3dd1ff20ea750ba74f718ba7e7c210fe}
\hypertarget{classIGbE_a94231b5b6ec824655f1e33a2481009fb}{
\index{IGbE@{IGbE}!rxWriteDelay@{rxWriteDelay}}
\index{rxWriteDelay@{rxWriteDelay}!IGbE@{IGbE}}
\subsubsection[{rxWriteDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf rxWriteDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a94231b5b6ec824655f1e33a2481009fb}
\hypertarget{classIGbE_a52af2948f0bdbd05624c9f1e90872556}{
\index{IGbE@{IGbE}!tadvEvent@{tadvEvent}}
\index{tadvEvent@{tadvEvent}!IGbE@{IGbE}}
\subsubsection[{tadvEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf IGbE}, \&IGbE::tadvProcess$>$ {\bf tadvEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a52af2948f0bdbd05624c9f1e90872556}
\hypertarget{classIGbE_a13b02e56360d63f349a514edb321bd9c}{
\index{IGbE@{IGbE}!tickEvent@{tickEvent}}
\index{tickEvent@{tickEvent}!IGbE@{IGbE}}
\subsubsection[{tickEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf IGbE}, \&IGbE::tick$>$ {\bf tickEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a13b02e56360d63f349a514edb321bd9c}
\hypertarget{classIGbE_a91fce863693eb4c56a924639620d77cf}{
\index{IGbE@{IGbE}!tidvEvent@{tidvEvent}}
\index{tidvEvent@{tidvEvent}!IGbE@{IGbE}}
\subsubsection[{tidvEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf IGbE}, \&IGbE::tidvProcess$>$ {\bf tidvEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a91fce863693eb4c56a924639620d77cf}
\hypertarget{classIGbE_a8ab7bc15342abe2e4fe9d9bde951441b}{
\index{IGbE@{IGbE}!txDescCache@{txDescCache}}
\index{txDescCache@{txDescCache}!IGbE@{IGbE}}
\subsubsection[{txDescCache}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TxDescCache} {\bf txDescCache}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a8ab7bc15342abe2e4fe9d9bde951441b}
\hypertarget{classIGbE_ae699c324753236e0a59aa2465920eb46}{
\index{IGbE@{IGbE}!txFifo@{txFifo}}
\index{txFifo@{txFifo}!IGbE@{IGbE}}
\subsubsection[{txFifo}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketFifo} {\bf txFifo}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_ae699c324753236e0a59aa2465920eb46}
\hypertarget{classIGbE_a99be71cc5dbbb45b77d1d66d1bedf454}{
\index{IGbE@{IGbE}!txFifoTick@{txFifoTick}}
\index{txFifoTick@{txFifoTick}!IGbE@{IGbE}}
\subsubsection[{txFifoTick}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf txFifoTick}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a99be71cc5dbbb45b77d1d66d1bedf454}
\hypertarget{classIGbE_a8d22e1a154942ff0d4ab9048e7e844bb}{
\index{IGbE@{IGbE}!txPacket@{txPacket}}
\index{txPacket@{txPacket}!IGbE@{IGbE}}
\subsubsection[{txPacket}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EthPacketPtr} {\bf txPacket}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a8d22e1a154942ff0d4ab9048e7e844bb}
\hypertarget{classIGbE_a2e204efac3d8a0a09aef20570520baac}{
\index{IGbE@{IGbE}!txReadDelay@{txReadDelay}}
\index{txReadDelay@{txReadDelay}!IGbE@{IGbE}}
\subsubsection[{txReadDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf txReadDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a2e204efac3d8a0a09aef20570520baac}
\hypertarget{classIGbE_a0f33aec9eb84199e089e1917f7df501d}{
\index{IGbE@{IGbE}!txTick@{txTick}}
\index{txTick@{txTick}!IGbE@{IGbE}}
\subsubsection[{txTick}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf txTick}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a0f33aec9eb84199e089e1917f7df501d}
\hypertarget{classIGbE_ab0f05d6ecbedd2a670abfe34bc8112e1}{
\index{IGbE@{IGbE}!wbCompDelay@{wbCompDelay}}
\index{wbCompDelay@{wbCompDelay}!IGbE@{IGbE}}
\subsubsection[{wbCompDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf wbCompDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_ab0f05d6ecbedd2a670abfe34bc8112e1}
\hypertarget{classIGbE_a899afa4a59ed0cf8334061645dc16c53}{
\index{IGbE@{IGbE}!wbDelay@{wbDelay}}
\index{wbDelay@{wbDelay}!IGbE@{IGbE}}
\subsubsection[{wbDelay}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf wbDelay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classIGbE_a899afa4a59ed0cf8334061645dc16c53}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/\hyperlink{i8254xGBe_8hh}{i8254xGBe.hh}\item 
dev/\hyperlink{i8254xGBe_8cc}{i8254xGBe.cc}\end{DoxyCompactItemize}
