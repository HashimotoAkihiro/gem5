<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>File&nbsp;GEM5&nbsp;Wrapper: クラス AddrRange</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- 作成： Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>メインページ</span></a></li>
      <li><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>構成</span></a></li>
      <li><a href="classes.html"><span>構成索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>構成メンバ</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>クラス AddrRange</h1><!-- doxytag: class="AddrRange" -->
<p><code>#include &lt;<a class="el" href="addr__range_8hh_source.html">addr_range.hh</a>&gt;</code></p>

<p><a href="classAddrRange-members.html">すべてのメンバ一覧</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a44912ab62e2b99d5550e4580da4f0bb6">AddrRange</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a76f19b26f65154f49d9316dbe37dbde6">AddrRange</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a">_start</a>, <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a>, uint8_t _intlv_high_bit, uint8_t _intlv_bits, uint8_t _intlv_match)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#ae9e275cc2d13224e46507e52869d9fa0">AddrRange</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a">_start</a>, <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a3f7bd25bb87bb07a17105ecfe3a41804">AddrRange</a> (const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAddrRange.html">AddrRange</a> &gt; &amp;ranges)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a5d52a3406dc6afea475c78ce06508afa">interleaved</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a2eca79b1c6faa6be9254f65e6e886355">granularity</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a922914e9ba305472e1643f0be3b6ab01">stripes</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#ade0faa4f478bf244b35fb208d640c648">size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a8d985300b138b6c5556ab17ed4df3b38">valid</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a85325674b7aed05d6b4e40a48563189b">start</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#aa48c39f92bc04eded742f5310c74aafe">to_string</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#aa1196b9847a4edf3e67f40a7e4bf63e8">mergesWith</a> (const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;r) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#af078c7e4b8ad8c7f3666ebb2fef613da">intersects</a> (const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;r) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a3d9821127a28a036fbcc96d1ba20b8e2">isSubset</a> (const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;r) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#aa839dbf0ffc0e871a3f08f1d23d78a18">contains</a> (const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> &amp;a) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a9f850195d97cc5f161ba7e5c880facc8">operator&lt;</a> (const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;r) const </td></tr>
<tr><td colspan="2"><h2>Private 変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a">_start</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Private fields for the start and end of the range.  <a href="#a8ae30d144fb49dec55c70ef1274df68a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a4160474d6dec766ee20330ae309e3998">intlvHighBit</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The high bit of the slice that is used for interleaving.  <a href="#a4160474d6dec766ee20330ae309e3998"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a02537b213a36c9f9d57d8c79a0dfb198">intlvBits</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of bits used for interleaving, set to 0 to disable.  <a href="#a02537b213a36c9f9d57d8c79a0dfb198"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrRange.html#a0d9068b55e0d449e9b8ec483536394a9">intlvMatch</a></td></tr>
</table>
<hr/><h2>コンストラクタとデストラクタ</h2>
<a class="anchor" id="a44912ab62e2b99d5550e4580da4f0bb6"></a><!-- doxytag: member="AddrRange::AddrRange" ref="a44912ab62e2b99d5550e4580da4f0bb6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrRange.html">AddrRange</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00077"></a>00077         : <a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a>(1), <a class="code" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a>(0), <a class="code" href="classAddrRange.html#a4160474d6dec766ee20330ae309e3998" title="The high bit of the slice that is used for interleaving.">intlvHighBit</a>(0), <a class="code" href="classAddrRange.html#a02537b213a36c9f9d57d8c79a0dfb198" title="The number of bits used for interleaving, set to 0 to disable.">intlvBits</a>(0), <a class="code" href="classAddrRange.html#a0d9068b55e0d449e9b8ec483536394a9">intlvMatch</a>(0)
<a name="l00078"></a>00078     {}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a76f19b26f65154f49d9316dbe37dbde6"></a><!-- doxytag: member="AddrRange::AddrRange" ref="a76f19b26f65154f49d9316dbe37dbde6" args="(Addr _start, Addr _end, uint8_t _intlv_high_bit, uint8_t _intlv_bits, uint8_t _intlv_match)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrRange.html">AddrRange</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>_intlv_high_bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>_intlv_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>_intlv_match</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00082"></a>00082         : <a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a>(<a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a>), <a class="code" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a>(<a class="code" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a>), <a class="code" href="classAddrRange.html#a4160474d6dec766ee20330ae309e3998" title="The high bit of the slice that is used for interleaving.">intlvHighBit</a>(_intlv_high_bit),
<a name="l00083"></a>00083           <a class="code" href="classAddrRange.html#a02537b213a36c9f9d57d8c79a0dfb198" title="The number of bits used for interleaving, set to 0 to disable.">intlvBits</a>(_intlv_bits), <a class="code" href="classAddrRange.html#a0d9068b55e0d449e9b8ec483536394a9">intlvMatch</a>(_intlv_match)
<a name="l00084"></a>00084     {}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae9e275cc2d13224e46507e52869d9fa0"></a><!-- doxytag: member="AddrRange::AddrRange" ref="ae9e275cc2d13224e46507e52869d9fa0" args="(Addr _start, Addr _end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrRange.html">AddrRange</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>_end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00087"></a>00087         : <a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a>(<a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a>), <a class="code" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a>(<a class="code" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a>), <a class="code" href="classAddrRange.html#a4160474d6dec766ee20330ae309e3998" title="The high bit of the slice that is used for interleaving.">intlvHighBit</a>(0), <a class="code" href="classAddrRange.html#a02537b213a36c9f9d57d8c79a0dfb198" title="The number of bits used for interleaving, set to 0 to disable.">intlvBits</a>(0),
<a name="l00088"></a>00088           <a class="code" href="classAddrRange.html#a0d9068b55e0d449e9b8ec483536394a9">intlvMatch</a>(0)
<a name="l00089"></a>00089     {}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3f7bd25bb87bb07a17105ecfe3a41804"></a><!-- doxytag: member="AddrRange::AddrRange" ref="a3f7bd25bb87bb07a17105ecfe3a41804" args="(const std::vector&lt; AddrRange &gt; &amp;ranges)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrRange.html">AddrRange</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAddrRange.html">AddrRange</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ranges</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an address range by merging a collection of interleaved ranges.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ranges</em>&nbsp;</td><td>Interleaved ranges to be merged </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00098"></a>00098         : <a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a>(1), <a class="code" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a>(0), <a class="code" href="classAddrRange.html#a4160474d6dec766ee20330ae309e3998" title="The high bit of the slice that is used for interleaving.">intlvHighBit</a>(0), <a class="code" href="classAddrRange.html#a02537b213a36c9f9d57d8c79a0dfb198" title="The number of bits used for interleaving, set to 0 to disable.">intlvBits</a>(0), <a class="code" href="classAddrRange.html#a0d9068b55e0d449e9b8ec483536394a9">intlvMatch</a>(0)
<a name="l00099"></a>00099     {
<a name="l00100"></a>00100         <span class="keywordflow">if</span> (!ranges.empty()) {
<a name="l00101"></a>00101             <span class="comment">// get the values from the first one and check the others</span>
<a name="l00102"></a>00102             <a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a> = ranges.front()._start;
<a name="l00103"></a>00103             <a class="code" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a> = ranges.front()._end;
<a name="l00104"></a>00104             <a class="code" href="classAddrRange.html#a4160474d6dec766ee20330ae309e3998" title="The high bit of the slice that is used for interleaving.">intlvHighBit</a> = ranges.front().intlvHighBit;
<a name="l00105"></a>00105             <a class="code" href="classAddrRange.html#a02537b213a36c9f9d57d8c79a0dfb198" title="The number of bits used for interleaving, set to 0 to disable.">intlvBits</a> = ranges.front().intlvBits;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107             <span class="keywordflow">if</span> (ranges.size() != (<a class="code" href="base_2types_8hh.html#adcc3cf526a71c0dfaae020d432c78b83">ULL</a>(1) &lt;&lt; <a class="code" href="classAddrRange.html#a02537b213a36c9f9d57d8c79a0dfb198" title="The number of bits used for interleaving, set to 0 to disable.">intlvBits</a>))
<a name="l00108"></a>00108                 <a class="code" href="base_2misc_8hh.html#acad519418dbfdd70c1208711e609c80e">fatal</a>(<span class="stringliteral">&quot;Got %d ranges spanning %d interleaving bits\n&quot;</span>,
<a name="l00109"></a>00109                       ranges.size(), <a class="code" href="classAddrRange.html#a02537b213a36c9f9d57d8c79a0dfb198" title="The number of bits used for interleaving, set to 0 to disable.">intlvBits</a>);
<a name="l00110"></a>00110 
<a name="l00111"></a>00111             uint8_t match = 0;
<a name="l00112"></a>00112             <span class="keywordflow">for</span> (<a class="code" href="classstd_1_1vector.html">std::vector&lt;AddrRange&gt;::const_iterator</a> <a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a> = ranges.begin();
<a name="l00113"></a>00113                  <a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a> != ranges.end(); ++<a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a>) {
<a name="l00114"></a>00114                 <span class="keywordflow">if</span> (!<a class="code" href="classAddrRange.html#aa1196b9847a4edf3e67f40a7e4bf63e8">mergesWith</a>(*<a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a>))
<a name="l00115"></a>00115                     <a class="code" href="base_2misc_8hh.html#acad519418dbfdd70c1208711e609c80e">fatal</a>(<span class="stringliteral">&quot;Can only merge ranges with the same start, end &quot;</span>
<a name="l00116"></a>00116                           <span class="stringliteral">&quot;and interleaving bits\n&quot;</span>);
<a name="l00117"></a>00117 
<a name="l00118"></a>00118                 <span class="keywordflow">if</span> (<a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a>-&gt;intlvMatch != match)
<a name="l00119"></a>00119                     <a class="code" href="base_2misc_8hh.html#acad519418dbfdd70c1208711e609c80e">fatal</a>(<span class="stringliteral">&quot;Expected interleave match %d but got %d when &quot;</span>
<a name="l00120"></a>00120                           <span class="stringliteral">&quot;merging\n&quot;</span>, match, <a class="code" href="namespaceMipsISA.html#a7de4997f814ef7d6392df74a7a1c5e0d">r</a>-&gt;intlvMatch);
<a name="l00121"></a>00121                 ++match;
<a name="l00122"></a>00122             }
<a name="l00123"></a>00123 
<a name="l00124"></a>00124             <span class="comment">// our range is complete and we can turn this into a</span>
<a name="l00125"></a>00125             <span class="comment">// non-interleaved range</span>
<a name="l00126"></a>00126             <a class="code" href="classAddrRange.html#a4160474d6dec766ee20330ae309e3998" title="The high bit of the slice that is used for interleaving.">intlvHighBit</a> = 0;
<a name="l00127"></a>00127             <a class="code" href="classAddrRange.html#a02537b213a36c9f9d57d8c79a0dfb198" title="The number of bits used for interleaving, set to 0 to disable.">intlvBits</a> = 0;
<a name="l00128"></a>00128         }
<a name="l00129"></a>00129     }
</pre></div></p>

</div>
</div>
<hr/><h2>関数</h2>
<a class="anchor" id="aa839dbf0ffc0e871a3f08f1d23d78a18"></a><!-- doxytag: member="AddrRange::contains" ref="aa839dbf0ffc0e871a3f08f1d23d78a18" args="(const Addr &amp;a) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine if the range contains an address.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td><a class="el" href="classAddress.html">Address</a> to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>true if the address is in the range </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00260"></a>00260     {
<a name="l00261"></a>00261         <span class="comment">// check if the address is in the range and if there is either</span>
<a name="l00262"></a>00262         <span class="comment">// no interleaving, or with interleaving also if the selected</span>
<a name="l00263"></a>00263         <span class="comment">// bits from the address match the interleaving value</span>
<a name="l00264"></a>00264         <span class="keywordflow">return</span> <a class="code" href="namespaceArmISA.html#a468da4d7330577ee8746df2acfa40959">a</a> &gt;= <a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a> &amp;&amp; <a class="code" href="namespaceArmISA.html#a468da4d7330577ee8746df2acfa40959">a</a> &lt;= <a class="code" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a> &amp;&amp;
<a name="l00265"></a>00265             (!<a class="code" href="classAddrRange.html#a5d52a3406dc6afea475c78ce06508afa">interleaved</a>() ||
<a name="l00266"></a>00266              (<a class="code" href="bitfield_8hh.html#a4ee0dc0723e11679c52429d5f8e05123">bits</a>(a, <a class="code" href="classAddrRange.html#a4160474d6dec766ee20330ae309e3998" title="The high bit of the slice that is used for interleaving.">intlvHighBit</a>, <a class="code" href="classAddrRange.html#a4160474d6dec766ee20330ae309e3998" title="The high bit of the slice that is used for interleaving.">intlvHighBit</a> - <a class="code" href="classAddrRange.html#a02537b213a36c9f9d57d8c79a0dfb198" title="The number of bits used for interleaving, set to 0 to disable.">intlvBits</a> + 1) ==
<a name="l00267"></a>00267               <a class="code" href="classAddrRange.html#a0d9068b55e0d449e9b8ec483536394a9">intlvMatch</a>));
<a name="l00268"></a>00268     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2eca79b1c6faa6be9254f65e6e886355"></a><!-- doxytag: member="AddrRange::granularity" ref="a2eca79b1c6faa6be9254f65e6e886355" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t granularity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determing the interleaving granularity of the range.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>The size of the regions created by the interleaving bits </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00144"></a>00144     {
<a name="l00145"></a>00145         <span class="keywordflow">return</span> <a class="code" href="base_2types_8hh.html#adcc3cf526a71c0dfaae020d432c78b83">ULL</a>(1) &lt;&lt; (<a class="code" href="classAddrRange.html#a4160474d6dec766ee20330ae309e3998" title="The high bit of the slice that is used for interleaving.">intlvHighBit</a> - <a class="code" href="classAddrRange.html#a02537b213a36c9f9d57d8c79a0dfb198" title="The number of bits used for interleaving, set to 0 to disable.">intlvBits</a> + 1);
<a name="l00146"></a>00146     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5d52a3406dc6afea475c78ce06508afa"></a><!-- doxytag: member="AddrRange::interleaved" ref="a5d52a3406dc6afea475c78ce06508afa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool interleaved </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine if the range is interleaved or not.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>true if interleaved </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00136"></a>00136 { <span class="keywordflow">return</span> <a class="code" href="classAddrRange.html#a02537b213a36c9f9d57d8c79a0dfb198" title="The number of bits used for interleaving, set to 0 to disable.">intlvBits</a> != 0; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af078c7e4b8ad8c7f3666ebb2fef613da"></a><!-- doxytag: member="AddrRange::intersects" ref="af078c7e4b8ad8c7f3666ebb2fef613da" args="(const AddrRange &amp;r) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine if another range intersects this one, i.e. if there is an address that is both in this range and the other range. No check is made to ensure either range is valid.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>Range to intersect with </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>true if the intersection of the two ranges is not empty </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00215"></a>00215     {
<a name="l00216"></a>00216         <span class="keywordflow">if</span> (!<a class="code" href="classAddrRange.html#a5d52a3406dc6afea475c78ce06508afa">interleaved</a>()) {
<a name="l00217"></a>00217             <span class="keywordflow">return</span> <a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a> &lt;= r.<a class="code" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a> &amp;&amp; <a class="code" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a> &gt;= r.<a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a>;
<a name="l00218"></a>00218         }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220         <span class="comment">// the current range is interleaved, split the check up in</span>
<a name="l00221"></a>00221         <span class="comment">// three cases</span>
<a name="l00222"></a>00222         <span class="keywordflow">if</span> (r.<a class="code" href="classAddrRange.html#ade0faa4f478bf244b35fb208d640c648">size</a>() == 1)
<a name="l00223"></a>00223             <span class="comment">// keep it simple and check if the address is within</span>
<a name="l00224"></a>00224             <span class="comment">// this range</span>
<a name="l00225"></a>00225             <span class="keywordflow">return</span> <a class="code" href="classAddrRange.html#aa839dbf0ffc0e871a3f08f1d23d78a18">contains</a>(r.<a class="code" href="classAddrRange.html#a85325674b7aed05d6b4e40a48563189b">start</a>());
<a name="l00226"></a>00226         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!r.<a class="code" href="classAddrRange.html#a5d52a3406dc6afea475c78ce06508afa">interleaved</a>())
<a name="l00227"></a>00227             <span class="comment">// be conservative and ignore the interleaving</span>
<a name="l00228"></a>00228             <span class="keywordflow">return</span> _start &lt;= r._end &amp;&amp; _end &gt;= r.<a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a>;
<a name="l00229"></a>00229         <span class="keywordflow">else</span> if (<a class="code" href="classAddrRange.html#aa1196b9847a4edf3e67f40a7e4bf63e8">mergesWith</a>(r))
<a name="l00230"></a>00230             <span class="comment">// restrict the check to ranges that belong to the</span>
<a name="l00231"></a>00231             <span class="comment">// same chunk</span>
<a name="l00232"></a>00232             <span class="keywordflow">return</span> <a class="code" href="classAddrRange.html#a0d9068b55e0d449e9b8ec483536394a9">intlvMatch</a> == r.<a class="code" href="classAddrRange.html#a0d9068b55e0d449e9b8ec483536394a9">intlvMatch</a>;
<a name="l00233"></a>00233         <span class="keywordflow">else</span>
<a name="l00234"></a>00234             <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;Cannot test intersection of interleaved range %s\n&quot;</span>,
<a name="l00235"></a>00235                   <a class="code" href="classAddrRange.html#aa48c39f92bc04eded742f5310c74aafe">to_string</a>());
<a name="l00236"></a>00236     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3d9821127a28a036fbcc96d1ba20b8e2"></a><!-- doxytag: member="AddrRange::isSubset" ref="a3d9821127a28a036fbcc96d1ba20b8e2" args="(const AddrRange &amp;r) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isSubset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine if this range is a subset of another range, i.e. if every address in this range is also in the other range. No check is made to ensure either range is valid.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>Range to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>true if the this range is a subset of the other one </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00247"></a>00247     {
<a name="l00248"></a>00248         <span class="keywordflow">if</span> (<a class="code" href="classAddrRange.html#a5d52a3406dc6afea475c78ce06508afa">interleaved</a>())
<a name="l00249"></a>00249             <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;Cannot test subset of interleaved range %s\n&quot;</span>, <a class="code" href="classAddrRange.html#aa48c39f92bc04eded742f5310c74aafe">to_string</a>());
<a name="l00250"></a>00250         <span class="keywordflow">return</span> <a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a> &gt;= r.<a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a> &amp;&amp; <a class="code" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a> &lt;= r.<a class="code" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a>;
<a name="l00251"></a>00251     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa1196b9847a4edf3e67f40a7e4bf63e8"></a><!-- doxytag: member="AddrRange::mergesWith" ref="aa1196b9847a4edf3e67f40a7e4bf63e8" args="(const AddrRange &amp;r) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mergesWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine if another range merges with the current one, i.e. if they are part of the same contigous range and have the same interleaving bits.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>Range to evaluate merging with </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>true if the two ranges would merge </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00200"></a>00200     {
<a name="l00201"></a>00201         <span class="keywordflow">return</span> r.<a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a> == <a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a> &amp;&amp; r.<a class="code" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a> == <a class="code" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a> &amp;&amp;
<a name="l00202"></a>00202             r.<a class="code" href="classAddrRange.html#a4160474d6dec766ee20330ae309e3998" title="The high bit of the slice that is used for interleaving.">intlvHighBit</a> == <a class="code" href="classAddrRange.html#a4160474d6dec766ee20330ae309e3998" title="The high bit of the slice that is used for interleaving.">intlvHighBit</a> &amp;&amp;
<a name="l00203"></a>00203             r.<a class="code" href="classAddrRange.html#a02537b213a36c9f9d57d8c79a0dfb198" title="The number of bits used for interleaving, set to 0 to disable.">intlvBits</a> == <a class="code" href="classAddrRange.html#a02537b213a36c9f9d57d8c79a0dfb198" title="The number of bits used for interleaving, set to 0 to disable.">intlvBits</a>;
<a name="l00204"></a>00204     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9f850195d97cc5f161ba7e5c880facc8"></a><!-- doxytag: member="AddrRange::operator&lt;" ref="a9f850195d97cc5f161ba7e5c880facc8" args="(const AddrRange &amp;r) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddrRange.html">AddrRange</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Keep the operators away from SWIG. Less-than operator used to turn an STL map into a binary search tree of non-overlapping address ranges.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>Range to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>true if the start address is less than that of the other range </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00283"></a>00283     {
<a name="l00284"></a>00284         <span class="keywordflow">if</span> (<a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a> != r.<a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a>)
<a name="l00285"></a>00285             <span class="keywordflow">return</span> <a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a> &lt; r.<a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a>;
<a name="l00286"></a>00286         <span class="keywordflow">else</span>
<a name="l00287"></a>00287             <span class="comment">// for now assume that the end is also the same, and that</span>
<a name="l00288"></a>00288             <span class="comment">// we are looking at the same interleaving bits</span>
<a name="l00289"></a>00289             <span class="keywordflow">return</span> <a class="code" href="classAddrRange.html#a0d9068b55e0d449e9b8ec483536394a9">intlvMatch</a> &lt; r.<a class="code" href="classAddrRange.html#a0d9068b55e0d449e9b8ec483536394a9">intlvMatch</a>;
<a name="l00290"></a>00290     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ade0faa4f478bf244b35fb208d640c648"></a><!-- doxytag: member="AddrRange::size" ref="ade0faa4f478bf244b35fb208d640c648" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the size of the address range. For a case where interleaving is used we make the simplifying assumption that the size is a divisible by the size of the interleaving slice. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00162"></a>00162     {
<a name="l00163"></a>00163         <span class="keywordflow">return</span> (<a class="code" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a> - <a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a> + 1) &gt;&gt; <a class="code" href="classAddrRange.html#a02537b213a36c9f9d57d8c79a0dfb198" title="The number of bits used for interleaving, set to 0 to disable.">intlvBits</a>;
<a name="l00164"></a>00164     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a85325674b7aed05d6b4e40a48563189b"></a><!-- doxytag: member="AddrRange::start" ref="a85325674b7aed05d6b4e40a48563189b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> start </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the start address of the range. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00174"></a>00174 { <span class="keywordflow">return</span> <a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a922914e9ba305472e1643f0be3b6ab01"></a><!-- doxytag: member="AddrRange::stripes" ref="a922914e9ba305472e1643f0be3b6ab01" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Type_8hh.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> stripes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine the number of interleaved address stripes this range is part of.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>The number of stripes spanned by the interleaving bits </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00154"></a>00154 { <span class="keywordflow">return</span> <a class="code" href="base_2types_8hh.html#adcc3cf526a71c0dfaae020d432c78b83">ULL</a>(1) &lt;&lt; <a class="code" href="classAddrRange.html#a02537b213a36c9f9d57d8c79a0dfb198" title="The number of bits used for interleaving, set to 0 to disable.">intlvBits</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa48c39f92bc04eded742f5310c74aafe"></a><!-- doxytag: member="AddrRange::to_string" ref="aa48c39f92bc04eded742f5310c74aafe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a string representation of the range. This could alternatively be implemented as a operator&lt;&lt;, but at the moment that seems like overkill. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00182"></a>00182     {
<a name="l00183"></a>00183         <span class="keywordflow">if</span> (<a class="code" href="classAddrRange.html#a5d52a3406dc6afea475c78ce06508afa">interleaved</a>())
<a name="l00184"></a>00184             <span class="keywordflow">return</span> <a class="code" href="cprintf_8hh.html#ace22d1c39f2df58e593bc49d1613eca2">csprintf</a>(<span class="stringliteral">&quot;[%#llx : %#llx], [%d : %d] = %d&quot;</span>, <a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a>, <a class="code" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a>,
<a name="l00185"></a>00185                             <a class="code" href="classAddrRange.html#a4160474d6dec766ee20330ae309e3998" title="The high bit of the slice that is used for interleaving.">intlvHighBit</a>, <a class="code" href="classAddrRange.html#a4160474d6dec766ee20330ae309e3998" title="The high bit of the slice that is used for interleaving.">intlvHighBit</a> - <a class="code" href="classAddrRange.html#a02537b213a36c9f9d57d8c79a0dfb198" title="The number of bits used for interleaving, set to 0 to disable.">intlvBits</a> + 1,
<a name="l00186"></a>00186                             <a class="code" href="classAddrRange.html#a0d9068b55e0d449e9b8ec483536394a9">intlvMatch</a>);
<a name="l00187"></a>00187         <span class="keywordflow">else</span>
<a name="l00188"></a>00188             <span class="keywordflow">return</span> <a class="code" href="cprintf_8hh.html#ace22d1c39f2df58e593bc49d1613eca2">csprintf</a>(<span class="stringliteral">&quot;[%#llx : %#llx]&quot;</span>, <a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a>, <a class="code" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a>);
<a name="l00189"></a>00189     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8d985300b138b6c5556ab17ed4df3b38"></a><!-- doxytag: member="AddrRange::valid" ref="a8d985300b138b6c5556ab17ed4df3b38" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool valid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine if the range is valid. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00169"></a>00169 { <span class="keywordflow">return</span> <a class="code" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a" title="Private fields for the start and end of the range.">_start</a> &lt; <a class="code" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a>; }
</pre></div></p>

</div>
</div>
<hr/><h2>変数</h2>
<a class="anchor" id="a945d5a5b811e52aaf2aa2ca0b1aff5c5"></a><!-- doxytag: member="AddrRange::_end" ref="a945d5a5b811e52aaf2aa2ca0b1aff5c5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="classAddrRange.html#a945d5a5b811e52aaf2aa2ca0b1aff5c5">_end</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8ae30d144fb49dec55c70ef1274df68a"></a><!-- doxytag: member="AddrRange::_start" ref="a8ae30d144fb49dec55c70ef1274df68a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="classAddrRange.html#a8ae30d144fb49dec55c70ef1274df68a">_start</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Private fields for the start and end of the range. </p>

</div>
</div>
<a class="anchor" id="a02537b213a36c9f9d57d8c79a0dfb198"></a><!-- doxytag: member="AddrRange::intlvBits" ref="a02537b213a36c9f9d57d8c79a0dfb198" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="classAddrRange.html#a02537b213a36c9f9d57d8c79a0dfb198">intlvBits</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of bits used for interleaving, set to 0 to disable. </p>

</div>
</div>
<a class="anchor" id="a4160474d6dec766ee20330ae309e3998"></a><!-- doxytag: member="AddrRange::intlvHighBit" ref="a4160474d6dec766ee20330ae309e3998" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="classAddrRange.html#a4160474d6dec766ee20330ae309e3998">intlvHighBit</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The high bit of the slice that is used for interleaving. </p>

</div>
</div>
<a class="anchor" id="a0d9068b55e0d449e9b8ec483536394a9"></a><!-- doxytag: member="AddrRange::intlvMatch" ref="a0d9068b55e0d449e9b8ec483536394a9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="classAddrRange.html#a0d9068b55e0d449e9b8ec483536394a9">intlvMatch</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The value to compare the slice addr[high:(high - bits + 1)] with. </p>

</div>
</div>
<hr/>このクラスの説明は次のファイルから生成されました:<ul>
<li>base/<a class="el" href="addr__range_8hh_source.html">addr_range.hh</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>File&nbsp;GEM5&nbsp;Wrapperに対して25 May 2015に生成されました。&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
