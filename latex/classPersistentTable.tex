\hypertarget{classPersistentTable}{
\section{クラス PersistentTable}
\label{classPersistentTable}\index{PersistentTable@{PersistentTable}}
}


{\ttfamily \#include $<$PersistentTable.hh$>$}\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classPersistentTable_a510294388f7eff2158e00342afd3e945}{PersistentTable} ()
\item 
\hyperlink{classPersistentTable_a628f212bbb694c12cbdde6854bd8c03b}{$\sim$PersistentTable} ()
\item 
void \hyperlink{classPersistentTable_a628d4613da4e9d953077a69cb0c67e43}{persistentRequestLock} (const \hyperlink{classAddress}{Address} \&address, \hyperlink{structMachineID}{MachineID} locker, AccessType type)
\item 
void \hyperlink{classPersistentTable_a9b62725c7279882365ff19efb985b035}{persistentRequestUnlock} (const \hyperlink{classAddress}{Address} \&address, \hyperlink{structMachineID}{MachineID} unlocker)
\item 
bool \hyperlink{classPersistentTable_a0de642e5242f4db892cdd20a693fc7e1}{okToIssueStarving} (const \hyperlink{classAddress}{Address} \&address, \hyperlink{structMachineID}{MachineID} machID) const 
\item 
\hyperlink{structMachineID}{MachineID} \hyperlink{classPersistentTable_a2a83d43cb75685cce8e2beb456e71375}{findSmallest} (const \hyperlink{classAddress}{Address} \&address) const 
\item 
AccessType \hyperlink{classPersistentTable_ad8b7797f65c290ccfb5963c3770a03b3}{typeOfSmallest} (const \hyperlink{classAddress}{Address} \&address) const 
\item 
void \hyperlink{classPersistentTable_ae534be554d865e61002a832e0fdc2684}{markEntries} (const \hyperlink{classAddress}{Address} \&address)
\item 
bool \hyperlink{classPersistentTable_a1fdc9104426b06c2dda1a9bef5f7ec58}{isLocked} (const \hyperlink{classAddress}{Address} \&addr) const 
\item 
int \hyperlink{classPersistentTable_ac7209c5a747491d956abe358ea30b987}{countStarvingForAddress} (const \hyperlink{classAddress}{Address} \&addr) const 
\item 
int \hyperlink{classPersistentTable_ac80b0e6c384f94d8e1c64cfe0d4fc4ad}{countReadStarvingForAddress} (const \hyperlink{classAddress}{Address} \&addr) const 
\item 
void \hyperlink{classPersistentTable_ac55fe386a101fbae38c716067c9966a0}{print} (std::ostream \&out) const 
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef m5::hash\_\-map$<$ \hyperlink{classAddress}{Address}, \hyperlink{classPersistentTableEntry}{PersistentTableEntry} $>$ \hyperlink{classPersistentTable_a4d7d821cf1f494582d40290d825c64aa}{AddressMap}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classPersistentTable_a0e21d362ba71e7ff415d1e7bdee72db4}{PersistentTable} (const \hyperlink{classPersistentTable}{PersistentTable} \&obj)
\item 
\hyperlink{classPersistentTable}{PersistentTable} \& \hyperlink{classPersistentTable_af4ed77850998cfdc187ce72c12864dfe}{operator=} (const \hyperlink{classPersistentTable}{PersistentTable} \&obj)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classPersistentTable_a4d7d821cf1f494582d40290d825c64aa}{AddressMap} \hyperlink{classPersistentTable_a81aeb6fef4ddb55c4abc1662d977def1}{m\_\-map}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classPersistentTable_a4d7d821cf1f494582d40290d825c64aa}{
\index{PersistentTable@{PersistentTable}!AddressMap@{AddressMap}}
\index{AddressMap@{AddressMap}!PersistentTable@{PersistentTable}}
\subsubsection[{AddressMap}]{\setlength{\rightskip}{0pt plus 5cm}typedef m5::hash\_\-map$<${\bf Address}, {\bf PersistentTableEntry}$>$ {\bf AddressMap}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPersistentTable_a4d7d821cf1f494582d40290d825c64aa}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classPersistentTable_a510294388f7eff2158e00342afd3e945}{
\index{PersistentTable@{PersistentTable}!PersistentTable@{PersistentTable}}
\index{PersistentTable@{PersistentTable}!PersistentTable@{PersistentTable}}
\subsubsection[{PersistentTable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PersistentTable} ()}}
\label{classPersistentTable_a510294388f7eff2158e00342afd3e945}



\begin{DoxyCode}
42 {
43 }
\end{DoxyCode}
\hypertarget{classPersistentTable_a628f212bbb694c12cbdde6854bd8c03b}{
\index{PersistentTable@{PersistentTable}!$\sim$PersistentTable@{$\sim$PersistentTable}}
\index{$\sim$PersistentTable@{$\sim$PersistentTable}!PersistentTable@{PersistentTable}}
\subsubsection[{$\sim$PersistentTable}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf PersistentTable} ()}}
\label{classPersistentTable_a628f212bbb694c12cbdde6854bd8c03b}



\begin{DoxyCode}
46 {
47 }
\end{DoxyCode}
\hypertarget{classPersistentTable_a0e21d362ba71e7ff415d1e7bdee72db4}{
\index{PersistentTable@{PersistentTable}!PersistentTable@{PersistentTable}}
\index{PersistentTable@{PersistentTable}!PersistentTable@{PersistentTable}}
\subsubsection[{PersistentTable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PersistentTable} (const {\bf PersistentTable} \& {\em obj})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPersistentTable_a0e21d362ba71e7ff415d1e7bdee72db4}


\subsection{関数}
\hypertarget{classPersistentTable_ac80b0e6c384f94d8e1c64cfe0d4fc4ad}{
\index{PersistentTable@{PersistentTable}!countReadStarvingForAddress@{countReadStarvingForAddress}}
\index{countReadStarvingForAddress@{countReadStarvingForAddress}!PersistentTable@{PersistentTable}}
\subsubsection[{countReadStarvingForAddress}]{\setlength{\rightskip}{0pt plus 5cm}int countReadStarvingForAddress (const {\bf Address} \& {\em addr}) const}}
\label{classPersistentTable_ac80b0e6c384f94d8e1c64cfe0d4fc4ad}



\begin{DoxyCode}
205 {
206     assert(address == line_address(address));
207     AddressMap::const_iterator i = m_map.find(address);
208     if (i == m_map.end())
209         return 0;
210 
211     const PersistentTableEntry& entry = i->second;
212     return entry.m_starving.count() - entry.m_request_to_write.count();
213 }
\end{DoxyCode}
\hypertarget{classPersistentTable_ac7209c5a747491d956abe358ea30b987}{
\index{PersistentTable@{PersistentTable}!countStarvingForAddress@{countStarvingForAddress}}
\index{countStarvingForAddress@{countStarvingForAddress}!PersistentTable@{PersistentTable}}
\subsubsection[{countStarvingForAddress}]{\setlength{\rightskip}{0pt plus 5cm}int countStarvingForAddress (const {\bf Address} \& {\em addr}) const}}
\label{classPersistentTable_ac7209c5a747491d956abe358ea30b987}



\begin{DoxyCode}
193 {
194     assert(address == line_address(address));
195     AddressMap::const_iterator i = m_map.find(address);
196     if (i == m_map.end())
197         return 0;
198 
199     const PersistentTableEntry& entry = i->second;
200     return entry.m_starving.count();
201 }
\end{DoxyCode}
\hypertarget{classPersistentTable_a2a83d43cb75685cce8e2beb456e71375}{
\index{PersistentTable@{PersistentTable}!findSmallest@{findSmallest}}
\index{findSmallest@{findSmallest}!PersistentTable@{PersistentTable}}
\subsubsection[{findSmallest}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MachineID} findSmallest (const {\bf Address} \& {\em address}) const}}
\label{classPersistentTable_a2a83d43cb75685cce8e2beb456e71375}



\begin{DoxyCode}
142 {
143     assert(address == line_address(address));
144     AddressMap::const_iterator i = m_map.find(address);
145     assert(i != m_map.end());
146     const PersistentTableEntry& entry = i->second;
147     return entry.m_starving.smallestElement();
148 }
\end{DoxyCode}
\hypertarget{classPersistentTable_a1fdc9104426b06c2dda1a9bef5f7ec58}{
\index{PersistentTable@{PersistentTable}!isLocked@{isLocked}}
\index{isLocked@{isLocked}!PersistentTable@{PersistentTable}}
\subsubsection[{isLocked}]{\setlength{\rightskip}{0pt plus 5cm}bool isLocked (const {\bf Address} \& {\em addr}) const}}
\label{classPersistentTable_a1fdc9104426b06c2dda1a9bef5f7ec58}



\begin{DoxyCode}
184 {
185     assert(address == line_address(address));
186 
187     // If an entry is present, it must be locked
188     return m_map.count(address) > 0;
189 }
\end{DoxyCode}
\hypertarget{classPersistentTable_ae534be554d865e61002a832e0fdc2684}{
\index{PersistentTable@{PersistentTable}!markEntries@{markEntries}}
\index{markEntries@{markEntries}!PersistentTable@{PersistentTable}}
\subsubsection[{markEntries}]{\setlength{\rightskip}{0pt plus 5cm}void markEntries (const {\bf Address} \& {\em address})}}
\label{classPersistentTable_ae534be554d865e61002a832e0fdc2684}



\begin{DoxyCode}
167 {
168     assert(address == line_address(address));
169     AddressMap::iterator i = m_map.find(address);
170     if (i == m_map.end())
171         return;
172 
173     PersistentTableEntry& entry = i->second;
174 
175     // None should be marked
176     assert(entry.m_marked.isEmpty());
177 
178     // Mark all the nodes currently in the table
179     entry.m_marked = entry.m_starving;
180 }
\end{DoxyCode}
\hypertarget{classPersistentTable_a0de642e5242f4db892cdd20a693fc7e1}{
\index{PersistentTable@{PersistentTable}!okToIssueStarving@{okToIssueStarving}}
\index{okToIssueStarving@{okToIssueStarving}!PersistentTable@{PersistentTable}}
\subsubsection[{okToIssueStarving}]{\setlength{\rightskip}{0pt plus 5cm}bool okToIssueStarving (const {\bf Address} \& {\em address}, \/  {\bf MachineID} {\em machID}) const}}
\label{classPersistentTable_a0de642e5242f4db892cdd20a693fc7e1}



\begin{DoxyCode}
120 {
121     assert(address == line_address(address));
122 
123     AddressMap::const_iterator i = m_map.find(address);
124     if (i == m_map.end()) {
125         // No entry present
126         return true;
127     }
128 
129     const PersistentTableEntry &entry = i->second;
130 
131     if (entry.m_starving.isElement(machId)) {
132         // We can't issue another lockdown until are previous unlock
133         // has occurred
134         return false;
135     }
136 
137     return entry.m_marked.isEmpty();
138 }
\end{DoxyCode}
\hypertarget{classPersistentTable_af4ed77850998cfdc187ce72c12864dfe}{
\index{PersistentTable@{PersistentTable}!operator=@{operator=}}
\index{operator=@{operator=}!PersistentTable@{PersistentTable}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PersistentTable}\& operator= (const {\bf PersistentTable} \& {\em obj})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPersistentTable_af4ed77850998cfdc187ce72c12864dfe}
\hypertarget{classPersistentTable_a628d4613da4e9d953077a69cb0c67e43}{
\index{PersistentTable@{PersistentTable}!persistentRequestLock@{persistentRequestLock}}
\index{persistentRequestLock@{persistentRequestLock}!PersistentTable@{PersistentTable}}
\subsubsection[{persistentRequestLock}]{\setlength{\rightskip}{0pt plus 5cm}void persistentRequestLock (const {\bf Address} \& {\em address}, \/  {\bf MachineID} {\em locker}, \/  AccessType {\em type})}}
\label{classPersistentTable_a628d4613da4e9d953077a69cb0c67e43}



\begin{DoxyCode}
53 {
54 #if 0
55     if (locker == m_chip_ptr->getID())
56         cout << "Chip " << m_chip_ptr->getID() << ": " << llocker
57              << " requesting lock for " << address << endl;
58 
59     MachineID locker = (MachineID) persistent_randomize[llocker];
60 #endif
61 
62     assert(address == line_address(address));
63 
64     static const PersistentTableEntry dflt;
65     pair<AddressMap::iterator, bool> r =
66         m_map.insert(AddressMap::value_type(address, dflt));
67     bool present = !r.second;
68     AddressMap::iterator i = r.first;
69     PersistentTableEntry &entry = i->second;
70 
71     if (present) {
72         // Make sure we're not already in the locked set
73         assert(!(entry.m_starving.isElement(locker)));
74     }
75 
76     entry.m_starving.add(locker);
77     if (type == AccessType_Write)
78         entry.m_request_to_write.add(locker);
79 
80     if (present)
81         assert(entry.m_marked.isSubset(entry.m_starving));
82 }
\end{DoxyCode}
\hypertarget{classPersistentTable_a9b62725c7279882365ff19efb985b035}{
\index{PersistentTable@{PersistentTable}!persistentRequestUnlock@{persistentRequestUnlock}}
\index{persistentRequestUnlock@{persistentRequestUnlock}!PersistentTable@{PersistentTable}}
\subsubsection[{persistentRequestUnlock}]{\setlength{\rightskip}{0pt plus 5cm}void persistentRequestUnlock (const {\bf Address} \& {\em address}, \/  {\bf MachineID} {\em unlocker})}}
\label{classPersistentTable_a9b62725c7279882365ff19efb985b035}



\begin{DoxyCode}
87 {
88 #if 0
89     if (unlocker == m_chip_ptr->getID())
90         cout << "Chip " << m_chip_ptr->getID() << ": " << uunlocker
91              << " requesting unlock for " << address << endl;
92 
93     MachineID unlocker = (MachineID) persistent_randomize[uunlocker];
94 #endif
95 
96     assert(address == line_address(address));
97     assert(m_map.count(address));
98     PersistentTableEntry& entry = m_map[address];
99 
100     //
101     // Make sure we're in the locked set
102     //
103     assert(entry.m_starving.isElement(unlocker));
104     assert(entry.m_marked.isSubset(entry.m_starving));
105     entry.m_starving.remove(unlocker);
106     entry.m_marked.remove(unlocker);
107     entry.m_request_to_write.remove(unlocker);
108     assert(entry.m_marked.isSubset(entry.m_starving));
109 
110     // Deallocate if empty
111     if (entry.m_starving.isEmpty()) {
112         assert(entry.m_marked.isEmpty());
113         m_map.erase(address);
114     }
115 }
\end{DoxyCode}
\hypertarget{classPersistentTable_ac55fe386a101fbae38c716067c9966a0}{
\index{PersistentTable@{PersistentTable}!print@{print}}
\index{print@{print}!PersistentTable@{PersistentTable}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}void print (std::ostream \& {\em out}) const}}
\label{classPersistentTable_ac55fe386a101fbae38c716067c9966a0}
\hypertarget{classPersistentTable_ad8b7797f65c290ccfb5963c3770a03b3}{
\index{PersistentTable@{PersistentTable}!typeOfSmallest@{typeOfSmallest}}
\index{typeOfSmallest@{typeOfSmallest}!PersistentTable@{PersistentTable}}
\subsubsection[{typeOfSmallest}]{\setlength{\rightskip}{0pt plus 5cm}AccessType typeOfSmallest (const {\bf Address} \& {\em address}) const}}
\label{classPersistentTable_ad8b7797f65c290ccfb5963c3770a03b3}



\begin{DoxyCode}
152 {
153     assert(address == line_address(address));
154     AddressMap::const_iterator i = m_map.find(address);
155     assert(i != m_map.end());
156     const PersistentTableEntry& entry = i->second;
157     if (entry.m_request_to_write.
158         isElement(entry.m_starving.smallestElement())) {
159         return AccessType_Write;
160     } else {
161         return AccessType_Read;
162     }
163 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classPersistentTable_a81aeb6fef4ddb55c4abc1662d977def1}{
\index{PersistentTable@{PersistentTable}!m\_\-map@{m\_\-map}}
\index{m\_\-map@{m\_\-map}!PersistentTable@{PersistentTable}}
\subsubsection[{m\_\-map}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddressMap} {\bf m\_\-map}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classPersistentTable_a81aeb6fef4ddb55c4abc1662d977def1}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/ruby/system/\hyperlink{PersistentTable_8hh}{PersistentTable.hh}\item 
mem/ruby/system/\hyperlink{PersistentTable_8cc}{PersistentTable.cc}\end{DoxyCompactItemize}
