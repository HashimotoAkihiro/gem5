<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>File&nbsp;GEM5&nbsp;Wrapper: クラス SimpleMemory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- 作成： Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>メインページ</span></a></li>
      <li><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>構成</span></a></li>
      <li><a href="classes.html"><span>構成索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>構成メンバ</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>クラス SimpleMemory</h1><!-- doxytag: class="SimpleMemory" --><!-- doxytag: inherits="AbstractMemory" -->
<p><code>#include &lt;<a class="el" href="simple__mem_8hh_source.html">simple_mem.hh</a>&gt;</code></p>
<div class="dynheader">
SimpleMemoryに対する継承グラフ</div>
<div class="dynsection">
 <div class="center">
  <img src="classSimpleMemory.gif" usemap="#SimpleMemory_map" alt=""/>
  <map id="SimpleMemory_map" name="SimpleMemory_map">
<area href="classAbstractMemory.html" alt="AbstractMemory" shape="rect" coords="115,224,220,248"/>
<area href="classMemObject.html" alt="MemObject" shape="rect" coords="115,168,220,192"/>
<area href="classClockedObject.html" alt="ClockedObject" shape="rect" coords="115,112,220,136"/>
<area href="classSimObject.html" alt="SimObject" shape="rect" coords="115,56,220,80"/>
<area href="classEventManager.html" alt="EventManager" shape="rect" coords="0,0,105,24"/>
<area href="classSerializable.html" alt="Serializable" shape="rect" coords="115,0,220,24"/>
<area href="classDrainable.html" alt="Drainable" shape="rect" coords="230,0,335,24"/>
</map>
 </div>
</div>

<p><a href="classSimpleMemory-members.html">すべてのメンバ一覧</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>構成</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory_1_1DeferredPacket.html">DeferredPacket</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory_1_1MemoryPort.html">MemoryPort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory_1_1SimpleMemory.html">SimpleMemory</a></td></tr>
<tr><td colspan="2"><h2>Public メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#afc0d41f7c9b61cc5161f7f4b10a1b942">SimpleMemory</a> (const SimpleMemoryParams *p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#aa8a18d230dba7a674ac8a0b4f35bc36a">drain</a> (<a class="el" href="classDrainManager.html">DrainManager</a> *dm)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBaseSlavePort.html">BaseSlavePort</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#ac918a145092d7514ebc6dbd952dceafb">getSlavePort</a> (const std::string &amp;if_name, <a class="el" href="base_2types_8hh.html#acef4d7d41cb21fdc252e20c04cd7bb8e">PortID</a> idx=<a class="el" href="base_2types_8hh.html#a65bf40f138cf863f0c5e2d8ca1144126">InvalidPortID</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a> ()</td></tr>
<tr><td colspan="2"><h2>Protected メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#a5f0b4c4a94f6b0053f9d7a4eb9c2518a">recvAtomic</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#aeefa907fb6d6a787e6dab90e8138ea90">recvFunctional</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#a3344d9dd0f83257feab5424e761f31c6">recvTimingReq</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#a29cb5a4f98063ce6e9210eacbdb35298">recvRetry</a> ()</td></tr>
<tr><td colspan="2"><h2>Private メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#a23b477d0e2d399f75d585d154c346591">release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#a851b6644e3e336c07f8e6fe77234b97f">dequeue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#aab331854844f48e55c064a1d20d74361">getLatency</a> () const </td></tr>
<tr><td colspan="2"><h2>Private 変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimpleMemory_1_1MemoryPort.html">MemoryPort</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#a55c076720c982014096b57cadebf9a14">port</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#a8291bf96dadb3695aea55321d10c0e77">latency</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#aa983b5b77f758b06806499ada4568803">latency_var</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt; <a class="el" href="classSimpleMemory_1_1DeferredPacket.html">DeferredPacket</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#ae20fc3a6f9b02bebe5a9bff0c939c1f5">packetQueue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#a18386495a208eab463cafbccfc28d5f4">bandwidth</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#a099f725f22a344e190121634f53328d8">isBusy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#aab3b947b2633a30b5973a39b7e9b018a">retryReq</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#a6ddfdd4eb676d50001bda88567e6da14">retryResp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEventWrapper.html">EventWrapper</a>&lt; <a class="el" href="classSimpleMemory_1_1SimpleMemory.html">SimpleMemory</a>,&amp;SimpleMemory::release &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#a152504c9de53c1ab4c16f4dceaa6bbfa">releaseEvent</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEventWrapper.html">EventWrapper</a>&lt; <a class="el" href="classSimpleMemory_1_1SimpleMemory.html">SimpleMemory</a>,&amp;SimpleMemory::dequeue &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#a8c2927c28d324098f4c7bb9b4d96bca1">dequeueEvent</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classPacket.html">PacketPtr</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#a21da4bea3554874b557428e4cce5d4a4">pendingDelete</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDrainManager.html">DrainManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleMemory.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>説明</h2>
<p>The simple memory is a basic single-ported memory controller with a configurable throughput and latency.</p>
<dl class="see"><dt><b>参照:</b></dt><dd>gem5 Memory System </dd></dl>
<hr/><h2>コンストラクタとデストラクタ</h2>
<a class="anchor" id="afc0d41f7c9b61cc5161f7f4b10a1b942"></a><!-- doxytag: member="SimpleMemory::SimpleMemory" ref="afc0d41f7c9b61cc5161f7f4b10a1b942" args="(const SimpleMemoryParams *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleMemory_1_1SimpleMemory.html">SimpleMemory</a> </td>
          <td>(</td>
          <td class="paramtype">const SimpleMemoryParams *&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00050"></a>00050                                                       :
<a name="l00051"></a>00051     <a class="code" href="classAbstractMemory.html#abe7c4ad03729f9b3dd25d3dc43361103">AbstractMemory</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>),
<a name="l00052"></a>00052     <a class="code" href="classSimpleMemory.html#a55c076720c982014096b57cadebf9a14">port</a>(<a class="code" href="classSimObject.html#adbcff144e5e199d332a1352af1798148">name</a>() + <span class="stringliteral">&quot;.port&quot;</span>, *<span class="keyword">this</span>), <a class="code" href="classSimpleMemory.html#a8291bf96dadb3695aea55321d10c0e77">latency</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;latency),
<a name="l00053"></a>00053     <a class="code" href="classSimpleMemory.html#aa983b5b77f758b06806499ada4568803">latency_var</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;latency_var), <a class="code" href="classSimpleMemory.html#a18386495a208eab463cafbccfc28d5f4">bandwidth</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;bandwidth), <a class="code" href="classSimpleMemory.html#a099f725f22a344e190121634f53328d8">isBusy</a>(<span class="keyword">false</span>),
<a name="l00054"></a>00054     <a class="code" href="classSimpleMemory.html#aab3b947b2633a30b5973a39b7e9b018a">retryReq</a>(<span class="keyword">false</span>), <a class="code" href="classSimpleMemory.html#a6ddfdd4eb676d50001bda88567e6da14">retryResp</a>(<span class="keyword">false</span>),
<a name="l00055"></a>00055     <a class="code" href="classSimpleMemory.html#a152504c9de53c1ab4c16f4dceaa6bbfa">releaseEvent</a>(<span class="keyword">this</span>), <a class="code" href="classSimpleMemory.html#a8c2927c28d324098f4c7bb9b4d96bca1">dequeueEvent</a>(<span class="keyword">this</span>), <a class="code" href="classSimpleMemory.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a>(<a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>)
<a name="l00056"></a>00056 {
<a name="l00057"></a>00057 }

</pre></div></p>

</div>
</div>
<hr/><h2>関数</h2>
<a class="anchor" id="a851b6644e3e336c07f8e6fe77234b97f"></a><!-- doxytag: member="SimpleMemory::dequeue" ref="a851b6644e3e336c07f8e6fe77234b97f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dequeue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dequeue a packet from our internal packet queue and move it to the port where it will be sent as soon as possible. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00180"></a>00180 {
<a name="l00181"></a>00181     assert(!<a class="code" href="classSimpleMemory.html#ae20fc3a6f9b02bebe5a9bff0c939c1f5">packetQueue</a>.empty());
<a name="l00182"></a>00182     DeferredPacket deferred_pkt = <a class="code" href="classSimpleMemory.html#ae20fc3a6f9b02bebe5a9bff0c939c1f5">packetQueue</a>.front();
<a name="l00183"></a>00183 
<a name="l00184"></a>00184     <a class="code" href="classSimpleMemory.html#a6ddfdd4eb676d50001bda88567e6da14">retryResp</a> = !<a class="code" href="classSimpleMemory.html#a55c076720c982014096b57cadebf9a14">port</a>.<a class="code" href="classSlavePort.html#a0c021b2778a3358d110bd8700fe85732">sendTimingResp</a>(deferred_pkt.pkt);
<a name="l00185"></a>00185 
<a name="l00186"></a>00186     <span class="keywordflow">if</span> (!<a class="code" href="classSimpleMemory.html#a6ddfdd4eb676d50001bda88567e6da14">retryResp</a>) {
<a name="l00187"></a>00187         <a class="code" href="classSimpleMemory.html#ae20fc3a6f9b02bebe5a9bff0c939c1f5">packetQueue</a>.pop_front();
<a name="l00188"></a>00188 
<a name="l00189"></a>00189         <span class="comment">// if the queue is not empty, schedule the next dequeue event,</span>
<a name="l00190"></a>00190         <span class="comment">// otherwise signal that we are drained if we were asked to do so</span>
<a name="l00191"></a>00191         <span class="keywordflow">if</span> (!<a class="code" href="classSimpleMemory.html#ae20fc3a6f9b02bebe5a9bff0c939c1f5">packetQueue</a>.empty()) {
<a name="l00192"></a>00192             <span class="comment">// if there were packets that got in-between then we</span>
<a name="l00193"></a>00193             <span class="comment">// already have an event scheduled, so use re-schedule</span>
<a name="l00194"></a>00194             <a class="code" href="classEventManager.html#a83fe8e2d06cd7c6e36743e5beb07298f">reschedule</a>(<a class="code" href="classSimpleMemory.html#a8c2927c28d324098f4c7bb9b4d96bca1">dequeueEvent</a>,
<a name="l00195"></a>00195                        std::max(<a class="code" href="classSimpleMemory.html#ae20fc3a6f9b02bebe5a9bff0c939c1f5">packetQueue</a>.front().tick, <a class="code" href="statistics_8hh.html#a7acdccbf0d35ce0c159c0cdd36371b22" title="The universal simulation clock.">curTick</a>()), <span class="keyword">true</span>);
<a name="l00196"></a>00196         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classSimpleMemory.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a>) {
<a name="l00197"></a>00197             <a class="code" href="classSimpleMemory.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a>-&gt;<a class="code" href="classDrainManager.html#ab89d10e368d2e82061eddb9e40022382">signalDrainDone</a>();
<a name="l00198"></a>00198             <a class="code" href="classSimpleMemory.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a> = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00199"></a>00199         }
<a name="l00200"></a>00200     }
<a name="l00201"></a>00201 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa8a18d230dba7a674ac8a0b4f35bc36a"></a><!-- doxytag: member="SimpleMemory::drain" ref="aa8a18d230dba7a674ac8a0b4f35bc36a" args="(DrainManager *dm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int drain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDrainManager.html">DrainManager</a> *&nbsp;</td>
          <td class="paramname"> <em>drainManger</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Provide a default implementation of the drain interface that simply returns 0 (draining completed) and sets the drain state to Drained. </p>

<p><a class="el" href="classSimObject.html#a6bf479c521c7c3eb473822d953275b26">SimObject</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00230"></a>00230 {
<a name="l00231"></a>00231     <span class="keywordtype">int</span> <a class="code" href="namespaceX86ISA.html#a668f84c330035fdb72824eb18e09cd09">count</a> = 0;
<a name="l00232"></a>00232 
<a name="l00233"></a>00233     <span class="comment">// also track our internal queue</span>
<a name="l00234"></a>00234     <span class="keywordflow">if</span> (!<a class="code" href="classSimpleMemory.html#ae20fc3a6f9b02bebe5a9bff0c939c1f5">packetQueue</a>.empty()) {
<a name="l00235"></a>00235         count += 1;
<a name="l00236"></a>00236         <a class="code" href="classSimpleMemory.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a> = <a class="code" href="namespaceMipsISA.html#a2575c29e7f4617b6076486f340b6fe19">dm</a>;
<a name="l00237"></a>00237     }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239     <span class="keywordflow">if</span> (count)
<a name="l00240"></a>00240         <a class="code" href="classDrainable.html#ad800905390fe03e850cf996e914038f9">setDrainState</a>(<a class="code" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8a929d17847bfad0d4689c9ab8540d5134">Drainable::Draining</a>);
<a name="l00241"></a>00241     <span class="keywordflow">else</span>
<a name="l00242"></a>00242         <a class="code" href="classDrainable.html#ad800905390fe03e850cf996e914038f9">setDrainState</a>(<a class="code" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8a5656955cb808502a2ec75b367e2c1e82">Drainable::Drained</a>);
<a name="l00243"></a>00243     <span class="keywordflow">return</span> count;
<a name="l00244"></a>00244 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aab331854844f48e55c064a1d20d74361"></a><!-- doxytag: member="SimpleMemory::getLatency" ref="aab331854844f48e55c064a1d20d74361" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> getLatency </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Detemine the latency.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>the latency seen by the current packet </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00205"></a>00205 {
<a name="l00206"></a>00206     <span class="keywordflow">return</span> <a class="code" href="classSimpleMemory.html#a8291bf96dadb3695aea55321d10c0e77">latency</a> +
<a name="l00207"></a>00207         (<a class="code" href="classSimpleMemory.html#aa983b5b77f758b06806499ada4568803">latency_var</a> ? <a class="code" href="random_8cc.html#afc426934ee11701464501fa46e24e041">random_mt</a>.<a class="code" href="classRandom.html#a0fd6fb9d84d010276df0648c266e563f">random</a>&lt;<a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&gt;(0, <a class="code" href="classSimpleMemory.html#aa983b5b77f758b06806499ada4568803">latency_var</a>) : 0);
<a name="l00208"></a>00208 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac918a145092d7514ebc6dbd952dceafb"></a><!-- doxytag: member="SimpleMemory::getSlavePort" ref="ac918a145092d7514ebc6dbd952dceafb" args="(const std::string &amp;if_name, PortID idx=InvalidPortID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBaseSlavePort.html">BaseSlavePort</a> &amp; getSlavePort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>if_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#acef4d7d41cb21fdc252e20c04cd7bb8e">PortID</a>&nbsp;</td>
          <td class="paramname"> <em>idx</em> = <code><a class="el" href="base_2types_8hh.html#a65bf40f138cf863f0c5e2d8ca1144126">InvalidPortID</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a slave port with a given name and index. This is used at binding time and returns a reference to a protocol-agnostic base master port.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>if_name</em>&nbsp;</td><td><a class="el" href="classPort.html">Port</a> name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idx</em>&nbsp;</td><td>Index in the case of a VectorPort</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>A reference to the given port </dd></dl>

<p><a class="el" href="classMemObject.html#ac918a145092d7514ebc6dbd952dceafb">MemObject</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00220"></a>00220 {
<a name="l00221"></a>00221     <span class="keywordflow">if</span> (if_name != <span class="stringliteral">&quot;port&quot;</span>) {
<a name="l00222"></a>00222         <span class="keywordflow">return</span> <a class="code" href="classSimpleMemory.html#ac918a145092d7514ebc6dbd952dceafb">MemObject::getSlavePort</a>(if_name, idx);
<a name="l00223"></a>00223     } <span class="keywordflow">else</span> {
<a name="l00224"></a>00224         <span class="keywordflow">return</span> <a class="code" href="classSimpleMemory.html#a55c076720c982014096b57cadebf9a14">port</a>;
<a name="l00225"></a>00225     }
<a name="l00226"></a>00226 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a02fd73d861ef2e4aabb38c0c9ff82947"></a><!-- doxytag: member="SimpleMemory::init" ref="a02fd73d861ef2e4aabb38c0c9ff82947" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classSimpleMemory.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected <a class="el" href="classSimObject.html">SimObject</a> graph should be done here. </p>

<p><a class="el" href="classSimObject.html#a02fd73d861ef2e4aabb38c0c9ff82947">SimObject</a>を再定義しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00061"></a>00061 {
<a name="l00062"></a>00062     <span class="comment">// allow unconnected memories as this is used in several ruby</span>
<a name="l00063"></a>00063     <span class="comment">// systems at the moment</span>
<a name="l00064"></a>00064     <span class="keywordflow">if</span> (<a class="code" href="classSimpleMemory.html#a55c076720c982014096b57cadebf9a14">port</a>.<a class="code" href="classBaseSlavePort.html#a180fa55a4bf36580963bed9e3e09c227">isConnected</a>()) {
<a name="l00065"></a>00065         <a class="code" href="classSimpleMemory.html#a55c076720c982014096b57cadebf9a14">port</a>.<a class="code" href="classSlavePort.html#afb438cc39c4c679860c791bcef6dc7f3">sendRangeChange</a>();
<a name="l00066"></a>00066     }
<a name="l00067"></a>00067 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5f0b4c4a94f6b0053f9d7a4eb9c2518a"></a><!-- doxytag: member="SimpleMemory::recvAtomic" ref="a5f0b4c4a94f6b0053f9d7a4eb9c2518a" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> recvAtomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00071"></a>00071 {
<a name="l00072"></a>00072     <a class="code" href="classAbstractMemory.html#aac5d96736802cb79fb2287135bcc1dff">access</a>(pkt);
<a name="l00073"></a>00073     <span class="keywordflow">return</span> pkt-&gt;<a class="code" href="classPacket.html#a9693a1ffeda326646443ab2a2a92be41">memInhibitAsserted</a>() ? 0 : <a class="code" href="classSimpleMemory.html#aab331854844f48e55c064a1d20d74361">getLatency</a>();
<a name="l00074"></a>00074 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aeefa907fb6d6a787e6dab90e8138ea90"></a><!-- doxytag: member="SimpleMemory::recvFunctional" ref="aeefa907fb6d6a787e6dab90e8138ea90" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void recvFunctional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00078"></a>00078 {
<a name="l00079"></a>00079     pkt-&gt;<a class="code" href="classPacket.html#ad2656c333949d4b445823d47398829f2">pushLabel</a>(<a class="code" href="classSimObject.html#adbcff144e5e199d332a1352af1798148">name</a>());
<a name="l00080"></a>00080 
<a name="l00081"></a>00081     <a class="code" href="classAbstractMemory.html#ace845b5316308e12fd958fa5df09a8e8">functionalAccess</a>(pkt);
<a name="l00082"></a>00082 
<a name="l00083"></a>00083     <span class="comment">// potentially update the packets in our packet queue as well</span>
<a name="l00084"></a>00084     <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> = <a class="code" href="classSimpleMemory.html#ae20fc3a6f9b02bebe5a9bff0c939c1f5">packetQueue</a>.begin(); <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> != <a class="code" href="classSimpleMemory.html#ae20fc3a6f9b02bebe5a9bff0c939c1f5">packetQueue</a>.end(); ++<a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>)
<a name="l00085"></a>00085         pkt-&gt;<a class="code" href="classPacket.html#a77410f93ce8057ce67882c121ac2e667">checkFunctional</a>(<a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>-&gt;pkt);
<a name="l00086"></a>00086 
<a name="l00087"></a>00087     pkt-&gt;<a class="code" href="classPacket.html#a3ab6da7065be0d85f45a8dd050515f16">popLabel</a>();
<a name="l00088"></a>00088 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a29cb5a4f98063ce6e9210eacbdb35298"></a><!-- doxytag: member="SimpleMemory::recvRetry" ref="a29cb5a4f98063ce6e9210eacbdb35298" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void recvRetry </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00212"></a>00212 {
<a name="l00213"></a>00213     assert(<a class="code" href="classSimpleMemory.html#a6ddfdd4eb676d50001bda88567e6da14">retryResp</a>);
<a name="l00214"></a>00214 
<a name="l00215"></a>00215     <a class="code" href="classSimpleMemory.html#a851b6644e3e336c07f8e6fe77234b97f">dequeue</a>();
<a name="l00216"></a>00216 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3344d9dd0f83257feab5424e761f31c6"></a><!-- doxytag: member="SimpleMemory::recvTimingReq" ref="a3344d9dd0f83257feab5424e761f31c6" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool recvTimingReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000086">TODO:</a></b></dt><dd>temporary hack to deal with memory corruption issues until 4-phase transactions are complete </dd></dl>
</p>

<p><div class="fragment"><pre class="fragment"><a name="l00092"></a>00092 {
<a name="l00095"></a>00095     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="namespaceX86ISA.html#ab5f9a01fc40e47853ae9551b008afcbd">x</a> = 0; <a class="code" href="namespaceX86ISA.html#ab5f9a01fc40e47853ae9551b008afcbd">x</a> &lt; <a class="code" href="classSimpleMemory.html#a21da4bea3554874b557428e4cce5d4a4">pendingDelete</a>.size(); <a class="code" href="namespaceX86ISA.html#ab5f9a01fc40e47853ae9551b008afcbd">x</a>++)
<a name="l00096"></a>00096         <span class="keyword">delete</span> <a class="code" href="classSimpleMemory.html#a21da4bea3554874b557428e4cce5d4a4">pendingDelete</a>[<a class="code" href="namespaceX86ISA.html#ab5f9a01fc40e47853ae9551b008afcbd">x</a>];
<a name="l00097"></a>00097     <a class="code" href="classSimpleMemory.html#a21da4bea3554874b557428e4cce5d4a4">pendingDelete</a>.clear();
<a name="l00098"></a>00098 
<a name="l00099"></a>00099     <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#a9693a1ffeda326646443ab2a2a92be41">memInhibitAsserted</a>()) {
<a name="l00100"></a>00100         <span class="comment">// snooper will supply based on copy of packet</span>
<a name="l00101"></a>00101         <span class="comment">// still target&apos;s responsibility to delete packet</span>
<a name="l00102"></a>00102         <a class="code" href="classSimpleMemory.html#a21da4bea3554874b557428e4cce5d4a4">pendingDelete</a>.push_back(pkt);
<a name="l00103"></a>00103         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00104"></a>00104     }
<a name="l00105"></a>00105 
<a name="l00106"></a>00106     <span class="comment">// we should never get a new request after committing to retry the</span>
<a name="l00107"></a>00107     <span class="comment">// current one, the bus violates the rule as it simply sends a</span>
<a name="l00108"></a>00108     <span class="comment">// retry to the next one waiting on the retry list, so simply</span>
<a name="l00109"></a>00109     <span class="comment">// ignore it</span>
<a name="l00110"></a>00110     <span class="keywordflow">if</span> (<a class="code" href="classSimpleMemory.html#aab3b947b2633a30b5973a39b7e9b018a">retryReq</a>)
<a name="l00111"></a>00111         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113     <span class="comment">// if we are busy with a read or write, remember that we have to</span>
<a name="l00114"></a>00114     <span class="comment">// retry</span>
<a name="l00115"></a>00115     <span class="keywordflow">if</span> (<a class="code" href="classSimpleMemory.html#a099f725f22a344e190121634f53328d8">isBusy</a>) {
<a name="l00116"></a>00116         <a class="code" href="classSimpleMemory.html#aab3b947b2633a30b5973a39b7e9b018a">retryReq</a> = <span class="keyword">true</span>;
<a name="l00117"></a>00117         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00118"></a>00118     }
<a name="l00119"></a>00119 
<a name="l00120"></a>00120     <span class="comment">// @todo someone should pay for this</span>
<a name="l00121"></a>00121     pkt-&gt;<a class="code" href="classPacket.html#af8986a05caa6c5b96b0b01bb6cf47772">busFirstWordDelay</a> = pkt-&gt;<a class="code" href="classPacket.html#a7bf8ae0a056329f751eda8b39ca4c268">busLastWordDelay</a> = 0;
<a name="l00122"></a>00122 
<a name="l00123"></a>00123     <span class="comment">// update the release time according to the bandwidth limit, and</span>
<a name="l00124"></a>00124     <span class="comment">// do so with respect to the time it takes to finish this request</span>
<a name="l00125"></a>00125     <span class="comment">// rather than long term as it is the short term data rate that is</span>
<a name="l00126"></a>00126     <span class="comment">// limited for any real memory</span>
<a name="l00127"></a>00127 
<a name="l00128"></a>00128     <span class="comment">// only look at reads and writes when determining if we are busy,</span>
<a name="l00129"></a>00129     <span class="comment">// and for how long, as it is not clear what to regulate for the</span>
<a name="l00130"></a>00130     <span class="comment">// other types of commands</span>
<a name="l00131"></a>00131     <span class="keywordflow">if</span> (pkt-&gt;<a class="code" href="classPacket.html#adc47901747fc3c447db3abddaf01491a">isRead</a>() || pkt-&gt;<a class="code" href="classPacket.html#ab699d2f0d186312531fd1c279fd27b73">isWrite</a>()) {
<a name="l00132"></a>00132         <span class="comment">// calculate an appropriate tick to release to not exceed</span>
<a name="l00133"></a>00133         <span class="comment">// the bandwidth limit</span>
<a name="l00134"></a>00134         <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> duration = pkt-&gt;<a class="code" href="classPacket.html#a1d18ba49c7be427da1f4a42d53e35f48">getSize</a>() * <a class="code" href="classSimpleMemory.html#a18386495a208eab463cafbccfc28d5f4">bandwidth</a>;
<a name="l00135"></a>00135 
<a name="l00136"></a>00136         <span class="comment">// only consider ourselves busy if there is any need to wait</span>
<a name="l00137"></a>00137         <span class="comment">// to avoid extra events being scheduled for (infinitely) fast</span>
<a name="l00138"></a>00138         <span class="comment">// memories</span>
<a name="l00139"></a>00139         <span class="keywordflow">if</span> (duration != 0) {
<a name="l00140"></a>00140             <a class="code" href="classEventManager.html#a4ddebbfe9a12b95be6fb993ce892dcd3">schedule</a>(<a class="code" href="classSimpleMemory.html#a152504c9de53c1ab4c16f4dceaa6bbfa">releaseEvent</a>, <a class="code" href="statistics_8hh.html#a7acdccbf0d35ce0c159c0cdd36371b22" title="The universal simulation clock.">curTick</a>() + duration);
<a name="l00141"></a>00141             <a class="code" href="classSimpleMemory.html#a099f725f22a344e190121634f53328d8">isBusy</a> = <span class="keyword">true</span>;
<a name="l00142"></a>00142         }
<a name="l00143"></a>00143     }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145     <span class="comment">// go ahead and deal with the packet and put the response in the</span>
<a name="l00146"></a>00146     <span class="comment">// queue if there is one</span>
<a name="l00147"></a>00147     <span class="keywordtype">bool</span> needsResponse = pkt-&gt;<a class="code" href="classPacket.html#a390c6cced05593f0a2c75a38a7a24fa9">needsResponse</a>();
<a name="l00148"></a>00148     <a class="code" href="classSimpleMemory.html#a5f0b4c4a94f6b0053f9d7a4eb9c2518a">recvAtomic</a>(pkt);
<a name="l00149"></a>00149     <span class="comment">// turn packet around to go back to requester if response expected</span>
<a name="l00150"></a>00150     <span class="keywordflow">if</span> (needsResponse) {
<a name="l00151"></a>00151         <span class="comment">// recvAtomic() should already have turned packet into</span>
<a name="l00152"></a>00152         <span class="comment">// atomic response</span>
<a name="l00153"></a>00153         assert(pkt-&gt;<a class="code" href="classPacket.html#a5f89a108755a6cb3e8185d85c850a816">isResponse</a>());
<a name="l00154"></a>00154         <span class="comment">// to keep things simple (and in order), we put the packet at</span>
<a name="l00155"></a>00155         <span class="comment">// the end even if the latency suggests it should be sent</span>
<a name="l00156"></a>00156         <span class="comment">// before the packet(s) before it</span>
<a name="l00157"></a>00157         <a class="code" href="classSimpleMemory.html#ae20fc3a6f9b02bebe5a9bff0c939c1f5">packetQueue</a>.push_back(DeferredPacket(pkt, <a class="code" href="statistics_8hh.html#a7acdccbf0d35ce0c159c0cdd36371b22" title="The universal simulation clock.">curTick</a>() + <a class="code" href="classSimpleMemory.html#aab331854844f48e55c064a1d20d74361">getLatency</a>()));
<a name="l00158"></a>00158         <span class="keywordflow">if</span> (!<a class="code" href="classSimpleMemory.html#a6ddfdd4eb676d50001bda88567e6da14">retryResp</a> &amp;&amp; !<a class="code" href="classSimpleMemory.html#a8c2927c28d324098f4c7bb9b4d96bca1">dequeueEvent</a>.<a class="code" href="classEvent.html#a9cd69a6b10cb037550943f177a0da688" title="Determine if the current event is scheduled.">scheduled</a>())
<a name="l00159"></a>00159             <a class="code" href="classEventManager.html#a4ddebbfe9a12b95be6fb993ce892dcd3">schedule</a>(<a class="code" href="classSimpleMemory.html#a8c2927c28d324098f4c7bb9b4d96bca1">dequeueEvent</a>, <a class="code" href="classSimpleMemory.html#ae20fc3a6f9b02bebe5a9bff0c939c1f5">packetQueue</a>.back().tick);
<a name="l00160"></a>00160     } <span class="keywordflow">else</span> {
<a name="l00161"></a>00161         <a class="code" href="classSimpleMemory.html#a21da4bea3554874b557428e4cce5d4a4">pendingDelete</a>.push_back(pkt);
<a name="l00162"></a>00162     }
<a name="l00163"></a>00163 
<a name="l00164"></a>00164     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00165"></a>00165 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a23b477d0e2d399f75d585d154c346591"></a><!-- doxytag: member="SimpleMemory::release" ref="a23b477d0e2d399f75d585d154c346591" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the memory after being busy and send a retry if a request was rejected in the meanwhile. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00169"></a>00169 {
<a name="l00170"></a>00170     assert(<a class="code" href="classSimpleMemory.html#a099f725f22a344e190121634f53328d8">isBusy</a>);
<a name="l00171"></a>00171     <a class="code" href="classSimpleMemory.html#a099f725f22a344e190121634f53328d8">isBusy</a> = <span class="keyword">false</span>;
<a name="l00172"></a>00172     <span class="keywordflow">if</span> (<a class="code" href="classSimpleMemory.html#aab3b947b2633a30b5973a39b7e9b018a">retryReq</a>) {
<a name="l00173"></a>00173         <a class="code" href="classSimpleMemory.html#aab3b947b2633a30b5973a39b7e9b018a">retryReq</a> = <span class="keyword">false</span>;
<a name="l00174"></a>00174         <a class="code" href="classSimpleMemory.html#a55c076720c982014096b57cadebf9a14">port</a>.<a class="code" href="classSlavePort.html#a6172657b944e32a722d90a20c5896bb7">sendRetry</a>();
<a name="l00175"></a>00175     }
<a name="l00176"></a>00176 }
</pre></div></p>

</div>
</div>
<hr/><h2>変数</h2>
<a class="anchor" id="a18386495a208eab463cafbccfc28d5f4"></a><!-- doxytag: member="SimpleMemory::bandwidth" ref="a18386495a208eab463cafbccfc28d5f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="classSimpleMemory.html#a18386495a208eab463cafbccfc28d5f4">bandwidth</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bandwidth in ticks per byte. The regulation affects the acceptance rate of requests and the queueing takes place after the regulation. </p>

</div>
</div>
<a class="anchor" id="a8c2927c28d324098f4c7bb9b4d96bca1"></a><!-- doxytag: member="SimpleMemory::dequeueEvent" ref="a8c2927c28d324098f4c7bb9b4d96bca1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEventWrapper.html">EventWrapper</a>&lt;<a class="el" href="classSimpleMemory_1_1SimpleMemory.html">SimpleMemory</a>, &amp;SimpleMemory::dequeue&gt; <a class="el" href="classSimpleMemory.html#a8c2927c28d324098f4c7bb9b4d96bca1">dequeueEvent</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a329b71fb934a93312ca0aacbf5a3f982"></a><!-- doxytag: member="SimpleMemory::drainManager" ref="a329b71fb934a93312ca0aacbf5a3f982" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDrainManager.html">DrainManager</a>* <a class="el" href="classSimpleMemory.html#a329b71fb934a93312ca0aacbf5a3f982">drainManager</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If we need to drain, keep the drain manager around until we're done here. </p>

</div>
</div>
<a class="anchor" id="a099f725f22a344e190121634f53328d8"></a><!-- doxytag: member="SimpleMemory::isBusy" ref="a099f725f22a344e190121634f53328d8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimpleMemory.html#a099f725f22a344e190121634f53328d8">isBusy</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Track the state of the memory as either idle or busy, no need for an enum with only two states. </p>

</div>
</div>
<a class="anchor" id="a8291bf96dadb3695aea55321d10c0e77"></a><!-- doxytag: member="SimpleMemory::latency" ref="a8291bf96dadb3695aea55321d10c0e77" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> <a class="el" href="classSimpleMemory.html#a8291bf96dadb3695aea55321d10c0e77">latency</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Latency from that a request is accepted until the response is ready to be sent. </p>

</div>
</div>
<a class="anchor" id="aa983b5b77f758b06806499ada4568803"></a><!-- doxytag: member="SimpleMemory::latency_var" ref="aa983b5b77f758b06806499ada4568803" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> <a class="el" href="classSimpleMemory.html#aa983b5b77f758b06806499ada4568803">latency_var</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fudge factor added to the latency. </p>

</div>
</div>
<a class="anchor" id="ae20fc3a6f9b02bebe5a9bff0c939c1f5"></a><!-- doxytag: member="SimpleMemory::packetQueue" ref="ae20fc3a6f9b02bebe5a9bff0c939c1f5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt;<a class="el" href="classSimpleMemory_1_1DeferredPacket.html">DeferredPacket</a>&gt; <a class="el" href="classSimpleMemory.html#ae20fc3a6f9b02bebe5a9bff0c939c1f5">packetQueue</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Internal (unbounded) storage to mimic the delay caused by the actual memory access. Note that this is where the packet spends the memory latency. </p>

</div>
</div>
<a class="anchor" id="a21da4bea3554874b557428e4cce5d4a4"></a><!-- doxytag: member="SimpleMemory::pendingDelete" ref="a21da4bea3554874b557428e4cce5d4a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="classPacket.html">PacketPtr</a>&gt; <a class="el" href="classSimpleMemory.html#a21da4bea3554874b557428e4cce5d4a4">pendingDelete</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000087">TODO:</a></b></dt><dd>this is a temporary workaround until the 4-phase code is committed. upstream caches needs this packet until true is returned, so hold onto it for deletion until a subsequent call </dd></dl>

</div>
</div>
<a class="anchor" id="a55c076720c982014096b57cadebf9a14"></a><!-- doxytag: member="SimpleMemory::port" ref="a55c076720c982014096b57cadebf9a14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleMemory_1_1MemoryPort.html">MemoryPort</a> <a class="el" href="classSimpleMemory.html#a55c076720c982014096b57cadebf9a14">port</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a152504c9de53c1ab4c16f4dceaa6bbfa"></a><!-- doxytag: member="SimpleMemory::releaseEvent" ref="a152504c9de53c1ab4c16f4dceaa6bbfa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEventWrapper.html">EventWrapper</a>&lt;<a class="el" href="classSimpleMemory_1_1SimpleMemory.html">SimpleMemory</a>, &amp;SimpleMemory::release&gt; <a class="el" href="classSimpleMemory.html#a152504c9de53c1ab4c16f4dceaa6bbfa">releaseEvent</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aab3b947b2633a30b5973a39b7e9b018a"></a><!-- doxytag: member="SimpleMemory::retryReq" ref="aab3b947b2633a30b5973a39b7e9b018a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimpleMemory.html#aab3b947b2633a30b5973a39b7e9b018a">retryReq</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remember if we have to retry an outstanding request that arrived while we were busy. </p>

</div>
</div>
<a class="anchor" id="a6ddfdd4eb676d50001bda88567e6da14"></a><!-- doxytag: member="SimpleMemory::retryResp" ref="a6ddfdd4eb676d50001bda88567e6da14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimpleMemory.html#a6ddfdd4eb676d50001bda88567e6da14">retryResp</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remember if we failed to send a response and are awaiting a retry. This is only used as a check. </p>

</div>
</div>
<hr/>このクラスの説明は次のファイルから生成されました:<ul>
<li>mem/<a class="el" href="simple__mem_8hh_source.html">simple_mem.hh</a></li>
<li>mem/<a class="el" href="simple__mem_8cc.html">simple_mem.cc</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>File&nbsp;GEM5&nbsp;Wrapperに対して25 May 2015に生成されました。&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
