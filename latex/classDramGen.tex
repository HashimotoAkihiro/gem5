\hypertarget{classDramGen}{
\section{クラス DramGen}
\label{classDramGen}\index{DramGen@{DramGen}}
}


{\ttfamily \#include $<$generators.hh$>$}DramGenに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classDramGen}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDramGen_afc7f569fe1b2004371d6c159a9bdcba7}{DramGen} (const std::string \&\hyperlink{classBaseGen_a1b003dc5cfce1a4d8f9a0c4b9b589045}{\_\-name}, \hyperlink{request_8hh_ac366b729262fd8e7cbd3283da6f775cf}{MasterID} master\_\-id, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \_\-duration, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} start\_\-addr, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} end\_\-addr, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \_\-blocksize, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} min\_\-period, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} max\_\-period, uint8\_\-t read\_\-percent, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} data\_\-limit, unsigned int num\_\-seq\_\-pkts, unsigned int page\_\-size, unsigned int nbr\_\-of\_\-banks\_\-DRAM, unsigned int nbr\_\-of\_\-banks\_\-util, unsigned int addr\_\-mapping)
\item 
\hyperlink{classPacket}{PacketPtr} \hyperlink{classDramGen_a938aa9841a9a62a776afbd0768af5379}{getNextPacket} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
const unsigned int \hyperlink{classDramGen_a3904e98c281ec13010eaf9fe0671cda4}{numSeqPkts}
\item 
unsigned int \hyperlink{classDramGen_afe76fc6f68d7bc6df6e5757cbc74d949}{countNumSeqPkts}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classDramGen_a0bb77b4ba61e408313e1118250f9278c}{addr}
\item 
bool \hyperlink{classDramGen_a1ba0c9f9857ad696d8c3cd03de468fae}{isRead}
\item 
const unsigned int \hyperlink{classDramGen_a0a5d2b9bad523ef4f6c613e9955c461d}{pageSize}
\item 
const unsigned int \hyperlink{classDramGen_a91979f75432119c425a60258ae2fae8f}{pageBits}
\item 
const unsigned int \hyperlink{classDramGen_a501bda29f816788d3bba6d280d6fdc94}{bankBits}
\item 
const unsigned int \hyperlink{classDramGen_a5f384954184da222f096688b1a3cc7a5}{blockBits}
\item 
const unsigned int \hyperlink{classDramGen_aad527c6f300f25a1ee8484deaba3d63c}{nbrOfBanksDRAM}
\item 
const unsigned int \hyperlink{classDramGen_ad0a8571226776987fe09f08baf268a06}{nbrOfBanksUtil}
\item 
unsigned int \hyperlink{classDramGen_ad03c09dad8f497cd0d9fb1a58500acab}{addrMapping}
\end{DoxyCompactItemize}


\subsection{説明}
DRAM specific generator is for issuing request with variable page hit length and bank utilization. Currently assumes a single channel, single rank configuration. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classDramGen_afc7f569fe1b2004371d6c159a9bdcba7}{
\index{DramGen@{DramGen}!DramGen@{DramGen}}
\index{DramGen@{DramGen}!DramGen@{DramGen}}
\subsubsection[{DramGen}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DramGen} (const std::string \& {\em \_\-name}, \/  {\bf MasterID} {\em master\_\-id}, \/  {\bf Tick} {\em \_\-duration}, \/  {\bf Addr} {\em start\_\-addr}, \/  {\bf Addr} {\em end\_\-addr}, \/  {\bf Addr} {\em \_\-blocksize}, \/  {\bf Tick} {\em min\_\-period}, \/  {\bf Tick} {\em max\_\-period}, \/  uint8\_\-t {\em read\_\-percent}, \/  {\bf Addr} {\em data\_\-limit}, \/  unsigned int {\em num\_\-seq\_\-pkts}, \/  unsigned int {\em page\_\-size}, \/  unsigned int {\em nbr\_\-of\_\-banks\_\-DRAM}, \/  unsigned int {\em nbr\_\-of\_\-banks\_\-util}, \/  unsigned int {\em addr\_\-mapping})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDramGen_afc7f569fe1b2004371d6c159a9bdcba7}
Create a DRAM address sequence generator.


\begin{DoxyParams}{引数}
\item[{\em \_\-name}]Name to use for status and debug \item[{\em master\_\-id}]MasterID set on each request \item[{\em \_\-duration}]duration of this state before transitioning \item[{\em start\_\-addr}]Start address \item[{\em end\_\-addr}]End address \item[{\em \_\-blocksize}]Size used for transactions injected \item[{\em min\_\-period}]Lower limit of random inter-\/transaction time \item[{\em max\_\-period}]Upper limit of random inter-\/transaction time \item[{\em read\_\-percent}]Percent of transactions that are reads \item[{\em data\_\-limit}]Upper limit on how much data to read/write \item[{\em num\_\-seq\_\-pkts}]Number of packets per stride, each of \_\-blocksize \item[{\em page\_\-size}]Page size (bytes) used in the DRAM \item[{\em nbr\_\-of\_\-banks\_\-DRAM}]Total number of banks in DRAM \item[{\em nbr\_\-of\_\-banks\_\-util}]Number of banks to utilized, for N banks, we will use banks: 0-\/$>$(N-\/1) \item[{\em addr\_\-mapping}]\hyperlink{classAddress}{Address} mapping to be used, 0: RoCoRaBaCh, 1: RoRaBaCoCh/RoRaBaChCo assumes single channel and single rank system \end{DoxyParams}



\begin{DoxyCode}
349         : RandomGen(_name, master_id, _duration, start_addr, end_addr,
350           _blocksize, min_period, max_period, read_percent, data_limit),
351           numSeqPkts(num_seq_pkts), countNumSeqPkts(0),
352           isRead(true), pageSize(page_size),
353           pageBits(floorLog2(page_size / _blocksize)),
354           bankBits(floorLog2(nbr_of_banks_DRAM)),
355           blockBits(floorLog2(_blocksize)),
356           nbrOfBanksDRAM(nbr_of_banks_DRAM),
357           nbrOfBanksUtil(nbr_of_banks_util), addrMapping(addr_mapping)
358     {
359         if (addrMapping != 1 && addrMapping != 0) {
360             addrMapping = 1;
361             warn("Unknown address mapping specified, using RoRaBaCoCh\n");
362         }
363     }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classDramGen_a938aa9841a9a62a776afbd0768af5379}{
\index{DramGen@{DramGen}!getNextPacket@{getNextPacket}}
\index{getNextPacket@{getNextPacket}!DramGen@{DramGen}}
\subsubsection[{getNextPacket}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketPtr} getNextPacket ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classDramGen_a938aa9841a9a62a776afbd0768af5379}
Get the next generated packet.

\begin{DoxyReturn}{戻り値}
A packet to be sent at the current tick 
\end{DoxyReturn}


\hyperlink{classRandomGen_a938aa9841a9a62a776afbd0768af5379}{RandomGen}を再定義しています。


\begin{DoxyCode}
179 {
180     // if this is the first of the packets in series to be generated,
181     // start counting again
182     if (countNumSeqPkts == 0) {
183         countNumSeqPkts = numSeqPkts;
184 
185         // choose if we generate a read or a write here
186         isRead = readPercent != 0 &&
187             (readPercent == 100 ||
188              random_mt.random<uint8_t>(0, 100) < readPercent);
189 
190         assert((readPercent == 0 && !isRead) ||
191                (readPercent == 100 && isRead) ||
192                readPercent != 100);
193 
194         // start by picking a random address in the range
195         addr = random_mt.random<Addr>(startAddr, endAddr - 1);
196 
197         // round down to start address of a block, i.e. a DRAM burst
198         addr -= addr % blocksize;
199 
200         // pick a random bank
201         unsigned int new_bank =
202             random_mt.random<unsigned int>(0, nbrOfBanksUtil - 1);
203 
204         // next, inser the bank bits at the right spot, and align the
205         // address to achieve the required hit length, this involves
206         // finding the appropriate start address such that all
207         // sequential packets target successive columns in the same
208         // page
209 
210         // for example, if we have a stride size of 192B, which means
211         // for LPDDR3 where burstsize = 32B we have numSeqPkts = 6,
212         // the address generated previously can be such that these
213         // 192B cross the page boundary, hence it needs to be aligned
214         // so that they all belong to the same page for page hit
215         unsigned int columns_per_page = pageSize / blocksize;
216 
217         // pick a random column, but ensure that there is room for
218         // numSeqPkts sequential columns in the same page
219         unsigned int new_col =
220             random_mt.random<unsigned int>(0, columns_per_page - numSeqPkts);
221 
222         if (addrMapping == 1) {
223             // assuming block bits, then page bits, then bank bits
224             replaceBits(addr, blockBits + pageBits + bankBits - 1,
225                         blockBits + pageBits, new_bank);
226             replaceBits(addr, blockBits + pageBits - 1, blockBits, new_col);
227         } else if (addrMapping == 0) {
228             // assuming bank bits in the bottom
229             replaceBits(addr, blockBits + bankBits - 1, blockBits, new_bank);
230             replaceBits(addr, blockBits + bankBits + pageBits - 1,
231                         blockBits + bankBits, new_col);
232         }
233     } else {
234         // increment the column by one
235         if (addrMapping == 1)
236             // column bits in the bottom, so just add a block
237             addr += blocksize;
238         else if (addrMapping == 0) {
239             // column bits are above the bank bits, so increment the column bits
240             unsigned int new_col = ((addr / blocksize / nbrOfBanksDRAM) %
241                                     (pageSize / blocksize)) + 1;
242             replaceBits(addr, blockBits + bankBits + pageBits - 1,
243                         blockBits + bankBits, new_col);
244         }
245     }
246 
247     DPRINTF(TrafficGen, "DramGen::getNextPacket: %c to addr %x, "
248             "size %d, countNumSeqPkts: %d, numSeqPkts: %d\n",
249             isRead ? 'r' : 'w', addr, blocksize, countNumSeqPkts, numSeqPkts);
250 
251     // create a new request packet
252     PacketPtr pkt = getPacket(addr, blocksize,
253                               isRead ? MemCmd::ReadReq : MemCmd::WriteReq);
254 
255     // add the amount of data manipulated to the total
256     dataManipulated += blocksize;
257 
258     // subtract the number of packets remained to be generated
259     --countNumSeqPkts;
260 
261     // return the generated packet
262     return pkt;
263 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classDramGen_a0bb77b4ba61e408313e1118250f9278c}{
\index{DramGen@{DramGen}!addr@{addr}}
\index{addr@{addr}!DramGen@{DramGen}}
\subsubsection[{addr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf addr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDramGen_a0bb77b4ba61e408313e1118250f9278c}
\hyperlink{classAddress}{Address} of request \hypertarget{classDramGen_ad03c09dad8f497cd0d9fb1a58500acab}{
\index{DramGen@{DramGen}!addrMapping@{addrMapping}}
\index{addrMapping@{addrMapping}!DramGen@{DramGen}}
\subsubsection[{addrMapping}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf addrMapping}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDramGen_ad03c09dad8f497cd0d9fb1a58500acab}
\hyperlink{classAddress}{Address} mapping to be used \hypertarget{classDramGen_a501bda29f816788d3bba6d280d6fdc94}{
\index{DramGen@{DramGen}!bankBits@{bankBits}}
\index{bankBits@{bankBits}!DramGen@{DramGen}}
\subsubsection[{bankBits}]{\setlength{\rightskip}{0pt plus 5cm}const unsigned int {\bf bankBits}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDramGen_a501bda29f816788d3bba6d280d6fdc94}
Number of bank bits in DRAM address \hypertarget{classDramGen_a5f384954184da222f096688b1a3cc7a5}{
\index{DramGen@{DramGen}!blockBits@{blockBits}}
\index{blockBits@{blockBits}!DramGen@{DramGen}}
\subsubsection[{blockBits}]{\setlength{\rightskip}{0pt plus 5cm}const unsigned int {\bf blockBits}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDramGen_a5f384954184da222f096688b1a3cc7a5}
Number of block bits in DRAM address \hypertarget{classDramGen_afe76fc6f68d7bc6df6e5757cbc74d949}{
\index{DramGen@{DramGen}!countNumSeqPkts@{countNumSeqPkts}}
\index{countNumSeqPkts@{countNumSeqPkts}!DramGen@{DramGen}}
\subsubsection[{countNumSeqPkts}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf countNumSeqPkts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDramGen_afe76fc6f68d7bc6df6e5757cbc74d949}
Track number of sequential packets generated for a request \hypertarget{classDramGen_a1ba0c9f9857ad696d8c3cd03de468fae}{
\index{DramGen@{DramGen}!isRead@{isRead}}
\index{isRead@{isRead}!DramGen@{DramGen}}
\subsubsection[{isRead}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf isRead}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDramGen_a1ba0c9f9857ad696d8c3cd03de468fae}
Remember type of requests to be generated in series \hypertarget{classDramGen_aad527c6f300f25a1ee8484deaba3d63c}{
\index{DramGen@{DramGen}!nbrOfBanksDRAM@{nbrOfBanksDRAM}}
\index{nbrOfBanksDRAM@{nbrOfBanksDRAM}!DramGen@{DramGen}}
\subsubsection[{nbrOfBanksDRAM}]{\setlength{\rightskip}{0pt plus 5cm}const unsigned int {\bf nbrOfBanksDRAM}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDramGen_aad527c6f300f25a1ee8484deaba3d63c}
Number of banks in DRAM \hypertarget{classDramGen_ad0a8571226776987fe09f08baf268a06}{
\index{DramGen@{DramGen}!nbrOfBanksUtil@{nbrOfBanksUtil}}
\index{nbrOfBanksUtil@{nbrOfBanksUtil}!DramGen@{DramGen}}
\subsubsection[{nbrOfBanksUtil}]{\setlength{\rightskip}{0pt plus 5cm}const unsigned int {\bf nbrOfBanksUtil}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDramGen_ad0a8571226776987fe09f08baf268a06}
Number of banks to be utilized for a given configuration \hypertarget{classDramGen_a3904e98c281ec13010eaf9fe0671cda4}{
\index{DramGen@{DramGen}!numSeqPkts@{numSeqPkts}}
\index{numSeqPkts@{numSeqPkts}!DramGen@{DramGen}}
\subsubsection[{numSeqPkts}]{\setlength{\rightskip}{0pt plus 5cm}const unsigned int {\bf numSeqPkts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDramGen_a3904e98c281ec13010eaf9fe0671cda4}
Number of sequential DRAM packets to be generated per cpu request \hypertarget{classDramGen_a91979f75432119c425a60258ae2fae8f}{
\index{DramGen@{DramGen}!pageBits@{pageBits}}
\index{pageBits@{pageBits}!DramGen@{DramGen}}
\subsubsection[{pageBits}]{\setlength{\rightskip}{0pt plus 5cm}const unsigned int {\bf pageBits}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDramGen_a91979f75432119c425a60258ae2fae8f}
Number of page bits in DRAM address \hypertarget{classDramGen_a0a5d2b9bad523ef4f6c613e9955c461d}{
\index{DramGen@{DramGen}!pageSize@{pageSize}}
\index{pageSize@{pageSize}!DramGen@{DramGen}}
\subsubsection[{pageSize}]{\setlength{\rightskip}{0pt plus 5cm}const unsigned int {\bf pageSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDramGen_a0a5d2b9bad523ef4f6c613e9955c461d}
Page size of DRAM 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/testers/traffic\_\-gen/\hyperlink{generators_8hh}{generators.hh}\item 
cpu/testers/traffic\_\-gen/\hyperlink{generators_8cc}{generators.cc}\end{DoxyCompactItemize}
