<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>File&nbsp;GEM5&nbsp;Wrapper: クラス MasterPort</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- 作成： Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>メインページ</span></a></li>
      <li><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>構成</span></a></li>
      <li><a href="classes.html"><span>構成索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>構成メンバ</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>クラス MasterPort</h1><!-- doxytag: class="MasterPort" --><!-- doxytag: inherits="BaseMasterPort" -->
<p><code>#include &lt;<a class="el" href="port_8hh_source.html">port.hh</a>&gt;</code></p>
<div class="dynheader">
MasterPortに対する継承グラフ</div>
<div class="dynsection">
 <div class="center">
  <img src="classMasterPort.gif" usemap="#MasterPort_map" alt=""/>
  <map id="MasterPort_map" name="MasterPort_map">
<area href="classBaseMasterPort.html" alt="BaseMasterPort" shape="rect" coords="0,56,168,80"/>
<area href="classPort.html" alt="Port" shape="rect" coords="0,0,168,24"/>
<area href="classAddrMapper_1_1MapperMasterPort.html" alt="MapperMasterPort" shape="rect" coords="178,168,346,192"/>
<area href="classAtomicSimpleCPU_1_1AtomicCPUPort.html" alt="AtomicCPUPort" shape="rect" coords="178,224,346,248"/>
<area href="classBaseKvmCPU_1_1KVMCpuPort.html" alt="KVMCpuPort" shape="rect" coords="178,280,346,304"/>
<area href="classBridge_1_1BridgeMasterPort.html" alt="BridgeMasterPort" shape="rect" coords="178,336,346,360"/>
<area href="classCoherentBus_1_1CoherentBusMasterPort.html" alt="CoherentBusMasterPort" shape="rect" coords="178,392,346,416"/>
<area href="classCoherentBus_1_1SnoopRespPort.html" alt="SnoopRespPort" shape="rect" coords="178,448,346,472"/>
<area href="classCommMonitor_1_1MonitorMasterPort.html" alt="MonitorMasterPort" shape="rect" coords="178,504,346,528"/>
<area href="classDmaPort.html" alt="DmaPort" shape="rect" coords="178,560,346,584"/>
<area href="classFrontEnd_1_1IcachePort.html" alt="IcachePort" shape="rect" coords="178,616,346,640"/>
<area href="classFullO3CPU_1_1DcachePort.html" alt="DcachePort" shape="rect" coords="178,672,346,696"/>
<area href="classFullO3CPU_1_1IcachePort.html" alt="IcachePort" shape="rect" coords="178,728,346,752"/>
<area href="classInOrderCPU_1_1CachePort.html" alt="CachePort" shape="rect" coords="178,784,346,808"/>
<area href="classMemTest_1_1CpuPort.html" alt="CpuPort" shape="rect" coords="178,840,346,864"/>
<area href="classNetworkTest_1_1CpuPort.html" alt="CpuPort" shape="rect" coords="178,896,346,920"/>
<area href="classNoncoherentBus_1_1NoncoherentBusMasterPort.html" alt="NoncoherentBusMasterPort" shape="rect" coords="178,952,346,976"/>
<area href="classOzoneLWLSQ_1_1DcachePort.html" alt="DcachePort" shape="rect" coords="178,1008,346,1032"/>
<area href="classQueuedMasterPort.html" alt="QueuedMasterPort" shape="rect" coords="178,1064,346,1088"/>
<area href="classRubyDirectedTester_1_1CpuPort.html" alt="CpuPort" shape="rect" coords="178,1120,346,1144"/>
<area href="classRubyTester_1_1CpuPort.html" alt="CpuPort" shape="rect" coords="178,1176,346,1200"/>
<area href="classSystem_1_1SystemPort.html" alt="SystemPort" shape="rect" coords="178,1232,346,1256"/>
<area href="classTimingSimpleCPU_1_1TimingCPUPort.html" alt="TimingCPUPort" shape="rect" coords="178,1288,346,1312"/>
<area href="classTrafficGen_1_1TrafficGenPort.html" alt="TrafficGenPort" shape="rect" coords="178,1344,346,1368"/>
<area href="classX86ISA_1_1Walker_1_1WalkerPort.html" alt="WalkerPort" shape="rect" coords="178,1400,346,1424"/>
</map>
 </div>
</div>

<p><a href="classMasterPort-members.html">すべてのメンバ一覧</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a4a4ccf1d4533ae4ce5ac9bf88a7edfd5">MasterPort</a> (const std::string &amp;name, <a class="el" href="classMemObject.html">MemObject</a> *<a class="el" href="classPort.html#aba966efb6c1df4b015be3a396df6c318">owner</a>, <a class="el" href="base_2types_8hh.html#acef4d7d41cb21fdc252e20c04cd7bb8e">PortID</a> <a class="el" href="classPort.html#a0a67444fc1c33a60fe4a92bfff05d0cb">id</a>=<a class="el" href="base_2types_8hh.html#a65bf40f138cf863f0c5e2d8ca1144126">InvalidPortID</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a5e846fe2c65dea8caa0c62564ce24f9f">~MasterPort</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a5035def22faf23d50855716f8c9602e2">bind</a> (<a class="el" href="classBaseSlavePort.html">BaseSlavePort</a> &amp;slave_port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#af294915156f1e30f1d2e574dccc87945">unbind</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a49fe5ebde5a0349bff76527b969b7643">sendAtomic</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#aef8a57d30c0da6a2d2a599a14a9b8751">sendFunctional</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#aafaf979005392447714384794f1a8610">sendTimingReq</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a4853cc2d61a4dee331dfaeaa54f64fcb">sendTimingSnoopResp</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a6172657b944e32a722d90a20c5896bb7">sendRetry</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a32602a6a3c3d66a639455036d6c08dd6">isSnooping</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1list.html">AddrRangeList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a36cf113d5e5e091ebddb32306c098fae">getAddrRanges</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a88aa41e2693dd0091afae2604eba9bed">printAddr</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> a)</td></tr>
<tr><td colspan="2"><h2>Protected メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#ae1160d8f94f042aba1dc9a07a72e1e82">recvAtomicSnoop</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#af5b15bc08781cf0ba6190efc37d5b67e">recvFunctionalSnoop</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#abd323548d6c93f8b0543f1fe3a86ca35">recvTimingResp</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#ae43c73eff109f907118829fcfa9e7096">recvTimingSnoopReq</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#ac1ccc3bcf7ebabb20b57fab99b2be5b0">recvRetry</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#af60d9c2c17fb4c9ebc5384a7e0c9f289">recvRangeChange</a> ()</td></tr>
<tr><td colspan="2"><h2>Private 変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSlavePort.html">SlavePort</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a33e3b01a66e2118c0e01887bd905e904">_slavePort</a></td></tr>
<tr><td colspan="2"><h2>フレンド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMasterPort.html#a5344d902f61e69b03cd4d737c6375ce3">SlavePort</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>説明</h2>
<p>A <a class="el" href="classMasterPort.html">MasterPort</a> is a specialisation of a <a class="el" href="classBaseMasterPort.html">BaseMasterPort</a>, which implements the default protocol for the three different level of transport functions. In addition to the basic functionality of sending packets, it also has functions to receive range changes or determine if the port is snooping or not. </p>
<hr/><h2>コンストラクタとデストラクタ</h2>
<a class="anchor" id="a4a4ccf1d4533ae4ce5ac9bf88a7edfd5"></a><!-- doxytag: member="MasterPort::MasterPort" ref="a4a4ccf1d4533ae4ce5ac9bf88a7edfd5" args="(const std::string &amp;name, MemObject *owner, PortID id=InvalidPortID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMasterPort.html">MasterPort</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMemObject.html">MemObject</a> *&nbsp;</td>
          <td class="paramname"> <em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#acef4d7d41cb21fdc252e20c04cd7bb8e">PortID</a>&nbsp;</td>
          <td class="paramname"> <em>_id</em> = <code><a class="el" href="base_2types_8hh.html#a65bf40f138cf863f0c5e2d8ca1144126">InvalidPortID</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Master port </p>

<p><div class="fragment"><pre class="fragment"><a name="l00118"></a>00118     : <a class="code" href="classBaseMasterPort.html#ac7ad9c573dec4e547b3c45154b965d55">BaseMasterPort</a>(<a class="code" href="classPort.html#a6490f765a824ced1cc94979609fe7e07">name</a>, owner, _id), <a class="code" href="classMasterPort.html#a33e3b01a66e2118c0e01887bd905e904">_slavePort</a>(<a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>)
<a name="l00119"></a>00119 {
<a name="l00120"></a>00120 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5e846fe2c65dea8caa0c62564ce24f9f"></a><!-- doxytag: member="MasterPort::~MasterPort" ref="a5e846fe2c65dea8caa0c62564ce24f9f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classMasterPort.html">MasterPort</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00123"></a>00123 {
<a name="l00124"></a>00124 }
</pre></div></p>

</div>
</div>
<hr/><h2>関数</h2>
<a class="anchor" id="a5035def22faf23d50855716f8c9602e2"></a><!-- doxytag: member="MasterPort::bind" ref="a5035def22faf23d50855716f8c9602e2" args="(BaseSlavePort &amp;slave_port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBaseSlavePort.html">BaseSlavePort</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>slave_port</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bind this master port to a slave port. This also does the mirror action and binds the slave port to the master port. </p>

<p><a class="el" href="classBaseMasterPort.html#a55647ab861a1f8cf8d26df2f402188d7">BaseMasterPort</a>を実装しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00128"></a>00128 {
<a name="l00129"></a>00129     <span class="comment">// bind on the level of the base ports</span>
<a name="l00130"></a>00130     <a class="code" href="classBaseMasterPort.html#a5b9273661ccc0128fc9505529741c91d">_baseSlavePort</a> = &amp;slave_port;
<a name="l00131"></a>00131 
<a name="l00132"></a>00132     <span class="comment">// also attempt to base the slave to the appropriate type</span>
<a name="l00133"></a>00133     <a class="code" href="classSlavePort.html">SlavePort</a>* cast_slave_port = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classSlavePort.html">SlavePort</a>*<span class="keyword">&gt;</span>(&amp;slave_port);
<a name="l00134"></a>00134 
<a name="l00135"></a>00135     <span class="comment">// if this port is compatible, then proceed with the binding</span>
<a name="l00136"></a>00136     <span class="keywordflow">if</span> (cast_slave_port != <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>) {
<a name="l00137"></a>00137         <span class="comment">// master port keeps track of the slave port</span>
<a name="l00138"></a>00138         <a class="code" href="classMasterPort.html#a33e3b01a66e2118c0e01887bd905e904">_slavePort</a> = cast_slave_port;
<a name="l00139"></a>00139         <span class="comment">// slave port also keeps track of master port</span>
<a name="l00140"></a>00140         <a class="code" href="classMasterPort.html#a33e3b01a66e2118c0e01887bd905e904">_slavePort</a>-&gt;<a class="code" href="classSlavePort.html#ad7992aad912bd9f1bf4774673a7980e1">bind</a>(*<span class="keyword">this</span>);
<a name="l00141"></a>00141     } <span class="keywordflow">else</span> {
<a name="l00142"></a>00142         <a class="code" href="base_2misc_8hh.html#acad519418dbfdd70c1208711e609c80e">fatal</a>(<span class="stringliteral">&quot;Master port %s cannot bind to %s\n&quot;</span>, <a class="code" href="classPort.html#a6490f765a824ced1cc94979609fe7e07">name</a>(),
<a name="l00143"></a>00143               slave_port.<a class="code" href="classPort.html#a6490f765a824ced1cc94979609fe7e07">name</a>());
<a name="l00144"></a>00144     }
<a name="l00145"></a>00145 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a36cf113d5e5e091ebddb32306c098fae"></a><!-- doxytag: member="MasterPort::getAddrRanges" ref="a36cf113d5e5e091ebddb32306c098fae" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1list.html">AddrRangeList</a> getAddrRanges </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the address ranges of the connected slave port. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00160"></a>00160 {
<a name="l00161"></a>00161     <span class="keywordflow">return</span> <a class="code" href="classMasterPort.html#a33e3b01a66e2118c0e01887bd905e904">_slavePort</a>-&gt;<a class="code" href="classSlavePort.html#a6e967f8921e80748eb2be35b6b481a7e">getAddrRanges</a>();
<a name="l00162"></a>00162 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a32602a6a3c3d66a639455036d6c08dd6"></a><!-- doxytag: member="MasterPort::isSnooping" ref="a32602a6a3c3d66a639455036d6c08dd6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool isSnooping </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine if this master port is snooping or not. The default implementation returns false and thus tells the neighbour we are not snooping. Any master port that wants to receive snoop requests (e.g. a cache connected to a bus) has to override this function.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>true if the port should be considered a snooper </dd></dl>

<p><a class="el" href="classArmISA_1_1TableWalker_1_1SnoopingDmaPort.html#a32602a6a3c3d66a639455036d6c08dd6">SnoopingDmaPort</a>, <a class="el" href="classX86ISA_1_1Walker_1_1WalkerPort.html#a5ce11b7a254d3cb756d94568f7cbc25d">WalkerPort</a>, <a class="el" href="classFullO3CPU_1_1DcachePort.html#a32602a6a3c3d66a639455036d6c08dd6">DcachePort</a>, <a class="el" href="classOzoneLWLSQ_1_1DcachePort.html#a32602a6a3c3d66a639455036d6c08dd6">DcachePort</a>, <a class="el" href="classAtomicSimpleCPU_1_1AtomicCPUDPort.html#a5ce11b7a254d3cb756d94568f7cbc25d">AtomicCPUDPort</a>, <a class="el" href="classAddrMapper_1_1MapperMasterPort.html#a5ce11b7a254d3cb756d94568f7cbc25d">MapperMasterPort</a>, <a class="el" href="classBaseCache_1_1CacheMasterPort.html#a32602a6a3c3d66a639455036d6c08dd6">CacheMasterPort</a>, <a class="el" href="classCoherentBus_1_1CoherentBusMasterPort.html#a32602a6a3c3d66a639455036d6c08dd6">CoherentBusMasterPort</a>, と <a class="el" href="classCommMonitor_1_1MonitorMasterPort.html#a5ce11b7a254d3cb756d94568f7cbc25d">MonitorMasterPort</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00265"></a>00265 { <span class="keywordflow">return</span> <span class="keyword">false</span>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a88aa41e2693dd0091afae2604eba9bed"></a><!-- doxytag: member="MasterPort::printAddr" ref="a88aa41e2693dd0091afae2604eba9bed" args="(Addr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void printAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inject a PrintReq for the given address to print the state of that address throughout the memory system. For debugging. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00200"></a>00200 {
<a name="l00201"></a>00201     <a class="code" href="classRequest.html">Request</a> req(<a class="code" href="namespaceArmISA.html#a468da4d7330577ee8746df2acfa40959">a</a>, 1, 0, <a class="code" href="classRequest.html#a2d69ed2b2928ccd91cc225b403200c4e">Request::funcMasterId</a>);
<a name="l00202"></a>00202     <a class="code" href="classPacket.html">Packet</a> pkt(&amp;req, <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a10510e46d8f306ecf30ad5b1e204a434">MemCmd::PrintReq</a>);
<a name="l00203"></a>00203     <a class="code" href="classPacket_1_1PrintReqState.html">Packet::PrintReqState</a> prs(std::cerr);
<a name="l00204"></a>00204     pkt.senderState = &amp;prs;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206     <a class="code" href="classMasterPort.html#aef8a57d30c0da6a2d2a599a14a9b8751">sendFunctional</a>(&amp;pkt);
<a name="l00207"></a>00207 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae1160d8f94f042aba1dc9a07a72e1e82"></a><!-- doxytag: member="MasterPort::recvAtomicSnoop" ref="ae1160d8f94f042aba1dc9a07a72e1e82" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> recvAtomicSnoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive an atomic snoop request packet from the slave port. </p>

<p><a class="el" href="classArmISA_1_1TableWalker_1_1SnoopingDmaPort.html#ae1160d8f94f042aba1dc9a07a72e1e82">SnoopingDmaPort</a>, <a class="el" href="classX86ISA_1_1Walker_1_1WalkerPort.html#a886d584c81ee4e398ff8069907f6e1a5">WalkerPort</a>, <a class="el" href="classAtomicSimpleCPU_1_1AtomicCPUPort.html#ae1160d8f94f042aba1dc9a07a72e1e82">AtomicCPUPort</a>, <a class="el" href="classAtomicSimpleCPU_1_1AtomicCPUDPort.html#a886d584c81ee4e398ff8069907f6e1a5">AtomicCPUDPort</a>, <a class="el" href="classMemTest_1_1CpuPort.html#ae1160d8f94f042aba1dc9a07a72e1e82">CpuPort</a>, <a class="el" href="classAddrMapper_1_1MapperMasterPort.html#a886d584c81ee4e398ff8069907f6e1a5">MapperMasterPort</a>, <a class="el" href="classCoherentBus_1_1CoherentBusMasterPort.html#ae1160d8f94f042aba1dc9a07a72e1e82">CoherentBusMasterPort</a>, と <a class="el" href="classCommMonitor_1_1MonitorMasterPort.html#a886d584c81ee4e398ff8069907f6e1a5">MonitorMasterPort</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00283"></a>00283     {
<a name="l00284"></a>00284         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;%s was not expecting an atomic snoop request\n&quot;</span>, <a class="code" href="classPort.html#a6490f765a824ced1cc94979609fe7e07">name</a>());
<a name="l00285"></a>00285         <span class="keywordflow">return</span> 0;
<a name="l00286"></a>00286     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af5b15bc08781cf0ba6190efc37d5b67e"></a><!-- doxytag: member="MasterPort::recvFunctionalSnoop" ref="af5b15bc08781cf0ba6190efc37d5b67e" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void recvFunctionalSnoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive a functional snoop request packet from the slave port. </p>

<p><a class="el" href="classArmISA_1_1TableWalker_1_1SnoopingDmaPort.html#af5b15bc08781cf0ba6190efc37d5b67e">SnoopingDmaPort</a>, <a class="el" href="classX86ISA_1_1Walker_1_1WalkerPort.html#a284dfb90c168233c9d416bc07de8fefe">WalkerPort</a>, <a class="el" href="classFullO3CPU_1_1DcachePort.html#af5b15bc08781cf0ba6190efc37d5b67e">DcachePort</a>, <a class="el" href="classAtomicSimpleCPU_1_1AtomicCPUDPort.html#a284dfb90c168233c9d416bc07de8fefe">AtomicCPUDPort</a>, <a class="el" href="classMemTest_1_1CpuPort.html#af5b15bc08781cf0ba6190efc37d5b67e">CpuPort</a>, <a class="el" href="classAddrMapper_1_1MapperMasterPort.html#a284dfb90c168233c9d416bc07de8fefe">MapperMasterPort</a>, <a class="el" href="classCoherentBus_1_1CoherentBusMasterPort.html#af5b15bc08781cf0ba6190efc37d5b67e">CoherentBusMasterPort</a>, と <a class="el" href="classCommMonitor_1_1MonitorMasterPort.html#a284dfb90c168233c9d416bc07de8fefe">MonitorMasterPort</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00292"></a>00292     {
<a name="l00293"></a>00293         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;%s was not expecting a functional snoop request\n&quot;</span>, <a class="code" href="classPort.html#a6490f765a824ced1cc94979609fe7e07">name</a>());
<a name="l00294"></a>00294     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af60d9c2c17fb4c9ebc5384a7e0c9f289"></a><!-- doxytag: member="MasterPort::recvRangeChange" ref="af60d9c2c17fb4c9ebc5384a7e0c9f289" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void recvRangeChange </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called to receive an address range change from the peer slave port. The default implementation ignores the change and does nothing. Override this function in a derived class if the owner needs to be aware of the address ranges, e.g. in an interconnect component like a bus. </p>

<p><a class="el" href="classAddrMapper_1_1MapperMasterPort.html#aecf310a01b533ae8700eccac2cf20480">MapperMasterPort</a>, <a class="el" href="classCoherentBus_1_1CoherentBusMasterPort.html#af60d9c2c17fb4c9ebc5384a7e0c9f289">CoherentBusMasterPort</a>, <a class="el" href="classCommMonitor_1_1MonitorMasterPort.html#aecf310a01b533ae8700eccac2cf20480">MonitorMasterPort</a>, <a class="el" href="classNoncoherentBus_1_1NoncoherentBusMasterPort.html#af60d9c2c17fb4c9ebc5384a7e0c9f289">NoncoherentBusMasterPort</a>, <a class="el" href="classRubyPort_1_1MemMasterPort.html#aecf310a01b533ae8700eccac2cf20480">MemMasterPort</a>, と <a class="el" href="classRubyPort_1_1PioMasterPort.html#aecf310a01b533ae8700eccac2cf20480">PioMasterPort</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00324"></a>00324 { }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac1ccc3bcf7ebabb20b57fab99b2be5b0"></a><!-- doxytag: member="MasterPort::recvRetry" ref="ac1ccc3bcf7ebabb20b57fab99b2be5b0" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void recvRetry </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called by the slave port if sendTimingReq or sendTimingSnoopResp was called on this master port (causing recvTimingReq and recvTimingSnoopResp to be called on the slave port) and was unsuccesful. </p>

<p><a class="el" href="classX86ISA_1_1Walker_1_1WalkerPort.html#a29cb5a4f98063ce6e9210eacbdb35298">WalkerPort</a>, <a class="el" href="classInOrderCPU_1_1CachePort.html#a29cb5a4f98063ce6e9210eacbdb35298">CachePort</a>, <a class="el" href="classBaseKvmCPU_1_1KVMCpuPort.html#a29cb5a4f98063ce6e9210eacbdb35298">KVMCpuPort</a>, <a class="el" href="classFullO3CPU_1_1IcachePort.html#a29cb5a4f98063ce6e9210eacbdb35298">IcachePort</a>, <a class="el" href="classFullO3CPU_1_1DcachePort.html#a29cb5a4f98063ce6e9210eacbdb35298">DcachePort</a>, <a class="el" href="classFrontEnd_1_1IcachePort.html#a29cb5a4f98063ce6e9210eacbdb35298">IcachePort</a>, <a class="el" href="classOzoneLWLSQ_1_1DcachePort.html#a29cb5a4f98063ce6e9210eacbdb35298">DcachePort</a>, <a class="el" href="classAtomicSimpleCPU_1_1AtomicCPUPort.html#a29cb5a4f98063ce6e9210eacbdb35298">AtomicCPUPort</a>, <a class="el" href="classTimingSimpleCPU_1_1IcachePort.html#a29cb5a4f98063ce6e9210eacbdb35298">IcachePort</a>, <a class="el" href="classTimingSimpleCPU_1_1DcachePort.html#a29cb5a4f98063ce6e9210eacbdb35298">DcachePort</a>, <a class="el" href="classRubyDirectedTester_1_1CpuPort.html#a7ec461ad187b82b4b21e27c86e45cf9c">CpuPort</a>, <a class="el" href="classMemTest_1_1CpuPort.html#a29cb5a4f98063ce6e9210eacbdb35298">CpuPort</a>, <a class="el" href="classNetworkTest_1_1CpuPort.html#a29cb5a4f98063ce6e9210eacbdb35298">CpuPort</a>, <a class="el" href="classRubyTester_1_1CpuPort.html#a7ec461ad187b82b4b21e27c86e45cf9c">CpuPort</a>, <a class="el" href="classTrafficGen_1_1TrafficGenPort.html#a29cb5a4f98063ce6e9210eacbdb35298">TrafficGenPort</a>, <a class="el" href="classDmaPort.html#a29cb5a4f98063ce6e9210eacbdb35298">DmaPort</a>, <a class="el" href="classAddrMapper_1_1MapperMasterPort.html#a29cb5a4f98063ce6e9210eacbdb35298">MapperMasterPort</a>, <a class="el" href="classBridge_1_1BridgeMasterPort.html#a29cb5a4f98063ce6e9210eacbdb35298">BridgeMasterPort</a>, <a class="el" href="classCoherentBus_1_1CoherentBusMasterPort.html#a7ec461ad187b82b4b21e27c86e45cf9c">CoherentBusMasterPort</a>, <a class="el" href="classCoherentBus_1_1SnoopRespPort.html#a29cb5a4f98063ce6e9210eacbdb35298">SnoopRespPort</a>, <a class="el" href="classCommMonitor_1_1MonitorMasterPort.html#a29cb5a4f98063ce6e9210eacbdb35298">MonitorMasterPort</a>, <a class="el" href="classNoncoherentBus_1_1NoncoherentBusMasterPort.html#a7ec461ad187b82b4b21e27c86e45cf9c">NoncoherentBusMasterPort</a>, <a class="el" href="classQueuedMasterPort.html#a7ec461ad187b82b4b21e27c86e45cf9c">QueuedMasterPort</a>, と <a class="el" href="classSystem_1_1SystemPort.html#a29cb5a4f98063ce6e9210eacbdb35298">SystemPort</a>で実装されています。</p>

</div>
</div>
<a class="anchor" id="abd323548d6c93f8b0543f1fe3a86ca35"></a><!-- doxytag: member="MasterPort::recvTimingResp" ref="abd323548d6c93f8b0543f1fe3a86ca35" args="(PacketPtr pkt)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool recvTimingResp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive a timing response from the slave port. </p>

<p><a class="el" href="classX86ISA_1_1Walker_1_1WalkerPort.html#a482dba5588f4bee43e498875a61e5e0b">WalkerPort</a>, <a class="el" href="classInOrderCPU_1_1CachePort.html#a482dba5588f4bee43e498875a61e5e0b">CachePort</a>, <a class="el" href="classBaseKvmCPU_1_1KVMCpuPort.html#a482dba5588f4bee43e498875a61e5e0b">KVMCpuPort</a>, <a class="el" href="classFullO3CPU_1_1IcachePort.html#a482dba5588f4bee43e498875a61e5e0b">IcachePort</a>, <a class="el" href="classFullO3CPU_1_1DcachePort.html#a482dba5588f4bee43e498875a61e5e0b">DcachePort</a>, <a class="el" href="classAtomicSimpleCPU_1_1AtomicCPUPort.html#a482dba5588f4bee43e498875a61e5e0b">AtomicCPUPort</a>, <a class="el" href="classTimingSimpleCPU_1_1IcachePort.html#a482dba5588f4bee43e498875a61e5e0b">IcachePort</a>, <a class="el" href="classTimingSimpleCPU_1_1DcachePort.html#a482dba5588f4bee43e498875a61e5e0b">DcachePort</a>, <a class="el" href="classRubyDirectedTester_1_1CpuPort.html#a482dba5588f4bee43e498875a61e5e0b">CpuPort</a>, <a class="el" href="classMemTest_1_1CpuPort.html#a482dba5588f4bee43e498875a61e5e0b">CpuPort</a>, <a class="el" href="classNetworkTest_1_1CpuPort.html#a482dba5588f4bee43e498875a61e5e0b">CpuPort</a>, <a class="el" href="classRubyTester_1_1CpuPort.html#a482dba5588f4bee43e498875a61e5e0b">CpuPort</a>, <a class="el" href="classTrafficGen_1_1TrafficGenPort.html#a482dba5588f4bee43e498875a61e5e0b">TrafficGenPort</a>, <a class="el" href="classDmaPort.html#a482dba5588f4bee43e498875a61e5e0b">DmaPort</a>, <a class="el" href="classAddrMapper_1_1MapperMasterPort.html#a482dba5588f4bee43e498875a61e5e0b">MapperMasterPort</a>, <a class="el" href="classBridge_1_1BridgeMasterPort.html#a482dba5588f4bee43e498875a61e5e0b">BridgeMasterPort</a>, <a class="el" href="classCoherentBus_1_1CoherentBusMasterPort.html#a197a199a6dabb291067a978d54bd2d04">CoherentBusMasterPort</a>, <a class="el" href="classCoherentBus_1_1SnoopRespPort.html#a482dba5588f4bee43e498875a61e5e0b">SnoopRespPort</a>, <a class="el" href="classCommMonitor_1_1MonitorMasterPort.html#a482dba5588f4bee43e498875a61e5e0b">MonitorMasterPort</a>, <a class="el" href="classMessageMasterPort.html#a482dba5588f4bee43e498875a61e5e0b">MessageMasterPort</a>, <a class="el" href="classNoncoherentBus_1_1NoncoherentBusMasterPort.html#a197a199a6dabb291067a978d54bd2d04">NoncoherentBusMasterPort</a>, <a class="el" href="classRubyPort_1_1MemMasterPort.html#a482dba5588f4bee43e498875a61e5e0b">MemMasterPort</a>, <a class="el" href="classRubyPort_1_1PioMasterPort.html#a482dba5588f4bee43e498875a61e5e0b">PioMasterPort</a>, と <a class="el" href="classSystem_1_1SystemPort.html#a482dba5588f4bee43e498875a61e5e0b">SystemPort</a>で実装されています。</p>

</div>
</div>
<a class="anchor" id="ae43c73eff109f907118829fcfa9e7096"></a><!-- doxytag: member="MasterPort::recvTimingSnoopReq" ref="ae43c73eff109f907118829fcfa9e7096" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void recvTimingSnoopReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive a timing snoop request from the slave port. </p>

<p><a class="el" href="classArmISA_1_1TableWalker_1_1SnoopingDmaPort.html#ae43c73eff109f907118829fcfa9e7096">SnoopingDmaPort</a>, <a class="el" href="classX86ISA_1_1Walker_1_1WalkerPort.html#aff3031c56fc4947a19695c868bb8233e">WalkerPort</a>, <a class="el" href="classInOrderCPU_1_1CachePort.html#aff3031c56fc4947a19695c868bb8233e">CachePort</a>, <a class="el" href="classFullO3CPU_1_1IcachePort.html#ae43c73eff109f907118829fcfa9e7096">IcachePort</a>, <a class="el" href="classFullO3CPU_1_1DcachePort.html#aff3031c56fc4947a19695c868bb8233e">DcachePort</a>, <a class="el" href="classTimingSimpleCPU_1_1TimingCPUPort.html#ae43c73eff109f907118829fcfa9e7096">TimingCPUPort</a>, <a class="el" href="classTimingSimpleCPU_1_1DcachePort.html#aff3031c56fc4947a19695c868bb8233e">DcachePort</a>, <a class="el" href="classMemTest_1_1CpuPort.html#ae43c73eff109f907118829fcfa9e7096">CpuPort</a>, <a class="el" href="classAddrMapper_1_1MapperMasterPort.html#aff3031c56fc4947a19695c868bb8233e">MapperMasterPort</a>, <a class="el" href="classCoherentBus_1_1CoherentBusMasterPort.html#ae43c73eff109f907118829fcfa9e7096">CoherentBusMasterPort</a>, と <a class="el" href="classCommMonitor_1_1MonitorMasterPort.html#aff3031c56fc4947a19695c868bb8233e">MonitorMasterPort</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00305"></a>00305     {
<a name="l00306"></a>00306         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;%s was not expecting a timing snoop request\n&quot;</span>, <a class="code" href="classPort.html#a6490f765a824ced1cc94979609fe7e07">name</a>());
<a name="l00307"></a>00307     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a49fe5ebde5a0349bff76527b969b7643"></a><!-- doxytag: member="MasterPort::sendAtomic" ref="a49fe5ebde5a0349bff76527b969b7643" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> sendAtomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send an atomic request packet, where the data is moved and the state is updated in zero time, without interleaving with other memory accesses.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td><a class="el" href="classPacket.html">Packet</a> to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>Estimated latency of access. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00166"></a>00166 {
<a name="l00167"></a>00167     assert(pkt-&gt;<a class="code" href="classPacket.html#af21986d725d75fa8e1b6c83457cd4501">isRequest</a>());
<a name="l00168"></a>00168     <span class="keywordflow">return</span> <a class="code" href="classMasterPort.html#a33e3b01a66e2118c0e01887bd905e904">_slavePort</a>-&gt;<a class="code" href="classSlavePort.html#a428ab07671bc9372dc44a2487b12a726">recvAtomic</a>(pkt);
<a name="l00169"></a>00169 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aef8a57d30c0da6a2d2a599a14a9b8751"></a><!-- doxytag: member="MasterPort::sendFunctional" ref="aef8a57d30c0da6a2d2a599a14a9b8751" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sendFunctional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send a functional request packet, where the data is instantly updated everywhere in the memory system, without affecting the current state of any block or moving the block.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td><a class="el" href="classPacket.html">Packet</a> to send. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00173"></a>00173 {
<a name="l00174"></a>00174     assert(pkt-&gt;<a class="code" href="classPacket.html#af21986d725d75fa8e1b6c83457cd4501">isRequest</a>());
<a name="l00175"></a>00175     <span class="keywordflow">return</span> <a class="code" href="classMasterPort.html#a33e3b01a66e2118c0e01887bd905e904">_slavePort</a>-&gt;<a class="code" href="classSlavePort.html#a6a3d6f2e5dab6bed16d53d9e7c17378d">recvFunctional</a>(pkt);
<a name="l00176"></a>00176 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6172657b944e32a722d90a20c5896bb7"></a><!-- doxytag: member="MasterPort::sendRetry" ref="a6172657b944e32a722d90a20c5896bb7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sendRetry </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send a retry to the slave port that previously attempted a sendTimingResp to this master port and failed. </p>

<p><a class="el" href="classCoherentBus_1_1SnoopRespPort.html#a6172657b944e32a722d90a20c5896bb7">SnoopRespPort</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00194"></a>00194 {
<a name="l00195"></a>00195     <a class="code" href="classMasterPort.html#a33e3b01a66e2118c0e01887bd905e904">_slavePort</a>-&gt;<a class="code" href="classSlavePort.html#ac1ccc3bcf7ebabb20b57fab99b2be5b0">recvRetry</a>();
<a name="l00196"></a>00196 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aafaf979005392447714384794f1a8610"></a><!-- doxytag: member="MasterPort::sendTimingReq" ref="aafaf979005392447714384794f1a8610" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sendTimingReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Attempt to send a timing request to the slave port by calling its corresponding receive function. If the send does not succeed, as indicated by the return value, then the sender must wait for a recvRetry at which point it can re-issue a sendTimingReq.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td><a class="el" href="classPacket.html">Packet</a> to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>If the send was succesful or not. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00180"></a>00180 {
<a name="l00181"></a>00181     assert(pkt-&gt;<a class="code" href="classPacket.html#af21986d725d75fa8e1b6c83457cd4501">isRequest</a>());
<a name="l00182"></a>00182     <span class="keywordflow">return</span> <a class="code" href="classMasterPort.html#a33e3b01a66e2118c0e01887bd905e904">_slavePort</a>-&gt;<a class="code" href="classSlavePort.html#abcece77e42f88ee41af8d3d01bb48253">recvTimingReq</a>(pkt);
<a name="l00183"></a>00183 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4853cc2d61a4dee331dfaeaa54f64fcb"></a><!-- doxytag: member="MasterPort::sendTimingSnoopResp" ref="a4853cc2d61a4dee331dfaeaa54f64fcb" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sendTimingSnoopResp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Attempt to send a timing snoop response packet to the slave port by calling its corresponding receive function. If the send does not succeed, as indicated by the return value, then the sender must wait for a recvRetry at which point it can re-issue a sendTimingSnoopResp.</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td><a class="el" href="classPacket.html">Packet</a> to send. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00187"></a>00187 {
<a name="l00188"></a>00188     assert(pkt-&gt;<a class="code" href="classPacket.html#a5f89a108755a6cb3e8185d85c850a816">isResponse</a>());
<a name="l00189"></a>00189     <span class="keywordflow">return</span> <a class="code" href="classMasterPort.html#a33e3b01a66e2118c0e01887bd905e904">_slavePort</a>-&gt;<a class="code" href="classSlavePort.html#ae808ca0180bf333d9072270ed66f17fe">recvTimingSnoopResp</a>(pkt);
<a name="l00190"></a>00190 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af294915156f1e30f1d2e574dccc87945"></a><!-- doxytag: member="MasterPort::unbind" ref="af294915156f1e30f1d2e574dccc87945" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unbind </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unbind this master port and the associated slave port. </p>

<p><a class="el" href="classBaseMasterPort.html#a406c5430a4a46c0068050632b9d3e765">BaseMasterPort</a>を実装しています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00149"></a>00149 {
<a name="l00150"></a>00150     <span class="keywordflow">if</span> (<a class="code" href="classMasterPort.html#a33e3b01a66e2118c0e01887bd905e904">_slavePort</a> == <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>)
<a name="l00151"></a>00151         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;Attempting to unbind master port %s that is not connected\n&quot;</span>,
<a name="l00152"></a>00152               <a class="code" href="classPort.html#a6490f765a824ced1cc94979609fe7e07">name</a>());
<a name="l00153"></a>00153     <a class="code" href="classMasterPort.html#a33e3b01a66e2118c0e01887bd905e904">_slavePort</a>-&gt;<a class="code" href="classSlavePort.html#af294915156f1e30f1d2e574dccc87945">unbind</a>();
<a name="l00154"></a>00154     <a class="code" href="classMasterPort.html#a33e3b01a66e2118c0e01887bd905e904">_slavePort</a> = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00155"></a>00155     <a class="code" href="classBaseMasterPort.html#a5b9273661ccc0128fc9505529741c91d">_baseSlavePort</a> = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00156"></a>00156 }
</pre></div></p>

</div>
</div>
<hr/><h2>フレンドと関連する関数</h2>
<a class="anchor" id="a5344d902f61e69b03cd4d737c6375ce3"></a><!-- doxytag: member="MasterPort::SlavePort" ref="a5344d902f61e69b03cd4d737c6375ce3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSlavePort.html">SlavePort</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>変数</h2>
<a class="anchor" id="a33e3b01a66e2118c0e01887bd905e904"></a><!-- doxytag: member="MasterPort::_slavePort" ref="a33e3b01a66e2118c0e01887bd905e904" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSlavePort.html">SlavePort</a>* <a class="el" href="classMasterPort.html#a33e3b01a66e2118c0e01887bd905e904">_slavePort</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>このクラスの説明は次のファイルから生成されました:<ul>
<li>mem/<a class="el" href="port_8hh_source.html">port.hh</a></li>
<li>mem/<a class="el" href="port_8cc.html">port.cc</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>File&nbsp;GEM5&nbsp;Wrapperに対して25 May 2015に生成されました。&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
