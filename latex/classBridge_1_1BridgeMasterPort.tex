\hypertarget{classBridge_1_1BridgeMasterPort}{
\section{クラス BridgeMasterPort}
\label{classBridge_1_1BridgeMasterPort}\index{Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}}
}


{\ttfamily \#include $<$bridge.hh$>$}BridgeMasterPortに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4cm]{classBridge_1_1BridgeMasterPort}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classBridge_1_1BridgeMasterPort_a0e907bb2314fb9bd4dcc0a702c1948dd}{BridgeMasterPort} (const std::string \&\_\-name, \hyperlink{classBridge_1_1Bridge}{Bridge} \&\_\-bridge, \hyperlink{classBridge_1_1BridgeSlavePort}{BridgeSlavePort} \&\hyperlink{classMasterPort_a33e3b01a66e2118c0e01887bd905e904}{\_\-slavePort}, \hyperlink{classCycles}{Cycles} \_\-delay, int \_\-req\_\-limit)
\item 
bool \hyperlink{classBridge_1_1BridgeMasterPort_a5b40b3c494ce10f0e9f0c89965808030}{reqQueueFull} () const 
\item 
void \hyperlink{classBridge_1_1BridgeMasterPort_a6e835b0c02fcb4679fc14de7605b4f13}{schedTimingReq} (\hyperlink{classPacket}{PacketPtr} pkt, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} when)
\item 
bool \hyperlink{classBridge_1_1BridgeMasterPort_a8eb60d4744b6212ad749f3a586759266}{checkFunctional} (\hyperlink{classPacket}{PacketPtr} pkt)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classBridge_1_1BridgeMasterPort_a482dba5588f4bee43e498875a61e5e0b}{recvTimingResp} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classBridge_1_1BridgeMasterPort_a29cb5a4f98063ce6e9210eacbdb35298}{recvRetry} ()
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classBridge_1_1BridgeMasterPort_a391c414b53eb45782e37bc539608e477}{trySendTiming} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classBridge_1_1Bridge}{Bridge} \& \hyperlink{classBridge_1_1BridgeMasterPort_a6d3b24e49ac986064571195ab9905136}{bridge}
\item 
\hyperlink{classBridge_1_1BridgeSlavePort}{BridgeSlavePort} \& \hyperlink{classBridge_1_1BridgeMasterPort_a1e08ec2f17b79c544fef06a37d6b4ba3}{slavePort}
\item 
const \hyperlink{classCycles}{Cycles} \hyperlink{classBridge_1_1BridgeMasterPort_a153dd7cdfa9816427cbbe84dce923c8d}{delay}
\item 
\hyperlink{classstd_1_1deque}{std::deque}$<$ \hyperlink{classBridge_1_1DeferredPacket}{DeferredPacket} $>$ \hyperlink{classBridge_1_1BridgeMasterPort_a640fbfa2436c06d6f64608f76261e6e5}{transmitList}
\item 
const unsigned int \hyperlink{classBridge_1_1BridgeMasterPort_abe7df187a5de0c89447640be0c8d6f87}{reqQueueLimit}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classBridge_1_1BridgeMasterPort}{BridgeMasterPort},\&BridgeMasterPort::trySendTiming $>$ \hyperlink{classBridge_1_1BridgeMasterPort_ac65e9e742d994553fd80b8b38c2bd5dd}{sendEvent}
\end{DoxyCompactItemize}


\subsection{説明}
\hyperlink{classPort}{Port} on the side that forwards requests and receives responses. The master port has a buffer for the requests not yet sent. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classBridge_1_1BridgeMasterPort_a0e907bb2314fb9bd4dcc0a702c1948dd}{
\index{Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}!BridgeMasterPort@{BridgeMasterPort}}
\index{BridgeMasterPort@{BridgeMasterPort}!Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}}
\subsubsection[{BridgeMasterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BridgeMasterPort} (const std::string \& {\em \_\-name}, \/  {\bf Bridge} \& {\em \_\-bridge}, \/  {\bf BridgeSlavePort} \& {\em \_\-slavePort}, \/  {\bf Cycles} {\em \_\-delay}, \/  int {\em \_\-req\_\-limit})}}
\label{classBridge_1_1BridgeMasterPort_a0e907bb2314fb9bd4dcc0a702c1948dd}
Constructor for the \hyperlink{classBridge_1_1BridgeMasterPort}{BridgeMasterPort}.


\begin{DoxyParams}{引数}
\item[{\em \_\-name}]the port name including the owner \item[{\em \_\-bridge}]the structural owner \item[{\em \_\-slavePort}]the slave port on the other side of the bridge \item[{\em \_\-delay}]the delay in cycles from receiving to sending \item[{\em \_\-req\_\-limit}]the size of the request queue \end{DoxyParams}



\begin{DoxyCode}
72     : MasterPort(_name, &_bridge), bridge(_bridge), slavePort(_slavePort),
73       delay(_delay), reqQueueLimit(_req_limit), sendEvent(*this)
74 {
75 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classBridge_1_1BridgeMasterPort_a8eb60d4744b6212ad749f3a586759266}{
\index{Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}!checkFunctional@{checkFunctional}}
\index{checkFunctional@{checkFunctional}!Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}}
\subsubsection[{checkFunctional}]{\setlength{\rightskip}{0pt plus 5cm}bool checkFunctional ({\bf PacketPtr} {\em pkt})}}
\label{classBridge_1_1BridgeMasterPort_a8eb60d4744b6212ad749f3a586759266}
\hyperlink{classCheck}{Check} a functional request against the packets in our request queue.


\begin{DoxyParams}{引数}
\item[{\em pkt}]packet to check against\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
true if we find a match 
\end{DoxyReturn}



\begin{DoxyCode}
387 {
388     bool found = false;
389     auto i = transmitList.begin();
390 
391     while(i != transmitList.end() && !found) {
392         if (pkt->checkFunctional((*i).pkt)) {
393             pkt->makeResponse();
394             found = true;
395         }
396         ++i;
397     }
398 
399     return found;
400 }
\end{DoxyCode}
\hypertarget{classBridge_1_1BridgeMasterPort_a29cb5a4f98063ce6e9210eacbdb35298}{
\index{Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetry ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBridge_1_1BridgeMasterPort_a29cb5a4f98063ce6e9210eacbdb35298}
When receiving a retry request from the peer port, pass it to the bridge. 

\hyperlink{classMasterPort_ac1ccc3bcf7ebabb20b57fab99b2be5b0}{MasterPort}を実装しています。


\begin{DoxyCode}
345 {
346     trySendTiming();
347 }
\end{DoxyCode}
\hypertarget{classBridge_1_1BridgeMasterPort_a482dba5588f4bee43e498875a61e5e0b}{
\index{Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}!recvTimingResp@{recvTimingResp}}
\index{recvTimingResp@{recvTimingResp}!Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}}
\subsubsection[{recvTimingResp}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingResp ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBridge_1_1BridgeMasterPort_a482dba5588f4bee43e498875a61e5e0b}
When receiving a timing request from the peer port, pass it to the bridge. 

\hyperlink{classMasterPort_abd323548d6c93f8b0543f1fe3a86ca35}{MasterPort}を実装しています。


\begin{DoxyCode}
131 {
132     // all checks are done when the request is accepted on the slave
133     // side, so we are guaranteed to have space for the response
134     DPRINTF(Bridge, "recvTimingResp: %s addr 0x%x\n",
135             pkt->cmdString(), pkt->getAddr());
136 
137     DPRINTF(Bridge, "Request queue size: %d\n", transmitList.size());
138 
139     // @todo: We need to pay for this and not just zero it out
140     pkt->busFirstWordDelay = pkt->busLastWordDelay = 0;
141 
142     slavePort.schedTimingResp(pkt, bridge.clockEdge(delay));
143 
144     return true;
145 }
\end{DoxyCode}
\hypertarget{classBridge_1_1BridgeMasterPort_a5b40b3c494ce10f0e9f0c89965808030}{
\index{Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}!reqQueueFull@{reqQueueFull}}
\index{reqQueueFull@{reqQueueFull}!Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}}
\subsubsection[{reqQueueFull}]{\setlength{\rightskip}{0pt plus 5cm}bool reqQueueFull () const}}
\label{classBridge_1_1BridgeMasterPort_a5b40b3c494ce10f0e9f0c89965808030}
Is this side blocked from accepting new request packets.

\begin{DoxyReturn}{戻り値}
true if the occupied space has reached the set limit 
\end{DoxyReturn}



\begin{DoxyCode}
125 {
126     return transmitList.size() == reqQueueLimit;
127 }
\end{DoxyCode}
\hypertarget{classBridge_1_1BridgeMasterPort_a6e835b0c02fcb4679fc14de7605b4f13}{
\index{Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}!schedTimingReq@{schedTimingReq}}
\index{schedTimingReq@{schedTimingReq}!Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}}
\subsubsection[{schedTimingReq}]{\setlength{\rightskip}{0pt plus 5cm}void schedTimingReq ({\bf PacketPtr} {\em pkt}, \/  {\bf Tick} {\em when})}}
\label{classBridge_1_1BridgeMasterPort_a6e835b0c02fcb4679fc14de7605b4f13}
Queue a request packet to be sent out later and also schedule a send if necessary.


\begin{DoxyParams}{引数}
\item[{\em pkt}]a request to send out after a delay \item[{\em when}]tick when response packet should be sent \end{DoxyParams}



\begin{DoxyCode}
209 {
210     // If we expect to see a response, we need to restore the source
211     // and destination field that is potentially changed by a second
212     // bus
213     if (!pkt->memInhibitAsserted() && pkt->needsResponse()) {
214         // Update the sender state so we can deal with the response
215         // appropriately
216         pkt->pushSenderState(new RequestState(pkt->getSrc()));
217     }
218 
219     // If we're about to put this packet at the head of the queue, we
220     // need to schedule an event to do the transmit.  Otherwise there
221     // should already be an event scheduled for sending the head
222     // packet.
223     if (transmitList.empty()) {
224         bridge.schedule(sendEvent, when);
225     }
226 
227     assert(transmitList.size() != reqQueueLimit);
228 
229     transmitList.push_back(DeferredPacket(pkt, when));
230 }
\end{DoxyCode}
\hypertarget{classBridge_1_1BridgeMasterPort_a391c414b53eb45782e37bc539608e477}{
\index{Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}!trySendTiming@{trySendTiming}}
\index{trySendTiming@{trySendTiming}!Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}}
\subsubsection[{trySendTiming}]{\setlength{\rightskip}{0pt plus 5cm}void trySendTiming ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBridge_1_1BridgeMasterPort_a391c414b53eb45782e37bc539608e477}
Handle send event, scheduled when the packet at the head of the outbound queue is ready to transmit (for timing accesses only). 


\begin{DoxyCode}
263 {
264     assert(!transmitList.empty());
265 
266     DeferredPacket req = transmitList.front();
267 
268     assert(req.tick <= curTick());
269 
270     PacketPtr pkt = req.pkt;
271 
272     DPRINTF(Bridge, "trySend request addr 0x%x, queue size %d\n",
273             pkt->getAddr(), transmitList.size());
274 
275     if (sendTimingReq(pkt)) {
276         // send successful
277         transmitList.pop_front();
278         DPRINTF(Bridge, "trySend request successful\n");
279 
280         // If there are more packets to send, schedule event to try again.
281         if (!transmitList.empty()) {
282             DeferredPacket next_req = transmitList.front();
283             DPRINTF(Bridge, "Scheduling next send\n");
284             bridge.schedule(sendEvent, std::max(next_req.tick,
285                                                 bridge.clockEdge()));
286         }
287 
288         // if we have stalled a request due to a full request queue,
289         // then send a retry at this point, also note that if the
290         // request we stalled was waiting for the response queue
291         // rather than the request queue we might stall it again
292         slavePort.retryStalledReq();
293     }
294 
295     // if the send failed, then we try again once we receive a retry,
296     // and therefore there is no need to take any action
297 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classBridge_1_1BridgeMasterPort_a6d3b24e49ac986064571195ab9905136}{
\index{Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}!bridge@{bridge}}
\index{bridge@{bridge}!Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}}
\subsubsection[{bridge}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Bridge}\& {\bf bridge}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBridge_1_1BridgeMasterPort_a6d3b24e49ac986064571195ab9905136}
The bridge to which this port belongs. \hypertarget{classBridge_1_1BridgeMasterPort_a153dd7cdfa9816427cbbe84dce923c8d}{
\index{Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}!delay@{delay}}
\index{delay@{delay}!Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}}
\subsubsection[{delay}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Cycles} {\bf delay}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBridge_1_1BridgeMasterPort_a153dd7cdfa9816427cbbe84dce923c8d}
Minimum delay though this bridge. \hypertarget{classBridge_1_1BridgeMasterPort_abe7df187a5de0c89447640be0c8d6f87}{
\index{Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}!reqQueueLimit@{reqQueueLimit}}
\index{reqQueueLimit@{reqQueueLimit}!Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}}
\subsubsection[{reqQueueLimit}]{\setlength{\rightskip}{0pt plus 5cm}const unsigned int {\bf reqQueueLimit}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBridge_1_1BridgeMasterPort_abe7df187a5de0c89447640be0c8d6f87}
Max queue size for request packets \hypertarget{classBridge_1_1BridgeMasterPort_ac65e9e742d994553fd80b8b38c2bd5dd}{
\index{Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}!sendEvent@{sendEvent}}
\index{sendEvent@{sendEvent}!Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}}
\subsubsection[{sendEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf BridgeMasterPort}, \&BridgeMasterPort::trySendTiming$>$ {\bf sendEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBridge_1_1BridgeMasterPort_ac65e9e742d994553fd80b8b38c2bd5dd}
Send event for the request queue. \hypertarget{classBridge_1_1BridgeMasterPort_a1e08ec2f17b79c544fef06a37d6b4ba3}{
\index{Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}!slavePort@{slavePort}}
\index{slavePort@{slavePort}!Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}}
\subsubsection[{slavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BridgeSlavePort}\& {\bf slavePort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBridge_1_1BridgeMasterPort_a1e08ec2f17b79c544fef06a37d6b4ba3}
The slave port on the other side of the bridge (connected to the other bus). \hypertarget{classBridge_1_1BridgeMasterPort_a640fbfa2436c06d6f64608f76261e6e5}{
\index{Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}!transmitList@{transmitList}}
\index{transmitList@{transmitList}!Bridge::BridgeMasterPort@{Bridge::BridgeMasterPort}}
\subsubsection[{transmitList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::deque}$<${\bf DeferredPacket}$>$ {\bf transmitList}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classBridge_1_1BridgeMasterPort_a640fbfa2436c06d6f64608f76261e6e5}
\hyperlink{classRequest}{Request} packet queue. \hyperlink{classRequest}{Request} packets are held in this queue for a specified delay to model the processing delay of the bridge. We use a deque as we need to iterate over the items for functional accesses. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{bridge_8hh}{bridge.hh}\item 
mem/\hyperlink{bridge_8cc}{bridge.cc}\end{DoxyCompactItemize}
