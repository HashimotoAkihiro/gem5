\hypertarget{classIGbE_1_1RxDescCache}{
\section{クラス RxDescCache}
\label{classIGbE_1_1RxDescCache}\index{IGbE::RxDescCache@{IGbE::RxDescCache}}
}
RxDescCacheに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classIGbE_1_1RxDescCache}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classIGbE_1_1RxDescCache_aa0df94c8316951374e466ed453451b26}{RxDescCache} (\hyperlink{classIGbE}{IGbE} $\ast$i, std::string n, int s)
\item 
int \hyperlink{classIGbE_1_1RxDescCache_a3e213f353f926628fed12519b96f1b47}{writePacket} (\hyperlink{classRefCountingPtr}{EthPacketPtr} packet, int pkt\_\-offset)
\item 
void \hyperlink{classIGbE_1_1RxDescCache_a4f0881be8aa8698e16dcf52a89085100}{pktComplete} ()
\item 
bool \hyperlink{classIGbE_1_1RxDescCache_a430d1dfdf7dcec48b02f69d6769acab6}{packetDone} ()
\item 
void \hyperlink{classIGbE_1_1RxDescCache_a05f4f640320394e21432a2d1c2ce8edc}{pktSplitDone} ()
\item 
virtual bool \hyperlink{classIGbE_1_1RxDescCache_a2587421ae644a9474416e5a5b63ccbca}{hasOutstandingEvents} ()
\item 
virtual void \hyperlink{classIGbE_1_1RxDescCache_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classIGbE_1_1RxDescCache_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classIGbE_1_1RxDescCache}{RxDescCache},\&RxDescCache::pktComplete $>$ \hyperlink{classIGbE_1_1RxDescCache_a28964c300d774b0dc1d7cabcff1cdc7b}{pktEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classIGbE_1_1RxDescCache}{RxDescCache},\&RxDescCache::pktSplitDone $>$ \hyperlink{classIGbE_1_1RxDescCache_aa1e4265fed174c3f3f46281e329a45de}{pktHdrEvent}
\item 
\hyperlink{classEventWrapper}{EventWrapper}$<$ \hyperlink{classIGbE_1_1RxDescCache}{RxDescCache},\&RxDescCache::pktSplitDone $>$ \hyperlink{classIGbE_1_1RxDescCache_a80533f1573c797ab5f5333d376e899c7}{pktDataEvent}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classIGbE_1_1RxDescCache_ae5a77c90557026fdf4fd78883f92bef9}{descBase} () const 
\item 
virtual long \hyperlink{classIGbE_1_1RxDescCache_af3d1877b6f30bdf98b95351c38d400f3}{descHead} () const 
\item 
virtual long \hyperlink{classIGbE_1_1RxDescCache_a465e4e31be3a89db3d7f9cd1ecc40064}{descLen} () const 
\item 
virtual long \hyperlink{classIGbE_1_1RxDescCache_a4b6b769be62592fc43518ba480bbd1f7}{descTail} () const 
\item 
virtual void \hyperlink{classIGbE_1_1RxDescCache_a4f8dbb4f64167626cac110753708c55c}{updateHead} (long h)
\item 
virtual void \hyperlink{classIGbE_1_1RxDescCache_aec7fdcc540223076999e0f8f07f854bc}{enableSm} ()
\item 
virtual void \hyperlink{classIGbE_1_1RxDescCache_abb8070fbcfa38a9697d92bbc4a0b6505}{fetchAfterWb} ()
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classIGbE_1_1RxDescCache_a0807bda2e863c4492ab0165135bf396c}{pktDone}
\item 
int \hyperlink{classIGbE_1_1RxDescCache_acdf18a76e0bed7bae532a2708fc559da}{splitCount}
\item 
unsigned \hyperlink{classIGbE_1_1RxDescCache_ac3c1fb8dcc0c6c83f6a85ef03c5047db}{bytesCopied}
\end{DoxyCompactItemize}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classIGbE_1_1RxDescCache_aa0df94c8316951374e466ed453451b26}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!RxDescCache@{RxDescCache}}
\index{RxDescCache@{RxDescCache}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{RxDescCache}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RxDescCache} ({\bf IGbE} $\ast$ {\em i}, \/  std::string {\em n}, \/  int {\em s})}}
\label{classIGbE_1_1RxDescCache_aa0df94c8316951374e466ed453451b26}



\begin{DoxyCode}
1195     : DescCache<RxDesc>(i, n, s), pktDone(false), splitCount(0), 
1196       pktEvent(this), pktHdrEvent(this), pktDataEvent(this)
1197 
1198 {
1199     annSmFetch = "RX Desc Fetch";
1200     annSmWb = "RX Desc Writeback";
1201     annUnusedDescQ = "RX Unused Descriptors";
1202     annUnusedCacheQ = "RX Unused Descriptor Cache";
1203     annUsedCacheQ = "RX Used Descriptor Cache";
1204     annUsedDescQ = "RX Used Descriptors";
1205     annDescQ = "RX Descriptors";
1206 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classIGbE_1_1RxDescCache_ae5a77c90557026fdf4fd78883f92bef9}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!descBase@{descBase}}
\index{descBase@{descBase}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{descBase}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Addr} descBase () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classIGbE_1_1RxDescCache_ae5a77c90557026fdf4fd78883f92bef9}


\hyperlink{classIGbE_1_1DescCache_aa8bdc83aee2be5e0eaa7a1f7f1f284e2}{DescCache$<$ iGbReg::RxDesc $>$}を実装しています。


\begin{DoxyCode}
340 { return igbe->regs.rdba(); }
\end{DoxyCode}
\hypertarget{classIGbE_1_1RxDescCache_af3d1877b6f30bdf98b95351c38d400f3}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!descHead@{descHead}}
\index{descHead@{descHead}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{descHead}]{\setlength{\rightskip}{0pt plus 5cm}virtual long descHead () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classIGbE_1_1RxDescCache_af3d1877b6f30bdf98b95351c38d400f3}


\hyperlink{classIGbE_1_1DescCache_af413050780b6b8b2fe0793fff12037e3}{DescCache$<$ iGbReg::RxDesc $>$}を実装しています。


\begin{DoxyCode}
341 { return igbe->regs.rdh(); }
\end{DoxyCode}
\hypertarget{classIGbE_1_1RxDescCache_a465e4e31be3a89db3d7f9cd1ecc40064}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!descLen@{descLen}}
\index{descLen@{descLen}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{descLen}]{\setlength{\rightskip}{0pt plus 5cm}virtual long descLen () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classIGbE_1_1RxDescCache_a465e4e31be3a89db3d7f9cd1ecc40064}


\hyperlink{classIGbE_1_1DescCache_a8eb35163568b01fa17aa47b23a80f90c}{DescCache$<$ iGbReg::RxDesc $>$}を実装しています。


\begin{DoxyCode}
342 { return igbe->regs.rdlen() >> 4; }
\end{DoxyCode}
\hypertarget{classIGbE_1_1RxDescCache_a4b6b769be62592fc43518ba480bbd1f7}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!descTail@{descTail}}
\index{descTail@{descTail}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{descTail}]{\setlength{\rightskip}{0pt plus 5cm}virtual long descTail () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classIGbE_1_1RxDescCache_a4b6b769be62592fc43518ba480bbd1f7}


\hyperlink{classIGbE_1_1DescCache_a88ebc5d9eb88ca9148465557e9a66c1c}{DescCache$<$ iGbReg::RxDesc $>$}を実装しています。


\begin{DoxyCode}
343 { return igbe->regs.rdt(); }
\end{DoxyCode}
\hypertarget{classIGbE_1_1RxDescCache_aec7fdcc540223076999e0f8f07f854bc}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!enableSm@{enableSm}}
\index{enableSm@{enableSm}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{enableSm}]{\setlength{\rightskip}{0pt plus 5cm}void enableSm ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classIGbE_1_1RxDescCache_aec7fdcc540223076999e0f8f07f854bc}


\hyperlink{classIGbE_1_1DescCache_a9b931707aadb26e13262c50e0dd87006}{DescCache$<$ iGbReg::RxDesc $>$}を実装しています。


\begin{DoxyCode}
1494 {
1495     if (!igbe->drainManager) {
1496         igbe->rxTick = true;
1497         igbe->restartClock();
1498     }
1499 }
\end{DoxyCode}
\hypertarget{classIGbE_1_1RxDescCache_abb8070fbcfa38a9697d92bbc4a0b6505}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!fetchAfterWb@{fetchAfterWb}}
\index{fetchAfterWb@{fetchAfterWb}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{fetchAfterWb}]{\setlength{\rightskip}{0pt plus 5cm}virtual void fetchAfterWb ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classIGbE_1_1RxDescCache_abb8070fbcfa38a9697d92bbc4a0b6505}


\hyperlink{classIGbE_1_1DescCache_abe568c102619a35d2aa1a37c64dff086}{DescCache$<$ iGbReg::RxDesc $>$}を実装しています。


\begin{DoxyCode}
346                                     {
347             if (!igbe->rxTick && igbe->getDrainState() == Drainable::Running)
348                 fetchDescriptors();
349         }
\end{DoxyCode}
\hypertarget{classIGbE_1_1RxDescCache_a2587421ae644a9474416e5a5b63ccbca}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!hasOutstandingEvents@{hasOutstandingEvents}}
\index{hasOutstandingEvents@{hasOutstandingEvents}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{hasOutstandingEvents}]{\setlength{\rightskip}{0pt plus 5cm}bool hasOutstandingEvents ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIGbE_1_1RxDescCache_a2587421ae644a9474416e5a5b63ccbca}


\hyperlink{classIGbE_1_1DescCache_a09989bc9720a200c8164dc1ef109d70b}{DescCache$<$ iGbReg::RxDesc $>$}を再定義しています。


\begin{DoxyCode}
1513 {
1514     return pktEvent.scheduled() || wbEvent.scheduled() ||
1515         fetchEvent.scheduled() || pktHdrEvent.scheduled() ||
1516         pktDataEvent.scheduled();
1517          
1518 }
\end{DoxyCode}
\hypertarget{classIGbE_1_1RxDescCache_a430d1dfdf7dcec48b02f69d6769acab6}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!packetDone@{packetDone}}
\index{packetDone@{packetDone}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{packetDone}]{\setlength{\rightskip}{0pt plus 5cm}bool packetDone ()}}
\label{classIGbE_1_1RxDescCache_a430d1dfdf7dcec48b02f69d6769acab6}
\hyperlink{classCheck}{Check} if the dma on the packet has completed and RX state machine can continue 


\begin{DoxyCode}
1503 {
1504     if (pktDone) {
1505         pktDone = false;
1506         return true;
1507     }
1508     return false;
1509 }
\end{DoxyCode}
\hypertarget{classIGbE_1_1RxDescCache_a4f0881be8aa8698e16dcf52a89085100}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!pktComplete@{pktComplete}}
\index{pktComplete@{pktComplete}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{pktComplete}]{\setlength{\rightskip}{0pt plus 5cm}void pktComplete ()}}
\label{classIGbE_1_1RxDescCache_a4f0881be8aa8698e16dcf52a89085100}
Called by event when dma to write packet is completed 


\begin{DoxyCode}
1333 {
1334     assert(unusedCache.size());
1335     RxDesc *desc;
1336     desc = unusedCache.front();
1337 
1338     igbe->anBegin("RXS", "Update Desc");
1339 
1340     uint16_t crcfixup = igbe->regs.rctl.secrc() ? 0 : 4 ;
1341     DPRINTF(EthernetDesc, "pktPtr->length: %d bytesCopied: %d "
1342             "stripcrc offset: %d value written: %d %d\n",
1343             pktPtr->length, bytesCopied, crcfixup,
1344             htole((uint16_t)(pktPtr->length + crcfixup)),
1345             (uint16_t)(pktPtr->length + crcfixup));
1346 
1347     // no support for anything but starting at 0
1348     assert(igbe->regs.rxcsum.pcss() == 0);
1349 
1350     DPRINTF(EthernetDesc, "Packet written to memory updating Descriptor\n");
1351 
1352     uint16_t status = RXDS_DD;
1353     uint8_t err = 0;
1354     uint16_t ext_err = 0;
1355     uint16_t csum = 0;
1356     uint16_t ptype = 0;
1357     uint16_t ip_id = 0;
1358 
1359     assert(bytesCopied <= pktPtr->length);
1360     if (bytesCopied == pktPtr->length)
1361         status |= RXDS_EOP;
1362 
1363     IpPtr ip(pktPtr);
1364 
1365     if (ip) {
1366         DPRINTF(EthernetDesc, "Proccesing Ip packet with Id=%d\n", ip->id());
1367         ptype |= RXDP_IPV4;
1368         ip_id = ip->id();
1369 
1370         if (igbe->regs.rxcsum.ipofld()) {
1371             DPRINTF(EthernetDesc, "Checking IP checksum\n");
1372             status |= RXDS_IPCS;
1373             csum = htole(cksum(ip));
1374             igbe->rxIpChecksums++;
1375             if (cksum(ip) != 0) {
1376                 err |= RXDE_IPE;
1377                 ext_err |= RXDEE_IPE;
1378                 DPRINTF(EthernetDesc, "Checksum is bad!!\n");
1379             }
1380         }
1381         TcpPtr tcp(ip);
1382         if (tcp && igbe->regs.rxcsum.tuofld()) {
1383             DPRINTF(EthernetDesc, "Checking TCP checksum\n");
1384             status |= RXDS_TCPCS;
1385             ptype |= RXDP_TCP;
1386             csum = htole(cksum(tcp));
1387             igbe->rxTcpChecksums++;
1388             if (cksum(tcp) != 0) {
1389                 DPRINTF(EthernetDesc, "Checksum is bad!!\n");
1390                 err |= RXDE_TCPE;
1391                 ext_err |= RXDEE_TCPE;
1392             }
1393         }
1394 
1395         UdpPtr udp(ip);
1396         if (udp && igbe->regs.rxcsum.tuofld()) {
1397             DPRINTF(EthernetDesc, "Checking UDP checksum\n");
1398             status |= RXDS_UDPCS;
1399             ptype |= RXDP_UDP;
1400             csum = htole(cksum(udp));
1401             igbe->rxUdpChecksums++;
1402             if (cksum(udp) != 0) {
1403                 DPRINTF(EthernetDesc, "Checksum is bad!!\n");
1404                 ext_err |= RXDEE_TCPE;
1405                 err |= RXDE_TCPE;
1406             }
1407         }
1408     } else { // if ip
1409         DPRINTF(EthernetSM, "Proccesing Non-Ip packet\n");
1410     }
1411 
1412     switch (igbe->regs.srrctl.desctype()) {
1413       case RXDT_LEGACY:
1414         desc->legacy.len = htole((uint16_t)(pktPtr->length + crcfixup));
1415         desc->legacy.status = htole(status);
1416         desc->legacy.errors = htole(err);
1417         // No vlan support at this point... just set it to 0
1418         desc->legacy.vlan = 0;
1419         break;
1420       case RXDT_ADV_SPLIT_A:
1421       case RXDT_ADV_ONEBUF:
1422         desc->adv_wb.rss_type = htole(0);
1423         desc->adv_wb.pkt_type = htole(ptype);
1424         if (igbe->regs.rxcsum.pcsd()) {
1425             // no rss support right now
1426             desc->adv_wb.rss_hash = htole(0);
1427         } else {
1428             desc->adv_wb.id = htole(ip_id);
1429             desc->adv_wb.csum = htole(csum);
1430         }
1431         desc->adv_wb.status = htole(status);
1432         desc->adv_wb.errors = htole(ext_err);
1433         // no vlan support
1434         desc->adv_wb.vlan_tag = htole(0); 
1435         break;
1436       default:
1437         panic("Unimplemnted RX receive buffer type %d\n",
1438               igbe->regs.srrctl.desctype());
1439     }
1440 
1441     DPRINTF(EthernetDesc, "Descriptor complete w0: %#x w1: %#x\n",
1442             desc->adv_read.pkt, desc->adv_read.hdr);
1443 
1444     if (bytesCopied == pktPtr->length) {
1445         DPRINTF(EthernetDesc,
1446                 "Packet completely written to descriptor buffers\n");
1447         // Deal with the rx timer interrupts
1448         if (igbe->regs.rdtr.delay()) {
1449             Tick delay = igbe->regs.rdtr.delay() * igbe->intClock();
1450             DPRINTF(EthernetSM, "RXS: Scheduling DTR for %d\n", delay);
1451             igbe->reschedule(igbe->rdtrEvent, curTick() + delay);
1452         }
1453 
1454         if (igbe->regs.radv.idv()) {
1455             Tick delay = igbe->regs.radv.idv() * igbe->intClock();
1456             DPRINTF(EthernetSM, "RXS: Scheduling ADV for %d\n", delay);
1457             if (!igbe->radvEvent.scheduled()) {
1458                 igbe->schedule(igbe->radvEvent, curTick() + delay);
1459             }
1460         }
1461 
1462         // if neither radv or rdtr, maybe itr is set...
1463         if (!igbe->regs.rdtr.delay() && !igbe->regs.radv.idv()) {
1464             DPRINTF(EthernetSM,
1465                     "RXS: Receive interrupt delay disabled, posting IT_RXT\n");
1466             igbe->postInterrupt(IT_RXT);
1467         }
1468 
1469         // If the packet is small enough, interrupt appropriately
1470         // I wonder if this is delayed or not?!
1471         if (pktPtr->length <= igbe->regs.rsrpd.idv()) {
1472             DPRINTF(EthernetSM,
1473                     "RXS: Posting IT_SRPD beacuse small packet received\n");
1474             igbe->postInterrupt(IT_SRPD);
1475         }
1476         bytesCopied = 0;
1477     }
1478 
1479     pktPtr = NULL;
1480     igbe->checkDrain();
1481     enableSm();
1482     pktDone = true;
1483 
1484     igbe->anBegin("RXS", "Done Updating Desc");
1485     DPRINTF(EthernetDesc, "Processing of this descriptor complete\n");
1486     igbe->anDq("RXS", annUnusedCacheQ);
1487     unusedCache.pop_front();
1488     igbe->anQ("RXS", annUsedCacheQ);
1489     usedCache.push_back(desc);
1490 }
\end{DoxyCode}
\hypertarget{classIGbE_1_1RxDescCache_a05f4f640320394e21432a2d1c2ce8edc}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!pktSplitDone@{pktSplitDone}}
\index{pktSplitDone@{pktSplitDone}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{pktSplitDone}]{\setlength{\rightskip}{0pt plus 5cm}void pktSplitDone ()}}
\label{classIGbE_1_1RxDescCache_a05f4f640320394e21432a2d1c2ce8edc}



\begin{DoxyCode}
1210 {
1211     splitCount++;
1212     DPRINTF(EthernetDesc,
1213             "Part of split packet done: splitcount now %d\n", splitCount);
1214     assert(splitCount <= 2);
1215     if (splitCount != 2)
1216         return;
1217     splitCount = 0;
1218     DPRINTF(EthernetDesc,
1219             "Part of split packet done: calling pktComplete()\n");
1220     pktComplete();
1221 }
\end{DoxyCode}
\hypertarget{classIGbE_1_1RxDescCache_a53e036786d17361be4c7320d39c99b84}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!serialize@{serialize}}
\index{serialize@{serialize}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIGbE_1_1RxDescCache_a53e036786d17361be4c7320d39c99b84}


\hyperlink{classIGbE_1_1DescCache_a53e036786d17361be4c7320d39c99b84}{DescCache$<$ iGbReg::RxDesc $>$}を再定義しています。


\begin{DoxyCode}
1522 {
1523     DescCache<RxDesc>::serialize(os);
1524     SERIALIZE_SCALAR(pktDone);
1525     SERIALIZE_SCALAR(splitCount);
1526     SERIALIZE_SCALAR(bytesCopied);
1527 }
\end{DoxyCode}
\hypertarget{classIGbE_1_1RxDescCache_af22e5d6d660b97db37003ac61ac4ee49}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classIGbE_1_1RxDescCache_af22e5d6d660b97db37003ac61ac4ee49}


\hyperlink{classIGbE_1_1DescCache_af22e5d6d660b97db37003ac61ac4ee49}{DescCache$<$ iGbReg::RxDesc $>$}を再定義しています。


\begin{DoxyCode}
1531 {
1532     DescCache<RxDesc>::unserialize(cp, section);
1533     UNSERIALIZE_SCALAR(pktDone);
1534     UNSERIALIZE_SCALAR(splitCount);
1535     UNSERIALIZE_SCALAR(bytesCopied);
1536 }
\end{DoxyCode}
\hypertarget{classIGbE_1_1RxDescCache_a4f8dbb4f64167626cac110753708c55c}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!updateHead@{updateHead}}
\index{updateHead@{updateHead}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{updateHead}]{\setlength{\rightskip}{0pt plus 5cm}virtual void updateHead (long {\em h})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classIGbE_1_1RxDescCache_a4f8dbb4f64167626cac110753708c55c}


\hyperlink{classIGbE_1_1DescCache_af48912789332a0283480cd85c7197f15}{DescCache$<$ iGbReg::RxDesc $>$}を実装しています。


\begin{DoxyCode}
344 { igbe->regs.rdh(h); }
\end{DoxyCode}
\hypertarget{classIGbE_1_1RxDescCache_a3e213f353f926628fed12519b96f1b47}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!writePacket@{writePacket}}
\index{writePacket@{writePacket}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{writePacket}]{\setlength{\rightskip}{0pt plus 5cm}int writePacket ({\bf EthPacketPtr} {\em packet}, \/  int {\em pkt\_\-offset})}}
\label{classIGbE_1_1RxDescCache_a3e213f353f926628fed12519b96f1b47}
Write the given packet into the buffer(s) pointed to by the descriptor and update the book keeping. Should only be called when there are no dma's pending. 
\begin{DoxyParams}{引数}
\item[{\em packet}]ethernet packet to write \item[{\em pkt\_\-offset}]bytes already copied from the packet to memory \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
pkt\_\-offset + number of bytes copied during this call 
\end{DoxyReturn}



\begin{DoxyCode}
1225 {
1226     assert(unusedCache.size());
1227     //if (!unusedCache.size())
1228     //    return false;
1229 
1230     pktPtr = packet;
1231     pktDone = false;
1232     unsigned buf_len, hdr_len;
1233 
1234     RxDesc *desc = unusedCache.front();
1235     switch (igbe->regs.srrctl.desctype()) {
1236       case RXDT_LEGACY:
1237         assert(pkt_offset == 0);
1238         bytesCopied = packet->length;
1239         DPRINTF(EthernetDesc, "Packet Length: %d Desc Size: %d\n",
1240                 packet->length, igbe->regs.rctl.descSize());
1241         assert(packet->length < igbe->regs.rctl.descSize());
1242         igbe->dmaWrite(pciToDma(desc->legacy.buf),
1243                        packet->length, &pktEvent, packet->data,
1244                        igbe->rxWriteDelay);
1245         break;
1246       case RXDT_ADV_ONEBUF:
1247         assert(pkt_offset == 0);
1248         bytesCopied = packet->length;
1249         buf_len = igbe->regs.rctl.lpe() ? igbe->regs.srrctl.bufLen() :
1250             igbe->regs.rctl.descSize();
1251         DPRINTF(EthernetDesc, "Packet Length: %d srrctl: %#x Desc Size: %d\n",
1252                 packet->length, igbe->regs.srrctl(), buf_len);
1253         assert(packet->length < buf_len);
1254         igbe->dmaWrite(pciToDma(desc->adv_read.pkt),
1255                        packet->length, &pktEvent, packet->data,
1256                        igbe->rxWriteDelay);
1257         desc->adv_wb.header_len = htole(0);
1258         desc->adv_wb.sph = htole(0);
1259         desc->adv_wb.pkt_len = htole((uint16_t)(pktPtr->length));
1260         break;
1261       case RXDT_ADV_SPLIT_A:
1262         int split_point;
1263         
1264         buf_len = igbe->regs.rctl.lpe() ? igbe->regs.srrctl.bufLen() :
1265             igbe->regs.rctl.descSize();
1266         hdr_len = igbe->regs.rctl.lpe() ? igbe->regs.srrctl.hdrLen() : 0; 
1267         DPRINTF(EthernetDesc,
1268                 "lpe: %d Packet Length: %d offset: %d srrctl: %#x "
1269                 "hdr addr: %#x Hdr Size: %d desc addr: %#x Desc Size: %d\n",
1270                 igbe->regs.rctl.lpe(), packet->length, pkt_offset,
1271                 igbe->regs.srrctl(), desc->adv_read.hdr, hdr_len,
1272                 desc->adv_read.pkt, buf_len);
1273 
1274         split_point = hsplit(pktPtr);
1275 
1276         if (packet->length <= hdr_len) {
1277             bytesCopied = packet->length;
1278             assert(pkt_offset == 0);
1279             DPRINTF(EthernetDesc, "Hdr split: Entire packet in header\n");
1280             igbe->dmaWrite(pciToDma(desc->adv_read.hdr),
1281                            packet->length, &pktEvent, packet->data,
1282                            igbe->rxWriteDelay);
1283             desc->adv_wb.header_len = htole((uint16_t)packet->length);
1284             desc->adv_wb.sph = htole(0);
1285             desc->adv_wb.pkt_len = htole(0);
1286         } else if (split_point) {
1287             if (pkt_offset) {
1288                 // we are only copying some data, header/data has already been
1289                 // copied
1290                 int max_to_copy =
1291                     std::min(packet->length - pkt_offset, buf_len);
1292                 bytesCopied += max_to_copy;
1293                 DPRINTF(EthernetDesc,
1294                         "Hdr split: Continuing data buffer copy\n");
1295                 igbe->dmaWrite(pciToDma(desc->adv_read.pkt),
1296                                max_to_copy, &pktEvent,
1297                                packet->data + pkt_offset, igbe->rxWriteDelay);
1298                 desc->adv_wb.header_len = htole(0);
1299                 desc->adv_wb.pkt_len = htole((uint16_t)max_to_copy);
1300                 desc->adv_wb.sph = htole(0);
1301             } else {
1302                 int max_to_copy =
1303                     std::min(packet->length - split_point, buf_len);
1304                 bytesCopied += max_to_copy + split_point;
1305                 
1306                 DPRINTF(EthernetDesc, "Hdr split: splitting at %d\n",
1307                         split_point);
1308                 igbe->dmaWrite(pciToDma(desc->adv_read.hdr),
1309                                split_point, &pktHdrEvent,
1310                                packet->data, igbe->rxWriteDelay);
1311                 igbe->dmaWrite(pciToDma(desc->adv_read.pkt),
1312                                max_to_copy, &pktDataEvent,
1313                                packet->data + split_point, igbe->rxWriteDelay);
1314                 desc->adv_wb.header_len = htole(split_point);
1315                 desc->adv_wb.sph = 1;
1316                 desc->adv_wb.pkt_len = htole((uint16_t)(max_to_copy));
1317             }
1318         } else {
1319             panic("Header split not fitting within header buffer or "
1320                   "undecodable packet not fitting in header unsupported\n");
1321         }
1322         break;
1323       default:
1324         panic("Unimplemnted RX receive buffer type: %d\n",
1325               igbe->regs.srrctl.desctype());
1326     }
1327     return bytesCopied;
1328 
1329 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classIGbE_1_1RxDescCache_ac3c1fb8dcc0c6c83f6a85ef03c5047db}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!bytesCopied@{bytesCopied}}
\index{bytesCopied@{bytesCopied}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{bytesCopied}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf bytesCopied}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1RxDescCache_ac3c1fb8dcc0c6c83f6a85ef03c5047db}
Bytes of packet that have been copied, so we know when to set EOP \hypertarget{classIGbE_1_1RxDescCache_a80533f1573c797ab5f5333d376e899c7}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!pktDataEvent@{pktDataEvent}}
\index{pktDataEvent@{pktDataEvent}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{pktDataEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf RxDescCache}, \&RxDescCache::pktSplitDone$>$ {\bf pktDataEvent}}}
\label{classIGbE_1_1RxDescCache_a80533f1573c797ab5f5333d376e899c7}
\hypertarget{classIGbE_1_1RxDescCache_a0807bda2e863c4492ab0165135bf396c}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!pktDone@{pktDone}}
\index{pktDone@{pktDone}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{pktDone}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf pktDone}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1RxDescCache_a0807bda2e863c4492ab0165135bf396c}
\hypertarget{classIGbE_1_1RxDescCache_a28964c300d774b0dc1d7cabcff1cdc7b}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!pktEvent@{pktEvent}}
\index{pktEvent@{pktEvent}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{pktEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf RxDescCache}, \&RxDescCache::pktComplete$>$ {\bf pktEvent}}}
\label{classIGbE_1_1RxDescCache_a28964c300d774b0dc1d7cabcff1cdc7b}
\hypertarget{classIGbE_1_1RxDescCache_aa1e4265fed174c3f3f46281e329a45de}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!pktHdrEvent@{pktHdrEvent}}
\index{pktHdrEvent@{pktHdrEvent}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{pktHdrEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventWrapper}$<${\bf RxDescCache}, \&RxDescCache::pktSplitDone$>$ {\bf pktHdrEvent}}}
\label{classIGbE_1_1RxDescCache_aa1e4265fed174c3f3f46281e329a45de}
\hypertarget{classIGbE_1_1RxDescCache_acdf18a76e0bed7bae532a2708fc559da}{
\index{IGbE::RxDescCache@{IGbE::RxDescCache}!splitCount@{splitCount}}
\index{splitCount@{splitCount}!IGbE::RxDescCache@{IGbE::RxDescCache}}
\subsubsection[{splitCount}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf splitCount}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classIGbE_1_1RxDescCache_acdf18a76e0bed7bae532a2708fc559da}
Variable to head with header/data completion events 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/\hyperlink{i8254xGBe_8hh}{i8254xGBe.hh}\item 
dev/\hyperlink{i8254xGBe_8cc}{i8254xGBe.cc}\end{DoxyCompactItemize}
