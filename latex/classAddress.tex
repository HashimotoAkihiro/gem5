\hypertarget{classAddress}{
\section{クラス Address}
\label{classAddress}\index{Address@{Address}}
}


{\ttfamily \#include $<$Address.hh$>$}\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classAddress_ac98de6c9250be1b4e3446d9989e058b3}{Address} ()
\item 
\hyperlink{classAddress_ab13b386b7f0bf74bab346a3f2cbde303}{Address} (\hyperlink{TypeDefines_8hh_a7901e1a365850c5ff38ec6e12b6b9ffc}{physical\_\-address\_\-t} address)
\item 
\hyperlink{classAddress_a3e2381cefd37090be9fda7e97116fe20}{Address} (const \hyperlink{classAddress}{Address} \&obj)
\item 
\hyperlink{classAddress}{Address} \& \hyperlink{classAddress_aa1132891400c01bf7857fb1cf4e55a25}{operator=} (const \hyperlink{classAddress}{Address} \&obj)
\item 
void \hyperlink{classAddress_a8febae9cef6a5c73aee5c73af61afc48}{setAddress} (\hyperlink{TypeDefines_8hh_a7901e1a365850c5ff38ec6e12b6b9ffc}{physical\_\-address\_\-t} address)
\item 
\hyperlink{TypeDefines_8hh_a7901e1a365850c5ff38ec6e12b6b9ffc}{physical\_\-address\_\-t} \hyperlink{classAddress_aa5c44fe637d09a708d70c4a689840cd0}{getAddress} () const 
\item 
\hyperlink{TypeDefines_8hh_a7901e1a365850c5ff38ec6e12b6b9ffc}{physical\_\-address\_\-t} \hyperlink{classAddress_a22669386ccc1e2491c7c46f55c37a038}{bitSelect} (unsigned int small, unsigned int big) const 
\item 
\hyperlink{TypeDefines_8hh_a7901e1a365850c5ff38ec6e12b6b9ffc}{physical\_\-address\_\-t} \hyperlink{classAddress_a3915ce6c78db893a57a516943f9796d1}{bitRemove} (unsigned int small, unsigned int big) const 
\item 
\hyperlink{TypeDefines_8hh_a7901e1a365850c5ff38ec6e12b6b9ffc}{physical\_\-address\_\-t} \hyperlink{classAddress_a9f50b73bd84b2fa8566f66416a04a1df}{maskLowOrderBits} (unsigned int number) const 
\item 
\hyperlink{TypeDefines_8hh_a7901e1a365850c5ff38ec6e12b6b9ffc}{physical\_\-address\_\-t} \hyperlink{classAddress_a81d4d297d2670a5d60ea08d23b2c7f96}{maskHighOrderBits} (unsigned int number) const 
\item 
\hyperlink{TypeDefines_8hh_a7901e1a365850c5ff38ec6e12b6b9ffc}{physical\_\-address\_\-t} \hyperlink{classAddress_a146a23f7187a79982f77b143db52835f}{shiftLowOrderBits} (unsigned int number) const 
\item 
\hyperlink{TypeDefines_8hh_a7901e1a365850c5ff38ec6e12b6b9ffc}{physical\_\-address\_\-t} \hyperlink{classAddress_a3d5e121d4366c4cba97dbb38ad2f8b00}{getLineAddress} () const 
\item 
\hyperlink{TypeDefines_8hh_a7901e1a365850c5ff38ec6e12b6b9ffc}{physical\_\-address\_\-t} \hyperlink{classAddress_a7f7b431504ce24277fd98a99a51e7865}{getOffset} () const 
\item 
void \hyperlink{classAddress_a16ec7c723f772ab7bee0af7d2e7a4305}{makeLineAddress} ()
\item 
void \hyperlink{classAddress_a9887a46e51d7ee63cc947dcdb0b29da3}{makePageAddress} ()
\item 
void \hyperlink{classAddress_a2cff729156aa38b416f0d32cea14977b}{makeNextStrideAddress} (int stride)
\item 
\hyperlink{TypeDefines_8hh_a39642de41f3574937f399f4fab25ba18}{Index} \hyperlink{classAddress_a90f2c61fd9821553b17cdf29d5a3c662}{memoryModuleIndex} () const 
\item 
void \hyperlink{classAddress_ac55fe386a101fbae38c716067c9966a0}{print} (std::ostream \&out) const 
\item 
void \hyperlink{classAddress_ad219174fdc50e934776bd97403903d00}{output} (std::ostream \&out) const 
\item 
void \hyperlink{classAddress_a62ef2ea8dd5db08546872dab6ed957ff}{input} (std::istream \&in)
\item 
void \hyperlink{classAddress_a360f28b444fb8f8ee6db216f80a54248}{setOffset} (int offset)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{TypeDefines_8hh_a7901e1a365850c5ff38ec6e12b6b9ffc}{physical\_\-address\_\-t} \hyperlink{classAddress_a854e037cfd8d3493a1770258559bf1b0}{m\_\-address}
\end{DoxyCompactItemize}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classAddress_ac98de6c9250be1b4e3446d9989e058b3}{
\index{Address@{Address}!Address@{Address}}
\index{Address@{Address}!Address@{Address}}
\subsubsection[{Address}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddress_ac98de6c9250be1b4e3446d9989e058b3}



\begin{DoxyCode}
49         : m_address(0)
50     { }
\end{DoxyCode}
\hypertarget{classAddress_ab13b386b7f0bf74bab346a3f2cbde303}{
\index{Address@{Address}!Address@{Address}}
\index{Address@{Address}!Address@{Address}}
\subsubsection[{Address}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} ({\bf physical\_\-address\_\-t} {\em address})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, explicit\mbox{]}}}}
\label{classAddress_ab13b386b7f0bf74bab346a3f2cbde303}



\begin{DoxyCode}
54         : m_address(address)
55     { }
\end{DoxyCode}
\hypertarget{classAddress_a3e2381cefd37090be9fda7e97116fe20}{
\index{Address@{Address}!Address@{Address}}
\index{Address@{Address}!Address@{Address}}
\subsubsection[{Address}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} (const {\bf Address} \& {\em obj})}}
\label{classAddress_a3e2381cefd37090be9fda7e97116fe20}



\begin{DoxyCode}
124 {
125     m_address = obj.m_address;
126 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classAddress_a3915ce6c78db893a57a516943f9796d1}{
\index{Address@{Address}!bitRemove@{bitRemove}}
\index{bitRemove@{bitRemove}!Address@{Address}}
\subsubsection[{bitRemove}]{\setlength{\rightskip}{0pt plus 5cm}{\bf physical\_\-address\_\-t} bitRemove (unsigned int {\em small}, \/  unsigned int {\em big}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddress_a3915ce6c78db893a57a516943f9796d1}



\begin{DoxyCode}
147 {
148     physical_address_t mask;
149     assert(big >= small);
150 
151     if (small >= ADDRESS_WIDTH - 1) {
152         return m_address;
153     } else if (big >= ADDRESS_WIDTH - 1) {
154         mask = (physical_address_t)~0 >> small;
155         return (m_address & mask);
156     } else if (small == 0) {
157         mask = (physical_address_t)~0 << big;
158         return (m_address & mask);
159     } else {
160         mask = ~((physical_address_t)~0 << small);
161         physical_address_t lower_bits = m_address & mask;
162         mask = (physical_address_t)~0 << (big + 1);
163         physical_address_t higher_bits = m_address & mask;
164 
165         // Shift the valid high bits over the removed section
166         higher_bits = higher_bits >> (big - small + 1);
167         return (higher_bits | lower_bits);
168     }
169 }
\end{DoxyCode}
\hypertarget{classAddress_a22669386ccc1e2491c7c46f55c37a038}{
\index{Address@{Address}!bitSelect@{bitSelect}}
\index{bitSelect@{bitSelect}!Address@{Address}}
\subsubsection[{bitSelect}]{\setlength{\rightskip}{0pt plus 5cm}{\bf physical\_\-address\_\-t} bitSelect (unsigned int {\em small}, \/  unsigned int {\em big}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddress_a22669386ccc1e2491c7c46f55c37a038}



\begin{DoxyCode}
130 {
131     physical_address_t mask;
132     assert(big >= small);
133 
134     if (big >= ADDRESS_WIDTH - 1) {
135         return (m_address >> small);
136     } else {
137         mask = ~((physical_address_t)~0 << (big + 1));
138         // FIXME - this is slow to manipulate a 64-bit number using 32-bits
139         physical_address_t partial = (m_address & mask);
140         return (partial >> small);
141     }
142 }
\end{DoxyCode}
\hypertarget{classAddress_aa5c44fe637d09a708d70c4a689840cd0}{
\index{Address@{Address}!getAddress@{getAddress}}
\index{getAddress@{getAddress}!Address@{Address}}
\subsubsection[{getAddress}]{\setlength{\rightskip}{0pt plus 5cm}{\bf physical\_\-address\_\-t} getAddress () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddress_aa5c44fe637d09a708d70c4a689840cd0}



\begin{DoxyCode}
61 {return m_address;}
\end{DoxyCode}
\hypertarget{classAddress_a3d5e121d4366c4cba97dbb38ad2f8b00}{
\index{Address@{Address}!getLineAddress@{getLineAddress}}
\index{getLineAddress@{getLineAddress}!Address@{Address}}
\subsubsection[{getLineAddress}]{\setlength{\rightskip}{0pt plus 5cm}{\bf physical\_\-address\_\-t} getLineAddress () const}}
\label{classAddress_a3d5e121d4366c4cba97dbb38ad2f8b00}



\begin{DoxyCode}
36 {
37     return bitSelect(RubySystem::getBlockSizeBits(), ADDRESS_WIDTH);
38 }
\end{DoxyCode}
\hypertarget{classAddress_a7f7b431504ce24277fd98a99a51e7865}{
\index{Address@{Address}!getOffset@{getOffset}}
\index{getOffset@{getOffset}!Address@{Address}}
\subsubsection[{getOffset}]{\setlength{\rightskip}{0pt plus 5cm}{\bf physical\_\-address\_\-t} getOffset () const}}
\label{classAddress_a7f7b431504ce24277fd98a99a51e7865}



\begin{DoxyCode}
42 {
43     return bitSelect(0, RubySystem::getBlockSizeBits() - 1);
44 }
\end{DoxyCode}
\hypertarget{classAddress_a62ef2ea8dd5db08546872dab6ed957ff}{
\index{Address@{Address}!input@{input}}
\index{input@{input}!Address@{Address}}
\subsubsection[{input}]{\setlength{\rightskip}{0pt plus 5cm}void input (std::istream \& {\em in})}}
\label{classAddress_a62ef2ea8dd5db08546872dab6ed957ff}



\begin{DoxyCode}
115 {
116     // Note: this only works with addresses in the form "ffff", not
117     // "0xffff".  This code should always be able to read in addresses
118     // written out by the above output() method.  Please don't change
119     // this without talking to Milo first.
120     in >> std::hex >> m_address >> std::dec;
121 }
\end{DoxyCode}
\hypertarget{classAddress_a16ec7c723f772ab7bee0af7d2e7a4305}{
\index{Address@{Address}!makeLineAddress@{makeLineAddress}}
\index{makeLineAddress@{makeLineAddress}!Address@{Address}}
\subsubsection[{makeLineAddress}]{\setlength{\rightskip}{0pt plus 5cm}void makeLineAddress ()}}
\label{classAddress_a16ec7c723f772ab7bee0af7d2e7a4305}



\begin{DoxyCode}
48 {
49     m_address = maskLowOrderBits(RubySystem::getBlockSizeBits());
50 }
\end{DoxyCode}
\hypertarget{classAddress_a2cff729156aa38b416f0d32cea14977b}{
\index{Address@{Address}!makeNextStrideAddress@{makeNextStrideAddress}}
\index{makeNextStrideAddress@{makeNextStrideAddress}!Address@{Address}}
\subsubsection[{makeNextStrideAddress}]{\setlength{\rightskip}{0pt plus 5cm}void makeNextStrideAddress (int {\em stride})}}
\label{classAddress_a2cff729156aa38b416f0d32cea14977b}



\begin{DoxyCode}
55 {
56     m_address = maskLowOrderBits(RubySystem::getBlockSizeBits())
57         + RubySystem::getBlockSizeBytes()*stride;
58 }
\end{DoxyCode}
\hypertarget{classAddress_a9887a46e51d7ee63cc947dcdb0b29da3}{
\index{Address@{Address}!makePageAddress@{makePageAddress}}
\index{makePageAddress@{makePageAddress}!Address@{Address}}
\subsubsection[{makePageAddress}]{\setlength{\rightskip}{0pt plus 5cm}void makePageAddress ()}}
\label{classAddress_a9887a46e51d7ee63cc947dcdb0b29da3}



\begin{DoxyCode}
141 {
142     m_address = maskLowOrderBits(TheISA::LogVMPageSize);
143 }
\end{DoxyCode}
\hypertarget{classAddress_a81d4d297d2670a5d60ea08d23b2c7f96}{
\index{Address@{Address}!maskHighOrderBits@{maskHighOrderBits}}
\index{maskHighOrderBits@{maskHighOrderBits}!Address@{Address}}
\subsubsection[{maskHighOrderBits}]{\setlength{\rightskip}{0pt plus 5cm}{\bf physical\_\-address\_\-t} maskHighOrderBits (unsigned int {\em number}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddress_a81d4d297d2670a5d60ea08d23b2c7f96}



\begin{DoxyCode}
186 {
187     physical_address_t mask;
188 
189     if (number >= ADDRESS_WIDTH - 1) {
190         mask = ~0;
191     } else {
192         mask = (physical_address_t)~0 >> number;
193     }
194     return (m_address & mask);
195 }
\end{DoxyCode}
\hypertarget{classAddress_a9f50b73bd84b2fa8566f66416a04a1df}{
\index{Address@{Address}!maskLowOrderBits@{maskLowOrderBits}}
\index{maskLowOrderBits@{maskLowOrderBits}!Address@{Address}}
\subsubsection[{maskLowOrderBits}]{\setlength{\rightskip}{0pt plus 5cm}{\bf physical\_\-address\_\-t} maskLowOrderBits (unsigned int {\em number}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddress_a9f50b73bd84b2fa8566f66416a04a1df}



\begin{DoxyCode}
173 {
174   physical_address_t mask;
175 
176   if (number >= ADDRESS_WIDTH - 1) {
177       mask = ~0;
178   } else {
179       mask = (physical_address_t)~0 << number;
180   }
181   return (m_address & mask);
182 }
\end{DoxyCode}
\hypertarget{classAddress_a90f2c61fd9821553b17cdf29d5a3c662}{
\index{Address@{Address}!memoryModuleIndex@{memoryModuleIndex}}
\index{memoryModuleIndex@{memoryModuleIndex}!Address@{Address}}
\subsubsection[{memoryModuleIndex}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Index} memoryModuleIndex () const}}
\label{classAddress_a90f2c61fd9821553b17cdf29d5a3c662}



\begin{DoxyCode}
62 {
63     Index index =
64         bitSelect(RubySystem::getBlockSizeBits() +
65                   RubySystem::getMemorySizeBits(), ADDRESS_WIDTH);
66     assert (index >= 0);
67     return index;
68 
69     // Index indexHighPortion =
70     //     address.bitSelect(MEMORY_SIZE_BITS - 1,
71     //                       PAGE_SIZE_BITS + NUMBER_OF_MEMORY_MODULE_BITS);
72     // Index indexLowPortion =
73     //     address.bitSelect(DATA_BLOCK_BITS, PAGE_SIZE_BITS - 1);
74     //
75     // Index index = indexLowPortion |
76     //     (indexHighPortion << (PAGE_SIZE_BITS - DATA_BLOCK_BITS));
77 
78     /*
79       Round-robin mapping of addresses, at page size granularity
80 
81 ADDRESS_WIDTH    MEMORY_SIZE_BITS        PAGE_SIZE_BITS  DATA_BLOCK_BITS
82   |                    |                       |               |
83  \ /                  \ /                     \ /             \ /       0
84   -----------------------------------------------------------------------
85   |       unused        |xxxxxxxxxxxxxxx|       |xxxxxxxxxxxxxxx|       |
86   |                     |xxxxxxxxxxxxxxx|       |xxxxxxxxxxxxxxx|       |
87   -----------------------------------------------------------------------
88                         indexHighPortion         indexLowPortion
89                                         <------->
90                                NUMBER_OF_MEMORY_MODULE_BITS
91     */
92 }
\end{DoxyCode}
\hypertarget{classAddress_aa1132891400c01bf7857fb1cf4e55a25}{
\index{Address@{Address}!operator=@{operator=}}
\index{operator=@{operator=}!Address@{Address}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Address} \& operator= (const {\bf Address} \& {\em obj})}}
\label{classAddress_aa1132891400c01bf7857fb1cf4e55a25}



\begin{DoxyCode}
130 {
131     if (this == &obj) {
132         // assert(false);
133     } else {
134         m_address = obj.m_address;
135     }
136     return *this;
137 }
\end{DoxyCode}
\hypertarget{classAddress_ad219174fdc50e934776bd97403903d00}{
\index{Address@{Address}!output@{output}}
\index{output@{output}!Address@{Address}}
\subsubsection[{output}]{\setlength{\rightskip}{0pt plus 5cm}void output (std::ostream \& {\em out}) const}}
\label{classAddress_ad219174fdc50e934776bd97403903d00}



\begin{DoxyCode}
105 {
106     // Note: this outputs addresses in the form "ffff", not "0xffff".
107     // This code should always be able to write out addresses in a
108     // format that can be read in by the below input() method.  Please
109     // don't change this without talking to Milo first.
110     out << std::hex << m_address << std::dec;
111 }
\end{DoxyCode}
\hypertarget{classAddress_ac55fe386a101fbae38c716067c9966a0}{
\index{Address@{Address}!print@{print}}
\index{print@{print}!Address@{Address}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}void print (std::ostream \& {\em out}) const}}
\label{classAddress_ac55fe386a101fbae38c716067c9966a0}



\begin{DoxyCode}
96 {
97     using namespace std;
98     out << "[" << hex << "0x" << m_address << "," << " line 0x"
99         << maskLowOrderBits(RubySystem::getBlockSizeBits()) << dec << "]"
100         << flush;
101 }
\end{DoxyCode}
\hypertarget{classAddress_a8febae9cef6a5c73aee5c73af61afc48}{
\index{Address@{Address}!setAddress@{setAddress}}
\index{setAddress@{setAddress}!Address@{Address}}
\subsubsection[{setAddress}]{\setlength{\rightskip}{0pt plus 5cm}void setAddress ({\bf physical\_\-address\_\-t} {\em address})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddress_a8febae9cef6a5c73aee5c73af61afc48}



\begin{DoxyCode}
60 { m_address = address; }
\end{DoxyCode}
\hypertarget{classAddress_a360f28b444fb8f8ee6db216f80a54248}{
\index{Address@{Address}!setOffset@{setOffset}}
\index{setOffset@{setOffset}!Address@{Address}}
\subsubsection[{setOffset}]{\setlength{\rightskip}{0pt plus 5cm}void setOffset (int {\em offset})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddress_a360f28b444fb8f8ee6db216f80a54248}



\begin{DoxyCode}
83     {
84         // first, zero out the offset bits
85         makeLineAddress();
86         m_address |= (physical_address_t) offset;
87     }
\end{DoxyCode}
\hypertarget{classAddress_a146a23f7187a79982f77b143db52835f}{
\index{Address@{Address}!shiftLowOrderBits@{shiftLowOrderBits}}
\index{shiftLowOrderBits@{shiftLowOrderBits}!Address@{Address}}
\subsubsection[{shiftLowOrderBits}]{\setlength{\rightskip}{0pt plus 5cm}{\bf physical\_\-address\_\-t} shiftLowOrderBits (unsigned int {\em number}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classAddress_a146a23f7187a79982f77b143db52835f}



\begin{DoxyCode}
199 {
200     return (m_address >> number);
201 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classAddress_a854e037cfd8d3493a1770258559bf1b0}{
\index{Address@{Address}!m\_\-address@{m\_\-address}}
\index{m\_\-address@{m\_\-address}!Address@{Address}}
\subsubsection[{m\_\-address}]{\setlength{\rightskip}{0pt plus 5cm}{\bf physical\_\-address\_\-t} {\bf m\_\-address}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classAddress_a854e037cfd8d3493a1770258559bf1b0}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/ruby/common/\hyperlink{Address_8hh}{Address.hh}\item 
mem/ruby/common/\hyperlink{Address_8cc}{Address.cc}\end{DoxyCompactItemize}
