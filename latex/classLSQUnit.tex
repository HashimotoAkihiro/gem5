\hypertarget{classLSQUnit}{
\section{クラス テンプレート LSQUnit$<$ Impl $>$}
\label{classLSQUnit}\index{LSQUnit@{LSQUnit}}
}


{\ttfamily \#include $<$lsq\_\-unit.hh$>$}\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classLSQUnit_1_1LSQSenderState}{LSQSenderState}
\item 
struct \hyperlink{structLSQUnit_1_1SQEntry}{SQEntry}
\item 
class \hyperlink{classLSQUnit_1_1WritebackEvent}{WritebackEvent}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef Impl::O3CPU \hyperlink{classLSQUnit_a44622cf06940413482836cb62931ac3f}{O3CPU}
\item 
typedef Impl::DynInstPtr \hyperlink{classLSQUnit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}
\item 
typedef Impl::CPUPol::IEW \hyperlink{classLSQUnit_a23f60a4095b5240dfcb18a4ec40210a9}{IEW}
\item 
typedef Impl::CPUPol::LSQ \hyperlink{classLSQUnit_acf05a3db8421d1ca800c285cf9a86301}{LSQ}
\item 
typedef Impl::CPUPol::IssueStruct \hyperlink{classLSQUnit_aa56c7524890b3a6337668c507be0f272}{IssueStruct}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classLSQUnit_a0b23136c4d1c97aab007aa60e707763b}{LSQUnit} ()
\item 
void \hyperlink{classLSQUnit_a45b3b65ba551c17c3b200db265611a4c}{init} (\hyperlink{classLSQUnit_a44622cf06940413482836cb62931ac3f}{O3CPU} $\ast$cpu\_\-ptr, \hyperlink{classLSQUnit_a23f60a4095b5240dfcb18a4ec40210a9}{IEW} $\ast$iew\_\-ptr, DerivO3CPUParams $\ast$params, \hyperlink{classLSQ}{LSQ} $\ast$lsq\_\-ptr, unsigned maxLQEntries, unsigned maxSQEntries, unsigned id)
\item 
std::string \hyperlink{classLSQUnit_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classLSQUnit_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classLSQUnit_a8d77cc755c7a424f4eb80130fb627012}{setDcachePort} (\hyperlink{classMasterPort}{MasterPort} $\ast$dcache\_\-port)
\item 
void \hyperlink{classLSQUnit_a0240eb42fa57fe5d3788093f62b77347}{drainSanityCheck} () const 
\item 
void \hyperlink{classLSQUnit_a8674059ce345e23aac5086b2c3e24a43}{takeOverFrom} ()
\item 
void \hyperlink{classLSQUnit_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\item 
void \hyperlink{classLSQUnit_a773e88db1aa010c3755e603493bf40ec}{insert} (\hyperlink{classLSQUnit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classLSQUnit_ad22b3ecafed2bcd9c59fcab049a1cb98}{insertLoad} (\hyperlink{classLSQUnit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&load\_\-inst)
\item 
void \hyperlink{classLSQUnit_a6a4b4e51bfff3639932ebaba45e8a282}{insertStore} (\hyperlink{classLSQUnit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&store\_\-inst)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classLSQUnit_a15239c5725d8744a793c867193e4bce7}{checkViolations} (int load\_\-idx, \hyperlink{classLSQUnit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classLSQUnit_a35b89a864d3af33a4b045b7fe0aa6b5a}{checkSnoop} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classLSQUnit_a30c6332142c2ecca389ed6ee463c692b}{executeLoad} (\hyperlink{classLSQUnit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classLSQUnit_a091a4d1788ce66e51ceb888bbd85ac08}{executeLoad} (int lq\_\-idx)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classLSQUnit_aad78b8a37ee5c61e47df58dd39980340}{executeStore} (\hyperlink{classLSQUnit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classLSQUnit_a8ddd26e169a62ec5ae591a9f95934839}{commitLoad} ()
\item 
void \hyperlink{classLSQUnit_a1ae517a923a864a4e3a5aa1eeb2dd2d6}{commitLoads} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&youngest\_\-inst)
\item 
void \hyperlink{classLSQUnit_a954ce1ce58b67cae49ba127d5ea40701}{commitStores} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&youngest\_\-inst)
\item 
void \hyperlink{classLSQUnit_a5f04e29d6f6feb8b86460491f2ba7547}{writebackStores} ()
\item 
void \hyperlink{classLSQUnit_a0f7f0d3412bbf494cd3d0c0f48e5fcf2}{completeDataAccess} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classLSQUnit_ae3af532345dbe6519e8272d9cd677230}{clearLQ} ()
\item 
void \hyperlink{classLSQUnit_a171cd7891063f418b1ee217f5c03537b}{clearSQ} ()
\item 
void \hyperlink{classLSQUnit_a3bc9500810cb2d5615e29206e2d6499f}{resizeLQ} (unsigned size)
\item 
void \hyperlink{classLSQUnit_a341dd6a3bd8d240659fd9d698c3b5c65}{resizeSQ} (unsigned size)
\item 
void \hyperlink{classLSQUnit_a51dd7e304d5413447717826fac6f4921}{squash} (const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&squashed\_\-num)
\item 
bool \hyperlink{classLSQUnit_a4f720bbfb5fdefdb23516500eeb0b4de}{violation} ()
\item 
\hyperlink{classLSQUnit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classLSQUnit_a30adaf6f5fb6b38b5747f35c419e3f31}{getMemDepViolator} ()
\item 
bool \hyperlink{classLSQUnit_a05c413ba417c6453e99f75d87c958590}{loadBlocked} ()
\item 
void \hyperlink{classLSQUnit_aaa9628e569d007b553e6830774b8548c}{clearLoadBlocked} ()
\item 
bool \hyperlink{classLSQUnit_ad0aa91a7b51ca925abf9c9992abad314}{isLoadBlockedHandled} ()
\item 
void \hyperlink{classLSQUnit_ac8bfb1e163f7ba2261d702623226973d}{setLoadBlockedHandled} ()
\item 
unsigned \hyperlink{classLSQUnit_a028971a565aca048c67ea1c36a6a9d51}{numFreeEntries} ()
\item 
int \hyperlink{classLSQUnit_a54460b759fb06e2b18e26657279a6f49}{numLoads} ()
\item 
int \hyperlink{classLSQUnit_aa0fc32a4a9d77696f5907f4d25e7d07f}{numStores} ()
\item 
bool \hyperlink{classLSQUnit_a3e70330939fdfc4dbc2f60c1a660584d}{isFull} ()
\item 
bool \hyperlink{classLSQUnit_a479432127ee77145cc19d6a2d1590821}{isEmpty} () const 
\item 
bool \hyperlink{classLSQUnit_a5893daf623130be826f492bbff58f757}{lqFull} ()
\item 
bool \hyperlink{classLSQUnit_a477981d1f905d2d398a1527f7149e3c4}{sqFull} ()
\item 
bool \hyperlink{classLSQUnit_a01d2807c1345befcffd168a2a9dbdbf2}{lqEmpty} () const 
\item 
bool \hyperlink{classLSQUnit_a5761e9640bec8ba8474945cce57b6501}{sqEmpty} () const 
\item 
unsigned \hyperlink{classLSQUnit_a24ba9cb3fa1e726321780a20a960c8cd}{getCount} ()
\item 
bool \hyperlink{classLSQUnit_ad2e4b46255cfb53e85522adeed4e2089}{hasStoresToWB} ()
\item 
int \hyperlink{classLSQUnit_a276cdbdaf4551f1b846c4e2535c5f882}{numStoresToWB} ()
\item 
bool \hyperlink{classLSQUnit_a338be821734603396bfef8d9fb8f04b0}{willWB} ()
\item 
void \hyperlink{classLSQUnit_a29cb5a4f98063ce6e9210eacbdb35298}{recvRetry} ()
\item 
void \hyperlink{classLSQUnit_ad0dcc54f6823ec37a9ab4eef289e2305}{dumpInsts} () const 
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classLSQUnit_a6f61d3e96e7ebc628121a63027d9c106}{read} (\hyperlink{classRequest}{Request} $\ast$req, \hyperlink{classRequest}{Request} $\ast$sreqLow, \hyperlink{classRequest}{Request} $\ast$sreqHigh, uint8\_\-t $\ast$data, int load\_\-idx)
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classLSQUnit_a8910d991217dd388c788727f8ebbb267}{write} (\hyperlink{classRequest}{Request} $\ast$req, \hyperlink{classRequest}{Request} $\ast$sreqLow, \hyperlink{classRequest}{Request} $\ast$sreqHigh, uint8\_\-t $\ast$data, int store\_\-idx)
\item 
int \hyperlink{classLSQUnit_ad43a7408f4e1c1e181bc40ecab6dc593}{getLoadHead} ()
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classLSQUnit_aee7352adadc6b43b7ce36a8c052eb222}{getLoadHeadSeqNum} ()
\item 
int \hyperlink{classLSQUnit_ab9d14b0deb8ab44dc09ac784b162e774}{getStoreHead} ()
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classLSQUnit_a1813b58ab7569d6aeefb5d4e235cceda}{getStoreHeadSeqNum} ()
\item 
bool \hyperlink{classLSQUnit_af8eb8590fbfa6ecd2f796390677a4c00}{isStalled} ()
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classLSQUnit_a755ee993c2d4e9d422c37990b15afa37}{resetState} ()
\item 
void \hyperlink{classLSQUnit_a3911bacb8817c31cfbeefd125dba0217}{writeback} (\hyperlink{classLSQUnit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst, \hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classLSQUnit_a173d8fd73280b1cf5b4d0dd9b68cf0cf}{writebackPendingStore} ()
\item 
void \hyperlink{classLSQUnit_a6f23a0d213e7d35f445f9cabfd2ed0cc}{storePostSend} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classLSQUnit_a12ec7cad6ac51a53bca7795588885e5c}{completeStore} (int store\_\-idx)
\item 
bool \hyperlink{classLSQUnit_a268a51a93dbdda9a0cff48ba036e673e}{sendStore} (\hyperlink{classPacket}{PacketPtr} data\_\-pkt)
\item 
void \hyperlink{classLSQUnit_a7576fc9eec69e3ce28ce7af7ad87416a}{incrStIdx} (int \&store\_\-idx) const 
\item 
void \hyperlink{classLSQUnit_a4ebe3751617bcb686e225184f77f971c}{decrStIdx} (int \&store\_\-idx) const 
\item 
void \hyperlink{classLSQUnit_a129dcadec1d9a805428c1cfd14bcad5e}{incrLdIdx} (int \&load\_\-idx) const 
\item 
void \hyperlink{classLSQUnit_a313eca7abdfb7c6642078e21bc49a968}{decrLdIdx} (int \&load\_\-idx) const 
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classLSQUnit_a44622cf06940413482836cb62931ac3f}{O3CPU} $\ast$ \hyperlink{classLSQUnit_a1379cf882a12ac6fc9eba5da7c84b18b}{cpu}
\item 
\hyperlink{classLSQUnit_a23f60a4095b5240dfcb18a4ec40210a9}{IEW} $\ast$ \hyperlink{classLSQUnit_a4e9ef25d8913b270d432be4bbfe4965c}{iewStage}
\item 
\hyperlink{classLSQ}{LSQ} $\ast$ \hyperlink{classLSQUnit_ac0894e8141823f8eea2c9041bac9dab4}{lsq}
\item 
\hyperlink{classMasterPort}{MasterPort} $\ast$ \hyperlink{classLSQUnit_a2bbddd281625b8b4d716708925673445}{dcachePort}
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classLSQUnit_a0ee490ba978f48fbf2579acc7eb60b24}{lsqID}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{structLSQUnit_1_1SQEntry}{SQEntry} $>$ \hyperlink{classLSQUnit_a1d370cdc36d253e0f786d46c6af77a40}{storeQueue}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classLSQUnit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classLSQUnit_aa5f3703c5d7c5ce21a497352b94c7465}{loadQueue}
\item 
unsigned \hyperlink{classLSQUnit_aafa99d800d574095881acbacdbbbcc47}{LQEntries}
\item 
unsigned \hyperlink{classLSQUnit_a38c8af5392da70119dc5cce4e3637cbc}{SQEntries}
\item 
unsigned \hyperlink{classLSQUnit_ab5dfaaa13f279adbed7a1eafea047796}{depCheckShift}
\item 
bool \hyperlink{classLSQUnit_a602a9ccaf8b313e8923d8b07ec5bc439}{checkLoads}
\item 
int \hyperlink{classLSQUnit_a867971f18e464abd16193e069c64a8ad}{loads}
\item 
int \hyperlink{classLSQUnit_ade9e895aa9c5ace27779c985c4f43326}{stores}
\item 
int \hyperlink{classLSQUnit_a3831a7965ffbe90df177026988476f9c}{storesToWB}
\item 
int \hyperlink{classLSQUnit_ac09af89928d2ef4da4cbdcfce26fa3f5}{loadHead}
\item 
int \hyperlink{classLSQUnit_a973a489225da164cc85e690f13c86841}{loadTail}
\item 
int \hyperlink{classLSQUnit_a6e87b6f77102183080ea6ab8599b26a9}{storeHead}
\item 
int \hyperlink{classLSQUnit_a9023e0813d4f3e566d17fb6334a2da02}{storeWBIdx}
\item 
int \hyperlink{classLSQUnit_acd5c7fbb5578b5cb505ffff16bbf6a8b}{storeTail}
\item 
int \hyperlink{classLSQUnit_ab2e23636971c40e7ed945026b2a184e1}{cachePorts}
\item 
int \hyperlink{classLSQUnit_a03435d626b7567ed154de5d7d8c3d419}{usedPorts}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classLSQUnit_af4264b12b32db39099b579e1ed670312}{cacheBlockMask}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{structIssueStruct}{IssueStruct} $>$::wire \hyperlink{classLSQUnit_af6f43373b6586aa8c486538fb076effb}{fromIssue}
\item 
bool \hyperlink{classLSQUnit_a6f8bff553ad30865c7d0c62e05421eb8}{stalled}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classLSQUnit_afe1cdcfca6b44c28581d862228adc3da}{stallingStoreIsn}
\item 
int \hyperlink{classLSQUnit_af55bc9000c8b4e4cfcfbd018feca12a7}{stallingLoadIdx}
\item 
\hyperlink{classPacket}{PacketPtr} \hyperlink{classLSQUnit_a314ae93c04b3ca96e79e1b1f39a8e478}{retryPkt}
\item 
bool \hyperlink{classLSQUnit_a89d931c74b63e0b0e7ad856fe9525ff6}{isStoreBlocked}
\item 
bool \hyperlink{classLSQUnit_a95dc31b4ce3ebcb6b9d75a510b3a128c}{isLoadBlocked}
\item 
bool \hyperlink{classLSQUnit_a2c1620029c162c7180e523b089e56ed5}{loadBlockedHandled}
\item 
bool \hyperlink{classLSQUnit_aec79dbfe7cf50cf3d047cad7ee8fa157}{storeInFlight}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classLSQUnit_a3fca34b247fd8d081557578f8ca60fe3}{blockedLoadSeqNum}
\item 
\hyperlink{classLSQUnit_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classLSQUnit_a270a20c3fa52139e0538288275db9d22}{memDepViolator}
\item 
bool \hyperlink{classLSQUnit_ae4914b6850f06ca3589fe9e75451fc2e}{hasPendingPkt}
\item 
\hyperlink{classPacket}{PacketPtr} \hyperlink{classLSQUnit_a54d6e1b7bac876ca215b09777bae1d34}{pendingPkt}
\item 
bool \hyperlink{classLSQUnit_abef3db582145f640478056f8413a03e3}{needsTSO}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classLSQUnit_a2adecfd8b85711a16f91e0fbd7ca8f10}{lsqForwLoads}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classLSQUnit_ab1c6fb6e4b6c6a243412e594629105ea}{invAddrLoads}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classLSQUnit_a737697c5df3fbe8e728541fec8220089}{lsqSquashedLoads}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classLSQUnit_ad620ac240b0d631c3a8aa19cfd05ad41}{lsqIgnoredResponses}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classLSQUnit_ac499fc2b461e03a110deae7c695f75bc}{lsqMemOrderViolation}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classLSQUnit_a0abe80f8caefb71a0351c3bed4d99c0e}{lsqSquashedStores}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classLSQUnit_a893e9b5b65df5710d85f6a583504a11c}{invAddrSwpfs}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classLSQUnit_a5323f1c2b6bf5cccc59253596656eb70}{lsqBlockedLoads}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classLSQUnit_af5c24658bed91065bf7d69d27ba9fbd6}{lsqRescheduledLoads}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classLSQUnit_a33a1cca2455a3e5909f462a778902643}{lsqCacheBlocked}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$class Impl$>$ class LSQUnit$<$ Impl $>$}

Class that implements the actual LQ and SQ for each specific thread. Both are circular queues; load entries are freed upon committing, while store entries are freed once they writeback. The \hyperlink{classLSQUnit}{LSQUnit} tracks if there are memory ordering violations, and also detects partial load to store forwarding cases (a store only has part of a load's data) that requires the load to wait until the store writes back. In the former case it holds onto the instruction until the dependence unit looks at it, and in the latter it stalls the \hyperlink{classLSQ}{LSQ} until the store writes back. At that point the load is replayed. 

\subsection{型定義}
\hypertarget{classLSQUnit_a028ce10889c5f6450239d9e9a7347976}{
\index{LSQUnit@{LSQUnit}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!LSQUnit@{LSQUnit}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInstPtr {\bf DynInstPtr}}}
\label{classLSQUnit_a028ce10889c5f6450239d9e9a7347976}
\hypertarget{classLSQUnit_a23f60a4095b5240dfcb18a4ec40210a9}{
\index{LSQUnit@{LSQUnit}!IEW@{IEW}}
\index{IEW@{IEW}!LSQUnit@{LSQUnit}}
\subsubsection[{IEW}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::CPUPol::IEW {\bf IEW}}}
\label{classLSQUnit_a23f60a4095b5240dfcb18a4ec40210a9}
\hypertarget{classLSQUnit_aa56c7524890b3a6337668c507be0f272}{
\index{LSQUnit@{LSQUnit}!IssueStruct@{IssueStruct}}
\index{IssueStruct@{IssueStruct}!LSQUnit@{LSQUnit}}
\subsubsection[{IssueStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::CPUPol::IssueStruct {\bf IssueStruct}}}
\label{classLSQUnit_aa56c7524890b3a6337668c507be0f272}
\hypertarget{classLSQUnit_acf05a3db8421d1ca800c285cf9a86301}{
\index{LSQUnit@{LSQUnit}!LSQ@{LSQ}}
\index{LSQ@{LSQ}!LSQUnit@{LSQUnit}}
\subsubsection[{LSQ}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::CPUPol::LSQ {\bf LSQ}}}
\label{classLSQUnit_acf05a3db8421d1ca800c285cf9a86301}
\hypertarget{classLSQUnit_a44622cf06940413482836cb62931ac3f}{
\index{LSQUnit@{LSQUnit}!O3CPU@{O3CPU}}
\index{O3CPU@{O3CPU}!LSQUnit@{LSQUnit}}
\subsubsection[{O3CPU}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::O3CPU {\bf O3CPU}}}
\label{classLSQUnit_a44622cf06940413482836cb62931ac3f}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classLSQUnit_a0b23136c4d1c97aab007aa60e707763b}{
\index{LSQUnit@{LSQUnit}!LSQUnit@{LSQUnit}}
\index{LSQUnit@{LSQUnit}!LSQUnit@{LSQUnit}}
\subsubsection[{LSQUnit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf LSQUnit} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a0b23136c4d1c97aab007aa60e707763b}
Constructs an \hyperlink{classLSQ}{LSQ} unit. \hyperlink{classLSQUnit_a45b3b65ba551c17c3b200db265611a4c}{init()} must be called prior to use. 


\begin{DoxyCode}
143     : loads(0), stores(0), storesToWB(0), cacheBlockMask(0), stalled(false),
144       isStoreBlocked(false), isLoadBlocked(false),
145       loadBlockedHandled(false), storeInFlight(false), hasPendingPkt(false)
146 {
147 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classLSQUnit_a35b89a864d3af33a4b045b7fe0aa6b5a}{
\index{LSQUnit@{LSQUnit}!checkSnoop@{checkSnoop}}
\index{checkSnoop@{checkSnoop}!LSQUnit@{LSQUnit}}
\subsubsection[{checkSnoop}]{\setlength{\rightskip}{0pt plus 5cm}void checkSnoop ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a35b89a864d3af33a4b045b7fe0aa6b5a}
\hyperlink{classCheck}{Check} if an incoming invalidate hits in the lsq on a load that might have issued out of order wrt another load beacuse of the intermediate invalidate. 


\begin{DoxyCode}
434 {
435     int load_idx = loadHead;
436     DPRINTF(LSQUnit, "Got snoop for address %#x\n", pkt->getAddr());
437 
438     // Unlock the cpu-local monitor when the CPU sees a snoop to a locked
439     // address. The CPU can speculatively execute a LL operation after a pending
440     // SC operation in the pipeline and that can make the cache monitor the CPU
441     // is connected to valid while it really shouldn't be.
442     for (int x = 0; x < cpu->numContexts(); x++) {
443         ThreadContext *tc = cpu->getContext(x);
444         bool no_squash = cpu->thread[x]->noSquashFromTC;
445         cpu->thread[x]->noSquashFromTC = true;
446         TheISA::handleLockedSnoop(tc, pkt, cacheBlockMask);
447         cpu->thread[x]->noSquashFromTC = no_squash;
448     }
449 
450     Addr invalidate_addr = pkt->getAddr() & cacheBlockMask;
451 
452     DynInstPtr ld_inst = loadQueue[load_idx];
453     if (ld_inst) {
454         Addr load_addr = ld_inst->physEffAddr & cacheBlockMask;
455         // Check that this snoop didn't just invalidate our lock flag
456         if (ld_inst->effAddrValid() && load_addr == invalidate_addr &&
457             ld_inst->memReqFlags & Request::LLSC)
458             TheISA::handleLockedSnoopHit(ld_inst.get());
459     }
460 
461     // If this is the only load in the LSQ we don't care
462     if (load_idx == loadTail)
463         return;
464 
465     incrLdIdx(load_idx);
466 
467     bool force_squash = false;
468 
469     while (load_idx != loadTail) {
470         DynInstPtr ld_inst = loadQueue[load_idx];
471 
472         if (!ld_inst->effAddrValid() || ld_inst->uncacheable()) {
473             incrLdIdx(load_idx);
474             continue;
475         }
476 
477         Addr load_addr = ld_inst->physEffAddr & cacheBlockMask;
478         DPRINTF(LSQUnit, "-- inst [sn:%lli] load_addr: %#x to pktAddr:%#x\n",
479                     ld_inst->seqNum, load_addr, invalidate_addr);
480 
481         if (load_addr == invalidate_addr || force_squash) {
482             if (needsTSO) {
483                 // If we have a TSO system, as all loads must be ordered with
484                 // all other loads, this load as well as *all* subsequent loads
485                 // need to be squashed to prevent possible load reordering.
486                 force_squash = true;
487             }
488             if (ld_inst->possibleLoadViolation() || force_squash) {
489                 DPRINTF(LSQUnit, "Conflicting load at addr %#x [sn:%lli]\n",
490                         pkt->getAddr(), ld_inst->seqNum);
491 
492                 // Mark the load for re-execution
493                 ld_inst->fault = new ReExec;
494             } else {
495                 DPRINTF(LSQUnit, "HitExternal Snoop for addr %#x [sn:%lli]\n",
496                         pkt->getAddr(), ld_inst->seqNum);
497 
498                 // Make sure that we don't lose a snoop hitting a LOCKED
499                 // address since the LOCK* flags don't get updated until
500                 // commit.
501                 if (ld_inst->memReqFlags & Request::LLSC)
502                     TheISA::handleLockedSnoopHit(ld_inst.get());
503 
504                 // If a older load checks this and it's true
505                 // then we might have missed the snoop
506                 // in which case we need to invalidate to be sure
507                 ld_inst->hitExternalSnoop(true);
508             }
509         }
510         incrLdIdx(load_idx);
511     }
512     return;
513 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a15239c5725d8744a793c867193e4bce7}{
\index{LSQUnit@{LSQUnit}!checkViolations@{checkViolations}}
\index{checkViolations@{checkViolations}!LSQUnit@{LSQUnit}}
\subsubsection[{checkViolations}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} checkViolations (int {\em load\_\-idx}, \/  {\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a15239c5725d8744a793c867193e4bce7}
\hyperlink{classCheck}{Check} for ordering violations in the \hyperlink{classLSQ}{LSQ}. For a store squash if we ever find a conflicting load. For a load, only squash if we an external snoop invalidate has been seen for that load address 
\begin{DoxyParams}{引数}
\item[{\em load\_\-idx}]index to start checking at \item[{\em inst}]the instruction to check \end{DoxyParams}


\begin{Desc}
\item[\hyperlink{todo__todo000039}{TODO}]in theory you only need to check an instruction that has executed however, there isn't a good way in the pipeline at the moment to check all instructions that will execute before the store writes back. Thus, like the implementation that came before it, we're overly conservative. \end{Desc}



\begin{DoxyCode}
518 {
519     Addr inst_eff_addr1 = inst->effAddr >> depCheckShift;
520     Addr inst_eff_addr2 = (inst->effAddr + inst->effSize - 1) >> depCheckShift;
521 
527     while (load_idx != loadTail) {
528         DynInstPtr ld_inst = loadQueue[load_idx];
529         if (!ld_inst->effAddrValid() || ld_inst->uncacheable()) {
530             incrLdIdx(load_idx);
531             continue;
532         }
533 
534         Addr ld_eff_addr1 = ld_inst->effAddr >> depCheckShift;
535         Addr ld_eff_addr2 =
536             (ld_inst->effAddr + ld_inst->effSize - 1) >> depCheckShift;
537 
538         if (inst_eff_addr2 >= ld_eff_addr1 && inst_eff_addr1 <= ld_eff_addr2) {
539             if (inst->isLoad()) {
540                 // If this load is to the same block as an external snoop
541                 // invalidate that we've observed then the load needs to be
542                 // squashed as it could have newer data
543                 if (ld_inst->hitExternalSnoop()) {
544                     if (!memDepViolator ||
545                             ld_inst->seqNum < memDepViolator->seqNum) {
546                         DPRINTF(LSQUnit, "Detected fault with inst [sn:%lli] "
547                                 "and [sn:%lli] at address %#x\n",
548                                 inst->seqNum, ld_inst->seqNum, ld_eff_addr1);
549                         memDepViolator = ld_inst;
550 
551                         ++lsqMemOrderViolation;
552 
553                         return new GenericISA::M5PanicFault(
554                                 "Detected fault with inst [sn:%lli] and "
555                                 "[sn:%lli] at address %#x\n",
556                                 inst->seqNum, ld_inst->seqNum, ld_eff_addr1);
557                     }
558                 }
559 
560                 // Otherwise, mark the load has a possible load violation
561                 // and if we see a snoop before it's commited, we need to squash
562                 ld_inst->possibleLoadViolation(true);
563                 DPRINTF(LSQUnit, "Found possible load violaiton at addr: %#x"
564                         " between instructions [sn:%lli] and [sn:%lli]\n",
565                         inst_eff_addr1, inst->seqNum, ld_inst->seqNum);
566             } else {
567                 // A load/store incorrectly passed this store.
568                 // Check if we already have a violator, or if it's newer
569                 // squash and refetch.
570                 if (memDepViolator && ld_inst->seqNum > memDepViolator->seqNum)
571                     break;
572 
573                 DPRINTF(LSQUnit, "Detected fault with inst [sn:%lli] and "
574                         "[sn:%lli] at address %#x\n",
575                         inst->seqNum, ld_inst->seqNum, ld_eff_addr1);
576                 memDepViolator = ld_inst;
577 
578                 ++lsqMemOrderViolation;
579 
580                 return new GenericISA::M5PanicFault("Detected fault with "
581                         "inst [sn:%lli] and [sn:%lli] at address %#x\n",
582                         inst->seqNum, ld_inst->seqNum, ld_eff_addr1);
583             }
584         }
585 
586         incrLdIdx(load_idx);
587     }
588     return NoFault;
589 }
\end{DoxyCode}
\hypertarget{classLSQUnit_aaa9628e569d007b553e6830774b8548c}{
\index{LSQUnit@{LSQUnit}!clearLoadBlocked@{clearLoadBlocked}}
\index{clearLoadBlocked@{clearLoadBlocked}!LSQUnit@{LSQUnit}}
\subsubsection[{clearLoadBlocked}]{\setlength{\rightskip}{0pt plus 5cm}void clearLoadBlocked ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_aaa9628e569d007b553e6830774b8548c}
Clears the signal that a load became blocked. 


\begin{DoxyCode}
191     { isLoadBlocked = false; }
\end{DoxyCode}
\hypertarget{classLSQUnit_ae3af532345dbe6519e8272d9cd677230}{
\index{LSQUnit@{LSQUnit}!clearLQ@{clearLQ}}
\index{clearLQ@{clearLQ}!LSQUnit@{LSQUnit}}
\subsubsection[{clearLQ}]{\setlength{\rightskip}{0pt plus 5cm}void clearLQ ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_ae3af532345dbe6519e8272d9cd677230}
Clears all the entries in the LQ. 


\begin{DoxyCode}
274 {
275     loadQueue.clear();
276 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a171cd7891063f418b1ee217f5c03537b}{
\index{LSQUnit@{LSQUnit}!clearSQ@{clearSQ}}
\index{clearSQ@{clearSQ}!LSQUnit@{LSQUnit}}
\subsubsection[{clearSQ}]{\setlength{\rightskip}{0pt plus 5cm}void clearSQ ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a171cd7891063f418b1ee217f5c03537b}
Clears all the entries in the SQ. 


\begin{DoxyCode}
281 {
282     storeQueue.clear();
283 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a8ddd26e169a62ec5ae591a9f95934839}{
\index{LSQUnit@{LSQUnit}!commitLoad@{commitLoad}}
\index{commitLoad@{commitLoad}!LSQUnit@{LSQUnit}}
\subsubsection[{commitLoad}]{\setlength{\rightskip}{0pt plus 5cm}void commitLoad ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a8ddd26e169a62ec5ae591a9f95934839}
Commits the head load. 


\begin{DoxyCode}
699 {
700     assert(loadQueue[loadHead]);
701 
702     DPRINTF(LSQUnit, "Committing head load instruction, PC %s\n",
703             loadQueue[loadHead]->pcState());
704 
705     loadQueue[loadHead] = NULL;
706 
707     incrLdIdx(loadHead);
708 
709     --loads;
710 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a1ae517a923a864a4e3a5aa1eeb2dd2d6}{
\index{LSQUnit@{LSQUnit}!commitLoads@{commitLoads}}
\index{commitLoads@{commitLoads}!LSQUnit@{LSQUnit}}
\subsubsection[{commitLoads}]{\setlength{\rightskip}{0pt plus 5cm}void commitLoads ({\bf InstSeqNum} \& {\em youngest\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a1ae517a923a864a4e3a5aa1eeb2dd2d6}
Commits loads older than a specific sequence number. 


\begin{DoxyCode}
715 {
716     assert(loads == 0 || loadQueue[loadHead]);
717 
718     while (loads != 0 && loadQueue[loadHead]->seqNum <= youngest_inst) {
719         commitLoad();
720     }
721 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a954ce1ce58b67cae49ba127d5ea40701}{
\index{LSQUnit@{LSQUnit}!commitStores@{commitStores}}
\index{commitStores@{commitStores}!LSQUnit@{LSQUnit}}
\subsubsection[{commitStores}]{\setlength{\rightskip}{0pt plus 5cm}void commitStores ({\bf InstSeqNum} \& {\em youngest\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a954ce1ce58b67cae49ba127d5ea40701}
Commits stores older than a specific sequence number. 


\begin{DoxyCode}
726 {
727     assert(stores == 0 || storeQueue[storeHead].inst);
728 
729     int store_idx = storeHead;
730 
731     while (store_idx != storeTail) {
732         assert(storeQueue[store_idx].inst);
733         // Mark any stores that are now committed and have not yet
734         // been marked as able to write back.
735         if (!storeQueue[store_idx].canWB) {
736             if (storeQueue[store_idx].inst->seqNum > youngest_inst) {
737                 break;
738             }
739             DPRINTF(LSQUnit, "Marking store as able to write back, PC "
740                     "%s [sn:%lli]\n",
741                     storeQueue[store_idx].inst->pcState(),
742                     storeQueue[store_idx].inst->seqNum);
743 
744             storeQueue[store_idx].canWB = true;
745 
746             ++storesToWB;
747         }
748 
749         incrStIdx(store_idx);
750     }
751 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a0f7f0d3412bbf494cd3d0c0f48e5fcf2}{
\index{LSQUnit@{LSQUnit}!completeDataAccess@{completeDataAccess}}
\index{completeDataAccess@{completeDataAccess}!LSQUnit@{LSQUnit}}
\subsubsection[{completeDataAccess}]{\setlength{\rightskip}{0pt plus 5cm}void completeDataAccess ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a0f7f0d3412bbf494cd3d0c0f48e5fcf2}
Completes the data access that has been returned from the memory system. 


\begin{DoxyCode}
95 {
96     LSQSenderState *state = dynamic_cast<LSQSenderState *>(pkt->senderState);
97     DynInstPtr inst = state->inst;
98     DPRINTF(IEW, "Writeback event [sn:%lli].\n", inst->seqNum);
99     DPRINTF(Activity, "Activity: Writeback event [sn:%lli].\n", inst->seqNum);
100 
101     //iewStage->ldstQueue.removeMSHR(inst->threadNumber,inst->seqNum);
102 
103     // If this is a split access, wait until all packets are received.
104     if (TheISA::HasUnalignedMemAcc && !state->complete()) {
105         delete pkt->req;
106         delete pkt;
107         return;
108     }
109 
110     assert(!cpu->switchedOut());
111     if (inst->isSquashed()) {
112         iewStage->decrWb(inst->seqNum);
113     } else {
114         if (!state->noWB) {
115             if (!TheISA::HasUnalignedMemAcc || !state->isSplit ||
116                 !state->isLoad) {
117                 writeback(inst, pkt);
118             } else {
119                 writeback(inst, state->mainPkt);
120             }
121         }
122 
123         if (inst->isStore()) {
124             completeStore(state->idx);
125         }
126     }
127 
128     if (TheISA::HasUnalignedMemAcc && state->isSplit && state->isLoad) {
129         delete state->mainPkt->req;
130         delete state->mainPkt;
131     }
132 
133     pkt->req->setAccessLatency();
134     cpu->ppDataAccessComplete->notify(std::make_pair(inst, pkt));
135 
136     delete state;
137     delete pkt->req;
138     delete pkt;
139 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a12ec7cad6ac51a53bca7795588885e5c}{
\index{LSQUnit@{LSQUnit}!completeStore@{completeStore}}
\index{completeStore@{completeStore}!LSQUnit@{LSQUnit}}
\subsubsection[{completeStore}]{\setlength{\rightskip}{0pt plus 5cm}void completeStore (int {\em store\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLSQUnit_a12ec7cad6ac51a53bca7795588885e5c}
Completes the store at the specified index. 


\begin{DoxyCode}
1152 {
1153     assert(storeQueue[store_idx].inst);
1154     storeQueue[store_idx].completed = true;
1155     --storesToWB;
1156     // A bit conservative because a store completion may not free up entries,
1157     // but hopefully avoids two store completions in one cycle from making
1158     // the CPU tick twice.
1159     cpu->wakeCPU();
1160     cpu->activityThisCycle();
1161 
1162     if (store_idx == storeHead) {
1163         do {
1164             incrStIdx(storeHead);
1165 
1166             --stores;
1167         } while (storeQueue[storeHead].completed &&
1168                  storeHead != storeTail);
1169 
1170         iewStage->updateLSQNextCycle = true;
1171     }
1172 
1173     DPRINTF(LSQUnit, "Completing store [sn:%lli], idx:%i, store head "
1174             "idx:%i\n",
1175             storeQueue[store_idx].inst->seqNum, store_idx, storeHead);
1176 
1177 #if TRACING_ON
1178     if (DTRACE(O3PipeView)) {
1179         storeQueue[store_idx].inst->storeTick =
1180             curTick() - storeQueue[store_idx].inst->fetchTick;
1181     }
1182 #endif
1183 
1184     if (isStalled() &&
1185         storeQueue[store_idx].inst->seqNum == stallingStoreIsn) {
1186         DPRINTF(LSQUnit, "Unstalling, stalling store [sn:%lli] "
1187                 "load idx:%i\n",
1188                 stallingStoreIsn, stallingLoadIdx);
1189         stalled = false;
1190         stallingStoreIsn = 0;
1191         iewStage->replayMemInst(loadQueue[stallingLoadIdx]);
1192     }
1193 
1194     storeQueue[store_idx].inst->setCompleted();
1195 
1196     if (needsTSO) {
1197         storeInFlight = false;
1198     }
1199 
1200     // Tell the checker we've completed this instruction.  Some stores
1201     // may get reported twice to the checker, but the checker can
1202     // handle that case.
1203     if (cpu->checker) {
1204         cpu->checker->verify(storeQueue[store_idx].inst);
1205     }
1206 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a313eca7abdfb7c6642078e21bc49a968}{
\index{LSQUnit@{LSQUnit}!decrLdIdx@{decrLdIdx}}
\index{decrLdIdx@{decrLdIdx}!LSQUnit@{LSQUnit}}
\subsubsection[{decrLdIdx}]{\setlength{\rightskip}{0pt plus 5cm}void decrLdIdx (int \& {\em load\_\-idx}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLSQUnit_a313eca7abdfb7c6642078e21bc49a968}
Decrements the given load index (circular queue). 


\begin{DoxyCode}
1293 {
1294     if (--load_idx < 0)
1295         load_idx += LQEntries;
1296 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a4ebe3751617bcb686e225184f77f971c}{
\index{LSQUnit@{LSQUnit}!decrStIdx@{decrStIdx}}
\index{decrStIdx@{decrStIdx}!LSQUnit@{LSQUnit}}
\subsubsection[{decrStIdx}]{\setlength{\rightskip}{0pt plus 5cm}void decrStIdx (int \& {\em store\_\-idx}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLSQUnit_a4ebe3751617bcb686e225184f77f971c}
Decrements the given store index (circular queue). 


\begin{DoxyCode}
1277 {
1278     if (--store_idx < 0)
1279         store_idx += SQEntries;
1280 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a0240eb42fa57fe5d3788093f62b77347}{
\index{LSQUnit@{LSQUnit}!drainSanityCheck@{drainSanityCheck}}
\index{drainSanityCheck@{drainSanityCheck}!LSQUnit@{LSQUnit}}
\subsubsection[{drainSanityCheck}]{\setlength{\rightskip}{0pt plus 5cm}void drainSanityCheck () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a0240eb42fa57fe5d3788093f62b77347}
Perform sanity checks after a drain. 


\begin{DoxyCode}
288 {
289     for (int i = 0; i < loadQueue.size(); ++i)
290         assert(!loadQueue[i]);
291 
292     assert(storesToWB == 0);
293     assert(!retryPkt);
294 }
\end{DoxyCode}
\hypertarget{classLSQUnit_ad0dcc54f6823ec37a9ab4eef289e2305}{
\index{LSQUnit@{LSQUnit}!dumpInsts@{dumpInsts}}
\index{dumpInsts@{dumpInsts}!LSQUnit@{LSQUnit}}
\subsubsection[{dumpInsts}]{\setlength{\rightskip}{0pt plus 5cm}void dumpInsts () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_ad0dcc54f6823ec37a9ab4eef289e2305}
Debugging function to dump instructions in the \hyperlink{classLSQ}{LSQ}. 


\begin{DoxyCode}
1301 {
1302     cprintf("Load store queue: Dumping instructions.\n");
1303     cprintf("Load queue size: %i\n", loads);
1304     cprintf("Load queue: ");
1305 
1306     int load_idx = loadHead;
1307 
1308     while (load_idx != loadTail && loadQueue[load_idx]) {
1309         const DynInstPtr &inst(loadQueue[load_idx]);
1310         cprintf("%s.[sn:%i] ", inst->pcState(), inst->seqNum);
1311 
1312         incrLdIdx(load_idx);
1313     }
1314     cprintf("\n");
1315 
1316     cprintf("Store queue size: %i\n", stores);
1317     cprintf("Store queue: ");
1318 
1319     int store_idx = storeHead;
1320 
1321     while (store_idx != storeTail && storeQueue[store_idx].inst) {
1322         const DynInstPtr &inst(storeQueue[store_idx].inst);
1323         cprintf("%s.[sn:%i] ", inst->pcState(), inst->seqNum);
1324 
1325         incrStIdx(store_idx);
1326     }
1327 
1328     cprintf("\n");
1329 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a091a4d1788ce66e51ceb888bbd85ac08}{
\index{LSQUnit@{LSQUnit}!executeLoad@{executeLoad}}
\index{executeLoad@{executeLoad}!LSQUnit@{LSQUnit}}
\subsubsection[{executeLoad}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} executeLoad (int {\em lq\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a091a4d1788ce66e51ceb888bbd85ac08}



\begin{DoxyCode}
143 { panic("Not implemented"); return NoFault; }
\end{DoxyCode}
\hypertarget{classLSQUnit_a30c6332142c2ecca389ed6ee463c692b}{
\index{LSQUnit@{LSQUnit}!executeLoad@{executeLoad}}
\index{executeLoad@{executeLoad}!LSQUnit@{LSQUnit}}
\subsubsection[{executeLoad}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} executeLoad ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a30c6332142c2ecca389ed6ee463c692b}
Executes a load instruction. 


\begin{DoxyCode}
597 {
598     using namespace TheISA;
599     // Execute a specific load.
600     Fault load_fault = NoFault;
601 
602     DPRINTF(LSQUnit, "Executing load PC %s, [sn:%lli]\n",
603             inst->pcState(), inst->seqNum);
604 
605     assert(!inst->isSquashed());
606 
607     load_fault = inst->initiateAcc();
608 
609     if (inst->isTranslationDelayed() &&
610         load_fault == NoFault)
611         return load_fault;
612 
613     // If the instruction faulted or predicated false, then we need to send it
614     // along to commit without the instruction completing.
615     if (load_fault != NoFault || !inst->readPredicate()) {
616         // Send this instruction to commit, also make sure iew stage
617         // realizes there is activity.
618         // Mark it as executed unless it is an uncached load that
619         // needs to hit the head of commit.
620         if (!inst->readPredicate())
621             inst->forwardOldRegs();
622         DPRINTF(LSQUnit, "Load [sn:%lli] not executed from %s\n",
623                 inst->seqNum,
624                 (load_fault != NoFault ? "fault" : "predication"));
625         if (!(inst->hasRequest() && inst->uncacheable()) ||
626             inst->isAtCommit()) {
627             inst->setExecuted();
628         }
629         iewStage->instToCommit(inst);
630         iewStage->activityThisCycle();
631     } else if (!loadBlocked()) {
632         assert(inst->effAddrValid());
633         int load_idx = inst->lqIdx;
634         incrLdIdx(load_idx);
635 
636         if (checkLoads)
637             return checkViolations(load_idx, inst);
638     }
639 
640     return load_fault;
641 }
\end{DoxyCode}
\hypertarget{classLSQUnit_aad78b8a37ee5c61e47df58dd39980340}{
\index{LSQUnit@{LSQUnit}!executeStore@{executeStore}}
\index{executeStore@{executeStore}!LSQUnit@{LSQUnit}}
\subsubsection[{executeStore}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} executeStore ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_aad78b8a37ee5c61e47df58dd39980340}
Executes a store instruction. 


\begin{DoxyCode}
646 {
647     using namespace TheISA;
648     // Make sure that a store exists.
649     assert(stores != 0);
650 
651     int store_idx = store_inst->sqIdx;
652 
653     DPRINTF(LSQUnit, "Executing store PC %s [sn:%lli]\n",
654             store_inst->pcState(), store_inst->seqNum);
655 
656     assert(!store_inst->isSquashed());
657 
658     // Check the recently completed loads to see if any match this store's
659     // address.  If so, then we have a memory ordering violation.
660     int load_idx = store_inst->lqIdx;
661 
662     Fault store_fault = store_inst->initiateAcc();
663 
664     if (store_inst->isTranslationDelayed() &&
665         store_fault == NoFault)
666         return store_fault;
667 
668     if (!store_inst->readPredicate())
669         store_inst->forwardOldRegs();
670 
671     if (storeQueue[store_idx].size == 0) {
672         DPRINTF(LSQUnit,"Fault on Store PC %s, [sn:%lli], Size = 0\n",
673                 store_inst->pcState(), store_inst->seqNum);
674 
675         return store_fault;
676     } else if (!store_inst->readPredicate()) {
677         DPRINTF(LSQUnit, "Store [sn:%lli] not executed from predication\n",
678                 store_inst->seqNum);
679         return store_fault;
680     }
681 
682     assert(store_fault == NoFault);
683 
684     if (store_inst->isStoreConditional()) {
685         // Store conditionals need to set themselves as able to
686         // writeback if we haven't had a fault by here.
687         storeQueue[store_idx].canWB = true;
688 
689         ++storesToWB;
690     }
691 
692     return checkViolations(load_idx, store_inst);
693 
694 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a24ba9cb3fa1e726321780a20a960c8cd}{
\index{LSQUnit@{LSQUnit}!getCount@{getCount}}
\index{getCount@{getCount}!LSQUnit@{LSQUnit}}
\subsubsection[{getCount}]{\setlength{\rightskip}{0pt plus 5cm}unsigned getCount ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a24ba9cb3fa1e726321780a20a960c8cd}
Returns the number of instructions in the \hyperlink{classLSQ}{LSQ}. 


\begin{DoxyCode}
229 { return loads + stores; }
\end{DoxyCode}
\hypertarget{classLSQUnit_ad43a7408f4e1c1e181bc40ecab6dc593}{
\index{LSQUnit@{LSQUnit}!getLoadHead@{getLoadHead}}
\index{getLoadHead@{getLoadHead}!LSQUnit@{LSQUnit}}
\subsubsection[{getLoadHead}]{\setlength{\rightskip}{0pt plus 5cm}int getLoadHead ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_ad43a7408f4e1c1e181bc40ecab6dc593}
Returns the index of the head load instruction. 


\begin{DoxyCode}
541 { return loadHead; }
\end{DoxyCode}
\hypertarget{classLSQUnit_aee7352adadc6b43b7ce36a8c052eb222}{
\index{LSQUnit@{LSQUnit}!getLoadHeadSeqNum@{getLoadHeadSeqNum}}
\index{getLoadHeadSeqNum@{getLoadHeadSeqNum}!LSQUnit@{LSQUnit}}
\subsubsection[{getLoadHeadSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} getLoadHeadSeqNum ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_aee7352adadc6b43b7ce36a8c052eb222}
Returns the sequence number of the head load instruction. 


\begin{DoxyCode}
544     {
545         if (loadQueue[loadHead]) {
546             return loadQueue[loadHead]->seqNum;
547         } else {
548             return 0;
549         }
550 
551     }
\end{DoxyCode}
\hypertarget{classLSQUnit_a30adaf6f5fb6b38b5747f35c419e3f31}{
\index{LSQUnit@{LSQUnit}!getMemDepViolator@{getMemDepViolator}}
\index{getMemDepViolator@{getMemDepViolator}!LSQUnit@{LSQUnit}}
\subsubsection[{getMemDepViolator}]{\setlength{\rightskip}{0pt plus 5cm}Impl::DynInstPtr getMemDepViolator ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a30adaf6f5fb6b38b5747f35c419e3f31}
Returns the memory ordering violator. 


\begin{DoxyCode}
407 {
408     DynInstPtr temp = memDepViolator;
409 
410     memDepViolator = NULL;
411 
412     return temp;
413 }
\end{DoxyCode}
\hypertarget{classLSQUnit_ab9d14b0deb8ab44dc09ac784b162e774}{
\index{LSQUnit@{LSQUnit}!getStoreHead@{getStoreHead}}
\index{getStoreHead@{getStoreHead}!LSQUnit@{LSQUnit}}
\subsubsection[{getStoreHead}]{\setlength{\rightskip}{0pt plus 5cm}int getStoreHead ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_ab9d14b0deb8ab44dc09ac784b162e774}
Returns the index of the head store instruction. 


\begin{DoxyCode}
554 { return storeHead; }
\end{DoxyCode}
\hypertarget{classLSQUnit_a1813b58ab7569d6aeefb5d4e235cceda}{
\index{LSQUnit@{LSQUnit}!getStoreHeadSeqNum@{getStoreHeadSeqNum}}
\index{getStoreHeadSeqNum@{getStoreHeadSeqNum}!LSQUnit@{LSQUnit}}
\subsubsection[{getStoreHeadSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} getStoreHeadSeqNum ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a1813b58ab7569d6aeefb5d4e235cceda}
Returns the sequence number of the head store instruction. 


\begin{DoxyCode}
557     {
558         if (storeQueue[storeHead].inst) {
559             return storeQueue[storeHead].inst->seqNum;
560         } else {
561             return 0;
562         }
563 
564     }
\end{DoxyCode}
\hypertarget{classLSQUnit_ad2e4b46255cfb53e85522adeed4e2089}{
\index{LSQUnit@{LSQUnit}!hasStoresToWB@{hasStoresToWB}}
\index{hasStoresToWB@{hasStoresToWB}!LSQUnit@{LSQUnit}}
\subsubsection[{hasStoresToWB}]{\setlength{\rightskip}{0pt plus 5cm}bool hasStoresToWB ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_ad2e4b46255cfb53e85522adeed4e2089}
Returns if there are any stores to writeback. 


\begin{DoxyCode}
232 { return storesToWB; }
\end{DoxyCode}
\hypertarget{classLSQUnit_a129dcadec1d9a805428c1cfd14bcad5e}{
\index{LSQUnit@{LSQUnit}!incrLdIdx@{incrLdIdx}}
\index{incrLdIdx@{incrLdIdx}!LSQUnit@{LSQUnit}}
\subsubsection[{incrLdIdx}]{\setlength{\rightskip}{0pt plus 5cm}void incrLdIdx (int \& {\em load\_\-idx}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLSQUnit_a129dcadec1d9a805428c1cfd14bcad5e}
Increments the given load index (circular queue). 


\begin{DoxyCode}
1285 {
1286     if (++load_idx >= LQEntries)
1287         load_idx = 0;
1288 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a7576fc9eec69e3ce28ce7af7ad87416a}{
\index{LSQUnit@{LSQUnit}!incrStIdx@{incrStIdx}}
\index{incrStIdx@{incrStIdx}!LSQUnit@{LSQUnit}}
\subsubsection[{incrStIdx}]{\setlength{\rightskip}{0pt plus 5cm}void incrStIdx (int \& {\em store\_\-idx}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLSQUnit_a7576fc9eec69e3ce28ce7af7ad87416a}
Increments the given store index (circular queue). 


\begin{DoxyCode}
1269 {
1270     if (++store_idx >= SQEntries)
1271         store_idx = 0;
1272 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a45b3b65ba551c17c3b200db265611a4c}{
\index{LSQUnit@{LSQUnit}!init@{init}}
\index{init@{init}!LSQUnit@{LSQUnit}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ({\bf O3CPU} $\ast$ {\em cpu\_\-ptr}, \/  {\bf IEW} $\ast$ {\em iew\_\-ptr}, \/  DerivO3CPUParams $\ast$ {\em params}, \/  {\bf LSQ} $\ast$ {\em lsq\_\-ptr}, \/  unsigned {\em maxLQEntries}, \/  unsigned {\em maxSQEntries}, \/  unsigned {\em id})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a45b3b65ba551c17c3b200db265611a4c}
Initializes the \hyperlink{classLSQ}{LSQ} unit with the specified number of entries. 


\begin{DoxyCode}
154 {
155     cpu = cpu_ptr;
156     iewStage = iew_ptr;
157 
158     lsq = lsq_ptr;
159 
160     lsqID = id;
161 
162     DPRINTF(LSQUnit, "Creating LSQUnit%i object.\n",id);
163 
164     // Add 1 for the sentinel entry (they are circular queues).
165     LQEntries = maxLQEntries + 1;
166     SQEntries = maxSQEntries + 1;
167 
168     //Due to uint8_t index in LSQSenderState
169     assert(LQEntries <= 256);
170     assert(SQEntries <= 256);
171 
172     loadQueue.resize(LQEntries);
173     storeQueue.resize(SQEntries);
174 
175     depCheckShift = params->LSQDepCheckShift;
176     checkLoads = params->LSQCheckLoads;
177     cachePorts = params->cachePorts;
178     needsTSO = params->needsTSO;
179 
180     resetState();
181 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a773e88db1aa010c3755e603493bf40ec}{
\index{LSQUnit@{LSQUnit}!insert@{insert}}
\index{insert@{insert}!LSQUnit@{LSQUnit}}
\subsubsection[{insert}]{\setlength{\rightskip}{0pt plus 5cm}void insert ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a773e88db1aa010c3755e603493bf40ec}
Inserts an instruction. 


\begin{DoxyCode}
344 {
345     assert(inst->isMemRef());
346 
347     assert(inst->isLoad() || inst->isStore());
348 
349     if (inst->isLoad()) {
350         insertLoad(inst);
351     } else {
352         insertStore(inst);
353     }
354 
355     inst->setInLSQ();
356 }
\end{DoxyCode}
\hypertarget{classLSQUnit_ad22b3ecafed2bcd9c59fcab049a1cb98}{
\index{LSQUnit@{LSQUnit}!insertLoad@{insertLoad}}
\index{insertLoad@{insertLoad}!LSQUnit@{LSQUnit}}
\subsubsection[{insertLoad}]{\setlength{\rightskip}{0pt plus 5cm}void insertLoad ({\bf DynInstPtr} \& {\em load\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_ad22b3ecafed2bcd9c59fcab049a1cb98}
Inserts a load instruction. 


\begin{DoxyCode}
361 {
362     assert((loadTail + 1) % LQEntries != loadHead);
363     assert(loads < LQEntries);
364 
365     DPRINTF(LSQUnit, "Inserting load PC %s, idx:%i [sn:%lli]\n",
366             load_inst->pcState(), loadTail, load_inst->seqNum);
367 
368     load_inst->lqIdx = loadTail;
369 
370     if (stores == 0) {
371         load_inst->sqIdx = -1;
372     } else {
373         load_inst->sqIdx = storeTail;
374     }
375 
376     loadQueue[loadTail] = load_inst;
377 
378     incrLdIdx(loadTail);
379 
380     ++loads;
381 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a6a4b4e51bfff3639932ebaba45e8a282}{
\index{LSQUnit@{LSQUnit}!insertStore@{insertStore}}
\index{insertStore@{insertStore}!LSQUnit@{LSQUnit}}
\subsubsection[{insertStore}]{\setlength{\rightskip}{0pt plus 5cm}void insertStore ({\bf DynInstPtr} \& {\em store\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a6a4b4e51bfff3639932ebaba45e8a282}
Inserts a store instruction. 


\begin{DoxyCode}
386 {
387     // Make sure it is not full before inserting an instruction.
388     assert((storeTail + 1) % SQEntries != storeHead);
389     assert(stores < SQEntries);
390 
391     DPRINTF(LSQUnit, "Inserting store PC %s, idx:%i [sn:%lli]\n",
392             store_inst->pcState(), storeTail, store_inst->seqNum);
393 
394     store_inst->sqIdx = storeTail;
395     store_inst->lqIdx = loadTail;
396 
397     storeQueue[storeTail] = SQEntry(store_inst);
398 
399     incrStIdx(storeTail);
400 
401     ++stores;
402 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a479432127ee77145cc19d6a2d1590821}{
\index{LSQUnit@{LSQUnit}!isEmpty@{isEmpty}}
\index{isEmpty@{isEmpty}!LSQUnit@{LSQUnit}}
\subsubsection[{isEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool isEmpty () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a479432127ee77145cc19d6a2d1590821}
Returns if both the LQ and SQ are empty. 


\begin{DoxyCode}
214 { return lqEmpty() && sqEmpty(); }
\end{DoxyCode}
\hypertarget{classLSQUnit_a3e70330939fdfc4dbc2f60c1a660584d}{
\index{LSQUnit@{LSQUnit}!isFull@{isFull}}
\index{isFull@{isFull}!LSQUnit@{LSQUnit}}
\subsubsection[{isFull}]{\setlength{\rightskip}{0pt plus 5cm}bool isFull ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a3e70330939fdfc4dbc2f60c1a660584d}
Returns if either the LQ or SQ is full. 


\begin{DoxyCode}
211 { return lqFull() || sqFull(); }
\end{DoxyCode}
\hypertarget{classLSQUnit_ad0aa91a7b51ca925abf9c9992abad314}{
\index{LSQUnit@{LSQUnit}!isLoadBlockedHandled@{isLoadBlockedHandled}}
\index{isLoadBlockedHandled@{isLoadBlockedHandled}!LSQUnit@{LSQUnit}}
\subsubsection[{isLoadBlockedHandled}]{\setlength{\rightskip}{0pt plus 5cm}bool isLoadBlockedHandled ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_ad0aa91a7b51ca925abf9c9992abad314}
Returns if the blocked load was handled. 


\begin{DoxyCode}
195     { return loadBlockedHandled; }
\end{DoxyCode}
\hypertarget{classLSQUnit_af8eb8590fbfa6ecd2f796390677a4c00}{
\index{LSQUnit@{LSQUnit}!isStalled@{isStalled}}
\index{isStalled@{isStalled}!LSQUnit@{LSQUnit}}
\subsubsection[{isStalled}]{\setlength{\rightskip}{0pt plus 5cm}bool isStalled ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_af8eb8590fbfa6ecd2f796390677a4c00}
Returns whether or not the \hyperlink{classLSQ}{LSQ} unit is stalled. 


\begin{DoxyCode}
567 { return stalled; }
\end{DoxyCode}
\hypertarget{classLSQUnit_a05c413ba417c6453e99f75d87c958590}{
\index{LSQUnit@{LSQUnit}!loadBlocked@{loadBlocked}}
\index{loadBlocked@{loadBlocked}!LSQUnit@{LSQUnit}}
\subsubsection[{loadBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool loadBlocked ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a05c413ba417c6453e99f75d87c958590}
Returns if a load became blocked due to the memory system. 


\begin{DoxyCode}
187     { return isLoadBlocked; }
\end{DoxyCode}
\hypertarget{classLSQUnit_a01d2807c1345befcffd168a2a9dbdbf2}{
\index{LSQUnit@{LSQUnit}!lqEmpty@{lqEmpty}}
\index{lqEmpty@{lqEmpty}!LSQUnit@{LSQUnit}}
\subsubsection[{lqEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool lqEmpty () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a01d2807c1345befcffd168a2a9dbdbf2}
Returns if the LQ is empty. 


\begin{DoxyCode}
223 { return loads == 0; }
\end{DoxyCode}
\hypertarget{classLSQUnit_a5893daf623130be826f492bbff58f757}{
\index{LSQUnit@{LSQUnit}!lqFull@{lqFull}}
\index{lqFull@{lqFull}!LSQUnit@{LSQUnit}}
\subsubsection[{lqFull}]{\setlength{\rightskip}{0pt plus 5cm}bool lqFull ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a5893daf623130be826f492bbff58f757}
Returns if the LQ is full. 


\begin{DoxyCode}
217 { return loads >= (LQEntries - 1); }
\end{DoxyCode}
\hypertarget{classLSQUnit_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{LSQUnit@{LSQUnit}!name@{name}}
\index{name@{name}!LSQUnit@{LSQUnit}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a37627d5d5bba7f4a8690c71c2ab3cb07}
Returns the name of the \hyperlink{classLSQ}{LSQ} unit. 


\begin{DoxyCode}
211 {
212     if (Impl::MaxThreads == 1) {
213         return iewStage->name() + ".lsq";
214     } else {
215         return iewStage->name() + ".lsq.thread" + to_string(lsqID);
216     }
217 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a028971a565aca048c67ea1c36a6a9d51}{
\index{LSQUnit@{LSQUnit}!numFreeEntries@{numFreeEntries}}
\index{numFreeEntries@{numFreeEntries}!LSQUnit@{LSQUnit}}
\subsubsection[{numFreeEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned numFreeEntries ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a028971a565aca048c67ea1c36a6a9d51}
Returns the number of free entries (min of free LQ and SQ entries). 


\begin{DoxyCode}
418 {
419     unsigned free_lq_entries = LQEntries - loads;
420     unsigned free_sq_entries = SQEntries - stores;
421 
422     // Both the LQ and SQ entries have an extra dummy entry to differentiate
423     // empty/full conditions.  Subtract 1 from the free entries.
424     if (free_lq_entries < free_sq_entries) {
425         return free_lq_entries - 1;
426     } else {
427         return free_sq_entries - 1;
428     }
429 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a54460b759fb06e2b18e26657279a6f49}{
\index{LSQUnit@{LSQUnit}!numLoads@{numLoads}}
\index{numLoads@{numLoads}!LSQUnit@{LSQUnit}}
\subsubsection[{numLoads}]{\setlength{\rightskip}{0pt plus 5cm}int numLoads ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a54460b759fb06e2b18e26657279a6f49}
Returns the number of loads in the LQ. 


\begin{DoxyCode}
205 { return loads; }
\end{DoxyCode}
\hypertarget{classLSQUnit_aa0fc32a4a9d77696f5907f4d25e7d07f}{
\index{LSQUnit@{LSQUnit}!numStores@{numStores}}
\index{numStores@{numStores}!LSQUnit@{LSQUnit}}
\subsubsection[{numStores}]{\setlength{\rightskip}{0pt plus 5cm}int numStores ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_aa0fc32a4a9d77696f5907f4d25e7d07f}
Returns the number of stores in the SQ. 


\begin{DoxyCode}
208 { return stores; }
\end{DoxyCode}
\hypertarget{classLSQUnit_a276cdbdaf4551f1b846c4e2535c5f882}{
\index{LSQUnit@{LSQUnit}!numStoresToWB@{numStoresToWB}}
\index{numStoresToWB@{numStoresToWB}!LSQUnit@{LSQUnit}}
\subsubsection[{numStoresToWB}]{\setlength{\rightskip}{0pt plus 5cm}int numStoresToWB ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a276cdbdaf4551f1b846c4e2535c5f882}
Returns the number of stores to writeback. 


\begin{DoxyCode}
235 { return storesToWB; }
\end{DoxyCode}
\hypertarget{classLSQUnit_a6f61d3e96e7ebc628121a63027d9c106}{
\index{LSQUnit@{LSQUnit}!read@{read}}
\index{read@{read}!LSQUnit@{LSQUnit}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} read ({\bf Request} $\ast$ {\em req}, \/  {\bf Request} $\ast$ {\em sreqLow}, \/  {\bf Request} $\ast$ {\em sreqHigh}, \/  uint8\_\-t $\ast$ {\em data}, \/  int {\em load\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a6f61d3e96e7ebc628121a63027d9c106}
Executes the load at the given index. 


\begin{DoxyCode}
574 {
575     DynInstPtr load_inst = loadQueue[load_idx];
576 
577     assert(load_inst);
578 
579     assert(!load_inst->isExecuted());
580 
581     // Make sure this isn't an uncacheable access
582     // A bit of a hackish way to get uncached accesses to work only if they're
583     // at the head of the LSQ and are ready to commit (at the head of the ROB
584     // too).
585     if (req->isUncacheable() &&
586         (load_idx != loadHead || !load_inst->isAtCommit())) {
587         iewStage->rescheduleMemInst(load_inst);
588         ++lsqRescheduledLoads;
589         DPRINTF(LSQUnit, "Uncachable load [sn:%lli] PC %s\n",
590                 load_inst->seqNum, load_inst->pcState());
591 
592         // Must delete request now that it wasn't handed off to
593         // memory.  This is quite ugly.  @todo: Figure out the proper
594         // place to really handle request deletes.
595         delete req;
596         if (TheISA::HasUnalignedMemAcc && sreqLow) {
597             delete sreqLow;
598             delete sreqHigh;
599         }
600         return new GenericISA::M5PanicFault(
601                 "Uncachable load [sn:%llx] PC %s\n",
602                 load_inst->seqNum, load_inst->pcState());
603     }
604 
605     // Check the SQ for any previous stores that might lead to forwarding
606     int store_idx = load_inst->sqIdx;
607 
608     int store_size = 0;
609 
610     DPRINTF(LSQUnit, "Read called, load idx: %i, store idx: %i, "
611             "storeHead: %i addr: %#x%s\n",
612             load_idx, store_idx, storeHead, req->getPaddr(),
613             sreqLow ? " split" : "");
614 
615     if (req->isLLSC()) {
616         assert(!sreqLow);
617         // Disable recording the result temporarily.  Writing to misc
618         // regs normally updates the result, but this is not the
619         // desired behavior when handling store conditionals.
620         load_inst->recordResult(false);
621         TheISA::handleLockedRead(load_inst.get(), req);
622         load_inst->recordResult(true);
623     }
624 
625     if (req->isMmappedIpr()) {
626         assert(!load_inst->memData);
627         load_inst->memData = new uint8_t[64];
628 
629         ThreadContext *thread = cpu->tcBase(lsqID);
630         Cycles delay(0);
631         PacketPtr data_pkt = new Packet(req, MemCmd::ReadReq);
632 
633         if (!TheISA::HasUnalignedMemAcc || !sreqLow) {
634             data_pkt->dataStatic(load_inst->memData);
635             delay = TheISA::handleIprRead(thread, data_pkt);
636         } else {
637             assert(sreqLow->isMmappedIpr() && sreqHigh->isMmappedIpr());
638             PacketPtr fst_data_pkt = new Packet(sreqLow, MemCmd::ReadReq);
639             PacketPtr snd_data_pkt = new Packet(sreqHigh, MemCmd::ReadReq);
640 
641             fst_data_pkt->dataStatic(load_inst->memData);
642             snd_data_pkt->dataStatic(load_inst->memData + sreqLow->getSize());
643 
644             delay = TheISA::handleIprRead(thread, fst_data_pkt);
645             Cycles delay2 = TheISA::handleIprRead(thread, snd_data_pkt);
646             if (delay2 > delay)
647                 delay = delay2;
648 
649             delete sreqLow;
650             delete sreqHigh;
651             delete fst_data_pkt;
652             delete snd_data_pkt;
653         }
654         WritebackEvent *wb = new WritebackEvent(load_inst, data_pkt, this);
655         cpu->schedule(wb, cpu->clockEdge(delay));
656         return NoFault;
657     }
658 
659     while (store_idx != -1) {
660         // End once we've reached the top of the LSQ
661         if (store_idx == storeWBIdx) {
662             break;
663         }
664 
665         // Move the index to one younger
666         if (--store_idx < 0)
667             store_idx += SQEntries;
668 
669         assert(storeQueue[store_idx].inst);
670 
671         store_size = storeQueue[store_idx].size;
672 
673         if (store_size == 0)
674             continue;
675         else if (storeQueue[store_idx].inst->uncacheable())
676             continue;
677 
678         assert(storeQueue[store_idx].inst->effAddrValid());
679 
680         // Check if the store data is within the lower and upper bounds of
681         // addresses that the request needs.
682         bool store_has_lower_limit =
683             req->getVaddr() >= storeQueue[store_idx].inst->effAddr;
684         bool store_has_upper_limit =
685             (req->getVaddr() + req->getSize()) <=
686             (storeQueue[store_idx].inst->effAddr + store_size);
687         bool lower_load_has_store_part =
688             req->getVaddr() < (storeQueue[store_idx].inst->effAddr +
689                            store_size);
690         bool upper_load_has_store_part =
691             (req->getVaddr() + req->getSize()) >
692             storeQueue[store_idx].inst->effAddr;
693 
694         // If the store's data has all of the data needed, we can forward.
695         if ((store_has_lower_limit && store_has_upper_limit)) {
696             // Get shift amount for offset into the store's data.
697             int shift_amt = req->getVaddr() - storeQueue[store_idx].inst->effAddr
      ;
698 
699 
700             //copy data
701             if (storeQueue[store_idx].isAllZeros)
702                 memset(data, 0, req->getSize());
703             else
704                 memcpy(data, storeQueue[store_idx].data + shift_amt,
705                    req->getSize());
706 
707             assert(!load_inst->memData);
708             load_inst->memData = new uint8_t[req->getSize()];
709             if (storeQueue[store_idx].isAllZeros)
710                 memset(load_inst->memData, 0, req->getSize());
711             else
712                 memcpy(load_inst->memData,
713                     storeQueue[store_idx].data + shift_amt, req->getSize());
714 
715             DPRINTF(LSQUnit, "Forwarding from store idx %i to load to "
716                     "addr %#x\n", store_idx, req->getVaddr());
717 
718             PacketPtr data_pkt = new Packet(req, MemCmd::ReadReq);
719             data_pkt->dataStatic(load_inst->memData);
720 
721             WritebackEvent *wb = new WritebackEvent(load_inst, data_pkt, this);
722 
723             // We'll say this has a 1 cycle load-store forwarding latency
724             // for now.
725             // @todo: Need to make this a parameter.
726             cpu->schedule(wb, curTick());
727 
728             // Don't need to do anything special for split loads.
729             if (TheISA::HasUnalignedMemAcc && sreqLow) {
730                 delete sreqLow;
731                 delete sreqHigh;
732             }
733 
734             ++lsqForwLoads;
735             return NoFault;
736         } else if ((store_has_lower_limit && lower_load_has_store_part) ||
737                    (store_has_upper_limit && upper_load_has_store_part) ||
738                    (lower_load_has_store_part && upper_load_has_store_part)) {
739             // This is the partial store-load forwarding case where a store
740             // has only part of the load's data.
741 
742             // If it's already been written back, then don't worry about
743             // stalling on it.
744             if (storeQueue[store_idx].completed) {
745                 panic("Should not check one of these");
746                 continue;
747             }
748 
749             // Must stall load and force it to retry, so long as it's the oldest
750             // load that needs to do so.
751             if (!stalled ||
752                 (stalled &&
753                  load_inst->seqNum <
754                  loadQueue[stallingLoadIdx]->seqNum)) {
755                 stalled = true;
756                 stallingStoreIsn = storeQueue[store_idx].inst->seqNum;
757                 stallingLoadIdx = load_idx;
758             }
759 
760             // Tell IQ/mem dep unit that this instruction will need to be
761             // rescheduled eventually
762             iewStage->rescheduleMemInst(load_inst);
763             iewStage->decrWb(load_inst->seqNum);
764             load_inst->clearIssued();
765             ++lsqRescheduledLoads;
766 
767             // Do not generate a writeback event as this instruction is not
768             // complete.
769             DPRINTF(LSQUnit, "Load-store forwarding mis-match. "
770                     "Store idx %i to load addr %#x\n",
771                     store_idx, req->getVaddr());
772 
773             // Must delete request now that it wasn't handed off to
774             // memory.  This is quite ugly.  @todo: Figure out the
775             // proper place to really handle request deletes.
776             delete req;
777             if (TheISA::HasUnalignedMemAcc && sreqLow) {
778                 delete sreqLow;
779                 delete sreqHigh;
780             }
781 
782             return NoFault;
783         }
784     }
785 
786     // If there's no forwarding case, then go access memory
787     DPRINTF(LSQUnit, "Doing memory access for inst [sn:%lli] PC %s\n",
788             load_inst->seqNum, load_inst->pcState());
789 
790     assert(!load_inst->memData);
791     load_inst->memData = new uint8_t[req->getSize()];
792 
793     ++usedPorts;
794 
795     // if we the cache is not blocked, do cache access
796     bool completedFirst = false;
797     if (!lsq->cacheBlocked()) {
798         MemCmd command =
799             req->isLLSC() ? MemCmd::LoadLockedReq : MemCmd::ReadReq;
800         PacketPtr data_pkt = new Packet(req, command);
801         PacketPtr fst_data_pkt = NULL;
802         PacketPtr snd_data_pkt = NULL;
803 
804         data_pkt->dataStatic(load_inst->memData);
805 
806         LSQSenderState *state = new LSQSenderState;
807         state->isLoad = true;
808         state->idx = load_idx;
809         state->inst = load_inst;
810         data_pkt->senderState = state;
811 
812         if (!TheISA::HasUnalignedMemAcc || !sreqLow) {
813 
814             // Point the first packet at the main data packet.
815             fst_data_pkt = data_pkt;
816         } else {
817 
818             // Create the split packets.
819             fst_data_pkt = new Packet(sreqLow, command);
820             snd_data_pkt = new Packet(sreqHigh, command);
821 
822             fst_data_pkt->dataStatic(load_inst->memData);
823             snd_data_pkt->dataStatic(load_inst->memData + sreqLow->getSize());
824 
825             fst_data_pkt->senderState = state;
826             snd_data_pkt->senderState = state;
827 
828             state->isSplit = true;
829             state->outstanding = 2;
830             state->mainPkt = data_pkt;
831         }
832 
833         if (!dcachePort->sendTimingReq(fst_data_pkt)) {
834             // Delete state and data packet because a load retry
835             // initiates a pipeline restart; it does not retry.
836             delete state;
837             delete data_pkt->req;
838             delete data_pkt;
839             if (TheISA::HasUnalignedMemAcc && sreqLow) {
840                 delete fst_data_pkt->req;
841                 delete fst_data_pkt;
842                 delete snd_data_pkt->req;
843                 delete snd_data_pkt;
844                 sreqLow = NULL;
845                 sreqHigh = NULL;
846             }
847 
848             req = NULL;
849 
850             // If the access didn't succeed, tell the LSQ by setting
851             // the retry thread id.
852             lsq->setRetryTid(lsqID);
853         } else if (TheISA::HasUnalignedMemAcc && sreqLow) {
854             completedFirst = true;
855 
856             // The first packet was sent without problems, so send this one
857             // too. If there is a problem with this packet then the whole
858             // load will be squashed, so indicate this to the state object.
859             // The first packet will return in completeDataAccess and be
860             // handled there.
861             ++usedPorts;
862             if (!dcachePort->sendTimingReq(snd_data_pkt)) {
863 
864                 // The main packet will be deleted in completeDataAccess.
865                 delete snd_data_pkt->req;
866                 delete snd_data_pkt;
867 
868                 state->complete();
869 
870                 req = NULL;
871                 sreqHigh = NULL;
872 
873                 lsq->setRetryTid(lsqID);
874             }
875         }
876     }
877 
878     // If the cache was blocked, or has become blocked due to the access,
879     // handle it.
880     if (lsq->cacheBlocked()) {
881         if (req)
882             delete req;
883         if (TheISA::HasUnalignedMemAcc && sreqLow && !completedFirst) {
884             delete sreqLow;
885             delete sreqHigh;
886         }
887 
888         ++lsqCacheBlocked;
889 
890         // If the first part of a split access succeeds, then let the LSQ
891         // handle the decrWb when completeDataAccess is called upon return
892         // of the requested first part of data
893         if (!completedFirst)
894             iewStage->decrWb(load_inst->seqNum);
895 
896         // There's an older load that's already going to squash.
897         if (isLoadBlocked && blockedLoadSeqNum < load_inst->seqNum)
898             return NoFault;
899 
900         // Record that the load was blocked due to memory.  This
901         // load will squash all instructions after it, be
902         // refetched, and re-executed.
903         isLoadBlocked = true;
904         loadBlockedHandled = false;
905         blockedLoadSeqNum = load_inst->seqNum;
906         // No fault occurred, even though the interface is blocked.
907         return NoFault;
908     }
909 
910     return NoFault;
911 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a29cb5a4f98063ce6e9210eacbdb35298}{
\index{LSQUnit@{LSQUnit}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!LSQUnit@{LSQUnit}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetry ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a29cb5a4f98063ce6e9210eacbdb35298}
Handles doing the retry. 


\begin{DoxyCode}
1227 {
1228     if (isStoreBlocked) {
1229         DPRINTF(LSQUnit, "Receiving retry: store blocked\n");
1230         assert(retryPkt != NULL);
1231 
1232         LSQSenderState *state =
1233             dynamic_cast<LSQSenderState *>(retryPkt->senderState);
1234 
1235         if (dcachePort->sendTimingReq(retryPkt)) {
1236             // Don't finish the store unless this is the last packet.
1237             if (!TheISA::HasUnalignedMemAcc || !state->pktToSend ||
1238                     state->pendingPacket == retryPkt) {
1239                 state->pktToSend = false;
1240                 storePostSend(retryPkt);
1241             }
1242             retryPkt = NULL;
1243             isStoreBlocked = false;
1244             lsq->setRetryTid(InvalidThreadID);
1245 
1246             // Send any outstanding packet.
1247             if (TheISA::HasUnalignedMemAcc && state->pktToSend) {
1248                 assert(state->pendingPacket);
1249                 if (sendStore(state->pendingPacket)) {
1250                     storePostSend(state->pendingPacket);
1251                 }
1252             }
1253         } else {
1254             // Still blocked!
1255             ++lsqCacheBlocked;
1256             lsq->setRetryTid(lsqID);
1257         }
1258     } else if (isLoadBlocked) {
1259         DPRINTF(LSQUnit, "Loads squash themselves and all younger insts, "
1260                 "no need to resend packet.\n");
1261     } else {
1262         DPRINTF(LSQUnit, "Retry received but LSQ is no longer blocked.\n");
1263     }
1264 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{LSQUnit@{LSQUnit}!regStats@{regStats}}
\index{regStats@{regStats}!LSQUnit@{LSQUnit}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a4dc637449366fcdfc4e764cdf12d9b11}
Registers statistics. 


\begin{DoxyCode}
222 {
223     lsqForwLoads
224         .name(name() + ".forwLoads")
225         .desc("Number of loads that had data forwarded from stores");
226 
227     invAddrLoads
228         .name(name() + ".invAddrLoads")
229         .desc("Number of loads ignored due to an invalid address");
230 
231     lsqSquashedLoads
232         .name(name() + ".squashedLoads")
233         .desc("Number of loads squashed");
234 
235     lsqIgnoredResponses
236         .name(name() + ".ignoredResponses")
237         .desc("Number of memory responses ignored because the instruction is squa
      shed");
238 
239     lsqMemOrderViolation
240         .name(name() + ".memOrderViolation")
241         .desc("Number of memory ordering violations");
242 
243     lsqSquashedStores
244         .name(name() + ".squashedStores")
245         .desc("Number of stores squashed");
246 
247     invAddrSwpfs
248         .name(name() + ".invAddrSwpfs")
249         .desc("Number of software prefetches ignored due to an invalid address");
      
250 
251     lsqBlockedLoads
252         .name(name() + ".blockedLoads")
253         .desc("Number of blocked loads due to partial load-store forwarding");
254 
255     lsqRescheduledLoads
256         .name(name() + ".rescheduledLoads")
257         .desc("Number of loads that were rescheduled");
258 
259     lsqCacheBlocked
260         .name(name() + ".cacheBlocked")
261         .desc("Number of times an access to memory failed due to the cache being 
      blocked");
262 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a755ee993c2d4e9d422c37990b15afa37}{
\index{LSQUnit@{LSQUnit}!resetState@{resetState}}
\index{resetState@{resetState}!LSQUnit@{LSQUnit}}
\subsubsection[{resetState}]{\setlength{\rightskip}{0pt plus 5cm}void resetState ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLSQUnit_a755ee993c2d4e9d422c37990b15afa37}
Reset the \hyperlink{classLSQ}{LSQ} state 


\begin{DoxyCode}
187 {
188     loads = stores = storesToWB = 0;
189 
190     loadHead = loadTail = 0;
191 
192     storeHead = storeWBIdx = storeTail = 0;
193 
194     usedPorts = 0;
195 
196     retryPkt = NULL;
197     memDepViolator = NULL;
198 
199     blockedLoadSeqNum = 0;
200 
201     stalled = false;
202     isLoadBlocked = false;
203     loadBlockedHandled = false;
204 
205     cacheBlockMask = ~(cpu->cacheLineSize() - 1);
206 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a3bc9500810cb2d5615e29206e2d6499f}{
\index{LSQUnit@{LSQUnit}!resizeLQ@{resizeLQ}}
\index{resizeLQ@{resizeLQ}!LSQUnit@{LSQUnit}}
\subsubsection[{resizeLQ}]{\setlength{\rightskip}{0pt plus 5cm}void resizeLQ (unsigned {\em size})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a3bc9500810cb2d5615e29206e2d6499f}
Resizes the LQ to a given size. 


\begin{DoxyCode}
306 {
307     unsigned size_plus_sentinel = size + 1;
308     assert(size_plus_sentinel >= LQEntries);
309 
310     if (size_plus_sentinel > LQEntries) {
311         while (size_plus_sentinel > loadQueue.size()) {
312             DynInstPtr dummy;
313             loadQueue.push_back(dummy);
314             LQEntries++;
315         }
316     } else {
317         LQEntries = size_plus_sentinel;
318     }
319 
320     assert(LQEntries <= 256);
321 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a341dd6a3bd8d240659fd9d698c3b5c65}{
\index{LSQUnit@{LSQUnit}!resizeSQ@{resizeSQ}}
\index{resizeSQ@{resizeSQ}!LSQUnit@{LSQUnit}}
\subsubsection[{resizeSQ}]{\setlength{\rightskip}{0pt plus 5cm}void resizeSQ (unsigned {\em size})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a341dd6a3bd8d240659fd9d698c3b5c65}
Resizes the SQ to a given size. 


\begin{DoxyCode}
326 {
327     unsigned size_plus_sentinel = size + 1;
328     if (size_plus_sentinel > SQEntries) {
329         while (size_plus_sentinel > storeQueue.size()) {
330             SQEntry dummy;
331             storeQueue.push_back(dummy);
332             SQEntries++;
333         }
334     } else {
335         SQEntries = size_plus_sentinel;
336     }
337 
338     assert(SQEntries <= 256);
339 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a268a51a93dbdda9a0cff48ba036e673e}{
\index{LSQUnit@{LSQUnit}!sendStore@{sendStore}}
\index{sendStore@{sendStore}!LSQUnit@{LSQUnit}}
\subsubsection[{sendStore}]{\setlength{\rightskip}{0pt plus 5cm}bool sendStore ({\bf PacketPtr} {\em data\_\-pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLSQUnit_a268a51a93dbdda9a0cff48ba036e673e}
Attempts to send a store to the cache. 


\begin{DoxyCode}
1211 {
1212     if (!dcachePort->sendTimingReq(data_pkt)) {
1213         // Need to handle becoming blocked on a store.
1214         isStoreBlocked = true;
1215         ++lsqCacheBlocked;
1216         assert(retryPkt == NULL);
1217         retryPkt = data_pkt;
1218         lsq->setRetryTid(lsqID);
1219         return false;
1220     }
1221     return true;
1222 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a8d77cc755c7a424f4eb80130fb627012}{
\index{LSQUnit@{LSQUnit}!setDcachePort@{setDcachePort}}
\index{setDcachePort@{setDcachePort}!LSQUnit@{LSQUnit}}
\subsubsection[{setDcachePort}]{\setlength{\rightskip}{0pt plus 5cm}void setDcachePort ({\bf MasterPort} $\ast$ {\em dcache\_\-port})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a8d77cc755c7a424f4eb80130fb627012}
Sets the pointer to the dcache port. 


\begin{DoxyCode}
267 {
268     dcachePort = dcache_port;
269 }
\end{DoxyCode}
\hypertarget{classLSQUnit_ac8bfb1e163f7ba2261d702623226973d}{
\index{LSQUnit@{LSQUnit}!setLoadBlockedHandled@{setLoadBlockedHandled}}
\index{setLoadBlockedHandled@{setLoadBlockedHandled}!LSQUnit@{LSQUnit}}
\subsubsection[{setLoadBlockedHandled}]{\setlength{\rightskip}{0pt plus 5cm}void setLoadBlockedHandled ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_ac8bfb1e163f7ba2261d702623226973d}
Records the blocked load as being handled. 


\begin{DoxyCode}
199     { loadBlockedHandled = true; }
\end{DoxyCode}
\hypertarget{classLSQUnit_a5761e9640bec8ba8474945cce57b6501}{
\index{LSQUnit@{LSQUnit}!sqEmpty@{sqEmpty}}
\index{sqEmpty@{sqEmpty}!LSQUnit@{LSQUnit}}
\subsubsection[{sqEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool sqEmpty () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a5761e9640bec8ba8474945cce57b6501}
Returns if the SQ is empty. 


\begin{DoxyCode}
226 { return stores == 0; }
\end{DoxyCode}
\hypertarget{classLSQUnit_a477981d1f905d2d398a1527f7149e3c4}{
\index{LSQUnit@{LSQUnit}!sqFull@{sqFull}}
\index{sqFull@{sqFull}!LSQUnit@{LSQUnit}}
\subsubsection[{sqFull}]{\setlength{\rightskip}{0pt plus 5cm}bool sqFull ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a477981d1f905d2d398a1527f7149e3c4}
Returns if the SQ is full. 


\begin{DoxyCode}
220 { return stores >= (SQEntries - 1); }
\end{DoxyCode}
\hypertarget{classLSQUnit_a51dd7e304d5413447717826fac6f4921}{
\index{LSQUnit@{LSQUnit}!squash@{squash}}
\index{squash@{squash}!LSQUnit@{LSQUnit}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash (const {\bf InstSeqNum} \& {\em squashed\_\-num})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a51dd7e304d5413447717826fac6f4921}
Squashes all instructions younger than a specific sequence number. 


\begin{DoxyCode}
992 {
993     DPRINTF(LSQUnit, "Squashing until [sn:%lli]!"
994             "(Loads:%i Stores:%i)\n", squashed_num, loads, stores);
995 
996     int load_idx = loadTail;
997     decrLdIdx(load_idx);
998 
999     while (loads != 0 && loadQueue[load_idx]->seqNum > squashed_num) {
1000         DPRINTF(LSQUnit,"Load Instruction PC %s squashed, "
1001                 "[sn:%lli]\n",
1002                 loadQueue[load_idx]->pcState(),
1003                 loadQueue[load_idx]->seqNum);
1004 
1005         if (isStalled() && load_idx == stallingLoadIdx) {
1006             stalled = false;
1007             stallingStoreIsn = 0;
1008             stallingLoadIdx = 0;
1009         }
1010 
1011         // Clear the smart pointer to make sure it is decremented.
1012         loadQueue[load_idx]->setSquashed();
1013         loadQueue[load_idx] = NULL;
1014         --loads;
1015 
1016         // Inefficient!
1017         loadTail = load_idx;
1018 
1019         decrLdIdx(load_idx);
1020         ++lsqSquashedLoads;
1021     }
1022 
1023     if (isLoadBlocked) {
1024         if (squashed_num < blockedLoadSeqNum) {
1025             isLoadBlocked = false;
1026             loadBlockedHandled = false;
1027             blockedLoadSeqNum = 0;
1028         }
1029     }
1030 
1031     if (memDepViolator && squashed_num < memDepViolator->seqNum) {
1032         memDepViolator = NULL;
1033     }
1034 
1035     int store_idx = storeTail;
1036     decrStIdx(store_idx);
1037 
1038     while (stores != 0 &&
1039            storeQueue[store_idx].inst->seqNum > squashed_num) {
1040         // Instructions marked as can WB are already committed.
1041         if (storeQueue[store_idx].canWB) {
1042             break;
1043         }
1044 
1045         DPRINTF(LSQUnit,"Store Instruction PC %s squashed, "
1046                 "idx:%i [sn:%lli]\n",
1047                 storeQueue[store_idx].inst->pcState(),
1048                 store_idx, storeQueue[store_idx].inst->seqNum);
1049 
1050         // I don't think this can happen.  It should have been cleared
1051         // by the stalling load.
1052         if (isStalled() &&
1053             storeQueue[store_idx].inst->seqNum == stallingStoreIsn) {
1054             panic("Is stalled should have been cleared by stalling load!\n");
1055             stalled = false;
1056             stallingStoreIsn = 0;
1057         }
1058 
1059         // Clear the smart pointer to make sure it is decremented.
1060         storeQueue[store_idx].inst->setSquashed();
1061         storeQueue[store_idx].inst = NULL;
1062         storeQueue[store_idx].canWB = 0;
1063 
1064         // Must delete request now that it wasn't handed off to
1065         // memory.  This is quite ugly.  @todo: Figure out the proper
1066         // place to really handle request deletes.
1067         delete storeQueue[store_idx].req;
1068         if (TheISA::HasUnalignedMemAcc && storeQueue[store_idx].isSplit) {
1069             delete storeQueue[store_idx].sreqLow;
1070             delete storeQueue[store_idx].sreqHigh;
1071 
1072             storeQueue[store_idx].sreqLow = NULL;
1073             storeQueue[store_idx].sreqHigh = NULL;
1074         }
1075 
1076         storeQueue[store_idx].req = NULL;
1077         --stores;
1078 
1079         // Inefficient!
1080         storeTail = store_idx;
1081 
1082         decrStIdx(store_idx);
1083         ++lsqSquashedStores;
1084     }
1085 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a6f23a0d213e7d35f445f9cabfd2ed0cc}{
\index{LSQUnit@{LSQUnit}!storePostSend@{storePostSend}}
\index{storePostSend@{storePostSend}!LSQUnit@{LSQUnit}}
\subsubsection[{storePostSend}]{\setlength{\rightskip}{0pt plus 5cm}void storePostSend ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLSQUnit_a6f23a0d213e7d35f445f9cabfd2ed0cc}
Handles completing the send of a store to memory. 


\begin{DoxyCode}
1090 {
1091     if (isStalled() &&
1092         storeQueue[storeWBIdx].inst->seqNum == stallingStoreIsn) {
1093         DPRINTF(LSQUnit, "Unstalling, stalling store [sn:%lli] "
1094                 "load idx:%i\n",
1095                 stallingStoreIsn, stallingLoadIdx);
1096         stalled = false;
1097         stallingStoreIsn = 0;
1098         iewStage->replayMemInst(loadQueue[stallingLoadIdx]);
1099     }
1100 
1101     if (!storeQueue[storeWBIdx].inst->isStoreConditional()) {
1102         // The store is basically completed at this time. This
1103         // only works so long as the checker doesn't try to
1104         // verify the value in memory for stores.
1105         storeQueue[storeWBIdx].inst->setCompleted();
1106 
1107         if (cpu->checker) {
1108             cpu->checker->verify(storeQueue[storeWBIdx].inst);
1109         }
1110     }
1111 
1112     if (needsTSO) {
1113         storeInFlight = true;
1114     }
1115 
1116     incrStIdx(storeWBIdx);
1117 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a8674059ce345e23aac5086b2c3e24a43}{
\index{LSQUnit@{LSQUnit}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!LSQUnit@{LSQUnit}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a8674059ce345e23aac5086b2c3e24a43}
Takes over from another CPU's thread. 


\begin{DoxyCode}
299 {
300     resetState();
301 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a873dd91783f9efb4a590aded1f70d6b0}{
\index{LSQUnit@{LSQUnit}!tick@{tick}}
\index{tick@{tick}!LSQUnit@{LSQUnit}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a873dd91783f9efb4a590aded1f70d6b0}
Ticks the \hyperlink{classLSQ}{LSQ} unit, which in this case only resets the number of used cache ports. \begin{Desc}
\item[\hyperlink{todo__todo000035}{TODO}]: Move the number of used ports up to the \hyperlink{classLSQ}{LSQ} level so it can be shared by all \hyperlink{classLSQ}{LSQ} units. \end{Desc}



\begin{DoxyCode}
117 { usedPorts = 0; }
\end{DoxyCode}
\hypertarget{classLSQUnit_a4f720bbfb5fdefdb23516500eeb0b4de}{
\index{LSQUnit@{LSQUnit}!violation@{violation}}
\index{violation@{violation}!LSQUnit@{LSQUnit}}
\subsubsection[{violation}]{\setlength{\rightskip}{0pt plus 5cm}bool violation ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a4f720bbfb5fdefdb23516500eeb0b4de}
Returns if there is a memory ordering violation. Value is reset upon call to \hyperlink{classLSQUnit_a30adaf6f5fb6b38b5747f35c419e3f31}{getMemDepViolator()}. 


\begin{DoxyCode}
180 { return memDepViolator; }
\end{DoxyCode}
\hypertarget{classLSQUnit_a338be821734603396bfef8d9fb8f04b0}{
\index{LSQUnit@{LSQUnit}!willWB@{willWB}}
\index{willWB@{willWB}!LSQUnit@{LSQUnit}}
\subsubsection[{willWB}]{\setlength{\rightskip}{0pt plus 5cm}bool willWB ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a338be821734603396bfef8d9fb8f04b0}
Returns if the \hyperlink{classLSQ}{LSQ} unit will writeback on this cycle. 


\begin{DoxyCode}
238                   { return storeQueue[storeWBIdx].canWB &&
239                         !storeQueue[storeWBIdx].completed &&
240                         !isStoreBlocked; }
\end{DoxyCode}
\hypertarget{classLSQUnit_a8910d991217dd388c788727f8ebbb267}{
\index{LSQUnit@{LSQUnit}!write@{write}}
\index{write@{write}!LSQUnit@{LSQUnit}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} write ({\bf Request} $\ast$ {\em req}, \/  {\bf Request} $\ast$ {\em sreqLow}, \/  {\bf Request} $\ast$ {\em sreqHigh}, \/  uint8\_\-t $\ast$ {\em data}, \/  int {\em store\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a8910d991217dd388c788727f8ebbb267}
Executes the store at the given index. 


\begin{DoxyCode}
917 {
918     assert(storeQueue[store_idx].inst);
919 
920     DPRINTF(LSQUnit, "Doing write to store idx %i, addr %#x"
921             " | storeHead:%i [sn:%i]\n",
922             store_idx, req->getPaddr(), storeHead,
923             storeQueue[store_idx].inst->seqNum);
924 
925     storeQueue[store_idx].req = req;
926     storeQueue[store_idx].sreqLow = sreqLow;
927     storeQueue[store_idx].sreqHigh = sreqHigh;
928     unsigned size = req->getSize();
929     storeQueue[store_idx].size = size;
930     storeQueue[store_idx].isAllZeros = req->getFlags() & 
      Request::CACHE_BLOCK_ZERO;
931     assert(size <= sizeof(storeQueue[store_idx].data) ||
932             (req->getFlags() & Request::CACHE_BLOCK_ZERO));
933 
934     // Split stores can only occur in ISAs with unaligned memory accesses.  If
935     // a store request has been split, sreqLow and sreqHigh will be non-null.
936     if (TheISA::HasUnalignedMemAcc && sreqLow) {
937         storeQueue[store_idx].isSplit = true;
938     }
939 
940     if (!(req->getFlags() & Request::CACHE_BLOCK_ZERO))
941         memcpy(storeQueue[store_idx].data, data, size);
942 
943     // This function only writes the data to the store queue, so no fault
944     // can happen here.
945     return NoFault;
946 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a3911bacb8817c31cfbeefd125dba0217}{
\index{LSQUnit@{LSQUnit}!writeback@{writeback}}
\index{writeback@{writeback}!LSQUnit@{LSQUnit}}
\subsubsection[{writeback}]{\setlength{\rightskip}{0pt plus 5cm}void writeback ({\bf DynInstPtr} \& {\em inst}, \/  {\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLSQUnit_a3911bacb8817c31cfbeefd125dba0217}
Writes back the instruction, sending it to IEW. 


\begin{DoxyCode}
1122 {
1123     iewStage->wakeCPU();
1124 
1125     // Squashed instructions do not need to complete their access.
1126     if (inst->isSquashed()) {
1127         iewStage->decrWb(inst->seqNum);
1128         assert(!inst->isStore());
1129         ++lsqIgnoredResponses;
1130         return;
1131     }
1132 
1133     if (!inst->isExecuted()) {
1134         inst->setExecuted();
1135 
1136         // Complete access to copy data to proper place.
1137         inst->completeAcc(pkt);
1138     }
1139 
1140     // Need to insert instruction into queue to commit
1141     iewStage->instToCommit(inst);
1142 
1143     iewStage->activityThisCycle();
1144 
1145     // see if this load changed the PC
1146     iewStage->checkMisprediction(inst);
1147 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a173d8fd73280b1cf5b4d0dd9b68cf0cf}{
\index{LSQUnit@{LSQUnit}!writebackPendingStore@{writebackPendingStore}}
\index{writebackPendingStore@{writebackPendingStore}!LSQUnit@{LSQUnit}}
\subsubsection[{writebackPendingStore}]{\setlength{\rightskip}{0pt plus 5cm}void writebackPendingStore ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classLSQUnit_a173d8fd73280b1cf5b4d0dd9b68cf0cf}
Writes back a store that couldn't be completed the previous cycle. 


\begin{DoxyCode}
756 {
757     if (hasPendingPkt) {
758         assert(pendingPkt != NULL);
759 
760         // If the cache is blocked, this will store the packet for retry.
761         if (sendStore(pendingPkt)) {
762             storePostSend(pendingPkt);
763         }
764         pendingPkt = NULL;
765         hasPendingPkt = false;
766     }
767 }
\end{DoxyCode}
\hypertarget{classLSQUnit_a5f04e29d6f6feb8b86460491f2ba7547}{
\index{LSQUnit@{LSQUnit}!writebackStores@{writebackStores}}
\index{writebackStores@{writebackStores}!LSQUnit@{LSQUnit}}
\subsubsection[{writebackStores}]{\setlength{\rightskip}{0pt plus 5cm}void writebackStores ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLSQUnit_a5f04e29d6f6feb8b86460491f2ba7547}
Writes back stores. 


\begin{DoxyCode}
772 {
773     // First writeback the second packet from any split store that didn't
774     // complete last cycle because there weren't enough cache ports available.
775     if (TheISA::HasUnalignedMemAcc) {
776         writebackPendingStore();
777     }
778 
779     while (storesToWB > 0 &&
780            storeWBIdx != storeTail &&
781            storeQueue[storeWBIdx].inst &&
782            storeQueue[storeWBIdx].canWB &&
783            ((!needsTSO) || (!storeInFlight)) &&
784            usedPorts < cachePorts) {
785 
786         if (isStoreBlocked || lsq->cacheBlocked()) {
787             DPRINTF(LSQUnit, "Unable to write back any more stores, cache"
788                     " is blocked!\n");
789             break;
790         }
791 
792         // Store didn't write any data so no need to write it back to
793         // memory.
794         if (storeQueue[storeWBIdx].size == 0) {
795             completeStore(storeWBIdx);
796 
797             incrStIdx(storeWBIdx);
798 
799             continue;
800         }
801 
802         ++usedPorts;
803 
804         if (storeQueue[storeWBIdx].inst->isDataPrefetch()) {
805             incrStIdx(storeWBIdx);
806 
807             continue;
808         }
809 
810         assert(storeQueue[storeWBIdx].req);
811         assert(!storeQueue[storeWBIdx].committed);
812 
813         if (TheISA::HasUnalignedMemAcc && storeQueue[storeWBIdx].isSplit) {
814             assert(storeQueue[storeWBIdx].sreqLow);
815             assert(storeQueue[storeWBIdx].sreqHigh);
816         }
817 
818         DynInstPtr inst = storeQueue[storeWBIdx].inst;
819 
820         Request *req = storeQueue[storeWBIdx].req;
821         RequestPtr sreqLow = storeQueue[storeWBIdx].sreqLow;
822         RequestPtr sreqHigh = storeQueue[storeWBIdx].sreqHigh;
823 
824         storeQueue[storeWBIdx].committed = true;
825 
826         assert(!inst->memData);
827         inst->memData = new uint8_t[req->getSize()];
828 
829         if (storeQueue[storeWBIdx].isAllZeros)
830             memset(inst->memData, 0, req->getSize());
831         else
832             memcpy(inst->memData, storeQueue[storeWBIdx].data, req->getSize());
833 
834         MemCmd command =
835             req->isSwap() ? MemCmd::SwapReq :
836             (req->isLLSC() ? MemCmd::StoreCondReq : MemCmd::WriteReq);
837         PacketPtr data_pkt;
838         PacketPtr snd_data_pkt = NULL;
839 
840         LSQSenderState *state = new LSQSenderState;
841         state->isLoad = false;
842         state->idx = storeWBIdx;
843         state->inst = inst;
844 
845         if (!TheISA::HasUnalignedMemAcc || !storeQueue[storeWBIdx].isSplit) {
846 
847             // Build a single data packet if the store isn't split.
848             data_pkt = new Packet(req, command);
849             data_pkt->dataStatic(inst->memData);
850             data_pkt->senderState = state;
851         } else {
852             // Create two packets if the store is split in two.
853             data_pkt = new Packet(sreqLow, command);
854             snd_data_pkt = new Packet(sreqHigh, command);
855 
856             data_pkt->dataStatic(inst->memData);
857             snd_data_pkt->dataStatic(inst->memData + sreqLow->getSize());
858 
859             data_pkt->senderState = state;
860             snd_data_pkt->senderState = state;
861 
862             state->isSplit = true;
863             state->outstanding = 2;
864 
865             // Can delete the main request now.
866             delete req;
867             req = sreqLow;
868         }
869 
870         DPRINTF(LSQUnit, "D-Cache: Writing back store idx:%i PC:%s "
871                 "to Addr:%#x, data:%#x [sn:%lli]\n",
872                 storeWBIdx, inst->pcState(),
873                 req->getPaddr(), (int)*(inst->memData),
874                 inst->seqNum);
875 
876         // @todo: Remove this SC hack once the memory system handles it.
877         if (inst->isStoreConditional()) {
878             assert(!storeQueue[storeWBIdx].isSplit);
879             // Disable recording the result temporarily.  Writing to
880             // misc regs normally updates the result, but this is not
881             // the desired behavior when handling store conditionals.
882             inst->recordResult(false);
883             bool success = TheISA::handleLockedWrite(inst.get(), req, 
      cacheBlockMask);
884             inst->recordResult(true);
885 
886             if (!success) {
887                 // Instantly complete this store.
888                 DPRINTF(LSQUnit, "Store conditional [sn:%lli] failed.  "
889                         "Instantly completing it.\n",
890                         inst->seqNum);
891                 WritebackEvent *wb = new WritebackEvent(inst, data_pkt, this);
892                 cpu->schedule(wb, curTick() + 1);
893                 if (cpu->checker) {
894                     // Make sure to set the LLSC data for verification
895                     // if checker is loaded
896                     inst->reqToVerify->setExtraData(0);
897                     inst->completeAcc(data_pkt);
898                 }
899                 completeStore(storeWBIdx);
900                 incrStIdx(storeWBIdx);
901                 continue;
902             }
903         } else {
904             // Non-store conditionals do not need a writeback.
905             state->noWB = true;
906         }
907 
908         bool split =
909             TheISA::HasUnalignedMemAcc && storeQueue[storeWBIdx].isSplit;
910 
911         ThreadContext *thread = cpu->tcBase(lsqID);
912 
913         if (req->isMmappedIpr()) {
914             assert(!inst->isStoreConditional());
915             TheISA::handleIprWrite(thread, data_pkt);
916             delete data_pkt;
917             if (split) {
918                 assert(snd_data_pkt->req->isMmappedIpr());
919                 TheISA::handleIprWrite(thread, snd_data_pkt);
920                 delete snd_data_pkt;
921                 delete sreqLow;
922                 delete sreqHigh;
923             }
924             delete state;
925             delete req;
926             completeStore(storeWBIdx);
927             incrStIdx(storeWBIdx);
928         } else if (!sendStore(data_pkt)) {
929             DPRINTF(IEW, "D-Cache became blocked when writing [sn:%lli], will"
930                     "retry later\n",
931                     inst->seqNum);
932 
933             // Need to store the second packet, if split.
934             if (split) {
935                 state->pktToSend = true;
936                 state->pendingPacket = snd_data_pkt;
937             }
938         } else {
939 
940             // If split, try to send the second packet too
941             if (split) {
942                 assert(snd_data_pkt);
943 
944                 // Ensure there are enough ports to use.
945                 if (usedPorts < cachePorts) {
946                     ++usedPorts;
947                     if (sendStore(snd_data_pkt)) {
948                         storePostSend(snd_data_pkt);
949                     } else {
950                         DPRINTF(IEW, "D-Cache became blocked when writing"
951                                 " [sn:%lli] second packet, will retry later\n",
952                                 inst->seqNum);
953                     }
954                 } else {
955 
956                     // Store the packet for when there's free ports.
957                     assert(pendingPkt == NULL);
958                     pendingPkt = snd_data_pkt;
959                     hasPendingPkt = true;
960                 }
961             } else {
962 
963                 // Not a split store.
964                 storePostSend(data_pkt);
965             }
966         }
967     }
968 
969     // Not sure this should set it to 0.
970     usedPorts = 0;
971 
972     assert(stores >= 0 && storesToWB >= 0);
973 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classLSQUnit_a3fca34b247fd8d081557578f8ca60fe3}{
\index{LSQUnit@{LSQUnit}!blockedLoadSeqNum@{blockedLoadSeqNum}}
\index{blockedLoadSeqNum@{blockedLoadSeqNum}!LSQUnit@{LSQUnit}}
\subsubsection[{blockedLoadSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf blockedLoadSeqNum}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a3fca34b247fd8d081557578f8ca60fe3}
The sequence number of the blocked load. \hypertarget{classLSQUnit_af4264b12b32db39099b579e1ed670312}{
\index{LSQUnit@{LSQUnit}!cacheBlockMask@{cacheBlockMask}}
\index{cacheBlockMask@{cacheBlockMask}!LSQUnit@{LSQUnit}}
\subsubsection[{cacheBlockMask}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf cacheBlockMask}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_af4264b12b32db39099b579e1ed670312}
\hyperlink{classAddress}{Address} Mask for a cache block (e.g. $\sim$(cache\_\-block\_\-size-\/1)) \hypertarget{classLSQUnit_ab2e23636971c40e7ed945026b2a184e1}{
\index{LSQUnit@{LSQUnit}!cachePorts@{cachePorts}}
\index{cachePorts@{cachePorts}!LSQUnit@{LSQUnit}}
\subsubsection[{cachePorts}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf cachePorts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_ab2e23636971c40e7ed945026b2a184e1}
\begin{Desc}
\item[\hyperlink{todo__todo000038}{TODO}]Consider moving to a more advanced model with write vs read ports \end{Desc}
The number of cache ports available each cycle. \hypertarget{classLSQUnit_a602a9ccaf8b313e8923d8b07ec5bc439}{
\index{LSQUnit@{LSQUnit}!checkLoads@{checkLoads}}
\index{checkLoads@{checkLoads}!LSQUnit@{LSQUnit}}
\subsubsection[{checkLoads}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf checkLoads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a602a9ccaf8b313e8923d8b07ec5bc439}
Should loads be checked for dependency issues \hypertarget{classLSQUnit_a1379cf882a12ac6fc9eba5da7c84b18b}{
\index{LSQUnit@{LSQUnit}!cpu@{cpu}}
\index{cpu@{cpu}!LSQUnit@{LSQUnit}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf O3CPU}$\ast$ {\bf cpu}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a1379cf882a12ac6fc9eba5da7c84b18b}
Pointer to the CPU. \hypertarget{classLSQUnit_a2bbddd281625b8b4d716708925673445}{
\index{LSQUnit@{LSQUnit}!dcachePort@{dcachePort}}
\index{dcachePort@{dcachePort}!LSQUnit@{LSQUnit}}
\subsubsection[{dcachePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterPort}$\ast$ {\bf dcachePort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a2bbddd281625b8b4d716708925673445}
Pointer to the dcache port. Used only for sending. \hypertarget{classLSQUnit_ab5dfaaa13f279adbed7a1eafea047796}{
\index{LSQUnit@{LSQUnit}!depCheckShift@{depCheckShift}}
\index{depCheckShift@{depCheckShift}!LSQUnit@{LSQUnit}}
\subsubsection[{depCheckShift}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf depCheckShift}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_ab5dfaaa13f279adbed7a1eafea047796}
The number of places to shift addresses in the \hyperlink{classLSQ}{LSQ} before checking for dependency violations \hypertarget{classLSQUnit_af6f43373b6586aa8c486538fb076effb}{
\index{LSQUnit@{LSQUnit}!fromIssue@{fromIssue}}
\index{fromIssue@{fromIssue}!LSQUnit@{LSQUnit}}
\subsubsection[{fromIssue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf IssueStruct}$>$::wire {\bf fromIssue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_af6f43373b6586aa8c486538fb076effb}
\hyperlink{classWire}{Wire} to read information from the issue stage time queue. \hypertarget{classLSQUnit_ae4914b6850f06ca3589fe9e75451fc2e}{
\index{LSQUnit@{LSQUnit}!hasPendingPkt@{hasPendingPkt}}
\index{hasPendingPkt@{hasPendingPkt}!LSQUnit@{LSQUnit}}
\subsubsection[{hasPendingPkt}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf hasPendingPkt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_ae4914b6850f06ca3589fe9e75451fc2e}
Whether or not there is a packet that couldn't be sent because of a lack of cache ports. \hypertarget{classLSQUnit_a4e9ef25d8913b270d432be4bbfe4965c}{
\index{LSQUnit@{LSQUnit}!iewStage@{iewStage}}
\index{iewStage@{iewStage}!LSQUnit@{LSQUnit}}
\subsubsection[{iewStage}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IEW}$\ast$ {\bf iewStage}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a4e9ef25d8913b270d432be4bbfe4965c}
Pointer to the IEW stage. \hypertarget{classLSQUnit_ab1c6fb6e4b6c6a243412e594629105ea}{
\index{LSQUnit@{LSQUnit}!invAddrLoads@{invAddrLoads}}
\index{invAddrLoads@{invAddrLoads}!LSQUnit@{LSQUnit}}
\subsubsection[{invAddrLoads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf invAddrLoads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_ab1c6fb6e4b6c6a243412e594629105ea}
Total number of loads ignored due to invalid addresses. \hypertarget{classLSQUnit_a893e9b5b65df5710d85f6a583504a11c}{
\index{LSQUnit@{LSQUnit}!invAddrSwpfs@{invAddrSwpfs}}
\index{invAddrSwpfs@{invAddrSwpfs}!LSQUnit@{LSQUnit}}
\subsubsection[{invAddrSwpfs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf invAddrSwpfs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a893e9b5b65df5710d85f6a583504a11c}
Total number of software prefetches ignored due to invalid addresses. \hypertarget{classLSQUnit_a95dc31b4ce3ebcb6b9d75a510b3a128c}{
\index{LSQUnit@{LSQUnit}!isLoadBlocked@{isLoadBlocked}}
\index{isLoadBlocked@{isLoadBlocked}!LSQUnit@{LSQUnit}}
\subsubsection[{isLoadBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf isLoadBlocked}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a95dc31b4ce3ebcb6b9d75a510b3a128c}
Whether or not a load is blocked due to the memory system. \hypertarget{classLSQUnit_a89d931c74b63e0b0e7ad856fe9525ff6}{
\index{LSQUnit@{LSQUnit}!isStoreBlocked@{isStoreBlocked}}
\index{isStoreBlocked@{isStoreBlocked}!LSQUnit@{LSQUnit}}
\subsubsection[{isStoreBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf isStoreBlocked}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a89d931c74b63e0b0e7ad856fe9525ff6}
Whehter or not a store is blocked due to the memory system. \hypertarget{classLSQUnit_a2c1620029c162c7180e523b089e56ed5}{
\index{LSQUnit@{LSQUnit}!loadBlockedHandled@{loadBlockedHandled}}
\index{loadBlockedHandled@{loadBlockedHandled}!LSQUnit@{LSQUnit}}
\subsubsection[{loadBlockedHandled}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf loadBlockedHandled}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a2c1620029c162c7180e523b089e56ed5}
Has the blocked load been handled. \hypertarget{classLSQUnit_ac09af89928d2ef4da4cbdcfce26fa3f5}{
\index{LSQUnit@{LSQUnit}!loadHead@{loadHead}}
\index{loadHead@{loadHead}!LSQUnit@{LSQUnit}}
\subsubsection[{loadHead}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf loadHead}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_ac09af89928d2ef4da4cbdcfce26fa3f5}
The index of the head instruction in the LQ. \hypertarget{classLSQUnit_aa5f3703c5d7c5ce21a497352b94c7465}{
\index{LSQUnit@{LSQUnit}!loadQueue@{loadQueue}}
\index{loadQueue@{loadQueue}!LSQUnit@{LSQUnit}}
\subsubsection[{loadQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf DynInstPtr}$>$ {\bf loadQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_aa5f3703c5d7c5ce21a497352b94c7465}
The load queue. \hypertarget{classLSQUnit_a867971f18e464abd16193e069c64a8ad}{
\index{LSQUnit@{LSQUnit}!loads@{loads}}
\index{loads@{loads}!LSQUnit@{LSQUnit}}
\subsubsection[{loads}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf loads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a867971f18e464abd16193e069c64a8ad}
The number of load instructions in the LQ. \hypertarget{classLSQUnit_a973a489225da164cc85e690f13c86841}{
\index{LSQUnit@{LSQUnit}!loadTail@{loadTail}}
\index{loadTail@{loadTail}!LSQUnit@{LSQUnit}}
\subsubsection[{loadTail}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf loadTail}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a973a489225da164cc85e690f13c86841}
The index of the tail instruction in the LQ. \hypertarget{classLSQUnit_aafa99d800d574095881acbacdbbbcc47}{
\index{LSQUnit@{LSQUnit}!LQEntries@{LQEntries}}
\index{LQEntries@{LQEntries}!LSQUnit@{LSQUnit}}
\subsubsection[{LQEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf LQEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_aafa99d800d574095881acbacdbbbcc47}
The number of LQ entries, plus a sentinel entry (circular queue). \begin{Desc}
\item[\hyperlink{todo__todo000036}{TODO}]: Consider having var that records the true number of LQ entries. \end{Desc}
\hypertarget{classLSQUnit_ac0894e8141823f8eea2c9041bac9dab4}{
\index{LSQUnit@{LSQUnit}!lsq@{lsq}}
\index{lsq@{lsq}!LSQUnit@{LSQUnit}}
\subsubsection[{lsq}]{\setlength{\rightskip}{0pt plus 5cm}{\bf LSQ}$\ast$ {\bf lsq}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_ac0894e8141823f8eea2c9041bac9dab4}
Pointer to the \hyperlink{classLSQ}{LSQ}. \hypertarget{classLSQUnit_a5323f1c2b6bf5cccc59253596656eb70}{
\index{LSQUnit@{LSQUnit}!lsqBlockedLoads@{lsqBlockedLoads}}
\index{lsqBlockedLoads@{lsqBlockedLoads}!LSQUnit@{LSQUnit}}
\subsubsection[{lsqBlockedLoads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf lsqBlockedLoads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a5323f1c2b6bf5cccc59253596656eb70}
Ready loads blocked due to partial store-\/forwarding. \hypertarget{classLSQUnit_a33a1cca2455a3e5909f462a778902643}{
\index{LSQUnit@{LSQUnit}!lsqCacheBlocked@{lsqCacheBlocked}}
\index{lsqCacheBlocked@{lsqCacheBlocked}!LSQUnit@{LSQUnit}}
\subsubsection[{lsqCacheBlocked}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf lsqCacheBlocked}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a33a1cca2455a3e5909f462a778902643}
Number of times the \hyperlink{classLSQ}{LSQ} is blocked due to the cache. \hypertarget{classLSQUnit_a2adecfd8b85711a16f91e0fbd7ca8f10}{
\index{LSQUnit@{LSQUnit}!lsqForwLoads@{lsqForwLoads}}
\index{lsqForwLoads@{lsqForwLoads}!LSQUnit@{LSQUnit}}
\subsubsection[{lsqForwLoads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf lsqForwLoads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a2adecfd8b85711a16f91e0fbd7ca8f10}
Total number of loads forwaded from \hyperlink{classLSQ}{LSQ} stores. \hypertarget{classLSQUnit_a0ee490ba978f48fbf2579acc7eb60b24}{
\index{LSQUnit@{LSQUnit}!lsqID@{lsqID}}
\index{lsqID@{lsqID}!LSQUnit@{LSQUnit}}
\subsubsection[{lsqID}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} {\bf lsqID}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a0ee490ba978f48fbf2579acc7eb60b24}
The \hyperlink{classLSQUnit}{LSQUnit} thread id. \hypertarget{classLSQUnit_ad620ac240b0d631c3a8aa19cfd05ad41}{
\index{LSQUnit@{LSQUnit}!lsqIgnoredResponses@{lsqIgnoredResponses}}
\index{lsqIgnoredResponses@{lsqIgnoredResponses}!LSQUnit@{LSQUnit}}
\subsubsection[{lsqIgnoredResponses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf lsqIgnoredResponses}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_ad620ac240b0d631c3a8aa19cfd05ad41}
Total number of responses from the memory system that are ignored due to the instruction already being squashed. \hypertarget{classLSQUnit_ac499fc2b461e03a110deae7c695f75bc}{
\index{LSQUnit@{LSQUnit}!lsqMemOrderViolation@{lsqMemOrderViolation}}
\index{lsqMemOrderViolation@{lsqMemOrderViolation}!LSQUnit@{LSQUnit}}
\subsubsection[{lsqMemOrderViolation}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf lsqMemOrderViolation}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_ac499fc2b461e03a110deae7c695f75bc}
Tota number of memory ordering violations. \hypertarget{classLSQUnit_af5c24658bed91065bf7d69d27ba9fbd6}{
\index{LSQUnit@{LSQUnit}!lsqRescheduledLoads@{lsqRescheduledLoads}}
\index{lsqRescheduledLoads@{lsqRescheduledLoads}!LSQUnit@{LSQUnit}}
\subsubsection[{lsqRescheduledLoads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf lsqRescheduledLoads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_af5c24658bed91065bf7d69d27ba9fbd6}
Number of loads that were rescheduled. \hypertarget{classLSQUnit_a737697c5df3fbe8e728541fec8220089}{
\index{LSQUnit@{LSQUnit}!lsqSquashedLoads@{lsqSquashedLoads}}
\index{lsqSquashedLoads@{lsqSquashedLoads}!LSQUnit@{LSQUnit}}
\subsubsection[{lsqSquashedLoads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf lsqSquashedLoads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a737697c5df3fbe8e728541fec8220089}
Total number of squashed loads. \hypertarget{classLSQUnit_a0abe80f8caefb71a0351c3bed4d99c0e}{
\index{LSQUnit@{LSQUnit}!lsqSquashedStores@{lsqSquashedStores}}
\index{lsqSquashedStores@{lsqSquashedStores}!LSQUnit@{LSQUnit}}
\subsubsection[{lsqSquashedStores}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf lsqSquashedStores}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a0abe80f8caefb71a0351c3bed4d99c0e}
Total number of squashed stores. \hypertarget{classLSQUnit_a270a20c3fa52139e0538288275db9d22}{
\index{LSQUnit@{LSQUnit}!memDepViolator@{memDepViolator}}
\index{memDepViolator@{memDepViolator}!LSQUnit@{LSQUnit}}
\subsubsection[{memDepViolator}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf memDepViolator}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a270a20c3fa52139e0538288275db9d22}
The oldest load that caused a memory ordering violation. \hypertarget{classLSQUnit_abef3db582145f640478056f8413a03e3}{
\index{LSQUnit@{LSQUnit}!needsTSO@{needsTSO}}
\index{needsTSO@{needsTSO}!LSQUnit@{LSQUnit}}
\subsubsection[{needsTSO}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf needsTSO}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_abef3db582145f640478056f8413a03e3}
Flag for memory model. \hypertarget{classLSQUnit_a54d6e1b7bac876ca215b09777bae1d34}{
\index{LSQUnit@{LSQUnit}!pendingPkt@{pendingPkt}}
\index{pendingPkt@{pendingPkt}!LSQUnit@{LSQUnit}}
\subsubsection[{pendingPkt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketPtr} {\bf pendingPkt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a54d6e1b7bac876ca215b09777bae1d34}
The packet that is pending free cache ports. \hypertarget{classLSQUnit_a314ae93c04b3ca96e79e1b1f39a8e478}{
\index{LSQUnit@{LSQUnit}!retryPkt@{retryPkt}}
\index{retryPkt@{retryPkt}!LSQUnit@{LSQUnit}}
\subsubsection[{retryPkt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketPtr} {\bf retryPkt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a314ae93c04b3ca96e79e1b1f39a8e478}
The packet that needs to be retried. \hypertarget{classLSQUnit_a38c8af5392da70119dc5cce4e3637cbc}{
\index{LSQUnit@{LSQUnit}!SQEntries@{SQEntries}}
\index{SQEntries@{SQEntries}!LSQUnit@{LSQUnit}}
\subsubsection[{SQEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf SQEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a38c8af5392da70119dc5cce4e3637cbc}
The number of SQ entries, plus a sentinel entry (circular queue). \begin{Desc}
\item[\hyperlink{todo__todo000037}{TODO}]: Consider having var that records the true number of SQ entries. \end{Desc}
\hypertarget{classLSQUnit_a6f8bff553ad30865c7d0c62e05421eb8}{
\index{LSQUnit@{LSQUnit}!stalled@{stalled}}
\index{stalled@{stalled}!LSQUnit@{LSQUnit}}
\subsubsection[{stalled}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf stalled}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a6f8bff553ad30865c7d0c62e05421eb8}
Whether or not the \hyperlink{classLSQ}{LSQ} is stalled. \hypertarget{classLSQUnit_af55bc9000c8b4e4cfcfbd018feca12a7}{
\index{LSQUnit@{LSQUnit}!stallingLoadIdx@{stallingLoadIdx}}
\index{stallingLoadIdx@{stallingLoadIdx}!LSQUnit@{LSQUnit}}
\subsubsection[{stallingLoadIdx}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf stallingLoadIdx}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_af55bc9000c8b4e4cfcfbd018feca12a7}
The index of the above store. \hypertarget{classLSQUnit_afe1cdcfca6b44c28581d862228adc3da}{
\index{LSQUnit@{LSQUnit}!stallingStoreIsn@{stallingStoreIsn}}
\index{stallingStoreIsn@{stallingStoreIsn}!LSQUnit@{LSQUnit}}
\subsubsection[{stallingStoreIsn}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf stallingStoreIsn}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_afe1cdcfca6b44c28581d862228adc3da}
The store that causes the stall due to partial store to load forwarding. \hypertarget{classLSQUnit_a6e87b6f77102183080ea6ab8599b26a9}{
\index{LSQUnit@{LSQUnit}!storeHead@{storeHead}}
\index{storeHead@{storeHead}!LSQUnit@{LSQUnit}}
\subsubsection[{storeHead}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf storeHead}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a6e87b6f77102183080ea6ab8599b26a9}
The index of the head instruction in the SQ. \hypertarget{classLSQUnit_aec79dbfe7cf50cf3d047cad7ee8fa157}{
\index{LSQUnit@{LSQUnit}!storeInFlight@{storeInFlight}}
\index{storeInFlight@{storeInFlight}!LSQUnit@{LSQUnit}}
\subsubsection[{storeInFlight}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf storeInFlight}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_aec79dbfe7cf50cf3d047cad7ee8fa157}
Whether or not a store is in flight. \hypertarget{classLSQUnit_a1d370cdc36d253e0f786d46c6af77a40}{
\index{LSQUnit@{LSQUnit}!storeQueue@{storeQueue}}
\index{storeQueue@{storeQueue}!LSQUnit@{LSQUnit}}
\subsubsection[{storeQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf SQEntry}$>$ {\bf storeQueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a1d370cdc36d253e0f786d46c6af77a40}
The store queue. \hypertarget{classLSQUnit_ade9e895aa9c5ace27779c985c4f43326}{
\index{LSQUnit@{LSQUnit}!stores@{stores}}
\index{stores@{stores}!LSQUnit@{LSQUnit}}
\subsubsection[{stores}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf stores}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_ade9e895aa9c5ace27779c985c4f43326}
The number of store instructions in the SQ. \hypertarget{classLSQUnit_a3831a7965ffbe90df177026988476f9c}{
\index{LSQUnit@{LSQUnit}!storesToWB@{storesToWB}}
\index{storesToWB@{storesToWB}!LSQUnit@{LSQUnit}}
\subsubsection[{storesToWB}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf storesToWB}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a3831a7965ffbe90df177026988476f9c}
The number of store instructions in the SQ waiting to writeback. \hypertarget{classLSQUnit_acd5c7fbb5578b5cb505ffff16bbf6a8b}{
\index{LSQUnit@{LSQUnit}!storeTail@{storeTail}}
\index{storeTail@{storeTail}!LSQUnit@{LSQUnit}}
\subsubsection[{storeTail}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf storeTail}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_acd5c7fbb5578b5cb505ffff16bbf6a8b}
The index of the tail instruction in the SQ. \hypertarget{classLSQUnit_a9023e0813d4f3e566d17fb6334a2da02}{
\index{LSQUnit@{LSQUnit}!storeWBIdx@{storeWBIdx}}
\index{storeWBIdx@{storeWBIdx}!LSQUnit@{LSQUnit}}
\subsubsection[{storeWBIdx}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf storeWBIdx}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a9023e0813d4f3e566d17fb6334a2da02}
The index of the first instruction that may be ready to be written back, and has not yet been written back. \hypertarget{classLSQUnit_a03435d626b7567ed154de5d7d8c3d419}{
\index{LSQUnit@{LSQUnit}!usedPorts@{usedPorts}}
\index{usedPorts@{usedPorts}!LSQUnit@{LSQUnit}}
\subsubsection[{usedPorts}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf usedPorts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLSQUnit_a03435d626b7567ed154de5d7d8c3d419}
The number of used cache ports in this cycle. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/o3/\hyperlink{o3_2lsq__unit_8hh}{lsq\_\-unit.hh}\item 
cpu/o3/\hyperlink{o3_2lsq__unit__impl_8hh}{lsq\_\-unit\_\-impl.hh}\end{DoxyCompactItemize}
