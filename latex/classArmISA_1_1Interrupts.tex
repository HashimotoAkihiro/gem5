\hypertarget{classArmISA_1_1Interrupts}{
\section{クラス Interrupts}
\label{classArmISA_1_1Interrupts}\index{ArmISA::Interrupts@{ArmISA::Interrupts}}
}


{\ttfamily \#include $<$interrupts.hh$>$}Interruptsに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classArmISA_1_1Interrupts}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classArmISA_1_1Interrupts_a97c4397dfb2beed097fea7fe60ef17d8}{InterruptMask} \{ \hyperlink{classArmISA_1_1Interrupts_a97c4397dfb2beed097fea7fe60ef17d8a9684cb72d9e92c47ef9b68789b11e9bc}{INT\_\-MASK\_\-M}, 
\hyperlink{classArmISA_1_1Interrupts_a97c4397dfb2beed097fea7fe60ef17d8a77a18b2a95141b2ca0f2af97528e8d56}{INT\_\-MASK\_\-T}, 
\hyperlink{classArmISA_1_1Interrupts_a97c4397dfb2beed097fea7fe60ef17d8a82af2120869ac7674b48b9439b924bf8}{INT\_\-MASK\_\-P}
 \}
\item 
typedef ArmInterruptsParams \hyperlink{classArmISA_1_1Interrupts_a747dfcc35968d9e2b82998fae6408d6a}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classArmISA_1_1Interrupts_a2ab8c6aed9969bc58d6aa2427d442cc4}{setCPU} (\hyperlink{classBaseCPU}{BaseCPU} $\ast$\_\-cpu)
\item 
const \hyperlink{classArmISA_1_1Interrupts_a747dfcc35968d9e2b82998fae6408d6a}{Params} $\ast$ \hyperlink{classArmISA_1_1Interrupts_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{classArmISA_1_1Interrupts_a3d148759405b99148e0c34750966edb1}{Interrupts} (\hyperlink{classArmISA_1_1Interrupts_a747dfcc35968d9e2b82998fae6408d6a}{Params} $\ast$p)
\item 
void \hyperlink{classArmISA_1_1Interrupts_a24c6c4fbdc0605bcd015ce06f194e4b4}{post} (int int\_\-num, int index)
\item 
void \hyperlink{classArmISA_1_1Interrupts_af60c3484087379d0330467d77f6cbaae}{clear} (int int\_\-num, int index)
\item 
void \hyperlink{classArmISA_1_1Interrupts_a798729dca95209ecdc609807a653a2bf}{clearAll} ()
\item 
bool \hyperlink{classArmISA_1_1Interrupts_a50dda1dd4fbbbf90b50f55cc0a712264}{takeInt} (\hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{namespaceArmISA_a5aff829af55e65b802d83dfcef4e9dd0}{tc}, \hyperlink{namespaceArmISA_acdad6d81b9a94402ce3979d531ae4f40}{InterruptTypes} int\_\-type) const 
\item 
bool \hyperlink{classArmISA_1_1Interrupts_af3c66fb49fec598cf78aaec29d764952}{checkInterrupts} (\hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{namespaceArmISA_a5aff829af55e65b802d83dfcef4e9dd0}{tc}) const 
\item 
bool \hyperlink{classArmISA_1_1Interrupts_a0b7f3ea5e340cd06e8dc803865a6083a}{checkWfiWake} (HCR hcr, CPSR \hyperlink{namespaceArmISA_ad377bf9b9c48f8cf3e8e918e0847b1fe}{cpsr}, SCR \hyperlink{namespaceArmISA_ace0bf26677706ecff809bd4c76d33c8c}{scr}) const 
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classArmISA_1_1Interrupts_a4c1c835071d8dcd4b0006a8665d11dde}{getISR} (HCR hcr, CPSR \hyperlink{namespaceArmISA_ad377bf9b9c48f8cf3e8e918e0847b1fe}{cpsr}, SCR \hyperlink{namespaceArmISA_ace0bf26677706ecff809bd4c76d33c8c}{scr})
\item 
bool \hyperlink{classArmISA_1_1Interrupts_a4240797ee6bfe09270680eccc63bbb9d}{checkRaw} (\hyperlink{namespaceArmISA_acdad6d81b9a94402ce3979d531ae4f40}{InterruptTypes} interrupt) const 
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classArmISA_1_1Interrupts_ae603c88d759977611d3bcc6e2deb61ae}{getInterrupt} (\hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{namespaceArmISA_a5aff829af55e65b802d83dfcef4e9dd0}{tc})
\item 
void \hyperlink{classArmISA_1_1Interrupts_a00892e9b06edcba6c3c27454d6235100}{updateIntrInfo} (\hyperlink{classThreadContext}{ThreadContext} $\ast$\hyperlink{namespaceArmISA_a5aff829af55e65b802d83dfcef4e9dd0}{tc})
\item 
void \hyperlink{classArmISA_1_1Interrupts_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
void \hyperlink{classArmISA_1_1Interrupts_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classBaseCPU}{BaseCPU} $\ast$ \hyperlink{classArmISA_1_1Interrupts_a7a31ca9fefb2fe821f29a270678912db}{cpu}
\item 
bool \hyperlink{classArmISA_1_1Interrupts_a1a97fbd95b3d09130494277ce6dcca67}{interrupts} \mbox{[}NumInterruptTypes\mbox{]}
\item 
uint64\_\-t \hyperlink{classArmISA_1_1Interrupts_a7bd80958fef7b80f720d1e764c63adb4}{intStatus}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classArmISA_1_1Interrupts_a747dfcc35968d9e2b82998fae6408d6a}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!Params@{Params}}
\index{Params@{Params}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef ArmInterruptsParams {\bf Params}}}
\label{classArmISA_1_1Interrupts_a747dfcc35968d9e2b82998fae6408d6a}


\subsection{列挙型}
\hypertarget{classArmISA_1_1Interrupts_a97c4397dfb2beed097fea7fe60ef17d8}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!InterruptMask@{InterruptMask}}
\index{InterruptMask@{InterruptMask}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{InterruptMask}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf InterruptMask}}}
\label{classArmISA_1_1Interrupts_a97c4397dfb2beed097fea7fe60ef17d8}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{INT\_\-MASK\_\-M@{INT\_\-MASK\_\-M}!ArmISA::Interrupts@{ArmISA::Interrupts}}\index{ArmISA::Interrupts@{ArmISA::Interrupts}!INT\_\-MASK\_\-M@{INT\_\-MASK\_\-M}}\item[{\em 
\hypertarget{classArmISA_1_1Interrupts_a97c4397dfb2beed097fea7fe60ef17d8a9684cb72d9e92c47ef9b68789b11e9bc}{
INT\_\-MASK\_\-M}
\label{classArmISA_1_1Interrupts_a97c4397dfb2beed097fea7fe60ef17d8a9684cb72d9e92c47ef9b68789b11e9bc}
}]\index{INT\_\-MASK\_\-T@{INT\_\-MASK\_\-T}!ArmISA::Interrupts@{ArmISA::Interrupts}}\index{ArmISA::Interrupts@{ArmISA::Interrupts}!INT\_\-MASK\_\-T@{INT\_\-MASK\_\-T}}\item[{\em 
\hypertarget{classArmISA_1_1Interrupts_a97c4397dfb2beed097fea7fe60ef17d8a77a18b2a95141b2ca0f2af97528e8d56}{
INT\_\-MASK\_\-T}
\label{classArmISA_1_1Interrupts_a97c4397dfb2beed097fea7fe60ef17d8a77a18b2a95141b2ca0f2af97528e8d56}
}]\index{INT\_\-MASK\_\-P@{INT\_\-MASK\_\-P}!ArmISA::Interrupts@{ArmISA::Interrupts}}\index{ArmISA::Interrupts@{ArmISA::Interrupts}!INT\_\-MASK\_\-P@{INT\_\-MASK\_\-P}}\item[{\em 
\hypertarget{classArmISA_1_1Interrupts_a97c4397dfb2beed097fea7fe60ef17d8a82af2120869ac7674b48b9439b924bf8}{
INT\_\-MASK\_\-P}
\label{classArmISA_1_1Interrupts_a97c4397dfb2beed097fea7fe60ef17d8a82af2120869ac7674b48b9439b924bf8}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
127                        {
128         INT_MASK_M, // masked (subject to PSTATE.{A,I,F} mask bit
129         INT_MASK_T, // taken regardless of mask
130         INT_MASK_P  // pending
131     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classArmISA_1_1Interrupts_a3d148759405b99148e0c34750966edb1}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!Interrupts@{Interrupts}}
\index{Interrupts@{Interrupts}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{Interrupts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Interrupts} ({\bf Params} $\ast$ {\em p})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1Interrupts_a3d148759405b99148e0c34750966edb1}



\begin{DoxyCode}
83                            : SimObject(p), cpu(NULL)
84     {
85         clearAll();
86     }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classArmISA_1_1Interrupts_af3c66fb49fec598cf78aaec29d764952}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!checkInterrupts@{checkInterrupts}}
\index{checkInterrupts@{checkInterrupts}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{checkInterrupts}]{\setlength{\rightskip}{0pt plus 5cm}bool checkInterrupts ({\bf ThreadContext} $\ast$ {\em tc}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1Interrupts_af3c66fb49fec598cf78aaec29d764952}



\begin{DoxyCode}
137     {
138         HCR  hcr  = tc->readMiscReg(MISCREG_HCR);
139 
140         if (!(intStatus || hcr.va || hcr.vi || hcr.vf))
141             return false;
142 
143         CPSR cpsr = tc->readMiscReg(MISCREG_CPSR);
144         SCR  scr  = tc->readMiscReg(MISCREG_SCR);
145 
146         bool isHypMode   = cpsr.mode == MODE_HYP;
147         bool isSecure    = inSecureState(scr, cpsr);
148         bool allowVIrq   = !cpsr.i && hcr.imo && !isSecure && !isHypMode;
149         bool allowVFiq   = !cpsr.f && hcr.fmo && !isSecure && !isHypMode;
150         bool allowVAbort = !cpsr.a && hcr.amo && !isSecure && !isHypMode;
151 
152         bool take_irq = takeInt(tc, INT_IRQ);
153         bool take_fiq = takeInt(tc, INT_FIQ);
154         bool take_ea =  takeInt(tc, INT_ABT);
155 
156         return ((interrupts[INT_IRQ] && take_irq)                   ||
157                 (interrupts[INT_FIQ] && take_fiq)                   ||
158                 (interrupts[INT_ABT] && take_ea)                    ||
159                 ((interrupts[INT_VIRT_IRQ] || hcr.vi) && allowVIrq) ||
160                 ((interrupts[INT_VIRT_FIQ] || hcr.vf) && allowVFiq) ||
161                 (hcr.va && allowVAbort)                             ||
162                 (interrupts[INT_RST])                               ||
163                 (interrupts[INT_SEV])
164                );
165     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1Interrupts_a4240797ee6bfe09270680eccc63bbb9d}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!checkRaw@{checkRaw}}
\index{checkRaw@{checkRaw}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{checkRaw}]{\setlength{\rightskip}{0pt plus 5cm}bool checkRaw ({\bf InterruptTypes} {\em interrupt}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1Interrupts_a4240797ee6bfe09270680eccc63bbb9d}
\hyperlink{classCheck}{Check} the state of a particular interrupt, ignoring CPSR masks.

This method is primarily used when running the target CPU in a hardware VM (e.g., KVM) to check if interrupts should be delivered upon guest entry.


\begin{DoxyParams}{引数}
\item[{\em interrupt}]\hyperlink{classArmISA_1_1Interrupt}{Interrupt} type to check the state of. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
true if the interrupt is asserted, false otherwise. 
\end{DoxyReturn}



\begin{DoxyCode}
214     {
215         if (interrupt >= NumInterruptTypes)
216             panic("Interrupt number out of range.\n");
217 
218         return interrupts[interrupt];
219     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1Interrupts_a0b7f3ea5e340cd06e8dc803865a6083a}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!checkWfiWake@{checkWfiWake}}
\index{checkWfiWake@{checkWfiWake}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{checkWfiWake}]{\setlength{\rightskip}{0pt plus 5cm}bool checkWfiWake (HCR {\em hcr}, \/  CPSR {\em cpsr}, \/  SCR {\em scr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1Interrupts_a0b7f3ea5e340cd06e8dc803865a6083a}
This function is used to check if a wfi operation should sleep. If there is an interrupt pending, even if it's masked, wfi doesn't sleep. \begin{DoxyReturn}{戻り値}
any interrupts pending 
\end{DoxyReturn}



\begin{DoxyCode}
174     {
175         uint64_t maskedIntStatus;
176         bool     virtWake;
177 
178         maskedIntStatus = intStatus & ~((1 << INT_VIRT_IRQ) |
179                                         (1 << INT_VIRT_FIQ));
180         virtWake  = (hcr.vi || interrupts[INT_VIRT_IRQ]) && hcr.imo;
181         virtWake |= (hcr.vf || interrupts[INT_VIRT_FIQ]) && hcr.fmo;
182         virtWake |=  hcr.va                              && hcr.amo;
183         virtWake &= (cpsr.mode != MODE_HYP) && !inSecureState(scr, cpsr);
184         return maskedIntStatus || virtWake;
185     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1Interrupts_af60c3484087379d0330467d77f6cbaae}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!clear@{clear}}
\index{clear@{clear}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{clear}]{\setlength{\rightskip}{0pt plus 5cm}void clear (int {\em int\_\-num}, \/  int {\em index})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1Interrupts_af60c3484087379d0330467d77f6cbaae}



\begin{DoxyCode}
106     {
107         DPRINTF(Interrupt, "Interrupt %d:%d cleared\n", int_num, index);
108 
109         if (int_num < 0 || int_num >= NumInterruptTypes)
110             panic("int_num out of bounds\n");
111 
112         if (index != 0)
113             panic("No support for other interrupt indexes\n");
114 
115         interrupts[int_num] = false;
116         intStatus &= ~(ULL(1) << int_num);
117     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1Interrupts_a798729dca95209ecdc609807a653a2bf}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!clearAll@{clearAll}}
\index{clearAll@{clearAll}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{clearAll}]{\setlength{\rightskip}{0pt plus 5cm}void clearAll ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1Interrupts_a798729dca95209ecdc609807a653a2bf}



\begin{DoxyCode}
121     {
122         DPRINTF(Interrupt, "Interrupts all cleared\n");
123         intStatus = 0;
124         memset(interrupts, 0, sizeof(interrupts));
125     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1Interrupts_ae603c88d759977611d3bcc6e2deb61ae}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!getInterrupt@{getInterrupt}}
\index{getInterrupt@{getInterrupt}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{getInterrupt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} getInterrupt ({\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1Interrupts_ae603c88d759977611d3bcc6e2deb61ae}



\begin{DoxyCode}
223     {
224         HCR  hcr  = tc->readMiscReg(MISCREG_HCR);
225         CPSR cpsr = tc->readMiscReg(MISCREG_CPSR);
226         SCR  scr  = tc->readMiscReg(MISCREG_SCR);
227 
228         // Calculate a few temp vars so we can work out if there's a pending
229         // virtual interrupt, and if its allowed to happen
230         // ARM ARM Issue C section B1.9.9, B1.9.11, and B1.9.13
231         bool isHypMode   = cpsr.mode == MODE_HYP;
232         bool isSecure    = inSecureState(scr, cpsr);
233         bool allowVIrq   = !cpsr.i && hcr.imo && !isSecure && !isHypMode;
234         bool allowVFiq   = !cpsr.f && hcr.fmo && !isSecure && !isHypMode;
235         bool allowVAbort = !cpsr.a && hcr.amo && !isSecure && !isHypMode;
236 
237         if ( !(intStatus || (hcr.vi && allowVIrq) || (hcr.vf && allowVFiq) ||
238                (hcr.va && allowVAbort)) )
239             return NoFault;
240 
241         bool take_irq = takeInt(tc, INT_IRQ);
242         bool take_fiq = takeInt(tc, INT_FIQ);
243         bool take_ea =  takeInt(tc, INT_ABT);
244 
245 
246         if (interrupts[INT_IRQ] && take_irq)
247             return new Interrupt;
248         if ((interrupts[INT_VIRT_IRQ] || hcr.vi) && allowVIrq)
249             return new VirtualInterrupt;
250         if (interrupts[INT_FIQ] && take_fiq)
251             return new FastInterrupt;
252         if ((interrupts[INT_VIRT_FIQ] || hcr.vf) && allowVFiq)
253             return new VirtualFastInterrupt;
254         if (interrupts[INT_ABT] && take_ea)
255             return new SystemError;
256         if (hcr.va && allowVAbort)
257             return new VirtualDataAbort(0, TlbEntry::DomainType::NoAccess, false,
      
258                                  ArmFault::AsynchronousExternalAbort);
259         if (interrupts[INT_RST])
260             return new Reset;
261         if (interrupts[INT_SEV])
262             return new ArmSev;
263 
264         panic("intStatus and interrupts not in sync\n");
265     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1Interrupts_a4c1c835071d8dcd4b0006a8665d11dde}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!getISR@{getISR}}
\index{getISR@{getISR}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{getISR}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} getISR (HCR {\em hcr}, \/  CPSR {\em cpsr}, \/  SCR {\em scr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1Interrupts_a4c1c835071d8dcd4b0006a8665d11dde}



\begin{DoxyCode}
189     {
190         bool useHcrMux;
191         CPSR isr = 0; // ARM ARM states ISR reg uses same bit possitions as CPSR
192 
193         useHcrMux = (cpsr.mode != MODE_HYP) && !inSecureState(scr, cpsr);
194         isr.i = (useHcrMux & hcr.imo) ? (interrupts[INT_VIRT_IRQ] || hcr.vi)
195                                       :  interrupts[INT_IRQ];
196         isr.f = (useHcrMux & hcr.fmo) ? (interrupts[INT_VIRT_FIQ] || hcr.vf)
197                                       :  interrupts[INT_FIQ];
198         isr.a = (useHcrMux & hcr.amo) ?  hcr.va : interrupts[INT_ABT];
199         return isr;
200     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1Interrupts_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!params@{params}}
\index{params@{params}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1Interrupts_acd3c3feb78ae7a8f88fe0f110a718dff}



\begin{DoxyCode}
79     {
80         return dynamic_cast<const Params *>(_params);
81     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1Interrupts_a24c6c4fbdc0605bcd015ce06f194e4b4}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!post@{post}}
\index{post@{post}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{post}]{\setlength{\rightskip}{0pt plus 5cm}void post (int {\em int\_\-num}, \/  int {\em index})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1Interrupts_a24c6c4fbdc0605bcd015ce06f194e4b4}



\begin{DoxyCode}
91     {
92         DPRINTF(Interrupt, "Interrupt %d:%d posted\n", int_num, index);
93 
94         if (int_num < 0 || int_num >= NumInterruptTypes)
95             panic("int_num out of bounds\n");
96 
97         if (index != 0)
98             panic("No support for other interrupt indexes\n");
99 
100         interrupts[int_num] = true;
101         intStatus |= ULL(1) << int_num;
102     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1Interrupts_a53e036786d17361be4c7320d39c99b84}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!serialize@{serialize}}
\index{serialize@{serialize}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1Interrupts_a53e036786d17361be4c7320d39c99b84}



\begin{DoxyCode}
275     {
276         SERIALIZE_ARRAY(interrupts, NumInterruptTypes);
277         SERIALIZE_SCALAR(intStatus);
278     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1Interrupts_a2ab8c6aed9969bc58d6aa2427d442cc4}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!setCPU@{setCPU}}
\index{setCPU@{setCPU}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{setCPU}]{\setlength{\rightskip}{0pt plus 5cm}void setCPU ({\bf BaseCPU} $\ast$ {\em \_\-cpu})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1Interrupts_a2ab8c6aed9969bc58d6aa2427d442cc4}



\begin{DoxyCode}
71     {
72         cpu = _cpu;
73     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1Interrupts_a50dda1dd4fbbbf90b50f55cc0a712264}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!takeInt@{takeInt}}
\index{takeInt@{takeInt}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{takeInt}]{\setlength{\rightskip}{0pt plus 5cm}bool takeInt ({\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf InterruptTypes} {\em int\_\-type}) const}}
\label{classArmISA_1_1Interrupts_a50dda1dd4fbbbf90b50f55cc0a712264}



\begin{DoxyCode}
51 {
52     // Table G1-17~19 of ARM V8 ARM
53     InterruptMask mask;
54     bool highest_el_is_64 = ArmSystem::highestELIs64(tc);
55 
56     CPSR cpsr = tc->readMiscReg(MISCREG_CPSR);
57     SCR scr;
58     HCR hcr;
59     hcr = tc->readMiscReg(MISCREG_HCR);
60     ExceptionLevel el = (ExceptionLevel) ((uint32_t) cpsr.el);
61     bool cpsr_mask_bit, scr_routing_bit, scr_fwaw_bit, hcr_mask_override_bit;
62 
63     if (!highest_el_is_64)
64         scr = tc->readMiscReg(MISCREG_SCR);
65     else
66         scr = tc->readMiscReg(MISCREG_SCR_EL3);
67 
68     bool is_secure = inSecureState(scr, cpsr);
69 
70     switch(int_type) {
71       case INT_FIQ:
72         cpsr_mask_bit = cpsr.f;
73         scr_routing_bit = scr.fiq;
74         scr_fwaw_bit = scr.fw;
75         hcr_mask_override_bit = hcr.fmo;
76         break;
77       case INT_IRQ:
78         cpsr_mask_bit = cpsr.i;
79         scr_routing_bit = scr.irq;
80         scr_fwaw_bit = 1;
81         hcr_mask_override_bit = hcr.imo;
82         break;
83       case INT_ABT:
84         cpsr_mask_bit = cpsr.a;
85         scr_routing_bit = scr.ea;
86         scr_fwaw_bit = scr.aw;
87         hcr_mask_override_bit = hcr.amo;
88         break;
89       default:
90         panic("Unhandled interrupt type!");
91     }
92 
93     if (hcr.tge)
94         hcr_mask_override_bit = 1;
95 
96     if (!highest_el_is_64) {
97         // AArch32
98         if (!scr_routing_bit) {
99             // SCR IRQ == 0
100             if (!hcr_mask_override_bit)
101                 mask = INT_MASK_M;
102             else {
103                 if (!is_secure && (el == EL0 || el == EL1))
104                     mask = INT_MASK_T;
105                 else
106                     mask = INT_MASK_M;
107             }
108         } else {
109             // SCR IRQ == 1
110             if ((!is_secure) &&
111                 (hcr_mask_override_bit ||
112                     (!scr_fwaw_bit && !hcr_mask_override_bit)))
113                 mask = INT_MASK_T;
114             else
115                 mask = INT_MASK_M;
116         }
117     } else {
118         // AArch64
119         if (!scr_routing_bit) {
120             // SCR IRQ == 0
121             if (!scr.rw) {
122                 // SCR RW == 0
123                 if (!hcr_mask_override_bit) {
124                     if (el == EL3)
125                         mask = INT_MASK_P;
126                     else
127                         mask = INT_MASK_M;
128                 } else {
129                     if (el == EL3)
130                         mask = INT_MASK_T;
131                     else if (is_secure || el == EL2)
132                         mask = INT_MASK_M;
133                     else
134                         mask = INT_MASK_T;
135                 }
136             } else {
137                 // SCR RW == 1
138                 if (!hcr_mask_override_bit) {
139                     if (el == EL3 || el == EL2)
140                         mask = INT_MASK_P;
141                     else
142                         mask = INT_MASK_M;
143                 } else {
144                     if (el == EL3)
145                         mask = INT_MASK_P;
146                     else if (is_secure || el == EL2)
147                         mask = INT_MASK_M;
148                     else
149                         mask = INT_MASK_T;
150                 }
151             }
152         } else {
153             // SCR IRQ == 1
154             if (el == EL3)
155                 mask = INT_MASK_M;
156             else
157                 mask = INT_MASK_T;
158         }
159     }
160 
161     return ((mask == INT_MASK_T) ||
162             ((mask == INT_MASK_M) && !cpsr_mask_bit)) &&
163             (mask != INT_MASK_P);
164 }
\end{DoxyCode}
\hypertarget{classArmISA_1_1Interrupts_af22e5d6d660b97db37003ac61ac4ee49}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1Interrupts_af22e5d6d660b97db37003ac61ac4ee49}



\begin{DoxyCode}
282     {
283         UNSERIALIZE_ARRAY(interrupts, NumInterruptTypes);
284         UNSERIALIZE_SCALAR(intStatus);
285     }
\end{DoxyCode}
\hypertarget{classArmISA_1_1Interrupts_a00892e9b06edcba6c3c27454d6235100}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!updateIntrInfo@{updateIntrInfo}}
\index{updateIntrInfo@{updateIntrInfo}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{updateIntrInfo}]{\setlength{\rightskip}{0pt plus 5cm}void updateIntrInfo ({\bf ThreadContext} $\ast$ {\em tc})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classArmISA_1_1Interrupts_a00892e9b06edcba6c3c27454d6235100}



\begin{DoxyCode}
269     {
270         ; // nothing to do
271     }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classArmISA_1_1Interrupts_a7a31ca9fefb2fe821f29a270678912db}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!cpu@{cpu}}
\index{cpu@{cpu}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseCPU}$\ast$ {\bf cpu}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmISA_1_1Interrupts_a7a31ca9fefb2fe821f29a270678912db}
\hypertarget{classArmISA_1_1Interrupts_a1a97fbd95b3d09130494277ce6dcca67}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!interrupts@{interrupts}}
\index{interrupts@{interrupts}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{interrupts}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf interrupts}\mbox{[}NumInterruptTypes\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmISA_1_1Interrupts_a1a97fbd95b3d09130494277ce6dcca67}
\hypertarget{classArmISA_1_1Interrupts_a7bd80958fef7b80f720d1e764c63adb4}{
\index{ArmISA::Interrupts@{ArmISA::Interrupts}!intStatus@{intStatus}}
\index{intStatus@{intStatus}!ArmISA::Interrupts@{ArmISA::Interrupts}}
\subsubsection[{intStatus}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf intStatus}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classArmISA_1_1Interrupts_a7bd80958fef7b80f720d1e764c63adb4}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/arm/\hyperlink{arm_2interrupts_8hh}{interrupts.hh}\item 
arch/arm/\hyperlink{arm_2interrupts_8cc}{interrupts.cc}\end{DoxyCompactItemize}
