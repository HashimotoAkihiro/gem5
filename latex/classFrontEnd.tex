\hypertarget{classFrontEnd}{
\section{クラス テンプレート FrontEnd$<$ Impl $>$}
\label{classFrontEnd}\index{FrontEnd@{FrontEnd}}
}


{\ttfamily \#include $<$front\_\-end.hh$>$}\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classFrontEnd_1_1IcachePort}{IcachePort}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \{ \par
\hyperlink{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}{Running}, 
\hyperlink{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}{Idle}, 
\hyperlink{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70baa694766f134e9cd81f5ad5b91dedf852}{IcacheWaitResponse}, 
\hyperlink{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba2a36c8d85e537909b8fa14af846e48a3}{IcacheWaitRetry}, 
\par
\hyperlink{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70baff0dbe49b2bc9aee96de6b007b5b826e}{IcacheAccessComplete}, 
\hyperlink{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba806b5780135449a5572df8b7afe9d9d5}{SerializeBlocked}, 
\hyperlink{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba1aad3d3d6093186d4e0fe0db9ba433ea}{SerializeComplete}, 
\hyperlink{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba2828f5cf5f4747c5c75fbe0cfa5c1323}{RenameBlocked}, 
\par
\hyperlink{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba6dd2239b509a3ed085ad3bddda99cb16}{QuiescePending}, 
\hyperlink{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba8c49adf6da5f507150d403610c684877}{TrapPending}, 
\hyperlink{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70bad1b955879ac78b2f484bfc8a8f76ee23}{BEBlocked}
 \}
\item 
typedef Impl::Params \hyperlink{classFrontEnd_a818e103eae798a24a06a0a34631849ea}{Params}
\item 
typedef Impl::DynInst \hyperlink{classFrontEnd_ab741745c86a14c765b999c11167636d9}{DynInst}
\item 
typedef Impl::DynInstPtr \hyperlink{classFrontEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}
\item 
typedef Impl::CPUType \hyperlink{classFrontEnd_ad0cc927c8534eaba1d99c29b2942311f}{CPUType}
\item 
typedef Impl::BackEnd \hyperlink{classFrontEnd_a3de526baa0cbb2b55bf669a6f7bf81cc}{BackEnd}
\item 
typedef Impl::CPUType::OzoneTC \hyperlink{classFrontEnd_a4732af5c8908e169c3e86ef8a5bac05f}{OzoneTC}
\item 
typedef Impl::CPUType::CommStruct \hyperlink{classFrontEnd_ab99b68ad737741b1d3a073f2df88752a}{CommStruct}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classFrontEnd_a207b33a1b071e34c89c0af0c3d4ae9ae}{FrontEnd} (\hyperlink{classFrontEnd_a818e103eae798a24a06a0a34631849ea}{Params} $\ast$params)
\item 
std::string \hyperlink{classFrontEnd_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classFrontEnd_a565fc31c4022b672a5c6b03a3dbcb408}{setCPU} (\hyperlink{classFrontEnd_ad0cc927c8534eaba1d99c29b2942311f}{CPUType} $\ast$cpu\_\-ptr)
\item 
void \hyperlink{classFrontEnd_a5f15ff995704fecfa4b6e5d6147ec622}{setBackEnd} (\hyperlink{classBackEnd}{BackEnd} $\ast$back\_\-end\_\-ptr)
\item 
void \hyperlink{classFrontEnd_aeabdb9f0aae07df67c3029f8fddb2693}{setCommBuffer} (\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classFrontEnd_ab99b68ad737741b1d3a073f2df88752a}{CommStruct} $>$ $\ast$\_\-comm)
\item 
void \hyperlink{classFrontEnd_ac6ccaaea6ac518cab92f71723b5a739e}{setTC} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc\_\-ptr)
\item 
void \hyperlink{classFrontEnd_a2a6551551e11d9e1947d6805e8322757}{setThreadState} (\hyperlink{structOzoneThreadState}{OzoneThreadState}$<$ Impl $>$ $\ast$thread\_\-ptr)
\item 
void \hyperlink{classFrontEnd_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
\hyperlink{classPort}{Port} $\ast$ \hyperlink{classFrontEnd_a530e48c3dbd3fa3fc72df27f49ed09a9}{getIcachePort} ()
\item 
void \hyperlink{classFrontEnd_a873dd91783f9efb4a590aded1f70d6b0}{tick} ()
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classFrontEnd_abc6f8ec144effb7168fdfdfc9661b884}{fetchCacheLine} ()
\item 
void \hyperlink{classFrontEnd_a91359adcd9112672ff9264d6428b4106}{processInst} (\hyperlink{classFrontEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classFrontEnd_a2b2ddbfb364763ee4f0f337c79d436d9}{squash} (const \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \&squash\_\-num, const \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \&next\_\-PC, const bool is\_\-branch=false, const bool branch\_\-taken=false)
\item 
\hyperlink{classFrontEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classFrontEnd_a2032af0310bc2b8b708cac0af3811074}{getInst} ()
\item 
void \hyperlink{classFrontEnd_a3dc029c2e87eb911352b82ff15c86236}{processCacheCompletion} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classFrontEnd_a5562c5f14a79f595934df368f2e86d54}{addFreeRegs} (int num\_\-freed)
\item 
bool \hyperlink{classFrontEnd_af337ffd75e4f019ce15302c60715d84b}{isEmpty} ()
\item 
void \hyperlink{classFrontEnd_a05f299b443f8cc73a93d61572edc0218}{switchOut} ()
\item 
void \hyperlink{classFrontEnd_a039b639c41c289e1cfe6d71c41d9308c}{doSwitchOut} ()
\item 
void \hyperlink{classFrontEnd_a5a901e7ec5b94a55bd61fde88ad0b7f1}{takeOverFrom} (\hyperlink{classThreadContext}{ThreadContext} $\ast$old\_\-tc=NULL)
\item 
bool \hyperlink{classFrontEnd_a471165257f311a78136ce991a3bad31a}{isSwitchedOut} ()
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classFrontEnd_ab9b1142cc382fcfba846b1998e6c2f17}{getFault} ()
\item 
void \hyperlink{classFrontEnd_a9bd96a8460a26f24f520db702f3f6eec}{setPC} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} val)
\item 
void \hyperlink{classFrontEnd_a81b908e5de6420bc0c5a0c5b9b1e38c2}{setNextPC} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} val)
\item 
void \hyperlink{classFrontEnd_a040cbeac7187b0b8cdb1242d3f5aa179}{wakeFromQuiesce} ()
\item 
void \hyperlink{classFrontEnd_a80587b4fe043bbe1995536cb3b361588}{dumpInsts} ()
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classFrontEnd_a1aee6db9bfb75cf02e38a82e5d02847f}{switchedOut}
\item 
\hyperlink{classFrontEnd_ad0cc927c8534eaba1d99c29b2942311f}{CPUType} $\ast$ \hyperlink{classFrontEnd_ab2e5cd9c988b4f91a1b9040f14fbd0f9}{cpu}
\item 
\hyperlink{classBackEnd}{BackEnd} $\ast$ \hyperlink{classFrontEnd_af59b0af2f4e41305c729ac6e36fd7803}{backEnd}
\item 
\hyperlink{classThreadContext}{ThreadContext} $\ast$ \hyperlink{classFrontEnd_a4455a4759e69e5ebe68ae7298cbcc37d}{tc}
\item 
\hyperlink{structOzoneThreadState}{OzoneThreadState}$<$ Impl $>$ $\ast$ \hyperlink{classFrontEnd_ab6f834310107fd693035eba2eeca583f}{thread}
\item 
\hyperlink{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \hyperlink{classFrontEnd_ae29aa2d4ae440022daaed1107eb306b3}{status}
\item 
\hyperlink{classRenameTable}{RenameTable}$<$ Impl $>$ \hyperlink{classFrontEnd_af8d3f859e7c0dd9408ba99de6f415616}{renameTable}
\item 
bool \hyperlink{classFrontEnd_a310de3efc6b60f47de5792d2b00d0840}{interruptPending}
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef Impl::BranchPred \hyperlink{classFrontEnd_a25460b96f0b4cf1681e2c540a7a329eb}{BranchPred}
\item 
typedef \hyperlink{classstd_1_1deque}{std::deque}$<$ \hyperlink{classFrontEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classFrontEnd_aa99c789f993c7211a0d79f7b05cf887b}{InstBuff}
\item 
typedef InstBuff::iterator \hyperlink{classFrontEnd_a44b16657794dcb6775f2ef42b3e37b22}{InstBuffIt}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classFrontEnd_a29cb5a4f98063ce6e9210eacbdb35298}{recvRetry} ()
\item 
bool \hyperlink{classFrontEnd_a9a8ca871f405a4b52efc2a2f9f38a69a}{updateStatus} ()
\item 
void \hyperlink{classFrontEnd_aa4296e63c1facc468b3844b89fdb1b3c}{checkBE} ()
\item 
\hyperlink{classFrontEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classFrontEnd_a11bf7511e73a68b32e7ce600e2ef1bdc}{getInstFromCacheline} ()
\item 
void \hyperlink{classFrontEnd_a837fe0c15d6fe36620f73f1b81558d56}{renameInst} (\hyperlink{classFrontEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
bool \hyperlink{classFrontEnd_a71821f0ab4ae4fb1fa4ce667e2d6d8d9}{processBarriers} (\hyperlink{classFrontEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
void \hyperlink{classFrontEnd_a5ad7aa907418d2f604823ae7b0560036}{handleFault} (\hyperlink{classRefCountingPtr}{Fault} \&fault)
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classFrontEnd_a0a1c6bcaf75b2920f70132b2c9daba24}{icacheBlockAlignPC} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr)
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classFrontEnd_ace86a0dff0fe9648b7221e3a98fb4533}{getAndIncrementInstSeq} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classRefCountingPtr}{Fault} \hyperlink{classFrontEnd_ac2f4c2fc84b40d9abd220e8bd21242c9}{fetchFault}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classFrontEnd_ab99b68ad737741b1d3a073f2df88752a}{CommStruct} $>$ $\ast$ \hyperlink{classFrontEnd_a282f2307a986f183b83e887756561687}{comm}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ \hyperlink{classFrontEnd_ab99b68ad737741b1d3a073f2df88752a}{CommStruct} $>$::wire \hyperlink{classFrontEnd_a77bf6c956edddf1d551d5371ff72162e}{fromCommit}
\item 
\hyperlink{classFrontEnd_a25460b96f0b4cf1681e2c540a7a329eb}{BranchPred} \hyperlink{classFrontEnd_a98d9448d614ac60bbf861bbf3db21fa9}{branchPred}
\item 
\hyperlink{classFrontEnd_1_1IcachePort}{IcachePort} \hyperlink{classFrontEnd_a290723656a84b9cc90dfce377af9aad0}{icachePort}
\item 
\hyperlink{classRequest}{RequestPtr} \hyperlink{classFrontEnd_a5520eb2f7c2cf4b0e109d6ffd6d2d053}{memReq}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classFrontEnd_a33b99af01da30de3072e0fb714c0ca38}{cacheBlkMask}
\item 
unsigned \hyperlink{classFrontEnd_a7c9e97ff2bb74bc86262cd751490b482}{cacheBlkSize}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classFrontEnd_a5eccc8a239dec2935cc4a2c6aa5e3dd1}{cacheBlkPC}
\item 
uint8\_\-t $\ast$ \hyperlink{classFrontEnd_ab850d89c84ed3153a7e35592951cccd7}{cacheData}
\item 
bool \hyperlink{classFrontEnd_a2bc7884cb20b22f02a5454ca8b6205b6}{fetchCacheLineNextCycle}
\item 
bool \hyperlink{classFrontEnd_a80f6b4712235f03884c0447e594dd36c}{cacheBlkValid}
\item 
bool \hyperlink{classFrontEnd_a12a8dc8b9e94659a01ff979d9d98be89}{cacheBlocked}
\item 
\hyperlink{classPacket}{PacketPtr} \hyperlink{classFrontEnd_a314ae93c04b3ca96e79e1b1f39a8e478}{retryPkt}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classFrontEnd_ab4fee9d7e100be71a104b4b714909357}{PC}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classFrontEnd_a3bda64c96331af0ad914c5873b7074b5}{nextPC}
\item 
\hyperlink{classTimeBuffer}{TimeBuffer}$<$ int $>$ \hyperlink{classFrontEnd_a7e748ead7cabc60dbb73666b45a0cb18}{numInstsReady}
\item 
\hyperlink{classstd_1_1deque}{InstBuff} \hyperlink{classFrontEnd_ac7ded4b035e54069bf829087fd67c780}{feBuffer}
\item 
\hyperlink{classstd_1_1deque}{InstBuff} \hyperlink{classFrontEnd_ae82efc68a3059bd20d0dd5d8dbdd9d02}{instBuffer}
\item 
int \hyperlink{classFrontEnd_a4668a18dc57e1f433f756f8586c5ace7}{instBufferSize}
\item 
int \hyperlink{classFrontEnd_af676af949cf4321753cd6839d9d7e879}{maxInstBufferSize}
\item 
int \hyperlink{classFrontEnd_a9c5bf07170b5d91cfb44d4bfd0517128}{latency}
\item 
int \hyperlink{classFrontEnd_a2474a5474cbff19523a51eb1de01cda4}{width}
\item 
int \hyperlink{classFrontEnd_a6c1923b44f74e7cc11aeae29d9c1ec71}{freeRegs}
\item 
int \hyperlink{classFrontEnd_a57ec02581bb51a2421a7d401786beee5}{numPhysRegs}
\item 
bool \hyperlink{classFrontEnd_a7419c9cb2b5771ab5b23687a64c2af95}{serializeNext}
\item 
\hyperlink{classFrontEnd_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classFrontEnd_acf9d2aaec2de3b1c53dc1cce63de9794}{barrierInst}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classFrontEnd_a2b9328bdb1a6898bfae824981cd64311}{icacheStallCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classFrontEnd_af0e3fa228032036d2022ed9e2a3612b6}{fetchedInsts}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classFrontEnd_aaca0646636cde96795aed6beb2942975}{fetchedBranches}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classFrontEnd_ae5c954036e76b5cc5a82cf7f17d4d5ed}{predictedBranches}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classFrontEnd_a9699b5489dd499e832651b96f95b5d19}{fetchCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classFrontEnd_a8af716ad2a53a409640347226078591c}{fetchIdleCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classFrontEnd_ae1b92a3469ac6b00fddd788b71f64c9a}{fetchSquashCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classFrontEnd_a0501ffad4abed98618a6cf0ba9c3599b}{fetchBlockedCycles}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classFrontEnd_a0ead660daa133edcd64ac552d473ebba}{fetchedCacheLines}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classFrontEnd_af5ce6113f31fddaab758b8fb025600bc}{fetchIcacheSquashes}
\item 
\hyperlink{classStats_1_1Distribution}{Stats::Distribution} \hyperlink{classFrontEnd_a4793a4a8857c13e7812b1c37c6df761b}{fetchNisnDist}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classFrontEnd_a4b942e4ec6b8c1d29a1c96e901ea71dd}{idleRate}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classFrontEnd_abceba4006d416e352df47f692b589bc3}{branchRate}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classFrontEnd_a7656c6cac3b62fa389148c650a5d127a}{fetchRate}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classFrontEnd_af5442c563401e6561dbceb43f73edef5}{IFQCount}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classFrontEnd_a0cf052f31902edea9904fb44946d8add}{IFQOccupancy}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classFrontEnd_a4204358ee6bfe3c054b44863d0357534}{IFQLatency}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classFrontEnd_abb5d3a8be34487bf58c34aa0a95c5546}{IFQFcount}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classFrontEnd_a5e1f7150d45f7f01173be5aaec45e5b1}{IFQFullRate}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classFrontEnd_aeaaccfce2b14dfd27899536343487787}{dispatchCountStat}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classFrontEnd_a02e7f15196d5b571aca2e2fc4636a100}{dispatchedSerializing}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classFrontEnd_a7d0500ec7ced57d9f111842c84317fa6}{dispatchedTempSerializing}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classFrontEnd_a0188f971c738223b1be0cac46c0820c0}{dispatchSerializeStallCycles}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classFrontEnd_a39e060f97b4d1e11037234f7e2620e2a}{dispatchRate}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classFrontEnd_a19af07bae8f9b3d63c68d06893b5a70f}{regIntFull}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classFrontEnd_a36fecc5527bb51e9a1c6cc956c167ace}{regFpFull}
\end{DoxyCompactItemize}
\subsubsection*{template$<$class Impl$>$ class FrontEnd$<$ Impl $>$}



\subsection{型定義}
\hypertarget{classFrontEnd_a3de526baa0cbb2b55bf669a6f7bf81cc}{
\index{FrontEnd@{FrontEnd}!BackEnd@{BackEnd}}
\index{BackEnd@{BackEnd}!FrontEnd@{FrontEnd}}
\subsubsection[{BackEnd}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::BackEnd {\bf BackEnd}}}
\label{classFrontEnd_a3de526baa0cbb2b55bf669a6f7bf81cc}
\hypertarget{classFrontEnd_a25460b96f0b4cf1681e2c540a7a329eb}{
\index{FrontEnd@{FrontEnd}!BranchPred@{BranchPred}}
\index{BranchPred@{BranchPred}!FrontEnd@{FrontEnd}}
\subsubsection[{BranchPred}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::BranchPred {\bf BranchPred}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a25460b96f0b4cf1681e2c540a7a329eb}
\hypertarget{classFrontEnd_ab99b68ad737741b1d3a073f2df88752a}{
\index{FrontEnd@{FrontEnd}!CommStruct@{CommStruct}}
\index{CommStruct@{CommStruct}!FrontEnd@{FrontEnd}}
\subsubsection[{CommStruct}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::CPUType::CommStruct {\bf CommStruct}}}
\label{classFrontEnd_ab99b68ad737741b1d3a073f2df88752a}
\hypertarget{classFrontEnd_ad0cc927c8534eaba1d99c29b2942311f}{
\index{FrontEnd@{FrontEnd}!CPUType@{CPUType}}
\index{CPUType@{CPUType}!FrontEnd@{FrontEnd}}
\subsubsection[{CPUType}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::CPUType {\bf CPUType}}}
\label{classFrontEnd_ad0cc927c8534eaba1d99c29b2942311f}
\hypertarget{classFrontEnd_ab741745c86a14c765b999c11167636d9}{
\index{FrontEnd@{FrontEnd}!DynInst@{DynInst}}
\index{DynInst@{DynInst}!FrontEnd@{FrontEnd}}
\subsubsection[{DynInst}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInst {\bf DynInst}}}
\label{classFrontEnd_ab741745c86a14c765b999c11167636d9}
\hypertarget{classFrontEnd_a028ce10889c5f6450239d9e9a7347976}{
\index{FrontEnd@{FrontEnd}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!FrontEnd@{FrontEnd}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInstPtr {\bf DynInstPtr}}}
\label{classFrontEnd_a028ce10889c5f6450239d9e9a7347976}
\hypertarget{classFrontEnd_aa99c789f993c7211a0d79f7b05cf887b}{
\index{FrontEnd@{FrontEnd}!InstBuff@{InstBuff}}
\index{InstBuff@{InstBuff}!FrontEnd@{FrontEnd}}
\subsubsection[{InstBuff}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::deque}$<${\bf DynInstPtr}$>$ {\bf InstBuff}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_aa99c789f993c7211a0d79f7b05cf887b}
\hypertarget{classFrontEnd_a44b16657794dcb6775f2ef42b3e37b22}{
\index{FrontEnd@{FrontEnd}!InstBuffIt@{InstBuffIt}}
\index{InstBuffIt@{InstBuffIt}!FrontEnd@{FrontEnd}}
\subsubsection[{InstBuffIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef InstBuff::iterator {\bf InstBuffIt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a44b16657794dcb6775f2ef42b3e37b22}
\hypertarget{classFrontEnd_a4732af5c8908e169c3e86ef8a5bac05f}{
\index{FrontEnd@{FrontEnd}!OzoneTC@{OzoneTC}}
\index{OzoneTC@{OzoneTC}!FrontEnd@{FrontEnd}}
\subsubsection[{OzoneTC}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::CPUType::OzoneTC {\bf OzoneTC}}}
\label{classFrontEnd_a4732af5c8908e169c3e86ef8a5bac05f}
\hypertarget{classFrontEnd_a818e103eae798a24a06a0a34631849ea}{
\index{FrontEnd@{FrontEnd}!Params@{Params}}
\index{Params@{Params}!FrontEnd@{FrontEnd}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::Params {\bf Params}}}
\label{classFrontEnd_a818e103eae798a24a06a0a34631849ea}


\subsection{列挙型}
\hypertarget{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}{
\index{FrontEnd@{FrontEnd}!Status@{Status}}
\index{Status@{Status}!FrontEnd@{FrontEnd}}
\subsubsection[{Status}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Status}}}
\label{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70b}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Running@{Running}!FrontEnd@{FrontEnd}}\index{FrontEnd@{FrontEnd}!Running@{Running}}\item[{\em 
\hypertarget{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}{
Running}
\label{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}
}]\index{Idle@{Idle}!FrontEnd@{FrontEnd}}\index{FrontEnd@{FrontEnd}!Idle@{Idle}}\item[{\em 
\hypertarget{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}{
Idle}
\label{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}
}]\index{IcacheWaitResponse@{IcacheWaitResponse}!FrontEnd@{FrontEnd}}\index{FrontEnd@{FrontEnd}!IcacheWaitResponse@{IcacheWaitResponse}}\item[{\em 
\hypertarget{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70baa694766f134e9cd81f5ad5b91dedf852}{
IcacheWaitResponse}
\label{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70baa694766f134e9cd81f5ad5b91dedf852}
}]\index{IcacheWaitRetry@{IcacheWaitRetry}!FrontEnd@{FrontEnd}}\index{FrontEnd@{FrontEnd}!IcacheWaitRetry@{IcacheWaitRetry}}\item[{\em 
\hypertarget{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba2a36c8d85e537909b8fa14af846e48a3}{
IcacheWaitRetry}
\label{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba2a36c8d85e537909b8fa14af846e48a3}
}]\index{IcacheAccessComplete@{IcacheAccessComplete}!FrontEnd@{FrontEnd}}\index{FrontEnd@{FrontEnd}!IcacheAccessComplete@{IcacheAccessComplete}}\item[{\em 
\hypertarget{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70baff0dbe49b2bc9aee96de6b007b5b826e}{
IcacheAccessComplete}
\label{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70baff0dbe49b2bc9aee96de6b007b5b826e}
}]\index{SerializeBlocked@{SerializeBlocked}!FrontEnd@{FrontEnd}}\index{FrontEnd@{FrontEnd}!SerializeBlocked@{SerializeBlocked}}\item[{\em 
\hypertarget{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba806b5780135449a5572df8b7afe9d9d5}{
SerializeBlocked}
\label{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba806b5780135449a5572df8b7afe9d9d5}
}]\index{SerializeComplete@{SerializeComplete}!FrontEnd@{FrontEnd}}\index{FrontEnd@{FrontEnd}!SerializeComplete@{SerializeComplete}}\item[{\em 
\hypertarget{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba1aad3d3d6093186d4e0fe0db9ba433ea}{
SerializeComplete}
\label{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba1aad3d3d6093186d4e0fe0db9ba433ea}
}]\index{RenameBlocked@{RenameBlocked}!FrontEnd@{FrontEnd}}\index{FrontEnd@{FrontEnd}!RenameBlocked@{RenameBlocked}}\item[{\em 
\hypertarget{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba2828f5cf5f4747c5c75fbe0cfa5c1323}{
RenameBlocked}
\label{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba2828f5cf5f4747c5c75fbe0cfa5c1323}
}]\index{QuiescePending@{QuiescePending}!FrontEnd@{FrontEnd}}\index{FrontEnd@{FrontEnd}!QuiescePending@{QuiescePending}}\item[{\em 
\hypertarget{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba6dd2239b509a3ed085ad3bddda99cb16}{
QuiescePending}
\label{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba6dd2239b509a3ed085ad3bddda99cb16}
}]\index{TrapPending@{TrapPending}!FrontEnd@{FrontEnd}}\index{FrontEnd@{FrontEnd}!TrapPending@{TrapPending}}\item[{\em 
\hypertarget{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba8c49adf6da5f507150d403610c684877}{
TrapPending}
\label{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70ba8c49adf6da5f507150d403610c684877}
}]\index{BEBlocked@{BEBlocked}!FrontEnd@{FrontEnd}}\index{FrontEnd@{FrontEnd}!BEBlocked@{BEBlocked}}\item[{\em 
\hypertarget{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70bad1b955879ac78b2f484bfc8a8f76ee23}{
BEBlocked}
\label{classFrontEnd_a67a0db04d321a74b7e7fcfd3f1a3f70bad1b955879ac78b2f484bfc8a8f76ee23}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
177                 {
178         Running,
179         Idle,
180         IcacheWaitResponse,
181         IcacheWaitRetry,
182         IcacheAccessComplete,
183         SerializeBlocked,
184         SerializeComplete,
185         RenameBlocked,
186         QuiescePending,
187         TrapPending,
188         BEBlocked
189     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classFrontEnd_a207b33a1b071e34c89c0af0c3d4ae9ae}{
\index{FrontEnd@{FrontEnd}!FrontEnd@{FrontEnd}}
\index{FrontEnd@{FrontEnd}!FrontEnd@{FrontEnd}}
\subsubsection[{FrontEnd}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FrontEnd} ({\bf Params} $\ast$ {\em params})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a207b33a1b071e34c89c0af0c3d4ae9ae}



\begin{DoxyCode}
80     : branchPred(params),
81       icachePort(this),
82       numInstsReady(params->frontEndLatency, 0),
83       instBufferSize(0),
84       maxInstBufferSize(params->maxInstBufferSize),
85       latency(params->frontEndLatency),
86       width(params->frontEndWidth),
87       freeRegs(params->numPhysicalRegs),
88       numPhysRegs(params->numPhysicalRegs),
89       serializeNext(false),
90       interruptPending(false)
91 {
92     switchedOut = false;
93 
94     status = Idle;
95 
96     memReq = NULL;
97     // Size of cache block.
98     cacheBlkSize = 64;
99 
100     assert(isPowerOf2(cacheBlkSize));
101 
102     // Create mask to get rid of offset bits.
103     cacheBlkMask = (cacheBlkSize - 1);
104 
105     // Create space to store a cache line.
106     cacheData = new uint8_t[cacheBlkSize];
107 
108     fetchCacheLineNextCycle = true;
109 
110     cacheBlkValid = cacheBlocked = false;
111 
112     retryPkt = NULL;
113 
114     fetchFault = NoFault;
115 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classFrontEnd_a5562c5f14a79f595934df368f2e86d54}{
\index{FrontEnd@{FrontEnd}!addFreeRegs@{addFreeRegs}}
\index{addFreeRegs@{addFreeRegs}!FrontEnd@{FrontEnd}}
\subsubsection[{addFreeRegs}]{\setlength{\rightskip}{0pt plus 5cm}void addFreeRegs (int {\em num\_\-freed})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a5562c5f14a79f595934df368f2e86d54}



\begin{DoxyCode}
754 {
755     if (status == RenameBlocked && freeRegs + num_freed > 0) {
756         status = Running;
757     }
758 
759     DPRINTF(FE, "Adding %i freed registers\n", num_freed);
760 
761     freeRegs+= num_freed;
762 
763 //    assert(freeRegs <= numPhysRegs);
764     if (freeRegs > numPhysRegs)
765         freeRegs = numPhysRegs;
766 }
\end{DoxyCode}
\hypertarget{classFrontEnd_aa4296e63c1facc468b3844b89fdb1b3c}{
\index{FrontEnd@{FrontEnd}!checkBE@{checkBE}}
\index{checkBE@{checkBE}!FrontEnd@{FrontEnd}}
\subsubsection[{checkBE}]{\setlength{\rightskip}{0pt plus 5cm}void checkBE ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classFrontEnd_aa4296e63c1facc468b3844b89fdb1b3c}



\begin{DoxyCode}
816 {
817     bool be_block = cpu->decoupledFrontEnd ? false : backEnd->isBlocked();
818     if (be_block) {
819         if (status == Running || status == Idle) {
820             status = BEBlocked;
821         }
822     }
823 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a039b639c41c289e1cfe6d71c41d9308c}{
\index{FrontEnd@{FrontEnd}!doSwitchOut@{doSwitchOut}}
\index{doSwitchOut@{doSwitchOut}!FrontEnd@{FrontEnd}}
\subsubsection[{doSwitchOut}]{\setlength{\rightskip}{0pt plus 5cm}void doSwitchOut ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a039b639c41c289e1cfe6d71c41d9308c}



\begin{DoxyCode}
951 {
952     memReq = NULL;
953     squash(0, 0);
954     instBuffer.clear();
955     instBufferSize = 0;
956     feBuffer.clear();
957     status = Idle;
958 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a80587b4fe043bbe1995536cb3b361588}{
\index{FrontEnd@{FrontEnd}!dumpInsts@{dumpInsts}}
\index{dumpInsts@{dumpInsts}!FrontEnd@{FrontEnd}}
\subsubsection[{dumpInsts}]{\setlength{\rightskip}{0pt plus 5cm}void dumpInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a80587b4fe043bbe1995536cb3b361588}



\begin{DoxyCode}
980 {
981     cprintf("instBuffer size: %i\n", instBuffer.size());
982 
983     InstBuffIt buff_it = instBuffer.begin();
984 
985     for (int num = 0; buff_it != instBuffer.end(); num++) {
986         cprintf("Instruction:%i\nPC:%#x\n[tid:%i]\n[sn:%lli]\nIssued:%i\n"
987                 "Squashed:%i\n\n",
988                 num, (*buff_it)->readPC(), (*buff_it)->threadNumber,
989                 (*buff_it)->seqNum, (*buff_it)->isIssued(),
990                 (*buff_it)->isSquashed());
991         buff_it++;
992     }
993 }
\end{DoxyCode}
\hypertarget{classFrontEnd_abc6f8ec144effb7168fdfdfc9661b884}{
\index{FrontEnd@{FrontEnd}!fetchCacheLine@{fetchCacheLine}}
\index{fetchCacheLine@{fetchCacheLine}!FrontEnd@{FrontEnd}}
\subsubsection[{fetchCacheLine}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} fetchCacheLine ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_abc6f8ec144effb7168fdfdfc9661b884}



\begin{DoxyCode}
446 {
447     // Read a cache line, based on the current PC.
448     Fault fault = NoFault;
449 
450     //AlphaDep
451     if (interruptPending && (PC & 0x3)) {
452         return fault;
453     }
454 
455     // Align the fetch PC so it's at the start of a cache block.
456     Addr fetch_PC = icacheBlockAlignPC(PC);
457 
458     DPRINTF(FE, "Fetching cache line starting at %#x.\n", fetch_PC);
459 
460     // Setup the memReq to do a read of the first isntruction's address.
461     // Set the appropriate read size and flags as well.
462     memReq = new Request(0, fetch_PC, cacheBlkSize, 0,
463                          PC, cpu->thread->contextId());
464 
465     // Translate the instruction request.
466     fault = cpu->itb->translateAtomic(memReq, thread, false, true);
467 
468     // Now do the timing access to see whether or not the instruction
469     // exists within the cache.
470     if (fault == NoFault) {
471 #if 0
472         if (cpu->system->memctrl->badaddr(memReq->paddr) ||
473             memReq->isUncacheable()) {
474             DPRINTF(FE, "Fetch: Bad address %#x (hopefully on a "
475                     "misspeculating path!",
476                     memReq->paddr);
477             return TheISA::genMachineCheckFault();
478         }
479 #endif
480 
481         // Build packet here.
482         PacketPtr data_pkt = new Packet(memReq, Packet::ReadReq);
483         data_pkt->dataStatic(cacheData);
484 
485         if (!icachePort.sendTiming(data_pkt)) {
486             assert(retryPkt == NULL);
487             DPRINTF(Fetch, "Out of MSHRs!\n");
488             status = IcacheWaitRetry;
489             retryPkt = data_pkt;
490             cacheBlocked = true;
491             return NoFault;
492         }
493 
494         status = IcacheWaitResponse;
495     }
496 
497     // Note that this will set the cache block PC a bit earlier than it should
498     // be set.
499     cacheBlkPC = fetch_PC;
500 
501     ++fetchedCacheLines;
502 
503     DPRINTF(FE, "Done fetching cache line.\n");
504 
505     return fault;
506 }
\end{DoxyCode}
\hypertarget{classFrontEnd_ace86a0dff0fe9648b7221e3a98fb4533}{
\index{FrontEnd@{FrontEnd}!getAndIncrementInstSeq@{getAndIncrementInstSeq}}
\index{getAndIncrementInstSeq@{getAndIncrementInstSeq}!FrontEnd@{FrontEnd}}
\subsubsection[{getAndIncrementInstSeq}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} getAndIncrementInstSeq ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classFrontEnd_ace86a0dff0fe9648b7221e3a98fb4533}



\begin{DoxyCode}
166     { return cpu->globalSeqNum++; }
\end{DoxyCode}
\hypertarget{classFrontEnd_ab9b1142cc382fcfba846b1998e6c2f17}{
\index{FrontEnd@{FrontEnd}!getFault@{getFault}}
\index{getFault@{getFault}!FrontEnd@{FrontEnd}}
\subsubsection[{getFault}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} getFault ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_ab9b1142cc382fcfba846b1998e6c2f17}



\begin{DoxyCode}
154 { return fetchFault; }
\end{DoxyCode}
\hypertarget{classFrontEnd_a530e48c3dbd3fa3fc72df27f49ed09a9}{
\index{FrontEnd@{FrontEnd}!getIcachePort@{getIcachePort}}
\index{getIcachePort@{getIcachePort}!FrontEnd@{FrontEnd}}
\subsubsection[{getIcachePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Port}$\ast$ getIcachePort ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a530e48c3dbd3fa3fc72df27f49ed09a9}



\begin{DoxyCode}
116 { return &icachePort; }
\end{DoxyCode}
\hypertarget{classFrontEnd_a2032af0310bc2b8b708cac0af3811074}{
\index{FrontEnd@{FrontEnd}!getInst@{getInst}}
\index{getInst@{getInst}!FrontEnd@{FrontEnd}}
\subsubsection[{getInst}]{\setlength{\rightskip}{0pt plus 5cm}Impl::DynInstPtr getInst ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a2032af0310bc2b8b708cac0af3811074}



\begin{DoxyCode}
692 {
693     if (feBuffer.empty()) {
694         return NULL;
695     }
696 
697     DynInstPtr inst = feBuffer.front();
698 
699     if (inst->isSerializeBefore() || inst->isIprAccess()) {
700         DPRINTF(FE, "Back end is getting a serialize before inst\n");
701         if (!backEnd->robEmpty()) {
702             DPRINTF(FE, "Rob is not empty yet, not returning inst\n");
703             return NULL;
704         }
705         inst->clearSerializeBefore();
706     }
707 
708     feBuffer.pop_front();
709 
710     --instBufferSize;
711 
712     dispatchCountStat++;
713 
714     return inst;
715 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a11bf7511e73a68b32e7ce600e2ef1bdc}{
\index{FrontEnd@{FrontEnd}!getInstFromCacheline@{getInstFromCacheline}}
\index{getInstFromCacheline@{getInstFromCacheline}!FrontEnd@{FrontEnd}}
\subsubsection[{getInstFromCacheline}]{\setlength{\rightskip}{0pt plus 5cm}Impl::DynInstPtr getInstFromCacheline ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classFrontEnd_a11bf7511e73a68b32e7ce600e2ef1bdc}



\begin{DoxyCode}
828 {
829 /*
830     if (status == SerializeComplete) {
831         DynInstPtr inst = barrierInst;
832         status = Running;
833         barrierInst = NULL;
834         inst->clearSerializeBefore();
835         return inst;
836     }
837 */
838     InstSeqNum inst_seq;
839     MachInst inst;
840     // @todo: Fix this magic number used here to handle word offset (and
841     // getting rid of PAL bit)
842     unsigned offset = (PC & cacheBlkMask) & ~3;
843 
844     // PC of inst is not in this cache block
845     if (PC >= (cacheBlkPC + cacheBlkSize) || PC < cacheBlkPC || !cacheBlkValid) {
      
846         return NULL;
847     }
848 
850     // Fetch one instruction
852 
853     // Get a sequence number.
854     inst_seq = getAndIncrementInstSeq();
855 
856     // Make sure this is a valid index.
857     assert(offset <= cacheBlkSize - sizeof(MachInst));
858 
859     // Get the instruction from the array of the cache line.
860     inst = htog(*reinterpret_cast<MachInst *>(&cacheData[offset]));
861 
862 #if THE_ISA == ALPHA_ISA
863     ExtMachInst decode_inst = TheISA::makeExtMI(inst, PC);
864 #elif THE_ISA == SPARC_ISA
865     ExtMachInst decode_inst = TheISA::makeExtMI(inst, tc);
866 #endif
867 
868     // Create a new DynInst from the instruction fetched.
869     DynInstPtr instruction = new DynInst(decode_inst, PC, PC+sizeof(MachInst),
870                                          inst_seq, cpu);
871 
872     instruction->setThreadState(thread);
873 
874     DPRINTF(FE, "Instruction [sn:%lli] created, with PC %#x\n%s\n",
875             inst_seq, instruction->readPC(),
876             instruction->staticInst->disassemble(PC));
877 
878     instruction->traceData =
879         Trace::getInstRecord(curTick(), tc,
880                              instruction->staticInst,
881                              instruction->readPC());
882 
883     // Increment stat of fetched instructions.
884     ++fetchedInsts;
885 
886     return instruction;
887 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a5ad7aa907418d2f604823ae7b0560036}{
\index{FrontEnd@{FrontEnd}!handleFault@{handleFault}}
\index{handleFault@{handleFault}!FrontEnd@{FrontEnd}}
\subsubsection[{handleFault}]{\setlength{\rightskip}{0pt plus 5cm}void handleFault ({\bf Fault} \& {\em fault})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classFrontEnd_a5ad7aa907418d2f604823ae7b0560036}



\begin{DoxyCode}
587 {
588     DPRINTF(FE, "Fault at fetch, telling commit\n");
589 
590     // We're blocked on the back end until it handles this fault.
591     status = TrapPending;
592 
593     // Get a sequence number.
594     InstSeqNum inst_seq = getAndIncrementInstSeq();
595     // We will use a nop in order to carry the fault.
596     ExtMachInst ext_inst = TheISA::NoopMachInst;
597 
598     // Create a new DynInst from the dummy nop.
599     DynInstPtr instruction = new DynInst(ext_inst, PC,
600                                          PC+sizeof(MachInst),
601                                          inst_seq, cpu);
602     instruction->setPredTarg(instruction->readNextPC());
603 //    instruction->setThread(tid);
604 
605 //    instruction->setASID(tid);
606 
607     instruction->setThreadState(thread);
608 
609     instruction->traceData = NULL;
610 
611     instruction->fault = fault;
612     instruction->setCanIssue();
613     instBuffer.push_back(instruction);
614     numInstsReady[0]++;
615     ++instBufferSize;
616 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a0a1c6bcaf75b2920f70132b2c9daba24}{
\index{FrontEnd@{FrontEnd}!icacheBlockAlignPC@{icacheBlockAlignPC}}
\index{icacheBlockAlignPC@{icacheBlockAlignPC}!FrontEnd@{FrontEnd}}
\subsubsection[{icacheBlockAlignPC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} icacheBlockAlignPC ({\bf Addr} {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classFrontEnd_a0a1c6bcaf75b2920f70132b2c9daba24}



\begin{DoxyCode}
161     {
162         return (addr & ~(cacheBlkMask));
163     }
\end{DoxyCode}
\hypertarget{classFrontEnd_af337ffd75e4f019ce15302c60715d84b}{
\index{FrontEnd@{FrontEnd}!isEmpty@{isEmpty}}
\index{isEmpty@{isEmpty}!FrontEnd@{FrontEnd}}
\subsubsection[{isEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool isEmpty ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_af337ffd75e4f019ce15302c60715d84b}



\begin{DoxyCode}
129 { return instBuffer.empty(); }
\end{DoxyCode}
\hypertarget{classFrontEnd_a471165257f311a78136ce991a3bad31a}{
\index{FrontEnd@{FrontEnd}!isSwitchedOut@{isSwitchedOut}}
\index{isSwitchedOut@{isSwitchedOut}!FrontEnd@{FrontEnd}}
\subsubsection[{isSwitchedOut}]{\setlength{\rightskip}{0pt plus 5cm}bool isSwitchedOut ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a471165257f311a78136ce991a3bad31a}



\begin{DoxyCode}
137 { return switchedOut; }
\end{DoxyCode}
\hypertarget{classFrontEnd_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{FrontEnd@{FrontEnd}!name@{name}}
\index{name@{name}!FrontEnd@{FrontEnd}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a37627d5d5bba7f4a8690c71c2ab3cb07}



\begin{DoxyCode}
120 {
121     return cpu->name() + ".frontend";
122 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a71821f0ab4ae4fb1fa4ce667e2d6d8d9}{
\index{FrontEnd@{FrontEnd}!processBarriers@{processBarriers}}
\index{processBarriers@{processBarriers}!FrontEnd@{FrontEnd}}
\subsubsection[{processBarriers}]{\setlength{\rightskip}{0pt plus 5cm}bool processBarriers ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classFrontEnd_a71821f0ab4ae4fb1fa4ce667e2d6d8d9}



\begin{DoxyCode}
543 {
544     if (serializeNext) {
545         inst->setSerializeBefore();
546         serializeNext = false;
547     } else if (!inst->isSerializing() &&
548                !inst->isIprAccess() &&
549                !inst->isStoreConditional()) {
550         return false;
551     }
552 
553     if ((inst->isIprAccess() || inst->isSerializeBefore()) &&
554         !inst->isSerializeHandled()) {
555         DPRINTF(FE, "Serialize before instruction encountered.\n");
556 
557         if (!inst->isTempSerializeBefore()) {
558             dispatchedSerializing++;
559             inst->setSerializeHandled();
560         } else {
561             dispatchedTempSerializing++;
562         }
563 
564         // Change status over to SerializeBlocked so that other stages know
565         // what this is blocked on.
566 //        status = SerializeBlocked;
567 
568 //        barrierInst = inst;
569 //        return true;
570     } else if ((inst->isStoreConditional() || inst->isSerializeAfter())
571                && !inst->isSerializeHandled()) {
572         DPRINTF(FE, "Serialize after instruction encountered.\n");
573 
574         inst->setSerializeHandled();
575 
576         dispatchedSerializing++;
577 
578         serializeNext = true;
579         return false;
580     }
581     return false;
582 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a3dc029c2e87eb911352b82ff15c86236}{
\index{FrontEnd@{FrontEnd}!processCacheCompletion@{processCacheCompletion}}
\index{processCacheCompletion@{processCacheCompletion}!FrontEnd@{FrontEnd}}
\subsubsection[{processCacheCompletion}]{\setlength{\rightskip}{0pt plus 5cm}void processCacheCompletion ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a3dc029c2e87eb911352b82ff15c86236}



\begin{DoxyCode}
720 {
721     DPRINTF(FE, "Processing cache completion\n");
722 
723     // Do something here.
724     if (status != IcacheWaitResponse ||
725         pkt->req != memReq ||
726         switchedOut) {
727         DPRINTF(FE, "Previous fetch was squashed.\n");
728         fetchIcacheSquashes++;
729         delete pkt->req;
730         delete pkt;
731         return;
732     }
733 
734     status = IcacheAccessComplete;
735 
736 /*    if (checkStall(tid)) {
737         fetchStatus[tid] = Blocked;
738     } else {
739         fetchStatus[tid] = IcacheMissComplete;
740     }
741 */
742 //    memcpy(cacheData, memReq->data, memReq->size);
743 
744     // Reset the completion event to NULL.
745 //    memReq->completionEvent = NULL;
746     delete pkt->req;
747     delete pkt;
748     memReq = NULL;
749 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a91359adcd9112672ff9264d6428b4106}{
\index{FrontEnd@{FrontEnd}!processInst@{processInst}}
\index{processInst@{processInst}!FrontEnd@{FrontEnd}}
\subsubsection[{processInst}]{\setlength{\rightskip}{0pt plus 5cm}void processInst ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a91359adcd9112672ff9264d6428b4106}



\begin{DoxyCode}
511 {
512     if (processBarriers(inst)) {
513         return;
514     }
515 
516     Addr inst_PC = inst->readPC();
517 
518     if (!inst->isControl()) {
519         inst->setPredTarg(inst->readNextPC());
520     } else {
521         fetchedBranches++;
522         if (branchPred.predict(inst, inst_PC, inst->threadNumber)) {
523             predictedBranches++;
524         }
525     }
526 
527     Addr next_PC = inst->readPredTarg();
528 
529     DPRINTF(FE, "[sn:%lli] Predicted and processed inst PC %#x, next PC "
530             "%#x\n", inst->seqNum, inst_PC, next_PC);
531 
532 //    inst->setNextPC(next_PC);
533 
534     // Not sure where I should set this
535     PC = next_PC;
536 
537     renameInst(inst);
538 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a29cb5a4f98063ce6e9210eacbdb35298}{
\index{FrontEnd@{FrontEnd}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!FrontEnd@{FrontEnd}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetry ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classFrontEnd_a29cb5a4f98063ce6e9210eacbdb35298}



\begin{DoxyCode}
771 {
772     assert(cacheBlocked);
773     if (retryPkt != NULL) {
774         assert(status == IcacheWaitRetry);
775 
776         if (icachePort.sendTiming(retryPkt)) {
777             status = IcacheWaitResponse;
778             retryPkt = NULL;
779             cacheBlocked = false;
780         }
781     } else {
782         // Access has been squashed since it was sent out.  Just clear
783         // the cache being blocked.
784         cacheBlocked = false;
785     }
786 
787 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{FrontEnd@{FrontEnd}!regStats@{regStats}}
\index{regStats@{regStats}!FrontEnd@{FrontEnd}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a4dc637449366fcdfc4e764cdf12d9b11}



\begin{DoxyCode}
156 {
157     icacheStallCycles
158         .name(name() + ".icacheStallCycles")
159         .desc("Number of cycles fetch is stalled on an Icache miss")
160         .prereq(icacheStallCycles);
161 
162     fetchedInsts
163         .name(name() + ".fetchedInsts")
164         .desc("Number of instructions fetch has processed")
165         .prereq(fetchedInsts);
166 
167     fetchedBranches
168         .name(name() + ".fetchedBranches")
169         .desc("Number of fetched branches")
170         .prereq(fetchedBranches);
171 
172     predictedBranches
173         .name(name() + ".predictedBranches")
174         .desc("Number of branches that fetch has predicted taken")
175         .prereq(predictedBranches);
176 
177     fetchCycles
178         .name(name() + ".fetchCycles")
179         .desc("Number of cycles fetch has run and was not squashing or"
180               " blocked")
181         .prereq(fetchCycles);
182 
183     fetchIdleCycles
184         .name(name() + ".fetchIdleCycles")
185         .desc("Number of cycles fetch was idle")
186         .prereq(fetchIdleCycles);
187 
188     fetchSquashCycles
189         .name(name() + ".fetchSquashCycles")
190         .desc("Number of cycles fetch has spent squashing")
191         .prereq(fetchSquashCycles);
192 
193     fetchBlockedCycles
194         .name(name() + ".fetchBlockedCycles")
195         .desc("Number of cycles fetch has spent blocked")
196         .prereq(fetchBlockedCycles);
197 
198     fetchedCacheLines
199         .name(name() + ".fetchedCacheLines")
200         .desc("Number of cache lines fetched")
201         .prereq(fetchedCacheLines);
202 
203     fetchIcacheSquashes
204         .name(name() + ".fetchIcacheSquashes")
205         .desc("Number of outstanding Icache misses that were squashed")
206         .prereq(fetchIcacheSquashes);
207 
208     fetchNisnDist
209         .init(/* base value */ 0,
210               /* last value */ width,
211               /* bucket size */ 1)
212         .name(name() + ".rateDist")
213         .desc("Number of instructions fetched each cycle (Total)")
214         .flags(Stats::pdf);
215 
216     idleRate
217         .name(name() + ".idleRate")
218         .desc("Percent of cycles fetch was idle")
219         .prereq(idleRate);
220     idleRate = fetchIdleCycles * 100 / cpu->numCycles;
221 
222     branchRate
223         .name(name() + ".branchRate")
224         .desc("Number of branch fetches per cycle")
225         .flags(Stats::total);
226     branchRate = fetchedBranches / cpu->numCycles;
227 
228     fetchRate
229         .name(name() + ".rate")
230         .desc("Number of inst fetches per cycle")
231         .flags(Stats::total);
232     fetchRate = fetchedInsts / cpu->numCycles;
233 
234     IFQCount
235         .name(name() + ".IFQ:count")
236         .desc("cumulative IFQ occupancy")
237         ;
238 
239     IFQFcount
240         .name(name() + ".IFQ:fullCount")
241         .desc("cumulative IFQ full count")
242         .flags(Stats::total)
243         ;
244 
245     IFQOccupancy
246         .name(name() + ".IFQ:occupancy")
247         .desc("avg IFQ occupancy (inst's)")
248         ;
249     IFQOccupancy = IFQCount / cpu->numCycles;
250 
251     IFQLatency
252         .name(name() + ".IFQ:latency")
253         .desc("avg IFQ occupant latency (cycle's)")
254         .flags(Stats::total)
255         ;
256 
257     IFQFullRate
258         .name(name() + ".IFQ:fullRate")
259         .desc("fraction of time (cycles) IFQ was full")
260         .flags(Stats::total);
261         ;
262     IFQFullRate = IFQFcount * Stats::constant(100) / cpu->numCycles;
263 
264     dispatchCountStat
265         .name(name() + ".DIS:count")
266         .desc("cumulative count of dispatched insts")
267         .flags(Stats::total)
268         ;
269 
270     dispatchedSerializing
271         .name(name() + ".DIS:serializingInsts")
272         .desc("count of serializing insts dispatched")
273         .flags(Stats::total)
274         ;
275 
276     dispatchedTempSerializing
277         .name(name() + ".DIS:tempSerializingInsts")
278         .desc("count of temporary serializing insts dispatched")
279         .flags(Stats::total)
280         ;
281 
282     dispatchSerializeStallCycles
283         .name(name() + ".DIS:serializeStallCycles")
284         .desc("count of cycles dispatch stalled for serializing inst")
285         .flags(Stats::total)
286         ;
287 
288     dispatchRate
289         .name(name() + ".DIS:rate")
290         .desc("dispatched insts per cycle")
291         .flags(Stats::total)
292         ;
293     dispatchRate = dispatchCountStat / cpu->numCycles;
294 
295     regIntFull
296         .name(name() + ".REG:int:full")
297         .desc("number of cycles where there were no INT registers")
298         ;
299 
300     regFpFull
301         .name(name() + ".REG:fp:full")
302         .desc("number of cycles where there were no FP registers")
303         ;
304     IFQLatency = IFQOccupancy / dispatchRate;
305 
306     branchPred.regStats();
307 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a837fe0c15d6fe36620f73f1b81558d56}{
\index{FrontEnd@{FrontEnd}!renameInst@{renameInst}}
\index{renameInst@{renameInst}!FrontEnd@{FrontEnd}}
\subsubsection[{renameInst}]{\setlength{\rightskip}{0pt plus 5cm}void renameInst ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classFrontEnd_a837fe0c15d6fe36620f73f1b81558d56}



\begin{DoxyCode}
892 {
893     DynInstPtr src_inst = NULL;
894     int num_src_regs = inst->numSrcRegs();
895     if (num_src_regs == 0) {
896         inst->setCanIssue();
897     } else {
898         for (int i = 0; i < num_src_regs; ++i) {
899             src_inst = renameTable[inst->srcRegIdx(i)];
900 
901             inst->setSrcInst(src_inst, i);
902 
903             DPRINTF(FE, "[sn:%lli]: Src reg %i is inst [sn:%lli]\n",
904                     inst->seqNum, (int)inst->srcRegIdx(i), src_inst->seqNum);
905 
906             if (src_inst->isResultReady()) {
907                 DPRINTF(FE, "Reg ready.\n");
908                 inst->markSrcRegReady(i);
909             } else {
910                 DPRINTF(FE, "Adding to dependent list.\n");
911                 src_inst->addDependent(inst);
912             }
913         }
914     }
915 
916     for (int i = 0; i < inst->numDestRegs(); ++i) {
917         RegIndex idx = inst->destRegIdx(i);
918 
919         DPRINTF(FE, "Dest reg %i is now inst [sn:%lli], was previously "
920                 "[sn:%lli]\n",
921                 (int)inst->destRegIdx(i), inst->seqNum,
922                 renameTable[idx]->seqNum);
923 
924         inst->setPrevDestInst(renameTable[idx], i);
925 
926         renameTable[idx] = inst;
927         --freeRegs;
928     }
929 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a5f15ff995704fecfa4b6e5d6147ec622}{
\index{FrontEnd@{FrontEnd}!setBackEnd@{setBackEnd}}
\index{setBackEnd@{setBackEnd}!FrontEnd@{FrontEnd}}
\subsubsection[{setBackEnd}]{\setlength{\rightskip}{0pt plus 5cm}void setBackEnd ({\bf BackEnd} $\ast$ {\em back\_\-end\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a5f15ff995704fecfa4b6e5d6147ec622}



\begin{DoxyCode}
105     { backEnd = back_end_ptr; }
\end{DoxyCode}
\hypertarget{classFrontEnd_aeabdb9f0aae07df67c3029f8fddb2693}{
\index{FrontEnd@{FrontEnd}!setCommBuffer@{setCommBuffer}}
\index{setCommBuffer@{setCommBuffer}!FrontEnd@{FrontEnd}}
\subsubsection[{setCommBuffer}]{\setlength{\rightskip}{0pt plus 5cm}void setCommBuffer ({\bf TimeBuffer}$<$ {\bf CommStruct} $>$ $\ast$ {\em \_\-comm})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_aeabdb9f0aae07df67c3029f8fddb2693}



\begin{DoxyCode}
140 {
141     comm = _comm;
142     // @todo: Hardcoded for now.  Allow this to be set by a latency.
143     fromCommit = comm->getWire(-1);
144 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a565fc31c4022b672a5c6b03a3dbcb408}{
\index{FrontEnd@{FrontEnd}!setCPU@{setCPU}}
\index{setCPU@{setCPU}!FrontEnd@{FrontEnd}}
\subsubsection[{setCPU}]{\setlength{\rightskip}{0pt plus 5cm}void setCPU ({\bf CPUType} $\ast$ {\em cpu\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a565fc31c4022b672a5c6b03a3dbcb408}



\begin{DoxyCode}
127 {
128     cpu = cpu_ptr;
129 
130     icachePort.setName(this->name() + "-iport");
131 
132     if (cpu->checker) {
133         cpu->checker->setIcachePort(&icachePort);
134     }
135 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a81b908e5de6420bc0c5a0c5b9b1e38c2}{
\index{FrontEnd@{FrontEnd}!setNextPC@{setNextPC}}
\index{setNextPC@{setNextPC}!FrontEnd@{FrontEnd}}
\subsubsection[{setNextPC}]{\setlength{\rightskip}{0pt plus 5cm}void setNextPC ({\bf Addr} {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a81b908e5de6420bc0c5a0c5b9b1e38c2}



\begin{DoxyCode}
233 { nextPC = val; }
\end{DoxyCode}
\hypertarget{classFrontEnd_a9bd96a8460a26f24f520db702f3f6eec}{
\index{FrontEnd@{FrontEnd}!setPC@{setPC}}
\index{setPC@{setPC}!FrontEnd@{FrontEnd}}
\subsubsection[{setPC}]{\setlength{\rightskip}{0pt plus 5cm}void setPC ({\bf Addr} {\em val})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a9bd96a8460a26f24f520db702f3f6eec}



\begin{DoxyCode}
232 { PC = val; }
\end{DoxyCode}
\hypertarget{classFrontEnd_ac6ccaaea6ac518cab92f71723b5a739e}{
\index{FrontEnd@{FrontEnd}!setTC@{setTC}}
\index{setTC@{setTC}!FrontEnd@{FrontEnd}}
\subsubsection[{setTC}]{\setlength{\rightskip}{0pt plus 5cm}void setTC ({\bf ThreadContext} $\ast$ {\em tc\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_ac6ccaaea6ac518cab92f71723b5a739e}



\begin{DoxyCode}
149 {
150     tc = tc_ptr;
151 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a2a6551551e11d9e1947d6805e8322757}{
\index{FrontEnd@{FrontEnd}!setThreadState@{setThreadState}}
\index{setThreadState@{setThreadState}!FrontEnd@{FrontEnd}}
\subsubsection[{setThreadState}]{\setlength{\rightskip}{0pt plus 5cm}void setThreadState ({\bf OzoneThreadState}$<$ Impl $>$ $\ast$ {\em thread\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a2a6551551e11d9e1947d6805e8322757}



\begin{DoxyCode}
112     { thread = thread_ptr; }
\end{DoxyCode}
\hypertarget{classFrontEnd_a2b2ddbfb364763ee4f0f337c79d436d9}{
\index{FrontEnd@{FrontEnd}!squash@{squash}}
\index{squash@{squash}!FrontEnd@{FrontEnd}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash (const {\bf InstSeqNum} \& {\em squash\_\-num}, \/  const {\bf Addr} \& {\em next\_\-PC}, \/  const bool {\em is\_\-branch} = {\ttfamily false}, \/  const bool {\em branch\_\-taken} = {\ttfamily false})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a2b2ddbfb364763ee4f0f337c79d436d9}



\begin{DoxyCode}
622 {
623     DPRINTF(FE, "Squashing from [sn:%lli], setting PC to %#x\n",
624             squash_num, next_PC);
625 
626     if (fetchFault != NoFault)
627         fetchFault = NoFault;
628 
629     while (!instBuffer.empty() &&
630            instBuffer.back()->seqNum > squash_num) {
631         DynInstPtr inst = instBuffer.back();
632 
633         DPRINTF(FE, "Squashing instruction [sn:%lli] PC %#x\n",
634                 inst->seqNum, inst->readPC());
635 
636         inst->clearDependents();
637 
638         instBuffer.pop_back();
639         --instBufferSize;
640 
641         freeRegs+= inst->numDestRegs();
642     }
643 
644     while (!feBuffer.empty() &&
645            feBuffer.back()->seqNum > squash_num) {
646         DynInstPtr inst = feBuffer.back();
647 
648         DPRINTF(FE, "Squashing instruction [sn:%lli] PC %#x\n",
649                 inst->seqNum, inst->readPC());
650 
651         inst->clearDependents();
652 
653         feBuffer.pop_back();
654         --instBufferSize;
655 
656         freeRegs+= inst->numDestRegs();
657     }
658 
659     // Copy over rename table from the back end.
660     renameTable.copyFrom(backEnd->renameTable);
661 
662     PC = next_PC;
663 
664     // Update BP with proper information.
665     if (is_branch) {
666         branchPred.squash(squash_num, next_PC, branch_taken, 0);
667     } else {
668         branchPred.squash(squash_num, 0);
669     }
670 
671     // Clear the icache miss if it's outstanding.
672     if (status == IcacheWaitResponse) {
673         DPRINTF(FE, "Squashing outstanding Icache access.\n");
674         memReq = NULL;
675     }
676 /*
677     if (status == SerializeBlocked) {
678         assert(barrierInst->seqNum > squash_num);
679         barrierInst = NULL;
680     }
681 */
682     // Unless this squash originated from the front end, we're probably
683     // in running mode now.
684     // Actually might want to make this latency dependent.
685     status = Running;
686     fetchCacheLineNextCycle = true;
687 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a05f299b443f8cc73a93d61572edc0218}{
\index{FrontEnd@{FrontEnd}!switchOut@{switchOut}}
\index{switchOut@{switchOut}!FrontEnd@{FrontEnd}}
\subsubsection[{switchOut}]{\setlength{\rightskip}{0pt plus 5cm}void switchOut ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a05f299b443f8cc73a93d61572edc0218}



\begin{DoxyCode}
943 {
944     switchedOut = true;
945     cpu->signalSwitched();
946 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a5a901e7ec5b94a55bd61fde88ad0b7f1}{
\index{FrontEnd@{FrontEnd}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!FrontEnd@{FrontEnd}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ({\bf ThreadContext} $\ast$ {\em old\_\-tc} = {\ttfamily NULL})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a5a901e7ec5b94a55bd61fde88ad0b7f1}



\begin{DoxyCode}
963 {
964     assert(freeRegs == numPhysRegs);
965     fetchCacheLineNextCycle = true;
966 
967     cacheBlkValid = false;
968 
969     fetchFault = NoFault;
970     serializeNext = false;
971     barrierInst = NULL;
972     status = Running;
973     switchedOut = false;
974     interruptPending = false;
975 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a873dd91783f9efb4a590aded1f70d6b0}{
\index{FrontEnd@{FrontEnd}!tick@{tick}}
\index{tick@{tick}!FrontEnd@{FrontEnd}}
\subsubsection[{tick}]{\setlength{\rightskip}{0pt plus 5cm}void tick ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a873dd91783f9efb4a590aded1f70d6b0}



\begin{DoxyCode}
312 {
313     if (switchedOut)
314         return;
315 
316     for (int insts_to_queue = numInstsReady[-latency];
317          !instBuffer.empty() && insts_to_queue;
318          --insts_to_queue)
319     {
320         DPRINTF(FE, "Transferring instruction [sn:%lli] to the feBuffer\n",
321                 instBuffer.front()->seqNum);
322         feBuffer.push_back(instBuffer.front());
323         instBuffer.pop_front();
324     }
325 
326     numInstsReady.advance();
327 
328     // @todo: Maybe I want to just have direct communication...
329     if (fromCommit->doneSeqNum) {
330         branchPred.update(fromCommit->doneSeqNum, 0);
331     }
332 
333     IFQCount += instBufferSize;
334     IFQFcount += instBufferSize == maxInstBufferSize;
335 
336     // Fetch cache line
337     if (status == IcacheAccessComplete) {
338         cacheBlkValid = true;
339 
340         status = Running;
341 //        if (barrierInst)
342 //            status = SerializeBlocked;
343         if (freeRegs <= 0)
344             status = RenameBlocked;
345         checkBE();
346     } else if (status == IcacheWaitResponse || status == IcacheWaitRetry) {
347         DPRINTF(FE, "Still in Icache wait.\n");
348         icacheStallCycles++;
349         return;
350     }
351 
352     if (status == RenameBlocked || status == SerializeBlocked ||
353         status == TrapPending || status == BEBlocked) {
354         // Will cause a one cycle bubble between changing state and
355         // restarting.
356         DPRINTF(FE, "In blocked status.\n");
357 
358         fetchBlockedCycles++;
359 
360         if (status == SerializeBlocked) {
361             dispatchSerializeStallCycles++;
362         }
363         updateStatus();
364         return;
365     } else if (status == QuiescePending) {
366         DPRINTF(FE, "Waiting for quiesce to execute or get squashed.\n");
367         return;
368     } else if (status != IcacheAccessComplete) {
369         if (fetchCacheLineNextCycle) {
370             Fault fault = fetchCacheLine();
371             if (fault != NoFault) {
372                 handleFault(fault);
373                 fetchFault = fault;
374                 return;
375             }
376             fetchCacheLineNextCycle = false;
377         }
378         // If miss, stall until it returns.
379         if (status == IcacheWaitResponse || status == IcacheWaitRetry) {
380             // Tell CPU to not tick me for now.
381             return;
382         }
383     }
384 
385     fetchCycles++;
386 
387     int num_inst = 0;
388 
389     // Otherwise loop and process instructions.
390     // One way to hack infinite width is to set width and maxInstBufferSize
391     // both really high.  Inelegant, but probably will work.
392     while (num_inst < width &&
393            instBufferSize < maxInstBufferSize) {
394         // Get instruction from cache line.
395         DynInstPtr inst = getInstFromCacheline();
396 
397         if (!inst) {
398             // PC is no longer in the cache line, end fetch.
399             // Might want to check this at the end of the cycle so that
400             // there's no cycle lost to checking for a new cache line.
401             DPRINTF(FE, "Need to get new cache line\n");
402             fetchCacheLineNextCycle = true;
403             break;
404         }
405 
406         processInst(inst);
407 
408         if (status == SerializeBlocked) {
409             break;
410         }
411 
412         // Possibly push into a time buffer that estimates the front end
413         // latency
414         instBuffer.push_back(inst);
415         ++instBufferSize;
416         numInstsReady[0]++;
417         ++num_inst;
418 
419         if (inst->isQuiesce()) {
420             status = QuiescePending;
421             break;
422         }
423 
424         if (inst->predTaken()) {
425             // Start over with tick?
426             break;
427         } else if (freeRegs <= 0) {
428             DPRINTF(FE, "Ran out of free registers to rename to!\n");
429             status = RenameBlocked;
430             break;
431         } else if (serializeNext) {
432             break;
433         }
434     }
435 
436     fetchNisnDist.sample(num_inst);
437     checkBE();
438 
439     DPRINTF(FE, "Num insts processed: %i, Inst Buffer size: %i, Free "
440             "Regs %i\n", num_inst, instBufferSize, freeRegs);
441 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a9a8ca871f405a4b52efc2a2f9f38a69a}{
\index{FrontEnd@{FrontEnd}!updateStatus@{updateStatus}}
\index{updateStatus@{updateStatus}!FrontEnd@{FrontEnd}}
\subsubsection[{updateStatus}]{\setlength{\rightskip}{0pt plus 5cm}bool updateStatus ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classFrontEnd_a9a8ca871f405a4b52efc2a2f9f38a69a}



\begin{DoxyCode}
792 {
793     bool serialize_block = !backEnd->robEmpty() || instBufferSize;
794     bool be_block = cpu->decoupledFrontEnd ? false : backEnd->isBlocked();
795     bool ret_val = false;
796 
797     if (status == SerializeBlocked && !serialize_block) {
798         status = SerializeComplete;
799         ret_val = true;
800     }
801 
802     if (status == BEBlocked && !be_block) {
803 //        if (barrierInst) {
804 //            status = SerializeBlocked;
805 //        } else {
806             status = Running;
807 //        }
808         ret_val = true;
809     }
810     return ret_val;
811 }
\end{DoxyCode}
\hypertarget{classFrontEnd_a040cbeac7187b0b8cdb1242d3f5aa179}{
\index{FrontEnd@{FrontEnd}!wakeFromQuiesce@{wakeFromQuiesce}}
\index{wakeFromQuiesce@{wakeFromQuiesce}!FrontEnd@{FrontEnd}}
\subsubsection[{wakeFromQuiesce}]{\setlength{\rightskip}{0pt plus 5cm}void wakeFromQuiesce ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFrontEnd_a040cbeac7187b0b8cdb1242d3f5aa179}



\begin{DoxyCode}
934 {
935     DPRINTF(FE, "Waking up from quiesce\n");
936     // Hopefully this is safe
937     status = Running;
938 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classFrontEnd_af59b0af2f4e41305c729ac6e36fd7803}{
\index{FrontEnd@{FrontEnd}!backEnd@{backEnd}}
\index{backEnd@{backEnd}!FrontEnd@{FrontEnd}}
\subsubsection[{backEnd}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BackEnd}$\ast$ {\bf backEnd}}}
\label{classFrontEnd_af59b0af2f4e41305c729ac6e36fd7803}
\hypertarget{classFrontEnd_acf9d2aaec2de3b1c53dc1cce63de9794}{
\index{FrontEnd@{FrontEnd}!barrierInst@{barrierInst}}
\index{barrierInst@{barrierInst}!FrontEnd@{FrontEnd}}
\subsubsection[{barrierInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf barrierInst}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_acf9d2aaec2de3b1c53dc1cce63de9794}
\hypertarget{classFrontEnd_a98d9448d614ac60bbf861bbf3db21fa9}{
\index{FrontEnd@{FrontEnd}!branchPred@{branchPred}}
\index{branchPred@{branchPred}!FrontEnd@{FrontEnd}}
\subsubsection[{branchPred}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BranchPred} {\bf branchPred}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a98d9448d614ac60bbf861bbf3db21fa9}
\hypertarget{classFrontEnd_abceba4006d416e352df47f692b589bc3}{
\index{FrontEnd@{FrontEnd}!branchRate@{branchRate}}
\index{branchRate@{branchRate}!FrontEnd@{FrontEnd}}
\subsubsection[{branchRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf branchRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_abceba4006d416e352df47f692b589bc3}
\hypertarget{classFrontEnd_a33b99af01da30de3072e0fb714c0ca38}{
\index{FrontEnd@{FrontEnd}!cacheBlkMask@{cacheBlkMask}}
\index{cacheBlkMask@{cacheBlkMask}!FrontEnd@{FrontEnd}}
\subsubsection[{cacheBlkMask}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf cacheBlkMask}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a33b99af01da30de3072e0fb714c0ca38}
Mask to get a cache block's address. \hypertarget{classFrontEnd_a5eccc8a239dec2935cc4a2c6aa5e3dd1}{
\index{FrontEnd@{FrontEnd}!cacheBlkPC@{cacheBlkPC}}
\index{cacheBlkPC@{cacheBlkPC}!FrontEnd@{FrontEnd}}
\subsubsection[{cacheBlkPC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf cacheBlkPC}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a5eccc8a239dec2935cc4a2c6aa5e3dd1}
\hypertarget{classFrontEnd_a7c9e97ff2bb74bc86262cd751490b482}{
\index{FrontEnd@{FrontEnd}!cacheBlkSize@{cacheBlkSize}}
\index{cacheBlkSize@{cacheBlkSize}!FrontEnd@{FrontEnd}}
\subsubsection[{cacheBlkSize}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf cacheBlkSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a7c9e97ff2bb74bc86262cd751490b482}
\hypertarget{classFrontEnd_a80f6b4712235f03884c0447e594dd36c}{
\index{FrontEnd@{FrontEnd}!cacheBlkValid@{cacheBlkValid}}
\index{cacheBlkValid@{cacheBlkValid}!FrontEnd@{FrontEnd}}
\subsubsection[{cacheBlkValid}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf cacheBlkValid}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a80f6b4712235f03884c0447e594dd36c}
\hypertarget{classFrontEnd_a12a8dc8b9e94659a01ff979d9d98be89}{
\index{FrontEnd@{FrontEnd}!cacheBlocked@{cacheBlocked}}
\index{cacheBlocked@{cacheBlocked}!FrontEnd@{FrontEnd}}
\subsubsection[{cacheBlocked}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf cacheBlocked}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a12a8dc8b9e94659a01ff979d9d98be89}
\hypertarget{classFrontEnd_ab850d89c84ed3153a7e35592951cccd7}{
\index{FrontEnd@{FrontEnd}!cacheData@{cacheData}}
\index{cacheData@{cacheData}!FrontEnd@{FrontEnd}}
\subsubsection[{cacheData}]{\setlength{\rightskip}{0pt plus 5cm}uint8\_\-t$\ast$ {\bf cacheData}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_ab850d89c84ed3153a7e35592951cccd7}
The cache line being fetched. \hypertarget{classFrontEnd_a282f2307a986f183b83e887756561687}{
\index{FrontEnd@{FrontEnd}!comm@{comm}}
\index{comm@{comm}!FrontEnd@{FrontEnd}}
\subsubsection[{comm}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf CommStruct}$>$$\ast$ {\bf comm}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a282f2307a986f183b83e887756561687}
\hypertarget{classFrontEnd_ab2e5cd9c988b4f91a1b9040f14fbd0f9}{
\index{FrontEnd@{FrontEnd}!cpu@{cpu}}
\index{cpu@{cpu}!FrontEnd@{FrontEnd}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CPUType}$\ast$ {\bf cpu}}}
\label{classFrontEnd_ab2e5cd9c988b4f91a1b9040f14fbd0f9}
\hypertarget{classFrontEnd_aeaaccfce2b14dfd27899536343487787}{
\index{FrontEnd@{FrontEnd}!dispatchCountStat@{dispatchCountStat}}
\index{dispatchCountStat@{dispatchCountStat}!FrontEnd@{FrontEnd}}
\subsubsection[{dispatchCountStat}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf dispatchCountStat}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_aeaaccfce2b14dfd27899536343487787}
\hypertarget{classFrontEnd_a02e7f15196d5b571aca2e2fc4636a100}{
\index{FrontEnd@{FrontEnd}!dispatchedSerializing@{dispatchedSerializing}}
\index{dispatchedSerializing@{dispatchedSerializing}!FrontEnd@{FrontEnd}}
\subsubsection[{dispatchedSerializing}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf dispatchedSerializing}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a02e7f15196d5b571aca2e2fc4636a100}
\hypertarget{classFrontEnd_a7d0500ec7ced57d9f111842c84317fa6}{
\index{FrontEnd@{FrontEnd}!dispatchedTempSerializing@{dispatchedTempSerializing}}
\index{dispatchedTempSerializing@{dispatchedTempSerializing}!FrontEnd@{FrontEnd}}
\subsubsection[{dispatchedTempSerializing}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf dispatchedTempSerializing}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a7d0500ec7ced57d9f111842c84317fa6}
\hypertarget{classFrontEnd_a39e060f97b4d1e11037234f7e2620e2a}{
\index{FrontEnd@{FrontEnd}!dispatchRate@{dispatchRate}}
\index{dispatchRate@{dispatchRate}!FrontEnd@{FrontEnd}}
\subsubsection[{dispatchRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf dispatchRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a39e060f97b4d1e11037234f7e2620e2a}
\hypertarget{classFrontEnd_a0188f971c738223b1be0cac46c0820c0}{
\index{FrontEnd@{FrontEnd}!dispatchSerializeStallCycles@{dispatchSerializeStallCycles}}
\index{dispatchSerializeStallCycles@{dispatchSerializeStallCycles}!FrontEnd@{FrontEnd}}
\subsubsection[{dispatchSerializeStallCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf dispatchSerializeStallCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a0188f971c738223b1be0cac46c0820c0}
\hypertarget{classFrontEnd_ac7ded4b035e54069bf829087fd67c780}{
\index{FrontEnd@{FrontEnd}!feBuffer@{feBuffer}}
\index{feBuffer@{feBuffer}!FrontEnd@{FrontEnd}}
\subsubsection[{feBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstBuff} {\bf feBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_ac7ded4b035e54069bf829087fd67c780}
\hypertarget{classFrontEnd_a0501ffad4abed98618a6cf0ba9c3599b}{
\index{FrontEnd@{FrontEnd}!fetchBlockedCycles@{fetchBlockedCycles}}
\index{fetchBlockedCycles@{fetchBlockedCycles}!FrontEnd@{FrontEnd}}
\subsubsection[{fetchBlockedCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchBlockedCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a0501ffad4abed98618a6cf0ba9c3599b}
Stat for total number of cycles spent blocked due to other stages in the pipeline. \hypertarget{classFrontEnd_a2bc7884cb20b22f02a5454ca8b6205b6}{
\index{FrontEnd@{FrontEnd}!fetchCacheLineNextCycle@{fetchCacheLineNextCycle}}
\index{fetchCacheLineNextCycle@{fetchCacheLineNextCycle}!FrontEnd@{FrontEnd}}
\subsubsection[{fetchCacheLineNextCycle}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf fetchCacheLineNextCycle}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a2bc7884cb20b22f02a5454ca8b6205b6}
\hypertarget{classFrontEnd_a9699b5489dd499e832651b96f95b5d19}{
\index{FrontEnd@{FrontEnd}!fetchCycles@{fetchCycles}}
\index{fetchCycles@{fetchCycles}!FrontEnd@{FrontEnd}}
\subsubsection[{fetchCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a9699b5489dd499e832651b96f95b5d19}
Stat for total number of cycles spent fetching. \hypertarget{classFrontEnd_aaca0646636cde96795aed6beb2942975}{
\index{FrontEnd@{FrontEnd}!fetchedBranches@{fetchedBranches}}
\index{fetchedBranches@{fetchedBranches}!FrontEnd@{FrontEnd}}
\subsubsection[{fetchedBranches}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchedBranches}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_aaca0646636cde96795aed6beb2942975}
\hypertarget{classFrontEnd_a0ead660daa133edcd64ac552d473ebba}{
\index{FrontEnd@{FrontEnd}!fetchedCacheLines@{fetchedCacheLines}}
\index{fetchedCacheLines@{fetchedCacheLines}!FrontEnd@{FrontEnd}}
\subsubsection[{fetchedCacheLines}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchedCacheLines}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a0ead660daa133edcd64ac552d473ebba}
Stat for total number of fetched cache lines. \hypertarget{classFrontEnd_af0e3fa228032036d2022ed9e2a3612b6}{
\index{FrontEnd@{FrontEnd}!fetchedInsts@{fetchedInsts}}
\index{fetchedInsts@{fetchedInsts}!FrontEnd@{FrontEnd}}
\subsubsection[{fetchedInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchedInsts}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_af0e3fa228032036d2022ed9e2a3612b6}
Stat for total number of fetched instructions. \hypertarget{classFrontEnd_ac2f4c2fc84b40d9abd220e8bd21242c9}{
\index{FrontEnd@{FrontEnd}!fetchFault@{fetchFault}}
\index{fetchFault@{fetchFault}!FrontEnd@{FrontEnd}}
\subsubsection[{fetchFault}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Fault} {\bf fetchFault}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_ac2f4c2fc84b40d9abd220e8bd21242c9}
\hypertarget{classFrontEnd_af5ce6113f31fddaab758b8fb025600bc}{
\index{FrontEnd@{FrontEnd}!fetchIcacheSquashes@{fetchIcacheSquashes}}
\index{fetchIcacheSquashes@{fetchIcacheSquashes}!FrontEnd@{FrontEnd}}
\subsubsection[{fetchIcacheSquashes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchIcacheSquashes}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_af5ce6113f31fddaab758b8fb025600bc}
\hypertarget{classFrontEnd_a8af716ad2a53a409640347226078591c}{
\index{FrontEnd@{FrontEnd}!fetchIdleCycles@{fetchIdleCycles}}
\index{fetchIdleCycles@{fetchIdleCycles}!FrontEnd@{FrontEnd}}
\subsubsection[{fetchIdleCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchIdleCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a8af716ad2a53a409640347226078591c}
\hypertarget{classFrontEnd_a4793a4a8857c13e7812b1c37c6df761b}{
\index{FrontEnd@{FrontEnd}!fetchNisnDist@{fetchNisnDist}}
\index{fetchNisnDist@{fetchNisnDist}!FrontEnd@{FrontEnd}}
\subsubsection[{fetchNisnDist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Distribution} {\bf fetchNisnDist}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a4793a4a8857c13e7812b1c37c6df761b}
Distribution of number of instructions fetched each cycle. \hypertarget{classFrontEnd_a7656c6cac3b62fa389148c650a5d127a}{
\index{FrontEnd@{FrontEnd}!fetchRate@{fetchRate}}
\index{fetchRate@{fetchRate}!FrontEnd@{FrontEnd}}
\subsubsection[{fetchRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf fetchRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a7656c6cac3b62fa389148c650a5d127a}
\hypertarget{classFrontEnd_ae1b92a3469ac6b00fddd788b71f64c9a}{
\index{FrontEnd@{FrontEnd}!fetchSquashCycles@{fetchSquashCycles}}
\index{fetchSquashCycles@{fetchSquashCycles}!FrontEnd@{FrontEnd}}
\subsubsection[{fetchSquashCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf fetchSquashCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_ae1b92a3469ac6b00fddd788b71f64c9a}
Stat for total number of cycles spent squashing. \hypertarget{classFrontEnd_a6c1923b44f74e7cc11aeae29d9c1ec71}{
\index{FrontEnd@{FrontEnd}!freeRegs@{freeRegs}}
\index{freeRegs@{freeRegs}!FrontEnd@{FrontEnd}}
\subsubsection[{freeRegs}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf freeRegs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a6c1923b44f74e7cc11aeae29d9c1ec71}
\hypertarget{classFrontEnd_a77bf6c956edddf1d551d5371ff72162e}{
\index{FrontEnd@{FrontEnd}!fromCommit@{fromCommit}}
\index{fromCommit@{fromCommit}!FrontEnd@{FrontEnd}}
\subsubsection[{fromCommit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<${\bf CommStruct}$>$::wire {\bf fromCommit}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a77bf6c956edddf1d551d5371ff72162e}
\hypertarget{classFrontEnd_a290723656a84b9cc90dfce377af9aad0}{
\index{FrontEnd@{FrontEnd}!icachePort@{icachePort}}
\index{icachePort@{icachePort}!FrontEnd@{FrontEnd}}
\subsubsection[{icachePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf IcachePort} {\bf icachePort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a290723656a84b9cc90dfce377af9aad0}
\hypertarget{classFrontEnd_a2b9328bdb1a6898bfae824981cd64311}{
\index{FrontEnd@{FrontEnd}!icacheStallCycles@{icacheStallCycles}}
\index{icacheStallCycles@{icacheStallCycles}!FrontEnd@{FrontEnd}}
\subsubsection[{icacheStallCycles}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf icacheStallCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a2b9328bdb1a6898bfae824981cd64311}
Stat for total number of cycles stalled due to an icache miss. \hypertarget{classFrontEnd_a4b942e4ec6b8c1d29a1c96e901ea71dd}{
\index{FrontEnd@{FrontEnd}!idleRate@{idleRate}}
\index{idleRate@{idleRate}!FrontEnd@{FrontEnd}}
\subsubsection[{idleRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf idleRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a4b942e4ec6b8c1d29a1c96e901ea71dd}
\hypertarget{classFrontEnd_af5442c563401e6561dbceb43f73edef5}{
\index{FrontEnd@{FrontEnd}!IFQCount@{IFQCount}}
\index{IFQCount@{IFQCount}!FrontEnd@{FrontEnd}}
\subsubsection[{IFQCount}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf IFQCount}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_af5442c563401e6561dbceb43f73edef5}
\hypertarget{classFrontEnd_abb5d3a8be34487bf58c34aa0a95c5546}{
\index{FrontEnd@{FrontEnd}!IFQFcount@{IFQFcount}}
\index{IFQFcount@{IFQFcount}!FrontEnd@{FrontEnd}}
\subsubsection[{IFQFcount}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf IFQFcount}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_abb5d3a8be34487bf58c34aa0a95c5546}
\hypertarget{classFrontEnd_a5e1f7150d45f7f01173be5aaec45e5b1}{
\index{FrontEnd@{FrontEnd}!IFQFullRate@{IFQFullRate}}
\index{IFQFullRate@{IFQFullRate}!FrontEnd@{FrontEnd}}
\subsubsection[{IFQFullRate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf IFQFullRate}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a5e1f7150d45f7f01173be5aaec45e5b1}
\hypertarget{classFrontEnd_a4204358ee6bfe3c054b44863d0357534}{
\index{FrontEnd@{FrontEnd}!IFQLatency@{IFQLatency}}
\index{IFQLatency@{IFQLatency}!FrontEnd@{FrontEnd}}
\subsubsection[{IFQLatency}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf IFQLatency}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a4204358ee6bfe3c054b44863d0357534}
\hypertarget{classFrontEnd_a0cf052f31902edea9904fb44946d8add}{
\index{FrontEnd@{FrontEnd}!IFQOccupancy@{IFQOccupancy}}
\index{IFQOccupancy@{IFQOccupancy}!FrontEnd@{FrontEnd}}
\subsubsection[{IFQOccupancy}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf IFQOccupancy}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a0cf052f31902edea9904fb44946d8add}
\hypertarget{classFrontEnd_ae82efc68a3059bd20d0dd5d8dbdd9d02}{
\index{FrontEnd@{FrontEnd}!instBuffer@{instBuffer}}
\index{instBuffer@{instBuffer}!FrontEnd@{FrontEnd}}
\subsubsection[{instBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstBuff} {\bf instBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_ae82efc68a3059bd20d0dd5d8dbdd9d02}
\hypertarget{classFrontEnd_a4668a18dc57e1f433f756f8586c5ace7}{
\index{FrontEnd@{FrontEnd}!instBufferSize@{instBufferSize}}
\index{instBufferSize@{instBufferSize}!FrontEnd@{FrontEnd}}
\subsubsection[{instBufferSize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf instBufferSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a4668a18dc57e1f433f756f8586c5ace7}
\hypertarget{classFrontEnd_a310de3efc6b60f47de5792d2b00d0840}{
\index{FrontEnd@{FrontEnd}!interruptPending@{interruptPending}}
\index{interruptPending@{interruptPending}!FrontEnd@{FrontEnd}}
\subsubsection[{interruptPending}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf interruptPending}}}
\label{classFrontEnd_a310de3efc6b60f47de5792d2b00d0840}
\hypertarget{classFrontEnd_a9c5bf07170b5d91cfb44d4bfd0517128}{
\index{FrontEnd@{FrontEnd}!latency@{latency}}
\index{latency@{latency}!FrontEnd@{FrontEnd}}
\subsubsection[{latency}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf latency}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a9c5bf07170b5d91cfb44d4bfd0517128}
\hypertarget{classFrontEnd_af676af949cf4321753cd6839d9d7e879}{
\index{FrontEnd@{FrontEnd}!maxInstBufferSize@{maxInstBufferSize}}
\index{maxInstBufferSize@{maxInstBufferSize}!FrontEnd@{FrontEnd}}
\subsubsection[{maxInstBufferSize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf maxInstBufferSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_af676af949cf4321753cd6839d9d7e879}
\hypertarget{classFrontEnd_a5520eb2f7c2cf4b0e109d6ffd6d2d053}{
\index{FrontEnd@{FrontEnd}!memReq@{memReq}}
\index{memReq@{memReq}!FrontEnd@{FrontEnd}}
\subsubsection[{memReq}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RequestPtr} {\bf memReq}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a5520eb2f7c2cf4b0e109d6ffd6d2d053}
\hypertarget{classFrontEnd_a3bda64c96331af0ad914c5873b7074b5}{
\index{FrontEnd@{FrontEnd}!nextPC@{nextPC}}
\index{nextPC@{nextPC}!FrontEnd@{FrontEnd}}
\subsubsection[{nextPC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf nextPC}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a3bda64c96331af0ad914c5873b7074b5}
\hypertarget{classFrontEnd_a7e748ead7cabc60dbb73666b45a0cb18}{
\index{FrontEnd@{FrontEnd}!numInstsReady@{numInstsReady}}
\index{numInstsReady@{numInstsReady}!FrontEnd@{FrontEnd}}
\subsubsection[{numInstsReady}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TimeBuffer}$<$int$>$ {\bf numInstsReady}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a7e748ead7cabc60dbb73666b45a0cb18}
\hypertarget{classFrontEnd_a57ec02581bb51a2421a7d401786beee5}{
\index{FrontEnd@{FrontEnd}!numPhysRegs@{numPhysRegs}}
\index{numPhysRegs@{numPhysRegs}!FrontEnd@{FrontEnd}}
\subsubsection[{numPhysRegs}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf numPhysRegs}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a57ec02581bb51a2421a7d401786beee5}
\hypertarget{classFrontEnd_ab4fee9d7e100be71a104b4b714909357}{
\index{FrontEnd@{FrontEnd}!PC@{PC}}
\index{PC@{PC}!FrontEnd@{FrontEnd}}
\subsubsection[{PC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf PC}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_ab4fee9d7e100be71a104b4b714909357}
\hypertarget{classFrontEnd_ae5c954036e76b5cc5a82cf7f17d4d5ed}{
\index{FrontEnd@{FrontEnd}!predictedBranches@{predictedBranches}}
\index{predictedBranches@{predictedBranches}!FrontEnd@{FrontEnd}}
\subsubsection[{predictedBranches}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf predictedBranches}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_ae5c954036e76b5cc5a82cf7f17d4d5ed}
Stat for total number of predicted branches. \hypertarget{classFrontEnd_a36fecc5527bb51e9a1c6cc956c167ace}{
\index{FrontEnd@{FrontEnd}!regFpFull@{regFpFull}}
\index{regFpFull@{regFpFull}!FrontEnd@{FrontEnd}}
\subsubsection[{regFpFull}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf regFpFull}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a36fecc5527bb51e9a1c6cc956c167ace}
\hypertarget{classFrontEnd_a19af07bae8f9b3d63c68d06893b5a70f}{
\index{FrontEnd@{FrontEnd}!regIntFull@{regIntFull}}
\index{regIntFull@{regIntFull}!FrontEnd@{FrontEnd}}
\subsubsection[{regIntFull}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf regIntFull}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a19af07bae8f9b3d63c68d06893b5a70f}
\hypertarget{classFrontEnd_af8d3f859e7c0dd9408ba99de6f415616}{
\index{FrontEnd@{FrontEnd}!renameTable@{renameTable}}
\index{renameTable@{renameTable}!FrontEnd@{FrontEnd}}
\subsubsection[{renameTable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf RenameTable}$<$Impl$>$ {\bf renameTable}}}
\label{classFrontEnd_af8d3f859e7c0dd9408ba99de6f415616}
\hypertarget{classFrontEnd_a314ae93c04b3ca96e79e1b1f39a8e478}{
\index{FrontEnd@{FrontEnd}!retryPkt@{retryPkt}}
\index{retryPkt@{retryPkt}!FrontEnd@{FrontEnd}}
\subsubsection[{retryPkt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PacketPtr} {\bf retryPkt}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a314ae93c04b3ca96e79e1b1f39a8e478}
The packet that is waiting to be retried. \hypertarget{classFrontEnd_a7419c9cb2b5771ab5b23687a64c2af95}{
\index{FrontEnd@{FrontEnd}!serializeNext@{serializeNext}}
\index{serializeNext@{serializeNext}!FrontEnd@{FrontEnd}}
\subsubsection[{serializeNext}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf serializeNext}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a7419c9cb2b5771ab5b23687a64c2af95}
\hypertarget{classFrontEnd_ae29aa2d4ae440022daaed1107eb306b3}{
\index{FrontEnd@{FrontEnd}!status@{status}}
\index{status@{status}!FrontEnd@{FrontEnd}}
\subsubsection[{status}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Status} {\bf status}}}
\label{classFrontEnd_ae29aa2d4ae440022daaed1107eb306b3}
\hypertarget{classFrontEnd_a1aee6db9bfb75cf02e38a82e5d02847f}{
\index{FrontEnd@{FrontEnd}!switchedOut@{switchedOut}}
\index{switchedOut@{switchedOut}!FrontEnd@{FrontEnd}}
\subsubsection[{switchedOut}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf switchedOut}}}
\label{classFrontEnd_a1aee6db9bfb75cf02e38a82e5d02847f}
\hypertarget{classFrontEnd_a4455a4759e69e5ebe68ae7298cbcc37d}{
\index{FrontEnd@{FrontEnd}!tc@{tc}}
\index{tc@{tc}!FrontEnd@{FrontEnd}}
\subsubsection[{tc}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadContext}$\ast$ {\bf tc}}}
\label{classFrontEnd_a4455a4759e69e5ebe68ae7298cbcc37d}
\hypertarget{classFrontEnd_ab6f834310107fd693035eba2eeca583f}{
\index{FrontEnd@{FrontEnd}!thread@{thread}}
\index{thread@{thread}!FrontEnd@{FrontEnd}}
\subsubsection[{thread}]{\setlength{\rightskip}{0pt plus 5cm}{\bf OzoneThreadState}$<$Impl$>$$\ast$ {\bf thread}}}
\label{classFrontEnd_ab6f834310107fd693035eba2eeca583f}
\hypertarget{classFrontEnd_a2474a5474cbff19523a51eb1de01cda4}{
\index{FrontEnd@{FrontEnd}!width@{width}}
\index{width@{width}!FrontEnd@{FrontEnd}}
\subsubsection[{width}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf width}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFrontEnd_a2474a5474cbff19523a51eb1de01cda4}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/ozone/\hyperlink{front__end_8hh}{front\_\-end.hh}\item 
cpu/ozone/\hyperlink{front__end__impl_8hh}{front\_\-end\_\-impl.hh}\end{DoxyCompactItemize}
