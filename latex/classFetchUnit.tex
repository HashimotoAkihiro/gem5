\hypertarget{classFetchUnit}{
\section{クラス FetchUnit}
\label{classFetchUnit}\index{FetchUnit@{FetchUnit}}
}


{\ttfamily \#include $<$fetch\_\-unit.hh$>$}FetchUnitに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classFetchUnit}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structFetchUnit_1_1FetchBlock}{FetchBlock}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classFetchUnit_a2afce0a47a93eee73a314d53e4890153}{Command} \{ \hyperlink{classFetchUnit_a2afce0a47a93eee73a314d53e4890153a36b8c84ed26a9bbdd1dd1dd457fda0f4}{InitiateFetch}, 
\hyperlink{classFetchUnit_a2afce0a47a93eee73a314d53e4890153aa6cf31a29793ec4c8f38a24da999cdc2}{CompleteFetch}
 \}
\item 
typedef \hyperlink{classRefCountingPtr}{ThePipeline::DynInstPtr} \hyperlink{classFetchUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{DynInstPtr}
\item 
typedef TheISA::ExtMachInst \hyperlink{classFetchUnit_a5605d4fc727eae9e595325c90c0ec108}{ExtMachInst}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classFetchUnit_a75059c82e769a677cc5e29338234493b}{FetchUnit} (std::string res\_\-name, int res\_\-id, int res\_\-width, \hyperlink{classCycles}{Cycles} res\_\-latency, \hyperlink{classInOrderCPU}{InOrderCPU} $\ast$\_\-cpu, \hyperlink{namespaceThePipeline_ab62ca16eeca26566ad2422b5df4943ce}{ThePipeline::Params} $\ast$params)
\item 
virtual \hyperlink{classFetchUnit_a1c06a50150220d7a3cf7acc6e3161c01}{$\sim$FetchUnit} ()
\item 
\hyperlink{classResourceRequest}{ResourceRequest} $\ast$ \hyperlink{classFetchUnit_aae5ce84f94a1057d7f60172daf5d731d}{getRequest} (\hyperlink{classRefCountingPtr}{DynInstPtr} \_\-inst, int stage\_\-num, int res\_\-idx, int slot\_\-num, unsigned cmd)
\item 
void \hyperlink{classFetchUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{execute} (int slot\_\-num)
\item 
void \hyperlink{classFetchUnit_abf76d6d245f7d3b17d26ea8dcc0cf36f}{trap} (\hyperlink{classRefCountingPtr}{Fault} fault, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid, \hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
TheISA::Decoder $\ast$ \hyperlink{classFetchUnit_a5f15f1b871b77f550632262df3bce5f1}{decoder} \mbox{[}\hyperlink{namespaceThePipeline_ac9c0bbe9cf27d93e08ea8ccc4096e633}{ThePipeline::MaxThreads}\mbox{]}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classFetchUnit_ac2831520eb121be08811b040992f416b}{squashCacheRequest} (\hyperlink{classCacheRequest}{CacheReqPtr} req\_\-ptr)
\item 
void \hyperlink{classFetchUnit_a38dd226fde9580d1753032305635353f}{createMachInst} (\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{structFetchUnit_1_1FetchBlock}{FetchBlock} $\ast$ $>$::iterator fetch\_\-it, \hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
void \hyperlink{classFetchUnit_a3dc029c2e87eb911352b82ff15c86236}{processCacheCompletion} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual void \hyperlink{classFetchUnit_aa942d730ea26d41b72db771cc951f51e}{setupMemRequest} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, \hyperlink{classCacheRequest}{CacheReqPtr} cache\_\-req, int acc\_\-size, int flags)
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classFetchUnit_ab36871bdfd10e2b804a650594462b36e}{cacheBlockAlignPC} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr)
\item 
void \hyperlink{classFetchUnit_a8a894d91761439227fd27d91a318c31f}{removeAddrDependency} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{structFetchUnit_1_1FetchBlock}{FetchBlock} $\ast$ $>$::iterator \hyperlink{classFetchUnit_aa2c07c0c9648d711cd5916edb942dd4f}{findReplacementBlock} ()
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{structFetchUnit_1_1FetchBlock}{FetchBlock} $\ast$ $>$::iterator \hyperlink{classFetchUnit_ac92ba32e2d79eb977cc570fc6da90fcd}{findBlock} (\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{structFetchUnit_1_1FetchBlock}{FetchBlock} $\ast$ $>$ \&fetch\_\-blocks, int asid, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} block\_\-addr)
\item 
void \hyperlink{classFetchUnit_aa7abce4f82cf68e0c338953fb41e3fc8}{markBlockUsed} (\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{structFetchUnit_1_1FetchBlock}{FetchBlock} $\ast$ $>$::iterator block\_\-it)
\item 
int \hyperlink{classFetchUnit_a09d558cb19e49cebfa44ecfad6ca98d7}{blocksInUse} ()
\item 
void \hyperlink{classFetchUnit_a2ccfb855f570dc8e39e9d25d3fb845a3}{clearFetchBuffer} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classFetchUnit_a494a9a986bc62c946604f9e9047ad237}{instSize}
\item 
int \hyperlink{classFetchUnit_a97e2b6a8af0f5cb34f9d266a9ac21a48}{fetchBuffSize}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{structFetchUnit_1_1FetchBlock}{FetchBlock} $\ast$ $>$ \hyperlink{classFetchUnit_ab201075a98e275240766bee54144d42d}{fetchBuffer}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{structFetchUnit_1_1FetchBlock}{FetchBlock} $\ast$ $>$ \hyperlink{classFetchUnit_af2a77ef8e6fe01c93bcac28b1152e44b}{pendingFetch}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classFetchUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{
\index{FetchUnit@{FetchUnit}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!FetchUnit@{FetchUnit}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf ThePipeline::DynInstPtr} {\bf DynInstPtr}}}
\label{classFetchUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}


\hyperlink{classCacheUnit_af9d0c8a46736ba6aa2d8bb94da1a5e73}{CacheUnit}を再定義しています。\hypertarget{classFetchUnit_a5605d4fc727eae9e595325c90c0ec108}{
\index{FetchUnit@{FetchUnit}!ExtMachInst@{ExtMachInst}}
\index{ExtMachInst@{ExtMachInst}!FetchUnit@{FetchUnit}}
\subsubsection[{ExtMachInst}]{\setlength{\rightskip}{0pt plus 5cm}typedef TheISA::ExtMachInst {\bf ExtMachInst}}}
\label{classFetchUnit_a5605d4fc727eae9e595325c90c0ec108}


\subsection{列挙型}
\hypertarget{classFetchUnit_a2afce0a47a93eee73a314d53e4890153}{
\index{FetchUnit@{FetchUnit}!Command@{Command}}
\index{Command@{Command}!FetchUnit@{FetchUnit}}
\subsubsection[{Command}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Command}}}
\label{classFetchUnit_a2afce0a47a93eee73a314d53e4890153}
Actions that this resource can take on an instruction \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{InitiateFetch@{InitiateFetch}!FetchUnit@{FetchUnit}}\index{FetchUnit@{FetchUnit}!InitiateFetch@{InitiateFetch}}\item[{\em 
\hypertarget{classFetchUnit_a2afce0a47a93eee73a314d53e4890153a36b8c84ed26a9bbdd1dd1dd457fda0f4}{
InitiateFetch}
\label{classFetchUnit_a2afce0a47a93eee73a314d53e4890153a36b8c84ed26a9bbdd1dd1dd457fda0f4}
}]\index{CompleteFetch@{CompleteFetch}!FetchUnit@{FetchUnit}}\index{FetchUnit@{FetchUnit}!CompleteFetch@{CompleteFetch}}\item[{\em 
\hypertarget{classFetchUnit_a2afce0a47a93eee73a314d53e4890153aa6cf31a29793ec4c8f38a24da999cdc2}{
CompleteFetch}
\label{classFetchUnit_a2afce0a47a93eee73a314d53e4890153aa6cf31a29793ec4c8f38a24da999cdc2}
}]\end{description}
\end{Desc}



\hyperlink{classCacheUnit_a2afce0a47a93eee73a314d53e4890153}{CacheUnit}を再定義しています。


\begin{DoxyCode}
77                  {
78         InitiateFetch,
79         CompleteFetch
80     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classFetchUnit_a75059c82e769a677cc5e29338234493b}{
\index{FetchUnit@{FetchUnit}!FetchUnit@{FetchUnit}}
\index{FetchUnit@{FetchUnit}!FetchUnit@{FetchUnit}}
\subsubsection[{FetchUnit}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FetchUnit} (std::string {\em res\_\-name}, \/  int {\em res\_\-id}, \/  int {\em res\_\-width}, \/  {\bf Cycles} {\em res\_\-latency}, \/  {\bf InOrderCPU} $\ast$ {\em \_\-cpu}, \/  {\bf ThePipeline::Params} $\ast$ {\em params})}}
\label{classFetchUnit_a75059c82e769a677cc5e29338234493b}
\hypertarget{classFetchUnit_a1c06a50150220d7a3cf7acc6e3161c01}{
\index{FetchUnit@{FetchUnit}!$\sim$FetchUnit@{$\sim$FetchUnit}}
\index{$\sim$FetchUnit@{$\sim$FetchUnit}!FetchUnit@{FetchUnit}}
\subsubsection[{$\sim$FetchUnit}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf FetchUnit} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFetchUnit_a1c06a50150220d7a3cf7acc6e3161c01}



\begin{DoxyCode}
66 {
67     std::list<FetchBlock*>::iterator fetch_it = fetchBuffer.begin();
68     std::list<FetchBlock*>::iterator end_it = fetchBuffer.end();
69     while (fetch_it != end_it) {
70         delete (*fetch_it)->block;
71         delete *fetch_it;
72         fetch_it++;
73     }
74     fetchBuffer.clear();
75 
76 
77     std::list<FetchBlock*>::iterator pend_it = pendingFetch.begin();
78     std::list<FetchBlock*>::iterator pend_end = pendingFetch.end();
79     while (pend_it != pend_end) {
80         if ((*pend_it)->block) {
81             delete (*pend_it)->block;
82         }
83 
84         delete *pend_it;
85         pend_it++;
86     }
87     pendingFetch.clear();
88 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classFetchUnit_a09d558cb19e49cebfa44ecfad6ca98d7}{
\index{FetchUnit@{FetchUnit}!blocksInUse@{blocksInUse}}
\index{blocksInUse@{blocksInUse}!FetchUnit@{FetchUnit}}
\subsubsection[{blocksInUse}]{\setlength{\rightskip}{0pt plus 5cm}int blocksInUse ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFetchUnit_a09d558cb19e49cebfa44ecfad6ca98d7}



\begin{DoxyCode}
216 {
217     std::list<FetchBlock*>::iterator fetch_it = fetchBuffer.begin();
218     std::list<FetchBlock*>::iterator end_it = fetchBuffer.end();
219 
220     int cnt = 0;
221     while (fetch_it != end_it) {
222         if ((*fetch_it)->cnt > 0)
223             cnt++;
224 
225         fetch_it++;
226     }
227 
228     return cnt;
229 }
\end{DoxyCode}
\hypertarget{classFetchUnit_ab36871bdfd10e2b804a650594462b36e}{
\index{FetchUnit@{FetchUnit}!cacheBlockAlignPC@{cacheBlockAlignPC}}
\index{cacheBlockAlignPC@{cacheBlockAlignPC}!FetchUnit@{FetchUnit}}
\subsubsection[{cacheBlockAlignPC}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} cacheBlockAlignPC ({\bf Addr} {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classFetchUnit_ab36871bdfd10e2b804a650594462b36e}
Align a PC to the start of an I-\/cache block. 


\begin{DoxyCode}
111     {
112         return (addr & ~(cacheBlkMask));
113     }
\end{DoxyCode}
\hypertarget{classFetchUnit_a2ccfb855f570dc8e39e9d25d3fb845a3}{
\index{FetchUnit@{FetchUnit}!clearFetchBuffer@{clearFetchBuffer}}
\index{clearFetchBuffer@{clearFetchBuffer}!FetchUnit@{FetchUnit}}
\subsubsection[{clearFetchBuffer}]{\setlength{\rightskip}{0pt plus 5cm}void clearFetchBuffer ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFetchUnit_a2ccfb855f570dc8e39e9d25d3fb845a3}



\begin{DoxyCode}
233 {
234     std::list<FetchBlock*>::iterator fetch_it = fetchBuffer.begin();
235     std::list<FetchBlock*>::iterator end_it = fetchBuffer.end();
236 
237     while (fetch_it != end_it) {
238         if ((*fetch_it)->block) {
239             delete [] (*fetch_it)->block;
240         }
241         delete *fetch_it;
242         fetch_it++;
243     }
244     fetchBuffer.clear();
245 }
\end{DoxyCode}
\hypertarget{classFetchUnit_a38dd226fde9580d1753032305635353f}{
\index{FetchUnit@{FetchUnit}!createMachInst@{createMachInst}}
\index{createMachInst@{createMachInst}!FetchUnit@{FetchUnit}}
\subsubsection[{createMachInst}]{\setlength{\rightskip}{0pt plus 5cm}void createMachInst ({\bf std::list}$<$ {\bf FetchBlock} $\ast$ $>$::iterator {\em fetch\_\-it}, \/  {\bf DynInstPtr} {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFetchUnit_a38dd226fde9580d1753032305635353f}



\begin{DoxyCode}
93 {
94     Addr block_addr = cacheBlockAlign(inst->getMemAddr());
95     Addr fetch_addr = inst->getMemAddr();
96     unsigned fetch_offset = (fetch_addr - block_addr) / instSize;
97     ThreadID tid = inst->readTid();
98     TheISA::PCState instPC = inst->pcState();
99 
100 
101     DPRINTF(InOrderCachePort, "Creating instruction [sn:%i] w/fetch data @"
102             "addr:%08p block:%08p\n", inst->seqNum, fetch_addr, block_addr);
103 
104     assert((*fetch_it)->valid);
105 
106     TheISA::MachInst *fetchInsts =
107         reinterpret_cast<TheISA::MachInst *>((*fetch_it)->block);
108 
109     MachInst mach_inst =
110         TheISA::gtoh(fetchInsts[fetch_offset]);
111 
112     decoder[tid]->moreBytes(instPC, inst->instAddr(), mach_inst);
113     assert(decoder[tid]->instReady());
114     inst->setStaticInst(decoder[tid]->decode(instPC));
115     inst->pcState(instPC);
116 }
\end{DoxyCode}
\hypertarget{classFetchUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{
\index{FetchUnit@{FetchUnit}!execute@{execute}}
\index{execute@{execute}!FetchUnit@{FetchUnit}}
\subsubsection[{execute}]{\setlength{\rightskip}{0pt plus 5cm}void execute (int {\em slot\_\-num})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFetchUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}
Executes one of the commands from the \char`\"{}Command\char`\"{} enum 

\hyperlink{classCacheUnit_a7b7fff82f8c9cbdb02add1346f60bb9e}{CacheUnit}を再定義しています。


\begin{DoxyCode}
249 {
250     CacheReqPtr cache_req = dynamic_cast<CacheReqPtr>(reqs[slot_num]);
251     assert(cache_req);
252 
253     if (cachePortBlocked && cache_req->cmd == InitiateFetch) {
254         DPRINTF(InOrderCachePort, "Cache Port Blocked. Cannot Access\n");
255         cache_req->done(false);
256         return;
257     }
258 
259     DynInstPtr inst = cache_req->inst;
260     ThreadID tid = inst->readTid();
261     Addr block_addr = cacheBlockAlign(inst->getMemAddr());
262     int asid = cpu->asid[tid];
263 
264     if (inst->fault != NoFault) {
265         DPRINTF(InOrderCachePort,
266                 "[tid:%i]: [sn:%i]: Detected %s fault @ %x. Forwarding to "
267                 "next stage.\n", tid, inst->seqNum, inst->fault->name(),
268                 cacheBlockAlign(inst->getMemAddr()));
269         finishCacheUnitReq(inst, cache_req);
270         return;
271     }
272 
273     switch (cache_req->cmd)
274     {
275       case InitiateFetch:
276         {
277             // Check to see if we've already got this request buffered
278             // or pending to be buffered
279             bool do_fetch = true;
280             int total_pending = pendingFetch.size() + blocksInUse();
281 
282             std::list<FetchBlock*>::iterator pending_it;
283             pending_it = findBlock(pendingFetch, asid, block_addr);
284             if (pending_it != pendingFetch.end()) {
285                 (*pending_it)->cnt++;
286                 do_fetch = false;
287 
288                 DPRINTF(InOrderCachePort, "%08p is a pending fetch block "
289                         "(pending:%i).\n", block_addr,
290                         (*pending_it)->cnt);
291             } else if (total_pending < fetchBuffSize) {
292                 std::list<FetchBlock*>::iterator buff_it;
293                 buff_it = findBlock(fetchBuffer, asid, block_addr);
294                 if (buff_it != fetchBuffer.end()) {
295                     (*buff_it)->cnt++;
296                     do_fetch = false;
297 
298                     DPRINTF(InOrderCachePort, "%08p is in fetch buffer "
299                             "(pending:%i).\n", block_addr, (*buff_it)->cnt);
300                 }
301             }
302 
303             if (!do_fetch) {
304                 DPRINTF(InOrderCachePort, "Inst. [sn:%i] marked to be filled "
305                         "through fetch buffer.\n", inst->seqNum);
306                 cache_req->fetchBufferFill = true;
307                 cache_req->setCompleted(true);
308                 return;
309             }
310 
311             // Check to see if there is room in the fetchbuffer for this instruct
      ion.
312             // If not, block this request.
313             if (total_pending >= fetchBuffSize) {
314                 DPRINTF(InOrderCachePort, "No room available in fetch buffer.\n")
      ;
315                 cache_req->done(false);
316                 return;
317             }
318 
319             doTLBAccess(inst, cache_req, cacheBlkSize, Request::INST_FETCH, TheIS
      A::TLB::Execute);
320 
321             if (inst->fault == NoFault) {
322                 DPRINTF(InOrderCachePort,
323                         "[tid:%u]: Initiating fetch access to %s for "
324                         "addr:%#x (block:%#x)\n", tid, name(),
325                         cache_req->inst->getMemAddr(), block_addr);
326 
327                 cache_req->reqData = new uint8_t[cacheBlkSize];
328 
329                 inst->setCurResSlot(slot_num);
330 
331                 doCacheAccess(inst);
332 
333                 if (cache_req->isMemAccPending()) {
334                     pendingFetch.push_back(new FetchBlock(asid, block_addr));
335 
336                     // mark replacement block
337                 }
338             }
339 
340             break;
341         }
342 
343       case CompleteFetch:
344         if (inst->fault != NoFault) {
345             DPRINTF(InOrderCachePort,
346                 "[tid:%i]: [sn:%i]: Detected %s fault @ %x. Forwarding to "
347                 "next stage.\n", tid, inst->seqNum, inst->fault->name(),
348                 inst->getMemAddr());
349             finishCacheUnitReq(inst, cache_req);
350             return;
351         }
352 
353         if (cache_req->fetchBufferFill) {
354             // Block request if it's depending on a previous fetch, but it hasnt 
      made it yet
355             std::list<FetchBlock*>::iterator fetch_it = findBlock(fetchBuffer, as
      id, block_addr);
356             if (fetch_it == fetchBuffer.end()) {
357                 DPRINTF(InOrderCachePort, "%#x not available yet\n",
358                         block_addr);
359                 cache_req->setCompleted(false);
360                 return;
361             }
362 
363             // Make New Instruction
364             createMachInst(fetch_it, inst);
365             if (inst->traceData) {
366                 inst->traceData->setStaticInst(inst->staticInst);
367                 inst->traceData->setPC(inst->pcState());
368             }
369 
370             // FetchBuffer Book-Keeping
371             (*fetch_it)->cnt--;
372             assert((*fetch_it)->cnt >= 0);
373             markBlockUsed(fetch_it);
374 
375             cache_req->done();
376             return;
377         }
378 
379         if (cache_req->isMemAccComplete()) {
380             if (fetchBuffer.size() >= fetchBuffSize) {
381                 // If there is no replacement block, then we'll just have
382                 // to wait till that gets cleared before satisfying the fetch
383                 // for this instruction
384                 std::list<FetchBlock*>::iterator repl_it  =
385                     findReplacementBlock();
386                 if (repl_it == fetchBuffer.end()) {
387                     DPRINTF(InOrderCachePort, "Unable to find replacement block"
388                             " and complete fetch.\n");
389                     cache_req->setCompleted(false);
390                     return;
391                 }
392 
393                 delete [] (*repl_it)->block;
394                 delete *repl_it;
395                 fetchBuffer.erase(repl_it);
396             }
397 
398             DPRINTF(InOrderCachePort,
399                     "[tid:%i]: Completing Fetch Access for [sn:%i]\n",
400                     tid, inst->seqNum);
401 
402             // Make New Instruction
403             std::list<FetchBlock*>::iterator fetch_it  =
404                 findBlock(pendingFetch, asid, block_addr);
405 
406             assert(fetch_it != pendingFetch.end());
407             assert((*fetch_it)->valid);
408 
409             createMachInst(fetch_it, inst);
410             if (inst->traceData) {
411                 inst->traceData->setStaticInst(inst->staticInst);
412                 inst->traceData->setPC(inst->pcState());
413             }
414 
415 
416             // Update instructions waiting on new fetch block
417             FetchBlock *new_block = (*fetch_it);
418             new_block->cnt--;
419             assert(new_block->cnt >= 0);
420 
421             // Finally, update FetchBuffer w/Pending Block into the
422             // MRU location
423             pendingFetch.erase(fetch_it);
424             fetchBuffer.push_back(new_block);
425 
426             DPRINTF(InOrderCachePort, "[tid:%i]: Instruction [sn:%i] is: %s\n",
427                     tid, inst->seqNum,
428                     inst->staticInst->disassemble(inst->instAddr()));
429 
430             inst->unsetMemAddr();
431 
432             cache_req->done();
433         } else {
434             DPRINTF(InOrderCachePort,
435                      "[tid:%i]: [sn:%i]: Unable to Complete Fetch Access\n",
436                     tid, inst->seqNum);
437             DPRINTF(InOrderStall,
438                     "STALL: [tid:%i]: Fetch miss from %08p\n",
439                     tid, cache_req->inst->instAddr());
440             cache_req->setCompleted(false);
441             // NOTE: For SwitchOnCacheMiss ThreadModel, we *don't* switch on
442             //       fetch miss, but we could ...
443             // cache_req->setMemStall(true);
444         }
445         break;
446 
447       default:
448         fatal("Unrecognized command to %s", resName);
449     }
450 }
\end{DoxyCode}
\hypertarget{classFetchUnit_ac92ba32e2d79eb977cc570fc6da90fcd}{
\index{FetchUnit@{FetchUnit}!findBlock@{findBlock}}
\index{findBlock@{findBlock}!FetchUnit@{FetchUnit}}
\subsubsection[{findBlock}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<$ {\bf FetchUnit::FetchBlock} $\ast$ $>$::iterator findBlock ({\bf std::list}$<$ {\bf FetchBlock} $\ast$ $>$ \& {\em fetch\_\-blocks}, \/  int {\em asid}, \/  {\bf Addr} {\em block\_\-addr})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFetchUnit_ac92ba32e2d79eb977cc570fc6da90fcd}



\begin{DoxyCode}
167 {
168     std::list<FetchBlock*>::iterator fetch_it = fetch_blocks.begin();
169     std::list<FetchBlock*>::iterator end_it = fetch_blocks.end();
170 
171     while (fetch_it != end_it) {
172         if ((*fetch_it)->asid == asid &&
173             (*fetch_it)->addr == block_addr) {
174             return fetch_it;
175         }
176 
177         fetch_it++;
178     }
179 
180     return fetch_it;
181 }
\end{DoxyCode}
\hypertarget{classFetchUnit_aa2c07c0c9648d711cd5916edb942dd4f}{
\index{FetchUnit@{FetchUnit}!findReplacementBlock@{findReplacementBlock}}
\index{findReplacementBlock@{findReplacementBlock}!FetchUnit@{FetchUnit}}
\subsubsection[{findReplacementBlock}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<$ {\bf FetchUnit::FetchBlock} $\ast$ $>$::iterator findReplacementBlock ()\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFetchUnit_aa2c07c0c9648d711cd5916edb942dd4f}



\begin{DoxyCode}
185 {
186     std::list<FetchBlock*>::iterator fetch_it = fetchBuffer.begin();
187     std::list<FetchBlock*>::iterator end_it = fetchBuffer.end();
188 
189     while (fetch_it != end_it) {
190         if ((*fetch_it)->cnt == 0) {
191             return fetch_it;
192         } else {
193             DPRINTF(InOrderCachePort, "Block %08p has %i insts pending.\n",
194                     (*fetch_it)->addr, (*fetch_it)->cnt);
195         }
196         fetch_it++;
197     }
198 
199     return fetch_it;
200 }
\end{DoxyCode}
\hypertarget{classFetchUnit_aae5ce84f94a1057d7f60172daf5d731d}{
\index{FetchUnit@{FetchUnit}!getRequest@{getRequest}}
\index{getRequest@{getRequest}!FetchUnit@{FetchUnit}}
\subsubsection[{getRequest}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ResReqPtr} getRequest ({\bf DynInstPtr} {\em \_\-inst}, \/  int {\em stage\_\-num}, \/  int {\em res\_\-idx}, \/  int {\em slot\_\-num}, \/  unsigned {\em cmd})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFetchUnit_aae5ce84f94a1057d7f60172daf5d731d}
\hyperlink{classRequest}{Request} usage of a resource for this instruction. If this instruction already has made this request to this resource, and that request is uncompleted this function will just return that request 

\hyperlink{classCacheUnit_aae5ce84f94a1057d7f60172daf5d731d}{CacheUnit}を再定義しています。


\begin{DoxyCode}
127 {
128     ScheduleEntry* sched_entry = *inst->curSkedEntry;
129     CacheRequest* cache_req = dynamic_cast<CacheRequest*>(reqs[slot_num]);
130 
131     if (!inst->validMemAddr()) {
132         panic("Mem. Addr. must be set before requesting cache access\n");
133     }
134 
135     assert(sched_entry->cmd == InitiateFetch);
136 
137     DPRINTF(InOrderCachePort,
138             "[tid:%i]: Fetch request from [sn:%i] for addr %08p\n",
139             inst->readTid(), inst->seqNum, inst->getMemAddr());
140 
141     cache_req->setRequest(inst, stage_num, id, slot_num,
142                           sched_entry->cmd, MemCmd::ReadReq,
143                           inst->curSkedEntry->idx);
144 
145     return cache_req;
146 }
\end{DoxyCode}
\hypertarget{classFetchUnit_aa7abce4f82cf68e0c338953fb41e3fc8}{
\index{FetchUnit@{FetchUnit}!markBlockUsed@{markBlockUsed}}
\index{markBlockUsed@{markBlockUsed}!FetchUnit@{FetchUnit}}
\subsubsection[{markBlockUsed}]{\setlength{\rightskip}{0pt plus 5cm}void markBlockUsed ({\bf std::list}$<$ {\bf FetchBlock} $\ast$ $>$::iterator {\em block\_\-it})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFetchUnit_aa7abce4f82cf68e0c338953fb41e3fc8}



\begin{DoxyCode}
204 {
205     // Move block from whatever location it is in fetch buffer
206     // to the back (represents most-recently-used location)
207     if (block_it != fetchBuffer.end()) {
208         FetchBlock *mru_blk = *block_it;
209         fetchBuffer.erase(block_it);
210         fetchBuffer.push_back(mru_blk);
211     }
212 }
\end{DoxyCode}
\hypertarget{classFetchUnit_a3dc029c2e87eb911352b82ff15c86236}{
\index{FetchUnit@{FetchUnit}!processCacheCompletion@{processCacheCompletion}}
\index{processCacheCompletion@{processCacheCompletion}!FetchUnit@{FetchUnit}}
\subsubsection[{processCacheCompletion}]{\setlength{\rightskip}{0pt plus 5cm}void processCacheCompletion ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}private, virtual\mbox{]}}}}
\label{classFetchUnit_a3dc029c2e87eb911352b82ff15c86236}
After memory request is completed, then turn the fetched data into an instruction. 

\hyperlink{classCacheUnit_a3dc029c2e87eb911352b82ff15c86236}{CacheUnit}を再定義しています。


\begin{DoxyCode}
454 {
455     // Cast to correct packet type
456     // @todo: use pkt Sender state here to be consistent with other
457     // cpu models
458     CacheReqPacket* cache_pkt = dynamic_cast<CacheReqPacket*>(pkt);
459     assert(cache_pkt);
460 
461     DPRINTF(InOrderCachePort, "Finished request for %x\n",
462             cache_pkt->getAddr());
463 
464     if (processSquash(cache_pkt))
465         return;
466 
467     Addr block_addr = cacheBlockAlign(cache_pkt->cacheReq->
468                                       getInst()->getMemAddr());
469 
470     DPRINTF(InOrderCachePort,
471             "[tid:%u]: [sn:%i]: Waking from fetch access to addr:%#x(phys:%#x), s
      ize:%i\n",
472             cache_pkt->cacheReq->getInst()->readTid(),
473             cache_pkt->cacheReq->getInst()->seqNum,
474             block_addr, cache_pkt->getAddr(), cache_pkt->getSize());
475 
476     // Cast to correct request type
477     CacheRequest *cache_req = dynamic_cast<CacheReqPtr>(
478         findRequest(cache_pkt->cacheReq->getInst(), cache_pkt->instIdx));
479 
480     if (!cache_req) {
481         panic("[tid:%u]: [sn:%i]: Can't find slot for fetch access to "
482               "addr. %08p\n", cache_pkt->cacheReq->getInst()->readTid(),
483               cache_pkt->cacheReq->getInst()->seqNum,
484               block_addr);
485     }
486 
487     // Get resource request info
488     unsigned stage_num = cache_req->getStageNum();
489     DynInstPtr inst = cache_req->inst;
490     ThreadID tid = cache_req->inst->readTid();
491     short asid = cpu->asid[tid];
492 
493     assert(!cache_req->isSquashed());
494     assert(inst->curSkedEntry->cmd == CompleteFetch);
495 
496     DPRINTF(InOrderCachePort,
497             "[tid:%u]: [sn:%i]: Processing fetch access for block %#x\n",
498             tid, inst->seqNum, block_addr);
499 
500     std::list<FetchBlock*>::iterator pend_it = findBlock(pendingFetch, asid,
501                                                          block_addr);
502     assert(pend_it != pendingFetch.end());
503 
504     // Copy Data to pendingFetch queue...
505     (*pend_it)->block = new uint8_t[cacheBlkSize];
506     memcpy((*pend_it)->block, cache_pkt->getPtr<uint8_t>(), cacheBlkSize);
507     (*pend_it)->valid = true;
508 
509     cache_req->setMemAccPending(false);
510     cache_req->setMemAccCompleted();
511 
512     if (cache_req->isMemStall() &&
513         cpu->threadModel == InOrderCPU::SwitchOnCacheMiss) {
514         DPRINTF(InOrderCachePort, "[tid:%u] Waking up from Cache Miss.\n",
515                 tid);
516 
517         cpu->activateContext(tid);
518 
519         DPRINTF(ThreadModel, "Activating [tid:%i] after return from cache"
520                 "miss.\n", tid);
521     }
522 
523     // Wake up the CPU (if it went to sleep and was waiting on this
524     // completion event).
525     cpu->wakeCPU();
526 
527     DPRINTF(Activity, "[tid:%u] Activating %s due to cache completion\n",
528             tid, cpu->pipelineStage[stage_num]->name());
529 
530     cpu->switchToActive(stage_num);
531 }
\end{DoxyCode}
\hypertarget{classFetchUnit_a8a894d91761439227fd27d91a318c31f}{
\index{FetchUnit@{FetchUnit}!removeAddrDependency@{removeAddrDependency}}
\index{removeAddrDependency@{removeAddrDependency}!FetchUnit@{FetchUnit}}
\subsubsection[{removeAddrDependency}]{\setlength{\rightskip}{0pt plus 5cm}void removeAddrDependency ({\bf DynInstPtr} {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}private, virtual\mbox{]}}}}
\label{classFetchUnit_a8a894d91761439227fd27d91a318c31f}


\hyperlink{classCacheUnit_a8a894d91761439227fd27d91a318c31f}{CacheUnit}を再定義しています。


\begin{DoxyCode}
120 {
121     inst->unsetMemAddr();
122 }
\end{DoxyCode}
\hypertarget{classFetchUnit_aa942d730ea26d41b72db771cc951f51e}{
\index{FetchUnit@{FetchUnit}!setupMemRequest@{setupMemRequest}}
\index{setupMemRequest@{setupMemRequest}!FetchUnit@{FetchUnit}}
\subsubsection[{setupMemRequest}]{\setlength{\rightskip}{0pt plus 5cm}void setupMemRequest ({\bf DynInstPtr} {\em inst}, \/  {\bf CacheReqPtr} {\em cache\_\-req}, \/  int {\em acc\_\-size}, \/  int {\em flags})\hspace{0.3cm}{\ttfamily  \mbox{[}private, virtual\mbox{]}}}}
\label{classFetchUnit_aa942d730ea26d41b72db771cc951f51e}
Create request that will interface w/TLB and Memory objects 

\hyperlink{classCacheUnit_aa942d730ea26d41b72db771cc951f51e}{CacheUnit}を再定義しています。


\begin{DoxyCode}
151 {
152     ThreadID tid = inst->readTid();
153     Addr aligned_addr = cacheBlockAlign(inst->getMemAddr());
154     if (cache_req->memReq == NULL) {
155         cache_req->memReq =
156             new Request(tid, aligned_addr, acc_size, flags,
157                         cpu->instMasterId(), inst->instAddr(), cpu->readCpuId(),
158                         tid);
159         DPRINTF(InOrderCachePort, "[sn:%i] Created memReq @%x, ->%x\n",
160                 inst->seqNum, &cache_req->memReq, cache_req->memReq);
161     }
162 }
\end{DoxyCode}
\hypertarget{classFetchUnit_ac2831520eb121be08811b040992f416b}{
\index{FetchUnit@{FetchUnit}!squashCacheRequest@{squashCacheRequest}}
\index{squashCacheRequest@{squashCacheRequest}!FetchUnit@{FetchUnit}}
\subsubsection[{squashCacheRequest}]{\setlength{\rightskip}{0pt plus 5cm}void squashCacheRequest ({\bf CacheReqPtr} {\em req\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}private, virtual\mbox{]}}}}
\label{classFetchUnit_ac2831520eb121be08811b040992f416b}


\hyperlink{classCacheUnit_ac2831520eb121be08811b040992f416b}{CacheUnit}を再定義しています。


\begin{DoxyCode}
535 {
536     DynInstPtr inst = req_ptr->getInst();
537     ThreadID tid = inst->readTid();
538     Addr block_addr = cacheBlockAlign(inst->getMemAddr());
539     int asid = cpu->asid[tid];
540 
541     // Check Fetch Buffer (or pending fetch) for this block and
542     // update pending counts
543     std::list<FetchBlock*>::iterator buff_it = findBlock(fetchBuffer,
544                                                          asid,
545                                                          block_addr);
546     if (buff_it != fetchBuffer.end()) {
547         (*buff_it)->cnt--;
548         DPRINTF(InOrderCachePort, "[sn:%i] Removing Pending Access "
549                 "for Fetch Buffer block %08p (cnt=%i)\n", inst->seqNum,
550                 block_addr, (*buff_it)->cnt);
551         assert((*buff_it)->cnt >= 0);
552     } else {
553         std::list<FetchBlock*>::iterator block_it = findBlock(pendingFetch,
554                                                               asid,
555                                                               block_addr);
556         if (block_it != pendingFetch.end()) {
557             (*block_it)->cnt--;
558             DPRINTF(InOrderCachePort, "[sn:%i] Removing Pending Access "
559                     "for Pending Buffer Block %08p (cnt=%i)\n",
560                     inst->seqNum,
561                     block_addr, (*block_it)->cnt);
562             assert((*block_it)->cnt >= 0);
563             if ((*block_it)->cnt == 0) {
564                 if ((*block_it)->block) {
565                     delete [] (*block_it)->block;
566                 }
567                 delete *block_it;
568                 pendingFetch.erase(block_it);
569             }
570         }
571     }
572 
573     CacheUnit::squashCacheRequest(req_ptr);
574 }
\end{DoxyCode}
\hypertarget{classFetchUnit_abf76d6d245f7d3b17d26ea8dcc0cf36f}{
\index{FetchUnit@{FetchUnit}!trap@{trap}}
\index{trap@{trap}!FetchUnit@{FetchUnit}}
\subsubsection[{trap}]{\setlength{\rightskip}{0pt plus 5cm}void trap ({\bf Fault} {\em fault}, \/  {\bf ThreadID} {\em tid}, \/  {\bf DynInstPtr} {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFetchUnit_abf76d6d245f7d3b17d26ea8dcc0cf36f}
Post-\/processsing for Trap Generated from this instruction 

\hyperlink{classCacheUnit_abf76d6d245f7d3b17d26ea8dcc0cf36f}{CacheUnit}を再定義しています。


\begin{DoxyCode}
578 {
579     //@todo: per thread?
580     decoder[tid]->reset();
581 
582     //@todo: squash using dummy inst seq num
583     squash(NULL, NumStages - 1, 0, tid);
584 
585     //@todo: make sure no blocks are in use
586     assert(blocksInUse() == 0);
587     assert(pendingFetch.size() == 0);
588 
589     //@todo: clear pendingFetch and fetchBuffer
590     clearFetchBuffer();
591 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classFetchUnit_a5f15f1b871b77f550632262df3bce5f1}{
\index{FetchUnit@{FetchUnit}!decoder@{decoder}}
\index{decoder@{decoder}!FetchUnit@{FetchUnit}}
\subsubsection[{decoder}]{\setlength{\rightskip}{0pt plus 5cm}TheISA::Decoder$\ast$ {\bf decoder}\mbox{[}{\bf ThePipeline::MaxThreads}\mbox{]}}}
\label{classFetchUnit_a5f15f1b871b77f550632262df3bce5f1}
\hypertarget{classFetchUnit_ab201075a98e275240766bee54144d42d}{
\index{FetchUnit@{FetchUnit}!fetchBuffer@{fetchBuffer}}
\index{fetchBuffer@{fetchBuffer}!FetchUnit@{FetchUnit}}
\subsubsection[{fetchBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf FetchBlock}$\ast$$>$ {\bf fetchBuffer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFetchUnit_ab201075a98e275240766bee54144d42d}
Valid \hyperlink{classCache}{Cache} Blocks \hypertarget{classFetchUnit_a97e2b6a8af0f5cb34f9d266a9ac21a48}{
\index{FetchUnit@{FetchUnit}!fetchBuffSize@{fetchBuffSize}}
\index{fetchBuffSize@{fetchBuffSize}!FetchUnit@{FetchUnit}}
\subsubsection[{fetchBuffSize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf fetchBuffSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFetchUnit_a97e2b6a8af0f5cb34f9d266a9ac21a48}
\hypertarget{classFetchUnit_a494a9a986bc62c946604f9e9047ad237}{
\index{FetchUnit@{FetchUnit}!instSize@{instSize}}
\index{instSize@{instSize}!FetchUnit@{FetchUnit}}
\subsubsection[{instSize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf instSize}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFetchUnit_a494a9a986bc62c946604f9e9047ad237}
\hypertarget{classFetchUnit_af2a77ef8e6fe01c93bcac28b1152e44b}{
\index{FetchUnit@{FetchUnit}!pendingFetch@{pendingFetch}}
\index{pendingFetch@{pendingFetch}!FetchUnit@{FetchUnit}}
\subsubsection[{pendingFetch}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf FetchBlock}$\ast$$>$ {\bf pendingFetch}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classFetchUnit_af2a77ef8e6fe01c93bcac28b1152e44b}
\hyperlink{classCache}{Cache} lines that are pending 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/inorder/resources/\hyperlink{fetch__unit_8hh}{fetch\_\-unit.hh}\item 
cpu/inorder/resources/\hyperlink{fetch__unit_8cc}{fetch\_\-unit.cc}\end{DoxyCompactItemize}
