\hypertarget{classInstBuffer}{
\section{クラス InstBuffer}
\label{classInstBuffer}\index{InstBuffer@{InstBuffer}}
}


{\ttfamily \#include $<$inst\_\-buffer.hh$>$}InstBufferに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classInstBuffer}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classInstBuffer_a2afce0a47a93eee73a314d53e4890153}{Command} \{ \par
\hyperlink{classInstBuffer_a2afce0a47a93eee73a314d53e4890153a9923cb8ed2504b9ad0ef7d8c098de927}{InsertInst}, 
\hyperlink{classInstBuffer_a2afce0a47a93eee73a314d53e4890153a479d267bb3346d48813042a220b9bf33}{InsertAddr}, 
\hyperlink{classInstBuffer_a2afce0a47a93eee73a314d53e4890153af554d4e266ed08f9ba5b04e52ecf54b1}{RemoveInst}, 
\hyperlink{classInstBuffer_a2afce0a47a93eee73a314d53e4890153a1ab75403b8653ee6fa0ff346e37763c4}{RemoveAddr}, 
\par
\hyperlink{classInstBuffer_a2afce0a47a93eee73a314d53e4890153a828036f61bf534c1970ea8bc390c096a}{ScheduleOrBypass}
 \}
\item 
typedef \hyperlink{classRefCountingPtr}{ThePipeline::DynInstPtr} \hyperlink{classInstBuffer_af9d0c8a46736ba6aa2d8bb94da1a5e73}{DynInstPtr}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classInstBuffer_aed5f553acf1f60008e3cc5575617b8db}{InstBuffer} (std::string res\_\-name, int res\_\-id, int res\_\-width, \hyperlink{classCycles}{Cycles} res\_\-latency, \hyperlink{classInOrderCPU}{InOrderCPU} $\ast$\_\-cpu, \hyperlink{namespaceThePipeline_ab62ca16eeca26566ad2422b5df4943ce}{ThePipeline::Params} $\ast$params)
\item 
void \hyperlink{classInstBuffer_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
void \hyperlink{classInstBuffer_a7b7fff82f8c9cbdb02add1346f60bb9e}{execute} (int slot\_\-num)
\item 
void \hyperlink{classInstBuffer_ae55039f80e321715cf410a62b39d069c}{insert} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
void \hyperlink{classInstBuffer_a21558187a079b60fba92c9c66725f051}{remove} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst)
\item 
void \hyperlink{classInstBuffer_af6dbebba7f0784a65a148c6f06f7106d}{pop} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
\hyperlink{classRefCountingPtr}{DynInstPtr} \hyperlink{classInstBuffer_a636fc68dd4880da2b94630b1978a6e85}{top} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classInstBuffer_a52235c5e3d912452f254dc45f1496fd2}{squash} (\hyperlink{classRefCountingPtr}{DynInstPtr} inst, int stage\_\-num, \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} squash\_\-seq\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classInstBuffer_af6881f44f674fa9f704b80ee1d0bdd17}{instsBypassed}
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classRefCountingPtr}{DynInstPtr} $>$ \hyperlink{classInstBuffer_ae10a391d02ce1ef67ee13cd82b7d46e5}{instList}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classInstBuffer_af9d0c8a46736ba6aa2d8bb94da1a5e73}{
\index{InstBuffer@{InstBuffer}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!InstBuffer@{InstBuffer}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf ThePipeline::DynInstPtr} {\bf DynInstPtr}}}
\label{classInstBuffer_af9d0c8a46736ba6aa2d8bb94da1a5e73}


\hyperlink{classResource_af9d0c8a46736ba6aa2d8bb94da1a5e73}{Resource}を再定義しています。

\subsection{列挙型}
\hypertarget{classInstBuffer_a2afce0a47a93eee73a314d53e4890153}{
\index{InstBuffer@{InstBuffer}!Command@{Command}}
\index{Command@{Command}!InstBuffer@{InstBuffer}}
\subsubsection[{Command}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Command}}}
\label{classInstBuffer_a2afce0a47a93eee73a314d53e4890153}
\begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{InsertInst@{InsertInst}!InstBuffer@{InstBuffer}}\index{InstBuffer@{InstBuffer}!InsertInst@{InsertInst}}\item[{\em 
\hypertarget{classInstBuffer_a2afce0a47a93eee73a314d53e4890153a9923cb8ed2504b9ad0ef7d8c098de927}{
InsertInst}
\label{classInstBuffer_a2afce0a47a93eee73a314d53e4890153a9923cb8ed2504b9ad0ef7d8c098de927}
}]\index{InsertAddr@{InsertAddr}!InstBuffer@{InstBuffer}}\index{InstBuffer@{InstBuffer}!InsertAddr@{InsertAddr}}\item[{\em 
\hypertarget{classInstBuffer_a2afce0a47a93eee73a314d53e4890153a479d267bb3346d48813042a220b9bf33}{
InsertAddr}
\label{classInstBuffer_a2afce0a47a93eee73a314d53e4890153a479d267bb3346d48813042a220b9bf33}
}]\index{RemoveInst@{RemoveInst}!InstBuffer@{InstBuffer}}\index{InstBuffer@{InstBuffer}!RemoveInst@{RemoveInst}}\item[{\em 
\hypertarget{classInstBuffer_a2afce0a47a93eee73a314d53e4890153af554d4e266ed08f9ba5b04e52ecf54b1}{
RemoveInst}
\label{classInstBuffer_a2afce0a47a93eee73a314d53e4890153af554d4e266ed08f9ba5b04e52ecf54b1}
}]\index{RemoveAddr@{RemoveAddr}!InstBuffer@{InstBuffer}}\index{InstBuffer@{InstBuffer}!RemoveAddr@{RemoveAddr}}\item[{\em 
\hypertarget{classInstBuffer_a2afce0a47a93eee73a314d53e4890153a1ab75403b8653ee6fa0ff346e37763c4}{
RemoveAddr}
\label{classInstBuffer_a2afce0a47a93eee73a314d53e4890153a1ab75403b8653ee6fa0ff346e37763c4}
}]\index{ScheduleOrBypass@{ScheduleOrBypass}!InstBuffer@{InstBuffer}}\index{InstBuffer@{InstBuffer}!ScheduleOrBypass@{ScheduleOrBypass}}\item[{\em 
\hypertarget{classInstBuffer_a2afce0a47a93eee73a314d53e4890153a828036f61bf534c1970ea8bc390c096a}{
ScheduleOrBypass}
\label{classInstBuffer_a2afce0a47a93eee73a314d53e4890153a828036f61bf534c1970ea8bc390c096a}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
49                  {
50         InsertInst,
51         InsertAddr,
52         RemoveInst,
53         RemoveAddr,
54         ScheduleOrBypass
55     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classInstBuffer_aed5f553acf1f60008e3cc5575617b8db}{
\index{InstBuffer@{InstBuffer}!InstBuffer@{InstBuffer}}
\index{InstBuffer@{InstBuffer}!InstBuffer@{InstBuffer}}
\subsubsection[{InstBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstBuffer} (std::string {\em res\_\-name}, \/  int {\em res\_\-id}, \/  int {\em res\_\-width}, \/  {\bf Cycles} {\em res\_\-latency}, \/  {\bf InOrderCPU} $\ast$ {\em \_\-cpu}, \/  {\bf ThePipeline::Params} $\ast$ {\em params})}}
\label{classInstBuffer_aed5f553acf1f60008e3cc5575617b8db}


\subsection{関数}
\hypertarget{classInstBuffer_a7b7fff82f8c9cbdb02add1346f60bb9e}{
\index{InstBuffer@{InstBuffer}!execute@{execute}}
\index{execute@{execute}!InstBuffer@{InstBuffer}}
\subsubsection[{execute}]{\setlength{\rightskip}{0pt plus 5cm}void execute (int {\em slot\_\-idx})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classInstBuffer_a7b7fff82f8c9cbdb02add1346f60bb9e}
Execute the function of this resource. The Default is action is to do nothing. More specific models will derive from this class and define their own execute function. 

\hyperlink{classResource_a39af49c5568d1db3f53c12d7d6914c32}{Resource}を再定義しています。


\begin{DoxyCode}
66 {
67     ResReqPtr ib_req = reqs[slot_idx];
68     DynInstPtr inst = ib_req->inst;
69     ThreadID tid = inst->readTid();
70     int stage_num = ib_req->getStageNum();
71 
72     switch (ib_req->cmd)
73     {
74       case ScheduleOrBypass:
75         {
76             int next_stage = stage_num + 1;
77             int bypass_stage = stage_num + 2;
78             bool do_bypass = true;
79 
80             if (!instList.empty()) {
81                 DPRINTF(InOrderInstBuffer, "[sn:%i] cannot bypass stage %i "
82                         "because buffer isn't empty.\n",
83                         inst->seqNum, next_stage);
84                 do_bypass = false;
85             } else if(cpu->pipelineStage[bypass_stage]->isBlocked(tid)) {
86                 DPRINTF(InOrderInstBuffer, "[sn:%i] cannot bypass stage %i "
87                         "because stage %i is blocking.\n",
88                         inst->seqNum, next_stage);
89                 do_bypass = false;
90             } else if(cpu->pipelineStage[bypass_stage]->
91                       stageBufferAvail() <= 0) {
92                 DPRINTF(InOrderInstBuffer, "[sn:%i] cannot bypass stage %i "
93                         "because there is no room in stage %i incoming stage "
94                         "buffer.\n", inst->seqNum, next_stage);
95                 do_bypass = false;
96             }
97 
98             if (!do_bypass) { // SCHEDULE USAGE OF BUFFER
99                 DPRINTF(InOrderInstBuffer, "Scheduling [sn:%i] for buffer "
100                         "insertion in stage %i\n",
101                         inst->seqNum, next_stage);
102 
103                 // Add to schedule: Insert into buffer in next stage
104                 int stage_pri = 20;
105                 RSkedPtr insert_sked = (stage_num >= 
      ThePipeline::BackEndStartStage) ?
106                     inst->backSked : inst->frontSked;
107 
108                 insert_sked->push(new ScheduleEntry(next_stage,
109                                                       stage_pri,
110                                                       id,
111                                                       InstBuffer::InsertInst));
112 
113                 // Add to schedule: Remove from buffer in next next (bypass)
114                 // stage
115                 stage_pri = 20;
116                 RSkedPtr bypass_sked = (stage_num >= 
      ThePipeline::BackEndStartStage) ?
117                     inst->backSked : inst->frontSked;
118 
119                bypass_sked->push(new ScheduleEntry(bypass_stage,
120                                                       stage_pri,
121                                                       id,
122                                                       InstBuffer::RemoveInst));
123             } else {         // BYPASS BUFFER & NEXT STAGE
124                 DPRINTF(InOrderInstBuffer, "Setting [sn:%i] to bypass stage "
125                         "%i and enter stage %i.\n", inst->seqNum, next_stage,
126                         bypass_stage);
127                 inst->setNextStage(bypass_stage);
128                 instsBypassed++;
129             }
130 
131             ib_req->done();
132         }
133         break;
134 
135       case InsertInst:
136         {
137             bool inserted = false;
138 
139             if (instList.size() < width) {
140                 DPRINTF(InOrderInstBuffer, "[tid:%i]: Inserting [sn:%i] into "
141                         "buffer.\n", tid, inst->seqNum);
142                 insert(inst);
143                 inserted = true;
144             } else {
145                 DPRINTF(InOrderInstBuffer, "[tid:%i]: Denying [sn:%i] request "
146                         "because buffer is full.\n", tid, inst->seqNum);
147 
148 
149                 std::list<DynInstPtr>::iterator list_it = instList.begin();
150                 std::list<DynInstPtr>::iterator list_end = instList.end();
151 
152                 while (list_it != list_end) {
153                     DPRINTF(Resource,"Serving [tid:%i] [sn:%i].\n",
154                             (*list_it)->readTid(), (*list_it)->seqNum);
155                     list_it++;
156                 }
157             }
158 
159             ib_req->done(inserted);
160         }
161         break;
162 
163       case RemoveInst:
164         {
165             DPRINTF(InOrderInstBuffer, "[tid:%i]: Removing [sn:%i] from "
166                     "buffer.\n", tid, inst->seqNum);
167             remove(inst);
168             ib_req->done();
169         }
170         break;
171 
172       default:
173         fatal("Unrecognized command to %s", resName);
174     }
175 
176     DPRINTF(InOrderInstBuffer, "Buffer now contains %i insts.\n",
177             instList.size());
178 }
\end{DoxyCode}
\hypertarget{classInstBuffer_ae55039f80e321715cf410a62b39d069c}{
\index{InstBuffer@{InstBuffer}!insert@{insert}}
\index{insert@{insert}!InstBuffer@{InstBuffer}}
\subsubsection[{insert}]{\setlength{\rightskip}{0pt plus 5cm}void insert ({\bf DynInstPtr} {\em inst})}}
\label{classInstBuffer_ae55039f80e321715cf410a62b39d069c}



\begin{DoxyCode}
182 {
183     instList.push_back(inst);
184 }
\end{DoxyCode}
\hypertarget{classInstBuffer_af6dbebba7f0784a65a148c6f06f7106d}{
\index{InstBuffer@{InstBuffer}!pop@{pop}}
\index{pop@{pop}!InstBuffer@{InstBuffer}}
\subsubsection[{pop}]{\setlength{\rightskip}{0pt plus 5cm}void pop ({\bf ThreadID} {\em tid})}}
\label{classInstBuffer_af6dbebba7f0784a65a148c6f06f7106d}



\begin{DoxyCode}
203 {
204     instList.pop_front();
205 }
\end{DoxyCode}
\hypertarget{classInstBuffer_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{InstBuffer@{InstBuffer}!regStats@{regStats}}
\index{regStats@{regStats}!InstBuffer@{InstBuffer}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classInstBuffer_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} \hyperlink{namespaceStats}{Stats} for this resource 

\hyperlink{classResource_ac1739a9be0fbd5d96cf441cd3b2c1c78}{Resource}を再定義しています。


\begin{DoxyCode}
55 {
56     instsBypassed
57         .name(name() + ".instsBypassed")
58         .desc("Number of Instructions Bypassed.")
59         .prereq(instsBypassed);    
60 
61     Resource::regStats();
62 }
\end{DoxyCode}
\hypertarget{classInstBuffer_a21558187a079b60fba92c9c66725f051}{
\index{InstBuffer@{InstBuffer}!remove@{remove}}
\index{remove@{remove}!InstBuffer@{InstBuffer}}
\subsubsection[{remove}]{\setlength{\rightskip}{0pt plus 5cm}void remove ({\bf DynInstPtr} {\em inst})}}
\label{classInstBuffer_a21558187a079b60fba92c9c66725f051}



\begin{DoxyCode}
188 {
189     std::list<DynInstPtr>::iterator list_it = instList.begin();
190     std::list<DynInstPtr>::iterator list_end = instList.end();
191 
192     while (list_it != list_end) {
193         if((*list_it) == inst) {
194             instList.erase(list_it);
195             break;
196         }
197         list_it++;
198     }
199 }
\end{DoxyCode}
\hypertarget{classInstBuffer_a52235c5e3d912452f254dc45f1496fd2}{
\index{InstBuffer@{InstBuffer}!squash@{squash}}
\index{squash@{squash}!InstBuffer@{InstBuffer}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash ({\bf DynInstPtr} {\em inst}, \/  int {\em stage\_\-num}, \/  {\bf InstSeqNum} {\em squash\_\-seq\_\-num}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classInstBuffer_a52235c5e3d912452f254dc45f1496fd2}
Squash All Requests After This Seq Num 

\hyperlink{classResource_a52235c5e3d912452f254dc45f1496fd2}{Resource}を再定義しています。


\begin{DoxyCode}
216 {
217     queue<list<DynInstPtr>::iterator> remove_list;
218     list<DynInstPtr>::iterator list_it = instList.begin();
219     list<DynInstPtr>::iterator list_end = instList.end();
220 
221     // Collect All Instructions to be Removed in Remove List
222     while (list_it != list_end) {
223         if((*list_it)->readTid() == tid &&
224            (*list_it)->seqNum > squash_seq_num) {
225             (*list_it)->setSquashed();
226             remove_list.push(list_it);
227         }
228 
229         list_it++;
230     }
231 
232     // Removed Instructions from InstList & Clear Remove List
233     while (!remove_list.empty()) {
234         DPRINTF(InOrderInstBuffer, "[tid:%i]: Removing squashed [sn:%i] from "
235                 "buffer.\n", tid, (*remove_list.front())->seqNum);
236         instList.erase(remove_list.front());
237         remove_list.pop();
238     }
239 
240     Resource::squash(inst, stage_num, squash_seq_num, tid);
241 }
\end{DoxyCode}
\hypertarget{classInstBuffer_a636fc68dd4880da2b94630b1978a6e85}{
\index{InstBuffer@{InstBuffer}!top@{top}}
\index{top@{top}!InstBuffer@{InstBuffer}}
\subsubsection[{top}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThePipeline::DynInstPtr} top ({\bf ThreadID} {\em tid})}}
\label{classInstBuffer_a636fc68dd4880da2b94630b1978a6e85}



\begin{DoxyCode}
209 {
210     return instList.front();
211 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classInstBuffer_ae10a391d02ce1ef67ee13cd82b7d46e5}{
\index{InstBuffer@{InstBuffer}!instList@{instList}}
\index{instList@{instList}!InstBuffer@{InstBuffer}}
\subsubsection[{instList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf instList}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classInstBuffer_ae10a391d02ce1ef67ee13cd82b7d46e5}
List of instructions this resource is currently processing. \hypertarget{classInstBuffer_af6881f44f674fa9f704b80ee1d0bdd17}{
\index{InstBuffer@{InstBuffer}!instsBypassed@{instsBypassed}}
\index{instsBypassed@{instsBypassed}!InstBuffer@{InstBuffer}}
\subsubsection[{instsBypassed}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf instsBypassed}}}
\label{classInstBuffer_af6881f44f674fa9f704b80ee1d0bdd17}
Number of Instruction Requests the \hyperlink{classResource}{Resource} Processes 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/inorder/resources/\hyperlink{inst__buffer_8hh}{inst\_\-buffer.hh}\item 
cpu/inorder/resources/\hyperlink{inst__buffer_8cc}{inst\_\-buffer.cc}\end{DoxyCompactItemize}
