\hypertarget{classSystem}{
\section{クラス System}
\label{classSystem}\index{System@{System}}
}


{\ttfamily \#include $<$system.hh$>$}Systemに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4cm]{classSystem}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classSystem_1_1MemoryMode}{MemoryMode}
\item 
class \hyperlink{classSystem_1_1System}{System}
\item 
class \hyperlink{classSystem_1_1SystemPort}{SystemPort}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef SystemParams \hyperlink{classSystem_a5f461be6222ce76bffcb70f27d820c56}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classSystem_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
\hyperlink{classMasterPort}{MasterPort} \& \hyperlink{classSystem_ac19ed7d066a1932ab5b2309af9af350c}{getSystemPort} ()
\item 
\hyperlink{classBaseMasterPort}{BaseMasterPort} \& \hyperlink{classSystem_adc4e675e51defbdd1e354dac729d0703}{getMasterPort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
unsigned int \hyperlink{classSystem_ac1f842b56d922c001dda5262b4cccbc6}{cacheLineSize} () const 
\item 
\hyperlink{classThreadContext}{ThreadContext} $\ast$ \hyperlink{classSystem_af349994bde91bd82c98f31e10c495cd1}{getThreadContext} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
int \hyperlink{classSystem_a905b96f2c022dcde596bdb806661bcae}{numContexts} ()
\item 
int \hyperlink{classSystem_af17f73eb71dfedfb91e4f39e7bb732ce}{numRunningContexts} ()
\item 
uint64\_\-t \hyperlink{classSystem_a402028e3641447d7638e44c37190c7e3}{allocatePID} ()
\item 
\hyperlink{classPhysicalMemory}{PhysicalMemory} \& \hyperlink{classSystem_af828d179222e0a3764213c270bfa4097}{getPhysMem} ()
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classSystem_a1c6da3f76011beef47b9bb74c1a0ec19}{freeMemSize} () const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classSystem_a21f1f1db9f5cb71e5e24790fbac5f30f}{memSize} () const 
\item 
bool \hyperlink{classSystem_a0faeadf06436f8123c7bda01087bb222}{isMemAddr} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr) const 
\item 
\hyperlink{request_8hh_ac366b729262fd8e7cbd3283da6f775cf}{MasterID} \hyperlink{classSystem_a906e073613d8d8e76e11c1bf9310a25c}{getMasterId} (std::string req\_\-name)
\item 
std::string \hyperlink{classSystem_a810ce26f2e58138568d11cf179d6e89d}{getMasterName} (\hyperlink{request_8hh_ac366b729262fd8e7cbd3283da6f775cf}{MasterID} master\_\-id)
\item 
\hyperlink{request_8hh_ac366b729262fd8e7cbd3283da6f775cf}{MasterID} \hyperlink{classSystem_a4cd916c36458ce47e9ba4ccbfc75a095}{maxMasters} ()
\item 
virtual void \hyperlink{classSystem_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\item 
uint64\_\-t \hyperlink{classSystem_a3820060901c04aa2e536f374113a1daf}{incWorkItemsBegin} ()
\item 
uint64\_\-t \hyperlink{classSystem_a46800c998630f686bcdea38091fab11d}{incWorkItemsEnd} ()
\item 
int \hyperlink{classSystem_ae49314d8f9b44248e8b0577e5cdd0338}{markWorkItem} (int index)
\item 
void \hyperlink{classSystem_ad4b75de1d7e8c59fae68c3d0c1aa10d0}{workItemBegin} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} tid, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} workid)
\item 
void \hyperlink{classSystem_a5a8ccc590b04e540dab229b302e29c88}{workItemEnd} (\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} tid, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} workid)
\item 
virtual \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classSystem_aff94f650c5eef23b8dc350ea755bdef4}{fixFuncEventAddr} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr)
\item 
bool \hyperlink{classSystem_ae59ed2201db88c0668ca26040f6a3ad0}{breakpoint} ()
\item 
\hyperlink{classSystem_a0b8704078300e9b3cd65559df0ac79ab}{System} (\hyperlink{classSystem_a5f461be6222ce76bffcb70f27d820c56}{Params} $\ast$p)
\item 
\hyperlink{classSystem_a3bfbca0e3ddd7ea1f8709c986454d753}{$\sim$System} ()
\item 
void \hyperlink{classSystem_a3c34ea9b29f410748d4435a667484924}{initState} ()
\item 
const \hyperlink{classSystem_a5f461be6222ce76bffcb70f27d820c56}{Params} $\ast$ \hyperlink{classSystem_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classSystem_a5e068cbb27ba6c95ea26869f88964845}{getKernelStart} () const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classSystem_ab1fd157e4287a41711d83b7a48161c2b}{getKernelEnd} () const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classSystem_a21bc77f01980debea40a75c23c9a7ae8}{getKernelEntry} () const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classSystem_ab816e894891a147b8ba762d89f46c902}{allocPhysPages} (int npages)
\item 
int \hyperlink{classSystem_a7211419d4d2d396946880da898f5dbbf}{registerThreadContext} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc, int assigned=-\/1)
\item 
void \hyperlink{classSystem_ab2e74da826f1a39705880c80002f52fd}{replaceThreadContext} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc, int context\_\-id)
\item 
void \hyperlink{classSystem_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
void \hyperlink{classSystem_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\item 
unsigned int \hyperlink{classSystem_aa8a18d230dba7a674ac8a0b4f35bc36a}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)
\item 
void \hyperlink{classSystem_a8f020d3237536fe007fc488c4125c5d8}{drainResume} ()
\end{DoxyCompactItemize}
\begin{Indent}{\bf }\par
{\em \label{_amgrpd41d8cd98f00b204e9800998ecf8427e}
 }\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classSystem_a6685592df58820e9bb30d94908c9881a}{isAtomicMode} () const 
\item 
bool \hyperlink{classSystem_ae04bdd25f4dde1cc1b58b22505aa869c}{isTimingMode} () const 
\item 
bool \hyperlink{classSystem_a613d9d917b0e950cd322026de403d702}{bypassCaches} () const 
\item 
Enums::MemoryMode \hyperlink{classSystem_a1a43e0888d498acd3b15fcbd678998d6}{getMemoryMode} () const 
\item 
void \hyperlink{classSystem_ae0c4408279fbea962460bccd251cffe5}{setMemoryMode} (Enums::MemoryMode mode)
\item 
{\footnotesize template$<$class T , typename... Args$>$ }\\T $\ast$ \hyperlink{classSystem_a35e24b9d75d9b23f195b383672965a24}{addFuncEvent} (const \hyperlink{classSymbolTable}{SymbolTable} $\ast$symtab, const char $\ast$lbl, const std::string \&desc, Args...args)
\item 
{\footnotesize template$<$class T $>$ }\\T $\ast$ \hyperlink{classSystem_a651f66880621119f2d0ab293788c01c4}{addFuncEvent} (const \hyperlink{classSymbolTable}{SymbolTable} $\ast$symtab, const char $\ast$lbl)
\item 
{\footnotesize template$<$class T , typename... Args$>$ }\\T $\ast$ \hyperlink{classSystem_a299ade3c625c503681f9b0f7a3812075}{addFuncEventOrPanic} (const \hyperlink{classSymbolTable}{SymbolTable} $\ast$symtab, const char $\ast$lbl, Args...args)
\item 
{\footnotesize template$<$class T , typename... Args$>$ }\\T $\ast$ \hyperlink{classSystem_a87294b0dc6aa3e647f45e44a064269fb}{addKernelFuncEvent} (const char $\ast$lbl, Args...args)
\item 
{\footnotesize template$<$class T , typename... Args$>$ }\\T $\ast$ \hyperlink{classSystem_a627f7dd0edc7fbe7567d4c2a1bf340c4}{addKernelFuncEventOrPanic} (const char $\ast$lbl, Args...args)
\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Static Public メソッド}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{classSystem_a55206d1ab112cc51ccc3bbefdcc5b923}{printSystems} ()
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classThreadContext}{ThreadContext} $\ast$ $>$ \hyperlink{classSystem_a19840a204c4d6f67b45a07073e8b41df}{threadContexts}
\item 
int \hyperlink{classSystem_a13d38579137b1a8b8a2fcfdd501f8d4a}{\_\-numContexts}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classSystem_aeeee662e637858aeeb38ca8b84a115cb}{pagePtr}
\item 
uint64\_\-t \hyperlink{classSystem_aebfcbf904f5dc098c119f45063661dce}{init\_\-param}
\item 
\hyperlink{classPortProxy}{PortProxy} \hyperlink{classSystem_a6219b40ecb92ec67602ae32c1ae2c0d6}{physProxy}
\item 
\hyperlink{classSymbolTable}{SymbolTable} $\ast$ \hyperlink{classSystem_a579bef006c1d6148c2764355c0b039b7}{kernelSymtab}
\item 
\hyperlink{classObjectFile}{ObjectFile} $\ast$ \hyperlink{classSystem_ab5c2cc90b7ed9b57e9d9c6ce42a5200b}{kernel}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classSystem_ab7de1b59ae9f13ebe06ee0fdaf262505}{kernelStart}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classSystem_ab50e277f319055cb4e9d05e09e314b4a}{kernelEnd}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classSystem_aa4fb57a8e8cf6890a99606f31841c74f}{kernelEntry}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classSystem_a49e011922eb3cd15a03e61e206bf02d3}{loadAddrMask}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classSystem_a23e95dade560d359d40e4e98456279ad}{loadAddrOffset}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classBaseRemoteGDB}{BaseRemoteGDB} $\ast$ $>$ \hyperlink{classSystem_a0bb92fde095f717f1a9709fa16825091}{remoteGDB}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classGDBListener}{GDBListener} $\ast$ $>$ \hyperlink{classSystem_a258d0d6139d48d76bf8bdda04f6e2ef8}{gdbListen}
\item 
\hyperlink{base_2types_8hh_ae1475755791765b8e6f6a8bb091e273e}{Counter} \hyperlink{classSystem_ac59cc9ac6419c90b7add2f0dff8babc9}{totalNumInsts}
\item 
\hyperlink{classEventQueue}{EventQueue} \hyperlink{classSystem_a05694f19dc768ad2378b58790c870f61}{instEventQueue}
\item 
std::map$<$ \hyperlink{classstd_1_1pair}{std::pair}$<$ \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t}, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} $>$, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} $>$ \hyperlink{classSystem_a465e763cb54f007726f9b8c35e6638b3}{lastWorkItemStarted}
\item 
std::map$<$ \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t}, \hyperlink{classStats_1_1Histogram}{Stats::Histogram} $\ast$ $>$ \hyperlink{classSystem_a55a97611b6d940c8f1a15c49293ab7c7}{workItemStats}
\item 
std::map$<$ uint64\_\-t, \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classThreadContext}{ThreadContext} $\ast$ $>$ $\ast$ $>$ \hyperlink{classSystem_a0c17191d1d61a14d28a4d2ecd11beeff}{futexMap}
\end{DoxyCompactItemize}
\subsection*{Static Public 変数}
\begin{DoxyCompactItemize}
\item 
static const char $\ast$ \hyperlink{classSystem_a166de98735762528d9fd0d7cbd0ff5db}{MemoryModeStrings} \mbox{[}4\mbox{]}
\item 
static \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classSystem_1_1System}{System} $\ast$ $>$ \hyperlink{classSystem_a2ccf318c5f6beb8a1697389782c1f2bf}{systemList}
\item 
static int \hyperlink{classSystem_a1adea9b3072c7e8d2d045b275c8e37e7}{numSystemsRunning} = 0
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classSystem_a4a6e514fbf1ef35f9a914680884cedef}{serializeSymtab} (std::ostream \&os)
\item 
virtual void \hyperlink{classSystem_a3536a2e47acf307ec65515712f0e2b2d}{unserializeSymtab} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
uint64\_\-t \hyperlink{classSystem_a940df2387a1775c99f43e7e189a8c0fa}{nextPID}
\item 
\hyperlink{classPhysicalMemory}{PhysicalMemory} \hyperlink{classSystem_aefd0d5534ce05a7596afe30efe297ad8}{physmem}
\item 
Enums::MemoryMode \hyperlink{classSystem_a22abae1a5557f96f7fc5a0ef3c660141}{memoryMode}
\item 
const unsigned int \hyperlink{classSystem_a6e1b97389f603fc046fbb42ba91136e2}{\_\-cacheLineSize}
\item 
uint64\_\-t \hyperlink{classSystem_a479aaf1a4cb34f2bbdd533b4fb8ef412}{workItemsBegin}
\item 
uint64\_\-t \hyperlink{classSystem_a94de121bcd10e5fae1e1aadd6b4ab41b}{workItemsEnd}
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classSystem_a582d58a54a49964f2967b70bcd29f89d}{numWorkIds}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ bool $>$ \hyperlink{classSystem_adaa0501d61f40b707ee3add7379386fe}{activeCpus}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ std::string $>$ \hyperlink{classSystem_af29dc1c2c4242f28c6934043af159765}{masterIds}
\item 
\hyperlink{classSystem_a5f461be6222ce76bffcb70f27d820c56}{Params} $\ast$ \hyperlink{classSystem_afb9ae78c3e2cd51a280162491c99366c}{\_\-params}
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSystem_1_1SystemPort}{SystemPort} \hyperlink{classSystem_acc373b3a30590f0a6b23b470f85c07b0}{\_\-systemPort}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classSystem_a5f461be6222ce76bffcb70f27d820c56}{
\index{System@{System}!Params@{Params}}
\index{Params@{Params}!System@{System}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef SystemParams {\bf Params}}}
\label{classSystem_a5f461be6222ce76bffcb70f27d820c56}


\hyperlink{classMemObject_a905bbc621eeec0ed08859e21c8c95412}{MemObject}を再定義しています。

\hyperlink{classFreebsdAlphaSystem_a0cee38b7e957f9f434ee078d80b94d1b}{FreebsdAlphaSystem}, \hyperlink{classLinuxAlphaSystem_a0d8e2379ed014b6039c45eb98c24fed4}{LinuxAlphaSystem}, \hyperlink{classAlphaSystem_a2af24d7a564ee2ca81332fb46406cbe5}{AlphaSystem}, \hyperlink{classTru64AlphaSystem_a653e3d38e55079cc093cc4945c1ac3d1}{Tru64AlphaSystem}, \hyperlink{classLinuxArmSystem_ae0ebf28024a7bb607cc65e59c8faa9d5}{LinuxArmSystem}, \hyperlink{classArmSystem_a8ae84e66b34bac08937a6bad4412ba5d}{ArmSystem}, \hyperlink{classLinuxMipsSystem_a3d1083cbefc15728ca643470f9efbf13}{LinuxMipsSystem}, \hyperlink{classMipsSystem_acf01be080284e8262bc1ff41fbd1710c}{MipsSystem}, \hyperlink{classMipsSystem_acf01be080284e8262bc1ff41fbd1710c}{MipsSystem}, \hyperlink{classSparcSystem_ad1d7d4179ae16224e8ae3360e3e676b8}{SparcSystem}, \hyperlink{classLinuxX86System_a9a9d4fd080ddd5d649f7db5e47cfae8b}{LinuxX86System}, と \hyperlink{classX86System_a4f3142e3ba81ac1e14e960636ad3202b}{X86System}で再定義されています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classSystem_a0b8704078300e9b3cd65559df0ac79ab}{
\index{System@{System}!System@{System}}
\index{System@{System}!System@{System}}
\subsubsection[{System}]{\setlength{\rightskip}{0pt plus 5cm}{\bf System} ({\bf Params} $\ast$ {\em p})}}
\label{classSystem_a0b8704078300e9b3cd65559df0ac79ab}



\begin{DoxyCode}
76     : MemObject(p), _systemPort("system_port", this),
77       _numContexts(0),
78       pagePtr(0),
79       init_param(p->init_param),
80       physProxy(_systemPort, p->cache_line_size),
81       loadAddrMask(p->load_addr_mask),
82       loadAddrOffset(p->load_offset),
83       nextPID(0),
84       physmem(name() + ".physmem", p->memories),
85       memoryMode(p->mem_mode),
86       _cacheLineSize(p->cache_line_size),
87       workItemsBegin(0),
88       workItemsEnd(0),
89       numWorkIds(p->num_work_ids),
90       _params(p),
91       totalNumInsts(0),
92       instEventQueue("system instruction-based event queue")
93 {
94     // add self to global system list
95     systemList.push_back(this);
96 
97     if (FullSystem) {
98         kernelSymtab = new SymbolTable;
99         if (!debugSymbolTable)
100             debugSymbolTable = new SymbolTable;
101     }
102 
103     // check if the cache line size is a value known to work
104     if (!(_cacheLineSize == 16 || _cacheLineSize == 32 ||
105           _cacheLineSize == 64 || _cacheLineSize == 128))
106         warn_once("Cache line size is neither 16, 32, 64 nor 128 bytes.\n");
107 
108     // Get the generic system master IDs
109     MasterID tmp_id M5_VAR_USED;
110     tmp_id = getMasterId("writebacks");
111     assert(tmp_id == Request::wbMasterId);
112     tmp_id = getMasterId("functional");
113     assert(tmp_id == Request::funcMasterId);
114     tmp_id = getMasterId("interrupt");
115     assert(tmp_id == Request::intMasterId);
116 
117     if (FullSystem) {
118         if (params()->kernel == "") {
119             inform("No kernel set for full system simulation. "
120                    "Assuming you know what you're doing\n");
121 
122             kernel = NULL;
123         } else {
124             // Get the kernel code
125             kernel = createObjectFile(params()->kernel);
126             inform("kernel located at: %s", params()->kernel);
127 
128             if (kernel == NULL)
129                 fatal("Could not load kernel file %s", params()->kernel);
130 
131             // setup entry points
132             kernelStart = kernel->textBase();
133             kernelEnd = kernel->bssBase() + kernel->bssSize();
134             kernelEntry = kernel->entryPoint();
135 
136             // load symbols
137             if (!kernel->loadGlobalSymbols(kernelSymtab))
138                 fatal("could not load kernel symbols\n");
139 
140             if (!kernel->loadLocalSymbols(kernelSymtab))
141                 fatal("could not load kernel local symbols\n");
142 
143             if (!kernel->loadGlobalSymbols(debugSymbolTable))
144                 fatal("could not load kernel symbols\n");
145 
146             if (!kernel->loadLocalSymbols(debugSymbolTable))
147                 fatal("could not load kernel local symbols\n");
148 
149             // Loading only needs to happen once and after memory system is
150             // connected so it will happen in initState()
151         }
152     }
153 
154     // increment the number of running systms
155     numSystemsRunning++;
156 
157     // Set back pointers to the system in all memories
158     for (int x = 0; x < params()->memories.size(); x++)
159         params()->memories[x]->system(this);
160 }
\end{DoxyCode}
\hypertarget{classSystem_a3bfbca0e3ddd7ea1f8709c986454d753}{
\index{System@{System}!$\sim$System@{$\sim$System}}
\index{$\sim$System@{$\sim$System}!System@{System}}
\subsubsection[{$\sim$System}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf System} ()}}
\label{classSystem_a3bfbca0e3ddd7ea1f8709c986454d753}



\begin{DoxyCode}
163 {
164     delete kernelSymtab;
165     delete kernel;
166 
167     for (uint32_t j = 0; j < numWorkIds; j++)
168         delete workItemStats[j];
169 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classSystem_a651f66880621119f2d0ab293788c01c4}{
\index{System@{System}!addFuncEvent@{addFuncEvent}}
\index{addFuncEvent@{addFuncEvent}!System@{System}}
\subsubsection[{addFuncEvent}]{\setlength{\rightskip}{0pt plus 5cm}T$\ast$ addFuncEvent (const {\bf SymbolTable} $\ast$ {\em symtab}, \/  const char $\ast$ {\em lbl})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_a651f66880621119f2d0ab293788c01c4}



\begin{DoxyCode}
405     {
406         return addFuncEvent<T>(symtab, lbl, lbl);
407     }
\end{DoxyCode}
\hypertarget{classSystem_a35e24b9d75d9b23f195b383672965a24}{
\index{System@{System}!addFuncEvent@{addFuncEvent}}
\index{addFuncEvent@{addFuncEvent}!System@{System}}
\subsubsection[{addFuncEvent}]{\setlength{\rightskip}{0pt plus 5cm}T$\ast$ addFuncEvent (const {\bf SymbolTable} $\ast$ {\em symtab}, \/  const char $\ast$ {\em lbl}, \/  const std::string \& {\em desc}, \/  Args... {\em args})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_a35e24b9d75d9b23f195b383672965a24}
Add a function-\/based event to the given function, to be looked up in the specified symbol table.

The ...OrPanic flavor of the method causes the simulator to panic if the symbol can't be found.


\begin{DoxyParams}{引数}
\item[{\em symtab}]Symbol table to use for look up. \item[{\em lbl}]Function to hook the event to. \item[{\em desc}]Description to be passed to the event. \item[{\em args}]\hyperlink{classArguments}{Arguments} to be forwarded to the event constructor. \end{DoxyParams}



\begin{DoxyCode}
389     {
390         Addr addr M5_VAR_USED = 0; // initialize only to avoid compiler warning
391 
392 #if THE_ISA != NULL_ISA
393         if (symtab->findAddress(lbl, addr)) {
394             T *ev = new T(&pcEventQueue, desc, fixFuncEventAddr(addr),
395                           std::forward<Args>(args)...);
396             return ev;
397         }
398 #endif
399 
400         return NULL;
401     }
\end{DoxyCode}
\hypertarget{classSystem_a299ade3c625c503681f9b0f7a3812075}{
\index{System@{System}!addFuncEventOrPanic@{addFuncEventOrPanic}}
\index{addFuncEventOrPanic@{addFuncEventOrPanic}!System@{System}}
\subsubsection[{addFuncEventOrPanic}]{\setlength{\rightskip}{0pt plus 5cm}T$\ast$ addFuncEventOrPanic (const {\bf SymbolTable} $\ast$ {\em symtab}, \/  const char $\ast$ {\em lbl}, \/  Args... {\em args})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_a299ade3c625c503681f9b0f7a3812075}



\begin{DoxyCode}
412     {
413         T *e(addFuncEvent<T>(symtab, lbl, std::forward<Args>(args)...));
414         if (!e)
415             panic("Failed to find symbol '%s'", lbl);
416         return e;
417     }
\end{DoxyCode}
\hypertarget{classSystem_a87294b0dc6aa3e647f45e44a064269fb}{
\index{System@{System}!addKernelFuncEvent@{addKernelFuncEvent}}
\index{addKernelFuncEvent@{addKernelFuncEvent}!System@{System}}
\subsubsection[{addKernelFuncEvent}]{\setlength{\rightskip}{0pt plus 5cm}T$\ast$ addKernelFuncEvent (const char $\ast$ {\em lbl}, \/  Args... {\em args})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_a87294b0dc6aa3e647f45e44a064269fb}
Add a function-\/based event to a kernel symbol.

These functions work like their \hyperlink{classSystem_a35e24b9d75d9b23f195b383672965a24}{addFuncEvent()} and \hyperlink{classSystem_a299ade3c625c503681f9b0f7a3812075}{addFuncEventOrPanic()} counterparts. The only difference is that they automatically use the kernel symbol table. All arguments are forwarded to the underlying method.

\begin{DoxySeeAlso}{参照}
\hyperlink{classSystem_a35e24b9d75d9b23f195b383672965a24}{addFuncEvent()} 

\hyperlink{classSystem_a299ade3c625c503681f9b0f7a3812075}{addFuncEventOrPanic()}
\end{DoxySeeAlso}

\begin{DoxyParams}{引数}
\item[{\em lbl}]Function to hook the event to. \item[{\em args}]\hyperlink{classArguments}{Arguments} to be passed to addFuncEvent \end{DoxyParams}



\begin{DoxyCode}
437     {
438         return addFuncEvent<T>(kernelSymtab, lbl,
439                                std::forward<Args>(args)...);
440     }
\end{DoxyCode}
\hypertarget{classSystem_a627f7dd0edc7fbe7567d4c2a1bf340c4}{
\index{System@{System}!addKernelFuncEventOrPanic@{addKernelFuncEventOrPanic}}
\index{addKernelFuncEventOrPanic@{addKernelFuncEventOrPanic}!System@{System}}
\subsubsection[{addKernelFuncEventOrPanic}]{\setlength{\rightskip}{0pt plus 5cm}T$\ast$ addKernelFuncEventOrPanic (const char $\ast$ {\em lbl}, \/  Args... {\em args})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_a627f7dd0edc7fbe7567d4c2a1bf340c4}



\begin{DoxyCode}
444     {
445         T *e(addFuncEvent<T>(kernelSymtab, lbl,
446                              std::forward<Args>(args)...));
447         if (!e)
448             panic("Failed to find kernel symbol '%s'", lbl);
449         return e;
450     }
\end{DoxyCode}
\hypertarget{classSystem_a402028e3641447d7638e44c37190c7e3}{
\index{System@{System}!allocatePID@{allocatePID}}
\index{allocatePID@{allocatePID}!System@{System}}
\subsubsection[{allocatePID}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t allocatePID ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_a402028e3641447d7638e44c37190c7e3}



\begin{DoxyCode}
252     {
253         return nextPID++;
254     }
\end{DoxyCode}
\hypertarget{classSystem_ab816e894891a147b8ba762d89f46c902}{
\index{System@{System}!allocPhysPages@{allocPhysPages}}
\index{allocPhysPages@{allocPhysPages}!System@{System}}
\subsubsection[{allocPhysPages}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} allocPhysPages (int {\em npages})}}
\label{classSystem_ab816e894891a147b8ba762d89f46c902}
Allocate npages contiguous unused physical pages \begin{DoxyReturn}{戻り値}
Starting address of first page 
\end{DoxyReturn}



\begin{DoxyCode}
313 {
314     Addr return_addr = pagePtr << LogVMPageSize;
315     pagePtr += npages;
316     if ((pagePtr << LogVMPageSize) > physmem.totalSize())
317         fatal("Out of memory, please increase size of physical memory.");
318     return return_addr;
319 }
\end{DoxyCode}
\hypertarget{classSystem_ae59ed2201db88c0668ca26040f6a3ad0}{
\index{System@{System}!breakpoint@{breakpoint}}
\index{breakpoint@{breakpoint}!System@{System}}
\subsubsection[{breakpoint}]{\setlength{\rightskip}{0pt plus 5cm}bool breakpoint ()}}
\label{classSystem_ae59ed2201db88c0668ca26040f6a3ad0}


\hyperlink{classMipsSystem_ae59ed2201db88c0668ca26040f6a3ad0}{MipsSystem}, と \hyperlink{classMipsSystem_aa9fdfc3926a9047bc0fb3d7b13030064}{MipsSystem}で再定義されています。


\begin{DoxyCode}
194 {
195     if (remoteGDB.size())
196         return remoteGDB[0]->breakpoint();
197     return false;
198 }
\end{DoxyCode}
\hypertarget{classSystem_a613d9d917b0e950cd322026de403d702}{
\index{System@{System}!bypassCaches@{bypassCaches}}
\index{bypassCaches@{bypassCaches}!System@{System}}
\subsubsection[{bypassCaches}]{\setlength{\rightskip}{0pt plus 5cm}bool bypassCaches () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_a613d9d917b0e950cd322026de403d702}
Should caches be bypassed?

Some CPUs need to bypass caches to allow direct memory accesses, which is required for hardware virtualization. 


\begin{DoxyCode}
157                               {
158         return memoryMode == Enums::atomic_noncaching;
159     }
\end{DoxyCode}
\hypertarget{classSystem_ac1f842b56d922c001dda5262b4cccbc6}{
\index{System@{System}!cacheLineSize@{cacheLineSize}}
\index{cacheLineSize@{cacheLineSize}!System@{System}}
\subsubsection[{cacheLineSize}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int cacheLineSize () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_ac1f842b56d922c001dda5262b4cccbc6}
Get the cache line size of the system. 


\begin{DoxyCode}
185 { return _cacheLineSize; }
\end{DoxyCode}
\hypertarget{classSystem_aa8a18d230dba7a674ac8a0b4f35bc36a}{
\index{System@{System}!drain@{drain}}
\index{drain@{drain}!System@{System}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int drain ({\bf DrainManager} $\ast$ {\em drainManger})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSystem_aa8a18d230dba7a674ac8a0b4f35bc36a}
Provide a default implementation of the drain interface that simply returns 0 (draining completed) and sets the drain state to Drained. 

\hyperlink{classSimObject_a6bf479c521c7c3eb473822d953275b26}{SimObject}を再定義しています。


\begin{DoxyCode}
341 {
342     setDrainState(Drainable::Drained);
343     return 0;
344 }
\end{DoxyCode}
\hypertarget{classSystem_a8f020d3237536fe007fc488c4125c5d8}{
\index{System@{System}!drainResume@{drainResume}}
\index{drainResume@{drainResume}!System@{System}}
\subsubsection[{drainResume}]{\setlength{\rightskip}{0pt plus 5cm}void drainResume ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSystem_a8f020d3237536fe007fc488c4125c5d8}
Resume execution after a successful drain.

\begin{DoxyNote}{覚え書き}
This method is normally only called from the simulation scripts. 
\end{DoxyNote}


\hyperlink{classDrainable_a8f020d3237536fe007fc488c4125c5d8}{Drainable}を再定義しています。


\begin{DoxyCode}
348 {
349     Drainable::drainResume();
350     totalNumInsts = 0;
351 }
\end{DoxyCode}
\hypertarget{classSystem_aff94f650c5eef23b8dc350ea755bdef4}{
\index{System@{System}!fixFuncEventAddr@{fixFuncEventAddr}}
\index{fixFuncEventAddr@{fixFuncEventAddr}!System@{System}}
\subsubsection[{fixFuncEventAddr}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Addr} fixFuncEventAddr ({\bf Addr} {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classSystem_aff94f650c5eef23b8dc350ea755bdef4}
Fix up an address used to match PCs for hooking simulator events on to target function executions. See comment in system.cc for details. 

\hyperlink{classAlphaSystem_ac72b76fe05499c31c7091ec5a56c0d52}{AlphaSystem}, \hyperlink{classArmSystem_aff94f650c5eef23b8dc350ea755bdef4}{ArmSystem}, \hyperlink{classMipsSystem_ac72b76fe05499c31c7091ec5a56c0d52}{MipsSystem}, \hyperlink{classMipsSystem_aff94f650c5eef23b8dc350ea755bdef4}{MipsSystem}, \hyperlink{classSparcSystem_aff94f650c5eef23b8dc350ea755bdef4}{SparcSystem}, と \hyperlink{classX86System_aff94f650c5eef23b8dc350ea755bdef4}{X86System}で再定義されています。


\begin{DoxyCode}
369     {
370         panic("Base fixFuncEventAddr not implemented.\n");
371     }
\end{DoxyCode}
\hypertarget{classSystem_a1c6da3f76011beef47b9bb74c1a0ec19}{
\index{System@{System}!freeMemSize@{freeMemSize}}
\index{freeMemSize@{freeMemSize}!System@{System}}
\subsubsection[{freeMemSize}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} freeMemSize () const}}
\label{classSystem_a1c6da3f76011beef47b9bb74c1a0ec19}
Amount of physical memory that is still free 


\begin{DoxyCode}
329 {
330    return physmem.totalSize() - (pagePtr << LogVMPageSize);
331 }
\end{DoxyCode}
\hypertarget{classSystem_ab1fd157e4287a41711d83b7a48161c2b}{
\index{System@{System}!getKernelEnd@{getKernelEnd}}
\index{getKernelEnd@{getKernelEnd}!System@{System}}
\subsubsection[{getKernelEnd}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} getKernelEnd () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_ab1fd157e4287a41711d83b7a48161c2b}
Returns the addess the kernel ends at. \begin{DoxyReturn}{戻り値}
address the kernel ends at 
\end{DoxyReturn}



\begin{DoxyCode}
484 { return kernelEnd; }
\end{DoxyCode}
\hypertarget{classSystem_a21bc77f01980debea40a75c23c9a7ae8}{
\index{System@{System}!getKernelEntry@{getKernelEntry}}
\index{getKernelEntry@{getKernelEntry}!System@{System}}
\subsubsection[{getKernelEntry}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} getKernelEntry () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_a21bc77f01980debea40a75c23c9a7ae8}
Returns the addess the entry point to the kernel code. \begin{DoxyReturn}{戻り値}
entry point of the kernel code 
\end{DoxyReturn}



\begin{DoxyCode}
490 { return kernelEntry; }
\end{DoxyCode}
\hypertarget{classSystem_a5e068cbb27ba6c95ea26869f88964845}{
\index{System@{System}!getKernelStart@{getKernelStart}}
\index{getKernelStart@{getKernelStart}!System@{System}}
\subsubsection[{getKernelStart}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} getKernelStart () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_a5e068cbb27ba6c95ea26869f88964845}
Returns the addess the kernel starts at. \begin{DoxyReturn}{戻り値}
address the kernel starts at 
\end{DoxyReturn}



\begin{DoxyCode}
478 { return kernelStart; }
\end{DoxyCode}
\hypertarget{classSystem_a906e073613d8d8e76e11c1bf9310a25c}{
\index{System@{System}!getMasterId@{getMasterId}}
\index{getMasterId@{getMasterId}!System@{System}}
\subsubsection[{getMasterId}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterID} getMasterId (std::string {\em req\_\-name})}}
\label{classSystem_a906e073613d8d8e76e11c1bf9310a25c}
\hyperlink{classRequest}{Request} an id used to create a request object in the system. All objects that intend to issues requests into the memory system must request an id in the \hyperlink{classSystem_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} phase of startup. All master ids must be fixed by the \hyperlink{classSystem_a4dc637449366fcdfc4e764cdf12d9b11}{regStats()} phase that immediately preceeds it. This allows objects in the memory system to understand how many masters may exist and appropriately name the bins of their per-\/master stats before the stats are finalized 


\begin{DoxyCode}
431 {
432     // strip off system name if the string starts with it
433     if (startswith(master_name, name()))
434         master_name = master_name.erase(0, name().size() + 1);
435 
436     // CPUs in switch_cpus ask for ids again after switching
437     for (int i = 0; i < masterIds.size(); i++) {
438         if (masterIds[i] == master_name) {
439             return i;
440         }
441     }
442 
443     // Verify that the statistics haven't been enabled yet
444     // Otherwise objects will have sized their stat buckets and
445     // they will be too small
446 
447     if (Stats::enabled())
448         fatal("Can't request a masterId after regStats(). \
449                 You must do so in init().\n");
450 
451     masterIds.push_back(master_name);
452 
453     return masterIds.size() - 1;
454 }
\end{DoxyCode}
\hypertarget{classSystem_a810ce26f2e58138568d11cf179d6e89d}{
\index{System@{System}!getMasterName@{getMasterName}}
\index{getMasterName@{getMasterName}!System@{System}}
\subsubsection[{getMasterName}]{\setlength{\rightskip}{0pt plus 5cm}std::string getMasterName ({\bf MasterID} {\em master\_\-id})}}
\label{classSystem_a810ce26f2e58138568d11cf179d6e89d}
Get the name of an object for a given request id. 


\begin{DoxyCode}
458 {
459     if (master_id >= masterIds.size())
460         fatal("Invalid master_id passed to getMasterName()\n");
461 
462     return masterIds[master_id];
463 }
\end{DoxyCode}
\hypertarget{classSystem_adc4e675e51defbdd1e354dac729d0703}{
\index{System@{System}!getMasterPort@{getMasterPort}}
\index{getMasterPort@{getMasterPort}!System@{System}}
\subsubsection[{getMasterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseMasterPort} \& getMasterPort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSystem_adc4e675e51defbdd1e354dac729d0703}
Additional function to return the \hyperlink{classPort}{Port} of a memory object. 

\hyperlink{classMemObject_adc4e675e51defbdd1e354dac729d0703}{MemObject}を再定義しています。


\begin{DoxyCode}
181 {
182     // no need to distinguish at the moment (besides checking)
183     return _systemPort;
184 }
\end{DoxyCode}
\hypertarget{classSystem_a1a43e0888d498acd3b15fcbd678998d6}{
\index{System@{System}!getMemoryMode@{getMemoryMode}}
\index{getMemoryMode@{getMemoryMode}!System@{System}}
\subsubsection[{getMemoryMode}]{\setlength{\rightskip}{0pt plus 5cm}Enums::MemoryMode getMemoryMode () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_a1a43e0888d498acd3b15fcbd678998d6}
Get the memory mode of the system.

This should only be used by the Python world. The C++ world should use one of the query functions above (\hyperlink{classSystem_a6685592df58820e9bb30d94908c9881a}{isAtomicMode()}, \hyperlink{classSystem_ae04bdd25f4dde1cc1b58b22505aa869c}{isTimingMode()}, \hyperlink{classSystem_a613d9d917b0e950cd322026de403d702}{bypassCaches()}). 


\begin{DoxyCode}
170 { return memoryMode; }
\end{DoxyCode}
\hypertarget{classSystem_af828d179222e0a3764213c270bfa4097}{
\index{System@{System}!getPhysMem@{getPhysMem}}
\index{getPhysMem@{getPhysMem}!System@{System}}
\subsubsection[{getPhysMem}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PhysicalMemory}\& getPhysMem ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_af828d179222e0a3764213c270bfa4097}
Get a pointer to access the physical memory of the system 


\begin{DoxyCode}
257 { return physmem; }
\end{DoxyCode}
\hypertarget{classSystem_ac19ed7d066a1932ab5b2309af9af350c}{
\index{System@{System}!getSystemPort@{getSystemPort}}
\index{getSystemPort@{getSystemPort}!System@{System}}
\subsubsection[{getSystemPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterPort}\& getSystemPort ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_ac19ed7d066a1932ab5b2309af9af350c}
Get a reference to the system port that can be used by non-\/structural simulation objects like processes or threads, or external entities like loaders and debuggers, etc, to access the memory system.

\begin{DoxyReturn}{戻り値}
a reference to the system port we own 
\end{DoxyReturn}



\begin{DoxyCode}
116 { return _systemPort; }
\end{DoxyCode}
\hypertarget{classSystem_af349994bde91bd82c98f31e10c495cd1}{
\index{System@{System}!getThreadContext@{getThreadContext}}
\index{getThreadContext@{getThreadContext}!System@{System}}
\subsubsection[{getThreadContext}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadContext}$\ast$ getThreadContext ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_af349994bde91bd82c98f31e10c495cd1}



\begin{DoxyCode}
195     {
196         return threadContexts[tid];
197     }
\end{DoxyCode}
\hypertarget{classSystem_a3820060901c04aa2e536f374113a1daf}{
\index{System@{System}!incWorkItemsBegin@{incWorkItemsBegin}}
\index{incWorkItemsBegin@{incWorkItemsBegin}!System@{System}}
\subsubsection[{incWorkItemsBegin}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t incWorkItemsBegin ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_a3820060901c04aa2e536f374113a1daf}
Called by pseudo\_\-inst to track the number of work items started by this system. 


\begin{DoxyCode}
323     {
324         return ++workItemsBegin;
325     }
\end{DoxyCode}
\hypertarget{classSystem_a46800c998630f686bcdea38091fab11d}{
\index{System@{System}!incWorkItemsEnd@{incWorkItemsEnd}}
\index{incWorkItemsEnd@{incWorkItemsEnd}!System@{System}}
\subsubsection[{incWorkItemsEnd}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t incWorkItemsEnd ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_a46800c998630f686bcdea38091fab11d}
Called by pseudo\_\-inst to track the number of work items completed by this system. 


\begin{DoxyCode}
333     {
334         return ++workItemsEnd;
335     }
\end{DoxyCode}
\hypertarget{classSystem_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{System@{System}!init@{init}}
\index{init@{init}!System@{System}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSystem_a02fd73d861ef2e4aabb38c0c9ff82947}
After all objects have been created and all ports are connected, check that the system port is connected. 

\hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{SimObject}を再定義しています。


\begin{DoxyCode}
173 {
174     // check that the system port is connected
175     if (!_systemPort.isConnected())
176         panic("System port on %s is not connected.\n", name());
177 }
\end{DoxyCode}
\hypertarget{classSystem_a3c34ea9b29f410748d4435a667484924}{
\index{System@{System}!initState@{initState}}
\index{initState@{initState}!System@{System}}
\subsubsection[{initState}]{\setlength{\rightskip}{0pt plus 5cm}void initState ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSystem_a3c34ea9b29f410748d4435a667484924}
\hyperlink{classSystem_a3c34ea9b29f410748d4435a667484924}{initState()} is called on each \hyperlink{classSimObject}{SimObject} when $\ast$not$\ast$ restoring from a checkpoint. This provides a hook for state initializations that are only required for a \char`\"{}cold start\char`\"{}. 

Load the kernel code into memory

\hyperlink{classSimObject_a3c34ea9b29f410748d4435a667484924}{SimObject}を再定義しています。

\hyperlink{classLinuxAlphaSystem_a3c34ea9b29f410748d4435a667484924}{LinuxAlphaSystem}, \hyperlink{classAlphaSystem_a3c34ea9b29f410748d4435a667484924}{AlphaSystem}, \hyperlink{classLinuxArmSystem_a3c34ea9b29f410748d4435a667484924}{LinuxArmSystem}, \hyperlink{classArmSystem_a3c34ea9b29f410748d4435a667484924}{ArmSystem}, \hyperlink{classSparcSystem_a3c34ea9b29f410748d4435a667484924}{SparcSystem}, \hyperlink{classLinuxX86System_a3c34ea9b29f410748d4435a667484924}{LinuxX86System}, と \hyperlink{classX86System_a3c34ea9b29f410748d4435a667484924}{X86System}で再定義されています。


\begin{DoxyCode}
267 {
268     if (FullSystem) {
269         for (int i = 0; i < threadContexts.size(); i++)
270             TheISA::startupCPU(threadContexts[i], i);
271         // Moved from the constructor to here since it relies on the
272         // address map being resolved in the interconnect
276         if (params()->kernel != "")  {
277             // Validate kernel mapping before loading binary
278             if (!(isMemAddr((kernelStart & loadAddrMask) + loadAddrOffset) &&
279                      isMemAddr((kernelEnd & loadAddrMask) + loadAddrOffset))) {
280                 fatal("Kernel is mapped to invalid location (not memory). "
281                       "kernelStart 0x(%x) - kernelEnd 0x(%x) %#x:%#x\n", 
      kernelStart,
282                       kernelEnd, (kernelStart & loadAddrMask) + loadAddrOffset,
283                       (kernelEnd & loadAddrMask) + loadAddrOffset);
284             }
285             // Load program sections into memory
286             kernel->loadSections(physProxy, loadAddrMask, loadAddrOffset);
287 
288             DPRINTF(Loader, "Kernel start = %#x\n", kernelStart);
289             DPRINTF(Loader, "Kernel end   = %#x\n", kernelEnd);
290             DPRINTF(Loader, "Kernel entry = %#x\n", kernelEntry);
291             DPRINTF(Loader, "Kernel loaded...\n");
292         }
293     }
294 
295     activeCpus.clear();
296 }
\end{DoxyCode}
\hypertarget{classSystem_a6685592df58820e9bb30d94908c9881a}{
\index{System@{System}!isAtomicMode@{isAtomicMode}}
\index{isAtomicMode@{isAtomicMode}!System@{System}}
\subsubsection[{isAtomicMode}]{\setlength{\rightskip}{0pt plus 5cm}bool isAtomicMode () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_a6685592df58820e9bb30d94908c9881a}
Is the system in atomic mode?

There are currently two different atomic memory modes: 'atomic', which supports caches; and 'atomic\_\-noncaching', which bypasses caches. The latter is used by hardware virtualized CPUs. SimObjects are expected to use Port::sendAtomic() and Port::recvAtomic() when accessing memory in this mode. 


\begin{DoxyCode}
136                               {
137         return memoryMode == Enums::atomic ||
138             memoryMode == Enums::atomic_noncaching;
139     }
\end{DoxyCode}
\hypertarget{classSystem_a0faeadf06436f8123c7bda01087bb222}{
\index{System@{System}!isMemAddr@{isMemAddr}}
\index{isMemAddr@{isMemAddr}!System@{System}}
\subsubsection[{isMemAddr}]{\setlength{\rightskip}{0pt plus 5cm}bool isMemAddr ({\bf Addr} {\em addr}) const}}
\label{classSystem_a0faeadf06436f8123c7bda01087bb222}
\hyperlink{classCheck}{Check} if a physical address is within a range of a memory that is part of the global address map.


\begin{DoxyParams}{引数}
\item[{\em addr}]A physical address \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Whether the address corresponds to a memory 
\end{DoxyReturn}



\begin{DoxyCode}
335 {
336     return physmem.isMemAddr(addr);
337 }
\end{DoxyCode}
\hypertarget{classSystem_ae04bdd25f4dde1cc1b58b22505aa869c}{
\index{System@{System}!isTimingMode@{isTimingMode}}
\index{isTimingMode@{isTimingMode}!System@{System}}
\subsubsection[{isTimingMode}]{\setlength{\rightskip}{0pt plus 5cm}bool isTimingMode () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_ae04bdd25f4dde1cc1b58b22505aa869c}
Is the system in timing mode?

SimObjects are expected to use Port::sendTiming() and Port::recvTiming() when accessing memory in this mode. 


\begin{DoxyCode}
147                               {
148         return memoryMode == Enums::timing;
149     }
\end{DoxyCode}
\hypertarget{classSystem_ae49314d8f9b44248e8b0577e5cdd0338}{
\index{System@{System}!markWorkItem@{markWorkItem}}
\index{markWorkItem@{markWorkItem}!System@{System}}
\subsubsection[{markWorkItem}]{\setlength{\rightskip}{0pt plus 5cm}int markWorkItem (int {\em index})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_ae49314d8f9b44248e8b0577e5cdd0338}
Called by pseudo\_\-inst to mark the cpus actively executing work items. Returns the total number of cpus that have executed work item begin or ends. 


\begin{DoxyCode}
344     {
345         int count = 0;
346         assert(index < activeCpus.size());
347         activeCpus[index] = true;
348         for (std::vector<bool>::iterator i = activeCpus.begin();
349              i < activeCpus.end(); i++) {
350             if (*i) count++;
351         }
352         return count;
353     }
\end{DoxyCode}
\hypertarget{classSystem_a4cd916c36458ce47e9ba4ccbfc75a095}{
\index{System@{System}!maxMasters@{maxMasters}}
\index{maxMasters@{maxMasters}!System@{System}}
\subsubsection[{maxMasters}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterID} maxMasters ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_a4cd916c36458ce47e9ba4ccbfc75a095}
Get the number of masters registered in the system 


\begin{DoxyCode}
312     {
313         return masterIds.size();
314     }
\end{DoxyCode}
\hypertarget{classSystem_a21f1f1db9f5cb71e5e24790fbac5f30f}{
\index{System@{System}!memSize@{memSize}}
\index{memSize@{memSize}!System@{System}}
\subsubsection[{memSize}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} memSize () const}}
\label{classSystem_a21f1f1db9f5cb71e5e24790fbac5f30f}
Amount of physical memory that exists 


\begin{DoxyCode}
323 {
324     return physmem.totalSize();
325 }
\end{DoxyCode}
\hypertarget{classSystem_a905b96f2c022dcde596bdb806661bcae}{
\index{System@{System}!numContexts@{numContexts}}
\index{numContexts@{numContexts}!System@{System}}
\subsubsection[{numContexts}]{\setlength{\rightskip}{0pt plus 5cm}int numContexts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_a905b96f2c022dcde596bdb806661bcae}



\begin{DoxyCode}
200     {
201         assert(_numContexts == (int)threadContexts.size());
202         return _numContexts;
203     }
\end{DoxyCode}
\hypertarget{classSystem_af17f73eb71dfedfb91e4f39e7bb732ce}{
\index{System@{System}!numRunningContexts@{numRunningContexts}}
\index{numRunningContexts@{numRunningContexts}!System@{System}}
\subsubsection[{numRunningContexts}]{\setlength{\rightskip}{0pt plus 5cm}int numRunningContexts ()}}
\label{classSystem_af17f73eb71dfedfb91e4f39e7bb732ce}
Return number of running (non-\/halted) thread contexts in system. These threads could be Active or Suspended. 


\begin{DoxyCode}
256 {
257     int running = 0;
258     for (int i = 0; i < _numContexts; ++i) {
259         if (threadContexts[i]->status() != ThreadContext::Halted)
260             ++running;
261     }
262     return running;
263 }
\end{DoxyCode}
\hypertarget{classSystem_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{System@{System}!params@{params}}
\index{params@{params}!System@{System}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classMemObject_acd3c3feb78ae7a8f88fe0f110a718dff}{MemObject}を再定義しています。

\hyperlink{classLinuxAlphaSystem_acd3c3feb78ae7a8f88fe0f110a718dff}{LinuxAlphaSystem}, \hyperlink{classAlphaSystem_acd3c3feb78ae7a8f88fe0f110a718dff}{AlphaSystem}, \hyperlink{classLinuxArmSystem_acd3c3feb78ae7a8f88fe0f110a718dff}{LinuxArmSystem}, \hyperlink{classArmSystem_acd3c3feb78ae7a8f88fe0f110a718dff}{ArmSystem}, \hyperlink{classMipsSystem_acd3c3feb78ae7a8f88fe0f110a718dff}{MipsSystem}, \hyperlink{classMipsSystem_acd3c3feb78ae7a8f88fe0f110a718dff}{MipsSystem}, \hyperlink{classSparcSystem_acd3c3feb78ae7a8f88fe0f110a718dff}{SparcSystem}, と \hyperlink{classX86System_acd3c3feb78ae7a8f88fe0f110a718dff}{X86System}で再定義されています。


\begin{DoxyCode}
470 { return (const Params *)_params; }
\end{DoxyCode}
\hypertarget{classSystem_a55206d1ab112cc51ccc3bbefdcc5b923}{
\index{System@{System}!printSystems@{printSystems}}
\index{printSystems@{printSystems}!System@{System}}
\subsubsection[{printSystems}]{\setlength{\rightskip}{0pt plus 5cm}void printSystems ()\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classSystem_a55206d1ab112cc51ccc3bbefdcc5b923}



\begin{DoxyCode}
414 {
415     vector<System *>::iterator i = systemList.begin();
416     vector<System *>::iterator end = systemList.end();
417     for (; i != end; ++i) {
418         System *sys = *i;
419         cerr << "System " << sys->name() << ": " << hex << sys << endl;
420     }
421 }
\end{DoxyCode}
\hypertarget{classSystem_a7211419d4d2d396946880da898f5dbbf}{
\index{System@{System}!registerThreadContext@{registerThreadContext}}
\index{registerThreadContext@{registerThreadContext}!System@{System}}
\subsubsection[{registerThreadContext}]{\setlength{\rightskip}{0pt plus 5cm}int registerThreadContext ({\bf ThreadContext} $\ast$ {\em tc}, \/  int {\em assigned} = {\ttfamily -\/1})}}
\label{classSystem_a7211419d4d2d396946880da898f5dbbf}



\begin{DoxyCode}
209 {
210     int id;
211     if (assigned == -1) {
212         for (id = 0; id < threadContexts.size(); id++) {
213             if (!threadContexts[id])
214                 break;
215         }
216 
217         if (threadContexts.size() <= id)
218             threadContexts.resize(id + 1);
219     } else {
220         if (threadContexts.size() <= assigned)
221             threadContexts.resize(assigned + 1);
222         id = assigned;
223     }
224 
225     if (threadContexts[id])
226         fatal("Cannot have two CPUs with the same id (%d)\n", id);
227 
228     threadContexts[id] = tc;
229     _numContexts++;
230 
231 #if THE_ISA != NULL_ISA
232     int port = getRemoteGDBPort();
233     if (port) {
234         RemoteGDB *rgdb = new RemoteGDB(this, tc);
235         GDBListener *gdbl = new GDBListener(rgdb, port + id);
236         gdbl->listen();
237 
238         if (rgdb_wait != -1 && rgdb_wait == id)
239             gdbl->accept();
240 
241         if (remoteGDB.size() <= id) {
242             remoteGDB.resize(id + 1);
243         }
244 
245         remoteGDB[id] = rgdb;
246     }
247 #endif
248 
249     activeCpus.push_back(false);
250 
251     return id;
252 }
\end{DoxyCode}
\hypertarget{classSystem_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{System@{System}!regStats@{regStats}}
\index{regStats@{regStats}!System@{System}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSystem_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} statistics for this object. 

\hyperlink{classSimObject_a4dc637449366fcdfc4e764cdf12d9b11}{SimObject}を再定義しています。


\begin{DoxyCode}
383 {
384     for (uint32_t j = 0; j < numWorkIds ; j++) {
385         workItemStats[j] = new Stats::Histogram();
386         stringstream namestr;
387         ccprintf(namestr, "work_item_type%d", j);
388         workItemStats[j]->init(20)
389                          .name(name() + "." + namestr.str())
390                          .desc("Run time stat for" + namestr.str())
391                          .prereq(*workItemStats[j]);
392     }
393 }
\end{DoxyCode}
\hypertarget{classSystem_ab2e74da826f1a39705880c80002f52fd}{
\index{System@{System}!replaceThreadContext@{replaceThreadContext}}
\index{replaceThreadContext@{replaceThreadContext}!System@{System}}
\subsubsection[{replaceThreadContext}]{\setlength{\rightskip}{0pt plus 5cm}void replaceThreadContext ({\bf ThreadContext} $\ast$ {\em tc}, \/  int {\em context\_\-id})}}
\label{classSystem_ab2e74da826f1a39705880c80002f52fd}



\begin{DoxyCode}
300 {
301     if (context_id >= threadContexts.size()) {
302         panic("replaceThreadContext: bad id, %d >= %d\n",
303               context_id, threadContexts.size());
304     }
305 
306     threadContexts[context_id] = tc;
307     if (context_id < remoteGDB.size())
308         remoteGDB[context_id]->replaceThreadContext(tc);
309 }
\end{DoxyCode}
\hypertarget{classSystem_a53e036786d17361be4c7320d39c99b84}{
\index{System@{System}!serialize@{serialize}}
\index{serialize@{serialize}!System@{System}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSystem_a53e036786d17361be4c7320d39c99b84}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。\hypertarget{classSystem_a4a6e514fbf1ef35f9a914680884cedef}{
\index{System@{System}!serializeSymtab@{serializeSymtab}}
\index{serializeSymtab@{serializeSymtab}!System@{System}}
\subsubsection[{serializeSymtab}]{\setlength{\rightskip}{0pt plus 5cm}virtual void serializeSymtab (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classSystem_a4a6e514fbf1ef35f9a914680884cedef}
If needed, serialize additional symbol table entries for a specific subclass of this sytem. Currently this is used by Alpha and MIPS.


\begin{DoxyParams}{引数}
\item[{\em os}]stream to serialize to \end{DoxyParams}


\hyperlink{classAlphaSystem_a4a3f2000b7188750d8fc90aa204fbfd9}{AlphaSystem}, と \hyperlink{classSparcSystem_a4a3f2000b7188750d8fc90aa204fbfd9}{SparcSystem}で再定義されています。


\begin{DoxyCode}
534 {}
\end{DoxyCode}
\hypertarget{classSystem_ae0c4408279fbea962460bccd251cffe5}{
\index{System@{System}!setMemoryMode@{setMemoryMode}}
\index{setMemoryMode@{setMemoryMode}!System@{System}}
\subsubsection[{setMemoryMode}]{\setlength{\rightskip}{0pt plus 5cm}void setMemoryMode (Enums::MemoryMode {\em mode})}}
\label{classSystem_ae0c4408279fbea962460bccd251cffe5}
Change the memory mode of the system.

This should only be called by the Python!


\begin{DoxyParams}{引数}
\item[{\em mode}]Mode to change to (atomic/timing/...) \end{DoxyParams}



\begin{DoxyCode}
188 {
189     assert(getDrainState() == Drainable::Drained);
190     memoryMode = mode;
191 }
\end{DoxyCode}
\hypertarget{classSystem_af22e5d6d660b97db37003ac61ac4ee49}{
\index{System@{System}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!System@{System}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classSystem_af22e5d6d660b97db37003ac61ac4ee49}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。\hypertarget{classSystem_a3536a2e47acf307ec65515712f0e2b2d}{
\index{System@{System}!unserializeSymtab@{unserializeSymtab}}
\index{unserializeSymtab@{unserializeSymtab}!System@{System}}
\subsubsection[{unserializeSymtab}]{\setlength{\rightskip}{0pt plus 5cm}virtual void unserializeSymtab ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classSystem_a3536a2e47acf307ec65515712f0e2b2d}
If needed, unserialize additional symbol table entries for a specific subclass of this system.


\begin{DoxyParams}{引数}
\item[{\em \hyperlink{namespacecp}{cp}}]checkpoint to unserialize from \item[{\em section}]relevant section in the checkpoint \end{DoxyParams}


\hyperlink{classAlphaSystem_a183b92b9eac0994f5d446702e995132a}{AlphaSystem}, と \hyperlink{classSparcSystem_a183b92b9eac0994f5d446702e995132a}{SparcSystem}で再定義されています。


\begin{DoxyCode}
544                                                              {}
\end{DoxyCode}
\hypertarget{classSystem_ad4b75de1d7e8c59fae68c3d0c1aa10d0}{
\index{System@{System}!workItemBegin@{workItemBegin}}
\index{workItemBegin@{workItemBegin}!System@{System}}
\subsubsection[{workItemBegin}]{\setlength{\rightskip}{0pt plus 5cm}void workItemBegin ({\bf uint32\_\-t} {\em tid}, \/  {\bf uint32\_\-t} {\em workid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classSystem_ad4b75de1d7e8c59fae68c3d0c1aa10d0}



\begin{DoxyCode}
356     {
357         std::pair<uint32_t,uint32_t> p(tid, workid);
358         lastWorkItemStarted[p] = curTick();
359     }
\end{DoxyCode}
\hypertarget{classSystem_a5a8ccc590b04e540dab229b302e29c88}{
\index{System@{System}!workItemEnd@{workItemEnd}}
\index{workItemEnd@{workItemEnd}!System@{System}}
\subsubsection[{workItemEnd}]{\setlength{\rightskip}{0pt plus 5cm}void workItemEnd ({\bf uint32\_\-t} {\em tid}, \/  {\bf uint32\_\-t} {\em workid})}}
\label{classSystem_a5a8ccc590b04e540dab229b302e29c88}



\begin{DoxyCode}
397 {
398     std::pair<uint32_t,uint32_t> p(tid, workid);
399     if (!lastWorkItemStarted.count(p))
400         return;
401 
402     Tick samp = curTick() - lastWorkItemStarted[p];
403     DPRINTF(WorkItems, "Work item end: %d\t%d\t%lld\n", tid, workid, samp);
404 
405     if (workid >= numWorkIds)
406         fatal("Got workid greater than specified in system configuration\n");
407 
408     workItemStats[workid]->sample(samp);
409     lastWorkItemStarted.erase(p);
410 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classSystem_a6e1b97389f603fc046fbb42ba91136e2}{
\index{System@{System}!\_\-cacheLineSize@{\_\-cacheLineSize}}
\index{\_\-cacheLineSize@{\_\-cacheLineSize}!System@{System}}
\subsubsection[{\_\-cacheLineSize}]{\setlength{\rightskip}{0pt plus 5cm}const unsigned int {\bf \_\-cacheLineSize}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSystem_a6e1b97389f603fc046fbb42ba91136e2}
\hypertarget{classSystem_a13d38579137b1a8b8a2fcfdd501f8d4a}{
\index{System@{System}!\_\-numContexts@{\_\-numContexts}}
\index{\_\-numContexts@{\_\-numContexts}!System@{System}}
\subsubsection[{\_\-numContexts}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf \_\-numContexts}}}
\label{classSystem_a13d38579137b1a8b8a2fcfdd501f8d4a}
\hypertarget{classSystem_afb9ae78c3e2cd51a280162491c99366c}{
\index{System@{System}!\_\-params@{\_\-params}}
\index{\_\-params@{\_\-params}!System@{System}}
\subsubsection[{\_\-params}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Params}$\ast$ {\bf \_\-params}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSystem_afb9ae78c3e2cd51a280162491c99366c}
Cached copy of the object parameters. 

\hyperlink{classSimObject_acaf6024ae9dda44bfb1c67e05ad70aef}{SimObject}を再定義しています。\hypertarget{classSystem_acc373b3a30590f0a6b23b470f85c07b0}{
\index{System@{System}!\_\-systemPort@{\_\-systemPort}}
\index{\_\-systemPort@{\_\-systemPort}!System@{System}}
\subsubsection[{\_\-systemPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SystemPort} {\bf \_\-systemPort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classSystem_acc373b3a30590f0a6b23b470f85c07b0}
\hypertarget{classSystem_adaa0501d61f40b707ee3add7379386fe}{
\index{System@{System}!activeCpus@{activeCpus}}
\index{activeCpus@{activeCpus}!System@{System}}
\subsubsection[{activeCpus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<$bool$>$ {\bf activeCpus}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSystem_adaa0501d61f40b707ee3add7379386fe}
\hypertarget{classSystem_a0c17191d1d61a14d28a4d2ecd11beeff}{
\index{System@{System}!futexMap@{futexMap}}
\index{futexMap@{futexMap}!System@{System}}
\subsubsection[{futexMap}]{\setlength{\rightskip}{0pt plus 5cm}std::map$<$uint64\_\-t, {\bf std::list}$<${\bf ThreadContext} $\ast$$>$ $\ast$ $>$ {\bf futexMap}}}
\label{classSystem_a0c17191d1d61a14d28a4d2ecd11beeff}
\hypertarget{classSystem_a258d0d6139d48d76bf8bdda04f6e2ef8}{
\index{System@{System}!gdbListen@{gdbListen}}
\index{gdbListen@{gdbListen}!System@{System}}
\subsubsection[{gdbListen}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf GDBListener} $\ast$$>$ {\bf gdbListen}}}
\label{classSystem_a258d0d6139d48d76bf8bdda04f6e2ef8}
\hypertarget{classSystem_aebfcbf904f5dc098c119f45063661dce}{
\index{System@{System}!init\_\-param@{init\_\-param}}
\index{init\_\-param@{init\_\-param}!System@{System}}
\subsubsection[{init\_\-param}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf init\_\-param}}}
\label{classSystem_aebfcbf904f5dc098c119f45063661dce}
\hypertarget{classSystem_a05694f19dc768ad2378b58790c870f61}{
\index{System@{System}!instEventQueue@{instEventQueue}}
\index{instEventQueue@{instEventQueue}!System@{System}}
\subsubsection[{instEventQueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf EventQueue} {\bf instEventQueue}}}
\label{classSystem_a05694f19dc768ad2378b58790c870f61}
\hypertarget{classSystem_ab5c2cc90b7ed9b57e9d9c6ce42a5200b}{
\index{System@{System}!kernel@{kernel}}
\index{kernel@{kernel}!System@{System}}
\subsubsection[{kernel}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ObjectFile}$\ast$ {\bf kernel}}}
\label{classSystem_ab5c2cc90b7ed9b57e9d9c6ce42a5200b}
Object pointer for the kernel code \hypertarget{classSystem_ab50e277f319055cb4e9d05e09e314b4a}{
\index{System@{System}!kernelEnd@{kernelEnd}}
\index{kernelEnd@{kernelEnd}!System@{System}}
\subsubsection[{kernelEnd}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf kernelEnd}}}
\label{classSystem_ab50e277f319055cb4e9d05e09e314b4a}
End of kernel code \hypertarget{classSystem_aa4fb57a8e8cf6890a99606f31841c74f}{
\index{System@{System}!kernelEntry@{kernelEntry}}
\index{kernelEntry@{kernelEntry}!System@{System}}
\subsubsection[{kernelEntry}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf kernelEntry}}}
\label{classSystem_aa4fb57a8e8cf6890a99606f31841c74f}
Entry point in the kernel to start at \hypertarget{classSystem_ab7de1b59ae9f13ebe06ee0fdaf262505}{
\index{System@{System}!kernelStart@{kernelStart}}
\index{kernelStart@{kernelStart}!System@{System}}
\subsubsection[{kernelStart}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf kernelStart}}}
\label{classSystem_ab7de1b59ae9f13ebe06ee0fdaf262505}
Begining of kernel code \hypertarget{classSystem_a579bef006c1d6148c2764355c0b039b7}{
\index{System@{System}!kernelSymtab@{kernelSymtab}}
\index{kernelSymtab@{kernelSymtab}!System@{System}}
\subsubsection[{kernelSymtab}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SymbolTable}$\ast$ {\bf kernelSymtab}}}
\label{classSystem_a579bef006c1d6148c2764355c0b039b7}
kernel symbol table \hypertarget{classSystem_a465e763cb54f007726f9b8c35e6638b3}{
\index{System@{System}!lastWorkItemStarted@{lastWorkItemStarted}}
\index{lastWorkItemStarted@{lastWorkItemStarted}!System@{System}}
\subsubsection[{lastWorkItemStarted}]{\setlength{\rightskip}{0pt plus 5cm}std::map$<${\bf std::pair}$<${\bf uint32\_\-t},{\bf uint32\_\-t}$>$, {\bf Tick}$>$ {\bf lastWorkItemStarted}}}
\label{classSystem_a465e763cb54f007726f9b8c35e6638b3}
\hypertarget{classSystem_a49e011922eb3cd15a03e61e206bf02d3}{
\index{System@{System}!loadAddrMask@{loadAddrMask}}
\index{loadAddrMask@{loadAddrMask}!System@{System}}
\subsubsection[{loadAddrMask}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf loadAddrMask}}}
\label{classSystem_a49e011922eb3cd15a03e61e206bf02d3}
Mask that should be anded for binary/symbol loading. This allows one two different OS requirements for the same ISA to be handled. Some OSes are compiled for a virtual address and need to be loaded into physical memory that starts at address 0, while other bare metal tools generate images that start at address 0. \hypertarget{classSystem_a23e95dade560d359d40e4e98456279ad}{
\index{System@{System}!loadAddrOffset@{loadAddrOffset}}
\index{loadAddrOffset@{loadAddrOffset}!System@{System}}
\subsubsection[{loadAddrOffset}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf loadAddrOffset}}}
\label{classSystem_a23e95dade560d359d40e4e98456279ad}
Offset that should be used for binary/symbol loading. This further allows more flexibily than the loadAddrMask allows alone in loading kernels and similar. The loadAddrOffset is applied after the loadAddrMask. \hypertarget{classSystem_af29dc1c2c4242f28c6934043af159765}{
\index{System@{System}!masterIds@{masterIds}}
\index{masterIds@{masterIds}!System@{System}}
\subsubsection[{masterIds}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<$std::string$>$ {\bf masterIds}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSystem_af29dc1c2c4242f28c6934043af159765}
This array is a per-\/sytem list of all devices capable of issuing a memory system request and an associated string for each master id. It's used to uniquely id any master in the system by name for things like cache statistics. \hypertarget{classSystem_a22abae1a5557f96f7fc5a0ef3c660141}{
\index{System@{System}!memoryMode@{memoryMode}}
\index{memoryMode@{memoryMode}!System@{System}}
\subsubsection[{memoryMode}]{\setlength{\rightskip}{0pt plus 5cm}Enums::MemoryMode {\bf memoryMode}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSystem_a22abae1a5557f96f7fc5a0ef3c660141}
\hypertarget{classSystem_a166de98735762528d9fd0d7cbd0ff5db}{
\index{System@{System}!MemoryModeStrings@{MemoryModeStrings}}
\index{MemoryModeStrings@{MemoryModeStrings}!System@{System}}
\subsubsection[{MemoryModeStrings}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ {\bf MemoryModeStrings}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classSystem_a166de98735762528d9fd0d7cbd0ff5db}
{\bfseries 初期値:}
\begin{DoxyCode}
 {"invalid", "atomic", "timing",
                                            "atomic_noncaching"}
\end{DoxyCode}
\hypertarget{classSystem_a940df2387a1775c99f43e7e189a8c0fa}{
\index{System@{System}!nextPID@{nextPID}}
\index{nextPID@{nextPID}!System@{System}}
\subsubsection[{nextPID}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf nextPID}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSystem_a940df2387a1775c99f43e7e189a8c0fa}
\hypertarget{classSystem_a1adea9b3072c7e8d2d045b275c8e37e7}{
\index{System@{System}!numSystemsRunning@{numSystemsRunning}}
\index{numSystemsRunning@{numSystemsRunning}!System@{System}}
\subsubsection[{numSystemsRunning}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf numSystemsRunning} = 0\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classSystem_a1adea9b3072c7e8d2d045b275c8e37e7}
\hypertarget{classSystem_a582d58a54a49964f2967b70bcd29f89d}{
\index{System@{System}!numWorkIds@{numWorkIds}}
\index{numWorkIds@{numWorkIds}!System@{System}}
\subsubsection[{numWorkIds}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} {\bf numWorkIds}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSystem_a582d58a54a49964f2967b70bcd29f89d}
\hypertarget{classSystem_aeeee662e637858aeeb38ca8b84a115cb}{
\index{System@{System}!pagePtr@{pagePtr}}
\index{pagePtr@{pagePtr}!System@{System}}
\subsubsection[{pagePtr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf pagePtr}}}
\label{classSystem_aeeee662e637858aeeb38ca8b84a115cb}
\hypertarget{classSystem_aefd0d5534ce05a7596afe30efe297ad8}{
\index{System@{System}!physmem@{physmem}}
\index{physmem@{physmem}!System@{System}}
\subsubsection[{physmem}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PhysicalMemory} {\bf physmem}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSystem_aefd0d5534ce05a7596afe30efe297ad8}
\hypertarget{classSystem_a6219b40ecb92ec67602ae32c1ae2c0d6}{
\index{System@{System}!physProxy@{physProxy}}
\index{physProxy@{physProxy}!System@{System}}
\subsubsection[{physProxy}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PortProxy} {\bf physProxy}}}
\label{classSystem_a6219b40ecb92ec67602ae32c1ae2c0d6}
\hyperlink{classPort}{Port} to physical memory used for writing object files into ram at boot. \hypertarget{classSystem_a0bb92fde095f717f1a9709fa16825091}{
\index{System@{System}!remoteGDB@{remoteGDB}}
\index{remoteGDB@{remoteGDB}!System@{System}}
\subsubsection[{remoteGDB}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf BaseRemoteGDB} $\ast$$>$ {\bf remoteGDB}}}
\label{classSystem_a0bb92fde095f717f1a9709fa16825091}
\hypertarget{classSystem_a2ccf318c5f6beb8a1697389782c1f2bf}{
\index{System@{System}!systemList@{systemList}}
\index{systemList@{systemList}!System@{System}}
\subsubsection[{systemList}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ {\bf System} $\ast$ $>$ {\bf systemList}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classSystem_a2ccf318c5f6beb8a1697389782c1f2bf}
\hypertarget{classSystem_a19840a204c4d6f67b45a07073e8b41df}{
\index{System@{System}!threadContexts@{threadContexts}}
\index{threadContexts@{threadContexts}!System@{System}}
\subsubsection[{threadContexts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf ThreadContext} $\ast$$>$ {\bf threadContexts}}}
\label{classSystem_a19840a204c4d6f67b45a07073e8b41df}
\hypertarget{classSystem_ac59cc9ac6419c90b7add2f0dff8babc9}{
\index{System@{System}!totalNumInsts@{totalNumInsts}}
\index{totalNumInsts@{totalNumInsts}!System@{System}}
\subsubsection[{totalNumInsts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Counter} {\bf totalNumInsts}}}
\label{classSystem_ac59cc9ac6419c90b7add2f0dff8babc9}
\hypertarget{classSystem_a479aaf1a4cb34f2bbdd533b4fb8ef412}{
\index{System@{System}!workItemsBegin@{workItemsBegin}}
\index{workItemsBegin@{workItemsBegin}!System@{System}}
\subsubsection[{workItemsBegin}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf workItemsBegin}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSystem_a479aaf1a4cb34f2bbdd533b4fb8ef412}
\hypertarget{classSystem_a94de121bcd10e5fae1e1aadd6b4ab41b}{
\index{System@{System}!workItemsEnd@{workItemsEnd}}
\index{workItemsEnd@{workItemsEnd}!System@{System}}
\subsubsection[{workItemsEnd}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf workItemsEnd}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classSystem_a94de121bcd10e5fae1e1aadd6b4ab41b}
\hypertarget{classSystem_a55a97611b6d940c8f1a15c49293ab7c7}{
\index{System@{System}!workItemStats@{workItemStats}}
\index{workItemStats@{workItemStats}!System@{System}}
\subsubsection[{workItemStats}]{\setlength{\rightskip}{0pt plus 5cm}std::map$<${\bf uint32\_\-t}, {\bf Stats::Histogram}$\ast$$>$ {\bf workItemStats}}}
\label{classSystem_a55a97611b6d940c8f1a15c49293ab7c7}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
sim/\hyperlink{sim_2system_8hh}{system.hh}\item 
sim/\hyperlink{sim_2system_8cc}{system.cc}\end{DoxyCompactItemize}
