\hypertarget{classAddrMapper}{
\section{クラス AddrMapper}
\label{classAddrMapper}\index{AddrMapper@{AddrMapper}}
}


{\ttfamily \#include $<$addr\_\-mapper.hh$>$}AddrMapperに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=6cm]{classAddrMapper}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classAddrMapper_1_1AddrMapper}{AddrMapper}
\item 
class \hyperlink{classAddrMapper_1_1AddrMapperSenderState}{AddrMapperSenderState}
\item 
class \hyperlink{classAddrMapper_1_1MapperMasterPort}{MapperMasterPort}
\item 
class \hyperlink{classAddrMapper_1_1MapperSlavePort}{MapperSlavePort}
\item 
class \hyperlink{classAddrMapper_1_1RangeAddrMapper}{RangeAddrMapper}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classAddrMapper_a65d4ce504585c7421d5f7e6aba8ac336}{AddrMapper} (const AddrMapperParams $\ast$params)
\item 
virtual \hyperlink{classAddrMapper_a934511153fe50240d4d25a79586c4006}{$\sim$AddrMapper} ()
\item 
virtual \hyperlink{classBaseMasterPort}{BaseMasterPort} \& \hyperlink{classAddrMapper_adc4e675e51defbdd1e354dac729d0703}{getMasterPort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
virtual \hyperlink{classBaseSlavePort}{BaseSlavePort} \& \hyperlink{classAddrMapper_ac918a145092d7514ebc6dbd952dceafb}{getSlavePort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
virtual void \hyperlink{classAddrMapper_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classAddrMapper_a07fe2c0e12fc8be8a245306df09f1b2d}{remapAddr} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr) const =0
\item 
void \hyperlink{classAddrMapper_aeefa907fb6d6a787e6dab90e8138ea90}{recvFunctional} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classAddrMapper_a284dfb90c168233c9d416bc07de8fefe}{recvFunctionalSnoop} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classAddrMapper_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{recvAtomic} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classAddrMapper_a886d584c81ee4e398ff8069907f6e1a5}{recvAtomicSnoop} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classAddrMapper_a3344d9dd0f83257feab5424e761f31c6}{recvTimingReq} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classAddrMapper_a482dba5588f4bee43e498875a61e5e0b}{recvTimingResp} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classAddrMapper_aff3031c56fc4947a19695c868bb8233e}{recvTimingSnoopReq} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classAddrMapper_a9b643d565edc21dac11ce15a560238a7}{recvTimingSnoopResp} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classAddrMapper_a6e967f8921e80748eb2be35b6b481a7e}{getAddrRanges} () const =0
\item 
bool \hyperlink{classAddrMapper_a5ce11b7a254d3cb756d94568f7cbc25d}{isSnooping} () const 
\item 
void \hyperlink{classAddrMapper_a74fc0d5bf99b08c9899269e3dd7fab6a}{recvRetryMaster} ()
\item 
void \hyperlink{classAddrMapper_a2292f62803fe220e9629886f24aae91a}{recvRetrySlave} ()
\item 
void \hyperlink{classAddrMapper_aecf310a01b533ae8700eccac2cf20480}{recvRangeChange} ()
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classAddrMapper_1_1MapperMasterPort}{MapperMasterPort} \hyperlink{classAddrMapper_a36c3558566dd375b12f573c2ea62992d}{masterPort}
\item 
\hyperlink{classAddrMapper_1_1MapperSlavePort}{MapperSlavePort} \hyperlink{classAddrMapper_a2a442ca0515b14d53305139d239ce090}{slavePort}
\end{DoxyCompactItemize}


\subsection{説明}
An address mapper changes the packet addresses in going from the slave port side of the mapper to the master port side. When the slave port is queried for the address ranges, it also performs the necessary range updates. Note that snoop requests that travel from the master port (i.e. the memory side) to the slave port are currently not modified. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classAddrMapper_a65d4ce504585c7421d5f7e6aba8ac336}{
\index{AddrMapper@{AddrMapper}!AddrMapper@{AddrMapper}}
\index{AddrMapper@{AddrMapper}!AddrMapper@{AddrMapper}}
\subsubsection[{AddrMapper}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrMapper} (const AddrMapperParams $\ast$ {\em params})}}
\label{classAddrMapper_a65d4ce504585c7421d5f7e6aba8ac336}



\begin{DoxyCode}
43     : MemObject(p),
44       masterPort(name() + "-master", *this),
45       slavePort(name() + "-slave", *this)
46 {
47 }
\end{DoxyCode}
\hypertarget{classAddrMapper_a934511153fe50240d4d25a79586c4006}{
\index{AddrMapper@{AddrMapper}!$\sim$AddrMapper@{$\sim$AddrMapper}}
\index{$\sim$AddrMapper@{$\sim$AddrMapper}!AddrMapper@{AddrMapper}}
\subsubsection[{$\sim$AddrMapper}]{\setlength{\rightskip}{0pt plus 5cm}virtual $\sim${\bf AddrMapper} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classAddrMapper_a934511153fe50240d4d25a79586c4006}



\begin{DoxyCode}
63 { }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classAddrMapper_a6e967f8921e80748eb2be35b6b481a7e}{
\index{AddrMapper@{AddrMapper}!getAddrRanges@{getAddrRanges}}
\index{getAddrRanges@{getAddrRanges}!AddrMapper@{AddrMapper}}
\subsubsection[{getAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf AddrRangeList} getAddrRanges () const\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classAddrMapper_a6e967f8921e80748eb2be35b6b481a7e}


\hyperlink{classRangeAddrMapper_a36cf113d5e5e091ebddb32306c098fae}{RangeAddrMapper}で実装されています。\hypertarget{classAddrMapper_adc4e675e51defbdd1e354dac729d0703}{
\index{AddrMapper@{AddrMapper}!getMasterPort@{getMasterPort}}
\index{getMasterPort@{getMasterPort}!AddrMapper@{AddrMapper}}
\subsubsection[{getMasterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseMasterPort} \& getMasterPort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classAddrMapper_adc4e675e51defbdd1e354dac729d0703}
Get a master port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classMemObject_adc4e675e51defbdd1e354dac729d0703}{MemObject}を再定義しています。


\begin{DoxyCode}
58 {
59     if (if_name == "master") {
60         return masterPort;
61     } else {
62         return MemObject::getMasterPort(if_name, idx);
63     }
64 }
\end{DoxyCode}
\hypertarget{classAddrMapper_ac918a145092d7514ebc6dbd952dceafb}{
\index{AddrMapper@{AddrMapper}!getSlavePort@{getSlavePort}}
\index{getSlavePort@{getSlavePort}!AddrMapper@{AddrMapper}}
\subsubsection[{getSlavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseSlavePort} \& getSlavePort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classAddrMapper_ac918a145092d7514ebc6dbd952dceafb}
Get a slave port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classMemObject_ac918a145092d7514ebc6dbd952dceafb}{MemObject}を再定義しています。


\begin{DoxyCode}
68 {
69     if (if_name == "slave") {
70         return slavePort;
71     } else {
72         return MemObject::getSlavePort(if_name, idx);
73     }
74 }
\end{DoxyCode}
\hypertarget{classAddrMapper_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{AddrMapper@{AddrMapper}!init@{init}}
\index{init@{init}!AddrMapper@{AddrMapper}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classAddrMapper_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classAddrMapper_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{SimObject}を再定義しています。


\begin{DoxyCode}
51 {
52     if (!slavePort.isConnected() || !masterPort.isConnected())
53         fatal("Address mapper is not connected on both sides.\n");
54 }
\end{DoxyCode}
\hypertarget{classAddrMapper_a5ce11b7a254d3cb756d94568f7cbc25d}{
\index{AddrMapper@{AddrMapper}!isSnooping@{isSnooping}}
\index{isSnooping@{isSnooping}!AddrMapper@{AddrMapper}}
\subsubsection[{isSnooping}]{\setlength{\rightskip}{0pt plus 5cm}bool isSnooping () const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAddrMapper_a5ce11b7a254d3cb756d94568f7cbc25d}



\begin{DoxyCode}
186 {
187     if (slavePort.isSnooping())
188         fatal("AddrMapper doesn't support remapping of snooping requests\n");
189     return false;
190 }
\end{DoxyCode}
\hypertarget{classAddrMapper_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{
\index{AddrMapper@{AddrMapper}!recvAtomic@{recvAtomic}}
\index{recvAtomic@{recvAtomic}!AddrMapper@{AddrMapper}}
\subsubsection[{recvAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvAtomic ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAddrMapper_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}



\begin{DoxyCode}
96 {
97     Addr orig_addr = pkt->getAddr();
98     pkt->setAddr(remapAddr(orig_addr));
99     Tick ret_tick =  masterPort.sendAtomic(pkt);
100     pkt->setAddr(orig_addr);
101     return ret_tick;
102 }
\end{DoxyCode}
\hypertarget{classAddrMapper_a886d584c81ee4e398ff8069907f6e1a5}{
\index{AddrMapper@{AddrMapper}!recvAtomicSnoop@{recvAtomicSnoop}}
\index{recvAtomicSnoop@{recvAtomicSnoop}!AddrMapper@{AddrMapper}}
\subsubsection[{recvAtomicSnoop}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvAtomicSnoop ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAddrMapper_a886d584c81ee4e398ff8069907f6e1a5}



\begin{DoxyCode}
106 {
107     Addr orig_addr = pkt->getAddr();
108     pkt->setAddr(remapAddr(orig_addr));
109     Tick ret_tick = slavePort.sendAtomicSnoop(pkt);
110     pkt->setAddr(orig_addr);
111     return ret_tick;
112 }
\end{DoxyCode}
\hypertarget{classAddrMapper_aeefa907fb6d6a787e6dab90e8138ea90}{
\index{AddrMapper@{AddrMapper}!recvFunctional@{recvFunctional}}
\index{recvFunctional@{recvFunctional}!AddrMapper@{AddrMapper}}
\subsubsection[{recvFunctional}]{\setlength{\rightskip}{0pt plus 5cm}void recvFunctional ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAddrMapper_aeefa907fb6d6a787e6dab90e8138ea90}



\begin{DoxyCode}
78 {
79     Addr orig_addr = pkt->getAddr();
80     pkt->setAddr(remapAddr(orig_addr));
81     masterPort.sendFunctional(pkt);
82     pkt->setAddr(orig_addr);
83 }
\end{DoxyCode}
\hypertarget{classAddrMapper_a284dfb90c168233c9d416bc07de8fefe}{
\index{AddrMapper@{AddrMapper}!recvFunctionalSnoop@{recvFunctionalSnoop}}
\index{recvFunctionalSnoop@{recvFunctionalSnoop}!AddrMapper@{AddrMapper}}
\subsubsection[{recvFunctionalSnoop}]{\setlength{\rightskip}{0pt plus 5cm}void recvFunctionalSnoop ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAddrMapper_a284dfb90c168233c9d416bc07de8fefe}



\begin{DoxyCode}
87 {
88     Addr orig_addr = pkt->getAddr();
89     pkt->setAddr(remapAddr(orig_addr));
90     slavePort.sendFunctionalSnoop(pkt);
91     pkt->setAddr(orig_addr);
92 }
\end{DoxyCode}
\hypertarget{classAddrMapper_aecf310a01b533ae8700eccac2cf20480}{
\index{AddrMapper@{AddrMapper}!recvRangeChange@{recvRangeChange}}
\index{recvRangeChange@{recvRangeChange}!AddrMapper@{AddrMapper}}
\subsubsection[{recvRangeChange}]{\setlength{\rightskip}{0pt plus 5cm}void recvRangeChange ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAddrMapper_aecf310a01b533ae8700eccac2cf20480}



\begin{DoxyCode}
206 {
207     slavePort.sendRangeChange();
208 }
\end{DoxyCode}
\hypertarget{classAddrMapper_a74fc0d5bf99b08c9899269e3dd7fab6a}{
\index{AddrMapper@{AddrMapper}!recvRetryMaster@{recvRetryMaster}}
\index{recvRetryMaster@{recvRetryMaster}!AddrMapper@{AddrMapper}}
\subsubsection[{recvRetryMaster}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetryMaster ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAddrMapper_a74fc0d5bf99b08c9899269e3dd7fab6a}



\begin{DoxyCode}
194 {
195     slavePort.sendRetry();
196 }
\end{DoxyCode}
\hypertarget{classAddrMapper_a2292f62803fe220e9629886f24aae91a}{
\index{AddrMapper@{AddrMapper}!recvRetrySlave@{recvRetrySlave}}
\index{recvRetrySlave@{recvRetrySlave}!AddrMapper@{AddrMapper}}
\subsubsection[{recvRetrySlave}]{\setlength{\rightskip}{0pt plus 5cm}void recvRetrySlave ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAddrMapper_a2292f62803fe220e9629886f24aae91a}



\begin{DoxyCode}
200 {
201     masterPort.sendRetry();
202 }
\end{DoxyCode}
\hypertarget{classAddrMapper_a3344d9dd0f83257feab5424e761f31c6}{
\index{AddrMapper@{AddrMapper}!recvTimingReq@{recvTimingReq}}
\index{recvTimingReq@{recvTimingReq}!AddrMapper@{AddrMapper}}
\subsubsection[{recvTimingReq}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingReq ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAddrMapper_a3344d9dd0f83257feab5424e761f31c6}



\begin{DoxyCode}
116 {
117     Addr orig_addr = pkt->getAddr();
118     bool needsResponse = pkt->needsResponse();
119     bool memInhibitAsserted = pkt->memInhibitAsserted();
120 
121     if (needsResponse && !memInhibitAsserted) {
122         pkt->pushSenderState(new AddrMapperSenderState(orig_addr));
123     }
124 
125     pkt->setAddr(remapAddr(orig_addr));
126 
127     // Attempt to send the packet (always succeeds for inhibited
128     // packets)
129     bool successful = masterPort.sendTimingReq(pkt);
130 
131     // If not successful, restore the sender state
132     if (!successful && needsResponse) {
133         delete pkt->popSenderState();
134     }
135 
136     return successful;
137 }
\end{DoxyCode}
\hypertarget{classAddrMapper_a482dba5588f4bee43e498875a61e5e0b}{
\index{AddrMapper@{AddrMapper}!recvTimingResp@{recvTimingResp}}
\index{recvTimingResp@{recvTimingResp}!AddrMapper@{AddrMapper}}
\subsubsection[{recvTimingResp}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingResp ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAddrMapper_a482dba5588f4bee43e498875a61e5e0b}



\begin{DoxyCode}
141 {
142     AddrMapperSenderState* receivedState =
143         dynamic_cast<AddrMapperSenderState*>(pkt->senderState);
144 
145     // Restore initial sender state
146     if (receivedState == NULL)
147         panic("AddrMapper %s got a response without sender state\n",
148               name());
149 
150     Addr remapped_addr = pkt->getAddr();
151 
152     // Restore the state and address
153     pkt->senderState = receivedState->predecessor;
154     pkt->setAddr(receivedState->origAddr);
155 
156     // Attempt to send the packet
157     bool successful = slavePort.sendTimingResp(pkt);
158 
159     // If packet successfully sent, delete the sender state, otherwise
160     // restore state
161     if (successful) {
162         delete receivedState;
163     } else {
164         // Don't delete anything and let the packet look like we did
165         // not touch it
166         pkt->senderState = receivedState;
167         pkt->setAddr(remapped_addr);
168     }
169     return successful;
170 }
\end{DoxyCode}
\hypertarget{classAddrMapper_aff3031c56fc4947a19695c868bb8233e}{
\index{AddrMapper@{AddrMapper}!recvTimingSnoopReq@{recvTimingSnoopReq}}
\index{recvTimingSnoopReq@{recvTimingSnoopReq}!AddrMapper@{AddrMapper}}
\subsubsection[{recvTimingSnoopReq}]{\setlength{\rightskip}{0pt plus 5cm}void recvTimingSnoopReq ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAddrMapper_aff3031c56fc4947a19695c868bb8233e}



\begin{DoxyCode}
174 {
175     slavePort.sendTimingSnoopReq(pkt);
176 }
\end{DoxyCode}
\hypertarget{classAddrMapper_a9b643d565edc21dac11ce15a560238a7}{
\index{AddrMapper@{AddrMapper}!recvTimingSnoopResp@{recvTimingSnoopResp}}
\index{recvTimingSnoopResp@{recvTimingSnoopResp}!AddrMapper@{AddrMapper}}
\subsubsection[{recvTimingSnoopResp}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingSnoopResp ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAddrMapper_a9b643d565edc21dac11ce15a560238a7}



\begin{DoxyCode}
180 {
181     return masterPort.sendTimingSnoopResp(pkt);
182 }
\end{DoxyCode}
\hypertarget{classAddrMapper_a07fe2c0e12fc8be8a245306df09f1b2d}{
\index{AddrMapper@{AddrMapper}!remapAddr@{remapAddr}}
\index{remapAddr@{remapAddr}!AddrMapper@{AddrMapper}}
\subsubsection[{remapAddr}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Addr} remapAddr ({\bf Addr} {\em addr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classAddrMapper_a07fe2c0e12fc8be8a245306df09f1b2d}
This function does the actual remapping of one address to another. It is pure virtual in this case to to allow any implementation required. 
\begin{DoxyParams}{引数}
\item[{\em addr}]the address to remap \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
the new address (can be unchanged) 
\end{DoxyReturn}


\hyperlink{classRangeAddrMapper_a0991da7dcb180722b611eb4a58a397a6}{RangeAddrMapper}で実装されています。

\subsection{変数}
\hypertarget{classAddrMapper_a36c3558566dd375b12f573c2ea62992d}{
\index{AddrMapper@{AddrMapper}!masterPort@{masterPort}}
\index{masterPort@{masterPort}!AddrMapper@{AddrMapper}}
\subsubsection[{masterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MapperMasterPort} {\bf masterPort}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAddrMapper_a36c3558566dd375b12f573c2ea62992d}
Instance of master port, facing the memory side \hypertarget{classAddrMapper_a2a442ca0515b14d53305139d239ce090}{
\index{AddrMapper@{AddrMapper}!slavePort@{slavePort}}
\index{slavePort@{slavePort}!AddrMapper@{AddrMapper}}
\subsubsection[{slavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MapperSlavePort} {\bf slavePort}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classAddrMapper_a2a442ca0515b14d53305139d239ce090}
Instance of slave port, i.e. on the CPU side 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{addr__mapper_8hh}{addr\_\-mapper.hh}\item 
mem/\hyperlink{addr__mapper_8cc}{addr\_\-mapper.cc}\end{DoxyCompactItemize}
