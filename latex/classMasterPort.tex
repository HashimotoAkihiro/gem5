\hypertarget{classMasterPort}{
\section{クラス MasterPort}
\label{classMasterPort}\index{MasterPort@{MasterPort}}
}


{\ttfamily \#include $<$port.hh$>$}MasterPortに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=12cm]{classMasterPort}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMasterPort_a4a4ccf1d4533ae4ce5ac9bf88a7edfd5}{MasterPort} (const std::string \&name, \hyperlink{classMemObject}{MemObject} $\ast$\hyperlink{classPort_aba966efb6c1df4b015be3a396df6c318}{owner}, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} \hyperlink{classPort_a0a67444fc1c33a60fe4a92bfff05d0cb}{id}=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
virtual \hyperlink{classMasterPort_a5e846fe2c65dea8caa0c62564ce24f9f}{$\sim$MasterPort} ()
\item 
void \hyperlink{classMasterPort_a5035def22faf23d50855716f8c9602e2}{bind} (\hyperlink{classBaseSlavePort}{BaseSlavePort} \&slave\_\-port)
\item 
void \hyperlink{classMasterPort_af294915156f1e30f1d2e574dccc87945}{unbind} ()
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classMasterPort_a49fe5ebde5a0349bff76527b969b7643}{sendAtomic} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classMasterPort_aef8a57d30c0da6a2d2a599a14a9b8751}{sendFunctional} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classMasterPort_aafaf979005392447714384794f1a8610}{sendTimingReq} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classMasterPort_a4853cc2d61a4dee331dfaeaa54f64fcb}{sendTimingSnoopResp} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual void \hyperlink{classMasterPort_a6172657b944e32a722d90a20c5896bb7}{sendRetry} ()
\item 
virtual bool \hyperlink{classMasterPort_a32602a6a3c3d66a639455036d6c08dd6}{isSnooping} () const 
\item 
\hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classMasterPort_a36cf113d5e5e091ebddb32306c098fae}{getAddrRanges} () const 
\item 
void \hyperlink{classMasterPort_a88aa41e2693dd0091afae2604eba9bed}{printAddr} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} a)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classMasterPort_ae1160d8f94f042aba1dc9a07a72e1e82}{recvAtomicSnoop} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual void \hyperlink{classMasterPort_af5b15bc08781cf0ba6190efc37d5b67e}{recvFunctionalSnoop} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual bool \hyperlink{classMasterPort_abd323548d6c93f8b0543f1fe3a86ca35}{recvTimingResp} (\hyperlink{classPacket}{PacketPtr} pkt)=0
\item 
virtual void \hyperlink{classMasterPort_ae43c73eff109f907118829fcfa9e7096}{recvTimingSnoopReq} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual void \hyperlink{classMasterPort_ac1ccc3bcf7ebabb20b57fab99b2be5b0}{recvRetry} ()=0
\item 
virtual void \hyperlink{classMasterPort_af60d9c2c17fb4c9ebc5384a7e0c9f289}{recvRangeChange} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSlavePort}{SlavePort} $\ast$ \hyperlink{classMasterPort_a33e3b01a66e2118c0e01887bd905e904}{\_\-slavePort}
\end{DoxyCompactItemize}
\subsection*{フレンド}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classMasterPort_a5344d902f61e69b03cd4d737c6375ce3}{SlavePort}
\end{DoxyCompactItemize}


\subsection{説明}
A \hyperlink{classMasterPort}{MasterPort} is a specialisation of a \hyperlink{classBaseMasterPort}{BaseMasterPort}, which implements the default protocol for the three different level of transport functions. In addition to the basic functionality of sending packets, it also has functions to receive range changes or determine if the port is snooping or not. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classMasterPort_a4a4ccf1d4533ae4ce5ac9bf88a7edfd5}{
\index{MasterPort@{MasterPort}!MasterPort@{MasterPort}}
\index{MasterPort@{MasterPort}!MasterPort@{MasterPort}}
\subsubsection[{MasterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MasterPort} (const std::string \& {\em name}, \/  {\bf MemObject} $\ast$ {\em owner}, \/  {\bf PortID} {\em \_\-id} = {\ttfamily {\bf InvalidPortID}})}}
\label{classMasterPort_a4a4ccf1d4533ae4ce5ac9bf88a7edfd5}
Master port 


\begin{DoxyCode}
118     : BaseMasterPort(name, owner, _id), _slavePort(NULL)
119 {
120 }
\end{DoxyCode}
\hypertarget{classMasterPort_a5e846fe2c65dea8caa0c62564ce24f9f}{
\index{MasterPort@{MasterPort}!$\sim$MasterPort@{$\sim$MasterPort}}
\index{$\sim$MasterPort@{$\sim$MasterPort}!MasterPort@{MasterPort}}
\subsubsection[{$\sim$MasterPort}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf MasterPort} ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classMasterPort_a5e846fe2c65dea8caa0c62564ce24f9f}



\begin{DoxyCode}
123 {
124 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classMasterPort_a5035def22faf23d50855716f8c9602e2}{
\index{MasterPort@{MasterPort}!bind@{bind}}
\index{bind@{bind}!MasterPort@{MasterPort}}
\subsubsection[{bind}]{\setlength{\rightskip}{0pt plus 5cm}void bind ({\bf BaseSlavePort} \& {\em slave\_\-port})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classMasterPort_a5035def22faf23d50855716f8c9602e2}
Bind this master port to a slave port. This also does the mirror action and binds the slave port to the master port. 

\hyperlink{classBaseMasterPort_a55647ab861a1f8cf8d26df2f402188d7}{BaseMasterPort}を実装しています。


\begin{DoxyCode}
128 {
129     // bind on the level of the base ports
130     _baseSlavePort = &slave_port;
131 
132     // also attempt to base the slave to the appropriate type
133     SlavePort* cast_slave_port = dynamic_cast<SlavePort*>(&slave_port);
134 
135     // if this port is compatible, then proceed with the binding
136     if (cast_slave_port != NULL) {
137         // master port keeps track of the slave port
138         _slavePort = cast_slave_port;
139         // slave port also keeps track of master port
140         _slavePort->bind(*this);
141     } else {
142         fatal("Master port %s cannot bind to %s\n", name(),
143               slave_port.name());
144     }
145 }
\end{DoxyCode}
\hypertarget{classMasterPort_a36cf113d5e5e091ebddb32306c098fae}{
\index{MasterPort@{MasterPort}!getAddrRanges@{getAddrRanges}}
\index{getAddrRanges@{getAddrRanges}!MasterPort@{MasterPort}}
\subsubsection[{getAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRangeList} getAddrRanges () const}}
\label{classMasterPort_a36cf113d5e5e091ebddb32306c098fae}
Get the address ranges of the connected slave port. 


\begin{DoxyCode}
160 {
161     return _slavePort->getAddrRanges();
162 }
\end{DoxyCode}
\hypertarget{classMasterPort_a32602a6a3c3d66a639455036d6c08dd6}{
\index{MasterPort@{MasterPort}!isSnooping@{isSnooping}}
\index{isSnooping@{isSnooping}!MasterPort@{MasterPort}}
\subsubsection[{isSnooping}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool isSnooping () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, virtual\mbox{]}}}}
\label{classMasterPort_a32602a6a3c3d66a639455036d6c08dd6}
Determine if this master port is snooping or not. The default implementation returns false and thus tells the neighbour we are not snooping. Any master port that wants to receive snoop requests (e.g. a cache connected to a bus) has to override this function.

\begin{DoxyReturn}{戻り値}
true if the port should be considered a snooper 
\end{DoxyReturn}


\hyperlink{classArmISA_1_1TableWalker_1_1SnoopingDmaPort_a32602a6a3c3d66a639455036d6c08dd6}{SnoopingDmaPort}, \hyperlink{classX86ISA_1_1Walker_1_1WalkerPort_a5ce11b7a254d3cb756d94568f7cbc25d}{WalkerPort}, \hyperlink{classFullO3CPU_1_1DcachePort_a32602a6a3c3d66a639455036d6c08dd6}{DcachePort}, \hyperlink{classOzoneLWLSQ_1_1DcachePort_a32602a6a3c3d66a639455036d6c08dd6}{DcachePort}, \hyperlink{classAtomicSimpleCPU_1_1AtomicCPUDPort_a5ce11b7a254d3cb756d94568f7cbc25d}{AtomicCPUDPort}, \hyperlink{classAddrMapper_1_1MapperMasterPort_a5ce11b7a254d3cb756d94568f7cbc25d}{MapperMasterPort}, \hyperlink{classBaseCache_1_1CacheMasterPort_a32602a6a3c3d66a639455036d6c08dd6}{CacheMasterPort}, \hyperlink{classCoherentBus_1_1CoherentBusMasterPort_a32602a6a3c3d66a639455036d6c08dd6}{CoherentBusMasterPort}, と \hyperlink{classCommMonitor_1_1MonitorMasterPort_a5ce11b7a254d3cb756d94568f7cbc25d}{MonitorMasterPort}で再定義されています。


\begin{DoxyCode}
265 { return false; }
\end{DoxyCode}
\hypertarget{classMasterPort_a88aa41e2693dd0091afae2604eba9bed}{
\index{MasterPort@{MasterPort}!printAddr@{printAddr}}
\index{printAddr@{printAddr}!MasterPort@{MasterPort}}
\subsubsection[{printAddr}]{\setlength{\rightskip}{0pt plus 5cm}void printAddr ({\bf Addr} {\em a})}}
\label{classMasterPort_a88aa41e2693dd0091afae2604eba9bed}
Inject a PrintReq for the given address to print the state of that address throughout the memory system. For debugging. 


\begin{DoxyCode}
200 {
201     Request req(a, 1, 0, Request::funcMasterId);
202     Packet pkt(&req, MemCmd::PrintReq);
203     Packet::PrintReqState prs(std::cerr);
204     pkt.senderState = &prs;
205 
206     sendFunctional(&pkt);
207 }
\end{DoxyCode}
\hypertarget{classMasterPort_ae1160d8f94f042aba1dc9a07a72e1e82}{
\index{MasterPort@{MasterPort}!recvAtomicSnoop@{recvAtomicSnoop}}
\index{recvAtomicSnoop@{recvAtomicSnoop}!MasterPort@{MasterPort}}
\subsubsection[{recvAtomicSnoop}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Tick} recvAtomicSnoop ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classMasterPort_ae1160d8f94f042aba1dc9a07a72e1e82}
Receive an atomic snoop request packet from the slave port. 

\hyperlink{classArmISA_1_1TableWalker_1_1SnoopingDmaPort_ae1160d8f94f042aba1dc9a07a72e1e82}{SnoopingDmaPort}, \hyperlink{classX86ISA_1_1Walker_1_1WalkerPort_a886d584c81ee4e398ff8069907f6e1a5}{WalkerPort}, \hyperlink{classAtomicSimpleCPU_1_1AtomicCPUPort_ae1160d8f94f042aba1dc9a07a72e1e82}{AtomicCPUPort}, \hyperlink{classAtomicSimpleCPU_1_1AtomicCPUDPort_a886d584c81ee4e398ff8069907f6e1a5}{AtomicCPUDPort}, \hyperlink{classMemTest_1_1CpuPort_ae1160d8f94f042aba1dc9a07a72e1e82}{CpuPort}, \hyperlink{classAddrMapper_1_1MapperMasterPort_a886d584c81ee4e398ff8069907f6e1a5}{MapperMasterPort}, \hyperlink{classCoherentBus_1_1CoherentBusMasterPort_ae1160d8f94f042aba1dc9a07a72e1e82}{CoherentBusMasterPort}, と \hyperlink{classCommMonitor_1_1MonitorMasterPort_a886d584c81ee4e398ff8069907f6e1a5}{MonitorMasterPort}で再定義されています。


\begin{DoxyCode}
283     {
284         panic("%s was not expecting an atomic snoop request\n", name());
285         return 0;
286     }
\end{DoxyCode}
\hypertarget{classMasterPort_af5b15bc08781cf0ba6190efc37d5b67e}{
\index{MasterPort@{MasterPort}!recvFunctionalSnoop@{recvFunctionalSnoop}}
\index{recvFunctionalSnoop@{recvFunctionalSnoop}!MasterPort@{MasterPort}}
\subsubsection[{recvFunctionalSnoop}]{\setlength{\rightskip}{0pt plus 5cm}virtual void recvFunctionalSnoop ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classMasterPort_af5b15bc08781cf0ba6190efc37d5b67e}
Receive a functional snoop request packet from the slave port. 

\hyperlink{classArmISA_1_1TableWalker_1_1SnoopingDmaPort_af5b15bc08781cf0ba6190efc37d5b67e}{SnoopingDmaPort}, \hyperlink{classX86ISA_1_1Walker_1_1WalkerPort_a284dfb90c168233c9d416bc07de8fefe}{WalkerPort}, \hyperlink{classFullO3CPU_1_1DcachePort_af5b15bc08781cf0ba6190efc37d5b67e}{DcachePort}, \hyperlink{classAtomicSimpleCPU_1_1AtomicCPUDPort_a284dfb90c168233c9d416bc07de8fefe}{AtomicCPUDPort}, \hyperlink{classMemTest_1_1CpuPort_af5b15bc08781cf0ba6190efc37d5b67e}{CpuPort}, \hyperlink{classAddrMapper_1_1MapperMasterPort_a284dfb90c168233c9d416bc07de8fefe}{MapperMasterPort}, \hyperlink{classCoherentBus_1_1CoherentBusMasterPort_af5b15bc08781cf0ba6190efc37d5b67e}{CoherentBusMasterPort}, と \hyperlink{classCommMonitor_1_1MonitorMasterPort_a284dfb90c168233c9d416bc07de8fefe}{MonitorMasterPort}で再定義されています。


\begin{DoxyCode}
292     {
293         panic("%s was not expecting a functional snoop request\n", name());
294     }
\end{DoxyCode}
\hypertarget{classMasterPort_af60d9c2c17fb4c9ebc5384a7e0c9f289}{
\index{MasterPort@{MasterPort}!recvRangeChange@{recvRangeChange}}
\index{recvRangeChange@{recvRangeChange}!MasterPort@{MasterPort}}
\subsubsection[{recvRangeChange}]{\setlength{\rightskip}{0pt plus 5cm}virtual void recvRangeChange ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classMasterPort_af60d9c2c17fb4c9ebc5384a7e0c9f289}
Called to receive an address range change from the peer slave port. The default implementation ignores the change and does nothing. Override this function in a derived class if the owner needs to be aware of the address ranges, e.g. in an interconnect component like a bus. 

\hyperlink{classAddrMapper_1_1MapperMasterPort_aecf310a01b533ae8700eccac2cf20480}{MapperMasterPort}, \hyperlink{classCoherentBus_1_1CoherentBusMasterPort_af60d9c2c17fb4c9ebc5384a7e0c9f289}{CoherentBusMasterPort}, \hyperlink{classCommMonitor_1_1MonitorMasterPort_aecf310a01b533ae8700eccac2cf20480}{MonitorMasterPort}, \hyperlink{classNoncoherentBus_1_1NoncoherentBusMasterPort_af60d9c2c17fb4c9ebc5384a7e0c9f289}{NoncoherentBusMasterPort}, \hyperlink{classRubyPort_1_1MemMasterPort_aecf310a01b533ae8700eccac2cf20480}{MemMasterPort}, と \hyperlink{classRubyPort_1_1PioMasterPort_aecf310a01b533ae8700eccac2cf20480}{PioMasterPort}で再定義されています。


\begin{DoxyCode}
324 { }
\end{DoxyCode}
\hypertarget{classMasterPort_ac1ccc3bcf7ebabb20b57fab99b2be5b0}{
\index{MasterPort@{MasterPort}!recvRetry@{recvRetry}}
\index{recvRetry@{recvRetry}!MasterPort@{MasterPort}}
\subsubsection[{recvRetry}]{\setlength{\rightskip}{0pt plus 5cm}virtual void recvRetry ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classMasterPort_ac1ccc3bcf7ebabb20b57fab99b2be5b0}
Called by the slave port if sendTimingReq or sendTimingSnoopResp was called on this master port (causing recvTimingReq and recvTimingSnoopResp to be called on the slave port) and was unsuccesful. 

\hyperlink{classX86ISA_1_1Walker_1_1WalkerPort_a29cb5a4f98063ce6e9210eacbdb35298}{WalkerPort}, \hyperlink{classInOrderCPU_1_1CachePort_a29cb5a4f98063ce6e9210eacbdb35298}{CachePort}, \hyperlink{classBaseKvmCPU_1_1KVMCpuPort_a29cb5a4f98063ce6e9210eacbdb35298}{KVMCpuPort}, \hyperlink{classFullO3CPU_1_1IcachePort_a29cb5a4f98063ce6e9210eacbdb35298}{IcachePort}, \hyperlink{classFullO3CPU_1_1DcachePort_a29cb5a4f98063ce6e9210eacbdb35298}{DcachePort}, \hyperlink{classFrontEnd_1_1IcachePort_a29cb5a4f98063ce6e9210eacbdb35298}{IcachePort}, \hyperlink{classOzoneLWLSQ_1_1DcachePort_a29cb5a4f98063ce6e9210eacbdb35298}{DcachePort}, \hyperlink{classAtomicSimpleCPU_1_1AtomicCPUPort_a29cb5a4f98063ce6e9210eacbdb35298}{AtomicCPUPort}, \hyperlink{classTimingSimpleCPU_1_1IcachePort_a29cb5a4f98063ce6e9210eacbdb35298}{IcachePort}, \hyperlink{classTimingSimpleCPU_1_1DcachePort_a29cb5a4f98063ce6e9210eacbdb35298}{DcachePort}, \hyperlink{classRubyDirectedTester_1_1CpuPort_a7ec461ad187b82b4b21e27c86e45cf9c}{CpuPort}, \hyperlink{classMemTest_1_1CpuPort_a29cb5a4f98063ce6e9210eacbdb35298}{CpuPort}, \hyperlink{classNetworkTest_1_1CpuPort_a29cb5a4f98063ce6e9210eacbdb35298}{CpuPort}, \hyperlink{classRubyTester_1_1CpuPort_a7ec461ad187b82b4b21e27c86e45cf9c}{CpuPort}, \hyperlink{classTrafficGen_1_1TrafficGenPort_a29cb5a4f98063ce6e9210eacbdb35298}{TrafficGenPort}, \hyperlink{classDmaPort_a29cb5a4f98063ce6e9210eacbdb35298}{DmaPort}, \hyperlink{classAddrMapper_1_1MapperMasterPort_a29cb5a4f98063ce6e9210eacbdb35298}{MapperMasterPort}, \hyperlink{classBridge_1_1BridgeMasterPort_a29cb5a4f98063ce6e9210eacbdb35298}{BridgeMasterPort}, \hyperlink{classCoherentBus_1_1CoherentBusMasterPort_a7ec461ad187b82b4b21e27c86e45cf9c}{CoherentBusMasterPort}, \hyperlink{classCoherentBus_1_1SnoopRespPort_a29cb5a4f98063ce6e9210eacbdb35298}{SnoopRespPort}, \hyperlink{classCommMonitor_1_1MonitorMasterPort_a29cb5a4f98063ce6e9210eacbdb35298}{MonitorMasterPort}, \hyperlink{classNoncoherentBus_1_1NoncoherentBusMasterPort_a7ec461ad187b82b4b21e27c86e45cf9c}{NoncoherentBusMasterPort}, \hyperlink{classQueuedMasterPort_a7ec461ad187b82b4b21e27c86e45cf9c}{QueuedMasterPort}, と \hyperlink{classSystem_1_1SystemPort_a29cb5a4f98063ce6e9210eacbdb35298}{SystemPort}で実装されています。\hypertarget{classMasterPort_abd323548d6c93f8b0543f1fe3a86ca35}{
\index{MasterPort@{MasterPort}!recvTimingResp@{recvTimingResp}}
\index{recvTimingResp@{recvTimingResp}!MasterPort@{MasterPort}}
\subsubsection[{recvTimingResp}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool recvTimingResp ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classMasterPort_abd323548d6c93f8b0543f1fe3a86ca35}
Receive a timing response from the slave port. 

\hyperlink{classX86ISA_1_1Walker_1_1WalkerPort_a482dba5588f4bee43e498875a61e5e0b}{WalkerPort}, \hyperlink{classInOrderCPU_1_1CachePort_a482dba5588f4bee43e498875a61e5e0b}{CachePort}, \hyperlink{classBaseKvmCPU_1_1KVMCpuPort_a482dba5588f4bee43e498875a61e5e0b}{KVMCpuPort}, \hyperlink{classFullO3CPU_1_1IcachePort_a482dba5588f4bee43e498875a61e5e0b}{IcachePort}, \hyperlink{classFullO3CPU_1_1DcachePort_a482dba5588f4bee43e498875a61e5e0b}{DcachePort}, \hyperlink{classAtomicSimpleCPU_1_1AtomicCPUPort_a482dba5588f4bee43e498875a61e5e0b}{AtomicCPUPort}, \hyperlink{classTimingSimpleCPU_1_1IcachePort_a482dba5588f4bee43e498875a61e5e0b}{IcachePort}, \hyperlink{classTimingSimpleCPU_1_1DcachePort_a482dba5588f4bee43e498875a61e5e0b}{DcachePort}, \hyperlink{classRubyDirectedTester_1_1CpuPort_a482dba5588f4bee43e498875a61e5e0b}{CpuPort}, \hyperlink{classMemTest_1_1CpuPort_a482dba5588f4bee43e498875a61e5e0b}{CpuPort}, \hyperlink{classNetworkTest_1_1CpuPort_a482dba5588f4bee43e498875a61e5e0b}{CpuPort}, \hyperlink{classRubyTester_1_1CpuPort_a482dba5588f4bee43e498875a61e5e0b}{CpuPort}, \hyperlink{classTrafficGen_1_1TrafficGenPort_a482dba5588f4bee43e498875a61e5e0b}{TrafficGenPort}, \hyperlink{classDmaPort_a482dba5588f4bee43e498875a61e5e0b}{DmaPort}, \hyperlink{classAddrMapper_1_1MapperMasterPort_a482dba5588f4bee43e498875a61e5e0b}{MapperMasterPort}, \hyperlink{classBridge_1_1BridgeMasterPort_a482dba5588f4bee43e498875a61e5e0b}{BridgeMasterPort}, \hyperlink{classCoherentBus_1_1CoherentBusMasterPort_a197a199a6dabb291067a978d54bd2d04}{CoherentBusMasterPort}, \hyperlink{classCoherentBus_1_1SnoopRespPort_a482dba5588f4bee43e498875a61e5e0b}{SnoopRespPort}, \hyperlink{classCommMonitor_1_1MonitorMasterPort_a482dba5588f4bee43e498875a61e5e0b}{MonitorMasterPort}, \hyperlink{classMessageMasterPort_a482dba5588f4bee43e498875a61e5e0b}{MessageMasterPort}, \hyperlink{classNoncoherentBus_1_1NoncoherentBusMasterPort_a197a199a6dabb291067a978d54bd2d04}{NoncoherentBusMasterPort}, \hyperlink{classRubyPort_1_1MemMasterPort_a482dba5588f4bee43e498875a61e5e0b}{MemMasterPort}, \hyperlink{classRubyPort_1_1PioMasterPort_a482dba5588f4bee43e498875a61e5e0b}{PioMasterPort}, と \hyperlink{classSystem_1_1SystemPort_a482dba5588f4bee43e498875a61e5e0b}{SystemPort}で実装されています。\hypertarget{classMasterPort_ae43c73eff109f907118829fcfa9e7096}{
\index{MasterPort@{MasterPort}!recvTimingSnoopReq@{recvTimingSnoopReq}}
\index{recvTimingSnoopReq@{recvTimingSnoopReq}!MasterPort@{MasterPort}}
\subsubsection[{recvTimingSnoopReq}]{\setlength{\rightskip}{0pt plus 5cm}virtual void recvTimingSnoopReq ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classMasterPort_ae43c73eff109f907118829fcfa9e7096}
Receive a timing snoop request from the slave port. 

\hyperlink{classArmISA_1_1TableWalker_1_1SnoopingDmaPort_ae43c73eff109f907118829fcfa9e7096}{SnoopingDmaPort}, \hyperlink{classX86ISA_1_1Walker_1_1WalkerPort_aff3031c56fc4947a19695c868bb8233e}{WalkerPort}, \hyperlink{classInOrderCPU_1_1CachePort_aff3031c56fc4947a19695c868bb8233e}{CachePort}, \hyperlink{classFullO3CPU_1_1IcachePort_ae43c73eff109f907118829fcfa9e7096}{IcachePort}, \hyperlink{classFullO3CPU_1_1DcachePort_aff3031c56fc4947a19695c868bb8233e}{DcachePort}, \hyperlink{classTimingSimpleCPU_1_1TimingCPUPort_ae43c73eff109f907118829fcfa9e7096}{TimingCPUPort}, \hyperlink{classTimingSimpleCPU_1_1DcachePort_aff3031c56fc4947a19695c868bb8233e}{DcachePort}, \hyperlink{classMemTest_1_1CpuPort_ae43c73eff109f907118829fcfa9e7096}{CpuPort}, \hyperlink{classAddrMapper_1_1MapperMasterPort_aff3031c56fc4947a19695c868bb8233e}{MapperMasterPort}, \hyperlink{classCoherentBus_1_1CoherentBusMasterPort_ae43c73eff109f907118829fcfa9e7096}{CoherentBusMasterPort}, と \hyperlink{classCommMonitor_1_1MonitorMasterPort_aff3031c56fc4947a19695c868bb8233e}{MonitorMasterPort}で再定義されています。


\begin{DoxyCode}
305     {
306         panic("%s was not expecting a timing snoop request\n", name());
307     }
\end{DoxyCode}
\hypertarget{classMasterPort_a49fe5ebde5a0349bff76527b969b7643}{
\index{MasterPort@{MasterPort}!sendAtomic@{sendAtomic}}
\index{sendAtomic@{sendAtomic}!MasterPort@{MasterPort}}
\subsubsection[{sendAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} sendAtomic ({\bf PacketPtr} {\em pkt})}}
\label{classMasterPort_a49fe5ebde5a0349bff76527b969b7643}
Send an atomic request packet, where the data is moved and the state is updated in zero time, without interleaving with other memory accesses.


\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} to send.\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
Estimated latency of access. 
\end{DoxyReturn}



\begin{DoxyCode}
166 {
167     assert(pkt->isRequest());
168     return _slavePort->recvAtomic(pkt);
169 }
\end{DoxyCode}
\hypertarget{classMasterPort_aef8a57d30c0da6a2d2a599a14a9b8751}{
\index{MasterPort@{MasterPort}!sendFunctional@{sendFunctional}}
\index{sendFunctional@{sendFunctional}!MasterPort@{MasterPort}}
\subsubsection[{sendFunctional}]{\setlength{\rightskip}{0pt plus 5cm}void sendFunctional ({\bf PacketPtr} {\em pkt})}}
\label{classMasterPort_aef8a57d30c0da6a2d2a599a14a9b8751}
Send a functional request packet, where the data is instantly updated everywhere in the memory system, without affecting the current state of any block or moving the block.


\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} to send. \end{DoxyParams}



\begin{DoxyCode}
173 {
174     assert(pkt->isRequest());
175     return _slavePort->recvFunctional(pkt);
176 }
\end{DoxyCode}
\hypertarget{classMasterPort_a6172657b944e32a722d90a20c5896bb7}{
\index{MasterPort@{MasterPort}!sendRetry@{sendRetry}}
\index{sendRetry@{sendRetry}!MasterPort@{MasterPort}}
\subsubsection[{sendRetry}]{\setlength{\rightskip}{0pt plus 5cm}void sendRetry ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classMasterPort_a6172657b944e32a722d90a20c5896bb7}
Send a retry to the slave port that previously attempted a sendTimingResp to this master port and failed. 

\hyperlink{classCoherentBus_1_1SnoopRespPort_a6172657b944e32a722d90a20c5896bb7}{SnoopRespPort}で再定義されています。


\begin{DoxyCode}
194 {
195     _slavePort->recvRetry();
196 }
\end{DoxyCode}
\hypertarget{classMasterPort_aafaf979005392447714384794f1a8610}{
\index{MasterPort@{MasterPort}!sendTimingReq@{sendTimingReq}}
\index{sendTimingReq@{sendTimingReq}!MasterPort@{MasterPort}}
\subsubsection[{sendTimingReq}]{\setlength{\rightskip}{0pt plus 5cm}bool sendTimingReq ({\bf PacketPtr} {\em pkt})}}
\label{classMasterPort_aafaf979005392447714384794f1a8610}
Attempt to send a timing request to the slave port by calling its corresponding receive function. If the send does not succeed, as indicated by the return value, then the sender must wait for a recvRetry at which point it can re-\/issue a sendTimingReq.


\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} to send.\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
If the send was succesful or not. 
\end{DoxyReturn}



\begin{DoxyCode}
180 {
181     assert(pkt->isRequest());
182     return _slavePort->recvTimingReq(pkt);
183 }
\end{DoxyCode}
\hypertarget{classMasterPort_a4853cc2d61a4dee331dfaeaa54f64fcb}{
\index{MasterPort@{MasterPort}!sendTimingSnoopResp@{sendTimingSnoopResp}}
\index{sendTimingSnoopResp@{sendTimingSnoopResp}!MasterPort@{MasterPort}}
\subsubsection[{sendTimingSnoopResp}]{\setlength{\rightskip}{0pt plus 5cm}bool sendTimingSnoopResp ({\bf PacketPtr} {\em pkt})}}
\label{classMasterPort_a4853cc2d61a4dee331dfaeaa54f64fcb}
Attempt to send a timing snoop response packet to the slave port by calling its corresponding receive function. If the send does not succeed, as indicated by the return value, then the sender must wait for a recvRetry at which point it can re-\/issue a sendTimingSnoopResp.


\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} to send. \end{DoxyParams}



\begin{DoxyCode}
187 {
188     assert(pkt->isResponse());
189     return _slavePort->recvTimingSnoopResp(pkt);
190 }
\end{DoxyCode}
\hypertarget{classMasterPort_af294915156f1e30f1d2e574dccc87945}{
\index{MasterPort@{MasterPort}!unbind@{unbind}}
\index{unbind@{unbind}!MasterPort@{MasterPort}}
\subsubsection[{unbind}]{\setlength{\rightskip}{0pt plus 5cm}void unbind ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classMasterPort_af294915156f1e30f1d2e574dccc87945}
Unbind this master port and the associated slave port. 

\hyperlink{classBaseMasterPort_a406c5430a4a46c0068050632b9d3e765}{BaseMasterPort}を実装しています。


\begin{DoxyCode}
149 {
150     if (_slavePort == NULL)
151         panic("Attempting to unbind master port %s that is not connected\n",
152               name());
153     _slavePort->unbind();
154     _slavePort = NULL;
155     _baseSlavePort = NULL;
156 }
\end{DoxyCode}


\subsection{フレンドと関連する関数}
\hypertarget{classMasterPort_a5344d902f61e69b03cd4d737c6375ce3}{
\index{MasterPort@{MasterPort}!SlavePort@{SlavePort}}
\index{SlavePort@{SlavePort}!MasterPort@{MasterPort}}
\subsubsection[{SlavePort}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf SlavePort}\hspace{0.3cm}{\ttfamily  \mbox{[}friend\mbox{]}}}}
\label{classMasterPort_a5344d902f61e69b03cd4d737c6375ce3}


\subsection{変数}
\hypertarget{classMasterPort_a33e3b01a66e2118c0e01887bd905e904}{
\index{MasterPort@{MasterPort}!\_\-slavePort@{\_\-slavePort}}
\index{\_\-slavePort@{\_\-slavePort}!MasterPort@{MasterPort}}
\subsubsection[{\_\-slavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SlavePort}$\ast$ {\bf \_\-slavePort}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMasterPort_a33e3b01a66e2118c0e01887bd905e904}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{port_8hh}{port.hh}\item 
mem/\hyperlink{port_8cc}{port.cc}\end{DoxyCompactItemize}
