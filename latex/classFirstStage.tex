\hypertarget{classFirstStage}{
\section{クラス FirstStage}
\label{classFirstStage}\index{FirstStage@{FirstStage}}
}


{\ttfamily \#include $<$first\_\-stage.hh$>$}FirstStageに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classFirstStage}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classFirstStage_a818d5f50fdcec74a1a445b4fa8b760e3}{FetchPriority} \{ \hyperlink{classFirstStage_a818d5f50fdcec74a1a445b4fa8b760e3ae01d52cbe97a50e79f4195cd27b3185b}{SingleThread}, 
\hyperlink{classFirstStage_a818d5f50fdcec74a1a445b4fa8b760e3a5c08841de48c15133dd26a4d9d740a11}{RoundRobin}
 \}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classFirstStage_a11c6e3fc6cdc379408dffb110f0fb5e6}{FirstStage} (\hyperlink{namespaceThePipeline_ab62ca16eeca26566ad2422b5df4943ce}{ThePipeline::Params} $\ast$params, unsigned stage\_\-num)
\item 
void \hyperlink{classFirstStage_a6fd0f914e19bcfb6d9f28e537ad956d5}{setCPU} (\hyperlink{classInOrderCPU}{InOrderCPU} $\ast$cpu\_\-ptr)
\item 
void \hyperlink{classFirstStage_a0782fca2c80ef367ee914d464584ab20}{processStage} (bool \&status\_\-change)
\item 
void \hyperlink{classFirstStage_a4120d7c6b83eb82877f4d21109c105ba}{processInsts} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classFirstStage_ad9e3c0e17499440cfafb6145d7be97a1}{squash} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} squash\_\-seq\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classFirstStage_a960b60a46045a5363df0c263f0f43902}{squashDueToMemStall} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} seq\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classFirstStage_a9ff2aa32ab0f40674cb3518108d62f8e}{sortInsts} ()
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classFirstStage_a4a20466270bc79a695af63ea67a35576}{getFetchingThread} (\hyperlink{classFirstStage_a818d5f50fdcec74a1a445b4fa8b760e3}{FetchPriority} \&fetch\_\-priority)
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classFirstStage_a8aab9cacbc483081596b13ecd5192eb5}{roundRobin} ()
\item 
void \hyperlink{classFirstStage_a8674059ce345e23aac5086b2c3e24a43}{takeOverFrom} ()
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classFirstStage_abc07f427e4a6bddb47d14e781854189a}{numFetchingThreads}
\item 
\hyperlink{classFirstStage_a818d5f50fdcec74a1a445b4fa8b760e3}{FetchPriority} \hyperlink{classFirstStage_aad8c2ca9262308cfdb74cd69cda508f6}{fetchPolicy}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$ \hyperlink{classFirstStage_abdcd4a3705dfeada6582f853535e29f3}{fetchPriorityList}
\end{DoxyCompactItemize}


\subsection{列挙型}
\hypertarget{classFirstStage_a818d5f50fdcec74a1a445b4fa8b760e3}{
\index{FirstStage@{FirstStage}!FetchPriority@{FetchPriority}}
\index{FetchPriority@{FetchPriority}!FirstStage@{FirstStage}}
\subsubsection[{FetchPriority}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf FetchPriority}}}
\label{classFirstStage_a818d5f50fdcec74a1a445b4fa8b760e3}
Fetching Policy, Add new policies here. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{SingleThread@{SingleThread}!FirstStage@{FirstStage}}\index{FirstStage@{FirstStage}!SingleThread@{SingleThread}}\item[{\em 
\hypertarget{classFirstStage_a818d5f50fdcec74a1a445b4fa8b760e3ae01d52cbe97a50e79f4195cd27b3185b}{
SingleThread}
\label{classFirstStage_a818d5f50fdcec74a1a445b4fa8b760e3ae01d52cbe97a50e79f4195cd27b3185b}
}]\index{RoundRobin@{RoundRobin}!FirstStage@{FirstStage}}\index{FirstStage@{FirstStage}!RoundRobin@{RoundRobin}}\item[{\em 
\hypertarget{classFirstStage_a818d5f50fdcec74a1a445b4fa8b760e3a5c08841de48c15133dd26a4d9d740a11}{
RoundRobin}
\label{classFirstStage_a818d5f50fdcec74a1a445b4fa8b760e3a5c08841de48c15133dd26a4d9d740a11}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
75                        {
76         SingleThread,
77         RoundRobin
78     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classFirstStage_a11c6e3fc6cdc379408dffb110f0fb5e6}{
\index{FirstStage@{FirstStage}!FirstStage@{FirstStage}}
\index{FirstStage@{FirstStage}!FirstStage@{FirstStage}}
\subsubsection[{FirstStage}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FirstStage} ({\bf ThePipeline::Params} $\ast$ {\em params}, \/  unsigned {\em stage\_\-num})}}
\label{classFirstStage_a11c6e3fc6cdc379408dffb110f0fb5e6}


\subsection{関数}
\hypertarget{classFirstStage_a4a20466270bc79a695af63ea67a35576}{
\index{FirstStage@{FirstStage}!getFetchingThread@{getFetchingThread}}
\index{getFetchingThread@{getFetchingThread}!FirstStage@{FirstStage}}
\subsubsection[{getFetchingThread}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} getFetchingThread ({\bf FetchPriority} \& {\em fetch\_\-priority})}}
\label{classFirstStage_a4a20466270bc79a695af63ea67a35576}
Return the next fetching thread 


\begin{DoxyCode}
223 {
224     ThreadID num_active_threads = cpu->numActiveThreads();
225 
226     if (num_active_threads > 1) {
227         switch (fetch_priority) {
228           case SingleThread:
229             return cpu->activeThreadId();
230 
231           case RoundRobin:
232             return roundRobin();
233 
234           default:
235             return InvalidThreadID;
236         }
237     } else if (num_active_threads == 1) {
238         ThreadID tid = *activeThreads->begin();
239 
240         if (stageStatus[tid] == Running ||
241             stageStatus[tid] == Idle ||
242             stageStatus[tid] == Unblocking) {
243             return tid;
244         } else {
245             return InvalidThreadID;
246         }
247     } else {
248         return InvalidThreadID;
249     }    
250 }
\end{DoxyCode}
\hypertarget{classFirstStage_a4120d7c6b83eb82877f4d21109c105ba}{
\index{FirstStage@{FirstStage}!processInsts@{processInsts}}
\index{processInsts@{processInsts}!FirstStage@{FirstStage}}
\subsubsection[{processInsts}]{\setlength{\rightskip}{0pt plus 5cm}void processInsts ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFirstStage_a4120d7c6b83eb82877f4d21109c105ba}
\hyperlink{classProcess}{Process} All Instructions Available 

\hyperlink{classPipelineStage_a4120d7c6b83eb82877f4d21109c105ba}{PipelineStage}を再定義しています。


\begin{DoxyCode}
149 {
150     bool all_reqs_completed = true;
151 
152     for (int insts_fetched = instsProcessed;
153          insts_fetched < stageWidth;
154          insts_fetched++) {
155 
156         DynInstPtr inst;
157         bool new_inst = false;
158 
159         if (!skidBuffer[tid].empty()) {
160             inst = skidBuffer[tid].front();
161         } else {
162             // Get new instruction.
163             new_inst = true;
164 
165             inst = new InOrderDynInst(cpu,
166                                       cpu->thread[tid],
167                                       cpu->nextInstSeqNum(tid),
168                                       tid,
169                                       tid);
170 
171 #if TRACING_ON
172             inst->traceData =
173                 tracer->getInstRecord(ThePipeline::NumStages,
174                                       cpu->stageTracing,
175                                       cpu->thread[tid]->getTC());
176 
177 #else
178             inst->traceData = NULL;
179 #endif      // TRACING_ON
180 
181             // Add instruction to the CPU's list of instructions.
182             inst->setInstListIt(cpu->addInst(inst));
183 
184             // Create Front-End Resource Schedule For Instruction
185             inst->setFrontSked(cpu->frontEndSked);
186         }
187 
188         int reqs_processed = 0;            
189         all_reqs_completed = processInstSchedule(inst, reqs_processed);
190 
191         // If the instruction isnt squashed & we've completed one request
192         // Then we can officially count this instruction toward the stage's 
193         // bandwidth count
194         if (reqs_processed > 0)
195             instsProcessed++;
196 
197         if (!all_reqs_completed || !sendInstToNextStage(inst)) {
198             if (new_inst) {
199                 DPRINTF(InOrderStage, "[tid:%u]: [sn:%u] Did not finish all "
200                         "requests for this stage. Keep in stage inst. "
201                         "list.\n", tid, inst->seqNum);
202                 skidBuffer[tid].push_back(inst);
203             }
204             block(tid);
205             break;
206         } else if (!skidBuffer[tid].empty()){
207             DPRINTF(InOrderStage, "[tid:%u]: [sn:%u] Finished all "
208                     "requests for this stage.\n", tid, inst->seqNum);
209             skidBuffer[tid].pop_front();
210         }
211 
212     }
213 
214     // Record that stage has written to the time buffer for activity
215     // tracking.
216     if (instsProcessed) {
217         wroteToTimeBuffer = true;
218     }
219 }
\end{DoxyCode}
\hypertarget{classFirstStage_a0782fca2c80ef367ee914d464584ab20}{
\index{FirstStage@{FirstStage}!processStage@{processStage}}
\index{processStage@{processStage}!FirstStage@{FirstStage}}
\subsubsection[{processStage}]{\setlength{\rightskip}{0pt plus 5cm}void processStage (bool \& {\em status\_\-change})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFirstStage_a0782fca2c80ef367ee914d464584ab20}
Evaluate Stage Info. \& Execute Stage 

\hyperlink{classPipelineStage_a0782fca2c80ef367ee914d464584ab20}{PipelineStage}を再定義しています。


\begin{DoxyCode}
113 {
114     list<ThreadID>::iterator threads = activeThreads->begin();
115 
116     //Check stall and squash signals.
117     while (threads != activeThreads->end()) {
118         ThreadID tid = *threads++;
119         status_change =  checkSignalsAndUpdate(tid) || status_change;
120     }
121 
122     while (instsProcessed < stageWidth)  {
123         ThreadID tid = getFetchingThread(fetchPolicy);
124 
125         if (tid >= 0) {
126             DPRINTF(InOrderStage, "Processing [tid:%i]\n",tid);
127             processThread(status_change, tid);
128             DPRINTF(InOrderStage, "Done Processing [tid:%i]\n",tid);
129         } else {
130             DPRINTF(InOrderStage, "No more threads to fetch from.\n");
131             break;
132         }
133     }
134 
135     if (instsProcessed > 0) {
136         ++runCycles;
137         idle = false;        
138     } else {
139         ++idleCycles;
140         idle = true;        
141     }
142 
143 }
\end{DoxyCode}
\hypertarget{classFirstStage_a8aab9cacbc483081596b13ecd5192eb5}{
\index{FirstStage@{FirstStage}!roundRobin@{roundRobin}}
\index{roundRobin@{roundRobin}!FirstStage@{FirstStage}}
\subsubsection[{roundRobin}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} roundRobin ()}}
\label{classFirstStage_a8aab9cacbc483081596b13ecd5192eb5}
Return next thread given Round Robin Policy for Thread Fetching 


\begin{DoxyCode}
254 {
255     list<ThreadID>::iterator pri_iter = fetchPriorityList->begin();
256     list<ThreadID>::iterator end      = fetchPriorityList->end();
257 
258     ThreadID high_pri;
259 
260     while (pri_iter != end) {
261         high_pri = *pri_iter;
262 
263         assert(high_pri <= numThreads);
264 
265         if (stageStatus[high_pri] == Running ||
266             stageStatus[high_pri] == Idle ||
267             stageStatus[high_pri] == Unblocking){
268 
269             fetchPriorityList->erase(pri_iter);
270             fetchPriorityList->push_back(high_pri);
271 
272             return high_pri;
273         }
274 
275         pri_iter++;
276     }
277 
278     return InvalidThreadID;
279 }
\end{DoxyCode}
\hypertarget{classFirstStage_a6fd0f914e19bcfb6d9f28e537ad956d5}{
\index{FirstStage@{FirstStage}!setCPU@{setCPU}}
\index{setCPU@{setCPU}!FirstStage@{FirstStage}}
\subsubsection[{setCPU}]{\setlength{\rightskip}{0pt plus 5cm}void setCPU ({\bf InOrderCPU} $\ast$ {\em cpu\_\-ptr})}}
\label{classFirstStage_a6fd0f914e19bcfb6d9f28e537ad956d5}
\hyperlink{classSet}{Set} Pointer to CPU 

\hyperlink{classPipelineStage_a6fd0f914e19bcfb6d9f28e537ad956d5}{PipelineStage}を再定義しています。


\begin{DoxyCode}
54 {
55     cpu = cpu_ptr;
56 
57     fetchPriorityList = &cpu->fetchPriorityList;
58 
59     DPRINTF(InOrderStage, "Set CPU pointer.\n");
60 }
\end{DoxyCode}
\hypertarget{classFirstStage_a9ff2aa32ab0f40674cb3518108d62f8e}{
\index{FirstStage@{FirstStage}!sortInsts@{sortInsts}}
\index{sortInsts@{sortInsts}!FirstStage@{FirstStage}}
\subsubsection[{sortInsts}]{\setlength{\rightskip}{0pt plus 5cm}void sortInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classFirstStage_a9ff2aa32ab0f40674cb3518108d62f8e}
There are no \hyperlink{namespaceinsts}{insts}. coming from previous stages, so there is no need to sort \hyperlink{namespaceinsts}{insts} here 

\hyperlink{classPipelineStage_a9ff2aa32ab0f40674cb3518108d62f8e}{PipelineStage}を再定義しています。


\begin{DoxyCode}
68 {}
\end{DoxyCode}
\hypertarget{classFirstStage_ad9e3c0e17499440cfafb6145d7be97a1}{
\index{FirstStage@{FirstStage}!squash@{squash}}
\index{squash@{squash}!FirstStage@{FirstStage}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash ({\bf InstSeqNum} {\em squash\_\-seq\_\-num}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFirstStage_ad9e3c0e17499440cfafb6145d7be97a1}
Squash Instructions Above a Seq. Num 

\hyperlink{classPipelineStage_aee9dc23de90acd20200641407a3bd1da}{PipelineStage}を再定義しています。


\begin{DoxyCode}
65 {
66     // Set status to squashing.
67     //stageStatus[tid] = Squashing;
68 
69     // Clear the instruction list and skid buffer in case they have any
70     // insts in them.
71     DPRINTF(InOrderStage, "Removing instructions from stage instruction "
72             "list.\n");
73     while (!skidBuffer[tid].empty()) {
74         if (skidBuffer[tid].front()->seqNum <= squash_seq_num) {
75             DPRINTF(InOrderStage,"[tid:%i]: Cannot remove [sn:%i] because "
76                     "it's <= squashing seqNum %i.\n",
77                     tid,
78                     skidBuffer[tid].front()->seqNum,
79                     squash_seq_num);
80 
81             DPRINTF(InOrderStage, "[tid:%i]: Cannot remove incoming "
82                     "instructions before delay slot [sn:%i]. %i insts"
83                     "left.\n", tid, squash_seq_num,
84                     skidBuffer[tid].size());
85             break;
86         }
87         DPRINTF(InOrderStage, "[tid:%i]: Removing instruction, [sn:%i] "
88                 "PC %s.\n", tid, skidBuffer[tid].front()->seqNum,
89                 skidBuffer[tid].front()->pc);
90         skidBuffer[tid].pop_front();
91     }
92 
93     // Now that squash has propagated to the first stage,
94     // Alert CPU to remove instructions from the CPU instruction list.
95     // @todo: Move this to the CPU object.
96     cpu->removeInstsUntil(squash_seq_num, tid);
97 }
\end{DoxyCode}
\hypertarget{classFirstStage_a960b60a46045a5363df0c263f0f43902}{
\index{FirstStage@{FirstStage}!squashDueToMemStall@{squashDueToMemStall}}
\index{squashDueToMemStall@{squashDueToMemStall}!FirstStage@{FirstStage}}
\subsubsection[{squashDueToMemStall}]{\setlength{\rightskip}{0pt plus 5cm}void squashDueToMemStall ({\bf InstSeqNum} {\em seq\_\-num}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFirstStage_a960b60a46045a5363df0c263f0f43902}


\hyperlink{classPipelineStage_a960b60a46045a5363df0c263f0f43902}{PipelineStage}を再定義しています。


\begin{DoxyCode}
101 {
102     // Need to preserve the stalling instruction in first-stage
103     // since the squash() from first stage also removes
104     // the instruction from the CPU (removeInstsUntil). If that
105     // functionality gets changed then you can move this offset.
106     // (stalling instruction = seq_num + 1)
107     squash(seq_num+1, tid);
108 }
\end{DoxyCode}
\hypertarget{classFirstStage_a8674059ce345e23aac5086b2c3e24a43}{
\index{FirstStage@{FirstStage}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!FirstStage@{FirstStage}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classFirstStage_a8674059ce345e23aac5086b2c3e24a43}
Takes over from another CPU's thread. 

\hyperlink{classPipelineStage_a8674059ce345e23aac5086b2c3e24a43}{PipelineStage}を再定義しています。


\begin{DoxyCode}
283 {
284     PipelineStage::takeOverFrom();
285 
286     for(ThreadID tid = 0; tid < this->numThreads; tid++) {
287         stageStatus[tid] = Running;
288     }
289 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classFirstStage_aad8c2ca9262308cfdb74cd69cda508f6}{
\index{FirstStage@{FirstStage}!fetchPolicy@{fetchPolicy}}
\index{fetchPolicy@{fetchPolicy}!FirstStage@{FirstStage}}
\subsubsection[{fetchPolicy}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FetchPriority} {\bf fetchPolicy}}}
\label{classFirstStage_aad8c2ca9262308cfdb74cd69cda508f6}
Fetch policy. \hypertarget{classFirstStage_abdcd4a3705dfeada6582f853535e29f3}{
\index{FirstStage@{FirstStage}!fetchPriorityList@{fetchPriorityList}}
\index{fetchPriorityList@{fetchPriorityList}!FirstStage@{FirstStage}}
\subsubsection[{fetchPriorityList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf ThreadID}$>$$\ast$ {\bf fetchPriorityList}}}
\label{classFirstStage_abdcd4a3705dfeada6582f853535e29f3}
List that has the threads organized by priority. \hypertarget{classFirstStage_abc07f427e4a6bddb47d14e781854189a}{
\index{FirstStage@{FirstStage}!numFetchingThreads@{numFetchingThreads}}
\index{numFetchingThreads@{numFetchingThreads}!FirstStage@{FirstStage}}
\subsubsection[{numFetchingThreads}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf numFetchingThreads}}}
\label{classFirstStage_abc07f427e4a6bddb47d14e781854189a}
The number of fetching threads in the CPU 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/inorder/\hyperlink{first__stage_8hh}{first\_\-stage.hh}\item 
cpu/inorder/\hyperlink{first__stage_8cc}{first\_\-stage.cc}\end{DoxyCompactItemize}
