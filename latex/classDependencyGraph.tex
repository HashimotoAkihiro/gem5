\hypertarget{classDependencyGraph}{
\section{クラス テンプレート DependencyGraph$<$ DynInstPtr $>$}
\label{classDependencyGraph}\index{DependencyGraph@{DependencyGraph}}
}


{\ttfamily \#include $<$dep\_\-graph.hh$>$}\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classDependencyEntry}{DependencyEntry}$<$ DynInstPtr $>$ \hyperlink{classDependencyGraph_ab740e4c6c7a7c521e28f61fc991417f8}{DepEntry}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDependencyGraph_a272991aeaffc4f6a74a9f3de8cb3e055}{DependencyGraph} ()
\item 
\hyperlink{classDependencyGraph_aadf0cefbf15be129075d5c91be7c61b4}{$\sim$DependencyGraph} ()
\item 
void \hyperlink{classDependencyGraph_a3780426d320e4d44a0bc9f44ce6c2175}{resize} (int num\_\-entries)
\item 
void \hyperlink{classDependencyGraph_ad20897c5c8bd47f5d4005989bead0e55}{reset} ()
\item 
void \hyperlink{classDependencyGraph_a8147b910a65e5096dbbb3b8359f375f8}{insert} (\hyperlink{o3_2comm_8hh_a5ec29599c4bc29a3054c451674969e7b}{PhysRegIndex} idx, DynInstPtr \&new\_\-inst)
\item 
void \hyperlink{classDependencyGraph_ade8120ce15ebff1cb55df7995a51d237}{setInst} (\hyperlink{o3_2comm_8hh_a5ec29599c4bc29a3054c451674969e7b}{PhysRegIndex} idx, DynInstPtr \&new\_\-inst)
\item 
void \hyperlink{classDependencyGraph_a68804553aa4fc717c5e467b252ef37ca}{clearInst} (\hyperlink{o3_2comm_8hh_a5ec29599c4bc29a3054c451674969e7b}{PhysRegIndex} idx)
\item 
void \hyperlink{classDependencyGraph_a0f84aaa20d93732630c72593b97f5e13}{remove} (\hyperlink{o3_2comm_8hh_a5ec29599c4bc29a3054c451674969e7b}{PhysRegIndex} idx, DynInstPtr \&inst\_\-to\_\-remove)
\item 
DynInstPtr \hyperlink{classDependencyGraph_a37140b50c279f856724fe1eac144bc3a}{pop} (\hyperlink{o3_2comm_8hh_a5ec29599c4bc29a3054c451674969e7b}{PhysRegIndex} idx)
\item 
bool \hyperlink{classDependencyGraph_ac6e61de369e994009e36f344f99c15ad}{empty} () const 
\item 
bool \hyperlink{classDependencyGraph_a790abdbbdb5625ac65e5e3702b1e1a43}{empty} (\hyperlink{o3_2comm_8hh_a5ec29599c4bc29a3054c451674969e7b}{PhysRegIndex} idx) const 
\item 
void \hyperlink{classDependencyGraph_accd2600060dbaee3a3b41aed4034c63c}{dump} ()
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
uint64\_\-t \hyperlink{classDependencyGraph_a3872e5bf089b4615d62a04b097795a6e}{nodesTraversed}
\item 
uint64\_\-t \hyperlink{classDependencyGraph_ad997769c2f059584b9ffb4a2e118207b}{nodesRemoved}
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDependencyEntry}{DepEntry} $\ast$ \hyperlink{classDependencyGraph_a6f79afe06f613dc0de42e79175c6e776}{dependGraph}
\item 
int \hyperlink{classDependencyGraph_a75b15f0e26b4ccf3195772b134b660ec}{numEntries}
\item 
unsigned \hyperlink{classDependencyGraph_a3cfe22df7cc4db63a7704ae43ef789aa}{memAllocCounter}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$class DynInstPtr$>$ class DependencyGraph$<$ DynInstPtr $>$}

Array of linked list that maintains the dependencies between producing instructions and consuming instructions. Each linked list represents a single physical register, having the future producer of the register's value, and all consumers waiting on that value on the list. The head node of each linked list represents the producing instruction of that register. Instructions are put on the list upon reaching the IQ, and are removed from the list either when the producer completes, or the instruction is squashed. 

\subsection{型定義}
\hypertarget{classDependencyGraph_ab740e4c6c7a7c521e28f61fc991417f8}{
\index{DependencyGraph@{DependencyGraph}!DepEntry@{DepEntry}}
\index{DepEntry@{DepEntry}!DependencyGraph@{DependencyGraph}}
\subsubsection[{DepEntry}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf DependencyEntry}$<$DynInstPtr$>$ {\bf DepEntry}}}
\label{classDependencyGraph_ab740e4c6c7a7c521e28f61fc991417f8}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classDependencyGraph_a272991aeaffc4f6a74a9f3de8cb3e055}{
\index{DependencyGraph@{DependencyGraph}!DependencyGraph@{DependencyGraph}}
\index{DependencyGraph@{DependencyGraph}!DependencyGraph@{DependencyGraph}}
\subsubsection[{DependencyGraph}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DependencyGraph} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDependencyGraph_a272991aeaffc4f6a74a9f3de8cb3e055}
Default construction. Must call \hyperlink{classDependencyGraph_a3780426d320e4d44a0bc9f44ce6c2175}{resize()} prior to use. 


\begin{DoxyCode}
80         : numEntries(0), memAllocCounter(0), nodesTraversed(0), nodesRemoved(0)
81     { }
\end{DoxyCode}
\hypertarget{classDependencyGraph_aadf0cefbf15be129075d5c91be7c61b4}{
\index{DependencyGraph@{DependencyGraph}!$\sim$DependencyGraph@{$\sim$DependencyGraph}}
\index{$\sim$DependencyGraph@{$\sim$DependencyGraph}!DependencyGraph@{DependencyGraph}}
\subsubsection[{$\sim$DependencyGraph}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf DependencyGraph} ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDependencyGraph_aadf0cefbf15be129075d5c91be7c61b4}



\begin{DoxyCode}
142 {
143     delete [] dependGraph;
144 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classDependencyGraph_a68804553aa4fc717c5e467b252ef37ca}{
\index{DependencyGraph@{DependencyGraph}!clearInst@{clearInst}}
\index{clearInst@{clearInst}!DependencyGraph@{DependencyGraph}}
\subsubsection[{clearInst}]{\setlength{\rightskip}{0pt plus 5cm}void clearInst ({\bf PhysRegIndex} {\em idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDependencyGraph_a68804553aa4fc717c5e467b252ef37ca}
Clears the producing instruction. 


\begin{DoxyCode}
100     { dependGraph[idx].inst = NULL; }
\end{DoxyCode}
\hypertarget{classDependencyGraph_accd2600060dbaee3a3b41aed4034c63c}{
\index{DependencyGraph@{DependencyGraph}!dump@{dump}}
\index{dump@{dump}!DependencyGraph@{DependencyGraph}}
\subsubsection[{dump}]{\setlength{\rightskip}{0pt plus 5cm}void dump ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDependencyGraph_accd2600060dbaee3a3b41aed4034c63c}
Debugging function to dump out the dependency graph. 


\begin{DoxyCode}
272 {
273     DepEntry *curr;
274 
275     for (int i = 0; i < numEntries; ++i)
276     {
277         curr = &dependGraph[i];
278 
279         if (curr->inst) {
280             cprintf("dependGraph[%i]: producer: %s [sn:%lli] consumer: ",
281                     i, curr->inst->pcState(), curr->inst->seqNum);
282         } else {
283             cprintf("dependGraph[%i]: No producer. consumer: ", i);
284         }
285 
286         while (curr->next != NULL) {
287             curr = curr->next;
288 
289             cprintf("%s [sn:%lli] ",
290                     curr->inst->pcState(), curr->inst->seqNum);
291         }
292 
293         cprintf("\n");
294     }
295     cprintf("memAllocCounter: %i\n", memAllocCounter);
296 }
\end{DoxyCode}
\hypertarget{classDependencyGraph_a790abdbbdb5625ac65e5e3702b1e1a43}{
\index{DependencyGraph@{DependencyGraph}!empty@{empty}}
\index{empty@{empty}!DependencyGraph@{DependencyGraph}}
\subsubsection[{empty}]{\setlength{\rightskip}{0pt plus 5cm}bool empty ({\bf PhysRegIndex} {\em idx}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDependencyGraph_a790abdbbdb5625ac65e5e3702b1e1a43}
Checks if there are any dependents on a specific register. 


\begin{DoxyCode}
112 { return !dependGraph[idx].next; }
\end{DoxyCode}
\hypertarget{classDependencyGraph_ac6e61de369e994009e36f344f99c15ad}{
\index{DependencyGraph@{DependencyGraph}!empty@{empty}}
\index{empty@{empty}!DependencyGraph@{DependencyGraph}}
\subsubsection[{empty}]{\setlength{\rightskip}{0pt plus 5cm}bool empty () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDependencyGraph_ac6e61de369e994009e36f344f99c15ad}
Checks if the entire dependency graph is empty. 


\begin{DoxyCode}
261 {
262     for (int i = 0; i < numEntries; ++i) {
263         if (!empty(i))
264             return false;
265     }
266     return true;
267 }
\end{DoxyCode}
\hypertarget{classDependencyGraph_a8147b910a65e5096dbbb3b8359f375f8}{
\index{DependencyGraph@{DependencyGraph}!insert@{insert}}
\index{insert@{insert}!DependencyGraph@{DependencyGraph}}
\subsubsection[{insert}]{\setlength{\rightskip}{0pt plus 5cm}void insert ({\bf PhysRegIndex} {\em idx}, \/  DynInstPtr \& {\em new\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDependencyGraph_a8147b910a65e5096dbbb3b8359f375f8}
Inserts an instruction to be dependent on the given index. 


\begin{DoxyCode}
186 {
187     //Add this new, dependent instruction at the head of the dependency
188     //chain.
189 
190     // First create the entry that will be added to the head of the
191     // dependency chain.
192     DepEntry *new_entry = new DepEntry;
193     new_entry->next = dependGraph[idx].next;
194     new_entry->inst = new_inst;
195 
196     // Then actually add it to the chain.
197     dependGraph[idx].next = new_entry;
198 
199     ++memAllocCounter;
200 }
\end{DoxyCode}
\hypertarget{classDependencyGraph_a37140b50c279f856724fe1eac144bc3a}{
\index{DependencyGraph@{DependencyGraph}!pop@{pop}}
\index{pop@{pop}!DependencyGraph@{DependencyGraph}}
\subsubsection[{pop}]{\setlength{\rightskip}{0pt plus 5cm}DynInstPtr pop ({\bf PhysRegIndex} {\em idx})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDependencyGraph_a37140b50c279f856724fe1eac144bc3a}
Removes and returns the newest dependent of a specific register. 


\begin{DoxyCode}
244 {
245     DepEntry *node;
246     node = dependGraph[idx].next;
247     DynInstPtr inst = NULL;
248     if (node) {
249         inst = node->inst;
250         dependGraph[idx].next = node->next;
251         node->inst = NULL;
252         memAllocCounter--;
253         delete node;
254     }
255     return inst;
256 }
\end{DoxyCode}
\hypertarget{classDependencyGraph_a0f84aaa20d93732630c72593b97f5e13}{
\index{DependencyGraph@{DependencyGraph}!remove@{remove}}
\index{remove@{remove}!DependencyGraph@{DependencyGraph}}
\subsubsection[{remove}]{\setlength{\rightskip}{0pt plus 5cm}void remove ({\bf PhysRegIndex} {\em idx}, \/  DynInstPtr \& {\em inst\_\-to\_\-remove})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDependencyGraph_a0f84aaa20d93732630c72593b97f5e13}
Removes an instruction from a single linked list. 


\begin{DoxyCode}
207 {
208     DepEntry *prev = &dependGraph[idx];
209     DepEntry *curr = dependGraph[idx].next;
210 
211     // Make sure curr isn't NULL.  Because this instruction is being
212     // removed from a dependency list, it must have been placed there at
213     // an earlier time.  The dependency chain should not be empty,
214     // unless the instruction dependent upon it is already ready.
215     if (curr == NULL) {
216         return;
217     }
218 
219     nodesRemoved++;
220 
221     // Find the instruction to remove within the dependency linked list.
222     while (curr->inst != inst_to_remove) {
223         prev = curr;
224         curr = curr->next;
225         nodesTraversed++;
226 
227         assert(curr != NULL);
228     }
229 
230     // Now remove this instruction from the list.
231     prev->next = curr->next;
232 
233     --memAllocCounter;
234 
235     // Could push this off to the destructor of DependencyEntry
236     curr->inst = NULL;
237 
238     delete curr;
239 }
\end{DoxyCode}
\hypertarget{classDependencyGraph_ad20897c5c8bd47f5d4005989bead0e55}{
\index{DependencyGraph@{DependencyGraph}!reset@{reset}}
\index{reset@{reset}!DependencyGraph@{DependencyGraph}}
\subsubsection[{reset}]{\setlength{\rightskip}{0pt plus 5cm}void reset ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDependencyGraph_ad20897c5c8bd47f5d4005989bead0e55}
Clears all of the linked lists. 


\begin{DoxyCode}
157 {
158     // Clear the dependency graph
159     DepEntry *curr;
160     DepEntry *prev;
161 
162     for (int i = 0; i < numEntries; ++i) {
163         curr = dependGraph[i].next;
164 
165         while (curr) {
166             memAllocCounter--;
167 
168             prev = curr;
169             curr = prev->next;
170             prev->inst = NULL;
171 
172             delete prev;
173         }
174 
175         if (dependGraph[i].inst) {
176             dependGraph[i].inst = NULL;
177         }
178 
179         dependGraph[i].next = NULL;
180     }
181 }
\end{DoxyCode}
\hypertarget{classDependencyGraph_a3780426d320e4d44a0bc9f44ce6c2175}{
\index{DependencyGraph@{DependencyGraph}!resize@{resize}}
\index{resize@{resize}!DependencyGraph@{DependencyGraph}}
\subsubsection[{resize}]{\setlength{\rightskip}{0pt plus 5cm}void resize (int {\em num\_\-entries})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDependencyGraph_a3780426d320e4d44a0bc9f44ce6c2175}
Resize the dependency graph to have num\_\-entries registers. 


\begin{DoxyCode}
149 {
150     numEntries = num_entries;
151     dependGraph = new DepEntry[numEntries];
152 }
\end{DoxyCode}
\hypertarget{classDependencyGraph_ade8120ce15ebff1cb55df7995a51d237}{
\index{DependencyGraph@{DependencyGraph}!setInst@{setInst}}
\index{setInst@{setInst}!DependencyGraph@{DependencyGraph}}
\subsubsection[{setInst}]{\setlength{\rightskip}{0pt plus 5cm}void setInst ({\bf PhysRegIndex} {\em idx}, \/  DynInstPtr \& {\em new\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classDependencyGraph_ade8120ce15ebff1cb55df7995a51d237}
Sets the producing instruction of a given register. 


\begin{DoxyCode}
96     { dependGraph[idx].inst = new_inst; }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classDependencyGraph_a6f79afe06f613dc0de42e79175c6e776}{
\index{DependencyGraph@{DependencyGraph}!dependGraph@{dependGraph}}
\index{dependGraph@{dependGraph}!DependencyGraph@{DependencyGraph}}
\subsubsection[{dependGraph}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DepEntry}$\ast$ {\bf dependGraph}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDependencyGraph_a6f79afe06f613dc0de42e79175c6e776}
Array of linked lists. Each linked list is a list of all the instructions that depend upon a given register. The actual register's index is used to index into the graph; ie all instructions in flight that are dependent upon r34 will be in the linked list of dependGraph\mbox{[}34\mbox{]}. \hypertarget{classDependencyGraph_a3cfe22df7cc4db63a7704ae43ef789aa}{
\index{DependencyGraph@{DependencyGraph}!memAllocCounter@{memAllocCounter}}
\index{memAllocCounter@{memAllocCounter}!DependencyGraph@{DependencyGraph}}
\subsubsection[{memAllocCounter}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf memAllocCounter}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDependencyGraph_a3cfe22df7cc4db63a7704ae43ef789aa}
\hypertarget{classDependencyGraph_ad997769c2f059584b9ffb4a2e118207b}{
\index{DependencyGraph@{DependencyGraph}!nodesRemoved@{nodesRemoved}}
\index{nodesRemoved@{nodesRemoved}!DependencyGraph@{DependencyGraph}}
\subsubsection[{nodesRemoved}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf nodesRemoved}}}
\label{classDependencyGraph_ad997769c2f059584b9ffb4a2e118207b}
\hypertarget{classDependencyGraph_a3872e5bf089b4615d62a04b097795a6e}{
\index{DependencyGraph@{DependencyGraph}!nodesTraversed@{nodesTraversed}}
\index{nodesTraversed@{nodesTraversed}!DependencyGraph@{DependencyGraph}}
\subsubsection[{nodesTraversed}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf nodesTraversed}}}
\label{classDependencyGraph_a3872e5bf089b4615d62a04b097795a6e}
\hypertarget{classDependencyGraph_a75b15f0e26b4ccf3195772b134b660ec}{
\index{DependencyGraph@{DependencyGraph}!numEntries@{numEntries}}
\index{numEntries@{numEntries}!DependencyGraph@{DependencyGraph}}
\subsubsection[{numEntries}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf numEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDependencyGraph_a75b15f0e26b4ccf3195772b134b660ec}
Number of linked lists; identical to the number of registers. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/o3/\hyperlink{dep__graph_8hh}{dep\_\-graph.hh}\end{DoxyCompactItemize}
