\hypertarget{classDRAMCtrl_1_1MemoryPort}{
\section{クラス MemoryPort}
\label{classDRAMCtrl_1_1MemoryPort}\index{DRAMCtrl::MemoryPort@{DRAMCtrl::MemoryPort}}
}
MemoryPortに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=5cm]{classDRAMCtrl_1_1MemoryPort}
\end{center}
\end{figure}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDRAMCtrl_1_1MemoryPort_aee0ee389785135af506951436ea56679}{MemoryPort} (const std::string \&name, \hyperlink{classDRAMCtrl_1_1DRAMCtrl}{DRAMCtrl} \&\_\-memory)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classDRAMCtrl_1_1MemoryPort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{recvAtomic} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
void \hyperlink{classDRAMCtrl_1_1MemoryPort_aeefa907fb6d6a787e6dab90e8138ea90}{recvFunctional} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
bool \hyperlink{classDRAMCtrl_1_1MemoryPort_a8a15a0ae9c080c5f879fc5e791a9e3e7}{recvTimingReq} (\hyperlink{classPacket}{PacketPtr})
\item 
virtual \hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classDRAMCtrl_1_1MemoryPort_a36cf113d5e5e091ebddb32306c098fae}{getAddrRanges} () const 
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classSlavePacketQueue}{SlavePacketQueue} \hyperlink{classDRAMCtrl_1_1MemoryPort_a3055168363a9ed42f38173363b6c1975}{queue}
\item 
\hyperlink{classDRAMCtrl_1_1DRAMCtrl}{DRAMCtrl} \& \hyperlink{classDRAMCtrl_1_1MemoryPort_aab24e4ab19c79062554e1ad4bb0c5eb7}{memory}
\end{DoxyCompactItemize}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classDRAMCtrl_1_1MemoryPort_aee0ee389785135af506951436ea56679}{
\index{DRAMCtrl::MemoryPort@{DRAMCtrl::MemoryPort}!MemoryPort@{MemoryPort}}
\index{MemoryPort@{MemoryPort}!DRAMCtrl::MemoryPort@{DRAMCtrl::MemoryPort}}
\subsubsection[{MemoryPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MemoryPort} (const std::string \& {\em name}, \/  {\bf DRAMCtrl} \& {\em \_\-memory})}}
\label{classDRAMCtrl_1_1MemoryPort_aee0ee389785135af506951436ea56679}



\begin{DoxyCode}
1758     : QueuedSlavePort(name, &_memory, queue), queue(_memory, *this),
1759       memory(_memory)
1760 { }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classDRAMCtrl_1_1MemoryPort_a36cf113d5e5e091ebddb32306c098fae}{
\index{DRAMCtrl::MemoryPort@{DRAMCtrl::MemoryPort}!getAddrRanges@{getAddrRanges}}
\index{getAddrRanges@{getAddrRanges}!DRAMCtrl::MemoryPort@{DRAMCtrl::MemoryPort}}
\subsubsection[{getAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRangeList} getAddrRanges () const\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classDRAMCtrl_1_1MemoryPort_a36cf113d5e5e091ebddb32306c098fae}
Get a list of the non-\/overlapping address ranges the owner is responsible for. All slave ports must override this function and return a populated list with at least one item.

\begin{DoxyReturn}{戻り値}
a list of ranges responded to 
\end{DoxyReturn}


\hyperlink{classSlavePort_a6e967f8921e80748eb2be35b6b481a7e}{SlavePort}を実装しています。


\begin{DoxyCode}
1764 {
1765     AddrRangeList ranges;
1766     ranges.push_back(memory.getAddrRange());
1767     return ranges;
1768 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_1_1MemoryPort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{
\index{DRAMCtrl::MemoryPort@{DRAMCtrl::MemoryPort}!recvAtomic@{recvAtomic}}
\index{recvAtomic@{recvAtomic}!DRAMCtrl::MemoryPort@{DRAMCtrl::MemoryPort}}
\subsubsection[{recvAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvAtomic ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classDRAMCtrl_1_1MemoryPort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}
Receive an atomic request packet from the master port. 

\hyperlink{classSlavePort_a428ab07671bc9372dc44a2487b12a726}{SlavePort}を実装しています。


\begin{DoxyCode}
1787 {
1788     return memory.recvAtomic(pkt);
1789 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_1_1MemoryPort_aeefa907fb6d6a787e6dab90e8138ea90}{
\index{DRAMCtrl::MemoryPort@{DRAMCtrl::MemoryPort}!recvFunctional@{recvFunctional}}
\index{recvFunctional@{recvFunctional}!DRAMCtrl::MemoryPort@{DRAMCtrl::MemoryPort}}
\subsubsection[{recvFunctional}]{\setlength{\rightskip}{0pt plus 5cm}void recvFunctional ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classDRAMCtrl_1_1MemoryPort_aeefa907fb6d6a787e6dab90e8138ea90}
Receive a functional request packet from the master port. 

\hyperlink{classSlavePort_a6a3d6f2e5dab6bed16d53d9e7c17378d}{SlavePort}を実装しています。


\begin{DoxyCode}
1772 {
1773     pkt->pushLabel(memory.name());
1774 
1775     if (!queue.checkFunctional(pkt)) {
1776         // Default implementation of SimpleTimingPort::recvFunctional()
1777         // calls recvAtomic() and throws away the latency; we can save a
1778         // little here by just not calculating the latency.
1779         memory.recvFunctional(pkt);
1780     }
1781 
1782     pkt->popLabel();
1783 }
\end{DoxyCode}
\hypertarget{classDRAMCtrl_1_1MemoryPort_a8a15a0ae9c080c5f879fc5e791a9e3e7}{
\index{DRAMCtrl::MemoryPort@{DRAMCtrl::MemoryPort}!recvTimingReq@{recvTimingReq}}
\index{recvTimingReq@{recvTimingReq}!DRAMCtrl::MemoryPort@{DRAMCtrl::MemoryPort}}
\subsubsection[{recvTimingReq}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingReq ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classDRAMCtrl_1_1MemoryPort_a8a15a0ae9c080c5f879fc5e791a9e3e7}
Receive a timing request from the master port. 

\hyperlink{classSlavePort_abcece77e42f88ee41af8d3d01bb48253}{SlavePort}を実装しています。


\begin{DoxyCode}
1793 {
1794     // pass it to the memory controller
1795     return memory.recvTimingReq(pkt);
1796 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classDRAMCtrl_1_1MemoryPort_aab24e4ab19c79062554e1ad4bb0c5eb7}{
\index{DRAMCtrl::MemoryPort@{DRAMCtrl::MemoryPort}!memory@{memory}}
\index{memory@{memory}!DRAMCtrl::MemoryPort@{DRAMCtrl::MemoryPort}}
\subsubsection[{memory}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DRAMCtrl}\& {\bf memory}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_1_1MemoryPort_aab24e4ab19c79062554e1ad4bb0c5eb7}
\hypertarget{classDRAMCtrl_1_1MemoryPort_a3055168363a9ed42f38173363b6c1975}{
\index{DRAMCtrl::MemoryPort@{DRAMCtrl::MemoryPort}!queue@{queue}}
\index{queue@{queue}!DRAMCtrl::MemoryPort@{DRAMCtrl::MemoryPort}}
\subsubsection[{queue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf SlavePacketQueue} {\bf queue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classDRAMCtrl_1_1MemoryPort_a3055168363a9ed42f38173363b6c1975}
\hyperlink{classPacket}{Packet} queue used to store outgoing requests and responses. 

\hyperlink{classQueuedSlavePort_a89fcdbe2ab63d24f2112bc7e05bf2413}{QueuedSlavePort}を再定義しています。

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{dram__ctrl_8hh}{dram\_\-ctrl.hh}\item 
mem/\hyperlink{dram__ctrl_8cc}{dram\_\-ctrl.cc}\end{DoxyCompactItemize}
