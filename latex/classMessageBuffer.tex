\hypertarget{classMessageBuffer}{
\section{クラス MessageBuffer}
\label{classMessageBuffer}\index{MessageBuffer@{MessageBuffer}}
}


{\ttfamily \#include $<$MessageBuffer.hh$>$}\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMessageBuffer_a3ab015b49b89f6f1e8c9facc8441976f}{MessageBuffer} (const std::string \&name=\char`\"{}\char`\"{})
\item 
std::string \hyperlink{classMessageBuffer_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classMessageBuffer_ad9be4b0fe9efff18c2e56a1705d99918}{setRecycleLatency} (\hyperlink{classCycles}{Cycles} recycle\_\-latency)
\item 
void \hyperlink{classMessageBuffer_ac8fc02d2f80c73a67e76577139daaaf9}{reanalyzeMessages} (const \hyperlink{classAddress}{Address} \&addr)
\item 
void \hyperlink{classMessageBuffer_adfdac0293f076193ea9e70b12b54ecbe}{reanalyzeAllMessages} ()
\item 
void \hyperlink{classMessageBuffer_abef10942dc67e1641651a1f9542b7303}{stallMessage} (const \hyperlink{classAddress}{Address} \&addr)
\item 
bool \hyperlink{classMessageBuffer_ac12eec09d47a89a1ddf3eb6bb19b5bd3}{isReady} () const 
\item 
void \hyperlink{classMessageBuffer_ae20106ccbc4569ff9474570932956f7f}{delayHead} ()
\item 
bool \hyperlink{classMessageBuffer_a3164aa5c5bbbd31b6b1963ef9c90756f}{areNSlotsAvailable} (unsigned int n)
\item 
int \hyperlink{classMessageBuffer_a8e1ac3494e27c30441640926f0f07b6f}{getPriority} ()
\item 
void \hyperlink{classMessageBuffer_a6f56c404ece2826d0b11ad759fdf0fb4}{setPriority} (int rank)
\item 
void \hyperlink{classMessageBuffer_a81e888318cb316e49e3b6c9989970bb0}{setConsumer} (\hyperlink{classConsumer}{Consumer} $\ast$consumer)
\item 
void \hyperlink{classMessageBuffer_a0a949993188bb0d51b80b714be944447}{setSender} (\hyperlink{classClockedObject}{ClockedObject} $\ast$obj)
\item 
void \hyperlink{classMessageBuffer_a1fbc695c465cc14aeb497a623951ba6d}{setReceiver} (\hyperlink{classClockedObject}{ClockedObject} $\ast$obj)
\item 
void \hyperlink{classMessageBuffer_a9cdbe64eebafb111a124edec55ed2340}{setDescription} (const std::string \&name)
\item 
std::string \hyperlink{classMessageBuffer_a73da75c3e5ec30855a02eae2ba824e38}{getDescription} ()
\item 
\hyperlink{classConsumer}{Consumer} $\ast$ \hyperlink{classMessageBuffer_a2417fc7252a612b5c976ceaa2d1be4f7}{getConsumer} ()
\item 
const \hyperlink{classMessage}{Message} $\ast$ \hyperlink{classMessageBuffer_a5e133f7f4632eccf4bb7145962bc89ca}{peek} () const 
\item 
const \hyperlink{classRefCountingPtr}{MsgPtr} \& \hyperlink{classMessageBuffer_add248ff5db7f0e5dac1501da94c4c83e}{peekMsgPtr} () const 
\item 
void \hyperlink{classMessageBuffer_a3e66951ea4f67cc6837309bf2c962ad4}{enqueue} (\hyperlink{classRefCountingPtr}{MsgPtr} message)
\item 
void \hyperlink{classMessageBuffer_acac1ced7e82669dca7bb95e66ca54fb9}{enqueue} (\hyperlink{classRefCountingPtr}{MsgPtr} message, \hyperlink{classCycles}{Cycles} delta)
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classMessageBuffer_af900ed471b929eca9aa2649b378086ba}{dequeue} ()
\item 
void \hyperlink{classMessageBuffer_a98102238652df03cf871c9766de96af2}{recycle} ()
\item 
bool \hyperlink{classMessageBuffer_a479432127ee77145cc19d6a2d1590821}{isEmpty} () const 
\item 
void \hyperlink{classMessageBuffer_ae93cbe20820d1830a52fceed6a4407dc}{setOrdering} (bool order)
\item 
void \hyperlink{classMessageBuffer_a80ad9f22f168208fada0b5d4b332e6a9}{resize} (unsigned int size)
\item 
unsigned int \hyperlink{classMessageBuffer_a5301d277181ca5f033a81035ff20c76b}{getSize} ()
\item 
void \hyperlink{classMessageBuffer_a746f6cbcd8fa14109bb37712f8dbd210}{setRandomization} (bool random\_\-flag)
\item 
void \hyperlink{classMessageBuffer_ac8bb3912a3ce86b15842e79d0b421204}{clear} ()
\item 
void \hyperlink{classMessageBuffer_ac55fe386a101fbae38c716067c9966a0}{print} (std::ostream \&out) const 
\item 
void \hyperlink{classMessageBuffer_ac7ec7476159db4e2bb0372e30010fc9e}{clearStats} ()
\item 
void \hyperlink{classMessageBuffer_aee0eb866227b5e46be9a2c51c22bcb88}{setIncomingLink} (int link\_\-id)
\item 
void \hyperlink{classMessageBuffer_a528d693acf172c3acd1f7fbf73a463f9}{setVnet} (int net)
\item 
bool \hyperlink{classMessageBuffer_a729f57f557bb42c045c47d9388f1030e}{functionalRead} (\hyperlink{classPacket}{Packet} $\ast$pkt)
\item 
\hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classMessageBuffer_ad07b9def1d6f5e5f988a254c3a9d1ad9}{functionalWrite} (\hyperlink{classPacket}{Packet} $\ast$pkt)
\end{DoxyCompactItemize}
\subsection*{Private 型}
\begin{DoxyCompactItemize}
\item 
typedef std::map$<$ \hyperlink{classAddress}{Address}, \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classRefCountingPtr}{MsgPtr} $>$ $>$ \hyperlink{classMessageBuffer_a4f77caf961eb3357bbaa1534420e8213}{StallMsgMapType}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classMessageBuffer_ac278f790c547f9db8b4bedc853b8ae63}{reanalyzeList} (\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classRefCountingPtr}{MsgPtr} $>$ \&, \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick})
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classMessageBuffer_a896a9ceedfb77c22a82b490f05ae4624}{m\_\-recycle\_\-latency}
\item 
\hyperlink{classClockedObject}{ClockedObject} $\ast$ \hyperlink{classMessageBuffer_a8c9e563cbbe6ea97e8c1357a2dcce427}{m\_\-sender}
\begin{DoxyCompactList}\small\item\em The two ends of the buffer. \item\end{DoxyCompactList}\item 
\hyperlink{classClockedObject}{ClockedObject} $\ast$ \hyperlink{classMessageBuffer_a18393ec7ec37465d3c43d1de61fe7ea1}{m\_\-receiver}
\item 
\hyperlink{classConsumer}{Consumer} $\ast$ \hyperlink{classMessageBuffer_a138db353766834771d05a09ab273f245}{m\_\-consumer}
\begin{DoxyCompactList}\small\item\em \hyperlink{classConsumer}{Consumer} to signal a wakeup(), can be NULL. \item\end{DoxyCompactList}\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMessageBufferNode}{MessageBufferNode} $>$ \hyperlink{classMessageBuffer_ab02596c3ecacf48c081c7188a2e304ab}{m\_\-prio\_\-heap}
\item 
\hyperlink{classMessageBuffer_a4f77caf961eb3357bbaa1534420e8213}{StallMsgMapType} \hyperlink{classMessageBuffer_a588564bc2c906eaf69f9b34f18ff18ea}{m\_\-stall\_\-msg\_\-map}
\item 
std::string \hyperlink{classMessageBuffer_adb41893ba19e889e56c559f25fc1a68a}{m\_\-name}
\item 
unsigned int \hyperlink{classMessageBuffer_ac6512ff5a4845e1c7accef18b576f810}{m\_\-max\_\-size}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classMessageBuffer_a040f6bbf3cb647d2363ac247e2076126}{m\_\-time\_\-last\_\-time\_\-size\_\-checked}
\item 
unsigned int \hyperlink{classMessageBuffer_ad240a365b18b543a74ce40475a9e7d74}{m\_\-size\_\-last\_\-time\_\-size\_\-checked}
\item 
\hyperlink{classCycles}{Cycles} \hyperlink{classMessageBuffer_ad99d9b33ed6c9adbe0b672c6af0a5bf7}{m\_\-time\_\-last\_\-time\_\-enqueue}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classMessageBuffer_a6d825eaf3c6cf89227a953fcb5e91af3}{m\_\-time\_\-last\_\-time\_\-pop}
\item 
\hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classMessageBuffer_a691773cf753228bbb617fc07019c45bb}{m\_\-last\_\-arrival\_\-time}
\item 
unsigned int \hyperlink{classMessageBuffer_ad4ef3631d539c1c0a0434b51bdabf68c}{m\_\-size\_\-at\_\-cycle\_\-start}
\item 
unsigned int \hyperlink{classMessageBuffer_af37dc7ab69d718640e0622b64136543f}{m\_\-msgs\_\-this\_\-cycle}
\item 
int \hyperlink{classMessageBuffer_adb933651b11421e2e911a352db8edc94}{m\_\-not\_\-avail\_\-count}
\item 
\hyperlink{TypeDefines_8hh_a29940ae63ec06c9998bba873e25407ad}{uint64} \hyperlink{classMessageBuffer_a3ee0247e7b99d743ac9ec4d45edba8af}{m\_\-msg\_\-counter}
\item 
int \hyperlink{classMessageBuffer_a4ac5345a63b7618a47b477b57cde5ca0}{m\_\-priority\_\-rank}
\item 
bool \hyperlink{classMessageBuffer_a2d9ad769da997d66f23de51048f90566}{m\_\-strict\_\-fifo}
\item 
bool \hyperlink{classMessageBuffer_ae6fd7f88210bae2cdbd67370062be24c}{m\_\-ordering\_\-set}
\item 
bool \hyperlink{classMessageBuffer_aa846ca9467116a26a879dc4b262cf36a}{m\_\-randomization}
\item 
int \hyperlink{classMessageBuffer_ad214be76cbb069cc3acb2a843fffb26f}{m\_\-input\_\-link\_\-id}
\item 
int \hyperlink{classMessageBuffer_a3cd373167bcac343aba16bd3525cc0a2}{m\_\-vnet\_\-id}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classMessageBuffer_a4f77caf961eb3357bbaa1534420e8213}{
\index{MessageBuffer@{MessageBuffer}!StallMsgMapType@{StallMsgMapType}}
\index{StallMsgMapType@{StallMsgMapType}!MessageBuffer@{MessageBuffer}}
\subsubsection[{StallMsgMapType}]{\setlength{\rightskip}{0pt plus 5cm}typedef std::map$<$ {\bf Address}, {\bf std::list}$<${\bf MsgPtr}$>$ $>$ {\bf StallMsgMapType}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_a4f77caf961eb3357bbaa1534420e8213}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classMessageBuffer_a3ab015b49b89f6f1e8c9facc8441976f}{
\index{MessageBuffer@{MessageBuffer}!MessageBuffer@{MessageBuffer}}
\index{MessageBuffer@{MessageBuffer}!MessageBuffer@{MessageBuffer}}
\subsubsection[{MessageBuffer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf MessageBuffer} (const std::string \& {\em name} = {\ttfamily \char`\"{}\char`\"{}})}}
\label{classMessageBuffer_a3ab015b49b89f6f1e8c9facc8441976f}


\subsection{関数}
\hypertarget{classMessageBuffer_a3164aa5c5bbbd31b6b1963ef9c90756f}{
\index{MessageBuffer@{MessageBuffer}!areNSlotsAvailable@{areNSlotsAvailable}}
\index{areNSlotsAvailable@{areNSlotsAvailable}!MessageBuffer@{MessageBuffer}}
\subsubsection[{areNSlotsAvailable}]{\setlength{\rightskip}{0pt plus 5cm}bool areNSlotsAvailable (unsigned int {\em n})}}
\label{classMessageBuffer_a3164aa5c5bbbd31b6b1963ef9c90756f}



\begin{DoxyCode}
79 {
80 
81     // fast path when message buffers have infinite size
82     if (m_max_size == 0) {
83         return true;
84     }
85 
86     // determine the correct size for the current cycle
87     // pop operations shouldn't effect the network's visible size
88     // until next cycle, but enqueue operations effect the visible
89     // size immediately
90     unsigned int current_size = 0;
91 
92     if (m_time_last_time_pop < m_sender->clockEdge()) {
93         // no pops this cycle - heap size is correct
94         current_size = m_prio_heap.size();
95     } else {
96         if (m_time_last_time_enqueue < m_sender->curCycle()) {
97             // no enqueues this cycle - m_size_at_cycle_start is correct
98             current_size = m_size_at_cycle_start;
99         } else {
100             // both pops and enqueues occured this cycle - add new
101             // enqueued msgs to m_size_at_cycle_start
102             current_size = m_size_at_cycle_start + m_msgs_this_cycle;
103         }
104     }
105 
106     // now compare the new size with our max size
107     if (current_size + n <= m_max_size) {
108         return true;
109     } else {
110         DPRINTF(RubyQueue, "n: %d, current_size: %d, heap size: %d, "
111                 "m_max_size: %d\n",
112                 n, current_size, m_prio_heap.size(), m_max_size);
113         m_not_avail_count++;
114         return false;
115     }
116 }
\end{DoxyCode}
\hypertarget{classMessageBuffer_ac8bb3912a3ce86b15842e79d0b421204}{
\index{MessageBuffer@{MessageBuffer}!clear@{clear}}
\index{clear@{clear}!MessageBuffer@{MessageBuffer}}
\subsubsection[{clear}]{\setlength{\rightskip}{0pt plus 5cm}void clear ()}}
\label{classMessageBuffer_ac8bb3912a3ce86b15842e79d0b421204}



\begin{DoxyCode}
252 {
253     m_prio_heap.clear();
254 
255     m_msg_counter = 0;
256     m_time_last_time_enqueue = Cycles(0);
257     m_time_last_time_pop = 0;
258     m_size_at_cycle_start = 0;
259     m_msgs_this_cycle = 0;
260 }
\end{DoxyCode}
\hypertarget{classMessageBuffer_ac7ec7476159db4e2bb0372e30010fc9e}{
\index{MessageBuffer@{MessageBuffer}!clearStats@{clearStats}}
\index{clearStats@{clearStats}!MessageBuffer@{MessageBuffer}}
\subsubsection[{clearStats}]{\setlength{\rightskip}{0pt plus 5cm}void clearStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_ac7ec7476159db4e2bb0372e30010fc9e}



\begin{DoxyCode}
141 { m_not_avail_count = 0; m_msg_counter = 0; }
\end{DoxyCode}
\hypertarget{classMessageBuffer_ae20106ccbc4569ff9474570932956f7f}{
\index{MessageBuffer@{MessageBuffer}!delayHead@{delayHead}}
\index{delayHead@{delayHead}!MessageBuffer@{MessageBuffer}}
\subsubsection[{delayHead}]{\setlength{\rightskip}{0pt plus 5cm}void delayHead ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_ae20106ccbc4569ff9474570932956f7f}



\begin{DoxyCode}
69     {
70         MessageBufferNode node = m_prio_heap.front();
71         std::pop_heap(m_prio_heap.begin(), m_prio_heap.end(),
72                       std::greater<MessageBufferNode>());
73         m_prio_heap.pop_back();
74         enqueue(node.m_msgptr, Cycles(1));
75     }
\end{DoxyCode}
\hypertarget{classMessageBuffer_af900ed471b929eca9aa2649b378086ba}{
\index{MessageBuffer@{MessageBuffer}!dequeue@{dequeue}}
\index{dequeue@{dequeue}!MessageBuffer@{MessageBuffer}}
\subsubsection[{dequeue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} dequeue ()}}
\label{classMessageBuffer_af900ed471b929eca9aa2649b378086ba}
Updates the delay cycles of the message at the head of the queue, removes it from the queue and returns its total delay. 


\begin{DoxyCode}
224 {
225     DPRINTF(RubyQueue, "Popping\n");
226     assert(isReady());
227 
228     // get MsgPtr of the message about to be dequeued
229     MsgPtr message = m_prio_heap.front().m_msgptr;
230 
231     // get the delay cycles
232     message->updateDelayedTicks(m_receiver->clockEdge());
233     Cycles delayCycles =
234         m_receiver->ticksToCycles(message->getDelayedTicks());
235 
236     // record previous size and time so the current buffer size isn't
237     // adjusted until next cycle
238     if (m_time_last_time_pop < m_receiver->clockEdge()) {
239         m_size_at_cycle_start = m_prio_heap.size();
240         m_time_last_time_pop = m_receiver->clockEdge();
241     }
242 
243     pop_heap(m_prio_heap.begin(), m_prio_heap.end(),
244         greater<MessageBufferNode>());
245     m_prio_heap.pop_back();
246 
247     return delayCycles;
248 }
\end{DoxyCode}
\hypertarget{classMessageBuffer_acac1ced7e82669dca7bb95e66ca54fb9}{
\index{MessageBuffer@{MessageBuffer}!enqueue@{enqueue}}
\index{enqueue@{enqueue}!MessageBuffer@{MessageBuffer}}
\subsubsection[{enqueue}]{\setlength{\rightskip}{0pt plus 5cm}void enqueue ({\bf MsgPtr} {\em message}, \/  {\bf Cycles} {\em delta})}}
\label{classMessageBuffer_acac1ced7e82669dca7bb95e66ca54fb9}



\begin{DoxyCode}
145 {
146     m_msg_counter++;
147 
148     // record current time incase we have a pop that also adjusts my size
149     if (m_time_last_time_enqueue < m_sender->curCycle()) {
150         m_msgs_this_cycle = 0;  // first msg this cycle
151         m_time_last_time_enqueue = m_sender->curCycle();
152     }
153     m_msgs_this_cycle++;
154 
155     assert(m_ordering_set);
156 
157     // Calculate the arrival time of the message, that is, the first
158     // cycle the message can be dequeued.
159     assert(delta > 0);
160     Tick current_time = m_sender->clockEdge();
161     Tick arrival_time = 0;
162 
163     if (!RubySystem::getRandomization() || !m_randomization) {
164         // No randomization
165         arrival_time = current_time + delta * m_sender->clockPeriod();
166     } else {
167         // Randomization - ignore delta
168         if (m_strict_fifo) {
169             if (m_last_arrival_time < current_time) {
170                 m_last_arrival_time = current_time;
171             }
172             arrival_time = m_last_arrival_time +
173                            random_time() * m_sender->clockPeriod();
174         } else {
175             arrival_time = current_time +
176                            random_time() * m_sender->clockPeriod();
177         }
178     }
179 
180     // Check the arrival time
181     assert(arrival_time > current_time);
182     if (m_strict_fifo) {
183         if (arrival_time < m_last_arrival_time) {
184             panic("FIFO ordering violated: %s name: %s current time: %d "
185                   "delta: %d arrival_time: %d last arrival_time: %d\n",
186                   *this, m_name, current_time,
187                   delta * m_sender->clockPeriod(),
188                   arrival_time, m_last_arrival_time);
189         }
190     }
191 
192     // If running a cache trace, don't worry about the last arrival checks
193     if (!g_system_ptr->m_warmup_enabled) {
194         m_last_arrival_time = arrival_time;
195     }
196 
197     // compute the delay cycles and set enqueue time
198     Message* msg_ptr = message.get();
199     assert(msg_ptr != NULL);
200 
201     assert(m_sender->clockEdge() >= msg_ptr->getLastEnqueueTime() &&
202            "ensure we aren't dequeued early");
203 
204     msg_ptr->updateDelayedTicks(m_sender->clockEdge());
205     msg_ptr->setLastEnqueueTime(arrival_time);
206 
207     // Insert the message into the priority heap
208     MessageBufferNode thisNode(arrival_time, m_msg_counter, message);
209     m_prio_heap.push_back(thisNode);
210     push_heap(m_prio_heap.begin(), m_prio_heap.end(),
211         greater<MessageBufferNode>());
212 
213     DPRINTF(RubyQueue, "Enqueue arrival_time: %lld, Message: %s\n",
214             arrival_time, *(message.get()));
215 
216     // Schedule the wakeup
217     assert(m_consumer != NULL);
218     m_consumer->scheduleEventAbsolute(arrival_time);
219     m_consumer->storeEventInfo(m_vnet_id);
220 }
\end{DoxyCode}
\hypertarget{classMessageBuffer_a3e66951ea4f67cc6837309bf2c962ad4}{
\index{MessageBuffer@{MessageBuffer}!enqueue@{enqueue}}
\index{enqueue@{enqueue}!MessageBuffer@{MessageBuffer}}
\subsubsection[{enqueue}]{\setlength{\rightskip}{0pt plus 5cm}void enqueue ({\bf MsgPtr} {\em message})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_a3e66951ea4f67cc6837309bf2c962ad4}



\begin{DoxyCode}
118 { enqueue(message, Cycles(1)); }
\end{DoxyCode}
\hypertarget{classMessageBuffer_a729f57f557bb42c045c47d9388f1030e}{
\index{MessageBuffer@{MessageBuffer}!functionalRead@{functionalRead}}
\index{functionalRead@{functionalRead}!MessageBuffer@{MessageBuffer}}
\subsubsection[{functionalRead}]{\setlength{\rightskip}{0pt plus 5cm}bool functionalRead ({\bf Packet} $\ast$ {\em pkt})}}
\label{classMessageBuffer_a729f57f557bb42c045c47d9388f1030e}



\begin{DoxyCode}
367 {
368     // Check the priority heap and read any messages that may
369     // correspond to the address in the packet.
370     for (unsigned int i = 0; i < m_prio_heap.size(); ++i) {
371         Message *msg = m_prio_heap[i].m_msgptr.get();
372         if (msg->functionalRead(pkt)) return true;
373     }
374 
375     // Read the messages in the stall queue that correspond
376     // to the address in the packet.
377     for (StallMsgMapType::iterator map_iter = m_stall_msg_map.begin();
378          map_iter != m_stall_msg_map.end();
379          ++map_iter) {
380 
381         for (std::list<MsgPtr>::iterator it = (map_iter->second).begin();
382             it != (map_iter->second).end(); ++it) {
383 
384             Message *msg = (*it).get();
385             if (msg->functionalRead(pkt)) return true;
386         }
387     }
388     return false;
389 }
\end{DoxyCode}
\hypertarget{classMessageBuffer_ad07b9def1d6f5e5f988a254c3a9d1ad9}{
\index{MessageBuffer@{MessageBuffer}!functionalWrite@{functionalWrite}}
\index{functionalWrite@{functionalWrite}!MessageBuffer@{MessageBuffer}}
\subsubsection[{functionalWrite}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint32\_\-t} functionalWrite ({\bf Packet} $\ast$ {\em pkt})}}
\label{classMessageBuffer_ad07b9def1d6f5e5f988a254c3a9d1ad9}



\begin{DoxyCode}
393 {
394     uint32_t num_functional_writes = 0;
395 
396     // Check the priority heap and write any messages that may
397     // correspond to the address in the packet.
398     for (unsigned int i = 0; i < m_prio_heap.size(); ++i) {
399         Message *msg = m_prio_heap[i].m_msgptr.get();
400         if (msg->functionalWrite(pkt)) {
401             num_functional_writes++;
402         }
403     }
404 
405     // Check the stall queue and write any messages that may
406     // correspond to the address in the packet.
407     for (StallMsgMapType::iterator map_iter = m_stall_msg_map.begin();
408          map_iter != m_stall_msg_map.end();
409          ++map_iter) {
410 
411         for (std::list<MsgPtr>::iterator it = (map_iter->second).begin();
412             it != (map_iter->second).end(); ++it) {
413 
414             Message *msg = (*it).get();
415             if (msg->functionalWrite(pkt)) {
416                 num_functional_writes++;
417             }
418         }
419     }
420 
421     return num_functional_writes;
422 }
\end{DoxyCode}
\hypertarget{classMessageBuffer_a2417fc7252a612b5c976ceaa2d1be4f7}{
\index{MessageBuffer@{MessageBuffer}!getConsumer@{getConsumer}}
\index{getConsumer@{getConsumer}!MessageBuffer@{MessageBuffer}}
\subsubsection[{getConsumer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Consumer}$\ast$ getConsumer ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_a2417fc7252a612b5c976ceaa2d1be4f7}



\begin{DoxyCode}
105 { return m_consumer; }
\end{DoxyCode}
\hypertarget{classMessageBuffer_a73da75c3e5ec30855a02eae2ba824e38}{
\index{MessageBuffer@{MessageBuffer}!getDescription@{getDescription}}
\index{getDescription@{getDescription}!MessageBuffer@{MessageBuffer}}
\subsubsection[{getDescription}]{\setlength{\rightskip}{0pt plus 5cm}std::string getDescription ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_a73da75c3e5ec30855a02eae2ba824e38}



\begin{DoxyCode}
103 { return m_name;}
\end{DoxyCode}
\hypertarget{classMessageBuffer_a8e1ac3494e27c30441640926f0f07b6f}{
\index{MessageBuffer@{MessageBuffer}!getPriority@{getPriority}}
\index{getPriority@{getPriority}!MessageBuffer@{MessageBuffer}}
\subsubsection[{getPriority}]{\setlength{\rightskip}{0pt plus 5cm}int getPriority ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_a8e1ac3494e27c30441640926f0f07b6f}



\begin{DoxyCode}
78 { return m_priority_rank; }
\end{DoxyCode}
\hypertarget{classMessageBuffer_a5301d277181ca5f033a81035ff20c76b}{
\index{MessageBuffer@{MessageBuffer}!getSize@{getSize}}
\index{getSize@{getSize}!MessageBuffer@{MessageBuffer}}
\subsubsection[{getSize}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int getSize ()}}
\label{classMessageBuffer_a5301d277181ca5f033a81035ff20c76b}



\begin{DoxyCode}
68 {
69     if (m_time_last_time_size_checked != m_receiver->curCycle()) {
70         m_time_last_time_size_checked = m_receiver->curCycle();
71         m_size_last_time_size_checked = m_prio_heap.size();
72     }
73 
74     return m_size_last_time_size_checked;
75 }
\end{DoxyCode}
\hypertarget{classMessageBuffer_a479432127ee77145cc19d6a2d1590821}{
\index{MessageBuffer@{MessageBuffer}!isEmpty@{isEmpty}}
\index{isEmpty@{isEmpty}!MessageBuffer@{MessageBuffer}}
\subsubsection[{isEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool isEmpty () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_a479432127ee77145cc19d6a2d1590821}



\begin{DoxyCode}
126 { return m_prio_heap.size() == 0; }
\end{DoxyCode}
\hypertarget{classMessageBuffer_ac12eec09d47a89a1ddf3eb6bb19b5bd3}{
\index{MessageBuffer@{MessageBuffer}!isReady@{isReady}}
\index{isReady@{isReady}!MessageBuffer@{MessageBuffer}}
\subsubsection[{isReady}]{\setlength{\rightskip}{0pt plus 5cm}bool isReady () const}}
\label{classMessageBuffer_ac12eec09d47a89a1ddf3eb6bb19b5bd3}



\begin{DoxyCode}
360 {
361     return ((m_prio_heap.size() > 0) &&
362             (m_prio_heap.front().m_time <= m_receiver->clockEdge()));
363 }
\end{DoxyCode}
\hypertarget{classMessageBuffer_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{MessageBuffer@{MessageBuffer}!name@{name}}
\index{name@{name}!MessageBuffer@{MessageBuffer}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_a37627d5d5bba7f4a8690c71c2ab3cb07}



\begin{DoxyCode}
55 { return m_name; }
\end{DoxyCode}
\hypertarget{classMessageBuffer_a5e133f7f4632eccf4bb7145962bc89ca}{
\index{MessageBuffer@{MessageBuffer}!peek@{peek}}
\index{peek@{peek}!MessageBuffer@{MessageBuffer}}
\subsubsection[{peek}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Message} $\ast$ peek () const}}
\label{classMessageBuffer_a5e133f7f4632eccf4bb7145962bc89ca}
Function for extracting the message at the head of the message queue. The function assumes that the queue is nonempty. 


\begin{DoxyCode}
120 {
121     DPRINTF(RubyQueue, "Peeking at head of queue.\n");
122     assert(isReady());
123 
124     const Message* msg_ptr = m_prio_heap.front().m_msgptr.get();
125     assert(msg_ptr);
126 
127     DPRINTF(RubyQueue, "Message: %s\n", (*msg_ptr));
128     return msg_ptr;
129 }
\end{DoxyCode}
\hypertarget{classMessageBuffer_add248ff5db7f0e5dac1501da94c4c83e}{
\index{MessageBuffer@{MessageBuffer}!peekMsgPtr@{peekMsgPtr}}
\index{peekMsgPtr@{peekMsgPtr}!MessageBuffer@{MessageBuffer}}
\subsubsection[{peekMsgPtr}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf MsgPtr}\& peekMsgPtr () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_add248ff5db7f0e5dac1501da94c4c83e}



\begin{DoxyCode}
113     {
114         assert(isReady());
115         return m_prio_heap.front().m_msgptr;
116     }
\end{DoxyCode}
\hypertarget{classMessageBuffer_ac55fe386a101fbae38c716067c9966a0}{
\index{MessageBuffer@{MessageBuffer}!print@{print}}
\index{print@{print}!MessageBuffer@{MessageBuffer}}
\subsubsection[{print}]{\setlength{\rightskip}{0pt plus 5cm}void print (std::ostream \& {\em out}) const}}
\label{classMessageBuffer_ac55fe386a101fbae38c716067c9966a0}
\hypertarget{classMessageBuffer_adfdac0293f076193ea9e70b12b54ecbe}{
\index{MessageBuffer@{MessageBuffer}!reanalyzeAllMessages@{reanalyzeAllMessages}}
\index{reanalyzeAllMessages@{reanalyzeAllMessages}!MessageBuffer@{MessageBuffer}}
\subsubsection[{reanalyzeAllMessages}]{\setlength{\rightskip}{0pt plus 5cm}void reanalyzeAllMessages ()}}
\label{classMessageBuffer_adfdac0293f076193ea9e70b12b54ecbe}



\begin{DoxyCode}
312 {
313     DPRINTF(RubyQueue, "ReanalyzeAllMessages\n");
314     Tick nextTick = m_receiver->clockEdge(Cycles(1));
315 
316     //
317     // Put all stalled messages associated with this address back on the
318     // prio heap
319     //
320     for (StallMsgMapType::iterator map_iter = m_stall_msg_map.begin();
321          map_iter != m_stall_msg_map.end(); ++map_iter) {
322         reanalyzeList(map_iter->second, nextTick);
323     }
324     m_stall_msg_map.clear();
325 }
\end{DoxyCode}
\hypertarget{classMessageBuffer_ac278f790c547f9db8b4bedc853b8ae63}{
\index{MessageBuffer@{MessageBuffer}!reanalyzeList@{reanalyzeList}}
\index{reanalyzeList@{reanalyzeList}!MessageBuffer@{MessageBuffer}}
\subsubsection[{reanalyzeList}]{\setlength{\rightskip}{0pt plus 5cm}void reanalyzeList ({\bf std::list}$<$ {\bf MsgPtr} $>$ \& {\em lt}, \/  {\bf Tick} {\em nextTick})\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_ac278f790c547f9db8b4bedc853b8ae63}



\begin{DoxyCode}
281 {
282     while(!lt.empty()) {
283         m_msg_counter++;
284         MessageBufferNode msgNode(nextTick, m_msg_counter, lt.front());
285 
286         m_prio_heap.push_back(msgNode);
287         push_heap(m_prio_heap.begin(), m_prio_heap.end(),
288                   greater<MessageBufferNode>());
289 
290         m_consumer->scheduleEventAbsolute(nextTick);
291         lt.pop_front();
292     }
293 }
\end{DoxyCode}
\hypertarget{classMessageBuffer_ac8fc02d2f80c73a67e76577139daaaf9}{
\index{MessageBuffer@{MessageBuffer}!reanalyzeMessages@{reanalyzeMessages}}
\index{reanalyzeMessages@{reanalyzeMessages}!MessageBuffer@{MessageBuffer}}
\subsubsection[{reanalyzeMessages}]{\setlength{\rightskip}{0pt plus 5cm}void reanalyzeMessages (const {\bf Address} \& {\em addr})}}
\label{classMessageBuffer_ac8fc02d2f80c73a67e76577139daaaf9}



\begin{DoxyCode}
297 {
298     DPRINTF(RubyQueue, "ReanalyzeMessages\n");
299     assert(m_stall_msg_map.count(addr) > 0);
300     Tick nextTick = m_receiver->clockEdge(Cycles(1));
301 
302     //
303     // Put all stalled messages associated with this address back on the
304     // prio heap
305     //
306     reanalyzeList(m_stall_msg_map[addr], nextTick);
307     m_stall_msg_map.erase(addr);
308 }
\end{DoxyCode}
\hypertarget{classMessageBuffer_a98102238652df03cf871c9766de96af2}{
\index{MessageBuffer@{MessageBuffer}!recycle@{recycle}}
\index{recycle@{recycle}!MessageBuffer@{MessageBuffer}}
\subsubsection[{recycle}]{\setlength{\rightskip}{0pt plus 5cm}void recycle ()}}
\label{classMessageBuffer_a98102238652df03cf871c9766de96af2}



\begin{DoxyCode}
264 {
265     DPRINTF(RubyQueue, "Recycling.\n");
266     assert(isReady());
267     MessageBufferNode node = m_prio_heap.front();
268     pop_heap(m_prio_heap.begin(), m_prio_heap.end(),
269         greater<MessageBufferNode>());
270 
271     node.m_time = m_receiver->clockEdge(m_recycle_latency);
272     m_prio_heap.back() = node;
273     push_heap(m_prio_heap.begin(), m_prio_heap.end(),
274         greater<MessageBufferNode>());
275     m_consumer->
276         scheduleEventAbsolute(m_receiver->clockEdge(m_recycle_latency));
277 }
\end{DoxyCode}
\hypertarget{classMessageBuffer_a80ad9f22f168208fada0b5d4b332e6a9}{
\index{MessageBuffer@{MessageBuffer}!resize@{resize}}
\index{resize@{resize}!MessageBuffer@{MessageBuffer}}
\subsubsection[{resize}]{\setlength{\rightskip}{0pt plus 5cm}void resize (unsigned int {\em size})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_a80ad9f22f168208fada0b5d4b332e6a9}



\begin{DoxyCode}
135 { m_max_size = size; }
\end{DoxyCode}
\hypertarget{classMessageBuffer_a81e888318cb316e49e3b6c9989970bb0}{
\index{MessageBuffer@{MessageBuffer}!setConsumer@{setConsumer}}
\index{setConsumer@{setConsumer}!MessageBuffer@{MessageBuffer}}
\subsubsection[{setConsumer}]{\setlength{\rightskip}{0pt plus 5cm}void setConsumer ({\bf Consumer} $\ast$ {\em consumer})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_a81e888318cb316e49e3b6c9989970bb0}



\begin{DoxyCode}
81     {
82         if (m_consumer != NULL) {
83             fatal("Trying to connect %s to MessageBuffer %s. \
84                   \n%s already connected. Check the cntrl_id's.\n",
85                   *consumer, *this, *m_consumer);
86         }
87         m_consumer = consumer;
88     }
\end{DoxyCode}
\hypertarget{classMessageBuffer_a9cdbe64eebafb111a124edec55ed2340}{
\index{MessageBuffer@{MessageBuffer}!setDescription@{setDescription}}
\index{setDescription@{setDescription}!MessageBuffer@{MessageBuffer}}
\subsubsection[{setDescription}]{\setlength{\rightskip}{0pt plus 5cm}void setDescription (const std::string \& {\em name})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_a9cdbe64eebafb111a124edec55ed2340}



\begin{DoxyCode}
102 { m_name = name; }
\end{DoxyCode}
\hypertarget{classMessageBuffer_aee0eb866227b5e46be9a2c51c22bcb88}{
\index{MessageBuffer@{MessageBuffer}!setIncomingLink@{setIncomingLink}}
\index{setIncomingLink@{setIncomingLink}!MessageBuffer@{MessageBuffer}}
\subsubsection[{setIncomingLink}]{\setlength{\rightskip}{0pt plus 5cm}void setIncomingLink (int {\em link\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_aee0eb866227b5e46be9a2c51c22bcb88}



\begin{DoxyCode}
143 { m_input_link_id = link_id; }
\end{DoxyCode}
\hypertarget{classMessageBuffer_ae93cbe20820d1830a52fceed6a4407dc}{
\index{MessageBuffer@{MessageBuffer}!setOrdering@{setOrdering}}
\index{setOrdering@{setOrdering}!MessageBuffer@{MessageBuffer}}
\subsubsection[{setOrdering}]{\setlength{\rightskip}{0pt plus 5cm}void setOrdering (bool {\em order})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_ae93cbe20820d1830a52fceed6a4407dc}



\begin{DoxyCode}
130     {
131         m_strict_fifo = order;
132         m_ordering_set = true;
133     }
\end{DoxyCode}
\hypertarget{classMessageBuffer_a6f56c404ece2826d0b11ad759fdf0fb4}{
\index{MessageBuffer@{MessageBuffer}!setPriority@{setPriority}}
\index{setPriority@{setPriority}!MessageBuffer@{MessageBuffer}}
\subsubsection[{setPriority}]{\setlength{\rightskip}{0pt plus 5cm}void setPriority (int {\em rank})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_a6f56c404ece2826d0b11ad759fdf0fb4}



\begin{DoxyCode}
79 { m_priority_rank = rank; }
\end{DoxyCode}
\hypertarget{classMessageBuffer_a746f6cbcd8fa14109bb37712f8dbd210}{
\index{MessageBuffer@{MessageBuffer}!setRandomization@{setRandomization}}
\index{setRandomization@{setRandomization}!MessageBuffer@{MessageBuffer}}
\subsubsection[{setRandomization}]{\setlength{\rightskip}{0pt plus 5cm}void setRandomization (bool {\em random\_\-flag})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_a746f6cbcd8fa14109bb37712f8dbd210}



\begin{DoxyCode}
137 { m_randomization = random_flag; }
\end{DoxyCode}
\hypertarget{classMessageBuffer_a1fbc695c465cc14aeb497a623951ba6d}{
\index{MessageBuffer@{MessageBuffer}!setReceiver@{setReceiver}}
\index{setReceiver@{setReceiver}!MessageBuffer@{MessageBuffer}}
\subsubsection[{setReceiver}]{\setlength{\rightskip}{0pt plus 5cm}void setReceiver ({\bf ClockedObject} $\ast$ {\em obj})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_a1fbc695c465cc14aeb497a623951ba6d}



\begin{DoxyCode}
97     {
98         assert(m_receiver == NULL || m_receiver == obj);
99         m_receiver = obj;
100     }
\end{DoxyCode}
\hypertarget{classMessageBuffer_ad9be4b0fe9efff18c2e56a1705d99918}{
\index{MessageBuffer@{MessageBuffer}!setRecycleLatency@{setRecycleLatency}}
\index{setRecycleLatency@{setRecycleLatency}!MessageBuffer@{MessageBuffer}}
\subsubsection[{setRecycleLatency}]{\setlength{\rightskip}{0pt plus 5cm}void setRecycleLatency ({\bf Cycles} {\em recycle\_\-latency})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_ad9be4b0fe9efff18c2e56a1705d99918}



\begin{DoxyCode}
58     { m_recycle_latency = recycle_latency; }
\end{DoxyCode}
\hypertarget{classMessageBuffer_a0a949993188bb0d51b80b714be944447}{
\index{MessageBuffer@{MessageBuffer}!setSender@{setSender}}
\index{setSender@{setSender}!MessageBuffer@{MessageBuffer}}
\subsubsection[{setSender}]{\setlength{\rightskip}{0pt plus 5cm}void setSender ({\bf ClockedObject} $\ast$ {\em obj})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_a0a949993188bb0d51b80b714be944447}



\begin{DoxyCode}
91     {
92         assert(m_sender == NULL || m_sender == obj);
93         m_sender = obj;
94     }
\end{DoxyCode}
\hypertarget{classMessageBuffer_a528d693acf172c3acd1f7fbf73a463f9}{
\index{MessageBuffer@{MessageBuffer}!setVnet@{setVnet}}
\index{setVnet@{setVnet}!MessageBuffer@{MessageBuffer}}
\subsubsection[{setVnet}]{\setlength{\rightskip}{0pt plus 5cm}void setVnet (int {\em net})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classMessageBuffer_a528d693acf172c3acd1f7fbf73a463f9}



\begin{DoxyCode}
144 { m_vnet_id = net; }
\end{DoxyCode}
\hypertarget{classMessageBuffer_abef10942dc67e1641651a1f9542b7303}{
\index{MessageBuffer@{MessageBuffer}!stallMessage@{stallMessage}}
\index{stallMessage@{stallMessage}!MessageBuffer@{MessageBuffer}}
\subsubsection[{stallMessage}]{\setlength{\rightskip}{0pt plus 5cm}void stallMessage (const {\bf Address} \& {\em addr})}}
\label{classMessageBuffer_abef10942dc67e1641651a1f9542b7303}



\begin{DoxyCode}
329 {
330     DPRINTF(RubyQueue, "Stalling due to %s\n", addr);
331     assert(isReady());
332     assert(addr.getOffset() == 0);
333     MsgPtr message = m_prio_heap.front().m_msgptr;
334 
335     dequeue();
336 
337     //
338     // Note: no event is scheduled to analyze the map at a later time.
339     // Instead the controller is responsible to call reanalyzeMessages when
340     // these addresses change state.
341     //
342     (m_stall_msg_map[addr]).push_back(message);
343 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classMessageBuffer_a138db353766834771d05a09ab273f245}{
\index{MessageBuffer@{MessageBuffer}!m\_\-consumer@{m\_\-consumer}}
\index{m\_\-consumer@{m\_\-consumer}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-consumer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Consumer}$\ast$ {\bf m\_\-consumer}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_a138db353766834771d05a09ab273f245}


\hyperlink{classConsumer}{Consumer} to signal a wakeup(), can be NULL. \hypertarget{classMessageBuffer_ad214be76cbb069cc3acb2a843fffb26f}{
\index{MessageBuffer@{MessageBuffer}!m\_\-input\_\-link\_\-id@{m\_\-input\_\-link\_\-id}}
\index{m\_\-input\_\-link\_\-id@{m\_\-input\_\-link\_\-id}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-input\_\-link\_\-id}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-input\_\-link\_\-id}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_ad214be76cbb069cc3acb2a843fffb26f}
\hypertarget{classMessageBuffer_a691773cf753228bbb617fc07019c45bb}{
\index{MessageBuffer@{MessageBuffer}!m\_\-last\_\-arrival\_\-time@{m\_\-last\_\-arrival\_\-time}}
\index{m\_\-last\_\-arrival\_\-time@{m\_\-last\_\-arrival\_\-time}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-last\_\-arrival\_\-time}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf m\_\-last\_\-arrival\_\-time}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_a691773cf753228bbb617fc07019c45bb}
\hypertarget{classMessageBuffer_ac6512ff5a4845e1c7accef18b576f810}{
\index{MessageBuffer@{MessageBuffer}!m\_\-max\_\-size@{m\_\-max\_\-size}}
\index{m\_\-max\_\-size@{m\_\-max\_\-size}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-max\_\-size}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf m\_\-max\_\-size}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_ac6512ff5a4845e1c7accef18b576f810}
\hypertarget{classMessageBuffer_a3ee0247e7b99d743ac9ec4d45edba8af}{
\index{MessageBuffer@{MessageBuffer}!m\_\-msg\_\-counter@{m\_\-msg\_\-counter}}
\index{m\_\-msg\_\-counter@{m\_\-msg\_\-counter}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-msg\_\-counter}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uint64} {\bf m\_\-msg\_\-counter}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_a3ee0247e7b99d743ac9ec4d45edba8af}
\hypertarget{classMessageBuffer_af37dc7ab69d718640e0622b64136543f}{
\index{MessageBuffer@{MessageBuffer}!m\_\-msgs\_\-this\_\-cycle@{m\_\-msgs\_\-this\_\-cycle}}
\index{m\_\-msgs\_\-this\_\-cycle@{m\_\-msgs\_\-this\_\-cycle}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-msgs\_\-this\_\-cycle}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf m\_\-msgs\_\-this\_\-cycle}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_af37dc7ab69d718640e0622b64136543f}
\hypertarget{classMessageBuffer_adb41893ba19e889e56c559f25fc1a68a}{
\index{MessageBuffer@{MessageBuffer}!m\_\-name@{m\_\-name}}
\index{m\_\-name@{m\_\-name}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-name}]{\setlength{\rightskip}{0pt plus 5cm}std::string {\bf m\_\-name}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_adb41893ba19e889e56c559f25fc1a68a}
\hypertarget{classMessageBuffer_adb933651b11421e2e911a352db8edc94}{
\index{MessageBuffer@{MessageBuffer}!m\_\-not\_\-avail\_\-count@{m\_\-not\_\-avail\_\-count}}
\index{m\_\-not\_\-avail\_\-count@{m\_\-not\_\-avail\_\-count}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-not\_\-avail\_\-count}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-not\_\-avail\_\-count}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_adb933651b11421e2e911a352db8edc94}
\hypertarget{classMessageBuffer_ae6fd7f88210bae2cdbd67370062be24c}{
\index{MessageBuffer@{MessageBuffer}!m\_\-ordering\_\-set@{m\_\-ordering\_\-set}}
\index{m\_\-ordering\_\-set@{m\_\-ordering\_\-set}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-ordering\_\-set}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf m\_\-ordering\_\-set}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_ae6fd7f88210bae2cdbd67370062be24c}
\hypertarget{classMessageBuffer_ab02596c3ecacf48c081c7188a2e304ab}{
\index{MessageBuffer@{MessageBuffer}!m\_\-prio\_\-heap@{m\_\-prio\_\-heap}}
\index{m\_\-prio\_\-heap@{m\_\-prio\_\-heap}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-prio\_\-heap}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf MessageBufferNode}$>$ {\bf m\_\-prio\_\-heap}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_ab02596c3ecacf48c081c7188a2e304ab}
\hypertarget{classMessageBuffer_a4ac5345a63b7618a47b477b57cde5ca0}{
\index{MessageBuffer@{MessageBuffer}!m\_\-priority\_\-rank@{m\_\-priority\_\-rank}}
\index{m\_\-priority\_\-rank@{m\_\-priority\_\-rank}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-priority\_\-rank}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-priority\_\-rank}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_a4ac5345a63b7618a47b477b57cde5ca0}
\hypertarget{classMessageBuffer_aa846ca9467116a26a879dc4b262cf36a}{
\index{MessageBuffer@{MessageBuffer}!m\_\-randomization@{m\_\-randomization}}
\index{m\_\-randomization@{m\_\-randomization}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-randomization}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf m\_\-randomization}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_aa846ca9467116a26a879dc4b262cf36a}
\hypertarget{classMessageBuffer_a18393ec7ec37465d3c43d1de61fe7ea1}{
\index{MessageBuffer@{MessageBuffer}!m\_\-receiver@{m\_\-receiver}}
\index{m\_\-receiver@{m\_\-receiver}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-receiver}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ClockedObject}$\ast$ {\bf m\_\-receiver}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_a18393ec7ec37465d3c43d1de61fe7ea1}
\hypertarget{classMessageBuffer_a896a9ceedfb77c22a82b490f05ae4624}{
\index{MessageBuffer@{MessageBuffer}!m\_\-recycle\_\-latency@{m\_\-recycle\_\-latency}}
\index{m\_\-recycle\_\-latency@{m\_\-recycle\_\-latency}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-recycle\_\-latency}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf m\_\-recycle\_\-latency}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_a896a9ceedfb77c22a82b490f05ae4624}
\hypertarget{classMessageBuffer_a8c9e563cbbe6ea97e8c1357a2dcce427}{
\index{MessageBuffer@{MessageBuffer}!m\_\-sender@{m\_\-sender}}
\index{m\_\-sender@{m\_\-sender}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-sender}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ClockedObject}$\ast$ {\bf m\_\-sender}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_a8c9e563cbbe6ea97e8c1357a2dcce427}


The two ends of the buffer. \hypertarget{classMessageBuffer_ad4ef3631d539c1c0a0434b51bdabf68c}{
\index{MessageBuffer@{MessageBuffer}!m\_\-size\_\-at\_\-cycle\_\-start@{m\_\-size\_\-at\_\-cycle\_\-start}}
\index{m\_\-size\_\-at\_\-cycle\_\-start@{m\_\-size\_\-at\_\-cycle\_\-start}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-size\_\-at\_\-cycle\_\-start}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf m\_\-size\_\-at\_\-cycle\_\-start}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_ad4ef3631d539c1c0a0434b51bdabf68c}
\hypertarget{classMessageBuffer_ad240a365b18b543a74ce40475a9e7d74}{
\index{MessageBuffer@{MessageBuffer}!m\_\-size\_\-last\_\-time\_\-size\_\-checked@{m\_\-size\_\-last\_\-time\_\-size\_\-checked}}
\index{m\_\-size\_\-last\_\-time\_\-size\_\-checked@{m\_\-size\_\-last\_\-time\_\-size\_\-checked}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-size\_\-last\_\-time\_\-size\_\-checked}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf m\_\-size\_\-last\_\-time\_\-size\_\-checked}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_ad240a365b18b543a74ce40475a9e7d74}
\hypertarget{classMessageBuffer_a588564bc2c906eaf69f9b34f18ff18ea}{
\index{MessageBuffer@{MessageBuffer}!m\_\-stall\_\-msg\_\-map@{m\_\-stall\_\-msg\_\-map}}
\index{m\_\-stall\_\-msg\_\-map@{m\_\-stall\_\-msg\_\-map}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-stall\_\-msg\_\-map}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StallMsgMapType} {\bf m\_\-stall\_\-msg\_\-map}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_a588564bc2c906eaf69f9b34f18ff18ea}
\hypertarget{classMessageBuffer_a2d9ad769da997d66f23de51048f90566}{
\index{MessageBuffer@{MessageBuffer}!m\_\-strict\_\-fifo@{m\_\-strict\_\-fifo}}
\index{m\_\-strict\_\-fifo@{m\_\-strict\_\-fifo}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-strict\_\-fifo}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf m\_\-strict\_\-fifo}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_a2d9ad769da997d66f23de51048f90566}
\hypertarget{classMessageBuffer_ad99d9b33ed6c9adbe0b672c6af0a5bf7}{
\index{MessageBuffer@{MessageBuffer}!m\_\-time\_\-last\_\-time\_\-enqueue@{m\_\-time\_\-last\_\-time\_\-enqueue}}
\index{m\_\-time\_\-last\_\-time\_\-enqueue@{m\_\-time\_\-last\_\-time\_\-enqueue}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-time\_\-last\_\-time\_\-enqueue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf m\_\-time\_\-last\_\-time\_\-enqueue}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_ad99d9b33ed6c9adbe0b672c6af0a5bf7}
\hypertarget{classMessageBuffer_a6d825eaf3c6cf89227a953fcb5e91af3}{
\index{MessageBuffer@{MessageBuffer}!m\_\-time\_\-last\_\-time\_\-pop@{m\_\-time\_\-last\_\-time\_\-pop}}
\index{m\_\-time\_\-last\_\-time\_\-pop@{m\_\-time\_\-last\_\-time\_\-pop}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-time\_\-last\_\-time\_\-pop}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} {\bf m\_\-time\_\-last\_\-time\_\-pop}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_a6d825eaf3c6cf89227a953fcb5e91af3}
\hypertarget{classMessageBuffer_a040f6bbf3cb647d2363ac247e2076126}{
\index{MessageBuffer@{MessageBuffer}!m\_\-time\_\-last\_\-time\_\-size\_\-checked@{m\_\-time\_\-last\_\-time\_\-size\_\-checked}}
\index{m\_\-time\_\-last\_\-time\_\-size\_\-checked@{m\_\-time\_\-last\_\-time\_\-size\_\-checked}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-time\_\-last\_\-time\_\-size\_\-checked}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cycles} {\bf m\_\-time\_\-last\_\-time\_\-size\_\-checked}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_a040f6bbf3cb647d2363ac247e2076126}
\hypertarget{classMessageBuffer_a3cd373167bcac343aba16bd3525cc0a2}{
\index{MessageBuffer@{MessageBuffer}!m\_\-vnet\_\-id@{m\_\-vnet\_\-id}}
\index{m\_\-vnet\_\-id@{m\_\-vnet\_\-id}!MessageBuffer@{MessageBuffer}}
\subsubsection[{m\_\-vnet\_\-id}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf m\_\-vnet\_\-id}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classMessageBuffer_a3cd373167bcac343aba16bd3525cc0a2}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/ruby/buffers/\hyperlink{MessageBuffer_8hh}{MessageBuffer.hh}\item 
mem/ruby/buffers/\hyperlink{MessageBuffer_8cc}{MessageBuffer.cc}\end{DoxyCompactItemize}
