\hypertarget{classX86System}{
\section{クラス X86System}
\label{classX86System}\index{X86System@{X86System}}
}


{\ttfamily \#include $<$system.hh$>$}X86Systemに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=7cm]{classX86System}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classX86System_1_1LinuxX86System}{LinuxX86System}
\item 
class \hyperlink{classX86System_1_1X86System}{X86System}
\end{DoxyCompactItemize}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef X86SystemParams \hyperlink{classX86System_a4f3142e3ba81ac1e14e960636ad3202b}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classX86System_aa4f02fc2926ae35d549b6b5381b7656f}{X86System} (\hyperlink{classX86System_a4f3142e3ba81ac1e14e960636ad3202b}{Params} $\ast$p)
\item 
\hyperlink{classX86System_a0f8dc8b16330d4a51897190c3969e675}{$\sim$X86System} ()
\item 
void \hyperlink{classX86System_a3c34ea9b29f410748d4435a667484924}{initState} ()
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classX86System_aedc3044b917a61fa913215abf8d2840a}{writeOutSMBiosTable} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} header, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \&headerSize, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \&tableSize, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} table=0)
\item 
void \hyperlink{classX86System_ac86acd47948194bfedd9cf4f63400d2a}{writeOutMPTable} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} fp, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \&fpSize, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \&tableSize, \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} table=0)
\item 
const \hyperlink{classX86System_a4f3142e3ba81ac1e14e960636ad3202b}{Params} $\ast$ \hyperlink{classX86System_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
virtual \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classX86System_aff94f650c5eef23b8dc350ea755bdef4}{fixFuncEventAddr} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classX86ISA_1_1SMBios_1_1SMBiosTable}{X86ISA::SMBios::SMBiosTable} $\ast$ \hyperlink{classX86System_a5c04c44b233a4eb2f0b5257fbf325a16}{smbiosTable}
\item 
\hyperlink{classX86ISA_1_1IntelMP_1_1FloatingPointer}{X86ISA::IntelMP::FloatingPointer} $\ast$ \hyperlink{classX86System_ae6f1d27ec00245a1760fbadd3c288f27}{mpFloatingPointer}
\item 
\hyperlink{classX86ISA_1_1IntelMP_1_1ConfigTable}{X86ISA::IntelMP::ConfigTable} $\ast$ \hyperlink{classX86System_a9330926e79494dca3485ba60e2fe27d4}{mpConfigTable}
\item 
\hyperlink{classX86ISA_1_1ACPI_1_1RSDP}{X86ISA::ACPI::RSDP} $\ast$ \hyperlink{classX86System_a267601a08962af9107c6f7c533d4461d}{rsdp}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classX86System_a4f3142e3ba81ac1e14e960636ad3202b}{
\index{X86System@{X86System}!Params@{Params}}
\index{Params@{Params}!X86System@{X86System}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef X86SystemParams {\bf Params}}}
\label{classX86System_a4f3142e3ba81ac1e14e960636ad3202b}


\hyperlink{classSystem_a5f461be6222ce76bffcb70f27d820c56}{System}を再定義しています。

\hyperlink{classLinuxX86System_a9a9d4fd080ddd5d649f7db5e47cfae8b}{LinuxX86System}で再定義されています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classX86System_aa4f02fc2926ae35d549b6b5381b7656f}{
\index{X86System@{X86System}!X86System@{X86System}}
\index{X86System@{X86System}!X86System@{X86System}}
\subsubsection[{X86System}]{\setlength{\rightskip}{0pt plus 5cm}{\bf X86System} ({\bf Params} $\ast$ {\em p})}}
\label{classX86System_aa4f02fc2926ae35d549b6b5381b7656f}



\begin{DoxyCode}
58                               :
59     System(p), smbiosTable(p->smbios_table),
60     mpFloatingPointer(p->intel_mp_pointer),
61     mpConfigTable(p->intel_mp_table),
62     rsdp(p->acpi_description_table_pointer)
63 {
64 }

\end{DoxyCode}
\hypertarget{classX86System_a0f8dc8b16330d4a51897190c3969e675}{
\index{X86System@{X86System}!$\sim$X86System@{$\sim$X86System}}
\index{$\sim$X86System@{$\sim$X86System}!X86System@{X86System}}
\subsubsection[{$\sim$X86System}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf X86System} ()}}
\label{classX86System_a0f8dc8b16330d4a51897190c3969e675}



\begin{DoxyCode}
387 {
388     delete smbiosTable;
389 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classX86System_aff94f650c5eef23b8dc350ea755bdef4}{
\index{X86System@{X86System}!fixFuncEventAddr@{fixFuncEventAddr}}
\index{fixFuncEventAddr@{fixFuncEventAddr}!X86System@{X86System}}
\subsubsection[{fixFuncEventAddr}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Addr} fixFuncEventAddr ({\bf Addr} {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classX86System_aff94f650c5eef23b8dc350ea755bdef4}
Fix up an address used to match PCs for hooking simulator events on to target function executions. See comment in system.cc for details. 

\hyperlink{classSystem_aff94f650c5eef23b8dc350ea755bdef4}{System}を再定義しています。


\begin{DoxyCode}
96     {
97         //XXX This may eventually have to do something useful.
98         return addr;
99     }
\end{DoxyCode}
\hypertarget{classX86System_a3c34ea9b29f410748d4435a667484924}{
\index{X86System@{X86System}!initState@{initState}}
\index{initState@{initState}!X86System@{X86System}}
\subsubsection[{initState}]{\setlength{\rightskip}{0pt plus 5cm}void initState ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classX86System_a3c34ea9b29f410748d4435a667484924}
Serialization stuff 

\hyperlink{classSystem_a3c34ea9b29f410748d4435a667484924}{System}を再定義しています。

\hyperlink{classLinuxX86System_a3c34ea9b29f410748d4435a667484924}{LinuxX86System}で再定義されています。


\begin{DoxyCode}
114 {
115     System::initState();
116 
117     if (!kernel)
118         fatal("No kernel to load.\n");
119 
120     if (kernel->getArch() == ObjectFile::I386)
121         fatal("Loading a 32 bit x86 kernel is not supported.\n");
122 
123     ThreadContext *tc = threadContexts[0];
124     // This is the boot strap processor (BSP). Initialize it to look like
125     // the boot loader has just turned control over to the 64 bit OS. We
126     // won't actually set up real mode or legacy protected mode descriptor
127     // tables because we aren't executing any code that would require
128     // them. We do, however toggle the control bits in the correct order
129     // while allowing consistency checks and the underlying mechansims
130     // just to be safe.
131 
132     const int NumPDTs = 4;
133 
134     const Addr PageMapLevel4 = 0x70000;
135     const Addr PageDirPtrTable = 0x71000;
136     const Addr PageDirTable[NumPDTs] =
137         {0x72000, 0x73000, 0x74000, 0x75000};
138     const Addr GDTBase = 0x76000;
139 
140     const int PML4Bits = 9;
141     const int PDPTBits = 9;
142     const int PDTBits = 9;
143 
144     /*
145      * Set up the gdt.
146      */
147     uint8_t numGDTEntries = 0;
148     // Place holder at selector 0
149     uint64_t nullDescriptor = 0;
150     physProxy.writeBlob(GDTBase + numGDTEntries * 8,
151                         (uint8_t *)(&nullDescriptor), 8);
152     numGDTEntries++;
153 
154     //64 bit code segment
155     SegDescriptor csDesc = 0;
156     csDesc.type.codeOrData = 1;
157     csDesc.type.c = 0; // Not conforming
158     csDesc.type.r = 1; // Readable
159     csDesc.dpl = 0; // Privelege level 0
160     csDesc.p = 1; // Present
161     csDesc.l = 1; // 64 bit
162     csDesc.d = 0; // default operand size
163     csDesc.g = 1; // Page granularity
164     csDesc.s = 1; // Not a system segment
165     csDesc.limitHigh = 0xF;
166     csDesc.limitLow = 0xFFFF;
167     //Because we're dealing with a pointer and I don't think it's
168     //guaranteed that there isn't anything in a nonvirtual class between
169     //it's beginning in memory and it's actual data, we'll use an
170     //intermediary.
171     uint64_t csDescVal = csDesc;
172     physProxy.writeBlob(GDTBase + numGDTEntries * 8,
173                         (uint8_t *)(&csDescVal), 8);
174 
175     numGDTEntries++;
176 
177     SegSelector cs = 0;
178     cs.si = numGDTEntries - 1;
179 
180     tc->setMiscReg(MISCREG_CS, (MiscReg)cs);
181 
182     //32 bit data segment
183     SegDescriptor dsDesc = 0;
184     dsDesc.type.codeOrData = 0;
185     dsDesc.type.e = 0; // Not expand down
186     dsDesc.type.w = 1; // Writable
187     dsDesc.dpl = 0; // Privelege level 0
188     dsDesc.p = 1; // Present
189     dsDesc.d = 1; // default operand size
190     dsDesc.g = 1; // Page granularity
191     dsDesc.s = 1; // Not a system segment
192     dsDesc.limitHigh = 0xF;
193     dsDesc.limitLow = 0xFFFF;
194     uint64_t dsDescVal = dsDesc;
195     physProxy.writeBlob(GDTBase + numGDTEntries * 8,
196                         (uint8_t *)(&dsDescVal), 8);
197 
198     numGDTEntries++;
199 
200     SegSelector ds = 0;
201     ds.si = numGDTEntries - 1;
202 
203     tc->setMiscReg(MISCREG_DS, (MiscReg)ds);
204     tc->setMiscReg(MISCREG_ES, (MiscReg)ds);
205     tc->setMiscReg(MISCREG_FS, (MiscReg)ds);
206     tc->setMiscReg(MISCREG_GS, (MiscReg)ds);
207     tc->setMiscReg(MISCREG_SS, (MiscReg)ds);
208 
209     tc->setMiscReg(MISCREG_TSL, 0);
210     tc->setMiscReg(MISCREG_TSG_BASE, GDTBase);
211     tc->setMiscReg(MISCREG_TSG_LIMIT, 8 * numGDTEntries - 1);
212 
213     SegDescriptor tssDesc = 0;
214     tssDesc.type = 0xB;
215     tssDesc.dpl = 0; // Privelege level 0
216     tssDesc.p = 1; // Present
217     tssDesc.d = 1; // default operand size
218     tssDesc.g = 1; // Page granularity
219     tssDesc.s = 0;
220     tssDesc.limitHigh = 0xF;
221     tssDesc.limitLow = 0xFFFF;
222     uint64_t tssDescVal = tssDesc;
223     physProxy.writeBlob(GDTBase + numGDTEntries * 8,
224                         (uint8_t *)(&tssDescVal), 8);
225 
226     numGDTEntries++;
227 
228     SegSelector tss = 0;
229     tss.si = numGDTEntries - 1;
230 
231     tc->setMiscReg(MISCREG_TR, (MiscReg)tss);
232     installSegDesc(tc, SYS_SEGMENT_REG_TR, tssDesc, true);
233 
234     /*
235      * Identity map the first 4GB of memory. In order to map this region
236      * of memory in long mode, there needs to be one actual page map level
237      * 4 entry which points to one page directory pointer table which
238      * points to 4 different page directory tables which are full of two
239      * megabyte pages. All of the other entries in valid tables are set
240      * to indicate that they don't pertain to anything valid and will
241      * cause a fault if used.
242      */
243 
244     // Put valid values in all of the various table entries which indicate
245     // that those entries don't point to further tables or pages. Then
246     // set the values of those entries which are needed.
247 
248     // Page Map Level 4
249 
250     // read/write, user, not present
251     uint64_t pml4e = X86ISA::htog(0x6);
252     for (int offset = 0; offset < (1 << PML4Bits) * 8; offset += 8) {
253         physProxy.writeBlob(PageMapLevel4 + offset, (uint8_t *)(&pml4e), 8);
254     }
255     // Point to the only PDPT
256     pml4e = X86ISA::htog(0x7 | PageDirPtrTable);
257     physProxy.writeBlob(PageMapLevel4, (uint8_t *)(&pml4e), 8);
258 
259     // Page Directory Pointer Table
260 
261     // read/write, user, not present
262     uint64_t pdpe = X86ISA::htog(0x6);
263     for (int offset = 0; offset < (1 << PDPTBits) * 8; offset += 8) {
264         physProxy.writeBlob(PageDirPtrTable + offset,
265                             (uint8_t *)(&pdpe), 8);
266     }
267     // Point to the PDTs
268     for (int table = 0; table < NumPDTs; table++) {
269         pdpe = X86ISA::htog(0x7 | PageDirTable[table]);
270         physProxy.writeBlob(PageDirPtrTable + table * 8,
271                             (uint8_t *)(&pdpe), 8);
272     }
273 
274     // Page Directory Tables
275 
276     Addr base = 0;
277     const Addr pageSize = 2 << 20;
278     for (int table = 0; table < NumPDTs; table++) {
279         for (int offset = 0; offset < (1 << PDTBits) * 8; offset += 8) {
280             // read/write, user, present, 4MB
281             uint64_t pdte = X86ISA::htog(0x87 | base);
282             physProxy.writeBlob(PageDirTable[table] + offset,
283                                 (uint8_t *)(&pdte), 8);
284             base += pageSize;
285         }
286     }
287 
288     /*
289      * Transition from real mode all the way up to Long mode
290      */
291     CR0 cr0 = tc->readMiscRegNoEffect(MISCREG_CR0);
292     //Turn off paging.
293     cr0.pg = 0;
294     tc->setMiscReg(MISCREG_CR0, cr0);
295     //Turn on protected mode.
296     cr0.pe = 1;
297     tc->setMiscReg(MISCREG_CR0, cr0);
298 
299     CR4 cr4 = tc->readMiscRegNoEffect(MISCREG_CR4);
300     //Turn on pae.
301     cr4.pae = 1;
302     tc->setMiscReg(MISCREG_CR4, cr4);
303 
304     //Point to the page tables.
305     tc->setMiscReg(MISCREG_CR3, PageMapLevel4);
306 
307     Efer efer = tc->readMiscRegNoEffect(MISCREG_EFER);
308     //Enable long mode.
309     efer.lme = 1;
310     tc->setMiscReg(MISCREG_EFER, efer);
311 
312     //Start using longmode segments.
313     installSegDesc(tc, SEGMENT_REG_CS, csDesc, true);
314     installSegDesc(tc, SEGMENT_REG_DS, dsDesc, true);
315     installSegDesc(tc, SEGMENT_REG_ES, dsDesc, true);
316     installSegDesc(tc, SEGMENT_REG_FS, dsDesc, true);
317     installSegDesc(tc, SEGMENT_REG_GS, dsDesc, true);
318     installSegDesc(tc, SEGMENT_REG_SS, dsDesc, true);
319 
320     //Activate long mode.
321     cr0.pg = 1;
322     tc->setMiscReg(MISCREG_CR0, cr0);
323 
324     tc->pcState(tc->getSystemPtr()->kernelEntry);
325 
326     // We should now be in long mode. Yay!
327 
328     Addr ebdaPos = 0xF0000;
329     Addr fixed, table;
330 
331     //Write out the SMBios/DMI table
332     writeOutSMBiosTable(ebdaPos, fixed, table);
333     ebdaPos += (fixed + table);
334     ebdaPos = roundUp(ebdaPos, 16);
335 
336     //Write out the Intel MP Specification configuration table
337     writeOutMPTable(ebdaPos, fixed, table);
338     ebdaPos += (fixed + table);
339 }
\end{DoxyCode}
\hypertarget{classX86System_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{X86System@{X86System}!params@{params}}
\index{params@{params}!X86System@{X86System}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classX86System_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classSystem_acd3c3feb78ae7a8f88fe0f110a718dff}{System}を再定義しています。


\begin{DoxyCode}
93 { return (const Params *)_params; }
\end{DoxyCode}
\hypertarget{classX86System_ac86acd47948194bfedd9cf4f63400d2a}{
\index{X86System@{X86System}!writeOutMPTable@{writeOutMPTable}}
\index{writeOutMPTable@{writeOutMPTable}!X86System@{X86System}}
\subsubsection[{writeOutMPTable}]{\setlength{\rightskip}{0pt plus 5cm}void writeOutMPTable ({\bf Addr} {\em fp}, \/  {\bf Addr} \& {\em fpSize}, \/  {\bf Addr} \& {\em tableSize}, \/  {\bf Addr} {\em table} = {\ttfamily 0})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86System_ac86acd47948194bfedd9cf4f63400d2a}



\begin{DoxyCode}
362 {
363     // If the table location isn't specified and it exists, just put
364     // it after the floating pointer. The fp size as of the 1.4 Intel MP
365     // specification is 0x10 bytes.
366     if (mpConfigTable) {
367         if (!table)
368             table = fp + 0x10;
369         mpFloatingPointer->setTableAddr(table);
370     }
371 
372     fpSize = mpFloatingPointer->writeOut(physProxy, fp);
373     if (mpConfigTable)
374         tableSize = mpConfigTable->writeOut(physProxy, table);
375     else
376         tableSize = 0;
377 
378     // Do some bounds checking to make sure we at least didn't step on
379     // ourselves and the fp structure was the size we thought it was.
380     assert(fp > table || fp + fpSize <= table);
381     assert(table > fp || table + tableSize <= fp);
382     assert(fpSize == 0x10);
383 }
\end{DoxyCode}
\hypertarget{classX86System_aedc3044b917a61fa913215abf8d2840a}{
\index{X86System@{X86System}!writeOutSMBiosTable@{writeOutSMBiosTable}}
\index{writeOutSMBiosTable@{writeOutSMBiosTable}!X86System@{X86System}}
\subsubsection[{writeOutSMBiosTable}]{\setlength{\rightskip}{0pt plus 5cm}void writeOutSMBiosTable ({\bf Addr} {\em header}, \/  {\bf Addr} \& {\em headerSize}, \/  {\bf Addr} \& {\em tableSize}, \/  {\bf Addr} {\em table} = {\ttfamily 0})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86System_aedc3044b917a61fa913215abf8d2840a}



\begin{DoxyCode}
344 {
345     // If the table location isn't specified, just put it after the header.
346     // The header size as of the 2.5 SMBios specification is 0x1F bytes
347     if (!table)
348         table = header + 0x1F;
349     smbiosTable->setTableAddr(table);
350 
351     smbiosTable->writeOut(physProxy, header, headerSize, structSize);
352 
353     // Do some bounds checking to make sure we at least didn't step on
354     // ourselves.
355     assert(header > table || header + headerSize <= table);
356     assert(table > header || table + structSize <= header);
357 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classX86System_a9330926e79494dca3485ba60e2fe27d4}{
\index{X86System@{X86System}!mpConfigTable@{mpConfigTable}}
\index{mpConfigTable@{mpConfigTable}!X86System@{X86System}}
\subsubsection[{mpConfigTable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf X86ISA::IntelMP::ConfigTable}$\ast$ {\bf mpConfigTable}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86System_a9330926e79494dca3485ba60e2fe27d4}
\hypertarget{classX86System_ae6f1d27ec00245a1760fbadd3c288f27}{
\index{X86System@{X86System}!mpFloatingPointer@{mpFloatingPointer}}
\index{mpFloatingPointer@{mpFloatingPointer}!X86System@{X86System}}
\subsubsection[{mpFloatingPointer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf X86ISA::IntelMP::FloatingPointer}$\ast$ {\bf mpFloatingPointer}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86System_ae6f1d27ec00245a1760fbadd3c288f27}
\hypertarget{classX86System_a267601a08962af9107c6f7c533d4461d}{
\index{X86System@{X86System}!rsdp@{rsdp}}
\index{rsdp@{rsdp}!X86System@{X86System}}
\subsubsection[{rsdp}]{\setlength{\rightskip}{0pt plus 5cm}{\bf X86ISA::ACPI::RSDP}$\ast$ {\bf rsdp}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86System_a267601a08962af9107c6f7c533d4461d}
\hypertarget{classX86System_a5c04c44b233a4eb2f0b5257fbf325a16}{
\index{X86System@{X86System}!smbiosTable@{smbiosTable}}
\index{smbiosTable@{smbiosTable}!X86System@{X86System}}
\subsubsection[{smbiosTable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf X86ISA::SMBios::SMBiosTable}$\ast$ {\bf smbiosTable}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classX86System_a5c04c44b233a4eb2f0b5257fbf325a16}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/x86/\hyperlink{arch_2x86_2system_8hh}{system.hh}\item 
arch/x86/\hyperlink{arch_2x86_2system_8cc}{system.cc}\end{DoxyCompactItemize}
