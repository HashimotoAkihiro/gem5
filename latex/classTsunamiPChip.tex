\hypertarget{classTsunamiPChip}{
\section{クラス TsunamiPChip}
\label{classTsunamiPChip}\index{TsunamiPChip@{TsunamiPChip}}
}


{\ttfamily \#include $<$tsunami\_\-pchip.hh$>$}TsunamiPChipに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=7cm]{classTsunamiPChip}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef TsunamiPChipParams \hyperlink{classTsunamiPChip_ad83d95a5c11dc8215f058bbac3c02dd6}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classTsunamiPChip_a2b23bec87373536aec1deca8d2646a87}{TsunamiPChip} (const \hyperlink{classTsunamiPChip_ad83d95a5c11dc8215f058bbac3c02dd6}{Params} $\ast$p)
\item 
const \hyperlink{classTsunamiPChip_ad83d95a5c11dc8215f058bbac3c02dd6}{Params} $\ast$ \hyperlink{classTsunamiPChip_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classTsunamiPChip_a5de3f8c8c47bf4bb58e072f54f4a7cba}{translatePciToDma} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} busAddr)
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classTsunamiPChip_ac58937201c28a74230a03b39b03066b6}{calcConfigAddr} (int bus, int dev, int func)
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classTsunamiPChip_a6c236382792e59da5c56c9d7c01de500}{calcIOAddr} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr)
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classTsunamiPChip_a0501fb8a3bd69d670b9b92d2f7991ad2}{calcMemAddr} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classTsunamiPChip_a613ec7d5e1ec64f8d21fec78ae8e568e}{read} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classTsunamiPChip_a4cefab464e72b5dd42c003a0a4341802}{write} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual void \hyperlink{classTsunamiPChip_a53e036786d17361be4c7320d39c99b84}{serialize} (std::ostream \&os)
\item 
virtual void \hyperlink{classTsunamiPChip_af22e5d6d660b97db37003ac61ac4ee49}{unserialize} (\hyperlink{classCheckpoint}{Checkpoint} $\ast$cp, const std::string \&section)
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
uint64\_\-t \hyperlink{classTsunamiPChip_a8df2c098b72e9eee77a79290c8e4a6c5}{pctl}
\item 
uint64\_\-t \hyperlink{classTsunamiPChip_a8281ba8e4694bf75ec8b8b5d4d4ad50f}{wsba} \mbox{[}4\mbox{]}
\item 
uint64\_\-t \hyperlink{classTsunamiPChip_a16d1e04d18db960e6c8059d404989395}{wsm} \mbox{[}4\mbox{]}
\item 
uint64\_\-t \hyperlink{classTsunamiPChip_ad35698b8e7094fe0888d00cad38965ec}{tba} \mbox{[}4\mbox{]}
\end{DoxyCompactItemize}
\subsection*{Static Protected 変数}
\begin{DoxyCompactItemize}
\item 
static const \hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classTsunamiPChip_a8a9c49447e0f2ce2f8aaf2c7a4299eac}{TsunamiPciBus0Config} = ULL(0x801fe000000)
\end{DoxyCompactItemize}


\subsection{説明}
A very simple implementation of the \hyperlink{classTsunami}{Tsunami} PCI interface chips. 

\subsection{型定義}
\hypertarget{classTsunamiPChip_ad83d95a5c11dc8215f058bbac3c02dd6}{
\index{TsunamiPChip@{TsunamiPChip}!Params@{Params}}
\index{Params@{Params}!TsunamiPChip@{TsunamiPChip}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef TsunamiPChipParams {\bf Params}}}
\label{classTsunamiPChip_ad83d95a5c11dc8215f058bbac3c02dd6}


\hyperlink{classBasicPioDevice_a2845515ac6467f10540747053c8a0449}{BasicPioDevice}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classTsunamiPChip_a2b23bec87373536aec1deca8d2646a87}{
\index{TsunamiPChip@{TsunamiPChip}!TsunamiPChip@{TsunamiPChip}}
\index{TsunamiPChip@{TsunamiPChip}!TsunamiPChip@{TsunamiPChip}}
\subsubsection[{TsunamiPChip}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TsunamiPChip} (const {\bf Params} $\ast$ {\em p})}}
\label{classTsunamiPChip_a2b23bec87373536aec1deca8d2646a87}
\hyperlink{classRegister}{Register} the PChip with the mmu and init all wsba, wsm, and tba to 0 
\begin{DoxyParams}{引数}
\item[{\em p}]pointer to the parameters struct \end{DoxyParams}



\begin{DoxyCode}
55     : BasicPioDevice(p, 0x1000)
56 {
57     for (int i = 0; i < 4; i++) {
58         wsba[i] = 0;
59         wsm[i] = 0;
60         tba[i] = 0;
61     }
62 
63     // initialize pchip control register
64     pctl = (ULL(0x1) << 20) | (ULL(0x1) << 32) | (ULL(0x2) << 36);
65 
66     //Set back pointer in tsunami
67     p->tsunami->pchip = this;
68 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classTsunamiPChip_ac58937201c28a74230a03b39b03066b6}{
\index{TsunamiPChip@{TsunamiPChip}!calcConfigAddr@{calcConfigAddr}}
\index{calcConfigAddr@{calcConfigAddr}!TsunamiPChip@{TsunamiPChip}}
\subsubsection[{calcConfigAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} calcConfigAddr (int {\em bus}, \/  int {\em dev}, \/  int {\em func})}}
\label{classTsunamiPChip_ac58937201c28a74230a03b39b03066b6}



\begin{DoxyCode}
307 {
308     assert(func < 8);
309     assert(dev < 32);
310     assert(bus == 0);
311 
312     return TsunamiPciBus0Config | (func << 8) | (dev << 11);
313 }
\end{DoxyCode}
\hypertarget{classTsunamiPChip_a6c236382792e59da5c56c9d7c01de500}{
\index{TsunamiPChip@{TsunamiPChip}!calcIOAddr@{calcIOAddr}}
\index{calcIOAddr@{calcIOAddr}!TsunamiPChip@{TsunamiPChip}}
\subsubsection[{calcIOAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} calcIOAddr ({\bf Addr} {\em addr})}}
\label{classTsunamiPChip_a6c236382792e59da5c56c9d7c01de500}



\begin{DoxyCode}
317 {
318     return TSUNAMI_PCI0_IO + addr;
319 }
\end{DoxyCode}
\hypertarget{classTsunamiPChip_a0501fb8a3bd69d670b9b92d2f7991ad2}{
\index{TsunamiPChip@{TsunamiPChip}!calcMemAddr@{calcMemAddr}}
\index{calcMemAddr@{calcMemAddr}!TsunamiPChip@{TsunamiPChip}}
\subsubsection[{calcMemAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} calcMemAddr ({\bf Addr} {\em addr})}}
\label{classTsunamiPChip_a0501fb8a3bd69d670b9b92d2f7991ad2}



\begin{DoxyCode}
323 {
324     return TSUNAMI_PCI0_MEMORY + addr;
325 }
\end{DoxyCode}
\hypertarget{classTsunamiPChip_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{TsunamiPChip@{TsunamiPChip}!params@{params}}
\index{params@{params}!TsunamiPChip@{TsunamiPChip}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classTsunamiPChip_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classBasicPioDevice_acd3c3feb78ae7a8f88fe0f110a718dff}{BasicPioDevice}を再定義しています。


\begin{DoxyCode}
73     {
74         return dynamic_cast<const Params *>(_params);
75     }
\end{DoxyCode}
\hypertarget{classTsunamiPChip_a613ec7d5e1ec64f8d21fec78ae8e568e}{
\index{TsunamiPChip@{TsunamiPChip}!read@{read}}
\index{read@{read}!TsunamiPChip@{TsunamiPChip}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} read ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTsunamiPChip_a613ec7d5e1ec64f8d21fec78ae8e568e}
Pure virtual function that the device must implement. Called when a read command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_a842312590432036092c422c87a442358}{PioDevice}を実装しています。


\begin{DoxyCode}
72 {
73     assert(pkt->getAddr() >= pioAddr && pkt->getAddr() < pioAddr + pioSize);
74 
75     pkt->allocate();
76     Addr daddr = (pkt->getAddr() - pioAddr) >> 6;;
77     assert(pkt->getSize() == sizeof(uint64_t));
78 
79 
80     DPRINTF(Tsunami, "read  va=%#x size=%d\n", pkt->getAddr(), pkt->getSize());
81 
82     switch(daddr) {
83       case TSDEV_PC_WSBA0:
84             pkt->set(wsba[0]);
85             break;
86       case TSDEV_PC_WSBA1:
87             pkt->set(wsba[1]);
88             break;
89       case TSDEV_PC_WSBA2:
90             pkt->set(wsba[2]);
91             break;
92       case TSDEV_PC_WSBA3:
93             pkt->set(wsba[3]);
94             break;
95       case TSDEV_PC_WSM0:
96             pkt->set(wsm[0]);
97             break;
98       case TSDEV_PC_WSM1:
99             pkt->set(wsm[1]);
100             break;
101       case TSDEV_PC_WSM2:
102             pkt->set(wsm[2]);
103             break;
104       case TSDEV_PC_WSM3:
105             pkt->set(wsm[3]);
106             break;
107       case TSDEV_PC_TBA0:
108             pkt->set(tba[0]);
109             break;
110       case TSDEV_PC_TBA1:
111             pkt->set(tba[1]);
112             break;
113       case TSDEV_PC_TBA2:
114             pkt->set(tba[2]);
115             break;
116       case TSDEV_PC_TBA3:
117             pkt->set(tba[3]);
118             break;
119       case TSDEV_PC_PCTL:
120             pkt->set(pctl);
121             break;
122       case TSDEV_PC_PLAT:
123             panic("PC_PLAT not implemented\n");
124       case TSDEV_PC_RES:
125             panic("PC_RES not implemented\n");
126       case TSDEV_PC_PERROR:
127             pkt->set((uint64_t)0x00);
128             break;
129       case TSDEV_PC_PERRMASK:
130             pkt->set((uint64_t)0x00);
131             break;
132       case TSDEV_PC_PERRSET:
133             panic("PC_PERRSET not implemented\n");
134       case TSDEV_PC_TLBIV:
135             panic("PC_TLBIV not implemented\n");
136       case TSDEV_PC_TLBIA:
137             pkt->set((uint64_t)0x00); // shouldn't be readable, but linux
138             break;
139       case TSDEV_PC_PMONCTL:
140             panic("PC_PMONCTL not implemented\n");
141       case TSDEV_PC_PMONCNT:
142             panic("PC_PMONCTN not implemented\n");
143       default:
144           panic("Default in PChip Read reached reading 0x%x\n", daddr);
145     }
146     pkt->makeAtomicResponse();
147     return pioDelay;
148 
149 }
\end{DoxyCode}
\hypertarget{classTsunamiPChip_a53e036786d17361be4c7320d39c99b84}{
\index{TsunamiPChip@{TsunamiPChip}!serialize@{serialize}}
\index{serialize@{serialize}!TsunamiPChip@{TsunamiPChip}}
\subsubsection[{serialize}]{\setlength{\rightskip}{0pt plus 5cm}void serialize (std::ostream \& {\em os})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTsunamiPChip_a53e036786d17361be4c7320d39c99b84}
Serialize this object to the given output stream. 
\begin{DoxyParams}{引数}
\item[{\em os}]The stream to serialize to. \end{DoxyParams}


\hyperlink{classSerializable_ad6272f80ae37e8331e3969b3f072a801}{Serializable}を再定義しています。


\begin{DoxyCode}
329 {
330     SERIALIZE_SCALAR(pctl);
331     SERIALIZE_ARRAY(wsba, 4);
332     SERIALIZE_ARRAY(wsm, 4);
333     SERIALIZE_ARRAY(tba, 4);
334 }
\end{DoxyCode}
\hypertarget{classTsunamiPChip_a5de3f8c8c47bf4bb58e072f54f4a7cba}{
\index{TsunamiPChip@{TsunamiPChip}!translatePciToDma@{translatePciToDma}}
\index{translatePciToDma@{translatePciToDma}!TsunamiPChip@{TsunamiPChip}}
\subsubsection[{translatePciToDma}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} translatePciToDma ({\bf Addr} {\em busAddr})}}
\label{classTsunamiPChip_a5de3f8c8c47bf4bb58e072f54f4a7cba}
Translate a PCI bus address to a memory address for DMA. \begin{Desc}
\item[\hyperlink{todo__todo000051}{TODO}]Andrew says this needs to be fixed. What's wrong with it? \end{Desc}

\begin{DoxyParams}{引数}
\item[{\em busAddr}]PCI address to translate. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
memory system address 
\end{DoxyReturn}


\begin{Desc}
\item[\hyperlink{todo__todo000050}{TODO}]This currently is faked by just doing a direct read from memory, however, to be realistic, this needs to actually do a bus transaction. The process is explained in the tsunami documentation on page 10-\/12 and basically munges the address to look up a PTE from a table in memory and then uses that mapping to create an address for the SG page \end{Desc}



\begin{DoxyCode}
232 {
233     // compare the address to the window base registers
234     uint64_t tbaMask = 0;
235     uint64_t baMask = 0;
236 
237     uint64_t windowMask = 0;
238     uint64_t windowBase = 0;
239 
240     uint64_t pteEntry = 0;
241 
242     Addr pteAddr;
243     Addr dmaAddr;
244 
245 #if 0
246     DPRINTF(IdeDisk, "Translation for bus address: %#x\n", busAddr);
247     for (int i = 0; i < 4; i++) {
248         DPRINTF(IdeDisk, "(%d) base:%#x mask:%#x\n",
249                 i, wsba[i], wsm[i]);
250 
251         windowBase = wsba[i];
252         windowMask = ~wsm[i] & (ULL(0xfff) << 20);
253 
254         if ((busAddr & windowMask) == (windowBase & windowMask)) {
255             DPRINTF(IdeDisk, "Would have matched %d (wb:%#x wm:%#x --> ba&wm:%#x 
      wb&wm:%#x)\n",
256                     i, windowBase, windowMask, (busAddr & windowMask),
257                     (windowBase & windowMask));
258         }
259     }
260 #endif
261 
262     for (int i = 0; i < 4; i++) {
263 
264         windowBase = wsba[i];
265         windowMask = ~wsm[i] & (ULL(0xfff) << 20);
266 
267         if ((busAddr & windowMask) == (windowBase & windowMask)) {
268 
269             if (wsba[i] & 0x1) {   // see if enabled
270                 if (wsba[i] & 0x2) { // see if SG bit is set
281                     tbaMask = ~(((wsm[i] & (ULL(0xfff) << 20)) >> 10) | ULL(0x3ff
      ));
282                     baMask = (wsm[i] & (ULL(0xfff) << 20)) | (ULL(0x7f) << 13);
283                     pteAddr = (tba[i] & tbaMask) | ((busAddr & baMask) >> 10);
284 
285                     sys->physProxy.readBlob(pteAddr, (uint8_t*)&pteEntry,
286                                             sizeof(uint64_t));
287 
288                     dmaAddr = ((pteEntry & ~ULL(0x1)) << 12) | (busAddr & ULL(0x1
      fff));
289 
290                 } else {
291                     baMask = (wsm[i] & (ULL(0xfff) << 20)) | ULL(0xfffff);
292                     tbaMask = ~baMask;
293                     dmaAddr = (tba[i] & tbaMask) | (busAddr & baMask);
294                 }
295 
296                 return (dmaAddr & DMA_ADDR_MASK);
297             }
298         }
299     }
300 
301     // if no match was found, then return the original address
302     return busAddr;
303 }
\end{DoxyCode}
\hypertarget{classTsunamiPChip_af22e5d6d660b97db37003ac61ac4ee49}{
\index{TsunamiPChip@{TsunamiPChip}!unserialize@{unserialize}}
\index{unserialize@{unserialize}!TsunamiPChip@{TsunamiPChip}}
\subsubsection[{unserialize}]{\setlength{\rightskip}{0pt plus 5cm}void unserialize ({\bf Checkpoint} $\ast$ {\em cp}, \/  const std::string \& {\em section})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTsunamiPChip_af22e5d6d660b97db37003ac61ac4ee49}
Reconstruct the state of this object from a checkpoint. 
\begin{DoxyParams}{引数}
\item[{\em \hyperlink{namespacecp}{cp}}]The checkpoint use. \item[{\em section}]The section name of this object \end{DoxyParams}


\hyperlink{classSerializable_af100c4e9feabf3cd918619c88c718387}{Serializable}を再定義しています。


\begin{DoxyCode}
338 {
339     UNSERIALIZE_SCALAR(pctl);
340     UNSERIALIZE_ARRAY(wsba, 4);
341     UNSERIALIZE_ARRAY(wsm, 4);
342     UNSERIALIZE_ARRAY(tba, 4);
343 }
\end{DoxyCode}
\hypertarget{classTsunamiPChip_a4cefab464e72b5dd42c003a0a4341802}{
\index{TsunamiPChip@{TsunamiPChip}!write@{write}}
\index{write@{write}!TsunamiPChip@{TsunamiPChip}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} write ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classTsunamiPChip_a4cefab464e72b5dd42c003a0a4341802}
Pure virtual function that the device must implement. Called when a write command is recieved by the port. 
\begin{DoxyParams}{引数}
\item[{\em pkt}]\hyperlink{classPacket}{Packet} describing this request \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
number of ticks it took to complete 
\end{DoxyReturn}


\hyperlink{classPioDevice_afe8371668d023bb2516b286e5e399b6f}{PioDevice}を実装しています。


\begin{DoxyCode}
153 {
154     assert(pkt->getAddr() >= pioAddr && pkt->getAddr() < pioAddr + pioSize);
155     Addr daddr = (pkt->getAddr() - pioAddr) >> 6;
156 
157     assert(pkt->getSize() == sizeof(uint64_t));
158 
159     DPRINTF(Tsunami, "write - va=%#x size=%d \n", pkt->getAddr(), pkt->getSize())
      ;
160 
161     switch(daddr) {
162         case TSDEV_PC_WSBA0:
163               wsba[0] = pkt->get<uint64_t>();
164               break;
165         case TSDEV_PC_WSBA1:
166               wsba[1] = pkt->get<uint64_t>();
167               break;
168         case TSDEV_PC_WSBA2:
169               wsba[2] = pkt->get<uint64_t>();
170               break;
171         case TSDEV_PC_WSBA3:
172               wsba[3] = pkt->get<uint64_t>();
173               break;
174         case TSDEV_PC_WSM0:
175               wsm[0] = pkt->get<uint64_t>();
176               break;
177         case TSDEV_PC_WSM1:
178               wsm[1] = pkt->get<uint64_t>();
179               break;
180         case TSDEV_PC_WSM2:
181               wsm[2] = pkt->get<uint64_t>();
182               break;
183         case TSDEV_PC_WSM3:
184               wsm[3] = pkt->get<uint64_t>();
185               break;
186         case TSDEV_PC_TBA0:
187               tba[0] = pkt->get<uint64_t>();
188               break;
189         case TSDEV_PC_TBA1:
190               tba[1] = pkt->get<uint64_t>();
191               break;
192         case TSDEV_PC_TBA2:
193               tba[2] = pkt->get<uint64_t>();
194               break;
195         case TSDEV_PC_TBA3:
196               tba[3] = pkt->get<uint64_t>();
197               break;
198         case TSDEV_PC_PCTL:
199               pctl = pkt->get<uint64_t>();
200               break;
201         case TSDEV_PC_PLAT:
202               panic("PC_PLAT not implemented\n");
203         case TSDEV_PC_RES:
204               panic("PC_RES not implemented\n");
205         case TSDEV_PC_PERROR:
206               break;
207         case TSDEV_PC_PERRMASK:
208               panic("PC_PERRMASK not implemented\n");
209         case TSDEV_PC_PERRSET:
210               panic("PC_PERRSET not implemented\n");
211         case TSDEV_PC_TLBIV:
212               panic("PC_TLBIV not implemented\n");
213         case TSDEV_PC_TLBIA:
214               break; // value ignored, supposted to invalidate SG TLB
215         case TSDEV_PC_PMONCTL:
216               panic("PC_PMONCTL not implemented\n");
217         case TSDEV_PC_PMONCNT:
218               panic("PC_PMONCTN not implemented\n");
219         default:
220             panic("Default in PChip write reached reading 0x%x\n", daddr);
221 
222     } // uint64_t
223 
224     pkt->makeAtomicResponse();
225     return pioDelay;
226 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classTsunamiPChip_a8df2c098b72e9eee77a79290c8e4a6c5}{
\index{TsunamiPChip@{TsunamiPChip}!pctl@{pctl}}
\index{pctl@{pctl}!TsunamiPChip@{TsunamiPChip}}
\subsubsection[{pctl}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf pctl}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiPChip_a8df2c098b72e9eee77a79290c8e4a6c5}
Pchip control register \hypertarget{classTsunamiPChip_ad35698b8e7094fe0888d00cad38965ec}{
\index{TsunamiPChip@{TsunamiPChip}!tba@{tba}}
\index{tba@{tba}!TsunamiPChip@{TsunamiPChip}}
\subsubsection[{tba}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf tba}\mbox{[}4\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiPChip_ad35698b8e7094fe0888d00cad38965ec}
Translated Base Addresses \hypertarget{classTsunamiPChip_a8a9c49447e0f2ce2f8aaf2c7a4299eac}{
\index{TsunamiPChip@{TsunamiPChip}!TsunamiPciBus0Config@{TsunamiPciBus0Config}}
\index{TsunamiPciBus0Config@{TsunamiPciBus0Config}!TsunamiPChip@{TsunamiPChip}}
\subsubsection[{TsunamiPciBus0Config}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Addr} {\bf TsunamiPciBus0Config} = ULL(0x801fe000000)\hspace{0.3cm}{\ttfamily  \mbox{[}static, protected\mbox{]}}}}
\label{classTsunamiPChip_a8a9c49447e0f2ce2f8aaf2c7a4299eac}
\hypertarget{classTsunamiPChip_a8281ba8e4694bf75ec8b8b5d4d4ad50f}{
\index{TsunamiPChip@{TsunamiPChip}!wsba@{wsba}}
\index{wsba@{wsba}!TsunamiPChip@{TsunamiPChip}}
\subsubsection[{wsba}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf wsba}\mbox{[}4\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiPChip_a8281ba8e4694bf75ec8b8b5d4d4ad50f}
Window Base addresses \hypertarget{classTsunamiPChip_a16d1e04d18db960e6c8059d404989395}{
\index{TsunamiPChip@{TsunamiPChip}!wsm@{wsm}}
\index{wsm@{wsm}!TsunamiPChip@{TsunamiPChip}}
\subsubsection[{wsm}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t {\bf wsm}\mbox{[}4\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classTsunamiPChip_a16d1e04d18db960e6c8059d404989395}
Window masks 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
dev/alpha/\hyperlink{tsunami__pchip_8hh}{tsunami\_\-pchip.hh}\item 
dev/alpha/\hyperlink{tsunami__pchip_8cc}{tsunami\_\-pchip.cc}\end{DoxyCompactItemize}
