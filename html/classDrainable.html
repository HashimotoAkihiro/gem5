<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>File&nbsp;GEM5&nbsp;Wrapper: クラス Drainable</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- 作成： Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>メインページ</span></a></li>
      <li><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>構成</span></a></li>
      <li><a href="classes.html"><span>構成索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>構成メンバ</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>クラス Drainable</h1><!-- doxytag: class="Drainable" -->
<p><code>#include &lt;<a class="el" href="drain_8hh_source.html">drain.hh</a>&gt;</code></p>
<div class="dynheader">
Drainableに対する継承グラフ</div>
<div class="dynsection">
 <div class="center">
  <img src="classDrainable.gif" usemap="#Drainable_map" alt=""/>
  <map id="Drainable_map" name="Drainable_map">
<area href="classBaseBus_1_1Layer.html" alt="Layer&lt; SrcType, DstType &gt;" shape="rect" coords="0,56,172,80"/>
<area href="classCopyEngine_1_1CopyEngineChannel.html" alt="CopyEngineChannel" shape="rect" coords="182,56,354,80"/>
<area href="classMSHRQueue.html" alt="MSHRQueue" shape="rect" coords="364,56,536,80"/>
<area href="classPacketQueue.html" alt="PacketQueue" shape="rect" coords="546,56,718,80"/>
<area href="classSimObject.html" alt="SimObject" shape="rect" coords="910,56,1082,80"/>
<area href="classMasterPacketQueue.html" alt="MasterPacketQueue" shape="rect" coords="728,112,900,136"/>
<area href="classSlavePacketQueue.html" alt="SlavePacketQueue" shape="rect" coords="728,168,900,192"/>
<area href="classBaseTLB.html" alt="BaseTLB" shape="rect" coords="1092,112,1264,136"/>
<area href="classBasicLink.html" alt="BasicLink" shape="rect" coords="1092,168,1264,192"/>
<area href="classBasicLink_1_1BasicLink.html" alt="BasicLink" shape="rect" coords="1092,224,1264,248"/>
<area href="classBPredUnit.html" alt="BPredUnit" shape="rect" coords="1092,280,1264,304"/>
<area href="classBranchPredictor_1_1BranchPredictor.html" alt="BranchPredictor" shape="rect" coords="1092,336,1264,360"/>
<area href="classCache_1_1RubyCache.html" alt="RubyCache" shape="rect" coords="1092,392,1264,416"/>
<area href="classCacheMemory.html" alt="CacheMemory" shape="rect" coords="1092,448,1264,472"/>
<area href="classClockDomain.html" alt="ClockDomain" shape="rect" coords="1092,504,1264,528"/>
<area href="classClockDomain_1_1ClockDomain.html" alt="ClockDomain" shape="rect" coords="1092,560,1264,584"/>
<area href="classClockedObject.html" alt="ClockedObject" shape="rect" coords="1092,616,1264,640"/>
<area href="classClockedObject_1_1ClockedObject.html" alt="ClockedObject" shape="rect" coords="1092,672,1264,696"/>
<area href="classCPA_1_1CPA.html" alt="CPA" shape="rect" coords="1092,728,1264,752"/>
<area href="classDirectedGenerator.html" alt="DirectedGenerator" shape="rect" coords="1092,784,1264,808"/>
<area href="classDirectoryMemory.html" alt="DirectoryMemory" shape="rect" coords="1092,840,1264,864"/>
<area href="classDirectoryMemory_1_1RubyDirectoryMemory.html" alt="RubyDirectoryMemory" shape="rect" coords="1092,896,1264,920"/>
<area href="classDiskImage.html" alt="DiskImage" shape="rect" coords="1092,952,1264,976"/>
<area href="classDiskImage_1_1DiskImage.html" alt="DiskImage" shape="rect" coords="1092,1008,1264,1032"/>
<area href="classEtherDump.html" alt="EtherDump" shape="rect" coords="1092,1064,1264,1088"/>
<area href="classEtherObject.html" alt="EtherObject" shape="rect" coords="1092,1120,1264,1144"/>
<area href="classFaultModel.html" alt="FaultModel" shape="rect" coords="1092,1176,1264,1200"/>
<area href="classFaultModel_1_1FaultModel.html" alt="FaultModel" shape="rect" coords="1092,1232,1264,1256"/>
<area href="classFUDesc.html" alt="FUDesc" shape="rect" coords="1092,1288,1264,1312"/>
<area href="classFuncUnit_1_1FUDesc.html" alt="FUDesc" shape="rect" coords="1092,1344,1264,1368"/>
<area href="classFuncUnit_1_1OpDesc.html" alt="OpDesc" shape="rect" coords="1092,1400,1264,1424"/>
<area href="classFUPool.html" alt="FUPool" shape="rect" coords="1092,1456,1264,1480"/>
<area href="classFUPool_1_1FUPool.html" alt="FUPool" shape="rect" coords="1092,1512,1264,1536"/>
<area href="classGenericTimer.html" alt="GenericTimer" shape="rect" coords="1092,1568,1264,1592"/>
<area href="classIdeDisk.html" alt="IdeDisk" shape="rect" coords="1092,1624,1264,1648"/>
<area href="classIntrControl.html" alt="IntrControl" shape="rect" coords="1092,1680,1264,1704"/>
<area href="classIntrControl_1_1IntrControl.html" alt="IntrControl" shape="rect" coords="1092,1736,1264,1760"/>
<area href="classKvmVM.html" alt="KvmVM" shape="rect" coords="1092,1792,1264,1816"/>
<area href="classOpDesc.html" alt="OpDesc" shape="rect" coords="1092,1848,1264,1872"/>
<area href="classPlatform.html" alt="Platform" shape="rect" coords="1092,1904,1264,1928"/>
<area href="classPlatform_1_1Platform.html" alt="Platform" shape="rect" coords="1092,1960,1264,1984"/>
<area href="classPrefetcher.html" alt="Prefetcher" shape="rect" coords="1092,2016,1264,2040"/>
<area href="classProbeListenerObject.html" alt="ProbeListenerObject" shape="rect" coords="1092,2072,1264,2096"/>
<area href="classProcess.html" alt="Process" shape="rect" coords="1092,2128,1264,2152"/>
<area href="classProcess_1_1Process.html" alt="Process" shape="rect" coords="1092,2184,1264,2208"/>
<area href="classRealView_1_1GenericTimer.html" alt="GenericTimer" shape="rect" coords="1092,2240,1264,2264"/>
<area href="classRoot.html" alt="Root" shape="rect" coords="1092,2296,1264,2320"/>
<area href="classRoot_1_1Root.html" alt="Root" shape="rect" coords="1092,2352,1264,2376"/>
<area href="classRubyDirectedTester_1_1DirectedGenerator.html" alt="DirectedGenerator" shape="rect" coords="1092,2408,1264,2432"/>
<area href="classSimpleDisk.html" alt="SimpleDisk" shape="rect" coords="1092,2464,1264,2488"/>
<area href="classSimpleDisk_1_1SimpleDisk.html" alt="SimpleDisk" shape="rect" coords="1092,2520,1264,2544"/>
<area href="classSouthBridge.html" alt="SouthBridge" shape="rect" coords="1092,2576,1264,2600"/>
<area href="classSouthBridge_1_1SouthBridge.html" alt="SouthBridge" shape="rect" coords="1092,2632,1264,2656"/>
<area href="classTerminal.html" alt="Terminal" shape="rect" coords="1092,2688,1264,2712"/>
<area href="classTerminal_1_1Terminal.html" alt="Terminal" shape="rect" coords="1092,2744,1264,2768"/>
<area href="classTrace_1_1InstTracer.html" alt="InstTracer" shape="rect" coords="1092,2800,1264,2824"/>
<area href="classVncInput.html" alt="VncInput" shape="rect" coords="1092,2856,1264,2880"/>
<area href="classVoltageDomain.html" alt="VoltageDomain" shape="rect" coords="1092,2912,1264,2936"/>
<area href="classVoltageDomain_1_1VoltageDomain.html" alt="VoltageDomain" shape="rect" coords="1092,2968,1264,2992"/>
<area href="classWireBuffer.html" alt="WireBuffer" shape="rect" coords="1092,3024,1264,3048"/>
<area href="classWireBuffer_1_1RubyWireBuffer.html" alt="RubyWireBuffer" shape="rect" coords="1092,3080,1264,3104"/>
</map>
 </div>
</div>

<p><a href="classDrainable-members.html">すべてのメンバ一覧</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public 型</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8">State</a> { <a class="el" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8a2f5f2c4a8c4f4f0519d503dcdfbf55cb">Running</a>, 
<a class="el" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8a929d17847bfad0d4689c9ab8540d5134">Draining</a>, 
<a class="el" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8a5656955cb808502a2ec75b367e2c1e82">Drained</a>
 }</td></tr>
<tr><td colspan="2"><h2>Public メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDrainable.html#ab7e0a5035cfc2b76d859c266fa9f23ac">Drainable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDrainable.html#acbac1c0890f30cd7ed12ce72c755a270">~Drainable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDrainable.html#a1ed42c14f2f622ea6b0df3865e89c8b4">drain</a> (<a class="el" href="classDrainManager.html">DrainManager</a> *drainManager)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDrainable.html#a8f020d3237536fe007fc488c4125c5d8">drainResume</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDrainable.html#aaec8b1741246cef384bc2743ce21cc34">memWriteback</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDrainable.html#a7f243f736712f56d8dd50cd21c77b9d1">memInvalidate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8">State</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDrainable.html#a5c95358f0e9355bcc3979baf3fb7307f">getDrainState</a> () const </td></tr>
<tr><td colspan="2"><h2>Protected メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDrainable.html#ad800905390fe03e850cf996e914038f9">setDrainState</a> (<a class="el" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8">State</a> new_state)</td></tr>
<tr><td colspan="2"><h2>Private 変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8">State</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDrainable.html#a5aef2a2eb3b798eb214b1e83d6f75275">_drainState</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>説明</h2>
<p>Interface for objects that might require draining before checkpointing.</p>
<p>An object's internal state needs to be drained when creating a checkpoint, switching between CPU models, or switching between timing models. Once the internal state has been drained from <em>all</em> objects in the system, the objects are serialized to disc or the configuration change takes place. The process works as follows (see <a class="el" href="simulate_8py.html">simulate.py</a> for details):</p>
<ol>
<li>
<p class="startli">An instance of a <a class="el" href="classDrainManager.html">DrainManager</a> is created to keep track of how many objects need to be drained. The object maintains an internal counter that is decreased every time its CountedDrainEvent::signalDrainDone() method is called. When the counter reaches zero, the simulation is stopped.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Call <a class="el" href="classDrainable.html#a1ed42c14f2f622ea6b0df3865e89c8b4">Drainable::drain()</a> for every object in the system. Draining has completed if all of them return zero. Otherwise, the sum of the return values is loaded into the counter of the <a class="el" href="classDrainManager.html">DrainManager</a>. A pointer to the drain manager is passed as an argument to the <a class="el" href="classDrainable.html#a1ed42c14f2f622ea6b0df3865e89c8b4">drain()</a> method.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Continue simulation. When an object has finished draining its internal state, it calls CountedDrainEvent::signalDrainDone() on the manager. When the counter in the manager reaches zero, the simulation stops.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classCheck.html">Check</a> if any object still needs draining, if so repeat the process above.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Serialize objects, switch CPU model, or change timing model.</p>
<p class="endli"></p>
</li>
<li>
Call <a class="el" href="classDrainable.html#a8f020d3237536fe007fc488c4125c5d8">Drainable::drainResume()</a> and continue the simulation. </li>
</ol>
<hr/><h2>列挙型</h2>
<a class="anchor" id="a5d74787dedbc4e11c1ab15bf487e61f8"></a><!-- doxytag: member="Drainable::State" ref="a5d74787dedbc4e11c1ab15bf487e61f8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8">State</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Object drain/handover states</p>
<p>An object starts out in the Running state. When the simulator prepares to take a snapshot or prepares a CPU for handover, it calls the <a class="el" href="classDrainable.html#a1ed42c14f2f622ea6b0df3865e89c8b4">drain()</a> method to transfer the object into the Draining or Drained state. If any object enters the Draining state (<a class="el" href="classDrainable.html#a1ed42c14f2f622ea6b0df3865e89c8b4">drain()</a> returning &gt;0), simulation continues until it all objects have entered the Drained state.</p>
<p>Before resuming simulation, the simulator calls <a class="el" href="namespacem5_1_1simulate.html#a2985608bac11887a6ae3df9b068b10fe">resume()</a> to transfer the object to the Running state.</p>
<dl class="note"><dt><b>覚え書き:</b></dt><dd>Even though the state of an object (visible to the rest of the world through getState()) could be used to determine if all objects have entered the Drained state, the protocol is actually a bit more elaborate. See <a class="el" href="classDrainable.html#a1ed42c14f2f622ea6b0df3865e89c8b4">drain()</a> for details. </dd></dl>
<dl><dt><b>列挙型の値: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a5d74787dedbc4e11c1ab15bf487e61f8a2f5f2c4a8c4f4f0519d503dcdfbf55cb"></a><!-- doxytag: member="Running" ref="a5d74787dedbc4e11c1ab15bf487e61f8a2f5f2c4a8c4f4f0519d503dcdfbf55cb" args="" -->Running</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5d74787dedbc4e11c1ab15bf487e61f8a929d17847bfad0d4689c9ab8540d5134"></a><!-- doxytag: member="Draining" ref="a5d74787dedbc4e11c1ab15bf487e61f8a929d17847bfad0d4689c9ab8540d5134" args="" -->Draining</em>&nbsp;</td><td>
<p>Running normally </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5d74787dedbc4e11c1ab15bf487e61f8a5656955cb808502a2ec75b367e2c1e82"></a><!-- doxytag: member="Drained" ref="a5d74787dedbc4e11c1ab15bf487e61f8a5656955cb808502a2ec75b367e2c1e82" args="" -->Drained</em>&nbsp;</td><td>
<p>Draining buffers pending serialization/handover Buffers drained, ready for serialization/handover </p>
</td></tr>
</table>
</dd>
</dl>

<p><a class="el" href="classBaseBus_1_1Layer.html#a5d74787dedbc4e11c1ab15bf487e61f8">Layer&lt; SrcType, DstType &gt;</a>, と <a class="el" href="classVGic.html#a4ad4e2a479baf0de8e8cdcb0c84276db">VGic</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00162"></a>00162                {
<a name="l00163"></a>00163         <a class="code" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8a2f5f2c4a8c4f4f0519d503dcdfbf55cb">Running</a>,  
<a name="l00164"></a>00164         <a class="code" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8a929d17847bfad0d4689c9ab8540d5134">Draining</a>, 
<a name="l00165"></a>00165         <a class="code" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8a5656955cb808502a2ec75b367e2c1e82">Drained</a>   
<a name="l00166"></a>00166     };
</pre></div></p>

</div>
</div>
<hr/><h2>コンストラクタとデストラクタ</h2>
<a class="anchor" id="ab7e0a5035cfc2b76d859c266fa9f23ac"></a><!-- doxytag: member="Drainable::Drainable" ref="ab7e0a5035cfc2b76d859c266fa9f23ac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDrainable.html">Drainable</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00061"></a>00061     : <a class="code" href="classDrainable.html#a5aef2a2eb3b798eb214b1e83d6f75275">_drainState</a>(<a class="code" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8a2f5f2c4a8c4f4f0519d503dcdfbf55cb">Running</a>)
<a name="l00062"></a>00062 {
<a name="l00063"></a>00063 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="acbac1c0890f30cd7ed12ce72c755a270"></a><!-- doxytag: member="Drainable::~Drainable" ref="acbac1c0890f30cd7ed12ce72c755a270" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classDrainable.html">Drainable</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00066"></a>00066 {
<a name="l00067"></a>00067 }
</pre></div></p>

</div>
</div>
<hr/><h2>関数</h2>
<a class="anchor" id="a1ed42c14f2f622ea6b0df3865e89c8b4"></a><!-- doxytag: member="Drainable::drain" ref="a1ed42c14f2f622ea6b0df3865e89c8b4" args="(DrainManager *drainManager)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int drain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDrainManager.html">DrainManager</a> *&nbsp;</td>
          <td class="paramname"> <em>drainManager</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine if an object needs draining and register a <a class="el" href="classDrainManager.html">DrainManager</a>.</p>
<p>When draining the state of an object, the simulator calls drain with a pointer to a drain manager. If the object does not need further simulation to drain internal buffers, it switched to the Drained state and returns 0, otherwise it switches to the Draining state and returns the number of times that it will call <a class="el" href="classEvent.html#a142b75b68a6291400e20fb0dd905b1c8">Event::process()</a> on the drain event. Most objects are expected to return either 0 or 1.</p>
<dl class="note"><dt><b>覚え書き:</b></dt><dd>An object that has entered the Drained state can be disturbed by other objects in the system and consequently be forced to enter the Draining state again. The simulator therefore repeats the draining process until all objects return 0 on the first call to <a class="el" href="classDrainable.html#a1ed42c14f2f622ea6b0df3865e89c8b4">drain()</a>.</dd></dl>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>drainManager</em>&nbsp;</td><td><a class="el" href="classDrainManager.html">DrainManager</a> to use to inform the simulator when draining has completed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>戻り値:</b></dt><dd>0 if the object is ready for serialization now, &gt;0 if it needs further simulation. </dd></dl>

<p><a class="el" href="classArmISA_1_1TableWalker.html#aa8a18d230dba7a674ac8a0b4f35bc36a">TableWalker</a>, <a class="el" href="classTrafficGen.html#aa8a18d230dba7a674ac8a0b4f35bc36a">TrafficGen</a>, <a class="el" href="classCopyEngine_1_1CopyEngineChannel.html#a6bf479c521c7c3eb473822d953275b26">CopyEngineChannel</a>, <a class="el" href="classCopyEngine.html#a6bf479c521c7c3eb473822d953275b26">CopyEngine</a>, <a class="el" href="classDmaDevice.html#a6bf479c521c7c3eb473822d953275b26">DmaDevice</a>, <a class="el" href="classIGbE.html#aa8a18d230dba7a674ac8a0b4f35bc36a">IGbE</a>, <a class="el" href="classPioDevice.html#a6bf479c521c7c3eb473822d953275b26">PioDevice</a>, <a class="el" href="classPciDevice.html#aa8a18d230dba7a674ac8a0b4f35bc36a">PciDevice</a>, <a class="el" href="classBaseBus_1_1Layer.html#aa8a18d230dba7a674ac8a0b4f35bc36a">Layer&lt; SrcType, DstType &gt;</a>, <a class="el" href="classBaseBus.html#ac8c1510f7e1591e75a5c79b4b873f6b4">BaseBus</a>, <a class="el" href="classBaseCache.html#aa8a18d230dba7a674ac8a0b4f35bc36a">BaseCache</a>, <a class="el" href="classMSHRQueue.html#aa8a18d230dba7a674ac8a0b4f35bc36a">MSHRQueue</a>, <a class="el" href="classCoherentBus.html#aa8a18d230dba7a674ac8a0b4f35bc36a">CoherentBus</a>, <a class="el" href="classDRAMCtrl.html#aa8a18d230dba7a674ac8a0b4f35bc36a">DRAMCtrl</a>, <a class="el" href="classDRAMSim2.html#aa8a18d230dba7a674ac8a0b4f35bc36a">DRAMSim2</a>, <a class="el" href="classNoncoherentBus.html#aa8a18d230dba7a674ac8a0b4f35bc36a">NoncoherentBus</a>, <a class="el" href="classPacketQueue.html#aa8a18d230dba7a674ac8a0b4f35bc36a">PacketQueue</a>, <a class="el" href="classRubyMemoryControl.html#aa8a18d230dba7a674ac8a0b4f35bc36a">RubyMemoryControl</a>, <a class="el" href="classRubyPort.html#aa8a18d230dba7a674ac8a0b4f35bc36a">RubyPort</a>, <a class="el" href="classSimpleMemory.html#aa8a18d230dba7a674ac8a0b4f35bc36a">SimpleMemory</a>, <a class="el" href="classSimObject.html#a6bf479c521c7c3eb473822d953275b26">SimObject</a>, と <a class="el" href="classSystem.html#aa8a18d230dba7a674ac8a0b4f35bc36a">System</a>で実装されています。</p>

</div>
</div>
<a class="anchor" id="a8f020d3237536fe007fc488c4125c5d8"></a><!-- doxytag: member="Drainable::drainResume" ref="a8f020d3237536fe007fc488c4125c5d8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drainResume </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resume execution after a successful drain.</p>
<dl class="note"><dt><b>覚え書き:</b></dt><dd>This method is normally only called from the simulation scripts. </dd></dl>

<p><a class="el" href="classArmISA_1_1TableWalker.html#a8f020d3237536fe007fc488c4125c5d8">TableWalker</a>, <a class="el" href="classArmISA_1_1TLB.html#a8f020d3237536fe007fc488c4125c5d8">TLB</a>, <a class="el" href="classCopyEngine_1_1CopyEngineChannel.html#a8f020d3237536fe007fc488c4125c5d8">CopyEngineChannel</a>, <a class="el" href="classCopyEngine.html#a8f020d3237536fe007fc488c4125c5d8">CopyEngine</a>, <a class="el" href="classIGbE.html#a8f020d3237536fe007fc488c4125c5d8">IGbE</a>, <a class="el" href="classNSGigE.html#a8f020d3237536fe007fc488c4125c5d8">NSGigE</a>, <a class="el" href="classSinic_1_1Device.html#a8f020d3237536fe007fc488c4125c5d8">Device</a>, と <a class="el" href="classSystem.html#a8f020d3237536fe007fc488c4125c5d8">System</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00071"></a>00071 {
<a name="l00072"></a>00072     <a class="code" href="classDrainable.html#a5aef2a2eb3b798eb214b1e83d6f75275">_drainState</a> = <a class="code" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8a2f5f2c4a8c4f4f0519d503dcdfbf55cb">Running</a>;
<a name="l00073"></a>00073 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5c95358f0e9355bcc3979baf3fb7307f"></a><!-- doxytag: member="Drainable::getDrainState" ref="a5c95358f0e9355bcc3979baf3fb7307f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8">State</a> getDrainState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00228"></a>00228 { <span class="keywordflow">return</span> <a class="code" href="classDrainable.html#a5aef2a2eb3b798eb214b1e83d6f75275">_drainState</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7f243f736712f56d8dd50cd21c77b9d1"></a><!-- doxytag: member="Drainable::memInvalidate" ref="a7f243f736712f56d8dd50cd21c77b9d1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void memInvalidate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invalidate the contents of memory buffers.</p>
<p>When the switching to hardware virtualized CPU models, we need to make sure that we don't have any cached state in the system that might become stale when we return. This method is used to flush all such state back to main memory.</p>
<p>This does <em>not</em> cause any dirty state to be written back to memory. </p>

<p><a class="el" href="classBaseCache.html#aeb9356f940fbf8410f41920ee1d5864d">BaseCache</a>, <a class="el" href="classCache.html#afea64b0aa579c17485db54c6a5c2ede3">Cache&lt; TagStore &gt;</a>, と <a class="el" href="classBaseTLB.html#afea64b0aa579c17485db54c6a5c2ede3">BaseTLB</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00226"></a>00226 {};
</pre></div></p>

</div>
</div>
<a class="anchor" id="aaec8b1741246cef384bc2743ce21cc34"></a><!-- doxytag: member="Drainable::memWriteback" ref="aaec8b1741246cef384bc2743ce21cc34" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void memWriteback </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write back dirty buffers to memory using functional writes.</p>
<p>After returning, an object implementing this method should have written all its dirty data back to memory. This method is typically used to prepare a system with caches for checkpointing. </p>

<p><a class="el" href="classBaseCache.html#afd3c83f1883488031612de6c47fcaabb">BaseCache</a>, と <a class="el" href="classCache.html#a381272ae5c2cc173adb59cd67a76b458">Cache&lt; TagStore &gt;</a>で再定義されています。</p>

<p><div class="fragment"><pre class="fragment"><a name="l00213"></a>00213 {};
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad800905390fe03e850cf996e914038f9"></a><!-- doxytag: member="Drainable::setDrainState" ref="ad800905390fe03e850cf996e914038f9" args="(State new_state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setDrainState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8">State</a>&nbsp;</td>
          <td class="paramname"> <em>new_state</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00231"></a>00231 { <a class="code" href="classDrainable.html#a5aef2a2eb3b798eb214b1e83d6f75275">_drainState</a> = new_state; }
</pre></div></p>

</div>
</div>
<hr/><h2>変数</h2>
<a class="anchor" id="a5aef2a2eb3b798eb214b1e83d6f75275"></a><!-- doxytag: member="Drainable::_drainState" ref="a5aef2a2eb3b798eb214b1e83d6f75275" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8">State</a> <a class="el" href="classDrainable.html#a5aef2a2eb3b798eb214b1e83d6f75275">_drainState</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>このクラスの説明は次のファイルから生成されました:<ul>
<li>sim/<a class="el" href="drain_8hh_source.html">drain.hh</a></li>
<li>sim/<a class="el" href="drain_8cc.html">drain.cc</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>File&nbsp;GEM5&nbsp;Wrapperに対して25 May 2015に生成されました。&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
