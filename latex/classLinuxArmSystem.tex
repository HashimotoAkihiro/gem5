\hypertarget{classLinuxArmSystem}{
\section{クラス LinuxArmSystem}
\label{classLinuxArmSystem}\index{LinuxArmSystem@{LinuxArmSystem}}
}


{\ttfamily \#include $<$system.hh$>$}LinuxArmSystemに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=7cm]{classLinuxArmSystem}
\end{center}
\end{figure}
\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
typedef LinuxArmSystemParams \hyperlink{classLinuxArmSystem_ae0ebf28024a7bb607cc65e59c8faa9d5}{Params}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
const \hyperlink{classLinuxArmSystem_ae0ebf28024a7bb607cc65e59c8faa9d5}{Params} $\ast$ \hyperlink{classLinuxArmSystem_acd3c3feb78ae7a8f88fe0f110a718dff}{params} () const 
\item 
\hyperlink{classLinuxArmSystem_a8bd9f34635b50e93feedccfe117e75bb}{LinuxArmSystem} (\hyperlink{classLinuxArmSystem_ae0ebf28024a7bb607cc65e59c8faa9d5}{Params} $\ast$p)
\item 
\hyperlink{classLinuxArmSystem_a3e10e01606ed67da6f24837440bfb69f}{$\sim$LinuxArmSystem} ()
\item 
void \hyperlink{classLinuxArmSystem_a3c34ea9b29f410748d4435a667484924}{initState} ()
\item 
bool \hyperlink{classLinuxArmSystem_ac081da131af9bc2b37f4c4d7d99eaff1}{adderBootUncacheable} (\hyperlink{classm5_1_1params_1_1Addr}{Addr} a)
\item 
void \hyperlink{classLinuxArmSystem_aecc7d8debf54990ffeaaed5bac7d7d81}{startup} ()
\item 
void \hyperlink{classLinuxArmSystem_a7126cba24850188b3f0e08beec5e95d8}{mapPid} (\hyperlink{classThreadContext}{ThreadContext} $\ast$tc, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} pid)
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classLinuxArmSystem_a4f36b860c5380f4fc20e37e283fd8a1b}{enableContextSwitchStatsDump}
\item 
std::map$<$ \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t}, \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} $>$ \hyperlink{classLinuxArmSystem_af0a9621b833015091de5c531ad29b078}{taskMap}
\item 
std::ostream $\ast$ \hyperlink{classLinuxArmSystem_aade5b03480aa42a0aab017e273e847a1}{taskFile}
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDumpStatsPCEvent}{DumpStatsPCEvent} $\ast$ \hyperlink{classLinuxArmSystem_a20f10ec8abaa110783e089fa10fc4da3}{dumpStatsPCEvent}
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classPCEvent}{PCEvent} $\ast$ \hyperlink{classLinuxArmSystem_a06483304d3fd0e7aa71e46d602fd8fca}{kernelPanicEvent}
\item 
\hyperlink{classPCEvent}{PCEvent} $\ast$ \hyperlink{classLinuxArmSystem_a34ff17256dac7f50230fa2647f283d8b}{kernelOopsEvent}
\item 
Linux::UDelayEvent $\ast$ \hyperlink{classLinuxArmSystem_a556c0b2adbf4b92eb5105b222ce79e55}{uDelaySkipEvent}
\item 
Linux::UDelayEvent $\ast$ \hyperlink{classLinuxArmSystem_a4f8baa07addc116cd3bbca7ced7ed334}{constUDelaySkipEvent}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classLinuxArmSystem_adfcef8a6e43803757c1e941c5005ad36}{secDataPtrAddr}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classLinuxArmSystem_a6c059b006ceb752c5e6b2e1d90b54e33}{secDataAddr}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classLinuxArmSystem_a38de836fdda5d23ffd25ffbd1a1faa74}{penReleaseAddr}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classLinuxArmSystem_a013c7886af50b6686a3146af9a3ea898}{pen64ReleaseAddr}
\item 
\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} \hyperlink{classLinuxArmSystem_ab9398c8331a3a3619bf16596eb81c1dc}{bootReleaseAddr}
\end{DoxyCompactItemize}


\subsection{型定義}
\hypertarget{classLinuxArmSystem_ae0ebf28024a7bb607cc65e59c8faa9d5}{
\index{LinuxArmSystem@{LinuxArmSystem}!Params@{Params}}
\index{Params@{Params}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{Params}]{\setlength{\rightskip}{0pt plus 5cm}typedef LinuxArmSystemParams {\bf Params}}}
\label{classLinuxArmSystem_ae0ebf28024a7bb607cc65e59c8faa9d5}
Boilerplate params code 

\hyperlink{classArmSystem_a8ae84e66b34bac08937a6bad4412ba5d}{ArmSystem}を再定義しています。

\subsection{コンストラクタとデストラクタ}
\hypertarget{classLinuxArmSystem_a8bd9f34635b50e93feedccfe117e75bb}{
\index{LinuxArmSystem@{LinuxArmSystem}!LinuxArmSystem@{LinuxArmSystem}}
\index{LinuxArmSystem@{LinuxArmSystem}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{LinuxArmSystem}]{\setlength{\rightskip}{0pt plus 5cm}{\bf LinuxArmSystem} ({\bf Params} $\ast$ {\em p})}}
\label{classLinuxArmSystem_a8bd9f34635b50e93feedccfe117e75bb}



\begin{DoxyCode}
64     : ArmSystem(p),
65       enableContextSwitchStatsDump(p->enable_context_switch_stats_dump),
66       kernelPanicEvent(NULL), kernelOopsEvent(NULL),
67       bootReleaseAddr(p->boot_release_addr)
68 {
69     if (p->panic_on_panic) {
70         kernelPanicEvent = addKernelFuncEventOrPanic<PanicPCEvent>(
71             "panic", "Kernel panic in simulated kernel");
72     } else {
73 #ifndef NDEBUG
74         kernelPanicEvent = addKernelFuncEventOrPanic<BreakPCEvent>("panic");
75 #endif
76     }
77 
78     if (p->panic_on_oops) {
79         kernelOopsEvent = addKernelFuncEventOrPanic<PanicPCEvent>(
80             "oops_exit", "Kernel oops in guest");
81     }
82 
83     // With ARM udelay() is #defined to __udelay
84     // newer kernels use __loop_udelay and __loop_const_udelay symbols
85     uDelaySkipEvent = addKernelFuncEvent<UDelayEvent>(
86         "__loop_udelay", "__udelay", 1000, 0);
87     if(!uDelaySkipEvent)
88         uDelaySkipEvent = addKernelFuncEventOrPanic<UDelayEvent>(
89          "__udelay", "__udelay", 1000, 0);
90 
91     // constant arguments to udelay() have some precomputation done ahead of
92     // time. Constant comes from code.
93     constUDelaySkipEvent = addKernelFuncEvent<UDelayEvent>(
94         "__loop_const_udelay", "__const_udelay", 1000, 107374);
95     if(!constUDelaySkipEvent)
96         constUDelaySkipEvent = addKernelFuncEventOrPanic<UDelayEvent>(
97          "__const_udelay", "__const_udelay", 1000, 107374);
98 
99     secDataPtrAddr = 0;
100     secDataAddr = 0;
101     penReleaseAddr = 0;
102 
103     kernelSymtab->findAddress("__secondary_data", secDataPtrAddr);
104     kernelSymtab->findAddress("secondary_data", secDataAddr);
105     kernelSymtab->findAddress("pen_release", penReleaseAddr);
106     kernelSymtab->findAddress("secondary_holding_pen_release", pen64ReleaseAddr);
      
107 
108     secDataPtrAddr &= ~ULL(0x7F);
109     secDataAddr &= ~ULL(0x7F);
110     penReleaseAddr &= ~ULL(0x7F);
111     pen64ReleaseAddr &= ~ULL(0x7F);
112     bootReleaseAddr = (bootReleaseAddr & ~ULL(0x7F)) + loadAddrOffset;
113 
114 }
\end{DoxyCode}
\hypertarget{classLinuxArmSystem_a3e10e01606ed67da6f24837440bfb69f}{
\index{LinuxArmSystem@{LinuxArmSystem}!$\sim$LinuxArmSystem@{$\sim$LinuxArmSystem}}
\index{$\sim$LinuxArmSystem@{$\sim$LinuxArmSystem}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{$\sim$LinuxArmSystem}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf LinuxArmSystem} ()}}
\label{classLinuxArmSystem_a3e10e01606ed67da6f24837440bfb69f}



\begin{DoxyCode}
243 {
244     if (uDelaySkipEvent)
245         delete uDelaySkipEvent;
246     if (constUDelaySkipEvent)
247         delete constUDelaySkipEvent;
248 
249     if (dumpStatsPCEvent)
250         delete dumpStatsPCEvent;
251 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classLinuxArmSystem_ac081da131af9bc2b37f4c4d7d99eaff1}{
\index{LinuxArmSystem@{LinuxArmSystem}!adderBootUncacheable@{adderBootUncacheable}}
\index{adderBootUncacheable@{adderBootUncacheable}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{adderBootUncacheable}]{\setlength{\rightskip}{0pt plus 5cm}bool adderBootUncacheable ({\bf Addr} {\em a})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classLinuxArmSystem_ac081da131af9bc2b37f4c4d7d99eaff1}
\hyperlink{classCheck}{Check} if an address should be uncacheable until all caches are enabled. This exits because coherence on some addresses at boot is maintained via sw coherence until the caches are enbaled. Since we don't support sw coherence operations in gem5, this is a method that allows a system type to designate certain addresses that should remain uncachebale for a while. 

\hyperlink{classArmSystem_aa3d376f8ebebf8bc40b44b3ef359cf3d}{ArmSystem}を再定義しています。


\begin{DoxyCode}
118 {
119     Addr block = a & ~ULL(0x7F);
120 
121     if (block == secDataPtrAddr || block == secDataAddr ||
122             block == penReleaseAddr || pen64ReleaseAddr == block ||
123             block == bootReleaseAddr)
124         return true;
125 
126     return false;
127 }
\end{DoxyCode}
\hypertarget{classLinuxArmSystem_a3c34ea9b29f410748d4435a667484924}{
\index{LinuxArmSystem@{LinuxArmSystem}!initState@{initState}}
\index{initState@{initState}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{initState}]{\setlength{\rightskip}{0pt plus 5cm}void initState ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classLinuxArmSystem_a3c34ea9b29f410748d4435a667484924}
Initialise the system 

\hyperlink{classArmSystem_a3c34ea9b29f410748d4435a667484924}{ArmSystem}を再定義しています。


\begin{DoxyCode}
131 {
132     // Moved from the constructor to here since it relies on the
133     // address map being resolved in the interconnect
134 
135     // Call the initialisation of the super class
136     ArmSystem::initState();
137 
138     // Load symbols at physical address, we might not want
139     // to do this permanently, for but early bootup work
140     // it is helpful.
141     if (params()->early_kernel_symbols) {
142         kernel->loadGlobalSymbols(kernelSymtab, loadAddrMask);
143         kernel->loadGlobalSymbols(debugSymbolTable, loadAddrMask);
144     }
145 
146     // Setup boot data structure
147     Addr addr = 0;
148     // Check if the kernel image has a symbol that tells us it supports
149     // device trees.
150     bool kernel_has_fdt_support =
151         kernelSymtab->findAddress("unflatten_device_tree", addr);
152     bool dtb_file_specified = params()->dtb_filename != "";
153 
154     if (kernel_has_fdt_support && dtb_file_specified) {
155         // Kernel supports flattened device tree and dtb file specified.
156         // Using Device Tree Blob to describe system configuration.
157         inform("Loading DTB file: %s at address %#x\n", params()->dtb_filename,
158                 params()->atags_addr + loadAddrOffset);
159 
160         ObjectFile *dtb_file = createObjectFile(params()->dtb_filename, true);
161         if (!dtb_file) {
162             fatal("couldn't load DTB file: %s\n", params()->dtb_filename);
163         }
164 
165         DtbObject *_dtb_file = dynamic_cast<DtbObject*>(dtb_file);
166 
167         if (_dtb_file) {
168             if (!_dtb_file->addBootCmdLine(params()->boot_osflags.c_str(),
169                                            params()->boot_osflags.size())) {
170                 warn("couldn't append bootargs to DTB file: %s\n",
171                      params()->dtb_filename);
172             }
173         } else {
174             warn("dtb_file cast failed; couldn't append bootargs "
175                  "to DTB file: %s\n", params()->dtb_filename);
176         }
177 
178         dtb_file->setTextBase(params()->atags_addr + loadAddrOffset);
179         dtb_file->loadSections(physProxy);
180         delete dtb_file;
181     } else {
182         // Using ATAGS
183         // Warn if the kernel supports FDT and we haven't specified one
184         if (kernel_has_fdt_support) {
185             assert(!dtb_file_specified);
186             warn("Kernel supports device tree, but no DTB file specified\n");
187         }
188         // Warn if the kernel doesn't support FDT and we have specified one
189         if (dtb_file_specified) {
190             assert(!kernel_has_fdt_support);
191             warn("DTB file specified, but no device tree support in kernel\n");
192         }
193 
194         AtagCore ac;
195         ac.flags(1); // read-only
196         ac.pagesize(8192);
197         ac.rootdev(0);
198 
199         AddrRangeList atagRanges = physmem.getConfAddrRanges();
200         if (atagRanges.size() != 1) {
201             fatal("Expected a single ATAG memory entry but got %d\n",
202                   atagRanges.size());
203         }
204         AtagMem am;
205         am.memSize(atagRanges.begin()->size());
206         am.memStart(atagRanges.begin()->start());
207 
208         AtagCmdline ad;
209         ad.cmdline(params()->boot_osflags);
210 
211         DPRINTF(Loader, "boot command line %d bytes: %s\n",
212                 ad.size() <<2, params()->boot_osflags.c_str());
213 
214         AtagNone an;
215 
216         uint32_t size = ac.size() + am.size() + ad.size() + an.size();
217         uint32_t offset = 0;
218         uint8_t *boot_data = new uint8_t[size << 2];
219 
220         offset += ac.copyOut(boot_data + offset);
221         offset += am.copyOut(boot_data + offset);
222         offset += ad.copyOut(boot_data + offset);
223         offset += an.copyOut(boot_data + offset);
224 
225         DPRINTF(Loader, "Boot atags was %d bytes in total\n", size << 2);
226         DDUMP(Loader, boot_data, size << 2);
227 
228         physProxy.writeBlob(params()->atags_addr + loadAddrOffset, boot_data,
229                 size << 2);
230 
231         delete[] boot_data;
232     }
233 
234     // Kernel boot requirements to set up r0, r1 and r2 in ARMv7
235     for (int i = 0; i < threadContexts.size(); i++) {
236         threadContexts[i]->setIntReg(0, 0);
237         threadContexts[i]->setIntReg(1, params()->machine_type);
238         threadContexts[i]->setIntReg(2, params()->atags_addr + loadAddrOffset);
239     }
240 }
\end{DoxyCode}
\hypertarget{classLinuxArmSystem_a7126cba24850188b3f0e08beec5e95d8}{
\index{LinuxArmSystem@{LinuxArmSystem}!mapPid@{mapPid}}
\index{mapPid@{mapPid}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{mapPid}]{\setlength{\rightskip}{0pt plus 5cm}void mapPid ({\bf ThreadContext} $\ast$ {\em tc}, \/  {\bf uint32\_\-t} {\em pid})}}
\label{classLinuxArmSystem_a7126cba24850188b3f0e08beec5e95d8}
This function creates a new task Id for the given pid. 
\begin{DoxyParams}{引数}
\item[{\em tc}]thread context that is currentyl executing \end{DoxyParams}



\begin{DoxyCode}
283 {
284     // Create a new unique identifier for this pid
285     std::map<uint32_t, uint32_t>::iterator itr = taskMap.find(pid);
286     if (itr == taskMap.end()) {
287         uint32_t map_size = taskMap.size();
288         if (map_size > ContextSwitchTaskId::MaxNormalTaskId + 1) {
289             warn_once("Error out of identifiers for cache occupancy stats");
290             taskMap[pid] = ContextSwitchTaskId::Unknown;
291         } else {
292             taskMap[pid] = map_size;
293         }
294     }
295 }
\end{DoxyCode}
\hypertarget{classLinuxArmSystem_acd3c3feb78ae7a8f88fe0f110a718dff}{
\index{LinuxArmSystem@{LinuxArmSystem}!params@{params}}
\index{params@{params}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{params}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Params}$\ast$ params () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classLinuxArmSystem_acd3c3feb78ae7a8f88fe0f110a718dff}


\hyperlink{classArmSystem_acd3c3feb78ae7a8f88fe0f110a718dff}{ArmSystem}を再定義しています。


\begin{DoxyCode}
69     {
70         return dynamic_cast<const Params *>(_params);
71     }
\end{DoxyCode}
\hypertarget{classLinuxArmSystem_aecc7d8debf54990ffeaaed5bac7d7d81}{
\index{LinuxArmSystem@{LinuxArmSystem}!startup@{startup}}
\index{startup@{startup}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{startup}]{\setlength{\rightskip}{0pt plus 5cm}void startup ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classLinuxArmSystem_aecc7d8debf54990ffeaaed5bac7d7d81}
\hyperlink{classLinuxArmSystem_aecc7d8debf54990ffeaaed5bac7d7d81}{startup()} is the final initialization call before simulation. All state is initialized (including unserialized state, if any, such as the \hyperlink{statistics_8hh_a7acdccbf0d35ce0c159c0cdd36371b22}{curTick()} value), so this is the appropriate place to schedule initial event(s) for objects that need them. 

\hyperlink{classSimObject_aecc7d8debf54990ffeaaed5bac7d7d81}{SimObject}を再定義しています。


\begin{DoxyCode}
261 {
262     if (enableContextSwitchStatsDump) {
263         dumpStatsPCEvent = addKernelFuncEvent<DumpStatsPCEvent>("__switch_to");
264         if (!dumpStatsPCEvent)
265            panic("dumpStatsPCEvent not created!");
266 
267         std::string task_filename = "tasks.txt";
268         taskFile = simout.create(name() + "." + task_filename);
269 
270         for (int i = 0; i < _numContexts; i++) {
271             ThreadContext *tc = threadContexts[i];
272             uint32_t pid = tc->getCpuPtr()->getPid();
273             if (pid != Request::invldPid) {
274                 mapPid(tc, pid);
275                 tc->getCpuPtr()->taskId(taskMap[pid]);
276             }
277         }
278     }
279 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classLinuxArmSystem_ab9398c8331a3a3619bf16596eb81c1dc}{
\index{LinuxArmSystem@{LinuxArmSystem}!bootReleaseAddr@{bootReleaseAddr}}
\index{bootReleaseAddr@{bootReleaseAddr}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{bootReleaseAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf bootReleaseAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLinuxArmSystem_ab9398c8331a3a3619bf16596eb81c1dc}
\hypertarget{classLinuxArmSystem_a4f8baa07addc116cd3bbca7ced7ed334}{
\index{LinuxArmSystem@{LinuxArmSystem}!constUDelaySkipEvent@{constUDelaySkipEvent}}
\index{constUDelaySkipEvent@{constUDelaySkipEvent}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{constUDelaySkipEvent}]{\setlength{\rightskip}{0pt plus 5cm}Linux::UDelayEvent$\ast$ {\bf constUDelaySkipEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLinuxArmSystem_a4f8baa07addc116cd3bbca7ced7ed334}
Another PC based skip event for const\_\-udelay(). Similar to the udelay skip, but this function precomputes the first multiply that is done in the generic case since the parameter is known at compile time. Thus we need to do some division to get back to us. \hypertarget{classLinuxArmSystem_a20f10ec8abaa110783e089fa10fc4da3}{
\index{LinuxArmSystem@{LinuxArmSystem}!dumpStatsPCEvent@{dumpStatsPCEvent}}
\index{dumpStatsPCEvent@{dumpStatsPCEvent}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{dumpStatsPCEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DumpStatsPCEvent}$\ast$ {\bf dumpStatsPCEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classLinuxArmSystem_a20f10ec8abaa110783e089fa10fc4da3}
\hypertarget{classLinuxArmSystem_a4f36b860c5380f4fc20e37e283fd8a1b}{
\index{LinuxArmSystem@{LinuxArmSystem}!enableContextSwitchStatsDump@{enableContextSwitchStatsDump}}
\index{enableContextSwitchStatsDump@{enableContextSwitchStatsDump}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{enableContextSwitchStatsDump}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf enableContextSwitchStatsDump}}}
\label{classLinuxArmSystem_a4f36b860c5380f4fc20e37e283fd8a1b}
When enabled, dump stats/task info on context switches for Streamline and per-\/thread cache occupancy studies, etc. \hypertarget{classLinuxArmSystem_a34ff17256dac7f50230fa2647f283d8b}{
\index{LinuxArmSystem@{LinuxArmSystem}!kernelOopsEvent@{kernelOopsEvent}}
\index{kernelOopsEvent@{kernelOopsEvent}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{kernelOopsEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PCEvent}$\ast$ {\bf kernelOopsEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLinuxArmSystem_a34ff17256dac7f50230fa2647f283d8b}
\hyperlink{classEvent}{Event} to halt the simulator if the kernel calls oopses \hypertarget{classLinuxArmSystem_a06483304d3fd0e7aa71e46d602fd8fca}{
\index{LinuxArmSystem@{LinuxArmSystem}!kernelPanicEvent@{kernelPanicEvent}}
\index{kernelPanicEvent@{kernelPanicEvent}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{kernelPanicEvent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PCEvent}$\ast$ {\bf kernelPanicEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLinuxArmSystem_a06483304d3fd0e7aa71e46d602fd8fca}
\hyperlink{classEvent}{Event} to halt the simulator if the kernel calls \hyperlink{base_2misc_8hh_a1445e207e36c97ff84c54b47288cea19}{panic()} \hypertarget{classLinuxArmSystem_a013c7886af50b6686a3146af9a3ea898}{
\index{LinuxArmSystem@{LinuxArmSystem}!pen64ReleaseAddr@{pen64ReleaseAddr}}
\index{pen64ReleaseAddr@{pen64ReleaseAddr}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{pen64ReleaseAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf pen64ReleaseAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLinuxArmSystem_a013c7886af50b6686a3146af9a3ea898}
\hypertarget{classLinuxArmSystem_a38de836fdda5d23ffd25ffbd1a1faa74}{
\index{LinuxArmSystem@{LinuxArmSystem}!penReleaseAddr@{penReleaseAddr}}
\index{penReleaseAddr@{penReleaseAddr}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{penReleaseAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf penReleaseAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLinuxArmSystem_a38de836fdda5d23ffd25ffbd1a1faa74}
\hypertarget{classLinuxArmSystem_a6c059b006ceb752c5e6b2e1d90b54e33}{
\index{LinuxArmSystem@{LinuxArmSystem}!secDataAddr@{secDataAddr}}
\index{secDataAddr@{secDataAddr}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{secDataAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf secDataAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLinuxArmSystem_a6c059b006ceb752c5e6b2e1d90b54e33}
\hypertarget{classLinuxArmSystem_adfcef8a6e43803757c1e941c5005ad36}{
\index{LinuxArmSystem@{LinuxArmSystem}!secDataPtrAddr@{secDataPtrAddr}}
\index{secDataPtrAddr@{secDataPtrAddr}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{secDataPtrAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Addr} {\bf secDataPtrAddr}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLinuxArmSystem_adfcef8a6e43803757c1e941c5005ad36}
These variables store addresses of important data structures that are normaly kept coherent at boot with cache mainetence operations. Since these operations aren't supported in gem5, we keep them coherent by making them uncacheable until all processors in the system boot. \hypertarget{classLinuxArmSystem_aade5b03480aa42a0aab017e273e847a1}{
\index{LinuxArmSystem@{LinuxArmSystem}!taskFile@{taskFile}}
\index{taskFile@{taskFile}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{taskFile}]{\setlength{\rightskip}{0pt plus 5cm}std::ostream$\ast$ {\bf taskFile}}}
\label{classLinuxArmSystem_aade5b03480aa42a0aab017e273e847a1}
This is a file that is placed in the run directory that prints out mappings between taskIds and OS process IDs \hypertarget{classLinuxArmSystem_af0a9621b833015091de5c531ad29b078}{
\index{LinuxArmSystem@{LinuxArmSystem}!taskMap@{taskMap}}
\index{taskMap@{taskMap}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{taskMap}]{\setlength{\rightskip}{0pt plus 5cm}std::map$<${\bf uint32\_\-t}, {\bf uint32\_\-t}$>$ {\bf taskMap}}}
\label{classLinuxArmSystem_af0a9621b833015091de5c531ad29b078}
This map stores a mapping of OS process IDs to internal Task IDs. The mapping is done because the stats system doesn't tend to like vectors that are much greater than 1000 items and the entire process space is 65K. \hypertarget{classLinuxArmSystem_a556c0b2adbf4b92eb5105b222ce79e55}{
\index{LinuxArmSystem@{LinuxArmSystem}!uDelaySkipEvent@{uDelaySkipEvent}}
\index{uDelaySkipEvent@{uDelaySkipEvent}!LinuxArmSystem@{LinuxArmSystem}}
\subsubsection[{uDelaySkipEvent}]{\setlength{\rightskip}{0pt plus 5cm}Linux::UDelayEvent$\ast$ {\bf uDelaySkipEvent}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classLinuxArmSystem_a556c0b2adbf4b92eb5105b222ce79e55}
PC based event to skip udelay($<$time$>$) calls and quiesce the processor for the appropriate amount of time. This is not functionally required but does speed up simulation. 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
arch/arm/linux/\hyperlink{arch_2arm_2linux_2system_8hh}{system.hh}\item 
arch/arm/linux/\hyperlink{arch_2arm_2linux_2system_8cc}{system.cc}\end{DoxyCompactItemize}
