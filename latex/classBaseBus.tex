\hypertarget{classBaseBus}{
\section{クラス BaseBus}
\label{classBaseBus}\index{BaseBus@{BaseBus}}
}


{\ttfamily \#include $<$bus.hh$>$}BaseBusに対する継承グラフ:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=6cm]{classBaseBus}
\end{center}
\end{figure}
\subsection*{構成}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classBaseBus_1_1Layer}{Layer}
\item 
struct \hyperlink{structBaseBus_1_1PortCache}{PortCache}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classBaseBus_a02fd73d861ef2e4aabb38c0c9ff82947}{init} ()
\item 
\hyperlink{classBaseMasterPort}{BaseMasterPort} \& \hyperlink{classBaseBus_adc4e675e51defbdd1e354dac729d0703}{getMasterPort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
\hyperlink{classBaseSlavePort}{BaseSlavePort} \& \hyperlink{classBaseBus_ac918a145092d7514ebc6dbd952dceafb}{getSlavePort} (const std::string \&if\_\-name, \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} idx=\hyperlink{base_2types_8hh_a65bf40f138cf863f0c5e2d8ca1144126}{InvalidPortID})
\item 
virtual unsigned int \hyperlink{classBaseBus_ac8c1510f7e1591e75a5c79b4b873f6b4}{drain} (\hyperlink{classDrainManager}{DrainManager} $\ast$dm)=0
\item 
virtual void \hyperlink{classBaseBus_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classAddrRangeMap}{AddrRangeMap}$<$ \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} $>$::iterator \hyperlink{classBaseBus_adedf751dd92daa01137db6149c004ea7}{PortMapIter}
\item 
typedef \hyperlink{classAddrRangeMap}{AddrRangeMap}$<$ \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} $>$::const\_\-iterator \hyperlink{classBaseBus_ad31cae2c5a87fd020ee036a5d94c7420}{PortMapConstIter}
\item 
typedef \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classSlavePort}{SlavePort} $\ast$ $>$::iterator \hyperlink{classBaseBus_a2b00f9fc9ba7e236c9757ea764cda19d}{SlavePortIter}
\item 
typedef \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMasterPort}{MasterPort} $\ast$ $>$::iterator \hyperlink{classBaseBus_a44e87d907bdab92a2169caddd28979f9}{MasterPortIter}
\item 
typedef \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classSlavePort}{SlavePort} $\ast$ $>$::const\_\-iterator \hyperlink{classBaseBus_a4cfbb26aa06c3132b77227f45f39e224}{SlavePortConstIter}
\item 
typedef \hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMasterPort}{MasterPort} $\ast$ $>$::const\_\-iterator \hyperlink{classBaseBus_a19db300fe0038b9addfe69a31ef83b3d}{MasterPortConstIter}
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classBaseBus_a85a99f51d8fef63034675b40df7eea7e}{recvRangeChange} (\hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} master\_\-port\_\-id)
\item 
\hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} \hyperlink{classBaseBus_a16872a256ea6eae168abc47d498841cb}{findPort} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr)
\item 
\hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} \hyperlink{classBaseBus_a3ec7557ff2dd8a9390bbf310b3352ce2}{checkPortCache} (\hyperlink{base_2types_8hh_af1bb03d6a4ee096394a6749f0a169232}{Addr} addr) const 
\item 
void \hyperlink{classBaseBus_a3b429b2b5fe74236299bcb556d2308e7}{updatePortCache} (short id, const \hyperlink{classAddrRange}{AddrRange} \&range)
\item 
void \hyperlink{classBaseBus_a2b259c34a080563d0e03d5a1fec2cd7a}{clearPortCache} ()
\item 
\hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classBaseBus_a36cf113d5e5e091ebddb32306c098fae}{getAddrRanges} () const 
\item 
void \hyperlink{classBaseBus_a0e69bf0fe1b87ac59689c3807a942ee7}{calcPacketTiming} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
\hyperlink{classBaseBus_aafbb881b411bf8ecd7696a6b6c9fbf5c}{BaseBus} (const BaseBusParams $\ast$p)
\item 
virtual \hyperlink{classBaseBus_a4c37180f5639002a5c75b2c1ec3c3ab4}{$\sim$BaseBus} ()
\end{DoxyCompactItemize}
\subsection*{Protected 変数}
\begin{DoxyCompactItemize}
\item 
const \hyperlink{classCycles}{Cycles} \hyperlink{classBaseBus_ab9c87c91aa592a3542152117cdb99c9b}{headerCycles}
\item 
const \hyperlink{Type_8hh_a435d1572bf3f880d55459d9805097f62}{uint32\_\-t} \hyperlink{classBaseBus_a4c2292bdfd51cf112bcde1ad3fa55ac4}{width}
\item 
\hyperlink{classAddrRangeMap}{AddrRangeMap}$<$ \hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} $>$ \hyperlink{classBaseBus_a81c901d8c13bd997dee7a12453bb29e9}{portMap}
\item 
\hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classBaseBus_ae980bda7663fbe15e79dd75a91d8448c}{busRanges}
\item 
\hyperlink{classAddrRange}{AddrRange} \hyperlink{classBaseBus_aacb632304c6d3351600303116de8870d}{defaultRange}
\item 
\hyperlink{structBaseBus_1_1PortCache}{PortCache} \hyperlink{classBaseBus_ab8fed472717f8738191c2977c81e530b}{portCache} \mbox{[}3\mbox{]}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ bool $>$ \hyperlink{classBaseBus_ace0f90dcdbf1c53391c0971acc0269ec}{gotAddrRanges}
\item 
bool \hyperlink{classBaseBus_a0c924502f5e6c095ac7dcbdaf3e177a4}{gotAllAddrRanges}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classSlavePort}{SlavePort} $\ast$ $>$ \hyperlink{classBaseBus_a9f084bf86a306772d84ad52e839cce97}{slavePorts}
\item 
\hyperlink{classstd_1_1vector}{std::vector}$<$ \hyperlink{classMasterPort}{MasterPort} $\ast$ $>$ \hyperlink{classBaseBus_a0f7b2e1619b03085b0a28bb3216cd562}{masterPorts}
\item 
\hyperlink{base_2types_8hh_acef4d7d41cb21fdc252e20c04cd7bb8e}{PortID} \hyperlink{classBaseBus_a769e7b27ddafebcc1228757f2c9ec1ba}{defaultPortID}
\item 
const bool \hyperlink{classBaseBus_a1b0312e896847e0ef8bbad93fa73dc4c}{useDefaultRange}
\item 
\hyperlink{classStats_1_1Formula}{Stats::Formula} \hyperlink{classBaseBus_ac7ddaff47c2ff8945ba85797af602673}{throughput}
\item 
\hyperlink{classStats_1_1Vector}{Stats::Vector} \hyperlink{classBaseBus_a3eb88cd36449bb56229422858d34194d}{transDist}
\item 
\hyperlink{classStats_1_1Vector2d}{Stats::Vector2d} \hyperlink{classBaseBus_a1444e1d672a8bfe518b9c3d05412985a}{pktCount}
\item 
\hyperlink{classStats_1_1Vector2d}{Stats::Vector2d} \hyperlink{classBaseBus_a1b2222f1cfbd8c191ad8d1099fd24848}{totPktSize}
\end{DoxyCompactItemize}


\subsection{説明}
The base bus contains the common elements of the non-\/coherent and coherent bus. It is an abstract class that does not have any of the functionality relating to the actual reception and transmission of packets, as this is left for the subclasses.

The \hyperlink{classBaseBus}{BaseBus} is responsible for the basic flow control (busy or not), the administration of retries, and the address decoding. 

\subsection{型定義}
\hypertarget{classBaseBus_a19db300fe0038b9addfe69a31ef83b3d}{
\index{BaseBus@{BaseBus}!MasterPortConstIter@{MasterPortConstIter}}
\index{MasterPortConstIter@{MasterPortConstIter}!BaseBus@{BaseBus}}
\subsubsection[{MasterPortConstIter}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::vector}$<${\bf MasterPort}$\ast$$>$::const\_\-iterator {\bf MasterPortConstIter}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_a19db300fe0038b9addfe69a31ef83b3d}
\hypertarget{classBaseBus_a44e87d907bdab92a2169caddd28979f9}{
\index{BaseBus@{BaseBus}!MasterPortIter@{MasterPortIter}}
\index{MasterPortIter@{MasterPortIter}!BaseBus@{BaseBus}}
\subsubsection[{MasterPortIter}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::vector}$<${\bf MasterPort}$\ast$$>$::iterator {\bf MasterPortIter}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_a44e87d907bdab92a2169caddd28979f9}
\hypertarget{classBaseBus_ad31cae2c5a87fd020ee036a5d94c7420}{
\index{BaseBus@{BaseBus}!PortMapConstIter@{PortMapConstIter}}
\index{PortMapConstIter@{PortMapConstIter}!BaseBus@{BaseBus}}
\subsubsection[{PortMapConstIter}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf AddrRangeMap}$<${\bf PortID}$>$::const\_\-iterator {\bf PortMapConstIter}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_ad31cae2c5a87fd020ee036a5d94c7420}
\hypertarget{classBaseBus_adedf751dd92daa01137db6149c004ea7}{
\index{BaseBus@{BaseBus}!PortMapIter@{PortMapIter}}
\index{PortMapIter@{PortMapIter}!BaseBus@{BaseBus}}
\subsubsection[{PortMapIter}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf AddrRangeMap}$<${\bf PortID}$>$::iterator {\bf PortMapIter}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_adedf751dd92daa01137db6149c004ea7}
\hypertarget{classBaseBus_a4cfbb26aa06c3132b77227f45f39e224}{
\index{BaseBus@{BaseBus}!SlavePortConstIter@{SlavePortConstIter}}
\index{SlavePortConstIter@{SlavePortConstIter}!BaseBus@{BaseBus}}
\subsubsection[{SlavePortConstIter}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::vector}$<${\bf SlavePort}$\ast$$>$::const\_\-iterator {\bf SlavePortConstIter}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_a4cfbb26aa06c3132b77227f45f39e224}
\hypertarget{classBaseBus_a2b00f9fc9ba7e236c9757ea764cda19d}{
\index{BaseBus@{BaseBus}!SlavePortIter@{SlavePortIter}}
\index{SlavePortIter@{SlavePortIter}!BaseBus@{BaseBus}}
\subsubsection[{SlavePortIter}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::vector}$<${\bf SlavePort}$\ast$$>$::iterator {\bf SlavePortIter}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_a2b00f9fc9ba7e236c9757ea764cda19d}
Convenience typedefs. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classBaseBus_aafbb881b411bf8ecd7696a6b6c9fbf5c}{
\index{BaseBus@{BaseBus}!BaseBus@{BaseBus}}
\index{BaseBus@{BaseBus}!BaseBus@{BaseBus}}
\subsubsection[{BaseBus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseBus} (const BaseBusParams $\ast$ {\em p})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_aafbb881b411bf8ecd7696a6b6c9fbf5c}



\begin{DoxyCode}
58     : MemObject(p),
59       headerCycles(p->header_cycles), width(p->width),
60       gotAddrRanges(p->port_default_connection_count +
61                           p->port_master_connection_count, false),
62       gotAllAddrRanges(false), defaultPortID(InvalidPortID),
63       useDefaultRange(p->use_default_range)
64 {}
\end{DoxyCode}
\hypertarget{classBaseBus_a4c37180f5639002a5c75b2c1ec3c3ab4}{
\index{BaseBus@{BaseBus}!$\sim$BaseBus@{$\sim$BaseBus}}
\index{$\sim$BaseBus@{$\sim$BaseBus}!BaseBus@{BaseBus}}
\subsubsection[{$\sim$BaseBus}]{\setlength{\rightskip}{0pt plus 5cm}$\sim${\bf BaseBus} ()\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classBaseBus_a4c37180f5639002a5c75b2c1ec3c3ab4}



\begin{DoxyCode}
67 {
68     for (MasterPortIter m = masterPorts.begin(); m != masterPorts.end();
69          ++m) {
70         delete *m;
71     }
72 
73     for (SlavePortIter s = slavePorts.begin(); s != slavePorts.end();
74          ++s) {
75         delete *s;
76     }
77 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classBaseBus_a0e69bf0fe1b87ac59689c3807a942ee7}{
\index{BaseBus@{BaseBus}!calcPacketTiming@{calcPacketTiming}}
\index{calcPacketTiming@{calcPacketTiming}!BaseBus@{BaseBus}}
\subsubsection[{calcPacketTiming}]{\setlength{\rightskip}{0pt plus 5cm}void calcPacketTiming ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_a0e69bf0fe1b87ac59689c3807a942ee7}
Calculate the timing parameters for the packet. Updates the busFirstWordDelay and busLastWordDelay fields of the packet object with the relative number of ticks required to transmit the header and the first word, and the last word, respectively. 


\begin{DoxyCode}
110 {
111     // the bus will be called at a time that is not necessarily
112     // coinciding with its own clock, so start by determining how long
113     // until the next clock edge (could be zero)
114     Tick offset = clockEdge() - curTick();
115 
116     // determine how many cycles are needed to send the data
117     unsigned dataCycles = pkt->hasData() ? divCeil(pkt->getSize(), width) : 0;
118 
119     // before setting the bus delay fields of the packet, ensure that
120     // the delay from any previous bus has been accounted for
121     if (pkt->busFirstWordDelay != 0 || pkt->busLastWordDelay != 0)
122         panic("Packet %s already has bus delay (%d, %d) that should be "
123               "accounted for.\n", pkt->cmdString(), pkt->busFirstWordDelay,
124               pkt->busLastWordDelay);
125 
126     // The first word will be delivered on the cycle after the header.
127     pkt->busFirstWordDelay = (headerCycles + 1) * clockPeriod() + offset;
128 
129     // Note that currently busLastWordDelay can be smaller than
130     // busFirstWordDelay if the packet has no data
131     pkt->busLastWordDelay = (headerCycles + dataCycles) * clockPeriod() +
132         offset;
133 }
\end{DoxyCode}
\hypertarget{classBaseBus_a3ec7557ff2dd8a9390bbf310b3352ce2}{
\index{BaseBus@{BaseBus}!checkPortCache@{checkPortCache}}
\index{checkPortCache@{checkPortCache}!BaseBus@{BaseBus}}
\subsubsection[{checkPortCache}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PortID} checkPortCache ({\bf Addr} {\em addr}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classBaseBus_a3ec7557ff2dd8a9390bbf310b3352ce2}



\begin{DoxyCode}
296                                                   {
297         if (portCache[0].valid && portCache[0].range.contains(addr)) {
298             return portCache[0].id;
299         }
300         if (portCache[1].valid && portCache[1].range.contains(addr)) {
301             return portCache[1].id;
302         }
303         if (portCache[2].valid && portCache[2].range.contains(addr)) {
304             return portCache[2].id;
305         }
306 
307         return InvalidPortID;
308     }
\end{DoxyCode}
\hypertarget{classBaseBus_a2b259c34a080563d0e03d5a1fec2cd7a}{
\index{BaseBus@{BaseBus}!clearPortCache@{clearPortCache}}
\index{clearPortCache@{clearPortCache}!BaseBus@{BaseBus}}
\subsubsection[{clearPortCache}]{\setlength{\rightskip}{0pt plus 5cm}void clearPortCache ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classBaseBus_a2b259c34a080563d0e03d5a1fec2cd7a}



\begin{DoxyCode}
326                                  {
327         portCache[2].valid = false;
328         portCache[1].valid = false;
329         portCache[0].valid = false;
330     }
\end{DoxyCode}
\hypertarget{classBaseBus_ac8c1510f7e1591e75a5c79b4b873f6b4}{
\index{BaseBus@{BaseBus}!drain@{drain}}
\index{drain@{drain}!BaseBus@{BaseBus}}
\subsubsection[{drain}]{\setlength{\rightskip}{0pt plus 5cm}virtual unsigned int drain ({\bf DrainManager} $\ast$ {\em drainManger})\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classBaseBus_ac8c1510f7e1591e75a5c79b4b873f6b4}
Provide a default implementation of the drain interface that simply returns 0 (draining completed) and sets the drain state to Drained. 

\hyperlink{classSimObject_a6bf479c521c7c3eb473822d953275b26}{SimObject}を再定義しています。

\hyperlink{classCoherentBus_aa8a18d230dba7a674ac8a0b4f35bc36a}{CoherentBus}, と \hyperlink{classNoncoherentBus_aa8a18d230dba7a674ac8a0b4f35bc36a}{NoncoherentBus}で実装されています。\hypertarget{classBaseBus_a16872a256ea6eae168abc47d498841cb}{
\index{BaseBus@{BaseBus}!findPort@{findPort}}
\index{findPort@{findPort}!BaseBus@{BaseBus}}
\subsubsection[{findPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PortID} findPort ({\bf Addr} {\em addr})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_a16872a256ea6eae168abc47d498841cb}
Find which port connected to this bus (if any) should be given a packet with this address. 
\begin{DoxyParams}{引数}
\item[{\em addr}]\hyperlink{classAddress}{Address} to find port for. \end{DoxyParams}
\begin{DoxyReturn}{戻り値}
id of port that the packet should be sent out of. 
\end{DoxyReturn}



\begin{DoxyCode}
319 {
320     // we should never see any address lookups before we've got the
321     // ranges of all connected slave modules
322     assert(gotAllAddrRanges);
323 
324     // Check the cache
325     PortID dest_id = checkPortCache(addr);
326     if (dest_id != InvalidPortID)
327         return dest_id;
328 
329     // Check the address map interval tree
330     PortMapConstIter i = portMap.find(addr);
331     if (i != portMap.end()) {
332         dest_id = i->second;
333         updatePortCache(dest_id, i->first);
334         return dest_id;
335     }
336 
337     // Check if this matches the default range
338     if (useDefaultRange) {
339         if (defaultRange.contains(addr)) {
340             DPRINTF(BusAddrRanges, "  found addr %#llx on default\n",
341                     addr);
342             return defaultPortID;
343         }
344     } else if (defaultPortID != InvalidPortID) {
345         DPRINTF(BusAddrRanges, "Unable to find destination for addr %#llx, "
346                 "will use default port\n", addr);
347         return defaultPortID;
348     }
349 
350     // we should use the range for the default port and it did not
351     // match, or the default port is not set
352     fatal("Unable to find destination for addr %#llx on bus %s\n", addr,
353           name());
354 }
\end{DoxyCode}
\hypertarget{classBaseBus_a36cf113d5e5e091ebddb32306c098fae}{
\index{BaseBus@{BaseBus}!getAddrRanges@{getAddrRanges}}
\index{getAddrRanges@{getAddrRanges}!BaseBus@{BaseBus}}
\subsubsection[{getAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRangeList} getAddrRanges () const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_a36cf113d5e5e091ebddb32306c098fae}
Return the address ranges the bus is responsible for.

\begin{DoxyReturn}{戻り値}
a list of non-\/overlapping address ranges 
\end{DoxyReturn}



\begin{DoxyCode}
522 {
523     // we should never be asked without first having sent a range
524     // change, and the latter is only done once we have all the ranges
525     // of the connected devices
526     assert(gotAllAddrRanges);
527 
528     // at the moment, this never happens, as there are no cycles in
529     // the range queries and no devices on the master side of a bus
530     // (CPU, cache, bridge etc) actually care about the ranges of the
531     // ports they are connected to
532 
533     DPRINTF(BusAddrRanges, "Received address range request\n");
534 
535     return busRanges;
536 }
\end{DoxyCode}
\hypertarget{classBaseBus_adc4e675e51defbdd1e354dac729d0703}{
\index{BaseBus@{BaseBus}!getMasterPort@{getMasterPort}}
\index{getMasterPort@{getMasterPort}!BaseBus@{BaseBus}}
\subsubsection[{getMasterPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseMasterPort} \& getMasterPort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classBaseBus_adc4e675e51defbdd1e354dac729d0703}
A function used to return the port associated with this bus object. 

\hyperlink{classMemObject_adc4e675e51defbdd1e354dac729d0703}{MemObject}を再定義しています。


\begin{DoxyCode}
86 {
87     if (if_name == "master" && idx < masterPorts.size()) {
88         // the master port index translates directly to the vector position
89         return *masterPorts[idx];
90     } else  if (if_name == "default") {
91         return *masterPorts[defaultPortID];
92     } else {
93         return MemObject::getMasterPort(if_name, idx);
94     }
95 }
\end{DoxyCode}
\hypertarget{classBaseBus_ac918a145092d7514ebc6dbd952dceafb}{
\index{BaseBus@{BaseBus}!getSlavePort@{getSlavePort}}
\index{getSlavePort@{getSlavePort}!BaseBus@{BaseBus}}
\subsubsection[{getSlavePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BaseSlavePort} \& getSlavePort (const std::string \& {\em if\_\-name}, \/  {\bf PortID} {\em idx} = {\ttfamily {\bf InvalidPortID}})\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classBaseBus_ac918a145092d7514ebc6dbd952dceafb}
Get a slave port with a given name and index. This is used at binding time and returns a reference to a protocol-\/agnostic base master port.


\begin{DoxyParams}{引数}
\item[{\em if\_\-name}]\hyperlink{classPort}{Port} name \item[{\em idx}]Index in the case of a VectorPort\end{DoxyParams}
\begin{DoxyReturn}{戻り値}
A reference to the given port 
\end{DoxyReturn}


\hyperlink{classMemObject_ac918a145092d7514ebc6dbd952dceafb}{MemObject}を再定義しています。


\begin{DoxyCode}
99 {
100     if (if_name == "slave" && idx < slavePorts.size()) {
101         // the slave port index translates directly to the vector position
102         return *slavePorts[idx];
103     } else {
104         return MemObject::getSlavePort(if_name, idx);
105     }
106 }
\end{DoxyCode}
\hypertarget{classBaseBus_a02fd73d861ef2e4aabb38c0c9ff82947}{
\index{BaseBus@{BaseBus}!init@{init}}
\index{init@{init}!BaseBus@{BaseBus}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classBaseBus_a02fd73d861ef2e4aabb38c0c9ff82947}
\hyperlink{classBaseBus_a02fd73d861ef2e4aabb38c0c9ff82947}{init()} is called after all C++ SimObjects have been created and all ports are connected. Initializations that are independent of unserialization but rely on a fully instantiated and connected \hyperlink{classSimObject}{SimObject} graph should be done here. 

\hyperlink{classSimObject_a02fd73d861ef2e4aabb38c0c9ff82947}{SimObject}を再定義しています。

\hyperlink{classCoherentBus_a02fd73d861ef2e4aabb38c0c9ff82947}{CoherentBus}で再定義されています。


\begin{DoxyCode}
81 {
82 }
\end{DoxyCode}
\hypertarget{classBaseBus_a85a99f51d8fef63034675b40df7eea7e}{
\index{BaseBus@{BaseBus}!recvRangeChange@{recvRangeChange}}
\index{recvRangeChange@{recvRangeChange}!BaseBus@{BaseBus}}
\subsubsection[{recvRangeChange}]{\setlength{\rightskip}{0pt plus 5cm}void recvRangeChange ({\bf PortID} {\em master\_\-port\_\-id})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_a85a99f51d8fef63034675b40df7eea7e}
Function called by the port when the bus is recieving a range change.


\begin{DoxyParams}{引数}
\item[{\em master\_\-port\_\-id}]id of the port that received the change\end{DoxyParams}
Function called by the port when the bus is receiving a range change. 


\begin{DoxyCode}
359 {
360     DPRINTF(BusAddrRanges, "Received range change from slave port %s\n",
361             masterPorts[master_port_id]->getSlavePort().name());
362 
363     // remember that we got a range from this master port and thus the
364     // connected slave module
365     gotAddrRanges[master_port_id] = true;
366 
367     // update the global flag
368     if (!gotAllAddrRanges) {
369         // take a logical AND of all the ports and see if we got
370         // ranges from everyone
371         gotAllAddrRanges = true;
372         std::vector<bool>::const_iterator r = gotAddrRanges.begin();
373         while (gotAllAddrRanges &&  r != gotAddrRanges.end()) {
374             gotAllAddrRanges &= *r++;
375         }
376         if (gotAllAddrRanges)
377             DPRINTF(BusAddrRanges, "Got address ranges from all slaves\n");
378     }
379 
380     // note that we could get the range from the default port at any
381     // point in time, and we cannot assume that the default range is
382     // set before the other ones are, so we do additional checks once
383     // all ranges are provided
384     if (master_port_id == defaultPortID) {
385         // only update if we are indeed checking ranges for the
386         // default port since the port might not have a valid range
387         // otherwise
388         if (useDefaultRange) {
389             AddrRangeList ranges = masterPorts[master_port_id]->getAddrRanges();
390 
391             if (ranges.size() != 1)
392                 fatal("Bus %s may only have a single default range",
393                       name());
394 
395             defaultRange = ranges.front();
396         }
397     } else {
398         // the ports are allowed to update their address ranges
399         // dynamically, so remove any existing entries
400         if (gotAddrRanges[master_port_id]) {
401             for (PortMapIter p = portMap.begin(); p != portMap.end(); ) {
402                 if (p->second == master_port_id)
403                     // erasing invalidates the iterator, so advance it
404                     // before the deletion takes place
405                     portMap.erase(p++);
406                 else
407                     p++;
408             }
409         }
410 
411         AddrRangeList ranges = masterPorts[master_port_id]->getAddrRanges();
412 
413         for (AddrRangeConstIter r = ranges.begin(); r != ranges.end(); ++r) {
414             DPRINTF(BusAddrRanges, "Adding range %s for id %d\n",
415                     r->to_string(), master_port_id);
416             if (portMap.insert(*r, master_port_id) == portMap.end()) {
417                 PortID conflict_id = portMap.find(*r)->second;
418                 fatal("%s has two ports with same range:\n\t%s\n\t%s\n",
419                       name(),
420                       masterPorts[master_port_id]->getSlavePort().name(),
421                       masterPorts[conflict_id]->getSlavePort().name());
422             }
423         }
424     }
425 
426     // if we have received ranges from all our neighbouring slave
427     // modules, go ahead and tell our connected master modules in
428     // turn, this effectively assumes a tree structure of the system
429     if (gotAllAddrRanges) {
430         DPRINTF(BusAddrRanges, "Aggregating bus ranges\n");
431         busRanges.clear();
432 
433         // start out with the default range
434         if (useDefaultRange) {
435             if (!gotAddrRanges[defaultPortID])
436                 fatal("Bus %s uses default range, but none provided",
437                       name());
438 
439             busRanges.push_back(defaultRange);
440             DPRINTF(BusAddrRanges, "-- Adding default %s\n",
441                     defaultRange.to_string());
442         }
443 
444         // merge all interleaved ranges and add any range that is not
445         // a subset of the default range
446         std::vector<AddrRange> intlv_ranges;
447         for (AddrRangeMap<PortID>::const_iterator r = portMap.begin();
448              r != portMap.end(); ++r) {
449             // if the range is interleaved then save it for now
450             if (r->first.interleaved()) {
451                 // if we already got interleaved ranges that are not
452                 // part of the same range, then first do a merge
453                 // before we add the new one
454                 if (!intlv_ranges.empty() &&
455                     !intlv_ranges.back().mergesWith(r->first)) {
456                     DPRINTF(BusAddrRanges, "-- Merging range from %d ranges\n",
457                             intlv_ranges.size());
458                     AddrRange merged_range(intlv_ranges);
459                     // next decide if we keep the merged range or not
460                     if (!(useDefaultRange &&
461                           merged_range.isSubset(defaultRange))) {
462                         busRanges.push_back(merged_range);
463                         DPRINTF(BusAddrRanges, "-- Adding merged range %s\n",
464                                 merged_range.to_string());
465                     }
466                     intlv_ranges.clear();
467                 }
468                 intlv_ranges.push_back(r->first);
469             } else {
470                 // keep the current range if not a subset of the default
471                 if (!(useDefaultRange &&
472                       r->first.isSubset(defaultRange))) {
473                     busRanges.push_back(r->first);
474                     DPRINTF(BusAddrRanges, "-- Adding range %s\n",
475                             r->first.to_string());
476                 }
477             }
478         }
479 
480         // if there is still interleaved ranges waiting to be merged,
481         // go ahead and do it
482         if (!intlv_ranges.empty()) {
483             DPRINTF(BusAddrRanges, "-- Merging range from %d ranges\n",
484                     intlv_ranges.size());
485             AddrRange merged_range(intlv_ranges);
486             if (!(useDefaultRange && merged_range.isSubset(defaultRange))) {
487                 busRanges.push_back(merged_range);
488                 DPRINTF(BusAddrRanges, "-- Adding merged range %s\n",
489                         merged_range.to_string());
490             }
491         }
492 
493         // also check that no range partially overlaps with the
494         // default range, this has to be done after all ranges are set
495         // as there are no guarantees for when the default range is
496         // update with respect to the other ones
497         if (useDefaultRange) {
498             for (AddrRangeConstIter r = busRanges.begin();
499                  r != busRanges.end(); ++r) {
500                 // see if the new range is partially
501                 // overlapping the default range
502                 if (r->intersects(defaultRange) &&
503                     !r->isSubset(defaultRange))
504                     fatal("Range %s intersects the "                    \
505                           "default range of %s but is not a "           \
506                           "subset\n", r->to_string(), name());
507             }
508         }
509 
510         // tell all our neighbouring master ports that our address
511         // ranges have changed
512         for (SlavePortConstIter s = slavePorts.begin(); s != slavePorts.end();
513              ++s)
514             (*s)->sendRangeChange();
515     }
516 
517     clearPortCache();
518 }
\end{DoxyCode}
\hypertarget{classBaseBus_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{BaseBus@{BaseBus}!regStats@{regStats}}
\index{regStats@{regStats}!BaseBus@{BaseBus}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classBaseBus_a4dc637449366fcdfc4e764cdf12d9b11}
\hyperlink{classRegister}{Register} statistics for this object. 

\hyperlink{classSimObject_a4dc637449366fcdfc4e764cdf12d9b11}{SimObject}を再定義しています。

\hyperlink{classCoherentBus_a4dc637449366fcdfc4e764cdf12d9b11}{CoherentBus}, と \hyperlink{classNoncoherentBus_a4dc637449366fcdfc4e764cdf12d9b11}{NoncoherentBus}で再定義されています。


\begin{DoxyCode}
540 {
541     using namespace Stats;
542 
543     transDist
544         .init(MemCmd::NUM_MEM_CMDS)
545         .name(name() + ".trans_dist")
546         .desc("Transaction distribution")
547         .flags(nozero);
548 
549     // get the string representation of the commands
550     for (int i = 0; i < MemCmd::NUM_MEM_CMDS; i++) {
551         MemCmd cmd(i);
552         const std::string &cstr = cmd.toString();
553         transDist.subname(i, cstr);
554     }
555 
556     pktCount
557         .init(slavePorts.size(), masterPorts.size())
558         .name(name() + ".pkt_count")
559         .desc("Packet count per connected master and slave (bytes)")
560         .flags(total | nozero | nonan);
561 
562     totPktSize
563         .init(slavePorts.size(), masterPorts.size())
564         .name(name() + ".tot_pkt_size")
565         .desc("Cumulative packet size per connected master and slave (bytes)")
566         .flags(total | nozero | nonan);
567 
568     // both the packet count and total size are two-dimensional
569     // vectors, indexed by slave port id and master port id, thus the
570     // neighbouring master and slave, they do not differentiate what
571     // came from the master and was forwarded to the slave (requests
572     // and snoop responses) and what came from the slave and was
573     // forwarded to the master (responses and snoop requests)
574     for (int i = 0; i < slavePorts.size(); i++) {
575         pktCount.subname(i, slavePorts[i]->getMasterPort().name());
576         totPktSize.subname(i, slavePorts[i]->getMasterPort().name());
577         for (int j = 0; j < masterPorts.size(); j++) {
578             pktCount.ysubname(j, masterPorts[j]->getSlavePort().name());
579             totPktSize.ysubname(j, masterPorts[j]->getSlavePort().name());
580         }
581     }
582 }
\end{DoxyCode}
\hypertarget{classBaseBus_a3b429b2b5fe74236299bcb556d2308e7}{
\index{BaseBus@{BaseBus}!updatePortCache@{updatePortCache}}
\index{updatePortCache@{updatePortCache}!BaseBus@{BaseBus}}
\subsubsection[{updatePortCache}]{\setlength{\rightskip}{0pt plus 5cm}void updatePortCache (short {\em id}, \/  const {\bf AddrRange} \& {\em range})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected\mbox{]}}}}
\label{classBaseBus_a3b429b2b5fe74236299bcb556d2308e7}



\begin{DoxyCode}
311                                                                   {
312         portCache[2].valid = portCache[1].valid;
313         portCache[2].id    = portCache[1].id;
314         portCache[2].range = portCache[1].range;
315 
316         portCache[1].valid = portCache[0].valid;
317         portCache[1].id    = portCache[0].id;
318         portCache[1].range = portCache[0].range;
319 
320         portCache[0].valid = true;
321         portCache[0].id    = id;
322         portCache[0].range = range;
323     }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classBaseBus_ae980bda7663fbe15e79dd75a91d8448c}{
\index{BaseBus@{BaseBus}!busRanges@{busRanges}}
\index{busRanges@{busRanges}!BaseBus@{BaseBus}}
\subsubsection[{busRanges}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRangeList} {\bf busRanges}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_ae980bda7663fbe15e79dd75a91d8448c}
all contigous ranges seen by this bus \hypertarget{classBaseBus_a769e7b27ddafebcc1228757f2c9ec1ba}{
\index{BaseBus@{BaseBus}!defaultPortID@{defaultPortID}}
\index{defaultPortID@{defaultPortID}!BaseBus@{BaseBus}}
\subsubsection[{defaultPortID}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PortID} {\bf defaultPortID}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_a769e7b27ddafebcc1228757f2c9ec1ba}
\hyperlink{classPort}{Port} that handles requests that don't match any of the interfaces. \hypertarget{classBaseBus_aacb632304c6d3351600303116de8870d}{
\index{BaseBus@{BaseBus}!defaultRange@{defaultRange}}
\index{defaultRange@{defaultRange}!BaseBus@{BaseBus}}
\subsubsection[{defaultRange}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRange} {\bf defaultRange}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_aacb632304c6d3351600303116de8870d}
\hypertarget{classBaseBus_ace0f90dcdbf1c53391c0971acc0269ec}{
\index{BaseBus@{BaseBus}!gotAddrRanges@{gotAddrRanges}}
\index{gotAddrRanges@{gotAddrRanges}!BaseBus@{BaseBus}}
\subsubsection[{gotAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<$bool$>$ {\bf gotAddrRanges}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_ace0f90dcdbf1c53391c0971acc0269ec}
Remember for each of the master ports of the bus if we got an address range from the connected slave. For convenience, also keep track of if we got ranges from all the slave modules or not. \hypertarget{classBaseBus_a0c924502f5e6c095ac7dcbdaf3e177a4}{
\index{BaseBus@{BaseBus}!gotAllAddrRanges@{gotAllAddrRanges}}
\index{gotAllAddrRanges@{gotAllAddrRanges}!BaseBus@{BaseBus}}
\subsubsection[{gotAllAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf gotAllAddrRanges}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_a0c924502f5e6c095ac7dcbdaf3e177a4}
\hypertarget{classBaseBus_ab9c87c91aa592a3542152117cdb99c9b}{
\index{BaseBus@{BaseBus}!headerCycles@{headerCycles}}
\index{headerCycles@{headerCycles}!BaseBus@{BaseBus}}
\subsubsection[{headerCycles}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Cycles} {\bf headerCycles}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_ab9c87c91aa592a3542152117cdb99c9b}
cycles of overhead per transaction \hypertarget{classBaseBus_a0f7b2e1619b03085b0a28bb3216cd562}{
\index{BaseBus@{BaseBus}!masterPorts@{masterPorts}}
\index{masterPorts@{masterPorts}!BaseBus@{BaseBus}}
\subsubsection[{masterPorts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf MasterPort}$\ast$$>$ {\bf masterPorts}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_a0f7b2e1619b03085b0a28bb3216cd562}
\hypertarget{classBaseBus_a1444e1d672a8bfe518b9c3d05412985a}{
\index{BaseBus@{BaseBus}!pktCount@{pktCount}}
\index{pktCount@{pktCount}!BaseBus@{BaseBus}}
\subsubsection[{pktCount}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector2d} {\bf pktCount}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_a1444e1d672a8bfe518b9c3d05412985a}
\hypertarget{classBaseBus_ab8fed472717f8738191c2977c81e530b}{
\index{BaseBus@{BaseBus}!portCache@{portCache}}
\index{portCache@{portCache}!BaseBus@{BaseBus}}
\subsubsection[{portCache}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PortCache} {\bf portCache}\mbox{[}3\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_ab8fed472717f8738191c2977c81e530b}
\hypertarget{classBaseBus_a81c901d8c13bd997dee7a12453bb29e9}{
\index{BaseBus@{BaseBus}!portMap@{portMap}}
\index{portMap@{portMap}!BaseBus@{BaseBus}}
\subsubsection[{portMap}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRangeMap}$<${\bf PortID}$>$ {\bf portMap}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_a81c901d8c13bd997dee7a12453bb29e9}
\hypertarget{classBaseBus_a9f084bf86a306772d84ad52e839cce97}{
\index{BaseBus@{BaseBus}!slavePorts@{slavePorts}}
\index{slavePorts@{slavePorts}!BaseBus@{BaseBus}}
\subsubsection[{slavePorts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::vector}$<${\bf SlavePort}$\ast$$>$ {\bf slavePorts}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_a9f084bf86a306772d84ad52e839cce97}
The master and slave ports of the bus \hypertarget{classBaseBus_ac7ddaff47c2ff8945ba85797af602673}{
\index{BaseBus@{BaseBus}!throughput@{throughput}}
\index{throughput@{throughput}!BaseBus@{BaseBus}}
\subsubsection[{throughput}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Formula} {\bf throughput}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_ac7ddaff47c2ff8945ba85797af602673}
\hyperlink{namespaceStats}{Stats} for transaction distribution and data passing through the bus. The transaction distribution is globally counting different types of commands. The packet count and total packet size are two-\/dimensional vectors that are indexed by the bus slave port and master port id (thus the neighbouring master and neighbouring slave), summing up both directions (request and response). \hypertarget{classBaseBus_a1b2222f1cfbd8c191ad8d1099fd24848}{
\index{BaseBus@{BaseBus}!totPktSize@{totPktSize}}
\index{totPktSize@{totPktSize}!BaseBus@{BaseBus}}
\subsubsection[{totPktSize}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector2d} {\bf totPktSize}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_a1b2222f1cfbd8c191ad8d1099fd24848}
\hypertarget{classBaseBus_a3eb88cd36449bb56229422858d34194d}{
\index{BaseBus@{BaseBus}!transDist@{transDist}}
\index{transDist@{transDist}!BaseBus@{BaseBus}}
\subsubsection[{transDist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Vector} {\bf transDist}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_a3eb88cd36449bb56229422858d34194d}
\hypertarget{classBaseBus_a1b0312e896847e0ef8bbad93fa73dc4c}{
\index{BaseBus@{BaseBus}!useDefaultRange@{useDefaultRange}}
\index{useDefaultRange@{useDefaultRange}!BaseBus@{BaseBus}}
\subsubsection[{useDefaultRange}]{\setlength{\rightskip}{0pt plus 5cm}const bool {\bf useDefaultRange}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_a1b0312e896847e0ef8bbad93fa73dc4c}
If true, use address range provided by default device. Any address not handled by another port and not in default device's range will cause a fatal error. If false, just send all addresses not handled by another port to default device. \hypertarget{classBaseBus_a4c2292bdfd51cf112bcde1ad3fa55ac4}{
\index{BaseBus@{BaseBus}!width@{width}}
\index{width@{width}!BaseBus@{BaseBus}}
\subsubsection[{width}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf uint32\_\-t} {\bf width}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classBaseBus_a4c2292bdfd51cf112bcde1ad3fa55ac4}
the width of the bus in bytes 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/\hyperlink{bus_8hh}{bus.hh}\item 
mem/\hyperlink{bus_8cc}{bus.cc}\end{DoxyCompactItemize}
