\hypertarget{classROB}{
\section{クラス テンプレート ROB$<$ Impl $>$}
\label{classROB}\index{ROB@{ROB}}
}


{\ttfamily \#include $<$rob.hh$>$}\subsection*{Public 型}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classROB_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \{ \hyperlink{classROB_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}{Running}, 
\hyperlink{classROB_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}{Idle}, 
\hyperlink{classROB_a67a0db04d321a74b7e7fcfd3f1a3f70ba55ceab70c6d1094de92189130c899d84}{ROBSquashing}
 \}
\item 
enum \hyperlink{classROB_a7225bc69f7e1ed5d166fbf8e41be6a43}{ROBPolicy} \{ \hyperlink{classROB_a7225bc69f7e1ed5d166fbf8e41be6a43a96535b1625776102bcc13f7dfb598dcb}{Dynamic}, 
\hyperlink{classROB_a7225bc69f7e1ed5d166fbf8e41be6a43add8dfa69b567f90d3f13d819109ab74e}{Partitioned}, 
\hyperlink{classROB_a7225bc69f7e1ed5d166fbf8e41be6a43a267544c4de8ecc66bd0fed6310af63be}{Threshold}
 \}
\item 
typedef Impl::O3CPU \hyperlink{classROB_a44622cf06940413482836cb62931ac3f}{O3CPU}
\item 
typedef Impl::DynInstPtr \hyperlink{classROB_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr}
\item 
typedef \hyperlink{classstd_1_1pair}{std::pair}$<$ \hyperlink{classROB_a36d25e03e43fa3bb4c5482cbefe5e0fb}{RegIndex}, \hyperlink{o3_2comm_8hh_a5ec29599c4bc29a3054c451674969e7b}{PhysRegIndex} $>$ \hyperlink{classROB_a2aae34ed2f277a882bed03a84e40fcab}{UnmapInfo}
\item 
typedef \hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classROB_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$::iterator \hyperlink{classROB_a59263e64bd60700e053c0be08e7c93ab}{InstIt}
\end{DoxyCompactItemize}
\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classROB_a0fac6595ed6513e7b81d9098f6f345fb}{ROB} (\hyperlink{classROB_a44622cf06940413482836cb62931ac3f}{O3CPU} $\ast$\_\-cpu, DerivO3CPUParams $\ast$params)
\item 
std::string \hyperlink{classROB_a37627d5d5bba7f4a8690c71c2ab3cb07}{name} () const 
\item 
void \hyperlink{classROB_aab96bdacf8bd420402cbb543f994e054}{setActiveThreads} (\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$at\_\-ptr)
\item 
void \hyperlink{classROB_a0240eb42fa57fe5d3788093f62b77347}{drainSanityCheck} () const 
\item 
void \hyperlink{classROB_a8674059ce345e23aac5086b2c3e24a43}{takeOverFrom} ()
\item 
void \hyperlink{classROB_aa5f3ce0db8d338ad004f89955f495fef}{insertInst} (\hyperlink{classROB_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \&inst)
\item 
\hyperlink{classROB_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classROB_a5c156e82f6912abd14c61c6cc9b8000a}{readHeadInst} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
\hyperlink{classROB_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classROB_a6b0d3a4acdaebcd1eb294cb58a26be40}{findInst} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid, \hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} squash\_\-inst)
\item 
\hyperlink{classROB_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classROB_a6da43edd5511d34476626974724a32bf}{readTailInst} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classROB_aa14c02115ece83633552be2368b60e67}{retireHead} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classROB_aafcd2d518fa9f1e1b1e4c166804ea0ce}{isHeadReady} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classROB_a47c266650f91e4f5670ea25d8e7b787b}{canCommit} ()
\item 
void \hyperlink{classROB_aaf9a05771a835f9f8d634cef36e24d40}{resetEntries} ()
\item 
int \hyperlink{classROB_a5d2b0e4e7d98ea4ebd9fb98ac0d91e2f}{entryAmount} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} num\_\-threads)
\item 
unsigned \hyperlink{classROB_a028971a565aca048c67ea1c36a6a9d51}{numFreeEntries} ()
\item 
unsigned \hyperlink{classROB_acc878f608deead5b5319a6a3f98b50c8}{numFreeEntries} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
unsigned \hyperlink{classROB_a9844bb4676b40d12c10f411ffdd4b148}{getMaxEntries} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
unsigned \hyperlink{classROB_a6461a6d64f301a64dbf720f1290114eb}{getThreadEntries} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classROB_a3e70330939fdfc4dbc2f60c1a660584d}{isFull} ()
\item 
bool \hyperlink{classROB_a30fac732df9b3fda011c7329a112cb31}{isFull} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
bool \hyperlink{classROB_a479432127ee77145cc19d6a2d1590821}{isEmpty} () const 
\item 
bool \hyperlink{classROB_a1a6e3ff5a958bb55857fcf09f6d26ce7}{isEmpty} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid) const 
\item 
void \hyperlink{classROB_a06cf52c4f09162bea03ec848f247151a}{doSquash} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classROB_aee9dc23de90acd20200641407a3bd1da}{squash} (\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} squash\_\-num, \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classROB_a5284fa5ccee18ce965fb4863722e96a9}{updateHead} ()
\item 
void \hyperlink{classROB_acc69b1041902d0557b7be476f5c547aa}{updateTail} ()
\item 
bool \hyperlink{classROB_acd4497e40e00ada9d4d15336dcb35be8}{isDoneSquashing} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid) const 
\item 
bool \hyperlink{classROB_a361dee23017319068ba1585a4c393868}{isDoneSquashing} ()
\item 
int \hyperlink{classROB_ab654970f03abd90f0c397bba8e218bc9}{countInsts} ()
\item 
int \hyperlink{classROB_ac7828ae51d0a8c259745a7f45410a368}{countInsts} (\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} tid)
\item 
void \hyperlink{classROB_a4dc637449366fcdfc4e764cdf12d9b11}{regStats} ()
\end{DoxyCompactItemize}
\subsection*{Public 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classROB_a59263e64bd60700e053c0be08e7c93ab}{InstIt} \hyperlink{classROB_a20dbd4d473546ec8b674542f765626e5}{tail}
\item 
\hyperlink{classROB_a59263e64bd60700e053c0be08e7c93ab}{InstIt} \hyperlink{classROB_ae6c12b73bfe6227eded2623bf432805b}{head}
\item 
int \hyperlink{classROB_a191acd130c66ac40c8bfa8f59febe417}{numInstsInROB}
\item 
\hyperlink{classROB_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} \hyperlink{classROB_a3f3e1afdb445d65050c39300f93716d2}{dummyInst}
\end{DoxyCompactItemize}
\subsection*{Protected 型}
\begin{DoxyCompactItemize}
\item 
typedef TheISA::RegIndex \hyperlink{classROB_a36d25e03e43fa3bb4c5482cbefe5e0fb}{RegIndex}
\end{DoxyCompactItemize}
\subsection*{Private メソッド}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classROB_a755ee993c2d4e9d422c37990b15afa37}{resetState} ()
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classROB_a67a0db04d321a74b7e7fcfd3f1a3f70b}{Status} \hyperlink{classROB_a23d5e98a57c975ddb5106a14af875f9b}{robStatus} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classROB_a7225bc69f7e1ed5d166fbf8e41be6a43}{ROBPolicy} \hyperlink{classROB_a802d14d10f8445b65f5c9d50ea0c6794}{robPolicy}
\item 
\hyperlink{classROB_a44622cf06940413482836cb62931ac3f}{O3CPU} $\ast$ \hyperlink{classROB_a1379cf882a12ac6fc9eba5da7c84b18b}{cpu}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} $>$ $\ast$ \hyperlink{classROB_af6eaea53db532812052f71bf0380dab5}{activeThreads}
\item 
unsigned \hyperlink{classROB_a325de474a9f6652329339d9fc2ea09c0}{numEntries}
\item 
unsigned \hyperlink{classROB_a22332ec3217f4cc3ca98a489d0b6b6ab}{threadEntries} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
unsigned \hyperlink{classROB_a51e5f9f0cb40d61e95b1518f1be90b73}{maxEntries} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{classstd_1_1list}{std::list}$<$ \hyperlink{classROB_a028ce10889c5f6450239d9e9a7347976}{DynInstPtr} $>$ \hyperlink{classROB_a7f2828a4f877a4a4d4b85a6788536b82}{instList} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
unsigned \hyperlink{classROB_a2bfc819c212cc4fda248fe12fbba68b8}{squashWidth}
\item 
\hyperlink{classROB_a59263e64bd60700e053c0be08e7c93ab}{InstIt} \hyperlink{classROB_a51c7e06ec4f16d99b424b2e8ba8ff6fb}{squashIt} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{inst__seq_8hh_a258d93d98edaedee089435c19ea2ea2e}{InstSeqNum} \hyperlink{classROB_a97d5a7e4630ad1d017909f7504b9ec32}{squashedSeqNum} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
bool \hyperlink{classROB_aa5d029365d2db19432b68bc048d8773d}{doneSquashing} \mbox{[}Impl::MaxThreads\mbox{]}
\item 
\hyperlink{base_2types_8hh_ab39b1a4f9dad884694c7a74ed69e6a6b}{ThreadID} \hyperlink{classROB_a88377f855dbf5adeeecb06b5bb821d35}{numThreads}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classROB_a982979b3e3e933cd62fa40789af9153d}{robReads}
\item 
\hyperlink{classStats_1_1Scalar}{Stats::Scalar} \hyperlink{classROB_a4c459f15b21d3f34da46fe0ca2280cf6}{robWrites}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$class Impl$>$ class ROB$<$ Impl $>$}

\hyperlink{classROB}{ROB} class. The \hyperlink{classROB}{ROB} is largely what drives squashing. 

\subsection{型定義}
\hypertarget{classROB_a028ce10889c5f6450239d9e9a7347976}{
\index{ROB@{ROB}!DynInstPtr@{DynInstPtr}}
\index{DynInstPtr@{DynInstPtr}!ROB@{ROB}}
\subsubsection[{DynInstPtr}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::DynInstPtr {\bf DynInstPtr}}}
\label{classROB_a028ce10889c5f6450239d9e9a7347976}
\hypertarget{classROB_a59263e64bd60700e053c0be08e7c93ab}{
\index{ROB@{ROB}!InstIt@{InstIt}}
\index{InstIt@{InstIt}!ROB@{ROB}}
\subsubsection[{InstIt}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::list}$<${\bf DynInstPtr}$>$::iterator {\bf InstIt}}}
\label{classROB_a59263e64bd60700e053c0be08e7c93ab}
\hypertarget{classROB_a44622cf06940413482836cb62931ac3f}{
\index{ROB@{ROB}!O3CPU@{O3CPU}}
\index{O3CPU@{O3CPU}!ROB@{ROB}}
\subsubsection[{O3CPU}]{\setlength{\rightskip}{0pt plus 5cm}typedef Impl::O3CPU {\bf O3CPU}}}
\label{classROB_a44622cf06940413482836cb62931ac3f}
\hypertarget{classROB_a36d25e03e43fa3bb4c5482cbefe5e0fb}{
\index{ROB@{ROB}!RegIndex@{RegIndex}}
\index{RegIndex@{RegIndex}!ROB@{ROB}}
\subsubsection[{RegIndex}]{\setlength{\rightskip}{0pt plus 5cm}typedef TheISA::RegIndex {\bf RegIndex}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classROB_a36d25e03e43fa3bb4c5482cbefe5e0fb}
\hypertarget{classROB_a2aae34ed2f277a882bed03a84e40fcab}{
\index{ROB@{ROB}!UnmapInfo@{UnmapInfo}}
\index{UnmapInfo@{UnmapInfo}!ROB@{ROB}}
\subsubsection[{UnmapInfo}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf std::pair}$<${\bf RegIndex}, {\bf PhysRegIndex}$>$ {\bf UnmapInfo}}}
\label{classROB_a2aae34ed2f277a882bed03a84e40fcab}


\subsection{列挙型}
\hypertarget{classROB_a7225bc69f7e1ed5d166fbf8e41be6a43}{
\index{ROB@{ROB}!ROBPolicy@{ROBPolicy}}
\index{ROBPolicy@{ROBPolicy}!ROB@{ROB}}
\subsubsection[{ROBPolicy}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ROBPolicy}}}
\label{classROB_a7225bc69f7e1ed5d166fbf8e41be6a43}
SMT \hyperlink{classROB}{ROB} Sharing Policy \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Dynamic@{Dynamic}!ROB@{ROB}}\index{ROB@{ROB}!Dynamic@{Dynamic}}\item[{\em 
\hypertarget{classROB_a7225bc69f7e1ed5d166fbf8e41be6a43a96535b1625776102bcc13f7dfb598dcb}{
Dynamic}
\label{classROB_a7225bc69f7e1ed5d166fbf8e41be6a43a96535b1625776102bcc13f7dfb598dcb}
}]\index{Partitioned@{Partitioned}!ROB@{ROB}}\index{ROB@{ROB}!Partitioned@{Partitioned}}\item[{\em 
\hypertarget{classROB_a7225bc69f7e1ed5d166fbf8e41be6a43add8dfa69b567f90d3f13d819109ab74e}{
Partitioned}
\label{classROB_a7225bc69f7e1ed5d166fbf8e41be6a43add8dfa69b567f90d3f13d819109ab74e}
}]\index{Threshold@{Threshold}!ROB@{ROB}}\index{ROB@{ROB}!Threshold@{Threshold}}\item[{\em 
\hypertarget{classROB_a7225bc69f7e1ed5d166fbf8e41be6a43a267544c4de8ecc66bd0fed6310af63be}{
Threshold}
\label{classROB_a7225bc69f7e1ed5d166fbf8e41be6a43a267544c4de8ecc66bd0fed6310af63be}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
81                   {
82         Dynamic,
83         Partitioned,
84         Threshold
85     };
\end{DoxyCode}
\hypertarget{classROB_a67a0db04d321a74b7e7fcfd3f1a3f70b}{
\index{ROB@{ROB}!Status@{Status}}
\index{Status@{Status}!ROB@{ROB}}
\subsubsection[{Status}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Status}}}
\label{classROB_a67a0db04d321a74b7e7fcfd3f1a3f70b}
Possible \hyperlink{classROB}{ROB} statuses. \begin{Desc}
\item[列挙型の値: ]\par
\begin{description}
\index{Running@{Running}!ROB@{ROB}}\index{ROB@{ROB}!Running@{Running}}\item[{\em 
\hypertarget{classROB_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}{
Running}
\label{classROB_a67a0db04d321a74b7e7fcfd3f1a3f70ba2f5f2c4a8c4f4f0519d503dcdfbf55cb}
}]\index{Idle@{Idle}!ROB@{ROB}}\index{ROB@{ROB}!Idle@{Idle}}\item[{\em 
\hypertarget{classROB_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}{
Idle}
\label{classROB_a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19}
}]\index{ROBSquashing@{ROBSquashing}!ROB@{ROB}}\index{ROB@{ROB}!ROBSquashing@{ROBSquashing}}\item[{\em 
\hypertarget{classROB_a67a0db04d321a74b7e7fcfd3f1a3f70ba55ceab70c6d1094de92189130c899d84}{
ROBSquashing}
\label{classROB_a67a0db04d321a74b7e7fcfd3f1a3f70ba55ceab70c6d1094de92189130c899d84}
}]\end{description}
\end{Desc}




\begin{DoxyCode}
74                 {
75         Running,
76         Idle,
77         ROBSquashing
78     };
\end{DoxyCode}


\subsection{コンストラクタとデストラクタ}
\hypertarget{classROB_a0fac6595ed6513e7b81d9098f6f345fb}{
\index{ROB@{ROB}!ROB@{ROB}}
\index{ROB@{ROB}!ROB@{ROB}}
\subsubsection[{ROB}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ROB} ({\bf O3CPU} $\ast$ {\em \_\-cpu}, \/  DerivO3CPUParams $\ast$ {\em params})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a0fac6595ed6513e7b81d9098f6f345fb}
\hyperlink{classROB}{ROB} constructor. 
\begin{DoxyParams}{引数}
\item[{\em \_\-cpu}]The cpu object pointer. \item[{\em params}]The cpu params including several ROB-\/specific parameters. \end{DoxyParams}



\begin{DoxyCode}
58     : cpu(_cpu),
59       numEntries(params->numROBEntries),
60       squashWidth(params->squashWidth),
61       numInstsInROB(0),
62       numThreads(params->numThreads)
63 {
64     std::string policy = params->smtROBPolicy;
65 
66     //Convert string to lowercase
67     std::transform(policy.begin(), policy.end(), policy.begin(),
68                    (int(*)(int)) tolower);
69 
70     //Figure out rob policy
71     if (policy == "dynamic") {
72         robPolicy = Dynamic;
73 
74         //Set Max Entries to Total ROB Capacity
75         for (ThreadID tid = 0; tid < numThreads; tid++) {
76             maxEntries[tid] = numEntries;
77         }
78 
79     } else if (policy == "partitioned") {
80         robPolicy = Partitioned;
81         DPRINTF(Fetch, "ROB sharing policy set to Partitioned\n");
82 
83         //@todo:make work if part_amt doesnt divide evenly.
84         int part_amt = numEntries / numThreads;
85 
86         //Divide ROB up evenly
87         for (ThreadID tid = 0; tid < numThreads; tid++) {
88             maxEntries[tid] = part_amt;
89         }
90 
91     } else if (policy == "threshold") {
92         robPolicy = Threshold;
93         DPRINTF(Fetch, "ROB sharing policy set to Threshold\n");
94 
95         int threshold =  params->smtROBThreshold;;
96 
97         //Divide up by threshold amount
98         for (ThreadID tid = 0; tid < numThreads; tid++) {
99             maxEntries[tid] = threshold;
100         }
101     } else {
102         assert(0 && "Invalid ROB Sharing Policy.Options Are:{Dynamic,"
103                     "Partitioned, Threshold}");
104     }
105 
106     resetState();
107 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classROB_a47c266650f91e4f5670ea25d8e7b787b}{
\index{ROB@{ROB}!canCommit@{canCommit}}
\index{canCommit@{canCommit}!ROB@{ROB}}
\subsubsection[{canCommit}]{\setlength{\rightskip}{0pt plus 5cm}bool canCommit ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a47c266650f91e4f5670ea25d8e7b787b}
Is there any commitable head instruction across all threads ready. 


\begin{DoxyCode}
298 {
299     //@todo: set ActiveThreads through ROB or CPU
300     list<ThreadID>::iterator threads = activeThreads->begin();
301     list<ThreadID>::iterator end = activeThreads->end();
302 
303     while (threads != end) {
304         ThreadID tid = *threads++;
305 
306         if (isHeadReady(tid)) {
307             return true;
308         }
309     }
310 
311     return false;
312 }
\end{DoxyCode}
\hypertarget{classROB_ac7828ae51d0a8c259745a7f45410a368}{
\index{ROB@{ROB}!countInsts@{countInsts}}
\index{countInsts@{countInsts}!ROB@{ROB}}
\subsubsection[{countInsts}]{\setlength{\rightskip}{0pt plus 5cm}int countInsts ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_ac7828ae51d0a8c259745a7f45410a368}
This is more of a debugging function than anything. Use threadEntries to get the instructions in the \hyperlink{classROB}{ROB} unless you are double checking that variable. 


\begin{DoxyCode}
206 {
207     return instList[tid].size();
208 }
\end{DoxyCode}
\hypertarget{classROB_ab654970f03abd90f0c397bba8e218bc9}{
\index{ROB@{ROB}!countInsts@{countInsts}}
\index{countInsts@{countInsts}!ROB@{ROB}}
\subsubsection[{countInsts}]{\setlength{\rightskip}{0pt plus 5cm}int countInsts ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_ab654970f03abd90f0c397bba8e218bc9}
This is more of a debugging function than anything. Use numInstsInROB to get the instructions in the \hyperlink{classROB}{ROB} unless you are double checking that variable. 


\begin{DoxyCode}
194 {
195     int total = 0;
196 
197     for (ThreadID tid = 0; tid < numThreads; tid++)
198         total += countInsts(tid);
199 
200     return total;
201 }
\end{DoxyCode}
\hypertarget{classROB_a06cf52c4f09162bea03ec848f247151a}{
\index{ROB@{ROB}!doSquash@{doSquash}}
\index{doSquash@{doSquash}!ROB@{ROB}}
\subsubsection[{doSquash}]{\setlength{\rightskip}{0pt plus 5cm}void doSquash ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a06cf52c4f09162bea03ec848f247151a}
Executes the squash, marking squashed instructions. 


\begin{DoxyCode}
331 {
332     robWrites++;
333     DPRINTF(ROB, "[tid:%u]: Squashing instructions until [sn:%i].\n",
334             tid, squashedSeqNum[tid]);
335 
336     assert(squashIt[tid] != instList[tid].end());
337 
338     if ((*squashIt[tid])->seqNum < squashedSeqNum[tid]) {
339         DPRINTF(ROB, "[tid:%u]: Done squashing instructions.\n",
340                 tid);
341 
342         squashIt[tid] = instList[tid].end();
343 
344         doneSquashing[tid] = true;
345         return;
346     }
347 
348     bool robTailUpdate = false;
349 
350     for (int numSquashed = 0;
351          numSquashed < squashWidth &&
352          squashIt[tid] != instList[tid].end() &&
353          (*squashIt[tid])->seqNum > squashedSeqNum[tid];
354          ++numSquashed)
355     {
356         DPRINTF(ROB, "[tid:%u]: Squashing instruction PC %s, seq num %i.\n",
357                 (*squashIt[tid])->threadNumber,
358                 (*squashIt[tid])->pcState(),
359                 (*squashIt[tid])->seqNum);
360 
361         // Mark the instruction as squashed, and ready to commit so that
362         // it can drain out of the pipeline.
363         (*squashIt[tid])->setSquashed();
364 
365         (*squashIt[tid])->setCanCommit();
366 
367 
368         if (squashIt[tid] == instList[tid].begin()) {
369             DPRINTF(ROB, "Reached head of instruction list while "
370                     "squashing.\n");
371 
372             squashIt[tid] = instList[tid].end();
373 
374             doneSquashing[tid] = true;
375 
376             return;
377         }
378 
379         InstIt tail_thread = instList[tid].end();
380         tail_thread--;
381 
382         if ((*squashIt[tid]) == (*tail_thread))
383             robTailUpdate = true;
384 
385         squashIt[tid]--;
386     }
387 
388 
389     // Check if ROB is done squashing.
390     if ((*squashIt[tid])->seqNum <= squashedSeqNum[tid]) {
391         DPRINTF(ROB, "[tid:%u]: Done squashing instructions.\n",
392                 tid);
393 
394         squashIt[tid] = instList[tid].end();
395 
396         doneSquashing[tid] = true;
397     }
398 
399     if (robTailUpdate) {
400         updateTail();
401     }
402 }
\end{DoxyCode}
\hypertarget{classROB_a0240eb42fa57fe5d3788093f62b77347}{
\index{ROB@{ROB}!drainSanityCheck@{drainSanityCheck}}
\index{drainSanityCheck@{drainSanityCheck}!ROB@{ROB}}
\subsubsection[{drainSanityCheck}]{\setlength{\rightskip}{0pt plus 5cm}void drainSanityCheck () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a0240eb42fa57fe5d3788093f62b77347}
Perform sanity checks after a drain. 


\begin{DoxyCode}
145 {
146     for (ThreadID tid = 0; tid  < numThreads; tid++)
147         assert(instList[tid].empty());
148     assert(isEmpty());
149 }
\end{DoxyCode}
\hypertarget{classROB_a5d2b0e4e7d98ea4ebd9fb98ac0d91e2f}{
\index{ROB@{ROB}!entryAmount@{entryAmount}}
\index{entryAmount@{entryAmount}!ROB@{ROB}}
\subsubsection[{entryAmount}]{\setlength{\rightskip}{0pt plus 5cm}int entryAmount ({\bf ThreadID} {\em num\_\-threads})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a5d2b0e4e7d98ea4ebd9fb98ac0d91e2f}
Number of entries needed For 'num\_\-threads' amount of threads. 


\begin{DoxyCode}
183 {
184     if (robPolicy == Partitioned) {
185         return numEntries / num_threads;
186     } else {
187         return 0;
188     }
189 }
\end{DoxyCode}
\hypertarget{classROB_a6b0d3a4acdaebcd1eb294cb58a26be40}{
\index{ROB@{ROB}!findInst@{findInst}}
\index{findInst@{findInst}!ROB@{ROB}}
\subsubsection[{findInst}]{\setlength{\rightskip}{0pt plus 5cm}Impl::DynInstPtr findInst ({\bf ThreadID} {\em tid}, \/  {\bf InstSeqNum} {\em squash\_\-inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a6b0d3a4acdaebcd1eb294cb58a26be40}
Returns a pointer to the instruction with the given sequence if it is in the \hyperlink{classROB}{ROB}. 


\begin{DoxyCode}
557 {
558     for (InstIt it = instList[tid].begin(); it != instList[tid].end(); it++) {
559         if ((*it)->seqNum == squash_inst) {
560             return *it;
561         }
562     }
563     return NULL;
564 }
\end{DoxyCode}
\hypertarget{classROB_a9844bb4676b40d12c10f411ffdd4b148}{
\index{ROB@{ROB}!getMaxEntries@{getMaxEntries}}
\index{getMaxEntries@{getMaxEntries}!ROB@{ROB}}
\subsubsection[{getMaxEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned getMaxEntries ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a9844bb4676b40d12c10f411ffdd4b148}
Returns the maximum number of entries for a specific thread. 


\begin{DoxyCode}
181     { return maxEntries[tid]; }
\end{DoxyCode}
\hypertarget{classROB_a6461a6d64f301a64dbf720f1290114eb}{
\index{ROB@{ROB}!getThreadEntries@{getThreadEntries}}
\index{getThreadEntries@{getThreadEntries}!ROB@{ROB}}
\subsubsection[{getThreadEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned getThreadEntries ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a6461a6d64f301a64dbf720f1290114eb}
Returns the number of entries being used by a specific thread. 


\begin{DoxyCode}
185     { return threadEntries[tid]; }
\end{DoxyCode}
\hypertarget{classROB_aa5f3ce0db8d338ad004f89955f495fef}{
\index{ROB@{ROB}!insertInst@{insertInst}}
\index{insertInst@{insertInst}!ROB@{ROB}}
\subsubsection[{insertInst}]{\setlength{\rightskip}{0pt plus 5cm}void insertInst ({\bf DynInstPtr} \& {\em inst})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_aa5f3ce0db8d338ad004f89955f495fef}
Function to insert an instruction into the \hyperlink{classROB}{ROB}. Note that whatever calls this function must ensure that there is enough space within the \hyperlink{classROB}{ROB} for the new instruction. 
\begin{DoxyParams}{引数}
\item[{\em inst}]The instruction being inserted into the \hyperlink{classROB}{ROB}. \end{DoxyParams}



\begin{DoxyCode}
213 {
214     assert(inst);
215 
216     robWrites++;
217 
218     DPRINTF(ROB, "Adding inst PC %s to the ROB.\n", inst->pcState());
219 
220     assert(numInstsInROB != numEntries);
221 
222     ThreadID tid = inst->threadNumber;
223 
224     instList[tid].push_back(inst);
225 
226     //Set Up head iterator if this is the 1st instruction in the ROB
227     if (numInstsInROB == 0) {
228         head = instList[tid].begin();
229         assert((*head) == inst);
230     }
231 
232     //Must Decrement for iterator to actually be valid  since __.end()
233     //actually points to 1 after the last inst
234     tail = instList[tid].end();
235     tail--;
236 
237     inst->setInROB();
238 
239     ++numInstsInROB;
240     ++threadEntries[tid];
241 
242     assert((*tail) == inst);
243 
244     DPRINTF(ROB, "[tid:%i] Now has %d instructions.\n", tid, threadEntries[tid]);
      
245 }
\end{DoxyCode}
\hypertarget{classROB_a361dee23017319068ba1585a4c393868}{
\index{ROB@{ROB}!isDoneSquashing@{isDoneSquashing}}
\index{isDoneSquashing@{isDoneSquashing}!ROB@{ROB}}
\subsubsection[{isDoneSquashing}]{\setlength{\rightskip}{0pt plus 5cm}bool isDoneSquashing ()}}
\label{classROB_a361dee23017319068ba1585a4c393868}
Checks if the \hyperlink{classROB}{ROB} is still in the process of squashing instructions for any thread. \hypertarget{classROB_acd4497e40e00ada9d4d15336dcb35be8}{
\index{ROB@{ROB}!isDoneSquashing@{isDoneSquashing}}
\index{isDoneSquashing@{isDoneSquashing}!ROB@{ROB}}
\subsubsection[{isDoneSquashing}]{\setlength{\rightskip}{0pt plus 5cm}bool isDoneSquashing ({\bf ThreadID} {\em tid}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_acd4497e40e00ada9d4d15336dcb35be8}
Reads the PC of the oldest head instruction. Reads the PC of the head instruction of a specific thread. Reads the next PC of the oldest head instruction. Reads the next PC of the head instruction of a specific thread. Reads the sequence number of the oldest head instruction. Reads the sequence number of the head instruction of a specific thread. Reads the PC of the youngest tail instruction. Reads the PC of the tail instruction of a specific thread. Reads the sequence number of the youngest tail instruction. Reads the sequence number of tail instruction of a specific thread. Checks if the \hyperlink{classROB}{ROB} is still in the process of squashing instructions. 
\begin{DoxyRetVals}{戻り値}
\item[{\em Whether}]or not the \hyperlink{classROB}{ROB} is done squashing. \end{DoxyRetVals}



\begin{DoxyCode}
252     { return doneSquashing[tid]; }
\end{DoxyCode}
\hypertarget{classROB_a1a6e3ff5a958bb55857fcf09f6d26ce7}{
\index{ROB@{ROB}!isEmpty@{isEmpty}}
\index{isEmpty@{isEmpty}!ROB@{ROB}}
\subsubsection[{isEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool isEmpty ({\bf ThreadID} {\em tid}) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a1a6e3ff5a958bb55857fcf09f6d26ce7}
Returns if a specific thread's partition is empty. 


\begin{DoxyCode}
201     { return threadEntries[tid] == 0; }
\end{DoxyCode}
\hypertarget{classROB_a479432127ee77145cc19d6a2d1590821}{
\index{ROB@{ROB}!isEmpty@{isEmpty}}
\index{isEmpty@{isEmpty}!ROB@{ROB}}
\subsubsection[{isEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool isEmpty () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a479432127ee77145cc19d6a2d1590821}
Returns if the \hyperlink{classROB}{ROB} is empty. 


\begin{DoxyCode}
197     { return numInstsInROB == 0; }
\end{DoxyCode}
\hypertarget{classROB_a30fac732df9b3fda011c7329a112cb31}{
\index{ROB@{ROB}!isFull@{isFull}}
\index{isFull@{isFull}!ROB@{ROB}}
\subsubsection[{isFull}]{\setlength{\rightskip}{0pt plus 5cm}bool isFull ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a30fac732df9b3fda011c7329a112cb31}
Returns if a specific thread's partition is full. 


\begin{DoxyCode}
193     { return threadEntries[tid] == numEntries; }
\end{DoxyCode}
\hypertarget{classROB_a3e70330939fdfc4dbc2f60c1a660584d}{
\index{ROB@{ROB}!isFull@{isFull}}
\index{isFull@{isFull}!ROB@{ROB}}
\subsubsection[{isFull}]{\setlength{\rightskip}{0pt plus 5cm}bool isFull ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a3e70330939fdfc4dbc2f60c1a660584d}
Returns if the \hyperlink{classROB}{ROB} is full. 


\begin{DoxyCode}
189     { return numInstsInROB == numEntries; }
\end{DoxyCode}
\hypertarget{classROB_aafcd2d518fa9f1e1b1e4c166804ea0ce}{
\index{ROB@{ROB}!isHeadReady@{isHeadReady}}
\index{isHeadReady@{isHeadReady}!ROB@{ROB}}
\subsubsection[{isHeadReady}]{\setlength{\rightskip}{0pt plus 5cm}bool isHeadReady ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_aafcd2d518fa9f1e1b1e4c166804ea0ce}
Is the oldest instruction across all threads ready. Is the oldest instruction across a particular thread ready. 


\begin{DoxyCode}
286 {
287     robReads++;
288     if (threadEntries[tid] != 0) {
289         return instList[tid].front()->readyToCommit();
290     }
291 
292     return false;
293 }
\end{DoxyCode}
\hypertarget{classROB_a37627d5d5bba7f4a8690c71c2ab3cb07}{
\index{ROB@{ROB}!name@{name}}
\index{name@{name}!ROB@{ROB}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}std::string name () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a37627d5d5bba7f4a8690c71c2ab3cb07}



\begin{DoxyCode}
130 {
131     return cpu->name() + ".rob";
132 }
\end{DoxyCode}
\hypertarget{classROB_acc878f608deead5b5319a6a3f98b50c8}{
\index{ROB@{ROB}!numFreeEntries@{numFreeEntries}}
\index{numFreeEntries@{numFreeEntries}!ROB@{ROB}}
\subsubsection[{numFreeEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned numFreeEntries ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_acc878f608deead5b5319a6a3f98b50c8}
Returns the number of free entries in a specific \hyperlink{classROB}{ROB} paritition. 


\begin{DoxyCode}
324 {
325     return maxEntries[tid] - threadEntries[tid];
326 }
\end{DoxyCode}
\hypertarget{classROB_a028971a565aca048c67ea1c36a6a9d51}{
\index{ROB@{ROB}!numFreeEntries@{numFreeEntries}}
\index{numFreeEntries@{numFreeEntries}!ROB@{ROB}}
\subsubsection[{numFreeEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned numFreeEntries ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a028971a565aca048c67ea1c36a6a9d51}
Returns the number of total free entries in the \hyperlink{classROB}{ROB}. 


\begin{DoxyCode}
317 {
318     return numEntries - numInstsInROB;
319 }
\end{DoxyCode}
\hypertarget{classROB_a5c156e82f6912abd14c61c6cc9b8000a}{
\index{ROB@{ROB}!readHeadInst@{readHeadInst}}
\index{readHeadInst@{readHeadInst}!ROB@{ROB}}
\subsubsection[{readHeadInst}]{\setlength{\rightskip}{0pt plus 5cm}Impl::DynInstPtr readHeadInst ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a5c156e82f6912abd14c61c6cc9b8000a}
Returns pointer to the head instruction within the \hyperlink{classROB}{ROB}. There is no guarantee as to the return value if the \hyperlink{classROB}{ROB} is empty. 
\begin{DoxyRetVals}{戻り値}
\item[{\em Pointer}]to the DynInst that is at the head of the \hyperlink{classROB}{ROB}. Returns a pointer to the head instruction of a specific thread within the \hyperlink{classROB}{ROB}. \end{DoxyRetVals}
\begin{DoxyReturn}{戻り値}
Pointer to the DynInst that is at the head of the \hyperlink{classROB}{ROB}. 
\end{DoxyReturn}



\begin{DoxyCode}
518 {
519     if (threadEntries[tid] != 0) {
520         InstIt head_thread = instList[tid].begin();
521 
522         assert((*head_thread)->isInROB());
523 
524         return *head_thread;
525     } else {
526         return dummyInst;
527     }
528 }
\end{DoxyCode}
\hypertarget{classROB_a6da43edd5511d34476626974724a32bf}{
\index{ROB@{ROB}!readTailInst@{readTailInst}}
\index{readTailInst@{readTailInst}!ROB@{ROB}}
\subsubsection[{readTailInst}]{\setlength{\rightskip}{0pt plus 5cm}Impl::DynInstPtr readTailInst ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a6da43edd5511d34476626974724a32bf}
Returns pointer to the tail instruction within the \hyperlink{classROB}{ROB}. There is no guarantee as to the return value if the \hyperlink{classROB}{ROB} is empty. 
\begin{DoxyRetVals}{戻り値}
\item[{\em Pointer}]to the DynInst that is at the tail of the \hyperlink{classROB}{ROB}. Returns a pointer to the tail instruction of a specific thread within the \hyperlink{classROB}{ROB}. \end{DoxyRetVals}
\begin{DoxyReturn}{戻り値}
Pointer to the DynInst that is at the tail of the \hyperlink{classROB}{ROB}. 
\end{DoxyReturn}



\begin{DoxyCode}
533 {
534     InstIt tail_thread = instList[tid].end();
535     tail_thread--;
536 
537     return *tail_thread;
538 }
\end{DoxyCode}
\hypertarget{classROB_a4dc637449366fcdfc4e764cdf12d9b11}{
\index{ROB@{ROB}!regStats@{regStats}}
\index{regStats@{regStats}!ROB@{ROB}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}void regStats ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a4dc637449366fcdfc4e764cdf12d9b11}
Registers statistics. 


\begin{DoxyCode}
543 {
544     using namespace Stats;
545     robReads
546         .name(name() + ".rob_reads")
547         .desc("The number of ROB reads");
548 
549     robWrites
550         .name(name() + ".rob_writes")
551         .desc("The number of ROB writes");
552 }
\end{DoxyCode}
\hypertarget{classROB_aaf9a05771a835f9f8d634cef36e24d40}{
\index{ROB@{ROB}!resetEntries@{resetEntries}}
\index{resetEntries@{resetEntries}!ROB@{ROB}}
\subsubsection[{resetEntries}]{\setlength{\rightskip}{0pt plus 5cm}void resetEntries ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_aaf9a05771a835f9f8d634cef36e24d40}
Re-\/adjust \hyperlink{classROB}{ROB} partitioning. 


\begin{DoxyCode}
161 {
162     if (robPolicy != Dynamic || numThreads > 1) {
163         int active_threads = activeThreads->size();
164 
165         list<ThreadID>::iterator threads = activeThreads->begin();
166         list<ThreadID>::iterator end = activeThreads->end();
167 
168         while (threads != end) {
169             ThreadID tid = *threads++;
170 
171             if (robPolicy == Partitioned) {
172                 maxEntries[tid] = numEntries / active_threads;
173             } else if (robPolicy == Threshold && active_threads == 1) {
174                 maxEntries[tid] = numEntries;
175             }
176         }
177     }
178 }
\end{DoxyCode}
\hypertarget{classROB_a755ee993c2d4e9d422c37990b15afa37}{
\index{ROB@{ROB}!resetState@{resetState}}
\index{resetState@{resetState}!ROB@{ROB}}
\subsubsection[{resetState}]{\setlength{\rightskip}{0pt plus 5cm}void resetState ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline, private\mbox{]}}}}
\label{classROB_a755ee993c2d4e9d422c37990b15afa37}
Reset the \hyperlink{classROB}{ROB} state 


\begin{DoxyCode}
112 {
113     for (ThreadID tid = 0; tid  < numThreads; tid++) {
114         doneSquashing[tid] = true;
115         threadEntries[tid] = 0;
116         squashIt[tid] = instList[tid].end();
117         squashedSeqNum[tid] = 0;
118     }
119     numInstsInROB = 0;
120 
121     // Initialize the "universal" ROB head & tail point to invalid
122     // pointers
123     head = instList[0].end();
124     tail = instList[0].end();
125 }
\end{DoxyCode}
\hypertarget{classROB_aa14c02115ece83633552be2368b60e67}{
\index{ROB@{ROB}!retireHead@{retireHead}}
\index{retireHead@{retireHead}!ROB@{ROB}}
\subsubsection[{retireHead}]{\setlength{\rightskip}{0pt plus 5cm}void retireHead ({\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_aa14c02115ece83633552be2368b60e67}
Retires the head instruction, removing it from the \hyperlink{classROB}{ROB}. Retires the head instruction of a specific thread, removing it from the \hyperlink{classROB}{ROB}. 


\begin{DoxyCode}
250 {
251     robWrites++;
252 
253     assert(numInstsInROB > 0);
254 
255     // Get the head ROB instruction.
256     InstIt head_it = instList[tid].begin();
257 
258     DynInstPtr head_inst = (*head_it);
259 
260     assert(head_inst->readyToCommit());
261 
262     DPRINTF(ROB, "[tid:%u]: Retiring head instruction, "
263             "instruction PC %s, [sn:%lli]\n", tid, head_inst->pcState(),
264             head_inst->seqNum);
265 
266     --numInstsInROB;
267     --threadEntries[tid];
268 
269     head_inst->clearInROB();
270     head_inst->setCommitted();
271 
272     instList[tid].erase(head_it);
273 
274     //Update "Global" Head of ROB
275     updateHead();
276 
277     // @todo: A special case is needed if the instruction being
278     // retired is the only instruction in the ROB; otherwise the tail
279     // iterator will become invalidated.
280     cpu->removeFrontInst(head_inst);
281 }
\end{DoxyCode}
\hypertarget{classROB_aab96bdacf8bd420402cbb543f994e054}{
\index{ROB@{ROB}!setActiveThreads@{setActiveThreads}}
\index{setActiveThreads@{setActiveThreads}!ROB@{ROB}}
\subsubsection[{setActiveThreads}]{\setlength{\rightskip}{0pt plus 5cm}void setActiveThreads ({\bf std::list}$<$ {\bf ThreadID} $>$ $\ast$ {\em at\_\-ptr})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_aab96bdacf8bd420402cbb543f994e054}
Sets pointer to the list of active threads. 
\begin{DoxyParams}{引数}
\item[{\em at\_\-ptr}]Pointer to the list of active threads. \end{DoxyParams}



\begin{DoxyCode}
137 {
138     DPRINTF(ROB, "Setting active threads list pointer.\n");
139     activeThreads = at_ptr;
140 }
\end{DoxyCode}
\hypertarget{classROB_aee9dc23de90acd20200641407a3bd1da}{
\index{ROB@{ROB}!squash@{squash}}
\index{squash@{squash}!ROB@{ROB}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash ({\bf InstSeqNum} {\em squash\_\-num}, \/  {\bf ThreadID} {\em tid})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_aee9dc23de90acd20200641407a3bd1da}
Squashes all instructions younger than the given sequence number for the specific thread. 


\begin{DoxyCode}
488 {
489     if (isEmpty(tid)) {
490         DPRINTF(ROB, "Does not need to squash due to being empty "
491                 "[sn:%i]\n",
492                 squash_num);
493 
494         return;
495     }
496 
497     DPRINTF(ROB, "Starting to squash within the ROB.\n");
498 
499     robStatus[tid] = ROBSquashing;
500 
501     doneSquashing[tid] = false;
502 
503     squashedSeqNum[tid] = squash_num;
504 
505     if (!instList[tid].empty()) {
506         InstIt tail_thread = instList[tid].end();
507         tail_thread--;
508 
509         squashIt[tid] = tail_thread;
510 
511         doSquash(tid);
512     }
513 }
\end{DoxyCode}
\hypertarget{classROB_a8674059ce345e23aac5086b2c3e24a43}{
\index{ROB@{ROB}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!ROB@{ROB}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}void takeOverFrom ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a8674059ce345e23aac5086b2c3e24a43}
Takes over another CPU's thread. 


\begin{DoxyCode}
154 {
155     resetState();
156 }
\end{DoxyCode}
\hypertarget{classROB_a5284fa5ccee18ce965fb4863722e96a9}{
\index{ROB@{ROB}!updateHead@{updateHead}}
\index{updateHead@{updateHead}!ROB@{ROB}}
\subsubsection[{updateHead}]{\setlength{\rightskip}{0pt plus 5cm}void updateHead ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_a5284fa5ccee18ce965fb4863722e96a9}
Updates the head instruction with the new oldest instruction. 


\begin{DoxyCode}
408 {
409     InstSeqNum lowest_num = 0;
410     bool first_valid = true;
411 
412     // @todo: set ActiveThreads through ROB or CPU
413     list<ThreadID>::iterator threads = activeThreads->begin();
414     list<ThreadID>::iterator end = activeThreads->end();
415 
416     while (threads != end) {
417         ThreadID tid = *threads++;
418 
419         if (instList[tid].empty())
420             continue;
421 
422         if (first_valid) {
423             head = instList[tid].begin();
424             lowest_num = (*head)->seqNum;
425             first_valid = false;
426             continue;
427         }
428 
429         InstIt head_thread = instList[tid].begin();
430 
431         DynInstPtr head_inst = (*head_thread);
432 
433         assert(head_inst != 0);
434 
435         if (head_inst->seqNum < lowest_num) {
436             head = head_thread;
437             lowest_num = head_inst->seqNum;
438         }
439     }
440 
441     if (first_valid) {
442         head = instList[0].end();
443     }
444 
445 }
\end{DoxyCode}
\hypertarget{classROB_acc69b1041902d0557b7be476f5c547aa}{
\index{ROB@{ROB}!updateTail@{updateTail}}
\index{updateTail@{updateTail}!ROB@{ROB}}
\subsubsection[{updateTail}]{\setlength{\rightskip}{0pt plus 5cm}void updateTail ()\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classROB_acc69b1041902d0557b7be476f5c547aa}
Updates the tail instruction with the new youngest instruction. 


\begin{DoxyCode}
450 {
451     tail = instList[0].end();
452     bool first_valid = true;
453 
454     list<ThreadID>::iterator threads = activeThreads->begin();
455     list<ThreadID>::iterator end = activeThreads->end();
456 
457     while (threads != end) {
458         ThreadID tid = *threads++;
459 
460         if (instList[tid].empty()) {
461             continue;
462         }
463 
464         // If this is the first valid then assign w/out
465         // comparison
466         if (first_valid) {
467             tail = instList[tid].end();
468             tail--;
469             first_valid = false;
470             continue;
471         }
472 
473         // Assign new tail if this thread's tail is younger
474         // than our current "tail high"
475         InstIt tail_thread = instList[tid].end();
476         tail_thread--;
477 
478         if ((*tail_thread)->seqNum > (*tail)->seqNum) {
479             tail = tail_thread;
480         }
481     }
482 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classROB_af6eaea53db532812052f71bf0380dab5}{
\index{ROB@{ROB}!activeThreads@{activeThreads}}
\index{activeThreads@{activeThreads}!ROB@{ROB}}
\subsubsection[{activeThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf ThreadID}$>$$\ast$ {\bf activeThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classROB_af6eaea53db532812052f71bf0380dab5}
Active Threads in CPU \hypertarget{classROB_a1379cf882a12ac6fc9eba5da7c84b18b}{
\index{ROB@{ROB}!cpu@{cpu}}
\index{cpu@{cpu}!ROB@{ROB}}
\subsubsection[{cpu}]{\setlength{\rightskip}{0pt plus 5cm}{\bf O3CPU}$\ast$ {\bf cpu}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classROB_a1379cf882a12ac6fc9eba5da7c84b18b}
Pointer to the CPU. \hypertarget{classROB_aa5d029365d2db19432b68bc048d8773d}{
\index{ROB@{ROB}!doneSquashing@{doneSquashing}}
\index{doneSquashing@{doneSquashing}!ROB@{ROB}}
\subsubsection[{doneSquashing}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf doneSquashing}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classROB_aa5d029365d2db19432b68bc048d8773d}
Is the \hyperlink{classROB}{ROB} done squashing. \hypertarget{classROB_a3f3e1afdb445d65050c39300f93716d2}{
\index{ROB@{ROB}!dummyInst@{dummyInst}}
\index{dummyInst@{dummyInst}!ROB@{ROB}}
\subsubsection[{dummyInst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DynInstPtr} {\bf dummyInst}}}
\label{classROB_a3f3e1afdb445d65050c39300f93716d2}
Dummy instruction returned if there are no \hyperlink{namespaceinsts}{insts} left. \hypertarget{classROB_ae6c12b73bfe6227eded2623bf432805b}{
\index{ROB@{ROB}!head@{head}}
\index{head@{head}!ROB@{ROB}}
\subsubsection[{head}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstIt} {\bf head}}}
\label{classROB_ae6c12b73bfe6227eded2623bf432805b}
Iterator pointing to the instruction which is the first instruction in in the \hyperlink{classROB}{ROB} \hypertarget{classROB_a7f2828a4f877a4a4d4b85a6788536b82}{
\index{ROB@{ROB}!instList@{instList}}
\index{instList@{instList}!ROB@{ROB}}
\subsubsection[{instList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std::list}$<${\bf DynInstPtr}$>$ {\bf instList}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classROB_a7f2828a4f877a4a4d4b85a6788536b82}
\hyperlink{classROB}{ROB} List of Instructions \hypertarget{classROB_a51e5f9f0cb40d61e95b1518f1be90b73}{
\index{ROB@{ROB}!maxEntries@{maxEntries}}
\index{maxEntries@{maxEntries}!ROB@{ROB}}
\subsubsection[{maxEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf maxEntries}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classROB_a51e5f9f0cb40d61e95b1518f1be90b73}
Max Insts a Thread Can Have in the \hyperlink{classROB}{ROB} \hypertarget{classROB_a325de474a9f6652329339d9fc2ea09c0}{
\index{ROB@{ROB}!numEntries@{numEntries}}
\index{numEntries@{numEntries}!ROB@{ROB}}
\subsubsection[{numEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf numEntries}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classROB_a325de474a9f6652329339d9fc2ea09c0}
Number of instructions in the \hyperlink{classROB}{ROB}. \hypertarget{classROB_a191acd130c66ac40c8bfa8f59febe417}{
\index{ROB@{ROB}!numInstsInROB@{numInstsInROB}}
\index{numInstsInROB@{numInstsInROB}!ROB@{ROB}}
\subsubsection[{numInstsInROB}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf numInstsInROB}}}
\label{classROB_a191acd130c66ac40c8bfa8f59febe417}
Number of instructions in the \hyperlink{classROB}{ROB}. \hypertarget{classROB_a88377f855dbf5adeeecb06b5bb821d35}{
\index{ROB@{ROB}!numThreads@{numThreads}}
\index{numThreads@{numThreads}!ROB@{ROB}}
\subsubsection[{numThreads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ThreadID} {\bf numThreads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classROB_a88377f855dbf5adeeecb06b5bb821d35}
Number of active threads. \hypertarget{classROB_a802d14d10f8445b65f5c9d50ea0c6794}{
\index{ROB@{ROB}!robPolicy@{robPolicy}}
\index{robPolicy@{robPolicy}!ROB@{ROB}}
\subsubsection[{robPolicy}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ROBPolicy} {\bf robPolicy}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classROB_a802d14d10f8445b65f5c9d50ea0c6794}
\hyperlink{classROB}{ROB} resource sharing policy for SMT mode. \hypertarget{classROB_a982979b3e3e933cd62fa40789af9153d}{
\index{ROB@{ROB}!robReads@{robReads}}
\index{robReads@{robReads}!ROB@{ROB}}
\subsubsection[{robReads}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf robReads}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classROB_a982979b3e3e933cd62fa40789af9153d}
\hypertarget{classROB_a23d5e98a57c975ddb5106a14af875f9b}{
\index{ROB@{ROB}!robStatus@{robStatus}}
\index{robStatus@{robStatus}!ROB@{ROB}}
\subsubsection[{robStatus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Status} {\bf robStatus}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classROB_a23d5e98a57c975ddb5106a14af875f9b}
Per-\/thread \hyperlink{classROB}{ROB} status. \hypertarget{classROB_a4c459f15b21d3f34da46fe0ca2280cf6}{
\index{ROB@{ROB}!robWrites@{robWrites}}
\index{robWrites@{robWrites}!ROB@{ROB}}
\subsubsection[{robWrites}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stats::Scalar} {\bf robWrites}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classROB_a4c459f15b21d3f34da46fe0ca2280cf6}
\hypertarget{classROB_a97d5a7e4630ad1d017909f7504b9ec32}{
\index{ROB@{ROB}!squashedSeqNum@{squashedSeqNum}}
\index{squashedSeqNum@{squashedSeqNum}!ROB@{ROB}}
\subsubsection[{squashedSeqNum}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstSeqNum} {\bf squashedSeqNum}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classROB_a97d5a7e4630ad1d017909f7504b9ec32}
The sequence number of the squashed instruction. \hypertarget{classROB_a51c7e06ec4f16d99b424b2e8ba8ff6fb}{
\index{ROB@{ROB}!squashIt@{squashIt}}
\index{squashIt@{squashIt}!ROB@{ROB}}
\subsubsection[{squashIt}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstIt} {\bf squashIt}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classROB_a51c7e06ec4f16d99b424b2e8ba8ff6fb}
Iterator used for walking through the list of instructions when squashing. Used so that there is persistent state between cycles; when squashing, the instructions are marked as squashed but not immediately removed, meaning the tail iterator remains the same before and after a squash. This will always be set to cpu-\/$>$instList.end() if it is invalid. \hypertarget{classROB_a2bfc819c212cc4fda248fe12fbba68b8}{
\index{ROB@{ROB}!squashWidth@{squashWidth}}
\index{squashWidth@{squashWidth}!ROB@{ROB}}
\subsubsection[{squashWidth}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf squashWidth}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classROB_a2bfc819c212cc4fda248fe12fbba68b8}
Number of instructions that can be squashed in a single cycle. \hypertarget{classROB_a20dbd4d473546ec8b674542f765626e5}{
\index{ROB@{ROB}!tail@{tail}}
\index{tail@{tail}!ROB@{ROB}}
\subsubsection[{tail}]{\setlength{\rightskip}{0pt plus 5cm}{\bf InstIt} {\bf tail}}}
\label{classROB_a20dbd4d473546ec8b674542f765626e5}
Iterator pointing to the instruction which is the last instruction in the \hyperlink{classROB}{ROB}. This may at times be invalid (ie when the \hyperlink{classROB}{ROB} is empty), however it should never be incorrect. \hypertarget{classROB_a22332ec3217f4cc3ca98a489d0b6b6ab}{
\index{ROB@{ROB}!threadEntries@{threadEntries}}
\index{threadEntries@{threadEntries}!ROB@{ROB}}
\subsubsection[{threadEntries}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf threadEntries}\mbox{[}Impl::MaxThreads\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classROB_a22332ec3217f4cc3ca98a489d0b6b6ab}
Entries Per Thread 

このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
cpu/o3/\hyperlink{rob_8hh}{rob.hh}\item 
cpu/o3/\hyperlink{rob__impl_8hh}{rob\_\-impl.hh}\end{DoxyCompactItemize}
