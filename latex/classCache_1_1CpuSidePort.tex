\hypertarget{classCache_1_1CpuSidePort}{
\section{クラス テンプレート CpuSidePort$<$ TagStore $>$}
\label{classCache_1_1CpuSidePort}\index{Cache::CpuSidePort@{Cache::CpuSidePort}}
}


{\ttfamily \#include $<$cache.hh$>$}\subsection*{Public メソッド}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classCache_1_1CpuSidePort_a3caee65fa12179ad530ea38fe45bd8be}{CpuSidePort} (const std::string \&\_\-name, \hyperlink{classCache}{Cache}$<$ TagStore $>$ $\ast$\_\-cache, const std::string \&\_\-label)
\end{DoxyCompactItemize}
\subsection*{Protected メソッド}
\begin{DoxyCompactItemize}
\item 
virtual bool \hyperlink{classCache_1_1CpuSidePort_a9b643d565edc21dac11ce15a560238a7}{recvTimingSnoopResp} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual bool \hyperlink{classCache_1_1CpuSidePort_a3344d9dd0f83257feab5424e761f31c6}{recvTimingReq} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{base_2types_8hh_a5c8ed81b7d238c9083e1037ba6d61643}{Tick} \hyperlink{classCache_1_1CpuSidePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{recvAtomic} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual void \hyperlink{classCache_1_1CpuSidePort_aeefa907fb6d6a787e6dab90e8138ea90}{recvFunctional} (\hyperlink{classPacket}{PacketPtr} pkt)
\item 
virtual \hyperlink{classstd_1_1list}{AddrRangeList} \hyperlink{classCache_1_1CpuSidePort_a36cf113d5e5e091ebddb32306c098fae}{getAddrRanges} () const 
\end{DoxyCompactItemize}
\subsection*{Private 変数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classCache}{Cache}$<$ TagStore $>$ $\ast$ \hyperlink{classCache_1_1CpuSidePort_ae1a869e306f5bc5028f706229d68aba1}{cache}
\end{DoxyCompactItemize}


\subsection{説明}
\subsubsection*{template$<$class TagStore$>$template$<$class TagStore$>$ class Cache$<$ TagStore $>$::CpuSidePort$<$ TagStore $>$}

The CPU-\/side port extends the base cache slave port with access functions for functional, atomic and timing requests. 

\subsection{コンストラクタとデストラクタ}
\hypertarget{classCache_1_1CpuSidePort_a3caee65fa12179ad530ea38fe45bd8be}{
\index{Cache::CpuSidePort@{Cache::CpuSidePort}!CpuSidePort@{CpuSidePort}}
\index{CpuSidePort@{CpuSidePort}!Cache::CpuSidePort@{Cache::CpuSidePort}}
\subsubsection[{CpuSidePort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf CpuSidePort} (const std::string \& {\em \_\-name}, \/  {\bf Cache}$<$ TagStore $>$ $\ast$ {\em \_\-cache}, \/  const std::string \& {\em \_\-label})\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classCache_1_1CpuSidePort_a3caee65fa12179ad530ea38fe45bd8be}



\begin{DoxyCode}
1900     : BaseCache::CacheSlavePort(_name, _cache, _label), cache(_cache)
1901 {
1902 }
\end{DoxyCode}


\subsection{関数}
\hypertarget{classCache_1_1CpuSidePort_a36cf113d5e5e091ebddb32306c098fae}{
\index{Cache::CpuSidePort@{Cache::CpuSidePort}!getAddrRanges@{getAddrRanges}}
\index{getAddrRanges@{getAddrRanges}!Cache::CpuSidePort@{Cache::CpuSidePort}}
\subsubsection[{getAddrRanges}]{\setlength{\rightskip}{0pt plus 5cm}{\bf AddrRangeList} getAddrRanges () const\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classCache_1_1CpuSidePort_a36cf113d5e5e091ebddb32306c098fae}



\begin{DoxyCode}
1861 {
1862     return cache->getAddrRanges();
1863 }
\end{DoxyCode}
\hypertarget{classCache_1_1CpuSidePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}{
\index{Cache::CpuSidePort@{Cache::CpuSidePort}!recvAtomic@{recvAtomic}}
\index{recvAtomic@{recvAtomic}!Cache::CpuSidePort@{Cache::CpuSidePort}}
\subsubsection[{recvAtomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Tick} recvAtomic ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classCache_1_1CpuSidePort_a5f0b4c4a94f6b0053f9d7a4eb9c2518a}



\begin{DoxyCode}
1884 {
1885     return cache->recvAtomic(pkt);
1886 }
\end{DoxyCode}
\hypertarget{classCache_1_1CpuSidePort_aeefa907fb6d6a787e6dab90e8138ea90}{
\index{Cache::CpuSidePort@{Cache::CpuSidePort}!recvFunctional@{recvFunctional}}
\index{recvFunctional@{recvFunctional}!Cache::CpuSidePort@{Cache::CpuSidePort}}
\subsubsection[{recvFunctional}]{\setlength{\rightskip}{0pt plus 5cm}void recvFunctional ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classCache_1_1CpuSidePort_aeefa907fb6d6a787e6dab90e8138ea90}



\begin{DoxyCode}
1891 {
1892     // functional request
1893     cache->functionalAccess(pkt, true);
1894 }
\end{DoxyCode}
\hypertarget{classCache_1_1CpuSidePort_a3344d9dd0f83257feab5424e761f31c6}{
\index{Cache::CpuSidePort@{Cache::CpuSidePort}!recvTimingReq@{recvTimingReq}}
\index{recvTimingReq@{recvTimingReq}!Cache::CpuSidePort@{Cache::CpuSidePort}}
\subsubsection[{recvTimingReq}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingReq ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classCache_1_1CpuSidePort_a3344d9dd0f83257feab5424e761f31c6}



\begin{DoxyCode}
1868 {
1869     // always let inhibited requests through even if blocked
1870     if (!pkt->memInhibitAsserted() && blocked) {
1871         assert(!cache->system->bypassCaches());
1872         DPRINTF(Cache,"Scheduling a retry while blocked\n");
1873         mustSendRetry = true;
1874         return false;
1875     }
1876 
1877     cache->recvTimingReq(pkt);
1878     return true;
1879 }
\end{DoxyCode}
\hypertarget{classCache_1_1CpuSidePort_a9b643d565edc21dac11ce15a560238a7}{
\index{Cache::CpuSidePort@{Cache::CpuSidePort}!recvTimingSnoopResp@{recvTimingSnoopResp}}
\index{recvTimingSnoopResp@{recvTimingSnoopResp}!Cache::CpuSidePort@{Cache::CpuSidePort}}
\subsubsection[{recvTimingSnoopResp}]{\setlength{\rightskip}{0pt plus 5cm}bool recvTimingSnoopResp ({\bf PacketPtr} {\em pkt})\hspace{0.3cm}{\ttfamily  \mbox{[}inline, protected, virtual\mbox{]}}}}
\label{classCache_1_1CpuSidePort_a9b643d565edc21dac11ce15a560238a7}



\begin{DoxyCode}
1593 {
1594     // Express snoop responses from master to slave, e.g., from L1 to L2
1595     cache->recvTimingSnoopResp(pkt);
1596     return true;
1597 }
\end{DoxyCode}


\subsection{変数}
\hypertarget{classCache_1_1CpuSidePort_ae1a869e306f5bc5028f706229d68aba1}{
\index{Cache::CpuSidePort@{Cache::CpuSidePort}!cache@{cache}}
\index{cache@{cache}!Cache::CpuSidePort@{Cache::CpuSidePort}}
\subsubsection[{cache}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cache}$<$TagStore$>$$\ast$ {\bf cache}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}
\label{classCache_1_1CpuSidePort_ae1a869e306f5bc5028f706229d68aba1}


このクラスの説明は次のファイルから生成されました:\begin{DoxyCompactItemize}
\item 
mem/cache/\hyperlink{cache_8hh}{cache.hh}\item 
mem/cache/\hyperlink{cache__impl_8hh}{cache\_\-impl.hh}\end{DoxyCompactItemize}
