<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>File&nbsp;GEM5&nbsp;Wrapper: クラス AtomicSimpleCPU</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- 作成： Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>メインページ</span></a></li>
      <li><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>構成</span></a></li>
      <li><a href="classes.html"><span>構成索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>構成メンバ</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>クラス AtomicSimpleCPU</h1><!-- doxytag: class="AtomicSimpleCPU" --><!-- doxytag: inherits="BaseSimpleCPU" -->
<p><code>#include &lt;<a class="el" href="atomic_8hh_source.html">atomic.hh</a>&gt;</code></p>
<div class="dynheader">
AtomicSimpleCPUに対する継承グラフ</div>
<div class="dynsection">
 <div class="center">
  <img src="classAtomicSimpleCPU.gif" usemap="#AtomicSimpleCPU_map" alt=""/>
  <map id="AtomicSimpleCPU_map" name="AtomicSimpleCPU_map">
<area href="classBaseSimpleCPU.html" alt="BaseSimpleCPU" shape="rect" coords="0,56,112,80"/>
<area href="classBaseCPU.html" alt="BaseCPU" shape="rect" coords="0,0,112,24"/>
</map>
 </div>
</div>

<p><a href="classAtomicSimpleCPU-members.html">すべてのメンバ一覧</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>構成</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU_1_1AtomicCPUDPort.html">AtomicCPUDPort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU_1_1AtomicCPUPort.html">AtomicCPUPort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU_1_1AtomicSimpleCPU.html">AtomicSimpleCPU</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtomicSimpleCPU_1_1BBInfo.html">BBInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtomicSimpleCPU_1_1TickEvent.html">TickEvent</a></td></tr>
<tr><td colspan="2"><h2>Public メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#ad25e81d46bd9fe8b4f176b129a012bc6">AtomicSimpleCPU</a> (AtomicSimpleCPUParams *params)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a0c1821e85cf304f5a090c51f3460d577">~AtomicSimpleCPU</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a4e932bfc8aa6dfb998b8496a0f04ace3">drain</a> (<a class="el" href="classDrainManager.html">DrainManager</a> *<a class="el" href="classAtomicSimpleCPU.html#af9ba920f669cbe0f18c71846715d690a">drain_manager</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a8f020d3237536fe007fc488c4125c5d8">drainResume</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a05f299b443f8cc73a93d61572edc0218">switchOut</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#ac82d2b8d331b2e8e6854a95d2917dfa2">takeOverFrom</a> (<a class="el" href="classBaseCPU_1_1BaseCPU.html">BaseCPU</a> *oldCPU)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#ae2e1ccebe596a180f8105d57f9a93645">verifyMemoryMode</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#ad7a501b28bdbe8b3e708cd1ef69ac191">activateContext</a> (<a class="el" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a> thread_num, <a class="el" href="classCycles.html">Cycles</a> delay)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a1dad4c4d2c3df4ef367e14fcc973ce74">suspendContext</a> (<a class="el" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a> thread_num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefCountingPtr.html">Fault</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a66191b2d8a45050b7df3c3efa7bb07c6">readMem</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> addr, uint8_t *data, unsigned size, unsigned flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefCountingPtr.html">Fault</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#ad46c5edeb1ee9b60445f3e26364e2c5e">writeMem</a> (uint8_t *data, unsigned size, <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> addr, unsigned flags, uint64_t *res)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a88aa41e2693dd0091afae2604eba9bed">printAddr</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> a)</td></tr>
<tr><td colspan="2"><h2>Protected メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMasterPort.html">MasterPort</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#aeea6b55ae1c4be53c21dbee434b221d4">getDataPort</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMasterPort.html">MasterPort</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a40da530cb5dd380fd7fc0d786e94d5eb">getInstPort</a> ()</td></tr>
<tr><td colspan="2"><h2>Private メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a873dd91783f9efb4a590aded1f70d6b0">tick</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#ac166e5bc3ddf730beb1282cf821096ae">isDrained</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#abfea8f75a7a7480716801affeebbe87b">tryCompleteDrain</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#aa51e4d7f169cd8e8b2e144fdcfd36f33">profileSimPoint</a> ()</td></tr>
<tr><td colspan="2"><h2>Private 変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAtomicSimpleCPU_1_1TickEvent.html">TickEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a837aabdd54757cb86d0f66387511753f">width</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a18a0f1e6c3d21c252b14ea6ae162e2ff">locked</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#aab46afe7eb154b233d2ba1886a4b399f">simulate_data_stalls</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#ac5ff523d495df7133594dec7894aacc7">simulate_inst_stalls</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDrainManager.html">DrainManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#af9ba920f669cbe0f18c71846715d690a">drain_manager</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAtomicSimpleCPU_1_1AtomicCPUPort.html">AtomicCPUPort</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a35e511691227100effd63e8a7fc12989">icachePort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAtomicSimpleCPU_1_1AtomicCPUDPort.html">AtomicCPUDPort</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#ab6b7665b418b12dc80b485e66d23ed19">dcachePort</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a66f9c88f6fa05c882787a7e98a7101f5">fastmem</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRequest.html">Request</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a64ba0dde58d6c2c1c5e24a0b3e3b506f">ifetch_req</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRequest.html">Request</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a836513db061d14f39d79751c40fa9951">data_read_req</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRequest.html">Request</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#af2cc98a9d486d932d85c4513a4670ca8">data_write_req</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a40a30a05f8e2b8b4c62c0ee0a019686a">dcache_access</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a08f04a43a6d731e966308aaeece77208">dcache_latency</a></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd41d8cd98f00b204e9800998ecf8427e"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a556c6eb1f8f869ee7d0802381701c49f">simpoint</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#afa2df438a2925349299948892f519ea2">intervalSize</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a4ba2ebd08d9a7f8efe072ed006f2ba56">intervalCount</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a0c93f234d5028e73f388f7e730db728f">intervalDrift</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a77497fabc62f774e824e9b57974e0301">simpointStream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">m5::hash_map&lt; <a class="el" href="classstd_1_1pair.html">BasicBlockRange</a>, <br class="typebreak"/>
<a class="el" href="structAtomicSimpleCPU_1_1BBInfo.html">BBInfo</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a06bfab070d35f298897393f7ee6e066c">bbMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1pair.html">BasicBlockRange</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#aa13454a445c3711abe528bdd288a953c">currentBBV</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicSimpleCPU.html#a375bb98c835fcacb306ec154ac3c7f85">currentBBVInstCount</a></td></tr>
</table>
<hr/><h2>コンストラクタとデストラクタ</h2>
<a class="anchor" id="ad25e81d46bd9fe8b4f176b129a012bc6"></a><!-- doxytag: member="AtomicSimpleCPU::AtomicSimpleCPU" ref="ad25e81d46bd9fe8b4f176b129a012bc6" args="(AtomicSimpleCPUParams *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAtomicSimpleCPU_1_1AtomicSimpleCPU.html">AtomicSimpleCPU</a> </td>
          <td>(</td>
          <td class="paramtype">AtomicSimpleCPUParams *&nbsp;</td>
          <td class="paramname"> <em>params</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00107"></a>00107     : <a class="code" href="classBaseSimpleCPU.html#a71551db7d052136dcf3e0ff87f935568">BaseSimpleCPU</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>), <a class="code" href="classAtomicSimpleCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>(<span class="keyword">this</span>), <a class="code" href="classAtomicSimpleCPU.html#a837aabdd54757cb86d0f66387511753f">width</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;width), <a class="code" href="classAtomicSimpleCPU.html#a18a0f1e6c3d21c252b14ea6ae162e2ff">locked</a>(<span class="keyword">false</span>),
<a name="l00108"></a>00108       <a class="code" href="classAtomicSimpleCPU.html#aab46afe7eb154b233d2ba1886a4b399f">simulate_data_stalls</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;simulate_data_stalls),
<a name="l00109"></a>00109       <a class="code" href="classAtomicSimpleCPU.html#ac5ff523d495df7133594dec7894aacc7">simulate_inst_stalls</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;simulate_inst_stalls),
<a name="l00110"></a>00110       <a class="code" href="classAtomicSimpleCPU.html#af9ba920f669cbe0f18c71846715d690a">drain_manager</a>(<a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>),
<a name="l00111"></a>00111       <a class="code" href="classAtomicSimpleCPU.html#a35e511691227100effd63e8a7fc12989">icachePort</a>(<a class="code" href="trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>() + <span class="stringliteral">&quot;.icache_port&quot;</span>, <span class="keyword">this</span>),
<a name="l00112"></a>00112       <a class="code" href="classAtomicSimpleCPU.html#ab6b7665b418b12dc80b485e66d23ed19">dcachePort</a>(<a class="code" href="trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>() + <span class="stringliteral">&quot;.dcache_port&quot;</span>, <span class="keyword">this</span>),
<a name="l00113"></a>00113       <a class="code" href="classAtomicSimpleCPU.html#a66f9c88f6fa05c882787a7e98a7101f5">fastmem</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;fastmem),
<a name="l00114"></a>00114       <a class="code" href="classAtomicSimpleCPU.html#a556c6eb1f8f869ee7d0802381701c49f">simpoint</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;simpoint_profile),
<a name="l00115"></a>00115       <a class="code" href="classAtomicSimpleCPU.html#afa2df438a2925349299948892f519ea2">intervalSize</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;simpoint_interval),
<a name="l00116"></a>00116       <a class="code" href="classAtomicSimpleCPU.html#a4ba2ebd08d9a7f8efe072ed006f2ba56">intervalCount</a>(0),
<a name="l00117"></a>00117       <a class="code" href="classAtomicSimpleCPU.html#a0c93f234d5028e73f388f7e730db728f">intervalDrift</a>(0),
<a name="l00118"></a>00118       <a class="code" href="classAtomicSimpleCPU.html#a77497fabc62f774e824e9b57974e0301">simpointStream</a>(<a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>),
<a name="l00119"></a>00119       <a class="code" href="classAtomicSimpleCPU.html#aa13454a445c3711abe528bdd288a953c">currentBBV</a>(0, 0),
<a name="l00120"></a>00120       <a class="code" href="classAtomicSimpleCPU.html#a375bb98c835fcacb306ec154ac3c7f85">currentBBVInstCount</a>(0)
<a name="l00121"></a>00121 {
<a name="l00122"></a>00122     <a class="code" href="classBaseSimpleCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> = <a class="code" href="classBaseSimpleCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124     <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#a556c6eb1f8f869ee7d0802381701c49f">simpoint</a>) {
<a name="l00125"></a>00125         <a class="code" href="classAtomicSimpleCPU.html#a77497fabc62f774e824e9b57974e0301">simpointStream</a> = <a class="code" href="output_8cc.html#a08819d32c217c58b155584845ddadd4a">simout</a>.<a class="code" href="classOutputDirectory.html#a22e4aa8ec29a265a1c299a1a009c85cc">create</a>(<a class="code" href="namespaceMipsISA.html#a37d3f683959086eac7bcf24a002a9fb8">p</a>-&gt;simpoint_profile_file, <span class="keyword">false</span>);
<a name="l00126"></a>00126     }
<a name="l00127"></a>00127 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0c1821e85cf304f5a090c51f3460d577"></a><!-- doxytag: member="AtomicSimpleCPU::~AtomicSimpleCPU" ref="a0c1821e85cf304f5a090c51f3460d577" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classAtomicSimpleCPU_1_1AtomicSimpleCPU.html">AtomicSimpleCPU</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00131"></a>00131 {
<a name="l00132"></a>00132     <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>.<a class="code" href="classEvent.html#a9cd69a6b10cb037550943f177a0da688" title="Determine if the current event is scheduled.">scheduled</a>()) {
<a name="l00133"></a>00133         deschedule(<a class="code" href="classAtomicSimpleCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>);
<a name="l00134"></a>00134     }
<a name="l00135"></a>00135     <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#a77497fabc62f774e824e9b57974e0301">simpointStream</a>) {
<a name="l00136"></a>00136         <a class="code" href="output_8cc.html#a08819d32c217c58b155584845ddadd4a">simout</a>.<a class="code" href="classOutputDirectory.html#a3cc929ea4ca094903ac826046d510634">close</a>(<a class="code" href="classAtomicSimpleCPU.html#a77497fabc62f774e824e9b57974e0301">simpointStream</a>);
<a name="l00137"></a>00137     }
<a name="l00138"></a>00138 }
</pre></div></p>

</div>
</div>
<hr/><h2>関数</h2>
<a class="anchor" id="ad7a501b28bdbe8b3e708cd1ef69ac191"></a><!-- doxytag: member="AtomicSimpleCPU::activateContext" ref="ad7a501b28bdbe8b3e708cd1ef69ac191" args="(ThreadID thread_num, Cycles delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activateContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a>&nbsp;</td>
          <td class="paramname"> <em>thread_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCycles.html">Cycles</a>&nbsp;</td>
          <td class="paramname"> <em>delay</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00240"></a>00240 {
<a name="l00241"></a>00241     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(SimpleCPU, <span class="stringliteral">&quot;ActivateContext %d (%d cycles)\n&quot;</span>, thread_num, delay);
<a name="l00242"></a>00242 
<a name="l00243"></a>00243     assert(thread_num == 0);
<a name="l00244"></a>00244     assert(<a class="code" href="classBaseSimpleCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>);
<a name="l00245"></a>00245 
<a name="l00246"></a>00246     assert(<a class="code" href="classBaseSimpleCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> == <a class="code" href="classBaseSimpleCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>);
<a name="l00247"></a>00247     assert(!<a class="code" href="classAtomicSimpleCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>.<a class="code" href="classEvent.html#a9cd69a6b10cb037550943f177a0da688" title="Determine if the current event is scheduled.">scheduled</a>());
<a name="l00248"></a>00248 
<a name="l00249"></a>00249     <a class="code" href="classBaseSimpleCPU.html#a40be38a691cf502b6ba46aaefd86dc77">notIdleFraction</a> = 1;
<a name="l00250"></a>00250     numCycles += ticksToCycles(<a class="code" href="classBaseSimpleCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="structThreadState.html#adba46356f3cbff06bc296a0cf84453e8">lastActivate</a> - <a class="code" href="classBaseSimpleCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="structThreadState.html#ac2a3eaa24ceabac390386cca70cc0aa3">lastSuspend</a>);
<a name="l00251"></a>00251 
<a name="l00252"></a>00252     <span class="comment">//Make sure ticks are still on multiples of cycles</span>
<a name="l00253"></a>00253     schedule(<a class="code" href="classAtomicSimpleCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>, clockEdge(delay));
<a name="l00254"></a>00254     <a class="code" href="classBaseSimpleCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> = <a class="code" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8a2f5f2c4a8c4f4f0519d503dcdfbf55cb">BaseSimpleCPU::Running</a>;
<a name="l00255"></a>00255 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4e932bfc8aa6dfb998b8496a0f04ace3"></a><!-- doxytag: member="AtomicSimpleCPU::drain" ref="a4e932bfc8aa6dfb998b8496a0f04ace3" args="(DrainManager *drain_manager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int drain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDrainManager.html">DrainManager</a> *&nbsp;</td>
          <td class="paramname"> <em>drain_manager</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00142"></a>00142 {
<a name="l00143"></a>00143     assert(!drain_manager);
<a name="l00144"></a>00144     <span class="keywordflow">if</span> (switchedOut())
<a name="l00145"></a>00145         <span class="keywordflow">return</span> 0;
<a name="l00146"></a>00146 
<a name="l00147"></a>00147     <span class="keywordflow">if</span> (!<a class="code" href="classAtomicSimpleCPU.html#ac166e5bc3ddf730beb1282cf821096ae">isDrained</a>()) {
<a name="l00148"></a>00148         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;Requesting drain: %s\n&quot;</span>, <a class="code" href="classBaseSimpleCPU.html#a827fb3454585cf4c620f4fd341966317">pcState</a>());
<a name="l00149"></a>00149         drain_manager = <a class="code" href="namespaceMipsISA.html#a2575c29e7f4617b6076486f340b6fe19">dm</a>;
<a name="l00150"></a>00150         <span class="keywordflow">return</span> 1;
<a name="l00151"></a>00151     } <span class="keywordflow">else</span> {
<a name="l00152"></a>00152         <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>.<a class="code" href="classEvent.html#a9cd69a6b10cb037550943f177a0da688" title="Determine if the current event is scheduled.">scheduled</a>())
<a name="l00153"></a>00153             deschedule(<a class="code" href="classAtomicSimpleCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>);
<a name="l00154"></a>00154 
<a name="l00155"></a>00155         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;Not executing microcode, no need to drain.\n&quot;</span>);
<a name="l00156"></a>00156         <span class="keywordflow">return</span> 0;
<a name="l00157"></a>00157     }
<a name="l00158"></a>00158 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8f020d3237536fe007fc488c4125c5d8"></a><!-- doxytag: member="AtomicSimpleCPU::drainResume" ref="a8f020d3237536fe007fc488c4125c5d8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drainResume </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00162"></a>00162 {
<a name="l00163"></a>00163     assert(!<a class="code" href="classAtomicSimpleCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>.<a class="code" href="classEvent.html#a9cd69a6b10cb037550943f177a0da688" title="Determine if the current event is scheduled.">scheduled</a>());
<a name="l00164"></a>00164     assert(!<a class="code" href="classAtomicSimpleCPU.html#af9ba920f669cbe0f18c71846715d690a">drain_manager</a>);
<a name="l00165"></a>00165     <span class="keywordflow">if</span> (switchedOut())
<a name="l00166"></a>00166         <span class="keywordflow">return</span>;
<a name="l00167"></a>00167 
<a name="l00168"></a>00168     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(SimpleCPU, <span class="stringliteral">&quot;Resume\n&quot;</span>);
<a name="l00169"></a>00169     <a class="code" href="classAtomicSimpleCPU.html#ae2e1ccebe596a180f8105d57f9a93645">verifyMemoryMode</a>();
<a name="l00170"></a>00170 
<a name="l00171"></a>00171     assert(!threadContexts.empty());
<a name="l00172"></a>00172     <span class="keywordflow">if</span> (threadContexts.size() &gt; 1)
<a name="l00173"></a>00173         <a class="code" href="base_2misc_8hh.html#acad519418dbfdd70c1208711e609c80e">fatal</a>(<span class="stringliteral">&quot;The atomic CPU only supports one thread.\n&quot;</span>);
<a name="l00174"></a>00174 
<a name="l00175"></a>00175     <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a2ad9e92a82d6f783b3061584729c2f4a">status</a>() == <a class="code" href="classThreadContext.html#a67a0db04d321a74b7e7fcfd3f1a3f70ba26bd8444261cc58df7a86753c79d2520">ThreadContext::Active</a>) {
<a name="l00176"></a>00176         schedule(<a class="code" href="classAtomicSimpleCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>, nextCycle());
<a name="l00177"></a>00177         <a class="code" href="classBaseSimpleCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> = <a class="code" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8a2f5f2c4a8c4f4f0519d503dcdfbf55cb">BaseSimpleCPU::Running</a>;
<a name="l00178"></a>00178         <a class="code" href="classBaseSimpleCPU.html#a40be38a691cf502b6ba46aaefd86dc77">notIdleFraction</a> = 1;
<a name="l00179"></a>00179     } <span class="keywordflow">else</span> {
<a name="l00180"></a>00180         <a class="code" href="classBaseSimpleCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> = <a class="code" href="classBaseSimpleCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">BaseSimpleCPU::Idle</a>;
<a name="l00181"></a>00181         <a class="code" href="classBaseSimpleCPU.html#a40be38a691cf502b6ba46aaefd86dc77">notIdleFraction</a> = 0;
<a name="l00182"></a>00182     }
<a name="l00183"></a>00183 
<a name="l00184"></a>00184     <a class="code" href="classBaseCPU.html#ab737471139f5a296e5b26e8a0e1b0744" title="initialize section">system</a>-&gt;totalNumInsts = 0;
<a name="l00185"></a>00185 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aeea6b55ae1c4be53c21dbee434b221d4"></a><!-- doxytag: member="AtomicSimpleCPU::getDataPort" ref="aeea6b55ae1c4be53c21dbee434b221d4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMasterPort.html">MasterPort</a>&amp; getDataPort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>End of data structures for SimPoints BBV generation Return a reference to the data port. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00250"></a>00250 { <span class="keywordflow">return</span> <a class="code" href="classAtomicSimpleCPU.html#ab6b7665b418b12dc80b485e66d23ed19">dcachePort</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a40da530cb5dd380fd7fc0d786e94d5eb"></a><!-- doxytag: member="AtomicSimpleCPU::getInstPort" ref="a40da530cb5dd380fd7fc0d786e94d5eb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMasterPort.html">MasterPort</a>&amp; getInstPort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the instruction port. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00253"></a>00253 { <span class="keywordflow">return</span> <a class="code" href="classAtomicSimpleCPU.html#a35e511691227100effd63e8a7fc12989">icachePort</a>; }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a02fd73d861ef2e4aabb38c0c9ff82947"></a><!-- doxytag: member="AtomicSimpleCPU::init" ref="a02fd73d861ef2e4aabb38c0c9ff82947" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00085"></a>00085 {
<a name="l00086"></a>00086     <a class="code" href="classSimObject.html#a02fd73d861ef2e4aabb38c0c9ff82947">BaseCPU::init</a>();
<a name="l00087"></a>00087 
<a name="l00088"></a>00088     <span class="comment">// Initialise the ThreadContext&apos;s memory proxies</span>
<a name="l00089"></a>00089     <a class="code" href="classBaseSimpleCPU.html#ad33756f3e96ee445dca8d69b1dd8709c">tcBase</a>()-&gt;<a class="code" href="classThreadContext.html#a6657d03bdea324a6ada2e4450307262c">initMemProxies</a>(<a class="code" href="classBaseSimpleCPU.html#ad33756f3e96ee445dca8d69b1dd8709c">tcBase</a>());
<a name="l00090"></a>00090 
<a name="l00091"></a>00091     <span class="keywordflow">if</span> (<a class="code" href="full__system_8hh.html#af929576af6f85c8849704b66d04b8370">FullSystem</a> &amp;&amp; !params()-&gt;<a class="code" href="classBaseCPU.html#a121f751814e1a758b12f22303623a3f2">switched_out</a>) {
<a name="l00092"></a>00092         <a class="code" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a> size = threadContexts.size();
<a name="l00093"></a>00093         <span class="keywordflow">for</span> (<a class="code" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a> <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> = 0; <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> &lt; size; ++<a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>) {
<a name="l00094"></a>00094             <a class="code" href="classThreadContext.html">ThreadContext</a> *<a class="code" href="classBaseSimpleCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a> = threadContexts[<a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>];
<a name="l00095"></a>00095             <span class="comment">// initialize CPU, including PC</span>
<a name="l00096"></a>00096             <a class="code" href="namespaceAlphaISA.html#aded557a1e716c6f849b0e0b05fc77676">TheISA::initCPU</a>(tc, tc-&gt;<a class="code" href="classThreadContext.html#a5a3ce3f955d2ec16ac6f2aa21e42f3a0">contextId</a>());
<a name="l00097"></a>00097         }
<a name="l00098"></a>00098     }
<a name="l00099"></a>00099 
<a name="l00100"></a>00100     <span class="comment">// Atomic doesn&apos;t do MT right now, so contextId == threadId</span>
<a name="l00101"></a>00101     <a class="code" href="classAtomicSimpleCPU.html#a64ba0dde58d6c2c1c5e24a0b3e3b506f">ifetch_req</a>.<a class="code" href="classRequest.html#a40574dadf22fb92b4966eb9815da7575">setThreadContext</a>(_cpuId, 0); <span class="comment">// Add thread ID if we add MT</span>
<a name="l00102"></a>00102     <a class="code" href="classAtomicSimpleCPU.html#a836513db061d14f39d79751c40fa9951">data_read_req</a>.<a class="code" href="classRequest.html#a40574dadf22fb92b4966eb9815da7575">setThreadContext</a>(_cpuId, 0); <span class="comment">// Add thread ID here too</span>
<a name="l00103"></a>00103     <a class="code" href="classAtomicSimpleCPU.html#af2cc98a9d486d932d85c4513a4670ca8">data_write_req</a>.<a class="code" href="classRequest.html#a40574dadf22fb92b4966eb9815da7575">setThreadContext</a>(_cpuId, 0); <span class="comment">// Add thread ID here too</span>
<a name="l00104"></a>00104 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac166e5bc3ddf730beb1282cf821096ae"></a><!-- doxytag: member="AtomicSimpleCPU::isDrained" ref="ac166e5bc3ddf730beb1282cf821096ae" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isDrained </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classCheck.html">Check</a> if a system is in a drained state.</p>
<p>We need to drain if: </p>
<ul>
<li>
<p class="startli">We are in the middle of a microcode sequence as some CPUs (e.g., HW accelerated CPUs) can't be started in the middle of a gem5 microcode sequence.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The CPU is in a LLSC region. This shouldn't normally happen as these are executed atomically within a single <a class="el" href="classAtomicSimpleCPU.html#a873dd91783f9efb4a590aded1f70d6b0">tick()</a> call. The only way this can happen at the moment is if there is an event in the PC event queue that affects the CPU state while it is in an LLSC region.</p>
<p class="endli"></p>
</li>
<li>
Stay at PC is true. </li>
</ul>

<p><div class="fragment"><pre class="fragment"><a name="l00126"></a>00126                      {
<a name="l00127"></a>00127         <span class="keywordflow">return</span> <a class="code" href="classBaseSimpleCPU.html#a1a21696f33a7d38f251687ae0b5e9718">microPC</a>() == 0 &amp;&amp;
<a name="l00128"></a>00128             !<a class="code" href="classAtomicSimpleCPU.html#a18a0f1e6c3d21c252b14ea6ae162e2ff">locked</a> &amp;&amp;
<a name="l00129"></a>00129             !<a class="code" href="classBaseSimpleCPU.html#ae91a837c03d66c9c15de3da2fc76e811">stayAtPC</a>;
<a name="l00130"></a>00130     }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a88aa41e2693dd0091afae2604eba9bed"></a><!-- doxytag: member="AtomicSimpleCPU::printAddr" ref="a88aa41e2693dd0091afae2604eba9bed" args="(Addr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void printAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Print state of address in memory system via PrintReq (for debugging). </p>

<p><div class="fragment"><pre class="fragment"><a name="l00636"></a>00636 {
<a name="l00637"></a>00637     <a class="code" href="classAtomicSimpleCPU.html#ab6b7665b418b12dc80b485e66d23ed19">dcachePort</a>.<a class="code" href="classMasterPort.html#a88aa41e2693dd0091afae2604eba9bed">printAddr</a>(<a class="code" href="namespaceArmISA.html#a468da4d7330577ee8746df2acfa40959">a</a>);
<a name="l00638"></a>00638 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa51e4d7f169cd8e8b2e144fdcfd36f33"></a><!-- doxytag: member="AtomicSimpleCPU::profileSimPoint" ref="aa51e4d7f169cd8e8b2e144fdcfd36f33" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void profileSimPoint </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Profile basic blocks for SimPoints. Called at every macro inst to increment basic block inst counts and to profile block if end of block. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00642"></a>00642 {
<a name="l00643"></a>00643     <span class="keywordflow">if</span> (!<a class="code" href="classAtomicSimpleCPU.html#a375bb98c835fcacb306ec154ac3c7f85">currentBBVInstCount</a>)
<a name="l00644"></a>00644         <a class="code" href="classAtomicSimpleCPU.html#aa13454a445c3711abe528bdd288a953c">currentBBV</a>.first = <a class="code" href="classBaseSimpleCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a827fb3454585cf4c620f4fd341966317">pcState</a>().instAddr();
<a name="l00645"></a>00645 
<a name="l00646"></a>00646     ++<a class="code" href="classAtomicSimpleCPU.html#a4ba2ebd08d9a7f8efe072ed006f2ba56">intervalCount</a>;
<a name="l00647"></a>00647     ++<a class="code" href="classAtomicSimpleCPU.html#a375bb98c835fcacb306ec154ac3c7f85">currentBBVInstCount</a>;
<a name="l00648"></a>00648 
<a name="l00649"></a>00649     <span class="comment">// If inst is control inst, assume end of basic block.</span>
<a name="l00650"></a>00650     <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#abd80e0d70258dae9a743c9930a385163">curStaticInst</a>-&gt;isControl()) {
<a name="l00651"></a>00651         <a class="code" href="classAtomicSimpleCPU.html#aa13454a445c3711abe528bdd288a953c">currentBBV</a>.second = <a class="code" href="classBaseSimpleCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a827fb3454585cf4c620f4fd341966317">pcState</a>().instAddr();
<a name="l00652"></a>00652 
<a name="l00653"></a>00653         <span class="keyword">auto</span> map_itr = <a class="code" href="classAtomicSimpleCPU.html#a06bfab070d35f298897393f7ee6e066c">bbMap</a>.find(<a class="code" href="classAtomicSimpleCPU.html#aa13454a445c3711abe528bdd288a953c">currentBBV</a>);
<a name="l00654"></a>00654         <span class="keywordflow">if</span> (map_itr == <a class="code" href="classAtomicSimpleCPU.html#a06bfab070d35f298897393f7ee6e066c">bbMap</a>.end()){
<a name="l00655"></a>00655             <span class="comment">// If a new (previously unseen) basic block is found,</span>
<a name="l00656"></a>00656             <span class="comment">// add a new unique id, record num of insts and insert into bbMap.</span>
<a name="l00657"></a>00657             BBInfo info;
<a name="l00658"></a>00658             info.id = <a class="code" href="classAtomicSimpleCPU.html#a06bfab070d35f298897393f7ee6e066c">bbMap</a>.size() + 1;
<a name="l00659"></a>00659             info.insts = <a class="code" href="classAtomicSimpleCPU.html#a375bb98c835fcacb306ec154ac3c7f85">currentBBVInstCount</a>;
<a name="l00660"></a>00660             info.count = <a class="code" href="classAtomicSimpleCPU.html#a375bb98c835fcacb306ec154ac3c7f85">currentBBVInstCount</a>;
<a name="l00661"></a>00661             <a class="code" href="classAtomicSimpleCPU.html#a06bfab070d35f298897393f7ee6e066c">bbMap</a>.insert(std::make_pair(<a class="code" href="classAtomicSimpleCPU.html#aa13454a445c3711abe528bdd288a953c">currentBBV</a>, info));
<a name="l00662"></a>00662         } <span class="keywordflow">else</span> {
<a name="l00663"></a>00663             <span class="comment">// If basic block is seen before, just increment the count by the</span>
<a name="l00664"></a>00664             <span class="comment">// number of insts in basic block.</span>
<a name="l00665"></a>00665             BBInfo&amp; info = map_itr-&gt;second;
<a name="l00666"></a>00666             info.count += <a class="code" href="classAtomicSimpleCPU.html#a375bb98c835fcacb306ec154ac3c7f85">currentBBVInstCount</a>;
<a name="l00667"></a>00667         }
<a name="l00668"></a>00668         <a class="code" href="classAtomicSimpleCPU.html#a375bb98c835fcacb306ec154ac3c7f85">currentBBVInstCount</a> = 0;
<a name="l00669"></a>00669 
<a name="l00670"></a>00670         <span class="comment">// Reached end of interval if the sum of the current inst count</span>
<a name="l00671"></a>00671         <span class="comment">// (intervalCount) and the excessive inst count from the previous</span>
<a name="l00672"></a>00672         <span class="comment">// interval (intervalDrift) is greater than/equal to the interval size.</span>
<a name="l00673"></a>00673         <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#a4ba2ebd08d9a7f8efe072ed006f2ba56">intervalCount</a> + <a class="code" href="classAtomicSimpleCPU.html#a0c93f234d5028e73f388f7e730db728f">intervalDrift</a> &gt;= <a class="code" href="classAtomicSimpleCPU.html#afa2df438a2925349299948892f519ea2">intervalSize</a>) {
<a name="l00674"></a>00674             <span class="comment">// summarize interval and display BBV info</span>
<a name="l00675"></a>00675             <a class="code" href="classstd_1_1vector.html">std::vector&lt;pair&lt;uint64_t, uint64_t&gt;</a> &gt; counts;
<a name="l00676"></a>00676             <span class="keywordflow">for</span> (<span class="keyword">auto</span> map_itr = <a class="code" href="classAtomicSimpleCPU.html#a06bfab070d35f298897393f7ee6e066c">bbMap</a>.begin(); map_itr != <a class="code" href="classAtomicSimpleCPU.html#a06bfab070d35f298897393f7ee6e066c">bbMap</a>.end();
<a name="l00677"></a>00677                     ++map_itr) {
<a name="l00678"></a>00678                 BBInfo&amp; info = map_itr-&gt;second;
<a name="l00679"></a>00679                 <span class="keywordflow">if</span> (info.count != 0) {
<a name="l00680"></a>00680                     counts.push_back(std::make_pair(info.id, info.count));
<a name="l00681"></a>00681                     info.count = 0;
<a name="l00682"></a>00682                 }
<a name="l00683"></a>00683             }
<a name="l00684"></a>00684             std::sort(counts.begin(), counts.end());
<a name="l00685"></a>00685 
<a name="l00686"></a>00686             <span class="comment">// Print output BBV info</span>
<a name="l00687"></a>00687             *<a class="code" href="classAtomicSimpleCPU.html#a77497fabc62f774e824e9b57974e0301">simpointStream</a> &lt;&lt; <span class="stringliteral">&quot;T&quot;</span>;
<a name="l00688"></a>00688             <span class="keywordflow">for</span> (<span class="keyword">auto</span> cnt_itr = counts.begin(); cnt_itr != counts.end();
<a name="l00689"></a>00689                     ++cnt_itr) {
<a name="l00690"></a>00690                 *simpointStream &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; cnt_itr-&gt;first
<a name="l00691"></a>00691                                 &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; cnt_itr-&gt;second &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00692"></a>00692             }
<a name="l00693"></a>00693             *simpointStream &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00694"></a>00694 
<a name="l00695"></a>00695             <a class="code" href="classAtomicSimpleCPU.html#a0c93f234d5028e73f388f7e730db728f">intervalDrift</a> = (<a class="code" href="classAtomicSimpleCPU.html#a4ba2ebd08d9a7f8efe072ed006f2ba56">intervalCount</a> + <a class="code" href="classAtomicSimpleCPU.html#a0c93f234d5028e73f388f7e730db728f">intervalDrift</a>) - <a class="code" href="classAtomicSimpleCPU.html#afa2df438a2925349299948892f519ea2">intervalSize</a>;
<a name="l00696"></a>00696             <a class="code" href="classAtomicSimpleCPU.html#a4ba2ebd08d9a7f8efe072ed006f2ba56">intervalCount</a> = 0;
<a name="l00697"></a>00697         }
<a name="l00698"></a>00698     }
<a name="l00699"></a>00699 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a66191b2d8a45050b7df3c3efa7bb07c6"></a><!-- doxytag: member="AtomicSimpleCPU::readMem" ref="a66191b2d8a45050b7df3c3efa7bb07c6" args="(Addr addr, uint8_t *data, unsigned size, unsigned flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRefCountingPtr.html">Fault</a> readMem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00314"></a>00314 {
<a name="l00315"></a>00315     <span class="comment">// use the CPU&apos;s statically allocated read request and packet objects</span>
<a name="l00316"></a>00316     <a class="code" href="classRequest.html">Request</a> *req = &amp;<a class="code" href="classAtomicSimpleCPU.html#a836513db061d14f39d79751c40fa9951">data_read_req</a>;
<a name="l00317"></a>00317 
<a name="l00318"></a>00318     <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#acbcf6d90551f8d3a598a70caae74d1ef">traceData</a>) {
<a name="l00319"></a>00319         <a class="code" href="classBaseSimpleCPU.html#acbcf6d90551f8d3a598a70caae74d1ef">traceData</a>-&gt;<a class="code" href="classTrace_1_1InstRecord.html#a0086c298c7423d3f7e571e9f63a1c09f">setAddr</a>(<a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a>);
<a name="l00320"></a>00320     }
<a name="l00321"></a>00321 
<a name="l00322"></a>00322     <span class="comment">//The size of the data we&apos;re trying to read.</span>
<a name="l00323"></a>00323     <span class="keywordtype">int</span> fullSize = size;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325     <span class="comment">//The address of the second part of this access if it needs to be split</span>
<a name="l00326"></a>00326     <span class="comment">//across a cache line boundary.</span>
<a name="l00327"></a>00327     <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> secondAddr = <a class="code" href="intmath_8hh.html#a343c19b0ae885d5f3c7960987096e9d5">roundDown</a>(<a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a> + size - 1, cacheLineSize());
<a name="l00328"></a>00328 
<a name="l00329"></a>00329     <span class="keywordflow">if</span> (secondAddr &gt; <a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a>)
<a name="l00330"></a>00330         size = secondAddr - <a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a>;
<a name="l00331"></a>00331 
<a name="l00332"></a>00332     <a class="code" href="classAtomicSimpleCPU.html#a08f04a43a6d731e966308aaeece77208">dcache_latency</a> = 0;
<a name="l00333"></a>00333 
<a name="l00334"></a>00334     req-&gt;<a class="code" href="classRequest.html#a7abf15d67b3fbd53236fde58eecb3f34">taskId</a>(taskId());
<a name="l00335"></a>00335     <span class="keywordflow">while</span> (1) {
<a name="l00336"></a>00336         req-&gt;<a class="code" href="classRequest.html#a63cbf386080363fe7c7b364bb2fe3b3e">setVirt</a>(0, addr, size, <a class="code" href="namespacem5_1_1debug.html#a9ceb38153d5c0f156fbeada6dc00ff4f">flags</a>, dataMasterId(), <a class="code" href="classBaseSimpleCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a827fb3454585cf4c620f4fd341966317">pcState</a>().instAddr());
<a name="l00337"></a>00337 
<a name="l00338"></a>00338         <span class="comment">// translate to physical address</span>
<a name="l00339"></a>00339         <a class="code" href="classRefCountingPtr.html">Fault</a> fault = <a class="code" href="classBaseSimpleCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#ad2fd039621f87592c4b344d4f8948e78">dtb</a>-&gt;translateAtomic(req, <a class="code" href="classBaseSimpleCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>, <a class="code" href="classBaseTLB.html#a46c8a310cf4c094f8c80e1cb8dc1f911a809abe96853e69894bbf8e5730b31348">BaseTLB::Read</a>);
<a name="l00340"></a>00340 
<a name="l00341"></a>00341         <span class="comment">// Now do the access.</span>
<a name="l00342"></a>00342         <span class="keywordflow">if</span> (fault == <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a> &amp;&amp; !req-&gt;<a class="code" href="classRequest.html#a8552aa8d45c9ba10449d51ac08e7d490">getFlags</a>().<a class="code" href="classFlags.html#ac976964169b81aaba1d4cbb422f559ca">isSet</a>(<a class="code" href="classRequest.html#ab305c2952b5ae966870f325f2bef006c">Request::NO_ACCESS</a>)) {
<a name="l00343"></a>00343             <a class="code" href="classPacket.html">Packet</a> pkt = <a class="code" href="classPacket.html">Packet</a>(req,
<a name="l00344"></a>00344                                 req-&gt;<a class="code" href="classRequest.html#a8965874e960faf91ad4b6af8dbf31875">isLLSC</a>() ? <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a1c703221ee751b9d3d635fe33ea8e350">MemCmd::LoadLockedReq</a> :
<a name="l00345"></a>00345                                 <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a96120c772a9cb695fe62ca81ec93a53b">MemCmd::ReadReq</a>);
<a name="l00346"></a>00346 
<a name="l00347"></a>00347             <span class="comment">//@@@copy ?</span>
<a name="l00348"></a>00348             pkt.<a class="code" href="classPacket.html#a60621b00d6ecd49b3e336087aca2eda0">dataStatic</a>(data);
<a name="l00349"></a>00349 
<a name="l00350"></a>00350             <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#aad621c262e009350dd86ad5715c50f7a">isMmappedIpr</a>())
<a name="l00351"></a>00351                 <a class="code" href="classAtomicSimpleCPU.html#a08f04a43a6d731e966308aaeece77208">dcache_latency</a> += <a class="code" href="namespaceGenericISA.html#a0b95fcdc1e1fe57dbb4fcad449a6efd8">TheISA::handleIprRead</a>(<a class="code" href="classBaseSimpleCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a81894d15db5190d5364449a4915b76f5">getTC</a>(), &amp;pkt);
<a name="l00352"></a>00352             <span class="keywordflow">else</span> {
<a name="l00353"></a>00353                 <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#a66f9c88f6fa05c882787a7e98a7101f5">fastmem</a> &amp;&amp; <a class="code" href="classBaseCPU.html#ab737471139f5a296e5b26e8a0e1b0744" title="initialize section">system</a>-&gt;isMemAddr(pkt.<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>()))
<a name="l00354"></a>00354                     <a class="code" href="classBaseCPU.html#ab737471139f5a296e5b26e8a0e1b0744" title="initialize section">system</a>-&gt;getPhysMem().access(&amp;pkt);
<a name="l00355"></a>00355                 <span class="keywordflow">else</span>
<a name="l00356"></a>00356                     <a class="code" href="classAtomicSimpleCPU.html#a08f04a43a6d731e966308aaeece77208">dcache_latency</a> += <a class="code" href="classAtomicSimpleCPU.html#ab6b7665b418b12dc80b485e66d23ed19">dcachePort</a>.<a class="code" href="classMasterPort.html#a49fe5ebde5a0349bff76527b969b7643">sendAtomic</a>(&amp;pkt);
<a name="l00357"></a>00357             }
<a name="l00358"></a>00358             <a class="code" href="classAtomicSimpleCPU.html#a40a30a05f8e2b8b4c62c0ee0a019686a">dcache_access</a> = <span class="keyword">true</span>;
<a name="l00359"></a>00359 
<a name="l00360"></a>00360             assert(!pkt.<a class="code" href="classPacket.html#a32759931a1b2d6380407c6a18abd46e3">isError</a>());
<a name="l00361"></a>00361 
<a name="l00362"></a>00362             <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#a8965874e960faf91ad4b6af8dbf31875">isLLSC</a>()) {
<a name="l00363"></a>00363                 <a class="code" href="namespaceAlphaISA.html#a00333a272d42606a01cc33c81999a58b">TheISA::handleLockedRead</a>(<a class="code" href="classBaseSimpleCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>, req);
<a name="l00364"></a>00364             }
<a name="l00365"></a>00365         }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367         <span class="comment">//If there&apos;s a fault, return it</span>
<a name="l00368"></a>00368         <span class="keywordflow">if</span> (fault != <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>) {
<a name="l00369"></a>00369             <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#a1eef1bb814a1f77346aba1648fb6d1c9">isPrefetch</a>()) {
<a name="l00370"></a>00370                 <span class="keywordflow">return</span> <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>;
<a name="l00371"></a>00371             } <span class="keywordflow">else</span> {
<a name="l00372"></a>00372                 <span class="keywordflow">return</span> fault;
<a name="l00373"></a>00373             }
<a name="l00374"></a>00374         }
<a name="l00375"></a>00375 
<a name="l00376"></a>00376         <span class="comment">//If we don&apos;t need to access a second cache line, stop now.</span>
<a name="l00377"></a>00377         <span class="keywordflow">if</span> (secondAddr &lt;= addr)
<a name="l00378"></a>00378         {
<a name="l00379"></a>00379             <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#ae0c9fa9daf2467984aea571a0f3940c6">isLocked</a>() &amp;&amp; fault == <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>) {
<a name="l00380"></a>00380                 assert(!<a class="code" href="classAtomicSimpleCPU.html#a18a0f1e6c3d21c252b14ea6ae162e2ff">locked</a>);
<a name="l00381"></a>00381                 <a class="code" href="classAtomicSimpleCPU.html#a18a0f1e6c3d21c252b14ea6ae162e2ff">locked</a> = <span class="keyword">true</span>;
<a name="l00382"></a>00382             }
<a name="l00383"></a>00383             <span class="keywordflow">return</span> fault;
<a name="l00384"></a>00384         }
<a name="l00385"></a>00385 
<a name="l00386"></a>00386         <span class="comment">/*</span>
<a name="l00387"></a>00387 <span class="comment">         * Set up for accessing the second cache line.</span>
<a name="l00388"></a>00388 <span class="comment">         */</span>
<a name="l00389"></a>00389 
<a name="l00390"></a>00390         <span class="comment">//Move the pointer we&apos;re reading into to the correct location.</span>
<a name="l00391"></a>00391         data += size;
<a name="l00392"></a>00392         <span class="comment">//Adjust the size to get the remaining bytes.</span>
<a name="l00393"></a>00393         size = addr + fullSize - secondAddr;
<a name="l00394"></a>00394         <span class="comment">//And access the right address.</span>
<a name="l00395"></a>00395         addr = secondAddr;
<a name="l00396"></a>00396     }
<a name="l00397"></a>00397 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1dad4c4d2c3df4ef367e14fcc973ce74"></a><!-- doxytag: member="AtomicSimpleCPU::suspendContext" ref="a1dad4c4d2c3df4ef367e14fcc973ce74" args="(ThreadID thread_num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void suspendContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b">ThreadID</a>&nbsp;</td>
          <td class="paramname"> <em>thread_num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00260"></a>00260 {
<a name="l00261"></a>00261     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(SimpleCPU, <span class="stringliteral">&quot;SuspendContext %d\n&quot;</span>, thread_num);
<a name="l00262"></a>00262 
<a name="l00263"></a>00263     assert(thread_num == 0);
<a name="l00264"></a>00264     assert(<a class="code" href="classBaseSimpleCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>);
<a name="l00265"></a>00265 
<a name="l00266"></a>00266     <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> == <a class="code" href="classBaseSimpleCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>)
<a name="l00267"></a>00267         <span class="keywordflow">return</span>;
<a name="l00268"></a>00268 
<a name="l00269"></a>00269     assert(<a class="code" href="classBaseSimpleCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> == <a class="code" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8a2f5f2c4a8c4f4f0519d503dcdfbf55cb">BaseSimpleCPU::Running</a>);
<a name="l00270"></a>00270 
<a name="l00271"></a>00271     <span class="comment">// tick event may not be scheduled if this gets called from inside</span>
<a name="l00272"></a>00272     <span class="comment">// an instruction&apos;s execution, e.g. &quot;quiesce&quot;</span>
<a name="l00273"></a>00273     <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>.<a class="code" href="classEvent.html#a9cd69a6b10cb037550943f177a0da688" title="Determine if the current event is scheduled.">scheduled</a>())
<a name="l00274"></a>00274         deschedule(<a class="code" href="classAtomicSimpleCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>);
<a name="l00275"></a>00275 
<a name="l00276"></a>00276     <a class="code" href="classBaseSimpleCPU.html#a40be38a691cf502b6ba46aaefd86dc77">notIdleFraction</a> = 0;
<a name="l00277"></a>00277     <a class="code" href="classBaseSimpleCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> = <a class="code" href="classBaseSimpleCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>;
<a name="l00278"></a>00278 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a05f299b443f8cc73a93d61572edc0218"></a><!-- doxytag: member="AtomicSimpleCPU::switchOut" ref="a05f299b443f8cc73a93d61572edc0218" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void switchOut </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00207"></a>00207 {
<a name="l00208"></a>00208     <a class="code" href="classAtomicSimpleCPU.html#a05f299b443f8cc73a93d61572edc0218">BaseSimpleCPU::switchOut</a>();
<a name="l00209"></a>00209 
<a name="l00210"></a>00210     assert(!<a class="code" href="classAtomicSimpleCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>.<a class="code" href="classEvent.html#a9cd69a6b10cb037550943f177a0da688" title="Determine if the current event is scheduled.">scheduled</a>());
<a name="l00211"></a>00211     assert(<a class="code" href="classBaseSimpleCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> == <a class="code" href="classDrainable.html#a5d74787dedbc4e11c1ab15bf487e61f8a2f5f2c4a8c4f4f0519d503dcdfbf55cb">BaseSimpleCPU::Running</a> || <a class="code" href="classBaseSimpleCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> == <a class="code" href="classBaseSimpleCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>);
<a name="l00212"></a>00212     assert(<a class="code" href="classAtomicSimpleCPU.html#ac166e5bc3ddf730beb1282cf821096ae">isDrained</a>());
<a name="l00213"></a>00213 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac82d2b8d331b2e8e6854a95d2917dfa2"></a><!-- doxytag: member="AtomicSimpleCPU::takeOverFrom" ref="ac82d2b8d331b2e8e6854a95d2917dfa2" args="(BaseCPU *oldCPU)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void takeOverFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBaseCPU_1_1BaseCPU.html">BaseCPU</a> *&nbsp;</td>
          <td class="paramname"> <em>oldCPU</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00218"></a>00218 {
<a name="l00219"></a>00219     <a class="code" href="classBaseCPU_1_1BaseCPU.html#ab5272c636861eb61b25aa639a46cfb77">BaseSimpleCPU::takeOverFrom</a>(oldCPU);
<a name="l00220"></a>00220 
<a name="l00221"></a>00221     <span class="comment">// The tick event should have been descheduled by drain()</span>
<a name="l00222"></a>00222     assert(!<a class="code" href="classAtomicSimpleCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>.<a class="code" href="classEvent.html#a9cd69a6b10cb037550943f177a0da688" title="Determine if the current event is scheduled.">scheduled</a>());
<a name="l00223"></a>00223 
<a name="l00224"></a>00224     <a class="code" href="classAtomicSimpleCPU.html#a64ba0dde58d6c2c1c5e24a0b3e3b506f">ifetch_req</a>.<a class="code" href="classRequest.html#a40574dadf22fb92b4966eb9815da7575">setThreadContext</a>(_cpuId, 0); <span class="comment">// Add thread ID if we add MT</span>
<a name="l00225"></a>00225     <a class="code" href="classAtomicSimpleCPU.html#a836513db061d14f39d79751c40fa9951">data_read_req</a>.<a class="code" href="classRequest.html#a40574dadf22fb92b4966eb9815da7575">setThreadContext</a>(_cpuId, 0); <span class="comment">// Add thread ID here too</span>
<a name="l00226"></a>00226     <a class="code" href="classAtomicSimpleCPU.html#af2cc98a9d486d932d85c4513a4670ca8">data_write_req</a>.<a class="code" href="classRequest.html#a40574dadf22fb92b4966eb9815da7575">setThreadContext</a>(_cpuId, 0); <span class="comment">// Add thread ID here too</span>
<a name="l00227"></a>00227 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a873dd91783f9efb4a590aded1f70d6b0"></a><!-- doxytag: member="AtomicSimpleCPU::tick" ref="a873dd91783f9efb4a590aded1f70d6b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tick </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00514"></a>00514 {
<a name="l00515"></a>00515     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(SimpleCPU, <span class="stringliteral">&quot;Tick\n&quot;</span>);
<a name="l00516"></a>00516 
<a name="l00517"></a>00517     <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> latency = 0;
<a name="l00518"></a>00518 
<a name="l00519"></a>00519     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> = 0; <a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a> &lt; <a class="code" href="classAtomicSimpleCPU.html#a837aabdd54757cb86d0f66387511753f">width</a> || <a class="code" href="classAtomicSimpleCPU.html#a18a0f1e6c3d21c252b14ea6ae162e2ff">locked</a>; ++<a class="code" href="namespaceArmISA.html#aca8175497376fbb9f0e71fefa122cef7">i</a>) {
<a name="l00520"></a>00520         numCycles++;
<a name="l00521"></a>00521 
<a name="l00522"></a>00522         <span class="keywordflow">if</span> (!<a class="code" href="classBaseSimpleCPU.html#abd80e0d70258dae9a743c9930a385163">curStaticInst</a> || !<a class="code" href="classBaseSimpleCPU.html#abd80e0d70258dae9a743c9930a385163">curStaticInst</a>-&gt;isDelayedCommit())
<a name="l00523"></a>00523             <a class="code" href="classBaseSimpleCPU.html#afc6b0526014df091373ec2c850508a55">checkForInterrupts</a>();
<a name="l00524"></a>00524 
<a name="l00525"></a>00525         <a class="code" href="classBaseSimpleCPU.html#a925a66fd31bbc43fa4bc4a90d5b316cb">checkPcEventQueue</a>();
<a name="l00526"></a>00526         <span class="comment">// We must have just got suspended by a PC event</span>
<a name="l00527"></a>00527         <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> == <a class="code" href="classBaseSimpleCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>) {
<a name="l00528"></a>00528             <a class="code" href="classAtomicSimpleCPU.html#abfea8f75a7a7480716801affeebbe87b">tryCompleteDrain</a>();
<a name="l00529"></a>00529             <span class="keywordflow">return</span>;
<a name="l00530"></a>00530         }
<a name="l00531"></a>00531 
<a name="l00532"></a>00532         <a class="code" href="classRefCountingPtr.html">Fault</a> fault = <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>;
<a name="l00533"></a>00533 
<a name="l00534"></a>00534         <a class="code" href="namespaceAlphaISA.html#af780de49982ecf691215cac9b9dfc615">TheISA::PCState</a> <a class="code" href="classBaseSimpleCPU.html#a827fb3454585cf4c620f4fd341966317">pcState</a> = <a class="code" href="classBaseSimpleCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a827fb3454585cf4c620f4fd341966317">pcState</a>();
<a name="l00535"></a>00535 
<a name="l00536"></a>00536         <span class="keywordtype">bool</span> needToFetch = !<a class="code" href="base_2types_8hh.html#a01ec7071d9749218cc83949b3f93cd9b">isRomMicroPC</a>(pcState.microPC()) &amp;&amp;
<a name="l00537"></a>00537                            !<a class="code" href="classBaseSimpleCPU.html#a52d6d2514fb5ccecad4788d57738f544">curMacroStaticInst</a>;
<a name="l00538"></a>00538         <span class="keywordflow">if</span> (needToFetch) {
<a name="l00539"></a>00539             <a class="code" href="classAtomicSimpleCPU.html#a64ba0dde58d6c2c1c5e24a0b3e3b506f">ifetch_req</a>.<a class="code" href="classRequest.html#a7abf15d67b3fbd53236fde58eecb3f34">taskId</a>(taskId());
<a name="l00540"></a>00540             <a class="code" href="classBaseSimpleCPU.html#a06bcbb6a9e9cbcf60796a0843cdf9a35">setupFetchRequest</a>(&amp;<a class="code" href="classAtomicSimpleCPU.html#a64ba0dde58d6c2c1c5e24a0b3e3b506f">ifetch_req</a>);
<a name="l00541"></a>00541             fault = <a class="code" href="classBaseSimpleCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#abcb37ddc11515555d8484702697bc4bb">itb</a>-&gt;translateAtomic(&amp;<a class="code" href="classAtomicSimpleCPU.html#a64ba0dde58d6c2c1c5e24a0b3e3b506f">ifetch_req</a>, <a class="code" href="classBaseSimpleCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>,
<a name="l00542"></a>00542                                                  <a class="code" href="classBaseTLB.html#a46c8a310cf4c094f8c80e1cb8dc1f911a31b7313c05d32519f3869a3de8be95e6">BaseTLB::Execute</a>);
<a name="l00543"></a>00543         }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545         <span class="keywordflow">if</span> (fault == <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>) {
<a name="l00546"></a>00546             <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> icache_latency = 0;
<a name="l00547"></a>00547             <span class="keywordtype">bool</span> icache_access = <span class="keyword">false</span>;
<a name="l00548"></a>00548             <a class="code" href="classAtomicSimpleCPU.html#a40a30a05f8e2b8b4c62c0ee0a019686a">dcache_access</a> = <span class="keyword">false</span>; <span class="comment">// assume no dcache access</span>
<a name="l00549"></a>00549 
<a name="l00550"></a>00550             <span class="keywordflow">if</span> (needToFetch) {
<a name="l00551"></a>00551                 <span class="comment">// This is commented out because the decoder would act like</span>
<a name="l00552"></a>00552                 <span class="comment">// a tiny cache otherwise. It wouldn&apos;t be flushed when needed</span>
<a name="l00553"></a>00553                 <span class="comment">// like the I cache. It should be flushed, and when that works</span>
<a name="l00554"></a>00554                 <span class="comment">// this code should be uncommented.</span>
<a name="l00555"></a>00555                 <span class="comment">//Fetch more instruction memory if necessary</span>
<a name="l00556"></a>00556                 <span class="comment">//if(decoder.needMoreBytes())</span>
<a name="l00557"></a>00557                 <span class="comment">//{</span>
<a name="l00558"></a>00558                     icache_access = <span class="keyword">true</span>;
<a name="l00559"></a>00559                     <a class="code" href="classPacket.html">Packet</a> ifetch_pkt = <a class="code" href="classPacket.html">Packet</a>(&amp;<a class="code" href="classAtomicSimpleCPU.html#a64ba0dde58d6c2c1c5e24a0b3e3b506f">ifetch_req</a>, <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a96120c772a9cb695fe62ca81ec93a53b">MemCmd::ReadReq</a>);
<a name="l00560"></a>00560                     ifetch_pkt.<a class="code" href="classPacket.html#a60621b00d6ecd49b3e336087aca2eda0">dataStatic</a>(&amp;<a class="code" href="classBaseSimpleCPU.html#a3fb19fcd9c09cfac7357af074b301868">inst</a>);
<a name="l00561"></a>00561 
<a name="l00562"></a>00562                     <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#a66f9c88f6fa05c882787a7e98a7101f5">fastmem</a> &amp;&amp; <a class="code" href="classBaseCPU.html#ab737471139f5a296e5b26e8a0e1b0744" title="initialize section">system</a>-&gt;isMemAddr(ifetch_pkt.<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>()))
<a name="l00563"></a>00563                         <a class="code" href="classBaseCPU.html#ab737471139f5a296e5b26e8a0e1b0744" title="initialize section">system</a>-&gt;getPhysMem().access(&amp;ifetch_pkt);
<a name="l00564"></a>00564                     <span class="keywordflow">else</span>
<a name="l00565"></a>00565                         icache_latency = <a class="code" href="classAtomicSimpleCPU.html#a35e511691227100effd63e8a7fc12989">icachePort</a>.<a class="code" href="classMasterPort.html#a49fe5ebde5a0349bff76527b969b7643">sendAtomic</a>(&amp;ifetch_pkt);
<a name="l00566"></a>00566 
<a name="l00567"></a>00567                     assert(!ifetch_pkt.<a class="code" href="classPacket.html#a32759931a1b2d6380407c6a18abd46e3">isError</a>());
<a name="l00568"></a>00568 
<a name="l00569"></a>00569                     <span class="comment">// ifetch_req is initialized to read the instruction directly</span>
<a name="l00570"></a>00570                     <span class="comment">// into the CPU object&apos;s inst field.</span>
<a name="l00571"></a>00571                 <span class="comment">//}</span>
<a name="l00572"></a>00572             }
<a name="l00573"></a>00573 
<a name="l00574"></a>00574             <a class="code" href="classBaseSimpleCPU.html#ad341f256f4b26b20980f548e42ea79c4">preExecute</a>();
<a name="l00575"></a>00575 
<a name="l00576"></a>00576             <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#abd80e0d70258dae9a743c9930a385163">curStaticInst</a>) {
<a name="l00577"></a>00577                 fault = <a class="code" href="classBaseSimpleCPU.html#abd80e0d70258dae9a743c9930a385163">curStaticInst</a>-&gt;execute(<span class="keyword">this</span>, <a class="code" href="classBaseSimpleCPU.html#acbcf6d90551f8d3a598a70caae74d1ef">traceData</a>);
<a name="l00578"></a>00578 
<a name="l00579"></a>00579                 <span class="comment">// keep an instruction count</span>
<a name="l00580"></a>00580                 <span class="keywordflow">if</span> (fault == <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>)
<a name="l00581"></a>00581                     <a class="code" href="classBaseSimpleCPU.html#ae14e8c918d9e0fa1f09581af157369e2">countInst</a>();
<a name="l00582"></a>00582                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#acbcf6d90551f8d3a598a70caae74d1ef">traceData</a> &amp;&amp; !<a class="code" href="trace_8hh.html#af76c9f7776aade1bf9d7dfa8a0c6b341">DTRACE</a>(ExecFaulting)) {
<a name="l00583"></a>00583                     <span class="keyword">delete</span> <a class="code" href="classBaseSimpleCPU.html#acbcf6d90551f8d3a598a70caae74d1ef">traceData</a>;
<a name="l00584"></a>00584                     <a class="code" href="classBaseSimpleCPU.html#acbcf6d90551f8d3a598a70caae74d1ef">traceData</a> = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00585"></a>00585                 }
<a name="l00586"></a>00586 
<a name="l00587"></a>00587                 <a class="code" href="classBaseSimpleCPU.html#a86cfcf0bbf35e6f79ccf03bd9436f633">postExecute</a>();
<a name="l00588"></a>00588             }
<a name="l00589"></a>00589 
<a name="l00590"></a>00590             <span class="comment">// @todo remove me after debugging with legion done</span>
<a name="l00591"></a>00591             <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#abd80e0d70258dae9a743c9930a385163">curStaticInst</a> &amp;&amp; (!<a class="code" href="classBaseSimpleCPU.html#abd80e0d70258dae9a743c9930a385163">curStaticInst</a>-&gt;isMicroop() ||
<a name="l00592"></a>00592                         <a class="code" href="classBaseSimpleCPU.html#abd80e0d70258dae9a743c9930a385163">curStaticInst</a>-&gt;isFirstMicroop()))
<a name="l00593"></a>00593                 instCnt++;
<a name="l00594"></a>00594 
<a name="l00595"></a>00595             <span class="comment">// profile for SimPoints if enabled and macro inst is finished</span>
<a name="l00596"></a>00596             <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#a556c6eb1f8f869ee7d0802381701c49f">simpoint</a> &amp;&amp; <a class="code" href="classBaseSimpleCPU.html#abd80e0d70258dae9a743c9930a385163">curStaticInst</a> &amp;&amp; (fault == <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>) &amp;&amp;
<a name="l00597"></a>00597                     (!<a class="code" href="classBaseSimpleCPU.html#abd80e0d70258dae9a743c9930a385163">curStaticInst</a>-&gt;isMicroop() ||
<a name="l00598"></a>00598                      <a class="code" href="classBaseSimpleCPU.html#abd80e0d70258dae9a743c9930a385163">curStaticInst</a>-&gt;isLastMicroop())) {
<a name="l00599"></a>00599                 <a class="code" href="classAtomicSimpleCPU.html#aa51e4d7f169cd8e8b2e144fdcfd36f33">profileSimPoint</a>();
<a name="l00600"></a>00600             }
<a name="l00601"></a>00601 
<a name="l00602"></a>00602             <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> stall_ticks = 0;
<a name="l00603"></a>00603             <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#ac5ff523d495df7133594dec7894aacc7">simulate_inst_stalls</a> &amp;&amp; icache_access)
<a name="l00604"></a>00604                 stall_ticks += icache_latency;
<a name="l00605"></a>00605 
<a name="l00606"></a>00606             <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#aab46afe7eb154b233d2ba1886a4b399f">simulate_data_stalls</a> &amp;&amp; <a class="code" href="classAtomicSimpleCPU.html#a40a30a05f8e2b8b4c62c0ee0a019686a">dcache_access</a>)
<a name="l00607"></a>00607                 stall_ticks += <a class="code" href="classAtomicSimpleCPU.html#a08f04a43a6d731e966308aaeece77208">dcache_latency</a>;
<a name="l00608"></a>00608 
<a name="l00609"></a>00609             <span class="keywordflow">if</span> (stall_ticks) {
<a name="l00610"></a>00610                 <span class="comment">// the atomic cpu does its accounting in ticks, so</span>
<a name="l00611"></a>00611                 <span class="comment">// keep counting in ticks but round to the clock</span>
<a name="l00612"></a>00612                 <span class="comment">// period</span>
<a name="l00613"></a>00613                 latency += <a class="code" href="intmath_8hh.html#ae842b412d3570df97a944085b8f85850">divCeil</a>(stall_ticks, clockPeriod()) *
<a name="l00614"></a>00614                     clockPeriod();
<a name="l00615"></a>00615             }
<a name="l00616"></a>00616 
<a name="l00617"></a>00617         }
<a name="l00618"></a>00618         <span class="keywordflow">if</span>(fault != <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a> || !<a class="code" href="classBaseSimpleCPU.html#ae91a837c03d66c9c15de3da2fc76e811">stayAtPC</a>)
<a name="l00619"></a>00619             <a class="code" href="classBaseSimpleCPU.html#a9ff8fd374877c2ff6c10178aaad00852">advancePC</a>(fault);
<a name="l00620"></a>00620     }
<a name="l00621"></a>00621 
<a name="l00622"></a>00622     <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#abfea8f75a7a7480716801affeebbe87b">tryCompleteDrain</a>())
<a name="l00623"></a>00623         <span class="keywordflow">return</span>;
<a name="l00624"></a>00624 
<a name="l00625"></a>00625     <span class="comment">// instruction takes at least one cycle</span>
<a name="l00626"></a>00626     <span class="keywordflow">if</span> (latency &lt; clockPeriod())
<a name="l00627"></a>00627         latency = clockPeriod();
<a name="l00628"></a>00628 
<a name="l00629"></a>00629     <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#a6cdf6e6db875a442f3ab6db542bd2bb5">_status</a> != <a class="code" href="classBaseSimpleCPU.html#a67a0db04d321a74b7e7fcfd3f1a3f70bad3fa9ae9431d6cb1772f9d9df48cab19">Idle</a>)
<a name="l00630"></a>00630         schedule(<a class="code" href="classAtomicSimpleCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a>, <a class="code" href="statistics_8hh.html#a7acdccbf0d35ce0c159c0cdd36371b22" title="The universal simulation clock.">curTick</a>() + latency);
<a name="l00631"></a>00631 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abfea8f75a7a7480716801affeebbe87b"></a><!-- doxytag: member="AtomicSimpleCPU::tryCompleteDrain" ref="abfea8f75a7a7480716801affeebbe87b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tryCompleteDrain </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Try to complete a drain request.</p>
<dl class="return"><dt><b>戻り値:</b></dt><dd>true if the CPU is drained, false otherwise. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00189"></a>00189 {
<a name="l00190"></a>00190     <span class="keywordflow">if</span> (!<a class="code" href="classAtomicSimpleCPU.html#af9ba920f669cbe0f18c71846715d690a">drain_manager</a>)
<a name="l00191"></a>00191         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00192"></a>00192 
<a name="l00193"></a>00193     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;tryCompleteDrain: %s\n&quot;</span>, <a class="code" href="classBaseSimpleCPU.html#a827fb3454585cf4c620f4fd341966317">pcState</a>());
<a name="l00194"></a>00194     <span class="keywordflow">if</span> (!<a class="code" href="classAtomicSimpleCPU.html#ac166e5bc3ddf730beb1282cf821096ae">isDrained</a>())
<a name="l00195"></a>00195         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00196"></a>00196 
<a name="l00197"></a>00197     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;CPU done draining, processing drain event\n&quot;</span>);
<a name="l00198"></a>00198     <a class="code" href="classAtomicSimpleCPU.html#af9ba920f669cbe0f18c71846715d690a">drain_manager</a>-&gt;<a class="code" href="classDrainManager.html#ab89d10e368d2e82061eddb9e40022382">signalDrainDone</a>();
<a name="l00199"></a>00199     <a class="code" href="classAtomicSimpleCPU.html#af9ba920f669cbe0f18c71846715d690a">drain_manager</a> = <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>;
<a name="l00200"></a>00200 
<a name="l00201"></a>00201     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00202"></a>00202 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae2e1ccebe596a180f8105d57f9a93645"></a><!-- doxytag: member="AtomicSimpleCPU::verifyMemoryMode" ref="ae2e1ccebe596a180f8105d57f9a93645" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void verifyMemoryMode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00231"></a>00231 {
<a name="l00232"></a>00232     <span class="keywordflow">if</span> (!<a class="code" href="classBaseCPU.html#ab737471139f5a296e5b26e8a0e1b0744" title="initialize section">system</a>-&gt;isAtomicMode()) {
<a name="l00233"></a>00233         <a class="code" href="base_2misc_8hh.html#acad519418dbfdd70c1208711e609c80e">fatal</a>(<span class="stringliteral">&quot;The atomic CPU requires the memory system to be in &quot;</span>
<a name="l00234"></a>00234               <span class="stringliteral">&quot;&apos;atomic&apos; mode.\n&quot;</span>);
<a name="l00235"></a>00235     }
<a name="l00236"></a>00236 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad46c5edeb1ee9b60445f3e26364e2c5e"></a><!-- doxytag: member="AtomicSimpleCPU::writeMem" ref="ad46c5edeb1ee9b60445f3e26364e2c5e" args="(uint8_t *data, unsigned size, Addr addr, unsigned flags, uint64_t *res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRefCountingPtr.html">Fault</a> writeMem </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><div class="fragment"><pre class="fragment"><a name="l00403"></a>00403 {
<a name="l00404"></a>00404 
<a name="l00405"></a>00405     <span class="keyword">static</span> uint8_t zero_array[64] = {};
<a name="l00406"></a>00406 
<a name="l00407"></a>00407     <span class="keywordflow">if</span> (data == <a class="code" href="namespacem5_1_1params.html#a1e2e219ac4e913a2c59019be3094d3ca">NULL</a>) {
<a name="l00408"></a>00408         assert(size &lt;= 64);
<a name="l00409"></a>00409         assert(<a class="code" href="namespacem5_1_1debug.html#a9ceb38153d5c0f156fbeada6dc00ff4f">flags</a> &amp; <a class="code" href="classRequest.html#a4c22f8a3275a06b136b28f633beeee03">Request::CACHE_BLOCK_ZERO</a>);
<a name="l00410"></a>00410         <span class="comment">// This must be a cache block cleaning request</span>
<a name="l00411"></a>00411         data = zero_array;
<a name="l00412"></a>00412     }
<a name="l00413"></a>00413 
<a name="l00414"></a>00414     <span class="comment">// use the CPU&apos;s statically allocated write request and packet objects</span>
<a name="l00415"></a>00415     <a class="code" href="classRequest.html">Request</a> *req = &amp;<a class="code" href="classAtomicSimpleCPU.html#af2cc98a9d486d932d85c4513a4670ca8">data_write_req</a>;
<a name="l00416"></a>00416 
<a name="l00417"></a>00417     <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#acbcf6d90551f8d3a598a70caae74d1ef">traceData</a>) {
<a name="l00418"></a>00418         <a class="code" href="classBaseSimpleCPU.html#acbcf6d90551f8d3a598a70caae74d1ef">traceData</a>-&gt;<a class="code" href="classTrace_1_1InstRecord.html#a0086c298c7423d3f7e571e9f63a1c09f">setAddr</a>(<a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a>);
<a name="l00419"></a>00419     }
<a name="l00420"></a>00420 
<a name="l00421"></a>00421     <span class="comment">//The size of the data we&apos;re trying to read.</span>
<a name="l00422"></a>00422     <span class="keywordtype">int</span> fullSize = size;
<a name="l00423"></a>00423 
<a name="l00424"></a>00424     <span class="comment">//The address of the second part of this access if it needs to be split</span>
<a name="l00425"></a>00425     <span class="comment">//across a cache line boundary.</span>
<a name="l00426"></a>00426     <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> secondAddr = <a class="code" href="intmath_8hh.html#a343c19b0ae885d5f3c7960987096e9d5">roundDown</a>(<a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a> + size - 1, cacheLineSize());
<a name="l00427"></a>00427 
<a name="l00428"></a>00428     <span class="keywordflow">if</span>(secondAddr &gt; <a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a>)
<a name="l00429"></a>00429         size = secondAddr - <a class="code" href="namespaceX86ISA.html#ab705917f60c5566f9ce56a93f798b2e2">addr</a>;
<a name="l00430"></a>00430 
<a name="l00431"></a>00431     <a class="code" href="classAtomicSimpleCPU.html#a08f04a43a6d731e966308aaeece77208">dcache_latency</a> = 0;
<a name="l00432"></a>00432 
<a name="l00433"></a>00433     req-&gt;<a class="code" href="classRequest.html#a7abf15d67b3fbd53236fde58eecb3f34">taskId</a>(taskId());
<a name="l00434"></a>00434     <span class="keywordflow">while</span>(1) {
<a name="l00435"></a>00435         req-&gt;<a class="code" href="classRequest.html#a63cbf386080363fe7c7b364bb2fe3b3e">setVirt</a>(0, addr, size, <a class="code" href="namespacem5_1_1debug.html#a9ceb38153d5c0f156fbeada6dc00ff4f">flags</a>, dataMasterId(), <a class="code" href="classBaseSimpleCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a827fb3454585cf4c620f4fd341966317">pcState</a>().instAddr());
<a name="l00436"></a>00436 
<a name="l00437"></a>00437         <span class="comment">// translate to physical address</span>
<a name="l00438"></a>00438         <a class="code" href="classRefCountingPtr.html">Fault</a> fault = <a class="code" href="classBaseSimpleCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#ad2fd039621f87592c4b344d4f8948e78">dtb</a>-&gt;translateAtomic(req, <a class="code" href="classBaseSimpleCPU.html#a4455a4759e69e5ebe68ae7298cbcc37d">tc</a>, <a class="code" href="classBaseTLB.html#a46c8a310cf4c094f8c80e1cb8dc1f911aa56670174817e3fed92bfd8182d7c0d1">BaseTLB::Write</a>);
<a name="l00439"></a>00439 
<a name="l00440"></a>00440         <span class="comment">// Now do the access.</span>
<a name="l00441"></a>00441         <span class="keywordflow">if</span> (fault == <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>) {
<a name="l00442"></a>00442             <a class="code" href="classMemCmd.html">MemCmd</a> cmd = <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153aa5ec34a7e56b23ff12c9b819519d168a">MemCmd::WriteReq</a>; <span class="comment">// default</span>
<a name="l00443"></a>00443             <span class="keywordtype">bool</span> do_access = <span class="keyword">true</span>;  <span class="comment">// flag to suppress cache access</span>
<a name="l00444"></a>00444 
<a name="l00445"></a>00445             <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#a8965874e960faf91ad4b6af8dbf31875">isLLSC</a>()) {
<a name="l00446"></a>00446                 cmd = <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a10ce12df51611216e2e8c4cb9b5d4047">MemCmd::StoreCondReq</a>;
<a name="l00447"></a>00447                 do_access = <a class="code" href="namespaceAlphaISA.html#a1087208351cf56657581daf8f2f918c8">TheISA::handleLockedWrite</a>(<a class="code" href="classBaseSimpleCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>, req, <a class="code" href="classAtomicSimpleCPU.html#ab6b7665b418b12dc80b485e66d23ed19">dcachePort</a>.<a class="code" href="classAtomicSimpleCPU_1_1AtomicCPUDPort.html#af4264b12b32db39099b579e1ed670312">cacheBlockMask</a>);
<a name="l00448"></a>00448             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#a6ec455c5a36403d3a8319bcfbf356bc1">isSwap</a>()) {
<a name="l00449"></a>00449                 cmd = <a class="code" href="classMemCmd.html#a2afce0a47a93eee73a314d53e4890153a544e456dc06d65a6998a7df182d247d3">MemCmd::SwapReq</a>;
<a name="l00450"></a>00450                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#a086ef1e55d60089d0aa0232ff797eaef">isCondSwap</a>()) {
<a name="l00451"></a>00451                     assert(res);
<a name="l00452"></a>00452                     req-&gt;<a class="code" href="classRequest.html#ac73800a0bae4776befb9d416e95ea6d9">setExtraData</a>(*res);
<a name="l00453"></a>00453                 }
<a name="l00454"></a>00454             }
<a name="l00455"></a>00455 
<a name="l00456"></a>00456             <span class="keywordflow">if</span> (do_access &amp;&amp; !req-&gt;<a class="code" href="classRequest.html#a8552aa8d45c9ba10449d51ac08e7d490">getFlags</a>().<a class="code" href="classFlags.html#ac976964169b81aaba1d4cbb422f559ca">isSet</a>(<a class="code" href="classRequest.html#ab305c2952b5ae966870f325f2bef006c">Request::NO_ACCESS</a>)) {
<a name="l00457"></a>00457                 <a class="code" href="classPacket.html">Packet</a> pkt = <a class="code" href="classPacket.html">Packet</a>(req, cmd);
<a name="l00458"></a>00458                 pkt.<a class="code" href="classPacket.html#a60621b00d6ecd49b3e336087aca2eda0">dataStatic</a>(data);
<a name="l00459"></a>00459 
<a name="l00460"></a>00460                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#aad621c262e009350dd86ad5715c50f7a">isMmappedIpr</a>()) {
<a name="l00461"></a>00461                     <a class="code" href="classAtomicSimpleCPU.html#a08f04a43a6d731e966308aaeece77208">dcache_latency</a> +=
<a name="l00462"></a>00462                         <a class="code" href="namespaceGenericISA.html#a31c83a2af3232333d9a399a2878dc729">TheISA::handleIprWrite</a>(<a class="code" href="classBaseSimpleCPU.html#af9572fa907cd21b54cb14bd626010d39">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a81894d15db5190d5364449a4915b76f5">getTC</a>(), &amp;pkt);
<a name="l00463"></a>00463                 } <span class="keywordflow">else</span> {
<a name="l00464"></a>00464                     <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#a66f9c88f6fa05c882787a7e98a7101f5">fastmem</a> &amp;&amp; <a class="code" href="classBaseCPU.html#ab737471139f5a296e5b26e8a0e1b0744" title="initialize section">system</a>-&gt;isMemAddr(pkt.<a class="code" href="classPacket.html#afca9af4d83a57836baba87603463a6e0">getAddr</a>()))
<a name="l00465"></a>00465                         <a class="code" href="classBaseCPU.html#ab737471139f5a296e5b26e8a0e1b0744" title="initialize section">system</a>-&gt;getPhysMem().access(&amp;pkt);
<a name="l00466"></a>00466                     <span class="keywordflow">else</span>
<a name="l00467"></a>00467                         <a class="code" href="classAtomicSimpleCPU.html#a08f04a43a6d731e966308aaeece77208">dcache_latency</a> += <a class="code" href="classAtomicSimpleCPU.html#ab6b7665b418b12dc80b485e66d23ed19">dcachePort</a>.<a class="code" href="classMasterPort.html#a49fe5ebde5a0349bff76527b969b7643">sendAtomic</a>(&amp;pkt);
<a name="l00468"></a>00468                 }
<a name="l00469"></a>00469                 <a class="code" href="classAtomicSimpleCPU.html#a40a30a05f8e2b8b4c62c0ee0a019686a">dcache_access</a> = <span class="keyword">true</span>;
<a name="l00470"></a>00470                 assert(!pkt.<a class="code" href="classPacket.html#a32759931a1b2d6380407c6a18abd46e3">isError</a>());
<a name="l00471"></a>00471 
<a name="l00472"></a>00472                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#a6ec455c5a36403d3a8319bcfbf356bc1">isSwap</a>()) {
<a name="l00473"></a>00473                     assert(res);
<a name="l00474"></a>00474                     memcpy(res, pkt.<a class="code" href="classPacket.html#a5c451baf3f0a89084e79e69bb9061200">getPtr</a>&lt;uint8_t&gt;(), fullSize);
<a name="l00475"></a>00475                 }
<a name="l00476"></a>00476             }
<a name="l00477"></a>00477 
<a name="l00478"></a>00478             <span class="keywordflow">if</span> (res &amp;&amp; !req-&gt;<a class="code" href="classRequest.html#a6ec455c5a36403d3a8319bcfbf356bc1">isSwap</a>()) {
<a name="l00479"></a>00479                 *res = req-&gt;<a class="code" href="classRequest.html#af848a06a731668855b203d679077623d">getExtraData</a>();
<a name="l00480"></a>00480             }
<a name="l00481"></a>00481         }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483         <span class="comment">//If there&apos;s a fault or we don&apos;t need to access a second cache line,</span>
<a name="l00484"></a>00484         <span class="comment">//stop now.</span>
<a name="l00485"></a>00485         <span class="keywordflow">if</span> (fault != <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a> || secondAddr &lt;= addr)
<a name="l00486"></a>00486         {
<a name="l00487"></a>00487             <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#ae0c9fa9daf2467984aea571a0f3940c6">isLocked</a>() &amp;&amp; fault == <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>) {
<a name="l00488"></a>00488                 assert(<a class="code" href="classAtomicSimpleCPU.html#a18a0f1e6c3d21c252b14ea6ae162e2ff">locked</a>);
<a name="l00489"></a>00489                 <a class="code" href="classAtomicSimpleCPU.html#a18a0f1e6c3d21c252b14ea6ae162e2ff">locked</a> = <span class="keyword">false</span>;
<a name="l00490"></a>00490             }
<a name="l00491"></a>00491             <span class="keywordflow">if</span> (fault != <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a> &amp;&amp; req-&gt;<a class="code" href="classRequest.html#a1eef1bb814a1f77346aba1648fb6d1c9">isPrefetch</a>()) {
<a name="l00492"></a>00492                 <span class="keywordflow">return</span> <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>;
<a name="l00493"></a>00493             } <span class="keywordflow">else</span> {
<a name="l00494"></a>00494                 <span class="keywordflow">return</span> fault;
<a name="l00495"></a>00495             }
<a name="l00496"></a>00496         }
<a name="l00497"></a>00497 
<a name="l00498"></a>00498         <span class="comment">/*</span>
<a name="l00499"></a>00499 <span class="comment">         * Set up for accessing the second cache line.</span>
<a name="l00500"></a>00500 <span class="comment">         */</span>
<a name="l00501"></a>00501 
<a name="l00502"></a>00502         <span class="comment">//Move the pointer we&apos;re reading into to the correct location.</span>
<a name="l00503"></a>00503         data += size;
<a name="l00504"></a>00504         <span class="comment">//Adjust the size to get the remaining bytes.</span>
<a name="l00505"></a>00505         size = addr + fullSize - secondAddr;
<a name="l00506"></a>00506         <span class="comment">//And access the right address.</span>
<a name="l00507"></a>00507         addr = secondAddr;
<a name="l00508"></a>00508     }
<a name="l00509"></a>00509 }
</pre></div></p>

</div>
</div>
<hr/><h2>変数</h2>
<a class="anchor" id="a06bfab070d35f298897393f7ee6e066c"></a><!-- doxytag: member="AtomicSimpleCPU::bbMap" ref="a06bfab070d35f298897393f7ee6e066c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">m5::hash_map&lt;<a class="el" href="classstd_1_1pair.html">BasicBlockRange</a>, <a class="el" href="structAtomicSimpleCPU_1_1BBInfo.html">BBInfo</a>&gt; <a class="el" href="classAtomicSimpleCPU.html#a06bfab070d35f298897393f7ee6e066c">bbMap</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Hash table containing all previously seen basic blocks </p>

</div>
</div>
<a class="anchor" id="aa13454a445c3711abe528bdd288a953c"></a><!-- doxytag: member="AtomicSimpleCPU::currentBBV" ref="aa13454a445c3711abe528bdd288a953c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1pair.html">BasicBlockRange</a> <a class="el" href="classAtomicSimpleCPU.html#aa13454a445c3711abe528bdd288a953c">currentBBV</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Currently executing basic block </p>

</div>
</div>
<a class="anchor" id="a375bb98c835fcacb306ec154ac3c7f85"></a><!-- doxytag: member="AtomicSimpleCPU::currentBBVInstCount" ref="a375bb98c835fcacb306ec154ac3c7f85" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classAtomicSimpleCPU.html#a375bb98c835fcacb306ec154ac3c7f85">currentBBVInstCount</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>inst count in current basic block </p>

</div>
</div>
<a class="anchor" id="a836513db061d14f39d79751c40fa9951"></a><!-- doxytag: member="AtomicSimpleCPU::data_read_req" ref="a836513db061d14f39d79751c40fa9951" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRequest.html">Request</a> <a class="el" href="classAtomicSimpleCPU.html#a836513db061d14f39d79751c40fa9951">data_read_req</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af2cc98a9d486d932d85c4513a4670ca8"></a><!-- doxytag: member="AtomicSimpleCPU::data_write_req" ref="af2cc98a9d486d932d85c4513a4670ca8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRequest.html">Request</a> <a class="el" href="classAtomicSimpleCPU.html#af2cc98a9d486d932d85c4513a4670ca8">data_write_req</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a40a30a05f8e2b8b4c62c0ee0a019686a"></a><!-- doxytag: member="AtomicSimpleCPU::dcache_access" ref="a40a30a05f8e2b8b4c62c0ee0a019686a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAtomicSimpleCPU.html#a40a30a05f8e2b8b4c62c0ee0a019686a">dcache_access</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a08f04a43a6d731e966308aaeece77208"></a><!-- doxytag: member="AtomicSimpleCPU::dcache_latency" ref="a08f04a43a6d731e966308aaeece77208" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> <a class="el" href="classAtomicSimpleCPU.html#a08f04a43a6d731e966308aaeece77208">dcache_latency</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab6b7665b418b12dc80b485e66d23ed19"></a><!-- doxytag: member="AtomicSimpleCPU::dcachePort" ref="ab6b7665b418b12dc80b485e66d23ed19" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAtomicSimpleCPU_1_1AtomicCPUDPort.html">AtomicCPUDPort</a> <a class="el" href="classAtomicSimpleCPU.html#ab6b7665b418b12dc80b485e66d23ed19">dcachePort</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af9ba920f669cbe0f18c71846715d690a"></a><!-- doxytag: member="AtomicSimpleCPU::drain_manager" ref="af9ba920f669cbe0f18c71846715d690a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDrainManager.html">DrainManager</a>* <a class="el" href="classAtomicSimpleCPU.html#af9ba920f669cbe0f18c71846715d690a">drain_manager</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Drain manager to use when signaling drain completion</p>
<p>This pointer is non-NULL when draining and NULL otherwise. </p>

</div>
</div>
<a class="anchor" id="a66f9c88f6fa05c882787a7e98a7101f5"></a><!-- doxytag: member="AtomicSimpleCPU::fastmem" ref="a66f9c88f6fa05c882787a7e98a7101f5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAtomicSimpleCPU.html#a66f9c88f6fa05c882787a7e98a7101f5">fastmem</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a35e511691227100effd63e8a7fc12989"></a><!-- doxytag: member="AtomicSimpleCPU::icachePort" ref="a35e511691227100effd63e8a7fc12989" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAtomicSimpleCPU_1_1AtomicCPUPort.html">AtomicCPUPort</a> <a class="el" href="classAtomicSimpleCPU.html#a35e511691227100effd63e8a7fc12989">icachePort</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a64ba0dde58d6c2c1c5e24a0b3e3b506f"></a><!-- doxytag: member="AtomicSimpleCPU::ifetch_req" ref="a64ba0dde58d6c2c1c5e24a0b3e3b506f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRequest.html">Request</a> <a class="el" href="classAtomicSimpleCPU.html#a64ba0dde58d6c2c1c5e24a0b3e3b506f">ifetch_req</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4ba2ebd08d9a7f8efe072ed006f2ba56"></a><!-- doxytag: member="AtomicSimpleCPU::intervalCount" ref="a4ba2ebd08d9a7f8efe072ed006f2ba56" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classAtomicSimpleCPU.html#a4ba2ebd08d9a7f8efe072ed006f2ba56">intervalCount</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inst count in current basic block </p>

</div>
</div>
<a class="anchor" id="a0c93f234d5028e73f388f7e730db728f"></a><!-- doxytag: member="AtomicSimpleCPU::intervalDrift" ref="a0c93f234d5028e73f388f7e730db728f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classAtomicSimpleCPU.html#a0c93f234d5028e73f388f7e730db728f">intervalDrift</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Excess inst count from previous interval </p>

</div>
</div>
<a class="anchor" id="afa2df438a2925349299948892f519ea2"></a><!-- doxytag: member="AtomicSimpleCPU::intervalSize" ref="afa2df438a2925349299948892f519ea2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t <a class="el" href="classAtomicSimpleCPU.html#afa2df438a2925349299948892f519ea2">intervalSize</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>SimPoint profiling interval size in instructions </p>

</div>
</div>
<a class="anchor" id="a18a0f1e6c3d21c252b14ea6ae162e2ff"></a><!-- doxytag: member="AtomicSimpleCPU::locked" ref="a18a0f1e6c3d21c252b14ea6ae162e2ff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAtomicSimpleCPU.html#a18a0f1e6c3d21c252b14ea6ae162e2ff">locked</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a556c6eb1f8f869ee7d0802381701c49f"></a><!-- doxytag: member="AtomicSimpleCPU::simpoint" ref="a556c6eb1f8f869ee7d0802381701c49f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classAtomicSimpleCPU.html#a556c6eb1f8f869ee7d0802381701c49f">simpoint</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Data structures for SimPoints BBV generation Whether SimPoint BBV profiling is enabled </p>

</div>
</div>
<a class="anchor" id="a77497fabc62f774e824e9b57974e0301"></a><!-- doxytag: member="AtomicSimpleCPU::simpointStream" ref="a77497fabc62f774e824e9b57974e0301" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream* <a class="el" href="classAtomicSimpleCPU.html#a77497fabc62f774e824e9b57974e0301">simpointStream</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer to SimPoint BBV output stream </p>

</div>
</div>
<a class="anchor" id="aab46afe7eb154b233d2ba1886a4b399f"></a><!-- doxytag: member="AtomicSimpleCPU::simulate_data_stalls" ref="aab46afe7eb154b233d2ba1886a4b399f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classAtomicSimpleCPU.html#aab46afe7eb154b233d2ba1886a4b399f">simulate_data_stalls</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac5ff523d495df7133594dec7894aacc7"></a><!-- doxytag: member="AtomicSimpleCPU::simulate_inst_stalls" ref="ac5ff523d495df7133594dec7894aacc7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classAtomicSimpleCPU.html#ac5ff523d495df7133594dec7894aacc7">simulate_inst_stalls</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa36b8e894416f0ec98f701ab08f2ac22"></a><!-- doxytag: member="AtomicSimpleCPU::tickEvent" ref="aa36b8e894416f0ec98f701ab08f2ac22" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAtomicSimpleCPU_1_1TickEvent.html">TickEvent</a> <a class="el" href="classAtomicSimpleCPU.html#aa36b8e894416f0ec98f701ab08f2ac22">tickEvent</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a837aabdd54757cb86d0f66387511753f"></a><!-- doxytag: member="AtomicSimpleCPU::width" ref="a837aabdd54757cb86d0f66387511753f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classAtomicSimpleCPU.html#a837aabdd54757cb86d0f66387511753f">width</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>このクラスの説明は次のファイルから生成されました:<ul>
<li>cpu/simple/<a class="el" href="atomic_8hh_source.html">atomic.hh</a></li>
<li>cpu/simple/<a class="el" href="atomic_8cc.html">atomic.cc</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>File&nbsp;GEM5&nbsp;Wrapperに対して25 May 2015に生成されました。&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
